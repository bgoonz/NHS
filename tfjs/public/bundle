(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
const tf = require('@tensorflow/tfjs')


testing = true

if(testing){
  window.tf = tf
  var s = 10 
  var eye = tf.eye(s).mul(tf.scalar(2))
  eye = eye.matMul(createRollMatrix(s, -1))
  //eye.print()
  //tf.batchNormalization(eye,tf.zerosLike(eye), tf.onesLike(eye).mul(tf.tensor([1]))).print()
  tf.linalg.gramSchmidt(eye).print()
}

async function nextTick(fn){ await tf.nextFrame(); fn()}

function createRollMatrix(s, t){

  return roll(s, t)

  function roll(s, t){ 
    l = s * s
    var one = t > 0 ? rollRightOne(l) : rollLeftOne(Math.abs(l))
    var rm = tf.eye(Math.sqrt(l))
    for(var x = 0; x < Math.abs(t); x++){
       rm = tf.matMul(rm, one)
    }
    return rm
  }

  function rollLeftOne(l){
    var a = new Float32Array(l)
    var n = Math.sqrt(l)
    a.fill(0)
    a.forEach((e,i,a) => (i - n) % (n + 1) === 0 ? a[i] = 1 : a[i] = 0)
    a[n - 1] = 1
    return tf.tensor(a, [n,n], 'float32')
  }

  function rollRightOne(l){
    var a = new Float32Array(l)
    var n = Math.sqrt(l)
    a.fill(0)
    a.forEach((e,i,a) => (i - 1) % (n + 1) === 0 ? a[i] = 1 : a[i] = 0)
    a[l - n] = 1
    return tf.tensor(a, [n,n], 'float32')
  }

}

},{"@tensorflow/tfjs":195}],2:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],3:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],6:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],9:[function(require,module,exports){
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

var $Reader = $protobuf.Reader, $util = $protobuf.util;

var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.tensorflow = (function() {

    var tensorflow = {};

    tensorflow.Any = (function() {

        function Any(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Any.prototype.typeUrl = "";
        Any.prototype.value = $util.newBuffer([]);

        Any.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.Any();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.typeUrl = r.string();
                    break;
                case 2:
                    m.value = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Any;
    })();

    tensorflow.DataType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DT_INVALID"] = 0;
        values[valuesById[1] = "DT_FLOAT"] = 1;
        values[valuesById[2] = "DT_DOUBLE"] = 2;
        values[valuesById[3] = "DT_INT32"] = 3;
        values[valuesById[4] = "DT_UINT8"] = 4;
        values[valuesById[5] = "DT_INT16"] = 5;
        values[valuesById[6] = "DT_INT8"] = 6;
        values[valuesById[7] = "DT_STRING"] = 7;
        values[valuesById[8] = "DT_COMPLEX64"] = 8;
        values[valuesById[9] = "DT_INT64"] = 9;
        values[valuesById[10] = "DT_BOOL"] = 10;
        values[valuesById[11] = "DT_QINT8"] = 11;
        values[valuesById[12] = "DT_QUINT8"] = 12;
        values[valuesById[13] = "DT_QINT32"] = 13;
        values[valuesById[14] = "DT_BFLOAT16"] = 14;
        values[valuesById[101] = "DT_FLOAT_REF"] = 101;
        values[valuesById[102] = "DT_DOUBLE_REF"] = 102;
        values[valuesById[103] = "DT_INT32_REF"] = 103;
        values[valuesById[104] = "DT_UINT8_REF"] = 104;
        values[valuesById[105] = "DT_INT16_REF"] = 105;
        values[valuesById[106] = "DT_INT8_REF"] = 106;
        values[valuesById[107] = "DT_STRING_REF"] = 107;
        values[valuesById[108] = "DT_COMPLEX64_REF"] = 108;
        values[valuesById[109] = "DT_INT64_REF"] = 109;
        values[valuesById[110] = "DT_BOOL_REF"] = 110;
        values[valuesById[111] = "DT_QINT8_REF"] = 111;
        values[valuesById[112] = "DT_QUINT8_REF"] = 112;
        values[valuesById[113] = "DT_QINT32_REF"] = 113;
        values[valuesById[114] = "DT_BFLOAT16_REF"] = 114;
        return values;
    })();

    tensorflow.TensorShape = (function() {

        function TensorShape(p) {
            this.dim = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        TensorShape.prototype.dim = $util.emptyArray;
        TensorShape.prototype.unknownRank = false;

        TensorShape.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorShape();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    if (!(m.dim && m.dim.length))
                        m.dim = [];
                    m.dim.push($root.tensorflow.TensorShape.Dim.decode(r, r.uint32()));
                    break;
                case 3:
                    m.unknownRank = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        TensorShape.Dim = (function() {

            function Dim(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Dim.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            Dim.prototype.name = "";

            Dim.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorShape.Dim();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.size = r.int64();
                        break;
                    case 2:
                        m.name = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Dim;
        })();

        return TensorShape;
    })();

    tensorflow.Tensor = (function() {

        function Tensor(p) {
            this.floatVal = [];
            this.doubleVal = [];
            this.intVal = [];
            this.stringVal = [];
            this.scomplexVal = [];
            this.int64Val = [];
            this.boolVal = [];
            this.uint32Val = [];
            this.uint64Val = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Tensor.prototype.dtype = 0;
        Tensor.prototype.tensorShape = null;
        Tensor.prototype.versionNumber = 0;
        Tensor.prototype.tensorContent = $util.newBuffer([]);
        Tensor.prototype.floatVal = $util.emptyArray;
        Tensor.prototype.doubleVal = $util.emptyArray;
        Tensor.prototype.intVal = $util.emptyArray;
        Tensor.prototype.stringVal = $util.emptyArray;
        Tensor.prototype.scomplexVal = $util.emptyArray;
        Tensor.prototype.int64Val = $util.emptyArray;
        Tensor.prototype.boolVal = $util.emptyArray;
        Tensor.prototype.uint32Val = $util.emptyArray;
        Tensor.prototype.uint64Val = $util.emptyArray;

        Tensor.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.Tensor();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.dtype = r.int32();
                    break;
                case 2:
                    m.tensorShape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                case 3:
                    m.versionNumber = r.int32();
                    break;
                case 4:
                    m.tensorContent = r.bytes();
                    break;
                case 5:
                    if (!(m.floatVal && m.floatVal.length))
                        m.floatVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.floatVal.push(r.float());
                    } else
                        m.floatVal.push(r.float());
                    break;
                case 6:
                    if (!(m.doubleVal && m.doubleVal.length))
                        m.doubleVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.doubleVal.push(r.double());
                    } else
                        m.doubleVal.push(r.double());
                    break;
                case 7:
                    if (!(m.intVal && m.intVal.length))
                        m.intVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.intVal.push(r.int32());
                    } else
                        m.intVal.push(r.int32());
                    break;
                case 8:
                    if (!(m.stringVal && m.stringVal.length))
                        m.stringVal = [];
                    m.stringVal.push(r.bytes());
                    break;
                case 9:
                    if (!(m.scomplexVal && m.scomplexVal.length))
                        m.scomplexVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.scomplexVal.push(r.float());
                    } else
                        m.scomplexVal.push(r.float());
                    break;
                case 10:
                    if (!(m.int64Val && m.int64Val.length))
                        m.int64Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.int64Val.push(r.int64());
                    } else
                        m.int64Val.push(r.int64());
                    break;
                case 11:
                    if (!(m.boolVal && m.boolVal.length))
                        m.boolVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.boolVal.push(r.bool());
                    } else
                        m.boolVal.push(r.bool());
                    break;
                case 16:
                    if (!(m.uint32Val && m.uint32Val.length))
                        m.uint32Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.uint32Val.push(r.uint32());
                    } else
                        m.uint32Val.push(r.uint32());
                    break;
                case 17:
                    if (!(m.uint64Val && m.uint64Val.length))
                        m.uint64Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.uint64Val.push(r.uint64());
                    } else
                        m.uint64Val.push(r.uint64());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Tensor;
    })();

    tensorflow.AttrValue = (function() {

        function AttrValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        AttrValue.prototype.list = null;
        AttrValue.prototype.s = $util.newBuffer([]);
        AttrValue.prototype.i = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        AttrValue.prototype.f = 0;
        AttrValue.prototype.b = false;
        AttrValue.prototype.type = 0;
        AttrValue.prototype.shape = null;
        AttrValue.prototype.tensor = null;
        AttrValue.prototype.placeholder = "";
        AttrValue.prototype.func = null;

        var $oneOfFields;

        Object.defineProperty(AttrValue.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["list", "s", "i", "f", "b", "type", "shape", "tensor", "placeholder", "func"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        AttrValue.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AttrValue();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.list = $root.tensorflow.AttrValue.ListValue.decode(r, r.uint32());
                    break;
                case 2:
                    m.s = r.bytes();
                    break;
                case 3:
                    m.i = r.int64();
                    break;
                case 4:
                    m.f = r.float();
                    break;
                case 5:
                    m.b = r.bool();
                    break;
                case 6:
                    m.type = r.int32();
                    break;
                case 7:
                    m.shape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                case 8:
                    m.tensor = $root.tensorflow.Tensor.decode(r, r.uint32());
                    break;
                case 9:
                    m.placeholder = r.string();
                    break;
                case 10:
                    m.func = $root.tensorflow.NameAttrList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        AttrValue.ListValue = (function() {

            function ListValue(p) {
                this.s = [];
                this.i = [];
                this.f = [];
                this.b = [];
                this.type = [];
                this.shape = [];
                this.tensor = [];
                this.func = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            ListValue.prototype.s = $util.emptyArray;
            ListValue.prototype.i = $util.emptyArray;
            ListValue.prototype.f = $util.emptyArray;
            ListValue.prototype.b = $util.emptyArray;
            ListValue.prototype.type = $util.emptyArray;
            ListValue.prototype.shape = $util.emptyArray;
            ListValue.prototype.tensor = $util.emptyArray;
            ListValue.prototype.func = $util.emptyArray;

            ListValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AttrValue.ListValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 2:
                        if (!(m.s && m.s.length))
                            m.s = [];
                        m.s.push(r.bytes());
                        break;
                    case 3:
                        if (!(m.i && m.i.length))
                            m.i = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.i.push(r.int64());
                        } else
                            m.i.push(r.int64());
                        break;
                    case 4:
                        if (!(m.f && m.f.length))
                            m.f = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.f.push(r.float());
                        } else
                            m.f.push(r.float());
                        break;
                    case 5:
                        if (!(m.b && m.b.length))
                            m.b = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.b.push(r.bool());
                        } else
                            m.b.push(r.bool());
                        break;
                    case 6:
                        if (!(m.type && m.type.length))
                            m.type = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.type.push(r.int32());
                        } else
                            m.type.push(r.int32());
                        break;
                    case 7:
                        if (!(m.shape && m.shape.length))
                            m.shape = [];
                        m.shape.push($root.tensorflow.TensorShape.decode(r, r.uint32()));
                        break;
                    case 8:
                        if (!(m.tensor && m.tensor.length))
                            m.tensor = [];
                        m.tensor.push($root.tensorflow.Tensor.decode(r, r.uint32()));
                        break;
                    case 9:
                        if (!(m.func && m.func.length))
                            m.func = [];
                        m.func.push($root.tensorflow.NameAttrList.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ListValue;
        })();

        return AttrValue;
    })();

    tensorflow.NameAttrList = (function() {

        function NameAttrList(p) {
            this.attr = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        NameAttrList.prototype.name = "";
        NameAttrList.prototype.attr = $util.emptyObject;

        NameAttrList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.NameAttrList(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NameAttrList;
    })();

    tensorflow.NodeDef = (function() {

        function NodeDef(p) {
            this.input = [];
            this.attr = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        NodeDef.prototype.name = "";
        NodeDef.prototype.op = "";
        NodeDef.prototype.input = $util.emptyArray;
        NodeDef.prototype.device = "";
        NodeDef.prototype.attr = $util.emptyObject;

        NodeDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.NodeDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    m.op = r.string();
                    break;
                case 3:
                    if (!(m.input && m.input.length))
                        m.input = [];
                    m.input.push(r.string());
                    break;
                case 4:
                    m.device = r.string();
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NodeDef;
    })();

    tensorflow.VersionDef = (function() {

        function VersionDef(p) {
            this.badConsumers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        VersionDef.prototype.producer = 0;
        VersionDef.prototype.minConsumer = 0;
        VersionDef.prototype.badConsumers = $util.emptyArray;

        VersionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.VersionDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.producer = r.int32();
                    break;
                case 2:
                    m.minConsumer = r.int32();
                    break;
                case 3:
                    if (!(m.badConsumers && m.badConsumers.length))
                        m.badConsumers = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.badConsumers.push(r.int32());
                    } else
                        m.badConsumers.push(r.int32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return VersionDef;
    })();

    tensorflow.GraphDef = (function() {

        function GraphDef(p) {
            this.node = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        GraphDef.prototype.node = $util.emptyArray;
        GraphDef.prototype.versions = null;
        GraphDef.prototype.library = null;

        GraphDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.GraphDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.node && m.node.length))
                        m.node = [];
                    m.node.push($root.tensorflow.NodeDef.decode(r, r.uint32()));
                    break;
                case 4:
                    m.versions = $root.tensorflow.VersionDef.decode(r, r.uint32());
                    break;
                case 2:
                    m.library = $root.tensorflow.FunctionDefLibrary.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GraphDef;
    })();

    tensorflow.CollectionDef = (function() {

        function CollectionDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        CollectionDef.prototype.nodeList = null;
        CollectionDef.prototype.bytesList = null;
        CollectionDef.prototype.int64List = null;
        CollectionDef.prototype.floatList = null;
        CollectionDef.prototype.anyList = null;

        var $oneOfFields;

        Object.defineProperty(CollectionDef.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["nodeList", "bytesList", "int64List", "floatList", "anyList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        CollectionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.nodeList = $root.tensorflow.CollectionDef.NodeList.decode(r, r.uint32());
                    break;
                case 2:
                    m.bytesList = $root.tensorflow.CollectionDef.BytesList.decode(r, r.uint32());
                    break;
                case 3:
                    m.int64List = $root.tensorflow.CollectionDef.Int64List.decode(r, r.uint32());
                    break;
                case 4:
                    m.floatList = $root.tensorflow.CollectionDef.FloatList.decode(r, r.uint32());
                    break;
                case 5:
                    m.anyList = $root.tensorflow.CollectionDef.AnyList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        CollectionDef.NodeList = (function() {

            function NodeList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            NodeList.prototype.value = $util.emptyArray;

            NodeList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.NodeList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push(r.string());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return NodeList;
        })();

        CollectionDef.BytesList = (function() {

            function BytesList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            BytesList.prototype.value = $util.emptyArray;

            BytesList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.BytesList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push(r.bytes());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BytesList;
        })();

        CollectionDef.Int64List = (function() {

            function Int64List(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Int64List.prototype.value = $util.emptyArray;

            Int64List.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.Int64List();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.value.push(r.int64());
                        } else
                            m.value.push(r.int64());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int64List;
        })();

        CollectionDef.FloatList = (function() {

            function FloatList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            FloatList.prototype.value = $util.emptyArray;

            FloatList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.FloatList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.value.push(r.float());
                        } else
                            m.value.push(r.float());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return FloatList;
        })();

        CollectionDef.AnyList = (function() {

            function AnyList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            AnyList.prototype.value = $util.emptyArray;

            AnyList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.AnyList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push($root.tensorflow.Any.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return AnyList;
        })();

        return CollectionDef;
    })();

    tensorflow.SaverDef = (function() {

        function SaverDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SaverDef.prototype.filenameTensorName = "";
        SaverDef.prototype.saveTensorName = "";
        SaverDef.prototype.restoreOpName = "";
        SaverDef.prototype.maxToKeep = 0;
        SaverDef.prototype.sharded = false;
        SaverDef.prototype.keepCheckpointEveryNHours = 0;
        SaverDef.prototype.version = 0;

        SaverDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SaverDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.filenameTensorName = r.string();
                    break;
                case 2:
                    m.saveTensorName = r.string();
                    break;
                case 3:
                    m.restoreOpName = r.string();
                    break;
                case 4:
                    m.maxToKeep = r.int32();
                    break;
                case 5:
                    m.sharded = r.bool();
                    break;
                case 6:
                    m.keepCheckpointEveryNHours = r.float();
                    break;
                case 7:
                    m.version = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        SaverDef.CheckpointFormatVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LEGACY"] = 0;
            values[valuesById[1] = "V1"] = 1;
            values[valuesById[2] = "V2"] = 2;
            return values;
        })();

        return SaverDef;
    })();

    tensorflow.TensorInfo = (function() {

        function TensorInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        TensorInfo.prototype.name = "";
        TensorInfo.prototype.cooSparse = null;
        TensorInfo.prototype.dtype = 0;
        TensorInfo.prototype.tensorShape = null;

        var $oneOfFields;

        Object.defineProperty(TensorInfo.prototype, "encoding", {
            get: $util.oneOfGetter($oneOfFields = ["name", "cooSparse"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        TensorInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 4:
                    m.cooSparse = $root.tensorflow.TensorInfo.CooSparse.decode(r, r.uint32());
                    break;
                case 2:
                    m.dtype = r.int32();
                    break;
                case 3:
                    m.tensorShape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        TensorInfo.CooSparse = (function() {

            function CooSparse(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            CooSparse.prototype.valuesTensorName = "";
            CooSparse.prototype.indicesTensorName = "";
            CooSparse.prototype.denseShapeTensorName = "";

            CooSparse.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorInfo.CooSparse();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.valuesTensorName = r.string();
                        break;
                    case 2:
                        m.indicesTensorName = r.string();
                        break;
                    case 3:
                        m.denseShapeTensorName = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return CooSparse;
        })();

        return TensorInfo;
    })();

    tensorflow.SignatureDef = (function() {

        function SignatureDef(p) {
            this.inputs = {};
            this.outputs = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SignatureDef.prototype.inputs = $util.emptyObject;
        SignatureDef.prototype.outputs = $util.emptyObject;
        SignatureDef.prototype.methodName = "";

        SignatureDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SignatureDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    r.skip().pos++;
                    if (m.inputs === $util.emptyObject)
                        m.inputs = {};
                    k = r.string();
                    r.pos++;
                    m.inputs[k] = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 2:
                    r.skip().pos++;
                    if (m.outputs === $util.emptyObject)
                        m.outputs = {};
                    k = r.string();
                    r.pos++;
                    m.outputs[k] = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 3:
                    m.methodName = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignatureDef;
    })();

    tensorflow.AssetFileDef = (function() {

        function AssetFileDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        AssetFileDef.prototype.tensorInfo = null;
        AssetFileDef.prototype.filename = "";

        AssetFileDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AssetFileDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tensorInfo = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 2:
                    m.filename = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AssetFileDef;
    })();

    tensorflow.OpDef = (function() {

        function OpDef(p) {
            this.inputArg = [];
            this.outputArg = [];
            this.attr = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        OpDef.prototype.name = "";
        OpDef.prototype.inputArg = $util.emptyArray;
        OpDef.prototype.outputArg = $util.emptyArray;
        OpDef.prototype.attr = $util.emptyArray;
        OpDef.prototype.deprecation = null;
        OpDef.prototype.summary = "";
        OpDef.prototype.description = "";
        OpDef.prototype.isCommutative = false;
        OpDef.prototype.isAggregate = false;
        OpDef.prototype.isStateful = false;
        OpDef.prototype.allowsUninitializedInput = false;

        OpDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    if (!(m.inputArg && m.inputArg.length))
                        m.inputArg = [];
                    m.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(r, r.uint32()));
                    break;
                case 3:
                    if (!(m.outputArg && m.outputArg.length))
                        m.outputArg = [];
                    m.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(r, r.uint32()));
                    break;
                case 4:
                    if (!(m.attr && m.attr.length))
                        m.attr = [];
                    m.attr.push($root.tensorflow.OpDef.AttrDef.decode(r, r.uint32()));
                    break;
                case 8:
                    m.deprecation = $root.tensorflow.OpDef.OpDeprecation.decode(r, r.uint32());
                    break;
                case 5:
                    m.summary = r.string();
                    break;
                case 6:
                    m.description = r.string();
                    break;
                case 18:
                    m.isCommutative = r.bool();
                    break;
                case 16:
                    m.isAggregate = r.bool();
                    break;
                case 17:
                    m.isStateful = r.bool();
                    break;
                case 19:
                    m.allowsUninitializedInput = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        OpDef.ArgDef = (function() {

            function ArgDef(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            ArgDef.prototype.name = "";
            ArgDef.prototype.description = "";
            ArgDef.prototype.type = 0;
            ArgDef.prototype.typeAttr = "";
            ArgDef.prototype.numberAttr = "";
            ArgDef.prototype.typeListAttr = "";
            ArgDef.prototype.isRef = false;

            ArgDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.ArgDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.name = r.string();
                        break;
                    case 2:
                        m.description = r.string();
                        break;
                    case 3:
                        m.type = r.int32();
                        break;
                    case 4:
                        m.typeAttr = r.string();
                        break;
                    case 5:
                        m.numberAttr = r.string();
                        break;
                    case 6:
                        m.typeListAttr = r.string();
                        break;
                    case 16:
                        m.isRef = r.bool();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ArgDef;
        })();

        OpDef.AttrDef = (function() {

            function AttrDef(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            AttrDef.prototype.name = "";
            AttrDef.prototype.type = "";
            AttrDef.prototype.defaultValue = null;
            AttrDef.prototype.description = "";
            AttrDef.prototype.hasMinimum = false;
            AttrDef.prototype.minimum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            AttrDef.prototype.allowedValues = null;

            AttrDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.AttrDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.name = r.string();
                        break;
                    case 2:
                        m.type = r.string();
                        break;
                    case 3:
                        m.defaultValue = $root.tensorflow.AttrValue.decode(r, r.uint32());
                        break;
                    case 4:
                        m.description = r.string();
                        break;
                    case 5:
                        m.hasMinimum = r.bool();
                        break;
                    case 6:
                        m.minimum = r.int64();
                        break;
                    case 7:
                        m.allowedValues = $root.tensorflow.AttrValue.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return AttrDef;
        })();

        OpDef.OpDeprecation = (function() {

            function OpDeprecation(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            OpDeprecation.prototype.version = 0;
            OpDeprecation.prototype.explanation = "";

            OpDeprecation.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.OpDeprecation();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.version = r.int32();
                        break;
                    case 2:
                        m.explanation = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return OpDeprecation;
        })();

        return OpDef;
    })();

    tensorflow.OpList = (function() {

        function OpList(p) {
            this.op = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        OpList.prototype.op = $util.emptyArray;

        OpList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.op && m.op.length))
                        m.op = [];
                    m.op.push($root.tensorflow.OpDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return OpList;
    })();

    tensorflow.MetaGraphDef = (function() {

        function MetaGraphDef(p) {
            this.collectionDef = {};
            this.signatureDef = {};
            this.assetFileDef = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        MetaGraphDef.prototype.metaInfoDef = null;
        MetaGraphDef.prototype.graphDef = null;
        MetaGraphDef.prototype.saverDef = null;
        MetaGraphDef.prototype.collectionDef = $util.emptyObject;
        MetaGraphDef.prototype.signatureDef = $util.emptyObject;
        MetaGraphDef.prototype.assetFileDef = $util.emptyArray;

        MetaGraphDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.MetaGraphDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.metaInfoDef = $root.tensorflow.MetaGraphDef.MetaInfoDef.decode(r, r.uint32());
                    break;
                case 2:
                    m.graphDef = $root.tensorflow.GraphDef.decode(r, r.uint32());
                    break;
                case 3:
                    m.saverDef = $root.tensorflow.SaverDef.decode(r, r.uint32());
                    break;
                case 4:
                    r.skip().pos++;
                    if (m.collectionDef === $util.emptyObject)
                        m.collectionDef = {};
                    k = r.string();
                    r.pos++;
                    m.collectionDef[k] = $root.tensorflow.CollectionDef.decode(r, r.uint32());
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.signatureDef === $util.emptyObject)
                        m.signatureDef = {};
                    k = r.string();
                    r.pos++;
                    m.signatureDef[k] = $root.tensorflow.SignatureDef.decode(r, r.uint32());
                    break;
                case 6:
                    if (!(m.assetFileDef && m.assetFileDef.length))
                        m.assetFileDef = [];
                    m.assetFileDef.push($root.tensorflow.AssetFileDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        MetaGraphDef.MetaInfoDef = (function() {

            function MetaInfoDef(p) {
                this.tags = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            MetaInfoDef.prototype.metaGraphVersion = "";
            MetaInfoDef.prototype.strippedOpList = null;
            MetaInfoDef.prototype.anyInfo = null;
            MetaInfoDef.prototype.tags = $util.emptyArray;
            MetaInfoDef.prototype.tensorflowVersion = "";
            MetaInfoDef.prototype.tensorflowGitVersion = "";

            MetaInfoDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.MetaGraphDef.MetaInfoDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.metaGraphVersion = r.string();
                        break;
                    case 2:
                        m.strippedOpList = $root.tensorflow.OpList.decode(r, r.uint32());
                        break;
                    case 3:
                        m.anyInfo = $root.tensorflow.Any.decode(r, r.uint32());
                        break;
                    case 4:
                        if (!(m.tags && m.tags.length))
                            m.tags = [];
                        m.tags.push(r.string());
                        break;
                    case 5:
                        m.tensorflowVersion = r.string();
                        break;
                    case 6:
                        m.tensorflowGitVersion = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return MetaInfoDef;
        })();

        return MetaGraphDef;
    })();

    tensorflow.SavedModel = (function() {

        function SavedModel(p) {
            this.metaGraphs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SavedModel.prototype.savedModelSchemaVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        SavedModel.prototype.metaGraphs = $util.emptyArray;

        SavedModel.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SavedModel();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.savedModelSchemaVersion = r.int64();
                    break;
                case 2:
                    if (!(m.metaGraphs && m.metaGraphs.length))
                        m.metaGraphs = [];
                    m.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SavedModel;
    })();

    tensorflow.FunctionDefLibrary = (function() {

        function FunctionDefLibrary(p) {
            this["function"] = [];
            this.gradient = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        FunctionDefLibrary.prototype["function"] = $util.emptyArray;
        FunctionDefLibrary.prototype.gradient = $util.emptyArray;

        FunctionDefLibrary.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.FunctionDefLibrary();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m["function"] && m["function"].length))
                        m["function"] = [];
                    m["function"].push($root.tensorflow.FunctionDef.decode(r, r.uint32()));
                    break;
                case 2:
                    if (!(m.gradient && m.gradient.length))
                        m.gradient = [];
                    m.gradient.push($root.tensorflow.GradientDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FunctionDefLibrary;
    })();

    tensorflow.FunctionDef = (function() {

        function FunctionDef(p) {
            this.attr = {};
            this.nodeDef = [];
            this.ret = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        FunctionDef.prototype.signature = null;
        FunctionDef.prototype.attr = $util.emptyObject;
        FunctionDef.prototype.nodeDef = $util.emptyArray;
        FunctionDef.prototype.ret = $util.emptyObject;

        FunctionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.FunctionDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.signature = $root.tensorflow.OpDef.decode(r, r.uint32());
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                case 3:
                    if (!(m.nodeDef && m.nodeDef.length))
                        m.nodeDef = [];
                    m.nodeDef.push($root.tensorflow.NodeDef.decode(r, r.uint32()));
                    break;
                case 4:
                    r.skip().pos++;
                    if (m.ret === $util.emptyObject)
                        m.ret = {};
                    k = r.string();
                    r.pos++;
                    m.ret[k] = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FunctionDef;
    })();

    tensorflow.GradientDef = (function() {

        function GradientDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        GradientDef.prototype.functionName = "";
        GradientDef.prototype.gradientFunc = "";

        GradientDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.GradientDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.functionName = r.string();
                    break;
                case 2:
                    m.gradientFunc = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GradientDef;
    })();

    return tensorflow;
})();

module.exports = $root;

},{"protobufjs/minimal":197}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ExecutionContext = (function () {
    function ExecutionContext(weightMap) {
        this.weightMap = weightMap;
        this.rootContext = { id: 0, frameName: '', iterationId: 0 };
        this.contexts = [this.rootContext];
        this.lastId = 0;
        this.generateCurrentContextIds();
    }
    ExecutionContext.prototype.newFrame = function (id, frameName) {
        return { id: id, frameName: frameName, iterationId: 0 };
    };
    Object.defineProperty(ExecutionContext.prototype, "currentContext", {
        get: function () {
            return this.contexts;
        },
        set: function (contexts) {
            if (this.contexts !== contexts) {
                this.contexts = contexts;
                this.generateCurrentContextIds();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExecutionContext.prototype, "currentContextId", {
        get: function () {
            return this._currentContextIds[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExecutionContext.prototype, "currentContextIds", {
        get: function () {
            return this._currentContextIds;
        },
        enumerable: true,
        configurable: true
    });
    ExecutionContext.prototype.generateCurrentContextIds = function () {
        var names = [];
        for (var i = 0; i < this.contexts.length - 1; i++) {
            var contexts = this.contexts.slice(0, this.contexts.length - i);
            names.push(this.contextIdforContexts(contexts));
        }
        names.push('');
        this._currentContextIds = names;
    };
    ExecutionContext.prototype.contextIdforContexts = function (contexts) {
        return contexts ?
            contexts
                .map(function (context) { return (context.id === 0 && context.iterationId === 0) ?
                '' :
                context.frameName + "-" + context.iterationId; })
                .join('/') :
            '';
    };
    ExecutionContext.prototype.enterFrame = function (frameId) {
        if (this.contexts) {
            this.lastId++;
            this.contexts = this.contexts.slice();
            this.contexts.push(this.newFrame(this.lastId, frameId));
            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
        }
    };
    ExecutionContext.prototype.exitFrame = function () {
        if (this.contexts && this.contexts.length > 1) {
            this.contexts = this.contexts.slice();
            this.contexts.splice(-1);
            this.currentContextIds.shift();
        }
        else {
            throw new Error('Cannot exit frame, the context is empty');
        }
    };
    ExecutionContext.prototype.nextIteration = function () {
        if (this.contexts && this.contexts.length > 0) {
            this.contexts = this.contexts.slice();
            this.lastId++;
            var context = Object.assign({}, this.contexts[this.contexts.length - 1]);
            context.iterationId += 1;
            context.id = this.lastId;
            this.contexts.splice(-1, 1, context);
            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
        }
        else {
            throw new Error('Cannot increase frame iteration, the context is empty');
        }
    };
    ExecutionContext.prototype.getWeight = function (name) {
        return this.weightMap[name];
    };
    return ExecutionContext;
}());
exports.ExecutionContext = ExecutionContext;

},{}],11:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var Url = require("url");
var compiled_api_1 = require("../data/compiled_api");
var operation_mapper_1 = require("../operations/operation_mapper");
var graph_executor_1 = require("./graph_executor");
var FrozenModel = (function () {
    function FrozenModel(modelUrl, weightManifestUrl, requestOption) {
        this.modelUrl = modelUrl;
        this.weightManifestUrl = weightManifestUrl;
        this.requestOption = requestOption;
        this.version = 'n/a';
        this.pathPrefix = this.getPathPrefix();
    }
    Object.defineProperty(FrozenModel.prototype, "modelVersion", {
        get: function () {
            return this.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "inputNodes", {
        get: function () {
            return this.executor.inputNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "outputNodes", {
        get: function () {
            return this.executor.outputNodes;
        },
        enumerable: true,
        configurable: true
    });
    FrozenModel.prototype.getPathPrefix = function () {
        var url = Url.parse(this.weightManifestUrl);
        var segments = url.pathname.split('/');
        segments.splice(-1);
        url.pathname = segments.join('/');
        return Url.format(url) + '/';
    };
    FrozenModel.prototype.loadRemoteProtoFile = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, _a, _b, _c, error_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 3, , 4]);
                        return [4, fetch(this.modelUrl, this.requestOption)];
                    case 1:
                        response = _d.sent();
                        _b = (_a = compiled_api_1.tensorflow.GraphDef).decode;
                        _c = Uint8Array.bind;
                        return [4, response.arrayBuffer()];
                    case 2: return [2, _b.apply(_a, [new (_c.apply(Uint8Array, [void 0, _d.sent()]))()])];
                    case 3:
                        error_1 = _d.sent();
                        throw new Error(this.modelUrl + " not found. " + error_1);
                    case 4: return [2];
                }
            });
        });
    };
    FrozenModel.prototype.loadWeightManifest = function () {
        return __awaiter(this, void 0, void 0, function () {
            var manifest, _a, error_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 3, , 4]);
                        return [4, fetch(this.weightManifestUrl, this.requestOption)];
                    case 1:
                        manifest = _b.sent();
                        _a = this;
                        return [4, manifest.clone().json()];
                    case 2:
                        _a.weightManifest = _b.sent();
                        return [3, 4];
                    case 3:
                        error_2 = _b.sent();
                        throw new Error(this.weightManifestUrl + " not found. " + error_2);
                    case 4: return [2];
                }
            });
        });
    };
    FrozenModel.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var graphPromise, manifestPromise, graph, weightMap;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        graphPromise = this.loadRemoteProtoFile();
                        manifestPromise = this.loadWeightManifest();
                        return [4, Promise.all([graphPromise, manifestPromise])];
                    case 1:
                        graph = (_a.sent())[0];
                        this.version = graph.versions.producer + "." + graph.versions.minConsumer;
                        return [4, tfc.io.loadWeights(this.weightManifest, this.pathPrefix, undefined, this.requestOption)];
                    case 2:
                        weightMap = _a.sent();
                        this.executor =
                            new graph_executor_1.GraphExecutor(operation_mapper_1.OperationMapper.Instance.transformGraph(graph));
                        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
                        return [2, true];
                }
            });
        });
    };
    FrozenModel.prototype.predict = function (inputs, config) {
        return this.execute(inputs, this.outputNodes);
    };
    FrozenModel.prototype.constructTensorMap = function (inputs) {
        var inputArray = inputs instanceof tfc.Tensor ? [inputs] : inputs;
        if (inputArray.length !== this.inputNodes.length) {
            throw new Error('Input tensor count mismatch,' +
                ("the frozen model has " + this.inputNodes.length + " placeholders, ") +
                ("while there are " + inputArray.length + " input tensors."));
        }
        return this.inputNodes.reduce(function (map, inputName, i) {
            map[inputName] = inputArray[i];
            return map;
        }, {});
    };
    FrozenModel.prototype.execute = function (inputs, outputs) {
        outputs = outputs || this.outputNodes;
        if (inputs instanceof tfc.Tensor || Array.isArray(inputs)) {
            inputs = this.constructTensorMap(inputs);
        }
        if (this.executor.isControlFlowModel) {
            throw new Error('The model contains control flow ops, ' +
                'please use executeAsync method');
        }
        var result = this.executor.execute(this.convertTensorMapToTensorsMap(inputs), outputs);
        var keys = Object.keys(result);
        return (Array.isArray(outputs) && outputs.length > 1) ?
            outputs.map(function (node) { return result[node]; }) :
            result[keys[0]];
    };
    FrozenModel.prototype.executeAsync = function (inputs, outputs) {
        return __awaiter(this, void 0, void 0, function () {
            var result, keys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.executor.isControlFlowModel) {
                            throw new Error('The model does not contain control flow ops, ' +
                                'please use execute method for better performance.');
                        }
                        outputs = outputs || this.outputNodes;
                        if (inputs instanceof tfc.Tensor || Array.isArray(inputs)) {
                            inputs = this.constructTensorMap(inputs);
                        }
                        return [4, this.executor.executeAsync(this.convertTensorMapToTensorsMap(inputs), outputs)];
                    case 1:
                        result = _a.sent();
                        keys = Object.keys(result);
                        return [2, Array.isArray(outputs) && outputs.length > 1 ?
                                outputs.map(function (node) { return result[node]; }) :
                                result[keys[0]]];
                }
            });
        });
    };
    FrozenModel.prototype.convertTensorMapToTensorsMap = function (map) {
        return Object.keys(map).reduce(function (newMap, key) {
            newMap[key] = [map[key]];
            return newMap;
        }, {});
    };
    FrozenModel.prototype.dispose = function () {
        this.executor.dispose();
    };
    return FrozenModel;
}());
exports.FrozenModel = FrozenModel;
function loadFrozenModel(modelUrl, weightsManifestUrl, requestOption) {
    return __awaiter(this, void 0, void 0, function () {
        var model;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    model = new FrozenModel(modelUrl, weightsManifestUrl, requestOption);
                    return [4, model.load()];
                case 1:
                    _a.sent();
                    return [2, model];
            }
        });
    });
}
exports.loadFrozenModel = loadFrozenModel;

},{"../data/compiled_api":9,"../operations/operation_mapper":42,"./graph_executor":12,"@tensorflow/tfjs-core":51,"url":222}],12:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var utils_1 = require("../operations/executors/utils");
var operation_executor_1 = require("../operations/operation_executor");
var execution_context_1 = require("./execution_context");
var GraphExecutor = (function () {
    function GraphExecutor(graph) {
        this.graph = graph;
        this.compiledOrder = [];
        this._weightMap = {};
        this.placeholders = graph.placeholders.map(function (node) { return node.name; });
        this.outputs = graph.outputs.map(function (node) { return node.name; });
        this.compile();
    }
    Object.defineProperty(GraphExecutor.prototype, "weightMap", {
        get: function () {
            return this._weightMap;
        },
        set: function (weightMap) {
            var weightIds = Object.keys(weightMap).map(function (key) { return weightMap[key].map(function (tensor) { return tensor.id; }); });
            this.weightIds = [].concat.apply([], weightIds);
            this._weightMap = weightMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "inputNodes", {
        get: function () {
            return this.placeholders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "outputNodes", {
        get: function () {
            return this.outputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "isControlFlowModel", {
        get: function () {
            return this.graph.withControlFlow;
        },
        enumerable: true,
        configurable: true
    });
    GraphExecutor.prototype.compile = function () {
        if (this.graph.withControlFlow) {
            return;
        }
        var stack = this.graph.inputs.slice();
        var visited = {};
        while (stack.length > 0) {
            var node = stack.pop();
            visited[node.name] = true;
            this.compiledOrder.push(node);
            node.children.forEach(function (childNode) {
                if (!visited[childNode.name] && childNode.inputNames.every(function (name) {
                    var nodeName = utils_1.getNodeNameAndIndex(name)[0];
                    return visited[nodeName];
                })) {
                    stack.push(childNode);
                }
            });
        }
    };
    GraphExecutor.prototype.execute = function (inputs, outputs) {
        var _this = this;
        this.checkInput(inputs);
        var result = tfjs_core_1.tidy(function () {
            var context = new execution_context_1.ExecutionContext(_this._weightMap);
            var tensors = _this.compiledOrder.reduce(function (map, node) {
                map[node.name] = operation_executor_1.executeOp(node, map, context);
                return map;
            }, __assign({}, _this.weightMap, inputs));
            return _this.findOutputs(tensors, context, outputs);
        });
        return result;
    };
    GraphExecutor.prototype.executeAsync = function (inputs, outputs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var context, tensors, results, outputIds, inputIdArray, inputIds;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        context = new execution_context_1.ExecutionContext(this._weightMap);
                        return [4, this.executeWithControlFlow(inputs, context)];
                    case 1:
                        tensors = _a.sent();
                        results = this.findOutputs(tensors, context, outputs);
                        outputIds = Object.keys(results).map(function (key) { return results[key].id; });
                        inputIdArray = Object.keys(inputs).map(function (key) { return inputs[key].map(function (input) { return input.id; }); });
                        inputIds = [].concat.apply([], inputIdArray);
                        Object.keys(tensors).forEach(function (key) {
                            var tensorArray = tensors[key];
                            tensorArray.forEach(function (tensor) {
                                if (tensor && outputIds.indexOf(tensor.id) === -1 &&
                                    inputIds.indexOf(tensor.id) === -1 &&
                                    _this.weightIds.indexOf(tensor.id) === -1) {
                                    tensor.dispose();
                                }
                            });
                        });
                        return [2, results];
                }
            });
        });
    };
    GraphExecutor.prototype.executeWithControlFlow = function (inputs, context) {
        return __awaiter(this, void 0, void 0, function () {
            var stack, tensorMap, added, item, tensors, nodeName, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        stack = this.graph.inputs.map(function (node) {
                            return { node: node, contexts: context.currentContext };
                        });
                        tensorMap = __assign({}, this.weightMap, inputs);
                        added = {};
                        _c.label = 1;
                    case 1:
                        if (!(stack.length > 0)) return [3, 3];
                        item = stack.pop();
                        context.currentContext = item.contexts;
                        tensors = operation_executor_1.executeOp(item.node, tensorMap, context);
                        nodeName = utils_1.getNodeNameAndIndex(item.node.name, context)[0];
                        _a = tensorMap;
                        _b = nodeName;
                        return [4, tensors];
                    case 2:
                        _a[_b] = _c.sent();
                        item.node.children.forEach(function (childNode) {
                            var nodeName = utils_1.getNodeNameAndIndex(childNode.name, context)[0];
                            if (!added[nodeName]) {
                                if (childNode.op === 'merge') {
                                    if (childNode.inputNames.some(function (name) {
                                        return !!utils_1.getTensor(name, tensorMap, context);
                                    })) {
                                        added[nodeName] = true;
                                        stack.push({ contexts: context.currentContext, node: childNode });
                                    }
                                }
                                else if (childNode.inputNames.every(function (name) {
                                    return !!utils_1.getTensor(name, tensorMap, context);
                                })) {
                                    added[nodeName] = true;
                                    stack.push({ contexts: context.currentContext, node: childNode });
                                }
                            }
                        });
                        return [3, 1];
                    case 3: return [2, tensorMap];
                }
            });
        });
    };
    GraphExecutor.prototype.findOutputs = function (tensorMap, context, outputs) {
        if (outputs && !(outputs instanceof Array)) {
            outputs = [outputs];
        }
        var requestedOutputs = (outputs || this.graph.outputs.map(function (node) { return node.name; }));
        return requestedOutputs.reduce(function (map, name) {
            map[name] = utils_1.getTensor(name, tensorMap, context);
            return map;
        }, {});
    };
    GraphExecutor.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.weightMap)
            .forEach(function (key) { return _this.weightMap[key].forEach(function (tensor) { return tensor.dispose(); }); });
    };
    GraphExecutor.prototype.checkInput = function (inputs) {
        var _this = this;
        var inputKeys = Object.keys(inputs);
        var missing = [];
        var extra = [];
        this.placeholders.forEach(function (name) {
            if (inputKeys.indexOf(name) === -1)
                missing.push(name);
        });
        inputKeys.forEach(function (name) {
            if (_this.placeholders.indexOf(name) === -1)
                extra.push(name);
        });
        if (missing.length > 0) {
            throw new Error("The dict provided in model.execute(dict) has the keys " +
                ("[" + inputKeys + "], but is missing the required keys: [" + missing + "]."));
        }
        if (extra.length > 0) {
            throw new Error("The dict provided in model.execute(dict) has " +
                ("unused keys: [" + extra + "]. Please provide only the following keys: ") +
                ("[" + this.placeholders + "]."));
        }
    };
    return GraphExecutor;
}());
exports.GraphExecutor = GraphExecutor;

},{"../operations/executors/utils":27,"../operations/operation_executor":41,"./execution_context":10,"@tensorflow/tfjs-core":51}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var frozen_model_1 = require("./executor/frozen_model");
exports.FrozenModel = frozen_model_1.FrozenModel;
exports.loadFrozenModel = frozen_model_1.loadFrozenModel;
var version_1 = require("./version");
exports.version_converter = version_1.version;

},{"./executor/frozen_model":11,"./version":43}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'add': {
            return [tfc.add(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'mod':
            return [tfc.mod(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        case 'mul':
            return [tfc.mul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        case 'div': {
            return [tfc.div(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'sub': {
            return [tfc.sub(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'minimum': {
            return [tfc.minimum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'maximum': {
            return [tfc.maximum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'pow': {
            return [tfc.pow(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'squaredDifference': {
            return [tfc.squaredDifference(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'arithmetic';

},{"./utils":27,"@tensorflow/tfjs-core":51}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'abs':
            return [tfc.abs(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'acos':
            return [tfc.acos(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'acosh':
            return [tfc.acosh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'asin':
            return [tfc.asin(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'asinh':
            return [tfc.asinh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'atan':
            return [tfc.atan(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'atanh':
            return [tfc.atanh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'ceil':
            return [tfc.ceil(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'cos':
            return [tfc.cos(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'cosh':
            return [tfc.cosh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'elu':
            return [tfc.elu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'erf':
            return [tfc.erf(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'exp':
            return [tfc.exp(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'expm1': {
            return [tfc.expm1(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'floor':
            return [tfc.floor(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'log':
            return [tfc.log(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'log1p': {
            return [tfc.log1p(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'neg':
            return [tfc.neg(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'reciprocal': {
            return [tfc.reciprocal(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'relu':
            return [tfc.relu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'round': {
            return [tfc.round(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'selu':
            return [tfc.selu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sigmoid':
            return [tfc.sigmoid(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sin':
            return [tfc.sin(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sign': {
            return [tfc.sign(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'sinh': {
            return [tfc.sinh(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'softplus': {
            return [tfc.softplus(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'sqrt': {
            return [tfc.sqrt(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'square': {
            return [tfc.square(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'tanh': {
            return [tfc.tanh(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'tan':
            return [tfc.tan(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'clipByValue':
            return [tfc.clipByValue(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('clipValueMin', node, tensorMap, context), utils_1.getParamValue('clipValueMax', node, tensorMap, context))];
        case 'rsqrt':
            return [tfc.div(tfc.scalar(1.0, 'float32'), tfc.sqrt(utils_1.getTensor(node.inputNames[0], tensorMap, context)))];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'basic_math';

},{"./utils":27,"@tensorflow/tfjs-core":51}],16:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
function executeOp(node, tensorMap, context) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, pred, data_1, inputName, frameId, data, tensor, input;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = node.op;
                    switch (_a) {
                        case 'loopCond': return [3, 1];
                        case 'switch': return [3, 2];
                        case 'merge': return [3, 4];
                        case 'enter': return [3, 5];
                        case 'exit': return [3, 6];
                        case 'nextIteration': return [3, 7];
                    }
                    return [3, 8];
                case 1: return [2, [utils_1.getParamValue('pred', node, tensorMap, context)]];
                case 2:
                    pred = utils_1.getParamValue('pred', node, tensorMap, context);
                    data_1 = utils_1.getParamValue('data', node, tensorMap, context);
                    return [4, pred.data()];
                case 3: return [2, (_b.sent())[0] ? [undefined, data_1] : [data_1, undefined]];
                case 4:
                    inputName = node.inputNames.find(function (name) { return utils_1.getTensor(name, tensorMap, context) !== undefined; });
                    return [2, inputName ? [utils_1.getTensor(inputName, tensorMap, context)] : undefined];
                case 5:
                    frameId = utils_1.getParamValue('frameName', node, tensorMap, context);
                    data = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.enterFrame(frameId);
                    return [2, [data]];
                case 6:
                    tensor = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.exitFrame();
                    return [2, [tensor]];
                case 7:
                    input = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.nextIteration();
                    return [2, [input]];
                case 8: throw TypeError("Node type " + node.op + " is not implemented");
            }
        });
    });
}
exports.executeOp = executeOp;
exports.CATEGORY = 'control';

},{"./utils":27}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'conv1d': {
            var stride = utils_1.getParamValue('stride', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            var dilation = utils_1.getParamValue('dilation', node, tensorMap, context);
            return [tfc.conv1d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];
        }
        case 'conv2d': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);
            return [tfc.conv2d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];
        }
        case 'conv2dTranspose': {
            var shape = utils_1.getParamValue('outputShape', node, tensorMap, context);
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            return [tfc.conv2dTranspose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];
        }
        case 'depthwiseConv2d': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            return [tfc.depthwiseConv2d(utils_1.getParamValue('input', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];
        }
        case 'avgPool': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);
            return [tfc.avgPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
        }
        case 'maxPool': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);
            return [tfc.maxPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'convolution';

},{"./utils":27,"@tensorflow/tfjs-core":51}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'fill': {
            var shape = utils_1.getParamValue('shape', node, tensorMap, context);
            var value = utils_1.getParamValue('value', node, tensorMap, context);
            return [tfc.fill(shape, value)];
        }
        case 'linspace': {
            var start = utils_1.getParamValue('start', node, tensorMap, context);
            var stop_1 = utils_1.getParamValue('stop', node, tensorMap, context);
            var num = utils_1.getParamValue('num', node, tensorMap, context);
            return [tfc.linspace(start, stop_1, num)];
        }
        case 'oneHot': {
            var indices = utils_1.getParamValue('indices', node, tensorMap, context);
            var depth = utils_1.getParamValue('depth', node, tensorMap, context);
            var onValue = utils_1.getParamValue('onValue', node, tensorMap, context);
            var offValue = utils_1.getParamValue('offValue', node, tensorMap, context);
            return [tfc.oneHot(indices, depth, onValue, offValue)];
        }
        case 'ones': {
            return [tfc.ones(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'onesLike': {
            return [tfc.onesLike(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'randomUniform': {
            return [tfc.randomUniform(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('minval', node, tensorMap, context), utils_1.getParamValue('maxval', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'range': {
            var start = utils_1.getParamValue('start', node, tensorMap, context);
            var stop_2 = utils_1.getParamValue('stop', node, tensorMap, context);
            var step = utils_1.getParamValue('step', node, tensorMap, context);
            return [tfc.range(start, stop_2, step, utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'truncatedNormal': {
            var shape = utils_1.getParamValue('shape', node, tensorMap, context);
            var mean = utils_1.getParamValue('mean', node, tensorMap, context);
            var stdDev = utils_1.getParamValue('stdDev', node, tensorMap, context);
            var seed = utils_1.getParamValue('seed', node, tensorMap, context);
            return [tfc.truncatedNormal(shape, mean, stdDev, utils_1.getParamValue('dtype', node, tensorMap, context), seed)];
        }
        case 'zeros': {
            return [tfc.zeros(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'zerosLike': {
            return [tfc.zerosLike(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'creation';

},{"./utils":27,"@tensorflow/tfjs-core":51}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'const': {
            return tensorMap[node.name];
        }
        case 'placeholder':
            var def = utils_1.getParamValue('default', node, tensorMap, context);
            return [utils_1.getTensor(node.name, tensorMap, context) || def];
        case 'identity':
        case 'stopGradient':
        case 'fakeQuantWithMinMaxVars':
            return [utils_1.getParamValue('x', node, tensorMap, context)];
        case 'snapshot':
            var snapshot = utils_1.getParamValue('x', node, tensorMap, context);
            return [snapshot.clone()];
        case 'shape':
            return [tfc.tensor1d(utils_1.getParamValue('x', node, tensorMap, context).shape, 'int32')];
        case 'noop':
            return [];
        case 'print':
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            var data = utils_1.getParamValue('data', node, tensorMap, context);
            var message = utils_1.getParamValue('message', node, tensorMap, context);
            var summarize = utils_1.getParamValue('summarize', node, tensorMap, context);
            console.warn('The graph has a tf.print() operation,' +
                'usually used for debugging, which slows down performance.');
            console.log(message);
            for (var i = 0; i < data.length; i++) {
                console.log(Array.prototype.slice.call(data[0].dataSync()).slice(0, summarize));
            }
            return [input];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'graph';

},{"./utils":27,"@tensorflow/tfjs-core":51}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'resizeBilinear': {
            var images = utils_1.getParamValue('images', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);
            return [tfc.image.resizeBilinear(images, [size[0], size[1]], alignCorners)];
        }
        case 'resizeNearestNeighbor': {
            var images = utils_1.getParamValue('images', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);
            return [tfc.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'image';

},{"./utils":27,"@tensorflow/tfjs-core":51}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'equal': {
            return [tfc.equal(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'notEqual': {
            return [tfc.notEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'greater': {
            return [tfc.greater(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'greaterEqual': {
            return [tfc.greaterEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'less': {
            return [tfc.less(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'lessEqual': {
            return [tfc.lessEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'logicalAnd': {
            return [tfc.logicalAnd(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'logicalNot': {
            return [tfc.logicalNot(utils_1.getParamValue('a', node, tensorMap, context))];
        }
        case 'logicalOr': {
            return [tfc.logicalOr(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'where': {
            return [tfc.where(utils_1.getParamValue('condition', node, tensorMap, context), utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'logical';

},{"./utils":27,"@tensorflow/tfjs-core":51}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'matMul':
            return [tfc.matMul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context), utils_1.getParamValue('transposeA', node, tensorMap, context), utils_1.getParamValue('transposeB', node, tensorMap, context))];
        case 'transpose':
            return [tfc.transpose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('perm', node, tensorMap, context))];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'matrices';

},{"./utils":27,"@tensorflow/tfjs-core":51}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'batchNormalization': {
            return [tfc.batchNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('mean', node, tensorMap, context), utils_1.getParamValue('variance', node, tensorMap, context), utils_1.getParamValue('epsilon', node, tensorMap, context), utils_1.getParamValue('scale', node, tensorMap, context), utils_1.getParamValue('offset', node, tensorMap, context))];
        }
        case 'localResponseNormalization': {
            return [tfc.localResponseNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('radius', node, tensorMap, context), utils_1.getParamValue('bias', node, tensorMap, context), utils_1.getParamValue('alpha', node, tensorMap, context), utils_1.getParamValue('beta', node, tensorMap, context))];
        }
        case 'softmax': {
            return [tfc.softmax(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'normalization';

},{"./utils":27,"@tensorflow/tfjs-core":51}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'max': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.max(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'mean': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.mean(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'min': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.min(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'sum': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.sum(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'argMax': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.argMax(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'argMin': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.argMin(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'reduction';

},{"./utils":27,"@tensorflow/tfjs-core":51}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'concat': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var inputs = utils_1.getParamValue('tensors', node, tensorMap, context);
            return [tfc.concat(inputs, axis)];
        }
        case 'gather': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            var indices = utils_1.getParamValue('indices', node, tensorMap, context);
            return [tfc.gather(input, indices, axis)];
        }
        case 'reverse': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            return [tfc.reverse(input, axis)];
        }
        case 'slice': {
            var begin = utils_1.getParamValue('begin', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            return [tfc.slice(utils_1.getParamValue('x', node, tensorMap, context), begin, size)];
        }
        case 'stridedSlice': {
            var begin = utils_1.getParamValue('begin', node, tensorMap, context);
            var end = utils_1.getParamValue('end', node, tensorMap, context);
            var strides = utils_1.getParamValue('strides', node, tensorMap, context);
            var beginMask = utils_1.getParamValue('beginMask', node, tensorMap, context);
            var endMask = utils_1.getParamValue('endMask', node, tensorMap, context);
            return [tfc.stridedSlice(utils_1.getParamValue('x', node, tensorMap, context), begin, end, strides, beginMask, endMask)];
        }
        case 'stack': {
            return tfc.tidy(function () {
                var axis = utils_1.getParamValue('axis', node, tensorMap, context);
                var tensors = utils_1.getParamValue('tensors', node, tensorMap, context);
                var shape = tensors[0].shape;
                var squeezedShape = tensors[0].squeeze().shape;
                var mapped = tensors.map(function (tensor) {
                    var sameShape = tfc.util.arraysEqual(tensor.shape, shape);
                    if (!sameShape &&
                        !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {
                        throw new Error('the input tensors shape does not match');
                    }
                    return sameShape ? tensor : tensor.reshape(shape);
                });
                return [tfc.stack(mapped, axis)];
            });
        }
        case 'tile': {
            var reps = utils_1.getParamValue('reps', node, tensorMap, context);
            return [tfc.tile(utils_1.getParamValue('x', node, tensorMap, context), reps)];
        }
        case 'split': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var numOrSizeSplits = utils_1.getParamValue('numOrSizeSplits', node, tensorMap, context);
            return tfc.split(utils_1.getParamValue('x', node, tensorMap, context), numOrSizeSplits, axis);
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'slice_join';

},{"./utils":27,"@tensorflow/tfjs-core":51}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'cast': {
            return [tfc.cast(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'expandDims': {
            var axis = node.params['axis'].value;
            return [tfc.expandDims(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'squeeze': {
            var axis = node.params['axis'].value;
            return [tfc.squeeze(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'reshape': {
            return [tfc.reshape(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('shape', node, tensorMap, context))];
        }
        case 'pad': {
            return [tfc.pad(utils_1.getParamValue('x', node, tensorMap, context), utils_1.split(utils_1.getParamValue('padding', node, tensorMap, context), 2), utils_1.getParamValue('constantValue', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'transformation';

},{"./utils":27,"@tensorflow/tfjs-core":51}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getParamValue(paramName, node, tensorMap, context) {
    var param = node.params[paramName];
    if (param && param.inputIndex !== undefined) {
        if (param.type === 'tensor') {
            return getTensor(node.inputNames[param.inputIndex], tensorMap, context);
        }
        if (param.type === 'tensors') {
            var inputs = param.inputIndex === 0 ?
                (param.inputParamLength === 0 ?
                    node.inputNames :
                    node.inputNames.slice(param.inputIndex, -param.inputParamLength)) :
                node.inputNames.splice(param.inputIndex);
            return inputs.map(function (name) { return getTensor(name, tensorMap, context); });
        }
        var data = Array.prototype.slice.call(getTensor(node.inputNames.slice(param.inputIndex)[0], tensorMap, context)
            .dataSync());
        return param.type === 'number' ? data[0] : data;
    }
    return param && param.value;
}
exports.getParamValue = getParamValue;
function getTensor(name, tensorsMap, context) {
    var _a = parseNodeName(name), nodeName = _a[0], index = _a[1];
    var contextId = context.currentContextIds.find(function (contextId) {
        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];
    });
    return contextId !== undefined ?
        tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :
        undefined;
}
exports.getTensor = getTensor;
function getNodeNameAndIndex(inputName, context) {
    var _a = parseNodeName(inputName), nodeName = _a[0], index = _a[1];
    return [
        getNodeNameWithContextId(nodeName, context && context.currentContextId),
        index
    ];
}
exports.getNodeNameAndIndex = getNodeNameAndIndex;
function getNodeNameWithContextId(name, contextId) {
    return !!contextId ? name + "-" + contextId : name;
}
function parseNodeName(name) {
    var index = name.lastIndexOf(':');
    if (index === -1)
        return [name, 0];
    var nodeName = name.substring(0, index);
    return [nodeName, Number(name.substring(index + 1))];
}
exports.parseNodeName = parseNodeName;
function split(arr, size) {
    var res = [];
    for (var i = 0; i < arr.length; i += size) {
        res.push(arr.slice(i, i + size));
    }
    return res;
}
exports.split = split;

},{}],28:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Add",
    "dlOpName": "add",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "BiasAdd",
    "dlOpName": "add",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sub",
    "dlOpName": "sub",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "RealDiv",
    "dlOpName": "div",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Div",
    "dlOpName": "div",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Mul",
    "dlOpName": "mul",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Maximum",
    "dlOpName": "maximum",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Minimum",
    "dlOpName": "minimum",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Pow",
    "dlOpName": "pow",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "SquaredDifference",
    "dlOpName": "squaredDifference",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Mod",
    "dlOpName": "mod",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],29:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Abs",
    "dlOpName": "abs",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Acos",
    "dlOpName": "acos",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Asin",
    "dlOpName": "asin",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "atan",
    "dlOpName": "atan",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Ceil",
    "dlOpName": "ceil",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ClipByValue",
    "dlOpName": "clipByValue",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "clip_value_min",
        "dlParamName": "clipValueMin",
        "type": "number"
      },
      {
        "tfParamName": "clip_value_max",
        "dlParamName": "clipValueMax",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Cos",
    "dlOpName": "cos",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Cosh",
    "dlOpName": "cosh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Elu",
    "dlOpName": "elu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Exp",
    "dlOpName": "exp",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Floor",
    "dlOpName": "floor",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Log",
    "dlOpName": "log",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Neg",
    "dlOpName": "neg",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Relu",
    "dlOpName": "relu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Relu6",
    "dlOpName": "clipByValue",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "dlParamName": "clipValueMin",
        "type": "number",
        "defaultValue": 0
      },
      {
        "dlParamName": "clipValueMax",
        "type": "number",
        "defaultValue": 6
      }
    ]
  },
  {
    "tfOpName": "Selu",
    "dlOpName": "selu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sigmoid",
    "dlOpName": "sigmoid",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sin",
    "dlOpName": "sin",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sinh",
    "dlOpName": "sinh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sqrt",
    "dlOpName": "sqrt",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Rsqrt",
    "dlOpName": "rsqrt",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Square",
    "dlOpName": "square",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tan",
    "dlOpName": "tan",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tanh",
    "dlOpName": "tanh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sign",
    "dlOpName": "sign",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Round",
    "dlOpName": "round",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Expm1",
    "dlOpName": "expm1",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Log1p",
    "dlOpName": "log1p",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reciprocal",
    "dlOpName": "reciprocal",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reciprocal",
    "dlOpName": "reciprocal",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Softplus",
    "dlOpName": "softplus",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Asinh",
    "dlOpName": "asinh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Acosh",
    "dlOpName": "acosh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Atanh",
    "dlOpName": "atanh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Erf",
    "dlOpName": "erf",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],30:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "LoopCond",
    "dlOpName": "loopCond",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "pred",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Switch",
    "dlOpName": "switch",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "data",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "pred",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Merge",
    "dlOpName": "merge",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "tfInputParamLength": 0,
        "dlParamName": "tensors",
        "type": "tensors"
      }
    ]
  },
  {
    "tfOpName": "Enter",
    "dlOpName": "enter",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "frame_name",
        "dlParamName": "frameName",
        "type": "string"
      },
      {
        "tfParamName": "is_constant",
        "dlParamName": "isConstant",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Exit",
    "dlOpName": "exit",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "NextIteration",
    "dlOpName": "nextIteration",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],31:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "AvgPool",
    "dlOpName": "avgPool",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfParamName": "ksize",
        "dlParamName": "kernelSize",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "MaxPool",
    "dlOpName": "maxPool",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfParamName": "ksize",
        "dlParamName": "kernelSize",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Conv1D",
    "dlOpName": "conv1d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "stride",
        "dlParamName": "stride",
        "type": "number"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NWC"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "dilation",
        "dlParamName": "dilation",
        "type": "number",
        "defaultValue": 1
      }
    ]
  },
  {
    "tfOpName": "Conv2D",
    "dlOpName": "conv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "useCudnnOnGpu",
        "dlParamName": "useCudnnOnGpu",
        "type": "bool"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Conv2DBackpropInput",
    "dlOpName": "conv2dTranspose",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 2,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfInputIndex": 0,
        "dlParamName": "outputShape",
        "type": "number[]"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2d",
    "dlOpName": "depthwiseConv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "input",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2dNative",
    "dlOpName": "depthwiseConv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "input",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  }
]

},{}],32:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Fill",
    "dlOpName": "fill",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "value",
        "type": "number"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LinSpace",
    "dlOpName": "linspace",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "start",
        "type": "number"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "stop",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "num",
        "type": "number"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "OneHot",
    "dlOpName": "oneHot",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "depth",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "onValue",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "offValue",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "notSupported": true
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Ones",
    "dlOpName": "ones",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "OnesLike",
    "dlOpName": "onesLike",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "RandomUniform",
    "dlOpName": "randomUniform",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "minval",
        "dlParamName": "minval",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "maxval",
        "dlParamName": "maxval",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      },
      {
        "tfParamName": "seed",
        "dlParamName": "seed",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "seed2",
        "dlParamName": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfParamName": "T",
        "dlParamName": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Range",
    "dlOpName": "range",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "start",
        "type": "number"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "stop",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "step",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "Tidx",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "truncatedNormal",
    "dlOpName": "truncatedNormal",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "means",
        "dlParamName": "mean",
        "type": "number",
        "defaultValue": 0.0
      },
      {
        "tfParamName": "stddev",
        "dlParamName": "stdDev",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "seed",
        "dlParamName": "seed",
        "type": "number"
      },
      {
        "tfParamName": "seed2",
        "dlParamName": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      },
      {
        "tfParamName": "T",
        "dlParamName": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Zeros",
    "dlOpName": "zeros",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "ZerosLike",
    "dlOpName": "zerosLike",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  }
]

},{}],33:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "PlaceholderWithDefault",
    "dlOpName": "placeholder",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "default",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Placeholder",
    "dlOpName": "placeholder",
    "category": "graph"
  },
  {
    "tfOpName": "Const",
    "dlOpName": "const",
    "category": "graph"
  },
  {
    "tfOpName": "Identity",
    "dlOpName": "identity",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Snapshot",
    "dlOpName": "snapshot",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Shape",
    "dlOpName": "shape",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Print",
    "dlOpName": "print",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "tfInputParamLength": 1,
        "dlParamName": "data",
        "type": "tensors"
      },
      {
        "tfParamName": "message",
        "dlParamName": "message",
        "type": "string"
      },
      {
        "tfParamName": "first_n",
        "dlParamName": "firstN",
        "type": "number",
        "notSupprted": true
      },
      {
        "tfParamName": "summarize",
        "dlParamName": "summarize",
        "type": "number",
        "defaultValue": 3
      }
    ]
  },
  {
    "tfOpName": "NoOp",
    "dlOpName": "noop",
    "category": "graph",
    "params": []
  },
  {
    "tfOpName": "StopGradient",
    "dlOpName": "stopGradient",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "FakeQuantWithMinMaxVars",
    "dlOpName": "fakeQuantWithMinMaxVars",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "min",
        "dlParamName": "min",
        "type": "number"
      },
      {
        "tfParamName": "max",
        "dlParamName": "max",
        "type": "number"
      }
    ]
  }
]

},{}],34:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "ResizeBilinear",
    "dlOpName": "resizeBilinear",
    "category": "image",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "images",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "size",
        "type": "number[]"
      },
      {
        "tfParamName": "align_corners",
        "dlParamName": "alignCorners",
        "type": "bool"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ResizeNearestNeighbor",
    "dlOpName": "resizeNearestNeighbor",
    "category": "image",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "images",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "size",
        "type": "number[]"
      },
      {
        "tfParamName": "align_corners",
        "dlParamName": "alignCorners",
        "type": "bool"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],35:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Equal",
    "dlOpName": "equal",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "NotEqual",
    "dlOpName": "notEqual",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Greater",
    "dlOpName": "greater",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "GreaterEqual",
    "dlOpName": "greaterEqual",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Less",
    "dlOpName": "less",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LessEqual",
    "dlOpName": "lessEqual",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalAnd",
    "dlOpName": "logicalAnd",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalNot",
    "dlOpName": "logicalNot",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalOr",
    "dlOpName": "logicalOr",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Select",
    "dlOpName": "where",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "condition",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],36:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "MatMul",
    "dlOpName": "matMul",
    "category": "matrices",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "transpose_a",
        "dlParamName": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfParamName": "transpose_b",
        "dlParamName": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Transpose",
    "dlOpName": "transpose",
    "category": "matrices",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "perm",
        "dlParamName": "perm",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],37:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "FusedBatchNorm",
    "dlOpName": "batchNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "scale",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "offset",
        "type": "tensor"
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "mean",
        "type": "tensor"
      },
      {
        "tfInputIndex": 4,
        "dlParamName": "variance",
        "type": "tensor"
      },
      {
        "tfParamName": "epsilon",
        "dlParamName": "epsilon",
        "type": "number",
        "defaultValue": 0.001
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FusedBatchNormV2",
    "dlOpName": "batchNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "scale",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "offset",
        "type": "tensor"
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "mean",
        "type": "tensor"
      },
      {
        "tfInputIndex": 4,
        "dlParamName": "variance",
        "type": "tensor"
      },
      {
        "tfParamName": "epsilon",
        "dlParamName": "epsilon",
        "type": "number",
        "defaultValue": 0.001
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LRN",
    "dlOpName": "localResponseNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "depth_radius",
        "dlParamName": "radius",
        "type": "number",
        "defaultValue": 5
      },
      {
        "tfParamName": "bias",
        "dlParamName": "bias",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "alpha",
        "dlParamName": "alpha",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "beta",
        "dlParamName": "beta",
        "type": "number",
        "defaultValue": 0.5
      }
    ]
  },  {
    "tfOpName": "Softmax",
    "dlOpName": "softmax",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  }
]

},{}],38:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Max",
    "dlOpName": "max",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Mean",
    "dlOpName": "mean",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Min",
    "dlOpName": "min",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Sum",
    "dlOpName": "sum",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "ArgMax",
    "dlOpName": "argMax",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "ArgMin",
    "dlOpName": "argMin",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  }
]

},{}],39:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "ConcatV2",
    "dlOpName": "concat",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "tfInputParamLength": 1,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfInputIndex": -1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Concat",
    "dlOpName": "concat",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 1,
        "tfInputParamLength": 1,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfInputIndex": 0,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "GatherV2",
    "dlOpName": "gather",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Gather",
    "dlOpName": "gather",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "validate_indices",
        "dlParamName": "validateIndices",
        "type": "bool",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reverse",
    "dlOpName": "reverse",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "ReverseV2",
    "dlOpName": "reverse",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Slice",
    "dlOpName": "slice",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "begin",
        "type": "number[]"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "size",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "StridedSlice",
    "dlOpName": "stridedSlice",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "begin",
        "type": "number[]"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "end",
        "type": "number[]"
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "begin_mask",
        "dlParamName": "beginMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "end_mask",
        "dlParamName": "endMask",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Pack",
    "dlOpName": "stack",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "tfInputParamLength": 0,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Tile",
    "dlOpName": "tile",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "reps",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Split",
    "dlOpName": "split",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "num_split",
        "dlParamName": "numOrSizeSplits",
        "type": "number",
        "defaultValue": 1
      }
    ]
  }
]

},{}],40:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Cast",
    "dlOpName": "cast",
    "category": "transformation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "SrcT",
        "dlParamName": "sdtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "DstT",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "ExpandDims",
    "dlOpName": "expandDims",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "tfParamNameDeprecated": "dim",
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Pad",
    "dlOpName": "pad",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "padding",
        "type": "number[]"
      },
      {
        "tfParamName": "constant_value",
        "dlParamName": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "PadV2",
    "dlOpName": "pad",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "padding",
        "type": "number[]"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Reshape",
    "dlOpName": "reshape",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "shape",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Squeeze",
    "dlOpName": "squeeze",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "tfParamNameDeprecated": "squeeze_dims",
        "dlParamName": "axis",
        "type": "number[]"
      }
    ]
  }
]

},{}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var arithmetic = require("./executors/arithmetic_executor");
var basicMath = require("./executors/basic_math_executor");
var control = require("./executors/control_executor");
var convolution = require("./executors/convolution_executor");
var creation = require("./executors/creation_executor");
var graph = require("./executors/graph_executor");
var image = require("./executors/image_executor");
var logical = require("./executors/logical_executor");
var matrices = require("./executors/matrices_executor");
var normalization = require("./executors/normalization_executor");
var reduction = require("./executors/reduction_executor");
var sliceJoin = require("./executors/slice_join_executor");
var transformation = require("./executors/transformation_executor");
function executeOp(node, tensorMap, context) {
    switch (node.category) {
        case 'arithmetic':
            return arithmetic.executeOp(node, tensorMap, context);
        case 'basic_math':
            return basicMath.executeOp(node, tensorMap, context);
        case 'control':
            return control.executeOp(node, tensorMap, context);
        case 'convolution':
            return convolution.executeOp(node, tensorMap, context);
        case 'creation':
            return creation.executeOp(node, tensorMap, context);
        case 'image':
            return image.executeOp(node, tensorMap, context);
        case 'graph':
            return graph.executeOp(node, tensorMap, context);
        case 'logical':
            return logical.executeOp(node, tensorMap, context);
        case 'matrices':
            return matrices.executeOp(node, tensorMap, context);
        case 'normalization':
            return normalization.executeOp(node, tensorMap, context);
        case 'reduction':
            return reduction.executeOp(node, tensorMap, context);
        case 'slice_join':
            return sliceJoin.executeOp(node, tensorMap, context);
        case 'transformation':
            return transformation.executeOp(node, tensorMap, context);
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
}
exports.executeOp = executeOp;

},{"./executors/arithmetic_executor":14,"./executors/basic_math_executor":15,"./executors/control_executor":16,"./executors/convolution_executor":17,"./executors/creation_executor":18,"./executors/graph_executor":19,"./executors/image_executor":20,"./executors/logical_executor":21,"./executors/matrices_executor":22,"./executors/normalization_executor":23,"./executors/reduction_executor":24,"./executors/slice_join_executor":25,"./executors/transformation_executor":26}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var compiled_api_1 = require("../data/compiled_api");
var utils_1 = require("./executors/utils");
var arithmetic = require("./op_list/arithmetic.json");
var basicMath = require("./op_list/basic_math.json");
var control = require("./op_list/control.json");
var convolution = require("./op_list/convolution.json");
var creation = require("./op_list/creation.json");
var graph = require("./op_list/graph.json");
var image = require("./op_list/image.json");
var logical = require("./op_list/logical.json");
var matrices = require("./op_list/matrices.json");
var normalization = require("./op_list/normalization.json");
var reduction = require("./op_list/reduction.json");
var sliceJoin = require("./op_list/slice_join.json");
var transformation = require("./op_list/transformation.json");
var CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration'];
var OperationMapper = (function () {
    function OperationMapper() {
        var ops = [
            arithmetic, basicMath, control, convolution, creation, logical, image,
            graph, matrices, normalization, reduction, sliceJoin, transformation
        ];
        var mappersJson = [].concat.apply([], ops.map(function (op) { return op.default ? op.default : op; }));
        this.opMappers = mappersJson.reduce(function (map, mapper) {
            map[mapper.tfOpName] = mapper;
            return map;
        }, {});
    }
    Object.defineProperty(OperationMapper, "Instance", {
        get: function () {
            return this._instance || (this._instance = new this());
        },
        enumerable: true,
        configurable: true
    });
    OperationMapper.prototype.isControlFlow = function (node) {
        return CONTROL_FLOW_OPS.some(function (op) { return op === node.op; });
    };
    OperationMapper.prototype.transformGraph = function (graph) {
        var _this = this;
        var tfNodes = graph.node;
        var withControlFlow = false;
        var placeholders = [];
        var nodes = tfNodes.reduce(function (map, node) {
            map[node.name] = _this.mapNode(node);
            if (_this.isControlFlow(node))
                withControlFlow = true;
            if (node.op === 'Placeholder')
                placeholders.push(map[node.name]);
            return map;
        }, {});
        var inputs = [];
        var outputs = [];
        Object.keys(nodes).forEach(function (key) {
            var node = nodes[key];
            node.inputNames.forEach(function (name) {
                var nodeName = utils_1.getNodeNameAndIndex(name)[0];
                node.inputs.push(nodes[nodeName]);
                nodes[nodeName].children.push(node);
            });
            if (node.inputs.length === 0)
                inputs.push(node);
        });
        Object.keys(nodes).forEach(function (key) {
            var node = nodes[key];
            if (node.children.length === 0)
                outputs.push(node);
        });
        return { nodes: nodes, inputs: inputs, outputs: outputs, placeholders: placeholders, withControlFlow: withControlFlow };
    };
    OperationMapper.prototype.mapNode = function (node) {
        var _this = this;
        var mapper = this.opMappers[node.op];
        if (mapper === undefined) {
            throw new Error('Tensorflow Op is not supported: ' + node.op);
        }
        var newNode = {
            name: node.name,
            op: mapper.dlOpName,
            category: mapper.category,
            inputNames: (node.input ||
                []).map(function (input) { return input.startsWith('^') ? input.substr(1) : input; }),
            inputs: [],
            children: [],
            params: {}
        };
        if (!!mapper.params) {
            newNode.params = mapper.params.reduce(function (map, param) {
                var inputIndex = param.tfInputIndex;
                var inputParamLength = param.tfInputParamLength;
                var type = param.type;
                var value = undefined;
                if (inputIndex === undefined) {
                    switch (param.type) {
                        case 'string':
                            value = _this.getStringParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getStringParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'number':
                            value = _this.getNumberParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getNumberParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'number[]':
                            value = _this.getNumericArrayParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getNumericArrayParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'bool':
                            value = _this.getBoolParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getBoolParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'shape':
                            value = _this.getTensorShapeParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getTensorShapeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'dtype':
                            value = _this.getDtypeParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getDtypeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'tensor':
                        case 'tensors':
                            break;
                        default:
                            throw new Error("Unsupported param type: " + param.type + " for op: " + node.op);
                    }
                }
                map[param.dlParamName] = { value: value, inputIndex: inputIndex, type: type, inputParamLength: inputParamLength };
                return map;
            }, {});
        }
        return newNode;
    };
    OperationMapper.prototype.getStringParam = function (attrs, name, def, keepCase) {
        if (keepCase === void 0) { keepCase = false; }
        var param = attrs[name];
        if (param !== undefined) {
            var value = String.fromCharCode.apply(null, param.s);
            return keepCase ? value : value.toLowerCase();
        }
        return def;
    };
    OperationMapper.prototype.getBoolParam = function (attrs, name, def) {
        var param = attrs[name];
        return param ? param.b : def;
    };
    OperationMapper.prototype.getNumberParam = function (attrs, name, def) {
        var param = attrs[name];
        var value = (param ? ((param.f !== undefined) ? param.f : param.i) : def);
        return (typeof value === 'number') ? value : value['toInt']();
    };
    OperationMapper.prototype.getDtypeParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param && param.type) {
            switch (param.type) {
                case compiled_api_1.tensorflow.DataType.DT_FLOAT:
                    return 'float32';
                case compiled_api_1.tensorflow.DataType.DT_INT32:
                    return 'int32';
                case compiled_api_1.tensorflow.DataType.DT_BOOL:
                    return 'bool';
                default:
                    return def;
            }
        }
        return def;
    };
    OperationMapper.prototype.getTensorShapeParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param && param.shape) {
            return param.shape.dim.map(function (dim) { return dim.size; });
        }
        return def;
    };
    OperationMapper.prototype.getNumericArrayParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param) {
            return ((param.list.f && param.list.f.length ? param.list.f :
                param.list.i))
                .map(function (v) { return (typeof v === 'number') ? v : v['toInt'](); });
        }
        return def;
    };
    return OperationMapper;
}());
exports.OperationMapper = OperationMapper;

},{"../data/compiled_api":9,"./executors/utils":27,"./op_list/arithmetic.json":28,"./op_list/basic_math.json":29,"./op_list/control.json":30,"./op_list/convolution.json":31,"./op_list/creation.json":32,"./op_list/graph.json":33,"./op_list/image.json":34,"./op_list/logical.json":35,"./op_list/matrices.json":36,"./op_list/normalization.json":37,"./op_list/reduction.json":38,"./op_list/slice_join.json":39,"./op_list/transformation.json":40}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.4.1';
exports.version = version;

},{}],44:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var BrowserUtil = (function () {
    function BrowserUtil() {
    }
    BrowserUtil.nextFrame = function () {
        return new Promise(function (resolve) { return requestAnimationFrame(function () { return resolve(); }); });
    };
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Timing' })
    ], BrowserUtil, "nextFrame", null);
    return BrowserUtil;
}());
exports.BrowserUtil = BrowserUtil;

},{"./doc":46}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;

},{}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function doc(info) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
}
exports.doc = doc;

},{}],47:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var globals_1 = require("./globals");
var ops = require("./ops/ops");
var profiler_1 = require("./profiler");
var tape_1 = require("./tape");
var tensor_1 = require("./tensor");
var util = require("./util");
var Engine = (function () {
    function Engine(backend, safeMode) {
        this.backend = backend;
        this.safeMode = safeMode;
        this.registeredVariables = {};
        this.refCounter = new WeakMap();
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numDataBuffers = 0;
        this.gradientScopeCount = 0;
        this.customGradientDepth = 0;
        this.keepTensors = new Set();
        this.activeScope = { track: [] };
        this.scopeStack = [this.activeScope];
        this.profiler = new profiler_1.Profiler(backend);
    }
    Engine.prototype.runKernel = function (forwardFunc, inputs, backwardsFunc) {
        var _this = this;
        var result;
        var saved = [];
        var saveFunc = function (x) {
            saved.push(x);
            return x;
        };
        var scopeName = this.activeScope.name;
        this.customGradientDepth++;
        if (!environment_1.ENV.get('DEBUG')) {
            result = forwardFunc(this.backend, saveFunc);
        }
        else {
            result = this.profiler.profileKernel(scopeName, function () { return forwardFunc(_this.backend, saveFunc); });
        }
        this.customGradientDepth--;
        if (this.shouldRecord()) {
            var tapeNode = {
                id: this.nextTapeNodeId++,
                name: scopeName,
                inputs: inputs,
                output: result,
            };
            if (backwardsFunc != null) {
                tapeNode.gradient = function (dy) { return backwardsFunc(dy, saved); };
            }
            this.activeTape.push(tapeNode);
        }
        return result;
    };
    Engine.prototype.registerTensor = function (a) {
        var refCount = this.refCounter.has(a.dataId) ? this.refCounter.get(a.dataId) : 0;
        this.numTensors++;
        if (refCount === 0) {
            this.numDataBuffers++;
            this.numBytes +=
                util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
            this.backend.register(a.dataId, a.shape, a.dtype);
        }
        this.refCounter.set(a.dataId, refCount + 1);
        if (!(a instanceof tensor_1.Variable)) {
            this.track(a);
        }
    };
    Engine.prototype.registerVariable = function (v) {
        if (this.registeredVariables[v.name] != null) {
            throw new Error("Variable with name " + v.name + " was already registered");
        }
        this.registeredVariables[v.name] = v;
    };
    Engine.prototype.disposeTensor = function (a) {
        if (!this.refCounter.has(a.dataId)) {
            return;
        }
        this.numTensors--;
        var refCount = this.refCounter.get(a.dataId);
        if (refCount <= 1) {
            this.refCounter.delete(a.dataId);
            this.backend.disposeData(a.dataId);
            this.numDataBuffers--;
            this.numBytes -=
                util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
        }
        else {
            this.refCounter.set(a.dataId, refCount - 1);
        }
    };
    Engine.prototype.disposeVariables = function () {
        for (var varName in this.registeredVariables) {
            var v = this.registeredVariables[varName];
            this.disposeTensor(v);
            delete this.registeredVariables[varName];
        }
    };
    Engine.prototype.memory = function () {
        var info = this.backend.memory();
        info.numTensors = this.numTensors;
        info.numDataBuffers = this.numDataBuffers;
        info.numBytes = this.numBytes;
        return info;
    };
    Engine.prototype.shouldRecord = function () {
        return this.activeTape != null && this.customGradientDepth === 0;
    };
    Engine.prototype.addTapeNode = function (inputs, result, gradientsFunc) {
        var inputsMap = {};
        inputs.forEach(function (input, idx) {
            inputsMap[idx] = input;
        });
        var gradient = function (dy) {
            var res = gradientsFunc(dy);
            var resMap = {};
            res.forEach(function (r, idx) {
                resMap[idx] = function () { return r; };
            });
            return resMap;
        };
        var tapeNode = {
            id: this.nextTapeNodeId++,
            name: this.activeScope.name,
            inputs: inputsMap,
            output: result,
            gradient: gradient
        };
        this.activeTape.push(tapeNode);
    };
    Engine.prototype.keep = function (result) {
        if (this.scopeStack.length === 1 && environment_1.ENV.engine.safeMode) {
            throw new Error('Safe mode is ON. Enclose all tensor operations inside tf.tidy(): ' +
                'tf.tidy(() => {...}) to avoid memory leaks.');
        }
        this.keepTensors.add(result.id);
        return result;
    };
    Engine.prototype.startScope = function (name, gradientsMode) {
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (gradientsMode && this.gradientScopeCount === 0) {
            this.activeTape = [];
        }
        if (gradientsMode) {
            this.gradientScopeCount++;
        }
        var scopeInfo = { track: [] };
        if (name) {
            scopeInfo.name = name;
        }
        this.scopeStack.push(scopeInfo);
        this.activeScope = scopeInfo;
    };
    Engine.prototype.endScope = function (result, gradientsMode) {
        var _this = this;
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (gradientsMode) {
            this.gradientScopeCount--;
            if (this.gradientScopeCount === 0) {
                this.activeTape = null;
            }
        }
        var tensorsToKeep = new Set(this.keepTensors);
        var tensorsToTrackInParent = util.getTensorsInContainer(result);
        tensorsToTrackInParent.forEach(function (tensor) { return tensorsToKeep.add(tensor.id); });
        for (var i = 0; i < this.activeScope.track.length; i++) {
            var tensor = this.activeScope.track[i];
            if (tensorsToKeep.has(tensor.id)) {
                continue;
            }
            if (this.activeTape != null) {
                tensorsToTrackInParent.push(tensor);
            }
            else {
                tensor.dispose();
            }
        }
        var oldScope = this.scopeStack.pop();
        this.activeScope = this.scopeStack.length === 0 ?
            { track: [] } :
            this.scopeStack[this.scopeStack.length - 1];
        tensorsToTrackInParent.forEach(function (tensor) {
            if (!_this.keepTensors.has(tensor.id) &&
                util.isTensorInList(tensor, oldScope.track)) {
                _this.track(tensor);
            }
        });
    };
    Engine.prototype.gradients = function (f, xs, dy, allowNoGradients) {
        var _this = this;
        if (allowNoGradients === void 0) { allowNoGradients = false; }
        util.assert(xs.length > 0, 'gradients() received an empty list of xs.');
        return globals_1.tidy('gradients', function () {
            var y = f();
            util.assert(y instanceof tensor_1.Tensor, 'The result y returned by f() must be a tensor.');
            var filteredTape = tape_1.getFilteredNodesXToY(_this.activeTape, xs, y);
            if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
                throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' +
                    'that the f you passed encloses all operations that lead from x ' +
                    'to y.');
            }
            var accumulatedGradientMap = {};
            accumulatedGradientMap[y.id] = (dy == null) ? ops.ones(y.shape) : dy;
            tape_1.backpropagateGradients(accumulatedGradientMap, filteredTape);
            var grads = xs.map(function (x) { return accumulatedGradientMap[x.id]; });
            return { value: y, grads: grads };
        }, true);
    };
    Engine.prototype.customGrad = function (f) {
        var _this = this;
        util.assert(util.isFunction(f), 'The f passed in customGrad(f) must be a function.');
        return function () {
            var inputs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                inputs[_i] = arguments[_i];
            }
            util.assert(inputs.every(function (t) { return t instanceof tensor_1.Tensor; }), 'The args passed in customGrad(f)(x1, x2,...) must all be tensors');
            _this.customGradientDepth++;
            var gradientsFunc;
            var gradientsMode = true;
            var result = globals_1.tidy(f.name, function () {
                var _a = f.apply(void 0, inputs), value = _a.value, gradFunc = _a.gradFunc;
                util.assert(value instanceof tensor_1.Tensor, 'The function f passed in customGrad(f) must return an object ' +
                    'where `obj.value` is a tensor');
                util.assert(util.isFunction(gradFunc), 'The function f passed in customGrad(f) must return an object ' +
                    'where `obj.gradFunc` is a function.');
                gradientsFunc = gradFunc;
                return value;
            }, gradientsMode);
            _this.customGradientDepth--;
            if (_this.shouldRecord()) {
                var gradFunc = function (dy) {
                    var res = gradientsFunc(dy);
                    var grads = Array.isArray(res) ? res : [res];
                    util.assert(grads.length === inputs.length, 'The function f passed in customGrad(f) must return an object ' +
                        'where `obj.gradFunc` is a function that returns the same ' +
                        'number of tensors as inputs passed to f(...).');
                    util.assert(grads.every(function (t) { return t instanceof tensor_1.Tensor; }), 'The function f passed in customGrad(f) must return an object ' +
                        'where `obj.gradFunc` is a function that returns a list of ' +
                        'only tensors.');
                    return grads;
                };
                _this.addTapeNode(inputs, result, gradFunc);
            }
            return result;
        };
    };
    Engine.prototype.write = function (dataId, values) {
        this.backend.write(dataId, values);
    };
    Engine.prototype.readSync = function (dataId) {
        return this.backend.readSync(dataId);
    };
    Engine.prototype.read = function (dataId) {
        return this.backend.read(dataId);
    };
    Engine.prototype.fromPixels = function (pixels, numChannels) {
        return this.backend.fromPixels(pixels, numChannels);
    };
    Engine.prototype.time = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var start, timingInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = performance.now();
                        return [4, this.backend.time(query)];
                    case 1:
                        timingInfo = _a.sent();
                        timingInfo.wallMs = performance.now() - start;
                        return [2, timingInfo];
                }
            });
        });
    };
    Engine.prototype.track = function (result) {
        if (this.scopeStack.length === 1 && this.safeMode) {
            throw new Error('Safe mode is ON. Enclose all tensor operations inside tf.tidy(): ' +
                'tf.tidy(() => {op();...}); to avoid memory leaks.');
        }
        this.activeScope.track.push(result);
        return result;
    };
    return Engine;
}());
exports.Engine = Engine;

},{"./environment":48,"./globals":49,"./ops/ops":124,"./profiler":146,"./tape":148,"./tensor":149,"./util":155}],48:[function(require,module,exports){
(function (process,global){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var device_util = require("./device_util");
var doc_1 = require("./doc");
var engine_1 = require("./engine");
var util = require("./util");
var Type;
(function (Type) {
    Type[Type["NUMBER"] = 0] = "NUMBER";
    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
    Type[Type["STRING"] = 2] = "STRING";
})(Type = exports.Type || (exports.Type = {}));
exports.URL_PROPERTIES = [
    { name: 'DEBUG', type: Type.BOOLEAN }, { name: 'IS_BROWSER', type: Type.BOOLEAN },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },
    { name: 'WEBGL_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN }, {
        name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',
        type: Type.BOOLEAN
    },
    { name: 'BACKEND', type: Type.STRING }
];
function hasExtension(gl, extensionName) {
    var ext = gl.getExtension(extensionName);
    return ext != null;
}
function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion === 0 || !exports.ENV.get('IS_BROWSER')) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    var tempCanvas = document.createElement('canvas');
    if (webGLVersion === 1) {
        return (tempCanvas.getContext('webgl') ||
            tempCanvas.getContext('experimental-webgl'));
    }
    return tempCanvas.getContext('webgl2');
}
function loseContext(gl) {
    if (gl != null) {
        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
        if (loseContextExtension == null) {
            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
        }
        loseContextExtension.loseContext();
    }
}
function isWebGLVersionEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    if (gl != null) {
        loseContext(gl);
        return true;
    }
    return false;
}
function getWebGLDisjointQueryTimerVersion(webGLVersion) {
    if (webGLVersion === 0) {
        return 0;
    }
    var queryTimerVersion;
    var gl = getWebGLRenderingContext(webGLVersion);
    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&
        webGLVersion === 2) {
        queryTimerVersion = 2;
    }
    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {
        queryTimerVersion = 1;
    }
    else {
        queryTimerVersion = 0;
    }
    if (gl != null) {
        loseContext(gl);
    }
    return queryTimerVersion;
}
function isFloatTextureReadPixelsEnabled(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    if (webGLVersion === 1) {
        if (!hasExtension(gl, 'OES_texture_float')) {
            return false;
        }
    }
    else {
        if (!hasExtension(gl, 'EXT_color_buffer_float')) {
            return false;
        }
    }
    var frameBuffer = gl.createFramebuffer();
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
    loseContext(gl);
    return frameBufferComplete && readPixelsNoError;
}
function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
    if (webGLVersion > 0) {
        return false;
    }
    if (webGLVersion !== 2) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    var isEnabled = hasExtension(gl, 'WEBGL_get_buffer_sub_data_async');
    loseContext(gl);
    return isEnabled;
}
var Environment = (function () {
    function Environment(features) {
        this.features = {};
        this.registry = {};
        if (features != null) {
            this.features = features;
        }
        if (this.get('DEBUG')) {
            console.warn('Debugging mode is ON. The output of every math call will ' +
                'be downloaded to CPU and checked for NaNs. ' +
                'This significantly impacts performance.');
        }
    }
    Environment.setBackend = function (backendType, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        if (!(backendType in exports.ENV.registry)) {
            throw new Error("Backend type '" + backendType + "' not found in registry");
        }
        exports.ENV.initBackend(backendType, safeMode);
    };
    Environment.getBackend = function () {
        exports.ENV.initDefaultBackend();
        return exports.ENV.currentBackend;
    };
    Environment.disposeVariables = function () {
        exports.ENV.engine.disposeVariables();
    };
    Environment.memory = function () {
        return exports.ENV.engine.memory();
    };
    Environment.prototype.get = function (feature) {
        if (feature in this.features) {
            return this.features[feature];
        }
        this.features[feature] = this.evaluateFeature(feature);
        return this.features[feature];
    };
    Environment.prototype.set = function (feature, value) {
        this.features[feature] = value;
    };
    Environment.prototype.getBestBackendType = function () {
        var _this = this;
        if (Object.keys(this.registry).length === 0) {
            throw new Error('No backend found in registry.');
        }
        var sortedBackends = Object.keys(this.registry)
            .map(function (name) {
            return { name: name, entry: _this.registry[name] };
        })
            .sort(function (a, b) {
            return b.entry.priority - a.entry.priority;
        });
        return sortedBackends[0].name;
    };
    Environment.prototype.evaluateFeature = function (feature) {
        if (feature === 'DEBUG') {
            return false;
        }
        else if (feature === 'IS_BROWSER') {
            return typeof window !== 'undefined';
        }
        else if (feature === 'IS_NODE') {
            return (typeof process !== 'undefined') &&
                (typeof process.versions.node !== 'undefined');
        }
        else if (feature === 'BACKEND') {
            return this.getBestBackendType();
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') {
            var webGLVersion = this.get('WEBGL_VERSION');
            if (webGLVersion === 0) {
                return 0;
            }
            return getWebGLDisjointQueryTimerVersion(webGLVersion);
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&
                !device_util.isMobile();
        }
        else if (feature === 'WEBGL_VERSION') {
            if (isWebGLVersionEnabled(2)) {
                return 2;
            }
            else if (isWebGLVersionEnabled(1)) {
                return 1;
            }
            return 0;
        }
        else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {
            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));
        }
        else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {
            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));
        }
        throw new Error("Unknown feature " + feature + ".");
    };
    Environment.prototype.setFeatures = function (features) {
        this.features = features;
    };
    Environment.prototype.reset = function () {
        this.features = getFeaturesFromURL();
        if (this.globalEngine != null) {
            this.globalEngine = null;
        }
    };
    Environment.prototype.initBackend = function (backendType, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        this.currentBackend = backendType;
        var backend = exports.ENV.findBackend(backendType);
        this.globalEngine = new engine_1.Engine(backend, safeMode);
    };
    Environment.prototype.findBackend = function (name) {
        if (!(name in this.registry)) {
            return null;
        }
        return this.registry[name].backend;
    };
    Environment.prototype.registerBackend = function (name, factory, priority) {
        if (priority === void 0) { priority = 1; }
        if (name in this.registry) {
            console.warn(name + " backend was already registered");
        }
        try {
            var backend = factory();
            this.registry[name] = { backend: backend, priority: priority };
            return true;
        }
        catch (err) {
            console.warn("Registration of backend " + name + " failed");
            console.warn(err.stack || err.message);
            return false;
        }
    };
    Environment.prototype.removeBackend = function (name) {
        if (!(name in this.registry)) {
            throw new Error(name + " backend not found in registry");
        }
        this.registry[name].backend.dispose();
        delete this.registry[name];
    };
    Object.defineProperty(Environment.prototype, "engine", {
        get: function () {
            this.initDefaultBackend();
            return this.globalEngine;
        },
        enumerable: true,
        configurable: true
    });
    Environment.prototype.initDefaultBackend = function () {
        if (this.globalEngine == null) {
            this.initBackend(exports.ENV.get('BACKEND'), false);
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Environment' })
    ], Environment, "setBackend", null);
    __decorate([
        doc_1.doc({ heading: 'Environment' })
    ], Environment, "getBackend", null);
    __decorate([
        doc_1.doc({ heading: 'Environment' })
    ], Environment, "disposeVariables", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Environment, "memory", null);
    return Environment;
}());
exports.Environment = Environment;
var TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';
function getFeaturesFromURL() {
    var features = {};
    if (typeof window === 'undefined' || typeof window.location === 'undefined') {
        return features;
    }
    var urlParams = util.getQueryParams(window.location.search);
    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
        var urlFlags_1 = {};
        var keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');
        keyValues.forEach(function (keyValue) {
            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
            urlFlags_1[key] = value;
        });
        exports.URL_PROPERTIES.forEach(function (urlProperty) {
            if (urlProperty.name in urlFlags_1) {
                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                    ("" + urlFlags_1[urlProperty.name]));
                if (urlProperty.type === Type.NUMBER) {
                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                }
                else if (urlProperty.type === Type.BOOLEAN) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                }
                else if (urlProperty.type === Type.STRING) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name];
                }
                else {
                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                }
            }
        });
    }
    return features;
}
function getGlobalNamespace() {
    var ns;
    if (typeof (window) !== 'undefined') {
        ns = window;
    }
    else if (typeof (global) !== 'undefined') {
        ns = global;
    }
    else {
        throw new Error('Could not find a global object');
    }
    return ns;
}
function getOrMakeEnvironment() {
    var ns = getGlobalNamespace();
    ns.ENV = ns.ENV || new Environment(getFeaturesFromURL());
    return ns.ENV;
}
exports.ENV = getOrMakeEnvironment();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./device_util":45,"./doc":46,"./engine":47,"./util":155,"_process":217}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gradients_1 = require("./gradients");
var tracking_1 = require("./tracking");
exports.tidy = tracking_1.Tracking.tidy;
exports.keep = tracking_1.Tracking.keep;
exports.dispose = tracking_1.Tracking.dispose;
exports.time = tracking_1.Tracking.time;
exports.grad = gradients_1.Gradients.grad;
exports.valueAndGrad = gradients_1.Gradients.valueAndGrad;
exports.grads = gradients_1.Gradients.grads;
exports.valueAndGrads = gradients_1.Gradients.valueAndGrads;
exports.variableGrads = gradients_1.Gradients.variableGrads;
exports.customGrad = gradients_1.Gradients.customGrad;

},{"./gradients":50,"./tracking":152}],50:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var globals_1 = require("./globals");
var tensor_1 = require("./tensor");
var util = require("./util");
var Gradients = (function () {
    function Gradients() {
    }
    Gradients.gradScope = function (nameOrScopeFn, scopeFn) {
        return globals_1.tidy(nameOrScopeFn, scopeFn, true);
    };
    Gradients.grad = function (f) {
        util.assert(util.isFunction(f), 'The f passed in grad(f) must be a function');
        return function (x, dy) {
            util.assert(x instanceof tensor_1.Tensor, 'The x passed in grad(f)(x) must be a tensor');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in grad(f)(x, dy) must be a tensor');
            return globals_1.tidy(function () {
                var _a = environment_1.ENV.engine.gradients(function () { return f(x); }, [x], dy), value = _a.value, grads = _a.grads;
                if (dy != null) {
                    util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grad(f)(x, dy) must match the shape ' +
                        'returned by f(x)');
                }
                checkGrads(grads);
                return grads[0];
            });
        };
    };
    Gradients.grads = function (f) {
        util.assert(util.isFunction(f), 'The f passed in grads(f) must be a function');
        return function (args, dy) {
            util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof tensor_1.Tensor; }), 'The args passed in grads(f)(args) must be an array of tensors');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in grads(f)(args, dy) must be a tensor');
            return globals_1.tidy(function () {
                var _a = environment_1.ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy), value = _a.value, grads = _a.grads;
                if (dy != null) {
                    util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grads(f)([x1,...], dy) must ' +
                        'match the shape returned by f([x1,...])');
                }
                checkGrads(grads);
                return grads;
            });
        };
    };
    Gradients.valueAndGrad = function (f) {
        util.assert(util.isFunction(f), 'The f passed in valueAndGrad(f) must be a function');
        return function (x, dy) {
            util.assert(x instanceof tensor_1.Tensor, 'The x passed in valueAndGrad(f)(x) must be a tensor');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in valueAndGrad(f)(x, dy) must be a tensor');
            var _a = environment_1.ENV.engine.gradients(function () { return f(x); }, [x], dy), grads = _a.grads, value = _a.value;
            checkGrads(grads);
            return { grad: grads[0], value: value };
        };
    };
    Gradients.valueAndGrads = function (f) {
        util.assert(util.isFunction(f), 'The f passed in valueAndGrads(f) must be a function');
        return function (args, dy) {
            util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof tensor_1.Tensor; }), 'The args passed in valueAndGrads(f)(args) must be array of tensors');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in valueAndGrads(f)(args, dy) must be a tensor');
            var res = environment_1.ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy);
            if (dy != null) {
                util.assertShapesMatch(res.value.shape, dy.shape, 'The shape of dy passed in valueAndGrads(f)([x1,...], dy) must ' +
                    'match the shape returned by f([x1,...])');
            }
            checkGrads(res.grads);
            return res;
        };
    };
    Gradients.variableGrads = function (f, varList) {
        util.assert(util.isFunction(f), 'The f passed in variableGrads(f) must be a function');
        util.assert(varList == null ||
            Array.isArray(varList) && varList.every(function (v) { return v instanceof tensor_1.Variable; }), 'The varList passed in variableGrads(f, varList) must be an array ' +
            'of variables');
        if (varList == null) {
            varList = [];
            for (var varName in environment_1.ENV.engine.registeredVariables) {
                varList.push(environment_1.ENV.engine.registeredVariables[varName]);
            }
        }
        var originalVarCount = varList.length;
        varList = varList.filter(function (variable) { return variable.trainable; });
        util.assert(varList.length > 0, "variableGrads() expects at least one of the input variables to be " +
            ("trainable, but none of the " + originalVarCount + " variables is ") +
            "trainable.");
        var allowNoGradients = true;
        var _a = environment_1.ENV.engine.gradients(f, varList, null, allowNoGradients), value = _a.value, grads = _a.grads;
        util.assert(grads.some(function (g) { return g != null; }), 'Cannot find a connection between any variable and the result of the ' +
            'loss function y=f(x). Please make sure the operations that use ' +
            'variables are inside the function f passed to minimize().');
        util.assert(value.rank === 0, "The f passed in variableGrads(f) must return a scalar, but it " +
            ("returned a rank-" + value.rank + " tensor"));
        var namedGrads = {};
        varList.forEach(function (v, i) {
            if (grads[i] != null) {
                namedGrads[v.name] = grads[i];
            }
        });
        return { value: value, grads: namedGrads };
    };
    Gradients.customGrad = function (f) {
        return environment_1.ENV.engine.customGrad(f);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "grad", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "grads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "valueAndGrad", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "valueAndGrads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "variableGrads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "customGrad", null);
    return Gradients;
}());
exports.Gradients = Gradients;
function checkGrads(grads) {
    var numNullGradients = grads.filter(function (g) { return g == null; }).length;
    if (numNullGradients > 0) {
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
    }
}

},{"./doc":46,"./environment":48,"./globals":49,"./tensor":149,"./util":155}],51:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
require("./kernels/backend_webgl");
require("./kernels/backend_cpu");
var browser_util_1 = require("./browser_util");
var environment = require("./environment");
exports.environment = environment;
var environment_1 = require("./environment");
var io = require("./io/io");
exports.io = io;
var serialization = require("./serialization");
exports.serialization = serialization;
var test_util = require("./test_util");
exports.test_util = test_util;
var util = require("./util");
exports.util = util;
var version_1 = require("./version");
exports.version_core = version_1.version;
var webgl = require("./webgl");
exports.webgl = webgl;
var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
var adam_optimizer_1 = require("./optimizers/adam_optimizer");
exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
var optimizer_1 = require("./optimizers/optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
var tensor_1 = require("./tensor");
exports.Tensor = tensor_1.Tensor;
exports.TensorBuffer = tensor_1.TensorBuffer;
exports.variable = tensor_1.variable;
exports.Variable = tensor_1.Variable;
var types_1 = require("./types");
exports.Rank = types_1.Rank;
__export(require("./ops/ops"));
var loss_ops_1 = require("./ops/loss_ops");
exports.Reduction = loss_ops_1.Reduction;
__export(require("./train"));
__export(require("./globals"));
var environment_2 = require("./environment");
exports.ENV = environment_2.ENV;
exports.Environment = environment_2.Environment;
exports.setBackend = environment_1.Environment.setBackend;
exports.getBackend = environment_1.Environment.getBackend;
exports.disposeVariables = environment_1.Environment.disposeVariables;
exports.memory = environment_1.Environment.memory;
var doc_1 = require("./doc");
exports.doc = doc_1.doc;
exports.nextFrame = browser_util_1.BrowserUtil.nextFrame;

},{"./browser_util":44,"./doc":46,"./environment":48,"./globals":49,"./io/io":55,"./kernels/backend_cpu":62,"./kernels/backend_webgl":64,"./ops/loss_ops":117,"./ops/ops":124,"./optimizers/adadelta_optimizer":137,"./optimizers/adagrad_optimizer":138,"./optimizers/adam_optimizer":139,"./optimizers/adamax_optimizer":140,"./optimizers/momentum_optimizer":141,"./optimizers/optimizer":142,"./optimizers/rmsprop_optimizer":144,"./optimizers/sgd_optimizer":145,"./serialization":147,"./tensor":149,"./test_util":151,"./train":153,"./types":154,"./util":155,"./version":156,"./webgl":157}],52:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var io_utils_1 = require("./io_utils");
var router_registry_1 = require("./router_registry");
var DEFAULT_FILE_NAME_PREFIX = 'model';
var DEFAULT_JSON_EXTENSION_NAME = '.json';
var DEFAULT_WEIGHT_DATA_EXTENSION_NAME = '.weights.bin';
var BrowserDownloads = (function () {
    function BrowserDownloads(fileNamePrefix) {
        if (!environment_1.ENV.get('IS_BROWSER')) {
            throw new Error('triggerDownloads() cannot proceed because the current environment ' +
                'is not a browser.');
        }
        if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
            fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
        }
        if (fileNamePrefix == null || fileNamePrefix.length === 0) {
            fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
        }
        this.modelTopologyFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
        this.weightDataFileName =
            fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
    }
    BrowserDownloads.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var weightsURL, weightsManifest, modelTopologyAndWeightManifest, modelTopologyAndWeightManifestURL, jsonAnchor, weightDataAnchor;
            return __generator(this, function (_a) {
                weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: 'application/octet-stream' }));
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('DownloadTrigger.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                else {
                    weightsManifest = [{
                            paths: ['./' + this.weightDataFileName],
                            weights: modelArtifacts.weightSpecs
                        }];
                    modelTopologyAndWeightManifest = {
                        modelTopology: modelArtifacts.modelTopology,
                        weightsManifest: weightsManifest
                    };
                    modelTopologyAndWeightManifestURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: 'application/json' }));
                    jsonAnchor = this.jsonAnchor == null ? document.createElement('a') :
                        this.jsonAnchor;
                    jsonAnchor.download = this.modelTopologyFileName;
                    jsonAnchor.href = modelTopologyAndWeightManifestURL;
                    jsonAnchor.click();
                    if (modelArtifacts.weightData != null) {
                        weightDataAnchor = this.weightDataAnchor == null ?
                            document.createElement('a') :
                            this.weightDataAnchor;
                        weightDataAnchor.download = this.weightDataFileName;
                        weightDataAnchor.href = weightsURL;
                        weightDataAnchor.click();
                    }
                    return [2, { modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts) }];
                }
                return [2];
            });
        });
    };
    BrowserDownloads.URL_SCHEME = 'downloads://';
    return BrowserDownloads;
}());
exports.BrowserDownloads = BrowserDownloads;
var BrowserFiles = (function () {
    function BrowserFiles(files) {
        if (files == null || files.length < 1) {
            throw new Error("When calling browserFiles, at least 1 file is required, " +
                ("but received " + files));
        }
        this.files = files;
    }
    BrowserFiles.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var jsonFile, weightFiles;
            return __generator(this, function (_a) {
                jsonFile = this.files[0];
                weightFiles = this.files.slice(1);
                return [2, new Promise(function (resolve, reject) {
                        var jsonReader = new FileReader();
                        jsonReader.onload = function (event) {
                            var modelJSON = JSON.parse(event.target.result);
                            var modelTopology = modelJSON.modelTopology;
                            if (modelTopology == null) {
                                reject(new Error("modelTopology field is missing from file " + jsonFile.name));
                                return;
                            }
                            if (weightFiles.length === 0) {
                                resolve({ modelTopology: modelTopology });
                            }
                            var weightsManifest = modelJSON.weightsManifest;
                            if (weightsManifest == null) {
                                reject(new Error("weightManifest field is missing from file " + jsonFile.name));
                                return;
                            }
                            var pathToFile;
                            try {
                                pathToFile =
                                    _this.checkManifestAndWeightFiles(weightsManifest, weightFiles);
                            }
                            catch (err) {
                                reject(err);
                                return;
                            }
                            var weightSpecs = [];
                            var paths = [];
                            var perFileBuffers = [];
                            weightsManifest.forEach(function (weightsGroup) {
                                weightsGroup.paths.forEach(function (path) {
                                    paths.push(path);
                                    perFileBuffers.push(null);
                                });
                                weightSpecs.push.apply(weightSpecs, weightsGroup.weights);
                            });
                            weightsManifest.forEach(function (weightsGroup) {
                                weightsGroup.paths.forEach(function (path) {
                                    var weightFileReader = new FileReader();
                                    weightFileReader.onload = function (event) {
                                        var weightData = event.target.result;
                                        var index = paths.indexOf(path);
                                        perFileBuffers[index] = weightData;
                                        if (perFileBuffers.indexOf(null) === -1) {
                                            resolve({
                                                modelTopology: modelTopology,
                                                weightSpecs: weightSpecs,
                                                weightData: io_utils_1.concatenateArrayBuffers(perFileBuffers),
                                            });
                                        }
                                    };
                                    weightFileReader.onerror = function (error) {
                                        reject("Failed to weights data from file of path '" + path + "'.");
                                        return;
                                    };
                                    weightFileReader.readAsArrayBuffer(pathToFile[path]);
                                });
                            });
                        };
                        jsonReader.onerror = function (error) {
                            reject("Failed to read model topology and weights manifest JSON " +
                                ("from file '" + jsonFile.name + "'. BrowserFiles supports loading ") +
                                "Keras-style tf.Model artifacts only.");
                            return;
                        };
                        jsonReader.readAsText(jsonFile);
                    })];
            });
        });
    };
    BrowserFiles.prototype.checkManifestAndWeightFiles = function (manifest, files) {
        var basenames = [];
        var fileNames = files.map(function (file) { return io_utils_1.basename(file.name); });
        var pathToFile = {};
        for (var _i = 0, manifest_1 = manifest; _i < manifest_1.length; _i++) {
            var group = manifest_1[_i];
            group.paths.forEach(function (path) {
                var pathBasename = io_utils_1.basename(path);
                if (basenames.indexOf(pathBasename) !== -1) {
                    throw new Error("Duplicate file basename found in weights manifest: " +
                        ("'" + pathBasename + "'"));
                }
                basenames.push(pathBasename);
                if (fileNames.indexOf(pathBasename) === -1) {
                    throw new Error("Weight file with basename '" + pathBasename + "' is not provided.");
                }
                else {
                    pathToFile[path] = files[fileNames.indexOf(pathBasename)];
                }
            });
        }
        if (basenames.length !== files.length) {
            throw new Error("Mismatch in the number of files in weights manifest " +
                ("(" + basenames.length + ") and the number of weight files provided ") +
                ("(" + files.length + ")."));
        }
        return pathToFile;
    };
    return BrowserFiles;
}());
exports.browserDownloadsRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (url.startsWith(BrowserDownloads.URL_SCHEME)) {
            return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.browserDownloadsRouter);
function browserDownloads(fileNamePrefix) {
    if (fileNamePrefix === void 0) { fileNamePrefix = 'model'; }
    return new BrowserDownloads(fileNamePrefix);
}
exports.browserDownloads = browserDownloads;
function browserFiles(files) {
    return new BrowserFiles(files);
}
exports.browserFiles = browserFiles;

},{"../environment":48,"./io_utils":56,"./router_registry":59}],53:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util_1 = require("../util");
var io_utils_1 = require("./io_utils");
var router_registry_1 = require("./router_registry");
var weights_loader_1 = require("./weights_loader");
var BrowserHTTPRequest = (function () {
    function BrowserHTTPRequest(path, requestInit) {
        this.DEFAULT_METHOD = 'POST';
        if (!environment_1.ENV.get('IS_BROWSER')) {
            throw new Error('browserHTTPRequest is not supported outside the web browser.');
        }
        util_1.assert(path != null && path.length > 0, 'URL path for browserHTTPRequest must not be null, undefined or ' +
            'empty.');
        this.path = path;
        if (requestInit != null && requestInit.body != null) {
            throw new Error('requestInit is expected to have no pre-existing body, but has one.');
        }
        this.requestInit = requestInit || {};
    }
    BrowserHTTPRequest.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var init, weightsManifest, modelTopologyAndWeightManifest, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                            throw new Error('BrowserHTTPRequest.save() does not support saving model topology ' +
                                'in binary formats yet.');
                        }
                        init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
                        init.body = new FormData();
                        weightsManifest = [{
                                paths: ['./model.weights.bin'],
                                weights: modelArtifacts.weightSpecs,
                            }];
                        modelTopologyAndWeightManifest = {
                            modelTopology: modelArtifacts.modelTopology,
                            weightsManifest: weightsManifest
                        };
                        init.body.append('model.json', new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: 'application/json' }), 'model.json');
                        if (modelArtifacts.weightData != null) {
                            init.body.append('model.weights.bin', new Blob([modelArtifacts.weightData], { type: 'application/octet-stream' }), 'model.weights.bin');
                        }
                        return [4, fetch(this.path, init)];
                    case 1:
                        response = _a.sent();
                        if (response.status === 200) {
                            return [2, {
                                    modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts),
                                    responses: [response],
                                }];
                        }
                        else {
                            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " +
                                (response.status + "."));
                        }
                        return [2];
                }
            });
        });
    };
    BrowserHTTPRequest.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var modelConfigRequest, modelConfig, modelTopology, weightsManifest, weightSpecs, weightData, weightsManifest_1, _i, weightsManifest_2, entry, pathPrefix_1, fetchURLs_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, fetch(this.path, this.requestInit)];
                    case 1:
                        modelConfigRequest = _b.sent();
                        return [4, modelConfigRequest.json()];
                    case 2:
                        modelConfig = _b.sent();
                        modelTopology = modelConfig['modelTopology'];
                        weightsManifest = modelConfig['weightsManifest'];
                        if (modelTopology == null && weightsManifest == null) {
                            throw new Error("The JSON from HTTP path " + this.path + " contains neither model " +
                                "topology or manifest for weights.");
                        }
                        if (!(weightsManifest != null)) return [3, 4];
                        weightsManifest_1 = modelConfig['weightsManifest'];
                        weightSpecs = [];
                        for (_i = 0, weightsManifest_2 = weightsManifest_1; _i < weightsManifest_2.length; _i++) {
                            entry = weightsManifest_2[_i];
                            weightSpecs.push.apply(weightSpecs, entry.weights);
                        }
                        pathPrefix_1 = this.path.substring(0, this.path.lastIndexOf('/'));
                        if (!pathPrefix_1.endsWith('/')) {
                            pathPrefix_1 = pathPrefix_1 + '/';
                        }
                        fetchURLs_1 = [];
                        weightsManifest_1.forEach(function (weightsGroup) {
                            weightsGroup.paths.forEach(function (path) {
                                fetchURLs_1.push(pathPrefix_1 + path);
                            });
                        });
                        _a = io_utils_1.concatenateArrayBuffers;
                        return [4, weights_loader_1.loadWeightsAsArrayBuffer(fetchURLs_1, this.requestInit)];
                    case 3:
                        weightData = _a.apply(void 0, [_b.sent()]);
                        _b.label = 4;
                    case 4: return [2, { modelTopology: modelTopology, weightSpecs: weightSpecs, weightData: weightData }];
                }
            });
        });
    };
    BrowserHTTPRequest.URL_SCHEMES = ['http://', 'https://'];
    return BrowserHTTPRequest;
}());
exports.BrowserHTTPRequest = BrowserHTTPRequest;
exports.httpRequestRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        for (var _i = 0, _a = BrowserHTTPRequest.URL_SCHEMES; _i < _a.length; _i++) {
            var scheme = _a[_i];
            if (url.startsWith(scheme)) {
                return browserHTTPRequest(url);
            }
        }
        return null;
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.httpRequestRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.httpRequestRouter);
function browserHTTPRequest(path, requestInit) {
    return new BrowserHTTPRequest(path, requestInit);
}
exports.browserHTTPRequest = browserHTTPRequest;

},{"../environment":48,"../util":155,"./io_utils":56,"./router_registry":59,"./weights_loader":61}],54:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var io_utils_1 = require("./io_utils");
var model_management_1 = require("./model_management");
var router_registry_1 = require("./router_registry");
var DATABASE_NAME = 'tensorflowjs';
var DATABASE_VERSION = 1;
var MODEL_STORE_NAME = 'models_store';
var INFO_STORE_NAME = 'model_info_store';
function deleteDatabase() {
    return __awaiter(this, void 0, void 0, function () {
        var idbFactory;
        return __generator(this, function (_a) {
            idbFactory = getIndexedDBFactory();
            return [2, new Promise(function (resolve, reject) {
                    var deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);
                    deleteRequest.onsuccess = function () { return resolve(); };
                    deleteRequest.onerror = function (error) { return reject(error); };
                })];
        });
    });
}
exports.deleteDatabase = deleteDatabase;
function getIndexedDBFactory() {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        throw new Error('Failed to obtain IndexedDB factory because the current environment' +
            'is not a web browser.');
    }
    var theWindow = window;
    var factory = theWindow.indexedDB || theWindow.mozIndexedDB ||
        theWindow.webkitIndexedDB || theWindow.msIndexedDB ||
        theWindow.shimIndexedDB;
    if (factory == null) {
        throw new Error('The current browser does not appear to support IndexedDB.');
    }
    return factory;
}
function setUpDatabase(openRequest) {
    var db = openRequest.result;
    db.createObjectStore(MODEL_STORE_NAME, { keyPath: 'modelPath' });
    db.createObjectStore(INFO_STORE_NAME, { keyPath: 'modelPath' });
}
var BrowserIndexedDB = (function () {
    function BrowserIndexedDB(modelPath) {
        this.indexedDB = getIndexedDBFactory();
        if (modelPath == null || !modelPath) {
            throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');
        }
        this.modelPath = modelPath;
    }
    BrowserIndexedDB.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                return [2, this.databaseAction(this.modelPath, modelArtifacts)];
            });
        });
    };
    BrowserIndexedDB.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.databaseAction(this.modelPath)];
            });
        });
    };
    BrowserIndexedDB.prototype.databaseAction = function (modelPath, modelArtifacts) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
            openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
            openRequest.onsuccess = function () {
                var db = openRequest.result;
                if (modelArtifacts == null) {
                    var modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');
                    var modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                    var getRequest_1 = modelStore.get(_this.modelPath);
                    getRequest_1.onsuccess = function () {
                        if (getRequest_1.result == null) {
                            db.close();
                            return reject(new Error("Cannot find model with path '" + _this.modelPath + "' " +
                                "in IndexedDB."));
                        }
                        else {
                            resolve(getRequest_1.result.modelArtifacts);
                        }
                    };
                    getRequest_1.onerror = function (error) {
                        db.close();
                        return reject(getRequest_1.error);
                    };
                    modelTx.oncomplete = function () { return db.close(); };
                }
                else {
                    var modelArtifactsInfo_1 = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);
                    var infoTx_1 = db.transaction(INFO_STORE_NAME, 'readwrite');
                    var infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);
                    var putInfoRequest_1 = infoStore_1.put({ modelPath: _this.modelPath, modelArtifactsInfo: modelArtifactsInfo_1 });
                    var modelTx_1;
                    putInfoRequest_1.onsuccess = function () {
                        modelTx_1 = db.transaction(MODEL_STORE_NAME, 'readwrite');
                        var modelStore = modelTx_1.objectStore(MODEL_STORE_NAME);
                        var putModelRequest = modelStore.put({
                            modelPath: _this.modelPath,
                            modelArtifacts: modelArtifacts,
                            modelArtifactsInfo: modelArtifactsInfo_1
                        });
                        putModelRequest.onsuccess = function () { return resolve({ modelArtifactsInfo: modelArtifactsInfo_1 }); };
                        putModelRequest.onerror = function (error) {
                            infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);
                            var deleteInfoRequest = infoStore_1.delete(_this.modelPath);
                            deleteInfoRequest.onsuccess = function () {
                                db.close();
                                return reject(putModelRequest.error);
                            };
                            deleteInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(putModelRequest.error);
                            };
                        };
                    };
                    putInfoRequest_1.onerror = function (error) {
                        db.close();
                        return reject(putInfoRequest_1.error);
                    };
                    infoTx_1.oncomplete = function () {
                        if (modelTx_1 == null) {
                            db.close();
                        }
                        else {
                            modelTx_1.oncomplete = function () { return db.close(); };
                        }
                    };
                }
            };
            openRequest.onerror = function (error) { return reject(openRequest.error); };
        });
    };
    BrowserIndexedDB.URL_SCHEME = 'indexeddb://';
    return BrowserIndexedDB;
}());
exports.BrowserIndexedDB = BrowserIndexedDB;
exports.indexedDBRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
            return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.indexedDBRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.indexedDBRouter);
function browserIndexedDB(modelPath) {
    return new BrowserIndexedDB(modelPath);
}
exports.browserIndexedDB = browserIndexedDB;
function maybeStripScheme(key) {
    return key.startsWith(BrowserIndexedDB.URL_SCHEME) ?
        key.slice(BrowserIndexedDB.URL_SCHEME.length) :
        key;
}
var BrowserIndexedDBManager = (function () {
    function BrowserIndexedDBManager() {
        this.indexedDB = getIndexedDBFactory();
    }
    BrowserIndexedDBManager.prototype.listModels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, new Promise(function (resolve, reject) {
                        var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                        openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
                        openRequest.onsuccess = function () {
                            var db = openRequest.result;
                            var tx = db.transaction(INFO_STORE_NAME, 'readonly');
                            var store = tx.objectStore(INFO_STORE_NAME);
                            var getAllInfoRequest = store.getAll();
                            getAllInfoRequest.onsuccess = function () {
                                var out = {};
                                for (var _i = 0, _a = getAllInfoRequest.result; _i < _a.length; _i++) {
                                    var item = _a[_i];
                                    out[item.modelPath] = item.modelArtifactsInfo;
                                }
                                resolve(out);
                            };
                            getAllInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(getAllInfoRequest.error);
                            };
                            tx.oncomplete = function () { return db.close(); };
                        };
                        openRequest.onerror = function (error) { return reject(openRequest.error); };
                    })];
            });
        });
    };
    BrowserIndexedDBManager.prototype.removeModel = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                path = maybeStripScheme(path);
                return [2, new Promise(function (resolve, reject) {
                        var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                        openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
                        openRequest.onsuccess = function () {
                            var db = openRequest.result;
                            var infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');
                            var infoStore = infoTx.objectStore(INFO_STORE_NAME);
                            var getInfoRequest = infoStore.get(path);
                            var modelTx;
                            getInfoRequest.onsuccess = function () {
                                if (getInfoRequest.result == null) {
                                    db.close();
                                    return reject(new Error("Cannot find model with path '" + path + "' " +
                                        "in IndexedDB."));
                                }
                                else {
                                    var deleteInfoRequest = infoStore.delete(path);
                                    var deleteModelData_1 = function () {
                                        modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');
                                        var modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                                        var deleteModelRequest = modelStore.delete(path);
                                        deleteModelRequest.onsuccess = function () {
                                            return resolve(getInfoRequest.result.modelArtifactsInfo);
                                        };
                                        deleteModelRequest.onerror = function (error) {
                                            return reject(getInfoRequest.error);
                                        };
                                    };
                                    deleteInfoRequest.onsuccess = deleteModelData_1;
                                    deleteInfoRequest.onerror = function (error) {
                                        deleteModelData_1();
                                        db.close();
                                        return reject(getInfoRequest.error);
                                    };
                                }
                            };
                            getInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(getInfoRequest.error);
                            };
                            infoTx.oncomplete = function () {
                                if (modelTx == null) {
                                    db.close();
                                }
                                else {
                                    modelTx.oncomplete = function () { return db.close(); };
                                }
                            };
                        };
                        openRequest.onerror = function (error) { return reject(openRequest.error); };
                    })];
            });
        });
    };
    return BrowserIndexedDBManager;
}());
exports.BrowserIndexedDBManager = BrowserIndexedDBManager;
if (environment_1.ENV.get('IS_BROWSER')) {
    try {
        model_management_1.ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
    }
    catch (err) {
    }
}

},{"../environment":48,"./io_utils":56,"./model_management":58,"./router_registry":59}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./indexed_db");
require("./local_storage");
var browser_files_1 = require("./browser_files");
exports.browserFiles = browser_files_1.browserFiles;
var browser_http_1 = require("./browser_http");
exports.browserHTTPRequest = browser_http_1.browserHTTPRequest;
var io_utils_1 = require("./io_utils");
exports.decodeWeights = io_utils_1.decodeWeights;
exports.encodeWeights = io_utils_1.encodeWeights;
exports.getModelArtifactsInfoForJSON = io_utils_1.getModelArtifactsInfoForJSON;
var model_management_1 = require("./model_management");
var router_registry_1 = require("./router_registry");
var weights_loader_1 = require("./weights_loader");
exports.loadWeights = weights_loader_1.loadWeights;
var registerSaveRouter = router_registry_1.IORouterRegistry.registerSaveRouter;
exports.registerSaveRouter = registerSaveRouter;
var registerLoadRouter = router_registry_1.IORouterRegistry.registerLoadRouter;
exports.registerLoadRouter = registerLoadRouter;
var getSaveHandlers = router_registry_1.IORouterRegistry.getSaveHandlers;
exports.getSaveHandlers = getSaveHandlers;
var getLoadHandlers = router_registry_1.IORouterRegistry.getLoadHandlers;
exports.getLoadHandlers = getLoadHandlers;
var copyModel = model_management_1.ModelManagement.copyModel;
exports.copyModel = copyModel;
var listModels = model_management_1.ModelManagement.listModels;
exports.listModels = listModels;
var moveModel = model_management_1.ModelManagement.moveModel;
exports.moveModel = moveModel;
var removeModel = model_management_1.ModelManagement.removeModel;
exports.removeModel = removeModel;

},{"./browser_files":52,"./browser_http":53,"./indexed_db":54,"./io_utils":56,"./local_storage":57,"./model_management":58,"./router_registry":59,"./weights_loader":61}],56:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var array_ops_1 = require("../ops/array_ops");
var util_1 = require("../util");
var types_1 = require("./types");
function encodeWeights(tensors) {
    return __awaiter(this, void 0, void 0, function () {
        var specs, dataPromises, name_1, t, tensorValues;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    specs = [];
                    dataPromises = [];
                    for (name_1 in tensors) {
                        t = tensors[name_1];
                        if (t.dtype !== 'float32' && t.dtype !== 'int32' && t.dtype !== 'bool') {
                            throw new Error("Unsupported dtype in weight '" + name_1 + "': " + t.dtype);
                        }
                        specs.push({ name: name_1, shape: t.shape, dtype: t.dtype });
                        dataPromises.push(t.data());
                    }
                    return [4, Promise.all(dataPromises)];
                case 1:
                    tensorValues = _a.sent();
                    return [2, { data: concatenateTypedArrays(tensorValues), specs: specs }];
            }
        });
    });
}
exports.encodeWeights = encodeWeights;
function decodeWeights(buffer, specs) {
    var out = {};
    var offset = 0;
    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
        var spec = specs_1[_i];
        var name_2 = spec.name;
        var dtype = spec.dtype;
        var shape = spec.shape;
        if (spec.quantization != null) {
            throw new Error("decodeWeights does not support quantization yet, but encountered " +
                ("weight '" + name_2 + " with quantization.'"));
        }
        var size = util_1.sizeFromShape(shape);
        var value = void 0;
        if (dtype === 'float32') {
            value = array_ops_1.ArrayOps.tensor(new Float32Array(buffer, offset, size), shape, 'float32');
        }
        else if (dtype === 'int32') {
            value =
                array_ops_1.ArrayOps.tensor(new Int32Array(buffer, offset, size), shape, 'int32');
        }
        else if (dtype === 'bool') {
            value =
                array_ops_1.ArrayOps.tensor(new Uint8Array(buffer, offset, size), shape, 'bool');
        }
        else {
            throw new Error("Unsupported dtype in weight '" + name_2 + "': " + dtype);
        }
        out[name_2] = value;
        offset += size * types_1.DTYPE_VALUE_SIZE_MAP[dtype];
    }
    return out;
}
exports.decodeWeights = decodeWeights;
function concatenateTypedArrays(xs) {
    if (xs === null) {
        throw new Error("Invalid input value: " + JSON.stringify(xs));
    }
    var totalByteLength = 0;
    xs.forEach(function (x) {
        if (x instanceof Float32Array || x instanceof Int32Array) {
            totalByteLength += x.length * 4;
        }
        else if (x instanceof Uint8Array) {
            totalByteLength += x.length;
        }
        else {
            throw new Error("Unsupported TypedArray subtype: " + x.constructor.name);
        }
    });
    var y = new Uint8Array(totalByteLength);
    var offset = 0;
    xs.forEach(function (x) {
        y.set(new Uint8Array(x.buffer), offset);
        if (x instanceof Float32Array || x instanceof Int32Array) {
            offset += x.length * 4;
        }
        else {
            offset += x.length;
        }
    });
    return y.buffer;
}
exports.concatenateTypedArrays = concatenateTypedArrays;
function stringByteLength(str) {
    return new Blob([str]).size;
}
exports.stringByteLength = stringByteLength;
function arrayBufferToBase64String(buffer) {
    return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
}
exports.arrayBufferToBase64String = arrayBufferToBase64String;
function base64StringToArrayBuffer(str) {
    var s = atob(str);
    var buffer = new Uint8Array(s.length);
    for (var i = 0; i < s.length; ++i) {
        buffer.set([s.charCodeAt(i)], i);
    }
    return buffer.buffer;
}
exports.base64StringToArrayBuffer = base64StringToArrayBuffer;
function concatenateArrayBuffers(buffers) {
    var totalByteLength = 0;
    buffers.forEach(function (buffer) {
        totalByteLength += buffer.byteLength;
    });
    var temp = new Uint8Array(totalByteLength);
    var offset = 0;
    buffers.forEach(function (buffer) {
        temp.set(new Uint8Array(buffer), offset);
        offset += buffer.byteLength;
    });
    return temp.buffer;
}
exports.concatenateArrayBuffers = concatenateArrayBuffers;
function basename(path) {
    var SEPARATOR = '/';
    path = path.trim();
    while (path.endsWith(SEPARATOR)) {
        path = path.slice(0, path.length - 1);
    }
    var items = path.split(SEPARATOR);
    return items[items.length - 1];
}
exports.basename = basename;
function getModelArtifactsInfoForJSON(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error('Expected JSON model topology, received ArrayBuffer.');
    }
    return {
        dateSaved: new Date(),
        modelTopologyType: 'JSON',
        modelTopologyBytes: modelArtifacts.modelTopology == null ?
            0 :
            stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
        weightSpecsBytes: modelArtifacts.weightSpecs == null ?
            0 :
            stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
        weightDataBytes: modelArtifacts.weightData == null ?
            0 :
            modelArtifacts.weightData.byteLength,
    };
}
exports.getModelArtifactsInfoForJSON = getModelArtifactsInfoForJSON;

},{"../ops/array_ops":103,"../util":155,"./types":60}],57:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util_1 = require("../util");
var io_utils_1 = require("./io_utils");
var model_management_1 = require("./model_management");
var router_registry_1 = require("./router_registry");
var PATH_SEPARATOR = '/';
var PATH_PREFIX = 'tensorflowjs_models';
var INFO_SUFFIX = 'info';
var MODEL_TOPOLOGY_SUFFIX = 'model_topology';
var WEIGHT_SPECS_SUFFIX = 'weight_specs';
var WEIGHT_DATA_SUFFIX = 'weight_data';
function purgeLocalStorageArtifacts() {
    if (!environment_1.ENV.get('IS_BROWSER') || typeof window.localStorage === 'undefined') {
        throw new Error('purgeLocalStorageModels() cannot proceed because local storage is ' +
            'unavailable in the current environment.');
    }
    var LS = window.localStorage;
    var purgedModelPaths = [];
    for (var i = 0; i < LS.length; ++i) {
        var key = LS.key(i);
        var prefix = PATH_PREFIX + PATH_SEPARATOR;
        if (key.startsWith(prefix) && key.length > prefix.length) {
            LS.removeItem(key);
            var modelName = getModelPathFromKey(key);
            if (purgedModelPaths.indexOf(modelName) === -1) {
                purgedModelPaths.push(modelName);
            }
        }
    }
    return purgedModelPaths;
}
exports.purgeLocalStorageArtifacts = purgeLocalStorageArtifacts;
function getModelKeys(path) {
    return {
        info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
        topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
        weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
        weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)
    };
}
function getModelPathFromKey(key) {
    var items = key.split(PATH_SEPARATOR);
    if (items.length < 3) {
        throw new Error("Invalid key format: " + key);
    }
    return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
}
function maybeStripScheme(key) {
    return key.startsWith(BrowserLocalStorage.URL_SCHEME) ?
        key.slice(BrowserLocalStorage.URL_SCHEME.length) :
        key;
}
var BrowserLocalStorage = (function () {
    function BrowserLocalStorage(modelPath) {
        if (!environment_1.ENV.get('IS_BROWSER') || typeof window.localStorage === 'undefined') {
            throw new Error('The current environment does not support local storage.');
        }
        this.LS = window.localStorage;
        if (modelPath == null || !modelPath) {
            throw new Error('For local storage, modelPath must not be null, undefined or empty.');
        }
        this.modelPath = modelPath;
        this.keys = getModelKeys(this.modelPath);
    }
    BrowserLocalStorage.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var topology, weightSpecs, modelArtifactsInfo, key;
            return __generator(this, function (_a) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                else {
                    topology = JSON.stringify(modelArtifacts.modelTopology);
                    weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
                    modelArtifactsInfo = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);
                    try {
                        this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
                        this.LS.setItem(this.keys.topology, topology);
                        this.LS.setItem(this.keys.weightSpecs, weightSpecs);
                        this.LS.setItem(this.keys.weightData, io_utils_1.arrayBufferToBase64String(modelArtifacts.weightData));
                        return [2, { modelArtifactsInfo: modelArtifactsInfo }];
                    }
                    catch (err) {
                        for (key in this.keys) {
                            this.LS.removeItem(this.keys[key]);
                        }
                        throw new Error("Failed to save model '" + this.modelPath + "' to local storage: " +
                            "size quota being exceeded is a possible cause of this failure: " +
                            ("modelTopologyBytes=" + modelArtifactsInfo.modelTopologyBytes + ", ") +
                            ("weightSpecsBytes=" + modelArtifactsInfo.weightSpecsBytes + ", ") +
                            ("weightDataBytes=" + modelArtifactsInfo.weightDataBytes + "."));
                    }
                }
                return [2];
            });
        });
    };
    BrowserLocalStorage.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var info, out, topology, weightSpecs, weightDataBase64;
            return __generator(this, function (_a) {
                info = JSON.parse(this.LS.getItem(this.keys.info));
                if (info == null) {
                    throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
                }
                if (info.modelTopologyType !== 'JSON') {
                    throw new Error('BrowserLocalStorage does not support loading non-JSON model ' +
                        'topology yet.');
                }
                out = {};
                topology = JSON.parse(this.LS.getItem(this.keys.topology));
                if (topology == null) {
                    throw new Error("In local storage, the topology of model '" + this.modelPath + "' " +
                        "is missing.");
                }
                out.modelTopology = topology;
                weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
                if (weightSpecs == null) {
                    throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' " +
                        "are missing.");
                }
                out.weightSpecs = weightSpecs;
                weightDataBase64 = this.LS.getItem(this.keys.weightData);
                if (weightDataBase64 == null) {
                    throw new Error("In local storage, the binary weight values of model " +
                        ("'" + this.modelPath + "' are missing."));
                }
                out.weightData = io_utils_1.base64StringToArrayBuffer(weightDataBase64);
                return [2, out];
            });
        });
    };
    BrowserLocalStorage.URL_SCHEME = 'localstorage://';
    return BrowserLocalStorage;
}());
exports.BrowserLocalStorage = BrowserLocalStorage;
exports.localStorageRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
            return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.localStorageRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.localStorageRouter);
function browserLocalStorage(modelPath) {
    return new BrowserLocalStorage(modelPath);
}
exports.browserLocalStorage = browserLocalStorage;
var BrowserLocalStorageManager = (function () {
    function BrowserLocalStorageManager() {
        util_1.assert(environment_1.ENV.get('IS_BROWSER'), 'Current environment is not a web browser');
        util_1.assert(typeof window.localStorage !== 'undefined', 'Current browser does not appear to support localStorage');
        this.LS = window.localStorage;
    }
    BrowserLocalStorageManager.prototype.listModels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var out, prefix, suffix, i, key, modelPath;
            return __generator(this, function (_a) {
                out = {};
                prefix = PATH_PREFIX + PATH_SEPARATOR;
                suffix = PATH_SEPARATOR + INFO_SUFFIX;
                for (i = 0; i < this.LS.length; ++i) {
                    key = this.LS.key(i);
                    if (key.startsWith(prefix) && key.endsWith(suffix)) {
                        modelPath = getModelPathFromKey(key);
                        out[modelPath] = JSON.parse(this.LS.getItem(key));
                    }
                }
                return [2, out];
            });
        });
    };
    BrowserLocalStorageManager.prototype.removeModel = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var keys, info;
            return __generator(this, function (_a) {
                path = maybeStripScheme(path);
                keys = getModelKeys(path);
                if (this.LS.getItem(keys.info) == null) {
                    throw new Error("Cannot find model at path '" + path + "'");
                }
                info = JSON.parse(this.LS.getItem(keys.info));
                this.LS.removeItem(keys.info);
                this.LS.removeItem(keys.topology);
                this.LS.removeItem(keys.weightSpecs);
                this.LS.removeItem(keys.weightData);
                return [2, info];
            });
        });
    };
    return BrowserLocalStorageManager;
}());
exports.BrowserLocalStorageManager = BrowserLocalStorageManager;
if (environment_1.ENV.get('IS_BROWSER')) {
    try {
        model_management_1.ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
    }
    catch (err) {
    }
}

},{"../environment":48,"../util":155,"./io_utils":56,"./model_management":58,"./router_registry":59}],58:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util_1 = require("../util");
var router_registry_1 = require("./router_registry");
var URL_SCHEME_SUFFIX = '://';
var ModelStoreManagerRegistry = (function () {
    function ModelStoreManagerRegistry() {
        this.managers = {};
    }
    ModelStoreManagerRegistry.getInstance = function () {
        if (ModelStoreManagerRegistry.instance == null) {
            ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
        }
        return ModelStoreManagerRegistry.instance;
    };
    ModelStoreManagerRegistry.registerManager = function (scheme, manager) {
        util_1.assert(scheme != null, 'scheme must not be undefined or null.');
        if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
            scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
        }
        util_1.assert(scheme.length > 0, 'scheme must not be an empty string.');
        var registry = ModelStoreManagerRegistry.getInstance();
        util_1.assert(registry.managers[scheme] == null, "A model store manager is already registered for scheme '" + scheme + "'.");
        registry.managers[scheme] = manager;
    };
    ModelStoreManagerRegistry.getManager = function (scheme) {
        var manager = this.getInstance().managers[scheme];
        if (manager == null) {
            throw new Error("Cannot find model manager for scheme '" + scheme + "'");
        }
        return manager;
    };
    ModelStoreManagerRegistry.getSchemes = function () {
        return Object.keys(this.getInstance().managers);
    };
    return ModelStoreManagerRegistry;
}());
exports.ModelStoreManagerRegistry = ModelStoreManagerRegistry;
function parseURL(url) {
    if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
        throw new Error("The url string provided does not contain a scheme. " +
            "Supported schemes are: " +
            ("" + ModelStoreManagerRegistry.getSchemes().join(',')));
    }
    return {
        scheme: url.split(URL_SCHEME_SUFFIX)[0],
        path: url.split(URL_SCHEME_SUFFIX)[1],
    };
}
function cloneModelInternal(sourceURL, destURL, deleteSource) {
    if (deleteSource === void 0) { deleteSource = false; }
    return __awaiter(this, void 0, void 0, function () {
        var loadHandlers, loadHandler, saveHandlers, saveHandler, sourceScheme, sourcePath, sameMedium, modelArtifacts, saveResult;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    util_1.assert(sourceURL !== destURL, "Old path and new path are the same: '" + sourceURL + "'");
                    loadHandlers = router_registry_1.IORouterRegistry.getLoadHandlers(sourceURL);
                    util_1.assert(loadHandlers.length > 0, "Copying failed because no load handler is found for source URL " + sourceURL + ".");
                    util_1.assert(loadHandlers.length < 2, "Copying failed because more than one (" + loadHandlers.length + ") " +
                        ("load handlers for source URL " + sourceURL + "."));
                    loadHandler = loadHandlers[0];
                    saveHandlers = router_registry_1.IORouterRegistry.getSaveHandlers(destURL);
                    util_1.assert(saveHandlers.length > 0, "Copying failed because no save handler is found for destination URL " +
                        (destURL + "."));
                    util_1.assert(saveHandlers.length < 2, "Copying failed because more than one (" + loadHandlers.length + ") " +
                        ("save handlers for destination URL " + destURL + "."));
                    saveHandler = saveHandlers[0];
                    sourceScheme = parseURL(sourceURL).scheme;
                    sourcePath = parseURL(sourceURL).path;
                    sameMedium = sourceScheme === parseURL(sourceURL).scheme;
                    return [4, loadHandler.load()];
                case 1:
                    modelArtifacts = _a.sent();
                    if (!(deleteSource && sameMedium)) return [3, 3];
                    return [4, ModelStoreManagerRegistry.getManager(sourceScheme)
                            .removeModel(sourcePath)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [4, saveHandler.save(modelArtifacts)];
                case 4:
                    saveResult = _a.sent();
                    if (!(deleteSource && !sameMedium)) return [3, 6];
                    return [4, ModelStoreManagerRegistry.getManager(sourceScheme)
                            .removeModel(sourcePath)];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6: return [2, saveResult.modelArtifactsInfo];
            }
        });
    });
}
var ModelManagement = (function () {
    function ModelManagement() {
    }
    ModelManagement.listModels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var schemes, out, _i, schemes_1, scheme, schemeOut, path, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        schemes = ModelStoreManagerRegistry.getSchemes();
                        out = {};
                        _i = 0, schemes_1 = schemes;
                        _a.label = 1;
                    case 1:
                        if (!(_i < schemes_1.length)) return [3, 4];
                        scheme = schemes_1[_i];
                        return [4, ModelStoreManagerRegistry.getManager(scheme).listModels()];
                    case 2:
                        schemeOut = _a.sent();
                        for (path in schemeOut) {
                            url = scheme + URL_SCHEME_SUFFIX + path;
                            out[url] = schemeOut[path];
                        }
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2, out];
                }
            });
        });
    };
    ModelManagement.removeModel = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var schemeAndPath, manager;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        schemeAndPath = parseURL(url);
                        manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
                        return [4, manager.removeModel(schemeAndPath.path)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    ModelManagement.copyModel = function (sourceURL, destURL) {
        return __awaiter(this, void 0, void 0, function () {
            var deleteSource;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deleteSource = false;
                        return [4, cloneModelInternal(sourceURL, destURL, deleteSource)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    ModelManagement.moveModel = function (sourceURL, destURL) {
        return __awaiter(this, void 0, void 0, function () {
            var deleteSource;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deleteSource = true;
                        return [4, cloneModelInternal(sourceURL, destURL, deleteSource)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    __decorate([
        doc_1.doc({ heading: 'Models', subheading: 'Management', namespace: 'io' })
    ], ModelManagement, "listModels", null);
    __decorate([
        doc_1.doc({ heading: 'Models', subheading: 'Management', namespace: 'io' })
    ], ModelManagement, "removeModel", null);
    __decorate([
        doc_1.doc({ heading: 'Models', subheading: 'Management', namespace: 'io' })
    ], ModelManagement, "copyModel", null);
    __decorate([
        doc_1.doc({ heading: 'Models', subheading: 'Management', namespace: 'io' })
    ], ModelManagement, "moveModel", null);
    return ModelManagement;
}());
exports.ModelManagement = ModelManagement;

},{"../doc":46,"../util":155,"./router_registry":59}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var IORouterRegistry = (function () {
    function IORouterRegistry() {
        this.saveRouters = [];
        this.loadRouters = [];
    }
    IORouterRegistry.getInstance = function () {
        if (IORouterRegistry.instance == null) {
            IORouterRegistry.instance = new IORouterRegistry();
        }
        return IORouterRegistry.instance;
    };
    IORouterRegistry.registerSaveRouter = function (saveRouter) {
        IORouterRegistry.getInstance().saveRouters.push(saveRouter);
    };
    IORouterRegistry.registerLoadRouter = function (loadRouter) {
        IORouterRegistry.getInstance().loadRouters.push(loadRouter);
    };
    IORouterRegistry.getSaveHandlers = function (url) {
        return IORouterRegistry.getHandlers(url, 'save');
    };
    IORouterRegistry.getLoadHandlers = function (url) {
        return IORouterRegistry.getHandlers(url, 'load');
    };
    IORouterRegistry.getHandlers = function (url, handlerType) {
        var validHandlers = [];
        var routers = handlerType === 'load' ? this.getInstance().loadRouters :
            this.getInstance().saveRouters;
        routers.forEach(function (router) {
            var handler = router(url);
            if (handler !== null) {
                validHandlers.push(handler);
            }
        });
        return validHandlers;
    };
    return IORouterRegistry;
}());
exports.IORouterRegistry = IORouterRegistry;

},{}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DTYPE_VALUE_SIZE_MAP = {
    'float32': 4,
    'int32': 4,
    'uint16': 2,
    'uint8': 1,
    'bool': 1,
};

},{}],61:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ops_1 = require("../ops/ops");
var util = require("../util");
var types_1 = require("./types");
function loadWeightsAsArrayBuffer(fetchURLs, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var requests, responses, buffers;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    requests = fetchURLs.map(function (fetchURL) { return fetch(fetchURL, requestOptions); });
                    return [4, Promise.all(requests)];
                case 1:
                    responses = _a.sent();
                    return [4, Promise.all(responses.map(function (response) { return response.arrayBuffer(); }))];
                case 2:
                    buffers = _a.sent();
                    return [2, buffers];
            }
        });
    });
}
exports.loadWeightsAsArrayBuffer = loadWeightsAsArrayBuffer;
function loadWeights(manifest, filePathPrefix, weightNames, requestOptions) {
    if (filePathPrefix === void 0) { filePathPrefix = ''; }
    return __awaiter(this, void 0, void 0, function () {
        var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames, weightsNotFound, groupIndicesToFetch, fetchUrls, buffers, weightsTensorMap, bufferIndexOffset;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    groupIndicesToFetchMap = manifest.map(function () { return false; });
                    groupWeightsToFetch = {};
                    weightsFound = weightNames != null ? weightNames.map(function () { return false; }) : [];
                    allManifestWeightNames = [];
                    manifest.forEach(function (manifestGroupConfig, groupIndex) {
                        var groupOffset = 0;
                        manifestGroupConfig.weights.forEach(function (weightsEntry) {
                            var rawDtype = ('quantization' in weightsEntry) ?
                                weightsEntry.quantization.dtype :
                                weightsEntry.dtype;
                            var weightsBytes = types_1.DTYPE_VALUE_SIZE_MAP[rawDtype] *
                                util.sizeFromShape(weightsEntry.shape);
                            var enqueueWeightsForFetchingFn = function () {
                                groupIndicesToFetchMap[groupIndex] = true;
                                if (groupWeightsToFetch[groupIndex] == null) {
                                    groupWeightsToFetch[groupIndex] = [];
                                }
                                groupWeightsToFetch[groupIndex].push({
                                    manifestEntry: weightsEntry,
                                    groupOffset: groupOffset,
                                    sizeBytes: weightsBytes
                                });
                            };
                            if (weightNames != null) {
                                weightNames.forEach(function (weightName, weightIndex) {
                                    if (weightName === weightsEntry.name) {
                                        enqueueWeightsForFetchingFn();
                                        weightsFound[weightIndex] = true;
                                    }
                                });
                            }
                            else {
                                enqueueWeightsForFetchingFn();
                            }
                            allManifestWeightNames.push(weightsEntry.name);
                            groupOffset += weightsBytes;
                        });
                    });
                    if (!weightsFound.every(function (found) { return found; })) {
                        weightsNotFound = weightNames.filter(function (weight, i) { return !weightsFound[i]; });
                        throw new Error("Could not find weights in manifest with names: " +
                            (weightsNotFound.join(', ') + ". \n") +
                            "Manifest JSON has weights with names: " +
                            (allManifestWeightNames.join(', ') + "."));
                    }
                    groupIndicesToFetch = groupIndicesToFetchMap.reduce(function (accumulator, shouldFetch, i) {
                        if (shouldFetch) {
                            accumulator.push(i);
                        }
                        return accumulator;
                    }, []);
                    fetchUrls = [];
                    groupIndicesToFetch.forEach(function (i) {
                        manifest[i].paths.forEach(function (filepath) {
                            var fetchUrl = filePathPrefix +
                                (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;
                            fetchUrls.push(fetchUrl);
                        });
                    });
                    return [4, loadWeightsAsArrayBuffer(fetchUrls, requestOptions)];
                case 1:
                    buffers = _a.sent();
                    weightsTensorMap = {};
                    bufferIndexOffset = 0;
                    groupIndicesToFetch.forEach(function (i) {
                        var numBuffers = manifest[i].paths.length;
                        var groupBytes = 0;
                        for (var i_1 = 0; i_1 < numBuffers; i_1++) {
                            groupBytes += buffers[bufferIndexOffset + i_1].byteLength;
                        }
                        var groupBuffer = new ArrayBuffer(groupBytes);
                        var groupByteBuffer = new Uint8Array(groupBuffer);
                        var groupBufferOffset = 0;
                        for (var i_2 = 0; i_2 < numBuffers; i_2++) {
                            var buffer = new Uint8Array(buffers[bufferIndexOffset + i_2]);
                            groupByteBuffer.set(buffer, groupBufferOffset);
                            groupBufferOffset += buffer.byteLength;
                        }
                        var weightsEntries = groupWeightsToFetch[i];
                        weightsEntries.forEach(function (weightsEntry) {
                            var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
                            var typedArray;
                            var dtype = weightsEntry.manifestEntry.dtype;
                            if ('quantization' in weightsEntry.manifestEntry) {
                                var quantization_1 = weightsEntry.manifestEntry.quantization;
                                if (quantization_1.dtype !== 'uint8' && quantization_1.dtype !== 'uint16') {
                                    throw new Error("Weight " + weightsEntry.manifestEntry.name + " has unknown " +
                                        ("quantization dtype " + quantization_1.dtype + "."));
                                }
                                var quantizedArray = (quantization_1.dtype === 'uint8') ?
                                    new Uint8Array(byteBuffer) :
                                    new Uint16Array(byteBuffer);
                                if (dtype === 'float32') {
                                    typedArray = Float32Array.from(quantizedArray, function (v) { return v * quantization_1.scale + quantization_1.min; });
                                }
                                else if (dtype === 'int32') {
                                    typedArray = Int32Array.from(quantizedArray, function (v) { return Math.round(v * quantization_1.scale + quantization_1.min); });
                                }
                                else {
                                    throw new Error("Weight " + weightsEntry.manifestEntry.name + " has a dtype not " +
                                        ("supported by quantization: " + dtype));
                                }
                            }
                            else {
                                if (dtype === 'float32') {
                                    typedArray = new Float32Array(byteBuffer);
                                }
                                else if (dtype === 'int32') {
                                    typedArray = new Int32Array(byteBuffer);
                                }
                                else {
                                    throw new Error("Weight " + weightsEntry.manifestEntry.name + " has unknown dtype " +
                                        (dtype + "."));
                                }
                            }
                            var weightName = weightsEntry.manifestEntry.name;
                            if (weightsTensorMap[weightName] != null) {
                                throw new Error("Duplicate weight with name " + weightName + ". " +
                                    "Please make sure weights names are unique in the manifest JSON.");
                            }
                            weightsTensorMap[weightName] = ops_1.tensor(typedArray, weightsEntry.manifestEntry.shape, weightsEntry.manifestEntry.dtype);
                        });
                        bufferIndexOffset += numBuffers;
                    });
                    return [2, weightsTensorMap];
            }
        });
    });
}
exports.loadWeights = loadWeights;

},{"../ops/ops":124,"../util":155,"./types":60}],62:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var environment_1 = require("../environment");
var axis_util = require("../ops/axis_util");
var broadcast_util = require("../ops/broadcast_util");
var concat_util = require("../ops/concat_util");
var erf_util = require("../ops/erf_util");
var ops = require("../ops/ops");
var ops_1 = require("../ops/ops");
var selu_util = require("../ops/selu_util");
var slice_util_1 = require("../ops/slice_util");
var tensor_1 = require("../tensor");
var types = require("../types");
var util = require("../util");
var backend_util = require("./backend_util");
var MathBackendCPU = (function () {
    function MathBackendCPU() {
        this.data = new WeakMap();
        this.firstUse = true;
        if (environment_1.ENV.get('IS_BROWSER')) {
            this.canvas = document.createElement('canvas');
        }
    }
    MathBackendCPU.prototype.register = function (dataId, shape, dtype) {
        if (this.firstUse) {
            this.firstUse = false;
            if (environment_1.ENV.get('IS_NODE')) {
                console.warn('\n============================\n' +
                    'Hi there . Looks like you are running TensorFlow.js in ' +
                    'Node.js. To speed things up dramatically, install our node ' +
                    'backend, which binds to TensorFlow C++, by running ' +
                    'npm i @tensorflow/tfjs-node, ' +
                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +
                    'Then call require(\'tensorflow/tfjs-node\'); (-gpu ' +
                    'suffix for CUDA) at the start of your program. ' +
                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +
                    '\n============================\n');
            }
        }
        if (this.data.has(dataId)) {
            throw new Error("Data buffer is already registered");
        }
        this.data.set(dataId, null);
    };
    MathBackendCPU.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendCPU.write(): values can not be null');
        }
        this.throwIfNoData(dataId);
        this.data.set(dataId, values);
    };
    MathBackendCPU.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('MathBackendCPU.writePixels(): pixels can not be null');
        }
        var vals;
        if (pixels instanceof ImageData) {
            vals = pixels.data;
        }
        else if (pixels instanceof HTMLCanvasElement) {
            vals = pixels.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else if (pixels instanceof HTMLImageElement ||
            pixels instanceof HTMLVideoElement) {
            if (this.canvas == null) {
                throw new Error('Can\'t read pixels from HTMLImageElement outside ' +
                    'the browser.');
            }
            this.canvas.width = pixels.width;
            this.canvas.height = pixels.height;
            this.canvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            vals = this.canvas.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else {
            throw new Error("pixels is of unknown type: " + pixels.constructor.name);
        }
        var values;
        if (numChannels === 4) {
            values = new Int32Array(vals);
        }
        else {
            var numPixels = pixels.width * pixels.height;
            values = new Int32Array(numPixels * numChannels);
            for (var i = 0; i < numPixels; i++) {
                for (var channel = 0; channel < numChannels; ++channel) {
                    values[i * numChannels + channel] = vals[i * 4 + channel];
                }
            }
        }
        var outShape = [pixels.height, pixels.width, numChannels];
        return ops_1.tensor3d(values, outShape, 'int32');
    };
    MathBackendCPU.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.readSync(dataId)];
            });
        });
    };
    MathBackendCPU.prototype.readSync = function (dataId) {
        this.throwIfNoData(dataId);
        return this.data.get(dataId);
    };
    MathBackendCPU.prototype.disposeData = function (dataId) {
        if (this.data.has(dataId)) {
            this.data.delete(dataId);
        }
    };
    MathBackendCPU.prototype.time = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var start, kernelMs;
            return __generator(this, function (_a) {
                start = performance.now();
                f();
                kernelMs = performance.now() - start;
                return [2, { kernelMs: kernelMs }];
            });
        });
    };
    MathBackendCPU.prototype.memory = function () {
        return {
            unreliable: true
        };
    };
    MathBackendCPU.prototype.throwIfNoData = function (dataId) {
        if (!this.data.has(dataId)) {
            throw new Error("CPU backend: No data found for this tensor. " +
                "Did you change your backend in the middle of the program? " +
                "New backends can't use Tensors created with previous backends");
        }
    };
    MathBackendCPU.prototype.slice = function (x, begin, size) {
        var buffer = ops.buffer(size, x.dtype);
        for (var i = 0; i < buffer.size; ++i) {
            var loc = buffer.indexToLoc(i);
            var xLoc = loc.map(function (idx, j) { return idx + begin[j]; });
            buffer.set.apply(buffer, [x.get.apply(x, xLoc)].concat(loc));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
        var _a = slice_util_1.getStridedSlicedInfo(x.shape, begin, end, strides, beginMask, endMask), beginIndex = _a[0], size = _a[1];
        if (size.some(function (axis) { return axis === 0; })) {
            return ops.tensor([], size);
        }
        var buffer = ops.buffer(size, x.dtype);
        for (var i = 0; i < buffer.size; i++) {
            var loc = buffer.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var j = 0; j < newLoc.length; j++) {
                newLoc[j] = loc[j] * strides[j] + beginIndex[j];
            }
            buffer.set.apply(buffer, [x.get.apply(x, newLoc)].concat(loc));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.reverse = function (x, axis) {
        var buffer = ops.buffer(x.shape, x.dtype);
        var xBuffer = x.buffer();
        var _loop_1 = function (i) {
            var outLoc = buffer.indexToLoc(i);
            var inLoc = outLoc.slice();
            axis.forEach(function (ax) { return inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]; });
            buffer.set.apply(buffer, [xBuffer.get.apply(xBuffer, inLoc)].concat(outLoc));
        };
        for (var i = 0; i < buffer.size; i++) {
            _loop_1(i);
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.concat = function (a, b) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, 1);
        var buffer = ops.buffer(outShape, a.dtype);
        if (a.shape[0] === 1 && b.shape[0] === 1) {
            var aVals = a.dataSync();
            var bVals = b.dataSync();
            var vals = buffer.values;
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return buffer.toTensor();
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < a.shape[1]; ++j) {
                buffer.set(a.get(i, j), i, j);
            }
            for (var j = 0; j < b.shape[1]; ++j) {
                buffer.set(b.get(i, j), i, j + a.shape[1]);
            }
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.neg = function (x) {
        return this.multiply(ops.scalar(-1), x);
    };
    MathBackendCPU.prototype.add = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue + bValue; });
    };
    MathBackendCPU.prototype.subtract = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue - bValue; });
    };
    MathBackendCPU.prototype.pow = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) { return Math.pow(aValue, bValue); });
    };
    MathBackendCPU.prototype.matMul = function (a, b, transposeA, transposeB) {
        var sharedDim = transposeA ? a.shape[0] : a.shape[1];
        var leftDim = transposeA ? a.shape[1] : a.shape[0];
        var rightDim = transposeB ? b.shape[0] : b.shape[1];
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var _a = transposeA ? [1, a.strides[0]] : [a.strides[0], 1], aOuterStep = _a[0], aInnerStep = _a[1];
        var _b = transposeB ? [b.strides[0], 1] : [1, b.strides[0]], bOuterStep = _b[0], bInnerStep = _b[1];
        var aOuterEnd = leftDim * aOuterStep;
        var bOuterEnd = rightDim * bOuterStep;
        var result = new Float32Array(leftDim * rightDim);
        var resultIndex = 0;
        for (var aOuter = 0; aOuter < aOuterEnd; aOuter += aOuterStep) {
            for (var bOuter = 0; bOuter < bOuterEnd; bOuter += bOuterStep) {
                var aInner = aOuter;
                var bInner = bOuter;
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aValues[aInner] * bValues[bInner];
                    aInner += aInnerStep;
                    bInner += bInnerStep;
                }
                result[resultIndex++] = sum;
            }
        }
        return ops.tensor2d(result, [leftDim, rightDim]);
    };
    MathBackendCPU.prototype.multiply = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue * bValue; });
    };
    MathBackendCPU.prototype.realDivide = function (a, b) {
        var op = function (a, b) { return a / b; };
        var outputDtype = 'float32';
        return this.broadcastedBinaryOp(a, b, outputDtype, op);
    };
    MathBackendCPU.prototype.floorDiv = function (a, b) {
        var op = function (a, b) { return Math.floor(a / b); };
        var outputDtype = 'int32';
        return this.broadcastedBinaryOp(a, b, outputDtype, op);
    };
    MathBackendCPU.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = types.upcastType(x.dtype, 'int32');
        var result = ops.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var sum = 0;
            for (var j = 0; j < reduceSize; ++j) {
                sum += aVals[offset + j];
            }
            vals[i] = sum;
        }
        return result;
    };
    MathBackendCPU.prototype.argMin = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            var minIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value < min) {
                    min = value;
                    minIndex = j;
                }
            }
            vals[i] = minIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.argMax = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            var maxIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value > max) {
                    max = value;
                    maxIndex = j;
                }
            }
            vals[i] = maxIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.cumsum = function (x, axis, exclusive, reverse) {
        if (axis !== x.rank - 1) {
            throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (x.rank - 1) + " " +
                ("but got axis=" + axis));
        }
        var resultDtype = types.upcastType(x.dtype, 'int32');
        var result = ops.zeros(x.shape, resultDtype);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        var finalDim = x.shape[x.rank - 1];
        var indexAdjuster = reverse ?
            function (i, j) { return i + finalDim - j - 1; } :
            function (i, j) { return i + j; };
        for (var i = 0; i < aVals.length; i += finalDim) {
            for (var j = 0; j < finalDim; j++) {
                var idx = indexAdjuster(i, j);
                if (j === 0) {
                    vals[idx] = exclusive ? 0 : aVals[idx];
                }
                else {
                    var prevIdx = indexAdjuster(i, j - 1);
                    vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] :
                        aVals[idx] + vals[prevIdx];
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.equal = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal === bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.notEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal !== bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.less = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal < bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.lessEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal <= bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.greater = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal > bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.greaterEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal >= bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.logicalNot = function (x) {
        var values = x.dataSync();
        var newValues = new Int32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = values[i] ? 0 : 1;
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues }, 'bool');
    };
    MathBackendCPU.prototype.logicalAnd = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return aVal && bVal;
        });
    };
    MathBackendCPU.prototype.logicalOr = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return aVal || bVal;
        });
    };
    MathBackendCPU.prototype.where = function (condition, a, b, dtype) {
        var values = condition.dataSync();
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var result = ops.zeros(a.shape, dtype);
        var newValues = result.dataSync();
        var index = 0;
        var offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ?
            1 :
            a.shape[1];
        for (var i = 0; i < values.length; i++) {
            for (var j = 0; j < offset; j++) {
                if (values[i] === 1) {
                    newValues[index++] = aValues[i];
                }
                else {
                    newValues[index++] = bValues[i];
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.topKValues = function (x, k) {
        return this.topK(x, k).values;
    };
    MathBackendCPU.prototype.topKIndices = function (x, k) {
        return this.topK(x, k).indices;
    };
    MathBackendCPU.prototype.topK = function (x, k) {
        var values = x.dataSync();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = util.getTypedArrayFromDType(x.dtype, k);
        var topkIndices = new Int32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return {
            values: ops.tensor1d(topkValues, x.dtype),
            indices: ops.tensor1d(topkIndices, 'int32')
        };
    };
    MathBackendCPU.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[0];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value < min) {
                    min = value;
                }
            }
            vals[i] = min;
        }
        return result;
    };
    MathBackendCPU.prototype.minimum = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.min(aVal, bVal); });
    };
    MathBackendCPU.prototype.mod = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
            var rem = aVal % bVal;
            if ((aVal < 0 && bVal < 0) || (aVal >= 0 && bVal >= 0)) {
                return rem;
            }
            else {
                return (rem + bVal) % bVal;
            }
        });
    };
    MathBackendCPU.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value > max) {
                    max = value;
                }
            }
            vals[i] = max;
        }
        return result;
    };
    MathBackendCPU.prototype.maximum = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.max(aVal, bVal); });
    };
    MathBackendCPU.prototype.squaredDifference = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
            var diff = aVal - bVal;
            return diff * diff;
        });
    };
    MathBackendCPU.prototype.ceil = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.ceil(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.floor = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.floor(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.sign = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            if (values[i] < 0) {
                newValues[i] = -1;
            }
            else if (values[i] > 0) {
                newValues[i] = 1;
            }
            else {
                newValues[i] = 0;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.round = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var base = Math.floor(values[i]);
            if (values[i] - base < 0.5) {
                newValues[i] = Math.floor(values[i]);
            }
            else if (values[i] - base > 0.5) {
                newValues[i] = Math.ceil(values[i]);
            }
            else {
                if (base % 2.0 === 0.0) {
                    newValues[i] = base;
                }
                else {
                    newValues[i] = base + 1.0;
                }
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.exp = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.expm1 = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.expm1(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.log = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.log1p = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log1p(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.sqrt = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.sqrt(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.rsqrt = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = 1 / Math.sqrt(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.square = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = value * value;
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.reciprocal = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = 1 / values[i];
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.relu = function (x) {
        var res = ops.zeros(x.shape, x.dtype);
        var resVals = res.dataSync();
        var inVals = x.dataSync();
        for (var i = 0; i < inVals.length; ++i) {
            resVals[i] = Math.max(0, inVals[i]);
        }
        return res;
    };
    MathBackendCPU.prototype.elu = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = (Math.exp(v) - 1);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.eluDer = function (dy, y) {
        var resultValues = new Float32Array(y.size);
        var values = y.dataSync();
        var dyValues = dy.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 1) {
                resultValues[i] = dyValues[i];
            }
            else {
                resultValues[i] = dyValues[i] * (v + 1);
            }
        }
        return tensor_1.Tensor.make(y.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.selu = function (x) {
        var scaleAlpha = selu_util.SELU_SCALEALPHA;
        var scale = selu_util.SELU_SCALE;
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = scale * v;
            }
            else {
                resultValues[i] = scaleAlpha * (Math.exp(v) - 1);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.clip = function (x, min, max) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.min(max, Math.max(min, values[i]));
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.abs = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.abs(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.int = function (x) {
        var resultValues = new Int32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = values[i];
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues }, 'int32');
    };
    MathBackendCPU.prototype.sigmoid = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.softplus = function (x) {
        var epsilon = 1.1920928955078125e-7;
        var threshold = Math.log(epsilon) + 2.0;
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var tooLarge = values[i] > -threshold;
            var tooSmall = values[i] < threshold;
            var expX = Math.exp(values[i]);
            var result = void 0;
            if (tooSmall) {
                result = expX;
            }
            else if (tooLarge) {
                result = values[i];
            }
            else {
                result = Math.log(1.0 + expX);
            }
            resultValues[i] = result;
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.sin = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cos = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cos(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tan = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.tan(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.asin = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asin(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.acos = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acos(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atan = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atan(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atan2 = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) { return Math.atan2(aValue, bValue); });
    };
    MathBackendCPU.prototype.sinh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sinh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cosh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cosh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tanh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.asinh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asinh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.acosh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acosh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atanh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atanh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.erf = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var p = erf_util.ERF_P;
        var a1 = erf_util.ERF_A1;
        var a2 = erf_util.ERF_A2;
        var a3 = erf_util.ERF_A3;
        var a4 = erf_util.ERF_A4;
        var a5 = erf_util.ERF_A5;
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            var t = 1.0 / (1.0 + p * v);
            resultValues[i] = 1.0 -
                (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t *
                    Math.exp(-v * v);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0; }
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                resultValues[i] = NaN;
            }
            else {
                resultValues[i] = value > 0 ? 1 : alpha;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.conv2d = function (x, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var y = ops.buffer(convInfo.outShape, x.dtype);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; wR++) {
                            var xR = xRCorner + wR * dilationHeight;
                            if (xR < 0 || xR >= convInfo.inHeight) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; wC++) {
                                var xC = xCCorner + wC * dilationWidth;
                                if (xC < 0 || xC >= convInfo.inWidth) {
                                    continue;
                                }
                                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                    var pixel = x.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, d2);
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        y.set(dotProd, b, yR, yC, d2);
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var dx = ops.buffer(convInfo.inShape, 'float32');
        var dxValues = dx.values;
        var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2];
        var dyValues = dy.dataSync();
        var _b = dy.strides, dyS0 = _b[0], dyS1 = _b[1], dyS2 = _b[2];
        var fltValues = filter.dataSync();
        var _c = filter.strides, fltS0 = _c[0], fltS1 = _c[1], fltS2 = _c[2];
        var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        for (var b = 0; b < batchSize; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var xR = 0; xR < inHeight; ++xR) {
                    var xRCorner = xR - topPad;
                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                    var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
                    for (var xC = 0; xC < inWidth; ++xC) {
                        var xCCorner = xC - leftPad;
                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                        var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                        var dotProd = 0;
                        for (var yR = xRMin; yR < yRMax; ++yR) {
                            var wR = yR * strideHeight - xRCorner;
                            for (var yC = xCMin; yC < yCMax; ++yC) {
                                var wC = yC * strideWidth - xCCorner;
                                var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                                var fltOffset = fltS0 * (filterHeight - 1 - wR) +
                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                                for (var d2 = 0; d2 < outChannels; ++d2) {
                                    var pixel = dyValues[dyOffset + d2];
                                    var weight = fltValues[fltOffset + d2];
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dW = ops.buffer(convInfo.filterShape, 'float32');
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                    for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                        var dotProd = 0;
                        for (var b = 0; b < convInfo.batchSize; ++b) {
                            for (var yR = yRMin; yR < yRMax; ++yR) {
                                var xR = wR + yR * strideHeight - topPad;
                                for (var yC = yCMin; yC < yCMax; ++yC) {
                                    var xC = wC + yC * strideWidth - leftPad;
                                    dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                                }
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var chMul = convInfo.outChannels / convInfo.inChannels;
        var y = ops.buffer(convInfo.outShape, x.dtype);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        for (var q = 0; q < chMul; ++q) {
                            var dotProd = 0;
                            for (var wR = 0; wR < filterHeight; ++wR) {
                                var xR = xRCorner + wR * dilationHeight;
                                if (xR < 0 || xR >= convInfo.inHeight) {
                                    continue;
                                }
                                for (var wC = 0; wC < filterWidth; ++wC) {
                                    var xC = xCCorner + wC * dilationWidth;
                                    if (xC < 0 || xC >= convInfo.inWidth) {
                                        continue;
                                    }
                                    var pixel = x.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, q);
                                    dotProd += pixel * weight;
                                }
                            }
                            y.set(dotProd, b, yR, yC, d1 * chMul + q);
                        }
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
        var dx = ops.buffer(convInfo.inShape, 'float32');
        var dxValues = dx.values;
        var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2];
        var dyValues = dy.dataSync();
        var _b = dy.strides, dyS0 = _b[0], dyS1 = _b[1], dyS2 = _b[2];
        var fltValues = filter.dataSync();
        var _c = filter.strides, fltS0 = _c[0], fltS1 = _c[1], fltS2 = _c[2];
        var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        var chMul = outChannels / inChannels;
        for (var b = 0; b < batchSize; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var xR = 0; xR < inHeight; ++xR) {
                    var xRCorner = xR - topPad;
                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                    var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
                    for (var xC = 0; xC < inWidth; ++xC) {
                        var xCCorner = xC - leftPad;
                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                        var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                        var dotProd = 0;
                        for (var yR = xRMin; yR < yRMax; ++yR) {
                            var wR = yR * strideHeight - xRCorner;
                            for (var yC = xCMin; yC < yCMax; ++yC) {
                                var wC = yC * strideWidth - xCCorner;
                                var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                                var fltOffset = fltS0 * (filterHeight - 1 - wR) +
                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                                for (var dm = 0; dm < chMul; ++dm) {
                                    var d2 = d1 * chMul + dm;
                                    var pixel = dyValues[dyOffset + d2];
                                    var weight = fltValues[fltOffset + dm];
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2DDerFilter = function (x, dy, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dW = ops.buffer(convInfo.filterShape, 'float32');
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        var chMul = convInfo.outChannels / convInfo.inChannels;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                    var d1 = Math.trunc(d2 / chMul);
                    var dm = d2 % chMul;
                    var dotProd = 0;
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var yR = yRMin; yR < yRMax; ++yR) {
                            var xR = wR + yR * strideHeight - topPad;
                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                var xC = wC + yC * strideWidth - leftPad;
                                dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                            }
                        }
                    }
                    dW.set(dotProd, wR, wC, d1, dm);
                }
            }
        }
        return dW.toTensor();
    };
    MathBackendCPU.prototype.tile = function (x, reps) {
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[i] * reps[i];
        }
        var result = ops.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < result.values.length; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = new Array(x.rank);
            for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                originalLoc[i_1] = newLoc[i_1] % x.shape[i_1];
            }
            var originalIndex = xBuf.locToIndex(originalLoc);
            result.values[i] = xBuf.values[originalIndex];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.pad = function (x, paddings, constantValue) {
        var outShape = paddings.map(function (p, i) { return p[0] + x.shape[i] + p[1]; });
        var start = paddings.map(function (p) { return p[0]; });
        var xBuffer = x.buffer();
        var buffer = ops.buffer(outShape, x.dtype);
        if (constantValue !== 0) {
            buffer.values.fill(constantValue);
        }
        for (var i = 0; i < x.size; i++) {
            var coords = xBuffer.indexToLoc(i);
            var outCoords = coords.map(function (c, i) { return c + start[i]; });
            buffer.set.apply(buffer, [x.get.apply(x, coords)].concat(outCoords));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.transpose = function (x, perm) {
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[perm[i]];
        }
        var values = x.dataSync();
        var result = ops_1.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < x.size; ++i) {
            var loc = xBuf.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                newLoc[i_2] = loc[perm[i_2]];
            }
            var newIndex = result.locToIndex(newLoc);
            result.values[newIndex] = values[i];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.gather = function (x, indices, axis) {
        var newShape = x.shape.slice();
        var indicesValues = indices.dataSync();
        newShape[axis] = indicesValues.length;
        var result = ops_1.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = newLoc.slice();
            originalLoc[axis] = indicesValues[newLoc[axis]];
            var originalIndex = xBuf.locToIndex(originalLoc);
            result.values[i] = xBuf.values[originalIndex];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.pool = function (x, convInfo, poolType) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var y = ops.buffer(convInfo.outShape, 'float32');
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                            Number.POSITIVE_INFINITY);
                        var avgValue = 0;
                        var count = 0;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var pixel = x.get(b, xR, xC, d);
                                if ((poolType === 'max' && pixel > minMaxValue)) {
                                    minMaxValue = pixel;
                                }
                                else if (poolType === 'avg') {
                                    avgValue += pixel;
                                    count++;
                                }
                            }
                            if (isNaN(minMaxValue)) {
                                break;
                            }
                        }
                        y.set(poolType === 'avg' ? avgValue / count : minMaxValue, b, yR, yC, d);
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.maxPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'max');
    };
    MathBackendCPU.prototype.maxPoolPositions = function (x, convInfo) {
        var maxPositions = ops.buffer(convInfo.outShape, 'int32');
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var maxValue = Number.NEGATIVE_INFINITY;
                        var maxPosition = -1;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            var wR = xR - xRCorner;
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var wC = xC - xCCorner;
                                var pixel = x.get(b, xR, xC, d);
                                if (pixel > maxValue) {
                                    maxValue = pixel;
                                    maxPosition = wR * filterWidth + wC;
                                }
                            }
                        }
                        maxPositions.set(maxPosition, b, yR, yC, d);
                    }
                }
            }
        }
        return maxPositions.toTensor();
    };
    MathBackendCPU.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
        var maxPositions = this.maxPoolPositions(x, convInfo);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.buffer(x.shape, 'float32');
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var maxPos = filterHeight * filterWidth - 1 -
                                    maxPositions.get(b, dyR, dyC, d);
                                var curPos = wR * filterWidth + wC;
                                var mask = maxPos === curPos ? 1 : 0;
                                if (mask === 0) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel * mask;
                            }
                        }
                        dx.set(dotProd, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.buffer(x.shape, 'float32');
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel;
                            }
                        }
                        dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.cast = function (x, dtype) {
        return backend_util.castTensor(x, dtype, this);
    };
    MathBackendCPU.prototype.reshape = function (x, shape) {
        return backend_util.reshapeTensor(x, shape);
    };
    MathBackendCPU.prototype.avgPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'avg').toFloat();
    };
    MathBackendCPU.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
        var output = ops.buffer([batch, newHeight, newWidth, numChannels], x.dtype);
        var effectiveInputSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        var effectiveOutputSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < newHeight; r++) {
                for (var c = 0; c < newWidth; c++) {
                    for (var d = 0; d < numChannels; d++) {
                        var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                        var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                        var sourceRowFloor = Math.floor(sourceFracRow);
                        var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
                        var sourceColFloor = Math.floor(sourceFracCol);
                        var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
                        var topLeft = x.get(b, sourceRowFloor, sourceColFloor, d);
                        var bottomLeft = x.get(b, sourceRowCeil, sourceColFloor, d);
                        var topRight = x.get(b, sourceRowFloor, sourceColCeil, d);
                        var bottomRight = x.get(b, sourceRowCeil, sourceColCeil, d);
                        var rowFrac = sourceFracRow - sourceRowFloor;
                        var colFrac = sourceFracCol - sourceColFloor;
                        var top_1 = topLeft + (topRight - topLeft) * colFrac;
                        var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                        var newValue = top_1 + (bottom - top_1) * rowFrac;
                        output.set(newValue, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
        var _a = x.shape, batch = _a[0], xHeight = _a[1], xWidth = _a[2], depth = _a[3];
        var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
        var output = ops.buffer([batch, xHeight, xWidth, depth], x.dtype);
        var effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        var effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        var heightScale = effectiveXSize[0] / effectiveYSize[0];
        var widthScale = effectiveXSize[1] / effectiveYSize[1];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < yHeight; r++) {
                var dxR = r * heightScale;
                var topDxRIndex = Math.floor(dxR);
                var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
                var dxRLerp = dxR - topDxRIndex;
                var inverseDxRLerp = 1.0 - dxRLerp;
                for (var c = 0; c < yWidth; c++) {
                    var dxC = c * widthScale;
                    var leftDxCIndex = Math.floor(dxC);
                    var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
                    var dxCLerp = dxC - leftDxCIndex;
                    var inverseDxCLerp = 1.0 - dxCLerp;
                    for (var d = 0; d < depth; d++) {
                        var dyVal = dy.get(b, r, c, d);
                        var topLeft = output.get(b, topDxRIndex, leftDxCIndex, d);
                        topLeft += dyVal * inverseDxRLerp * inverseDxCLerp;
                        output.set(topLeft, b, topDxRIndex, leftDxCIndex, d);
                        var topRight = output.get(b, topDxRIndex, rightDxCIndex, d);
                        topRight += dyVal * inverseDxRLerp * dxCLerp;
                        output.set(topRight, b, topDxRIndex, rightDxCIndex, d);
                        var bottomLeft = output.get(b, bottomDxRIndex, leftDxCIndex, d);
                        bottomLeft += dyVal * dxRLerp * inverseDxCLerp;
                        output.set(bottomLeft, b, bottomDxRIndex, leftDxCIndex, d);
                        var bottomRight = output.get(b, bottomDxRIndex, rightDxCIndex, d);
                        bottomRight += dyVal * dxRLerp * dxCLerp;
                        output.set(bottomRight, b, bottomDxRIndex, rightDxCIndex, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
        var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
        var output = ops.buffer([batch, newHeight, newWidth, numChannels], x.dtype);
        var effectiveInputSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
        var effectiveOutputSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < newHeight; r++) {
                for (var c = 0; c < newWidth; c++) {
                    for (var d = 0; d < numChannels; d++) {
                        var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                        var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                        var sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) :
                            Math.floor(sourceFracRow));
                        var sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :
                            Math.floor(sourceFracCol));
                        var newValue = x.get(b, sourceNearestRow, sourceNearestCol, d);
                        output.set(newValue, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.dataSync();
        var meanValues = mean.dataSync();
        var varianceValues = variance.dataSync();
        var scaleValues = scale ? scale.dataSync() : new Float32Array([1]);
        var offsetValues = offset ? offset.dataSync() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ops_1.tensor4d(outValues, x.shape);
    };
    MathBackendCPU.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
        var output = ops.buffer(x.shape, 'float32');
        var rad = radius;
        var maxD = output.shape[3] - 1;
        function sumAcrossChannels(b, r, c, d) {
            var sum = 0.0;
            for (var j = Math.max(0, d - rad); j <= Math.min(d + rad, maxD); j++) {
                var z = x.get(b, r, c, j);
                sum += z * z;
            }
            return sum;
        }
        for (var b = 0; b < output.shape[0]; b++) {
            for (var r = 0; r <= output.shape[1]; r++) {
                for (var c = 0; c < output.shape[2]; c++) {
                    for (var d = 0; d < output.shape[3]; d++) {
                        var sum = sumAcrossChannels(b, r, c, d);
                        var val = x.get(b, r, c, d) * Math.pow(bias + alpha * sum, -beta);
                        output.set(val, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.multinomial = function (logits, normalized, numSamples, seed) {
        var probabilities = normalized ? logits : ops.softmax(logits);
        var batchSize = probabilities.shape[0];
        var numEvents = probabilities.shape[1];
        var res = ops.zeros([batchSize, numSamples], 'int32');
        var resVals = res.dataSync();
        var probVals = probabilities.dataSync();
        for (var b = 0; b < batchSize; ++b) {
            var offset = b * numEvents;
            var cdf = new Float32Array(numEvents - 1);
            cdf[0] = probVals[offset];
            for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
            }
            var random = seedrandom.alea(seed.toString());
            var outOffset = b * numSamples;
            for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                var r = random();
                resVals[outOffset + sampleId] = cdf.length;
                for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                    if (r < cdf[event_2]) {
                        resVals[outOffset + sampleId] = event_2;
                        break;
                    }
                }
            }
        }
        return res;
    };
    MathBackendCPU.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        for (var event_3 = 0; event_3 < indices.size; ++event_3) {
            res[event_3 * depth + indices.get(event_3)] = onValue;
        }
        return ops.tensor2d(res, [indices.size, depth]);
    };
    MathBackendCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var result = ops.buffer(newShape, dtype);
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var aBuf = a.buffer();
        var bBuf = b.buffer();
        var _loop_2 = function (i) {
            var loc = result.indexToLoc(i);
            var aLoc = loc.slice(-a.rank);
            aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
            var aIndex = aBuf.locToIndex(aLoc);
            var bLoc = loc.slice(-b.rank);
            bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
            var bIndex = bBuf.locToIndex(bLoc);
            result.values[i] = op(aValues[aIndex], bValues[bIndex]);
        };
        for (var i = 0; i < result.values.length; ++i) {
            _loop_2(i);
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.dispose = function () { };
    return MathBackendCPU;
}());
exports.MathBackendCPU = MathBackendCPU;
environment_1.ENV.registerBackend('cpu', function () { return new MathBackendCPU(); }, 1);

},{"../environment":48,"../ops/axis_util":104,"../ops/broadcast_util":107,"../ops/concat_util":110,"../ops/erf_util":113,"../ops/ops":124,"../ops/selu_util":130,"../ops/slice_util":132,"../tensor":149,"../types":154,"../util":155,"./backend_util":63,"seedrandom":208}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var array_ops_1 = require("../ops/array_ops");
function castTensor(x, dtype, backend) {
    if (!__1.util.hasEncodingLoss(x.dtype, dtype)) {
        return __1.Tensor.make(x.shape, { dataId: x.dataId }, dtype);
    }
    if (dtype === 'int32') {
        return backend.int(x);
    }
    else if (dtype === 'bool') {
        return backend.notEqual(x, array_ops_1.ArrayOps.scalar(0, x.dtype));
    }
    else {
        throw new Error("Error in Cast: unknown dtype argument (" + dtype + ")");
    }
}
exports.castTensor = castTensor;
function reshapeTensor(x, shape) {
    return __1.Tensor.make(shape, { dataId: x.dataId }, x.dtype);
}
exports.reshapeTensor = reshapeTensor;

},{"..":51,"../ops/array_ops":103}],64:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var axis_util = require("../ops/axis_util");
var ops = require("../ops/ops");
var reduce_util = require("../ops/reduce_util");
var slice_util_1 = require("../ops/slice_util");
var tensor_1 = require("../tensor");
var types = require("../types");
var util = require("../util");
var backend_util = require("./backend_util");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var avg_pool_backprop_gpu_1 = require("./webgl/avg_pool_backprop_gpu");
var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
var binaryop_gpu = require("./webgl/binaryop_gpu");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var clip_gpu_1 = require("./webgl/clip_gpu");
var concat_gpu_1 = require("./webgl/concat_gpu");
var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
var conv_backprop_gpu_depthwise_1 = require("./webgl/conv_backprop_gpu_depthwise");
var conv_gpu_1 = require("./webgl/conv_gpu");
var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
var cumsum_gpu_1 = require("./webgl/cumsum_gpu");
var from_pixels_gpu_1 = require("./webgl/from_pixels_gpu");
var gather_gpu_1 = require("./webgl/gather_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var gpgpu_math = require("./webgl/gpgpu_math");
var gpgpu_util = require("./webgl/gpgpu_util");
var logical_gpu_1 = require("./webgl/logical_gpu");
var lrn_gpu_1 = require("./webgl/lrn_gpu");
var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
var onehot_gpu_1 = require("./webgl/onehot_gpu");
var pad_gpu_1 = require("./webgl/pad_gpu");
var pool_gpu_1 = require("./webgl/pool_gpu");
var reduce_gpu_1 = require("./webgl/reduce_gpu");
var resize_bilinear_backprop_gpu_1 = require("./webgl/resize_bilinear_backprop_gpu");
var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
var resize_nearest_neighbor_gpu_1 = require("./webgl/resize_nearest_neighbor_gpu");
var reverse_gpu_1 = require("./webgl/reverse_gpu");
var slice_gpu_1 = require("./webgl/slice_gpu");
var strided_slice_gpu_1 = require("./webgl/strided_slice_gpu");
var tex_util_1 = require("./webgl/tex_util");
var texture_manager_1 = require("./webgl/texture_manager");
var tile_gpu_1 = require("./webgl/tile_gpu");
var transpose_gpu_1 = require("./webgl/transpose_gpu");
var unary_op = require("./webgl/unaryop_gpu");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var webgl_util = require("./webgl/webgl_util");
var BEFORE_PAGING_CONSTANT = 300;
var MathBackendWebGL = (function () {
    function MathBackendWebGL(gpgpu, delayedStorage) {
        if (delayedStorage === void 0) { delayedStorage = true; }
        this.gpgpu = gpgpu;
        this.delayedStorage = delayedStorage;
        this.texData = new WeakMap();
        this.pendingRead = new WeakMap();
        this.pendingDisposal = new WeakSet();
        this.lruDataGPU = [];
        this.numBytesInGPU = 0;
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        this.binaryCache = {};
        this.disposed = false;
        if (environment_1.ENV.get('WEBGL_VERSION') < 1) {
            throw new Error('WebGL is not supported on this device');
        }
        if (environment_1.ENV.get('IS_BROWSER')) {
            this.canvas = document.createElement('canvas');
        }
        if (gpgpu == null) {
            this.gpgpu = new gpgpu_context_1.GPGPUContext(gpgpu_util.createWebGLContext(this.canvas));
            this.gpgpuCreatedLocally = true;
        }
        else {
            this.gpgpuCreatedLocally = false;
        }
        this.NUM_BYTES_BEFORE_PAGING =
            (window.screen.height * window.screen.width * window.devicePixelRatio) *
                BEFORE_PAGING_CONSTANT;
        this.textureManager = new texture_manager_1.TextureManager(this.gpgpu);
    }
    MathBackendWebGL.prototype.register = function (dataId, shape, dtype) {
        if (this.texData.has(dataId)) {
            throw new Error('Data buffer is already registered');
        }
        this.texData.set(dataId, {
            shape: shape,
            dtype: dtype,
            values: null,
            texture: null,
            texShape: null,
            texType: tex_util_1.TextureType.FLOAT
        });
    };
    MathBackendWebGL.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('MathBackendWebGL.writePixels(): pixels can not be null');
        }
        var texShape = [pixels.height, pixels.width];
        var outShape = [pixels.height, pixels.width, numChannels];
        if (pixels instanceof HTMLVideoElement) {
            if (this.fromPixelsCanvas == null) {
                if (!environment_1.ENV.get('IS_BROWSER')) {
                    throw new Error('Can\'t read pixels from HTMLImageElement outside the browser.');
                }
                if (document.readyState !== 'complete') {
                    throw new Error('The DOM is not ready yet. Please call tf.fromPixels() ' +
                        'once the DOM is ready. One way to do that is to add an event ' +
                        'listener for `DOMContentLoaded` on the document object');
                }
                this.fromPixelsCanvas = document.createElement('canvas');
            }
            this.fromPixelsCanvas.width = pixels.width;
            this.fromPixelsCanvas.height = pixels.height;
            this.fromPixelsCanvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            pixels = this.fromPixelsCanvas;
        }
        var tempPixelArray = tensor_1.Tensor.make(texShape, {}, 'int32');
        this.texData.get(tempPixelArray.dataId).texType = tex_util_1.TextureType.UNSIGNED_BYTE;
        this.gpgpu.uploadPixelDataToTexture(this.getTexture(tempPixelArray.dataId), pixels);
        var program = new from_pixels_gpu_1.FromPixelsProgram(outShape);
        var res = this.compileAndRun(program, [tempPixelArray]);
        tempPixelArray.dispose();
        return res;
    };
    MathBackendWebGL.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendWebGL.write(): values can not be null');
        }
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var texture = texData.texture, texShape = texData.texShape, texType = texData.texType;
        if (texture != null) {
            this.releaseTexture(dataId, texture, texShape, texType);
            texData.texture = null;
            texData.texShape = null;
        }
        texData.values = values;
        if (!this.delayedStorage) {
            this.uploadToGPU(dataId);
        }
    };
    MathBackendWebGL.prototype.readSync = function (dataId) {
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var texture = texData.texture, values = texData.values, texShape = texData.texShape;
        if (values != null) {
            this.cacheOnCPU(dataId);
            return values;
        }
        var shouldTimeProgram = this.activeTimers != null;
        var start;
        if (shouldTimeProgram) {
            start = performance.now();
        }
        var float32Values = this.gpgpu.downloadMatrixFromTexture(texture, texShape[0], texShape[1]);
        if (shouldTimeProgram) {
            this.downloadWaitMs += performance.now() - start;
        }
        this.cacheOnCPU(dataId, float32Values);
        return texData.values;
    };
    MathBackendWebGL.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            var subscribers_1, texData, texture, values, texShape, float32Values, subscribers, vals;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.pendingRead.has(dataId)) {
                            subscribers_1 = this.pendingRead.get(dataId);
                            return [2, new Promise(function (resolve) { return subscribers_1.push(resolve); })];
                        }
                        this.throwIfNoData(dataId);
                        texData = this.texData.get(dataId);
                        texture = texData.texture, values = texData.values, texShape = texData.texShape;
                        if (values != null) {
                            this.cacheOnCPU(dataId);
                            return [2, values];
                        }
                        if (!environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) return [3, 2];
                        return [4, this.gpgpu.downloadMatrixFromTextureAsync(texture, texShape[0], texShape[1])];
                    case 1:
                        float32Values = _a.sent();
                        this.cacheOnCPU(dataId, float32Values);
                        return [2, texData.values];
                    case 2:
                        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 0) {
                            return [2, this.readSync(dataId)];
                        }
                        this.pendingRead.set(dataId, []);
                        return [4, this.gpgpu.runQuery(function () { })];
                    case 3:
                        _a.sent();
                        subscribers = this.pendingRead.get(dataId);
                        this.pendingRead.delete(dataId);
                        vals = this.readSync(dataId);
                        subscribers.forEach(function (resolve) { return resolve(vals); });
                        if (this.pendingDisposal.has(dataId)) {
                            this.pendingDisposal.delete(dataId);
                            this.disposeData(dataId);
                        }
                        return [2, vals];
                }
            });
        });
    };
    MathBackendWebGL.prototype.time = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var oldActiveTimers, newActiveTimers, outerMostTime, flattenedActiveTimers, kernelMs, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        oldActiveTimers = this.activeTimers;
                        newActiveTimers = [];
                        outerMostTime = false;
                        if (this.programTimersStack == null) {
                            this.programTimersStack = newActiveTimers;
                            outerMostTime = true;
                        }
                        else {
                            this.activeTimers.push(newActiveTimers);
                        }
                        this.activeTimers = newActiveTimers;
                        f();
                        flattenedActiveTimers = util.flatten(this.activeTimers);
                        this.activeTimers = oldActiveTimers;
                        if (outerMostTime) {
                            this.programTimersStack = null;
                        }
                        return [4, Promise.all(flattenedActiveTimers).then(function (results) {
                                var sum = 0;
                                results.forEach(function (result) { return sum += result; });
                                return sum;
                            })];
                    case 1:
                        kernelMs = _a.sent();
                        res = {
                            uploadWaitMs: this.uploadWaitMs,
                            downloadWaitMs: this.downloadWaitMs,
                            kernelMs: kernelMs,
                            wallMs: null
                        };
                        this.uploadWaitMs = 0;
                        this.downloadWaitMs = 0;
                        return [2, res];
                }
            });
        });
    };
    MathBackendWebGL.prototype.memory = function () {
        return { unreliable: false, numBytesInGPU: this.numBytesInGPU };
    };
    MathBackendWebGL.prototype.startTimer = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            return this.gpgpu.beginQuery();
        }
        return { startMs: performance.now(), endMs: null };
    };
    MathBackendWebGL.prototype.endTimer = function (query) {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            this.gpgpu.endQuery();
            return query;
        }
        query.endMs = performance.now();
        return query;
    };
    MathBackendWebGL.prototype.getQueryTime = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var timerQuery;
            return __generator(this, function (_a) {
                if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
                    return [2, this.gpgpu.pollQueryTime(query)];
                }
                timerQuery = query;
                return [2, timerQuery.endMs - timerQuery.startMs];
            });
        });
    };
    MathBackendWebGL.prototype.disposeData = function (dataId) {
        if (this.pendingDisposal.has(dataId)) {
            return;
        }
        if (this.pendingRead.has(dataId)) {
            this.pendingDisposal.add(dataId);
            return;
        }
        if (this.texData.has(dataId)) {
            var _a = this.texData.get(dataId), texture = _a.texture, texShape = _a.texShape, texType = _a.texType;
            if (texture != null) {
                this.releaseTexture(dataId, texture, texShape, texType);
            }
            this.texData.delete(dataId);
        }
    };
    MathBackendWebGL.prototype.getTexture = function (dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture;
    };
    MathBackendWebGL.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    MathBackendWebGL.prototype.getCanvas = function () {
        return this.canvas;
    };
    MathBackendWebGL.prototype.slice = function (x, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
        var _a = slice_util_1.getStridedSlicedInfo(x.shape, begin, end, strides, beginMask, endMask), beginIndex = _a[0], size = _a[1];
        if (size.some(function (axis) { return axis === 0; })) {
            return ops.tensor([], size);
        }
        var program = new strided_slice_gpu_1.StridedSliceProgram(beginIndex, strides, size);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.reverse = function (x, axis) {
        var program = new reverse_gpu_1.ReverseProgram(x.shape, axis);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.concat = function (a, b) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.neg = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.NEG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.matMul = function (a, b, transposeA, transposeB) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, transposeA, transposeB);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.multiply = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
        var program = new lrn_gpu_1.LRNProgram(x.shape, radius, bias, alpha, beta);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tile = function (x, reps) {
        var program = new tile_gpu_1.TileProgram(x.shape, reps);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.pad = function (x, paddings, constantValue) {
        var program = new pad_gpu_1.PadProgram(x.shape, paddings, constantValue);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.transpose = function (x, perm) {
        var program = new transpose_gpu_1.TransposeProgram(x.shape, perm);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.gather = function (x, indices, axis) {
        var program = new gather_gpu_1.GatherProgram(x.shape, indices.size, axis);
        return this.compileAndRun(program, [x, indices]);
    };
    MathBackendWebGL.prototype.reduce = function (x, reduceType, dtype) {
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], dtype);
        this.compileAndRun(program, [x], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    MathBackendWebGL.prototype.argReduce = function (x, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], 'int32');
        var inputs = [x];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(x, reduceType, output);
    };
    MathBackendWebGL.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        var outputDType = types.sumOutType(x.dtype);
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    MathBackendWebGL.prototype.argMin = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    MathBackendWebGL.prototype.argMax = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    MathBackendWebGL.prototype.cumsum = function (x, axis, exclusive, reverse) {
        if (axis !== x.rank - 1) {
            throw new Error("WebGL cumsum shader expects an inner-most axis=" + (x.rank - 1) + " " +
                ("but got axis=" + axis));
        }
        var program = new cumsum_gpu_1.CumSumProgram(x.shape, exclusive, reverse);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.equal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.notEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.less = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.lessEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greater = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greaterEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalNot = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.logicalAnd = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalOr = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.where = function (condition, a, b, dtype) {
        var program = new logical_gpu_1.WhereProgram(condition.rank, a.shape, a.rank);
        var output = this.makeOutputArray(program.outputShape, dtype);
        return this.compileAndRun(program, [condition, a, b], output);
    };
    MathBackendWebGL.prototype.topKValues = function (x, k) {
        throw new Error('topKValues GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.topKIndices = function (x, k) {
        throw new Error('topKIndices GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.minimum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.mod = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MOD, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.maximum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.squaredDifference = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SQUARED_DIFFERENCE, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.realDivide = function (a, b) {
        var op = binaryop_gpu.DIV;
        var outputDtype = 'float32';
        var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, outputDtype);
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.floorDiv = function (a, b) {
        var op = binaryop_gpu.INT_DIV;
        var outputDtype = 'int32';
        var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, outputDtype);
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.add = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.subtract = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.pow = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.ceil = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.CEIL);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.floor = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sign = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.round = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ROUND);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.exp = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXP);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.expm1 = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXPM1);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.log = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.log1p = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG1P);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sqrt = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQRT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.rsqrt = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RSQRT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.square = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.reciprocal = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RECIPROCAL);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.relu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.elu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.eluDer = function (dy, y) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ELU_DER, dy.shape, y.shape);
        return this.compileAndRun(program, [dy, y]);
    };
    MathBackendWebGL.prototype.selu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.int = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TO_INT);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.clip = function (x, min, max) {
        var program = new clip_gpu_1.ClipProgram(x.shape, min, max);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.abs = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ABS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sigmoid = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.softplus = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SOFTPLUS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.asin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.acos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atan2 = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ATAN2, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.sinh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SINH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cosh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COSH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tanh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TANH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.asinh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASINH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.acosh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOSH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atanh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATANH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.erf = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ERF);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.step = function (x, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.conv2d = function (x, filter, convInfo) {
        var program = new conv_gpu_1.Conv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
    };
    MathBackendWebGL.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_depthwise_1.DepthwiseConv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.depthwiseConv2DDerFilter = function (x, dy, convInfo) {
        var program = new conv_backprop_gpu_depthwise_1.DepthwiseConv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
    };
    MathBackendWebGL.prototype.maxPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        var output = this.makeOutputArray(program.outputShape, x.dtype);
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.avgPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(maxPoolBackPropProgram.outputShape, x.dtype);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions], output);
        maxPoolPositions.dispose();
        return result;
    };
    MathBackendWebGL.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var avgPoolBackpropProgram = new avg_pool_backprop_gpu_1.AvgPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(avgPoolBackpropProgram.outputShape, x.dtype);
        return this.compileAndRun(avgPoolBackpropProgram, [dy], output);
    };
    MathBackendWebGL.prototype.cast = function (x, dtype) {
        return backend_util.castTensor(x, dtype, this);
    };
    MathBackendWebGL.prototype.reshape = function (x, shape) {
        return backend_util.reshapeTensor(x, shape);
    };
    MathBackendWebGL.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
        var program = new resize_bilinear_backprop_gpu_1.ResizeBilinearBackpropProgram(dy, x, alignCorners);
        return this.compileAndRun(program, [dy]);
    };
    MathBackendWebGL.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
        var program = new resize_nearest_neighbor_gpu_1.ResizeNearestNeighborProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.multinomial = function (logits, normalized, numSamples, seed) {
        var probs = normalized ? logits : ops.softmax(logits);
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {
        return tensor_1.Tensor.make(shape, {}, dtype);
    };
    MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup) {
        var _this = this;
        if (output == null) {
            output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        var inputsData = inputs.map(function (input) {
            _this.uploadToGPU(input.dataId);
            return { tensor: input, texData: _this.texData.get(input.dataId) };
        });
        this.uploadToGPU(output.dataId);
        var outputData = {
            tensor: output,
            texData: this.texData.get(output.dataId)
        };
        var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputsData, outputData);
        });
        var shouldTimeProgram = this.activeTimers != null;
        var query;
        if (shouldTimeProgram) {
            query = this.startTimer();
        }
        gpgpu_math.runProgram(binary, inputsData, outputData, customSetup);
        if (this.numBytesInGPU > this.NUM_BYTES_BEFORE_PAGING) {
            var numBytesToPage = this.numBytesInGPU - this.NUM_BYTES_BEFORE_PAGING;
            while (numBytesToPage > 0) {
                var dataId = this.lruDataGPU.shift();
                var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
                numBytesToPage -= this.computeBytes(shape, dtype);
                this.read(dataId);
            }
        }
        if (shouldTimeProgram) {
            query = this.endTimer(query);
            this.activeTimers.push(this.getQueryTime(query));
        }
        return output;
    };
    MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    MathBackendWebGL.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    MathBackendWebGL.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        this.canvas.remove();
        if (this.fromPixelsCanvas != null) {
            this.fromPixelsCanvas.remove();
        }
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
        this.disposed = true;
    };
    MathBackendWebGL.prototype.throwIfNoData = function (dataId) {
        if (!this.texData.has(dataId)) {
            throw new Error("WebGL backend: No data found for this tensor. " +
                "Did you change your backend in the middle of the program? " +
                "New backends can't use Tensors created with previous backends");
        }
    };
    MathBackendWebGL.prototype.uploadToGPU = function (dataId) {
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var shape = texData.shape, values = texData.values, texture = texData.texture, dtype = texData.dtype, texType = texData.texType;
        if (texture != null) {
            this.lruDataGPU.splice(this.lruDataGPU.indexOf(dataId), 1);
            this.lruDataGPU.push(dataId);
            return;
        }
        var shouldTimeProgram = this.activeTimers != null;
        var start;
        if (shouldTimeProgram) {
            start = performance.now();
        }
        var texShape = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        texData.texShape = texShape;
        var newTexture = this.acquireTexture(dataId, texShape, texType);
        texData.texture = newTexture;
        if (values != null) {
            this.gpgpu.uploadMatrixToTexture(newTexture, texShape[0], texShape[1], typedArrayToFloat32(values, dtype));
            texData.values = null;
            if (shouldTimeProgram) {
                this.uploadWaitMs += performance.now() - start;
            }
        }
    };
    MathBackendWebGL.prototype.cacheOnCPU = function (dataId, float32Values) {
        var dontKeepCopyOnGPU = this.delayedStorage;
        var texData = this.texData.get(dataId);
        var texture = texData.texture, texShape = texData.texShape, dtype = texData.dtype, texType = texData.texType;
        if (dontKeepCopyOnGPU && texture != null) {
            this.releaseTexture(dataId, texture, texShape, texType);
            texData.texture = null;
            texData.texShape = null;
        }
        if (float32Values != null) {
            texData.values = float32ToTypedArray(float32Values, dtype);
        }
    };
    MathBackendWebGL.prototype.releaseTexture = function (dataId, texture, texShape, texType) {
        var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
        var idx = this.lruDataGPU.indexOf(dataId);
        if (idx >= 0) {
            this.lruDataGPU.splice(idx, 1);
        }
        this.numBytesInGPU -= this.computeBytes(shape, dtype);
        this.textureManager.releaseTexture(texture, texShape, texType);
    };
    MathBackendWebGL.prototype.acquireTexture = function (dataId, texShape, texType) {
        var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
        this.lruDataGPU.push(dataId);
        this.numBytesInGPU += this.computeBytes(shape, dtype);
        return this.textureManager.acquireTexture(texShape, texType);
    };
    MathBackendWebGL.prototype.computeBytes = function (shape, dtype) {
        return util.sizeFromShape(shape) * util.bytesPerElement(dtype);
    };
    return MathBackendWebGL;
}());
exports.MathBackendWebGL = MathBackendWebGL;
if (environment_1.ENV.get('IS_BROWSER')) {
    environment_1.ENV.registerBackend('webgl', function () { return new MathBackendWebGL(); }, 2);
}
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        var result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (var i = 0; i < result.length; ++i) {
            result[i] = Math.round(a[i]);
        }
        return result;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
function typedArrayToFloat32(a, dtype) {
    return (a instanceof Float32Array) ? a : new Float32Array(a);
}

},{"../environment":48,"../ops/axis_util":104,"../ops/ops":124,"../ops/reduce_util":127,"../ops/slice_util":132,"../tensor":149,"../types":154,"../util":155,"./backend_util":63,"./webgl/argminmax_gpu":65,"./webgl/avg_pool_backprop_gpu":66,"./webgl/batchnorm_gpu":67,"./webgl/binaryop_gpu":68,"./webgl/clip_gpu":69,"./webgl/concat_gpu":70,"./webgl/conv_backprop_gpu":71,"./webgl/conv_backprop_gpu_depthwise":72,"./webgl/conv_gpu":73,"./webgl/conv_gpu_depthwise":74,"./webgl/cumsum_gpu":75,"./webgl/from_pixels_gpu":76,"./webgl/gather_gpu":77,"./webgl/gpgpu_context":78,"./webgl/gpgpu_math":79,"./webgl/gpgpu_util":80,"./webgl/logical_gpu":81,"./webgl/lrn_gpu":82,"./webgl/max_pool_backprop_gpu":83,"./webgl/mulmat_gpu":84,"./webgl/multinomial_gpu":85,"./webgl/onehot_gpu":86,"./webgl/pad_gpu":87,"./webgl/pool_gpu":88,"./webgl/reduce_gpu":89,"./webgl/resize_bilinear_backprop_gpu":90,"./webgl/resize_bilinear_gpu":91,"./webgl/resize_nearest_neighbor_gpu":92,"./webgl/reverse_gpu":93,"./webgl/slice_gpu":95,"./webgl/strided_slice_gpu":96,"./webgl/tex_util":97,"./webgl/texture_manager":98,"./webgl/tile_gpu":99,"./webgl/transpose_gpu":100,"./webgl/unaryop_gpu":101,"./webgl/webgl_util":102}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        var compOp = (op === 'max') ? '>' : '<';
        var indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AvgPool2DBackpropProgram = (function () {
    function AvgPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float avgMultiplier = float(" + avgMultiplier + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return AvgPool2DBackpropProgram;
}());
exports.AvgPool2DBackpropProgram = AvgPool2DBackpropProgram;

},{}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var BatchNormProgram = (function () {
    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.supportsBroadcasting = true;
        this.variableNames = ['x', 'mean', 'variance'];
        broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
        broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
        var offsetSnippet = '0.0';
        if (offsetShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        var scaleSnippet = '1.0';
        if (scaleShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale * inversesqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    }
    return BatchNormProgram;
}());
exports.BatchNormProgram = BatchNormProgram;

},{"../../ops/broadcast_util":107}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var CHECK_NAN_SNIPPET = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n";
exports.ADD = 'return a + b;';
exports.SUB = 'return a - b;';
exports.MUL = 'return a * b;';
exports.DIV = 'return a / b;';
exports.INT_DIV = "\n  float resultSign = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  int result = ia / ib;\n  int amodb = ia - ib * result;\n\n  if (resultSign < 0.0 && amodb != 0) {\n    result -= 1;\n  }\n  return float(result);\n";
exports.POW = "\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
exports.SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';
exports.EQUAL = "return float(a == b);";
exports.NOT_EQUAL = "return float(a != b);";
exports.LESS = "return float(a < b);";
exports.LESS_EQUAL = "return float(a <= b);";
exports.GREATER = "return float(a > b);";
exports.GREATER_EQUAL = "return float(a >= b);";
exports.LOGICAL_AND = "return float(a >= 1.0 && b >= 1.0);";
exports.LOGICAL_OR = "return float(a >= 1.0 || b >= 1.0);";
exports.MAX = CHECK_NAN_SNIPPET + "\n  return max(a, b);\n";
exports.MIN = CHECK_NAN_SNIPPET + "\n  return min(a, b);\n";
exports.MOD = "return mod(a, b);";
exports.ATAN2 = CHECK_NAN_SNIPPET + "\n  return atan(a, b);\n";
exports.ELU_DER = "return (b >= 1.0) ? a : a * (b + 1.0);";
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../../ops/broadcast_util":107}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClipProgram = (function () {
    function ClipProgram(aShape, min, max) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        var minFixed = min.toFixed(20);
        var maxFixed = max.toFixed(20);
        this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    ";
    }
    return ClipProgram;
}());
exports.ClipProgram = ClipProgram;

},{}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../../ops/concat_util");
var ConcatProgram = (function () {
    function ConcatProgram(aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        this.outputShape =
            concat_util.computeOutShape(aShape, bShape, 1);
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < " + aShape[1] + ") {\n          value = getA(yR, yC);\n        } else {\n          yC -= " + aShape[1] + ";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ConcatProgram;
}());
exports.ConcatProgram = ConcatProgram;

},{"../../ops/concat_util":110}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DDerFilterProgram = (function () {
    function Conv2DDerFilterProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerFilterProgram;
}());
exports.Conv2DDerFilterProgram = Conv2DDerFilterProgram;
var Conv2DDerInputProgram = (function () {
    function Conv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + convInfo.outChannels + "; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerInputProgram;
}());
exports.Conv2DDerInputProgram = Conv2DDerInputProgram;

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DDerFilterProgram = (function () {
    function DepthwiseConv2DDerFilterProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + channelMul + " + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DDerFilterProgram;
}());
exports.DepthwiseConv2DDerFilterProgram = DepthwiseConv2DDerFilterProgram;
var DepthwiseConv2DDerInputProgram = (function () {
    function DepthwiseConv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + channelMul + "; dm++) {\n              int d2 = d1 * " + channelMul + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DDerInputProgram;
}());
exports.DepthwiseConv2DDerInputProgram = DepthwiseConv2DDerInputProgram;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DProgram = (function () {
    function Conv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        var inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR * " + dilationHeight + ";\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC * " + dilationWidth + ";\n\n            if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DProgram;
}());
exports.Conv2DProgram = Conv2DProgram;

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DProgram = (function () {
    function DepthwiseConv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var xNumRows = convInfo.inHeight;
        var xNumCols = convInfo.inWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR * " + dilationHeight + ";\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC * " + dilationWidth + ";\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DProgram;
}());
exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var CumSumProgram = (function () {
    function CumSumProgram(shape, exclusive, reverse) {
        this.variableNames = ['x'];
        this.outputShape = shape;
        var rank = shape.length;
        var finalDim = shape[shape.length - 1];
        var comparator = reverse ? '<' : '>';
        this.userCode = "\n      int getIndex(int i) {\n        " + (reverse ? "return " + finalDim + " -i - 1;" : 'return i;') + "\n      }\n\n      void main() {\n        " + shader_compiler_1.getCoordsDataType(rank) + " coords = getOutputCoords();\n        int end = " + getFinalCoord(rank, 'coords') + ";\n        float val = 0.0;\n        for (int i = " + finalDim + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + comparator + " end) {\n            continue;\n          }\n          if (idx == end && " + exclusive + ") {\n            continue;\n          }\n          " + getFinalCoord(rank, 'coords') + " = idx;\n          val += getX(" + getCoords(rank, 'coords') + ");\n        }\n        setOutput(val);\n      }\n    ";
    }
    return CumSumProgram;
}());
exports.CumSumProgram = CumSumProgram;
function getCoords(rank, name) {
    if (rank === 1) {
        return "" + name;
    }
    else if (rank === 2) {
        return name + ".x, " + name + ".y";
    }
    else if (rank === 3) {
        return name + ".x, " + name + ".y, " + name + ".z";
    }
    else if (rank === 4) {
        return name + ".x, " + name + ".y, " + name + ".z, " + name + ".w";
    }
    else {
        throw Error("Cumulative sum for rank " + rank + " is not yet supported");
    }
}
function getFinalCoord(rank, name) {
    if (rank === 1) {
        return "" + name;
    }
    else if (rank === 2) {
        return name + ".y";
    }
    else if (rank === 3) {
        return name + ".z";
    }
    else if (rank === 4) {
        return name + ".w";
    }
    else {
        throw Error("Cumulative sum for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":94}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FromPixelsProgram = (function () {
    function FromPixelsProgram(outputShape) {
        this.variableNames = ['A'];
        var height = outputShape[0], width = outputShape[1];
        this.outputShape = outputShape;
        this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + width + ".0, " + height + ".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
    }
    return FromPixelsProgram;
}());
exports.FromPixelsProgram = FromPixelsProgram;

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var GatherProgram = (function () {
    function GatherProgram(aShape, indicesLength, axis) {
        this.variableNames = ['A', 'indices'];
        var outputShape = aShape.slice();
        outputShape[axis] = indicesLength;
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape, axis);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return GatherProgram;
}());
exports.GatherProgram = GatherProgram;
function getSourceCoords(aShape, axis) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Gather for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "int(getIndices(resRC))";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        if (i === axis) {
            sourceCoords.push("int(getIndices(" + currentCoords[i] + "))");
        }
        else {
            sourceCoords.push("" + currentCoords[i]);
        }
    }
    return sourceCoords.join();
}

},{"./shader_compiler":94}],78:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        this.vertexAttrsAreBound = false;
        this.itemsToPoll = [];
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
            this.colorBufferFloatExtension =
                this.gl.getExtension('WEBGL_color_buffer_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) {
            this.getBufferSubDataAsyncExtension =
                this.gl.getExtension('WEBGL_get_buffer_sub_data_async');
        }
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        if (this.disposed) {
            return;
        }
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.getBufferSubDataAsyncExtension == null) {
                    throw new Error("Cannot download matrix from output texture asynchronously, " +
                        "WEBGL_get_buffer_sub_data_async is not enabled.");
                }
                return [2, this.downloadMatrixDriverAsync(texture, function () { return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns); })];
            });
        });
    };
    GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels); });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        if (!this.vertexAttrsAreBound) {
            this.setProgram(program);
            this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (program, uniformName, shouldThrow) {
        if (shouldThrow === void 0) { shouldThrow = true; }
        this.throwIfDisposed();
        if (shouldThrow) {
            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
        }
        else {
            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);
        }
    };
    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
        var _this = this;
        this.throwIfDisposed();
        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
    };
    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function () {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.getQueryTimerExtension = function () {
        if (this.disjointQueryTimerExtension == null) {
            this.disjointQueryTimerExtension =
                webgl_util.getExtensionOrThrow(this.gl, environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?
                    'EXT_disjoint_timer_query_webgl2' :
                    'EXT_disjoint_timer_query');
        }
        return this.disjointQueryTimerExtension;
    };
    GPGPUContext.prototype.getQueryTimerExtensionWebGL2 = function () {
        return this.getQueryTimerExtension();
    };
    GPGPUContext.prototype.getQueryTimerExtensionWebGL1 = function () {
        return this.getQueryTimerExtension();
    };
    GPGPUContext.prototype.runQuery = function (queryFn) {
        var query = this.beginQuery();
        queryFn();
        this.endQuery();
        return this.pollQueryTime(query);
    };
    GPGPUContext.prototype.beginQuery = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            var gl2 = this.gl;
            var ext_1 = this.getQueryTimerExtensionWebGL2();
            var query_1 = gl2.createQuery();
            gl2.beginQuery(ext_1.TIME_ELAPSED_EXT, query_1);
            return query_1;
        }
        var ext = this.getQueryTimerExtensionWebGL1();
        var query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        return query;
    };
    GPGPUContext.prototype.endQuery = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            var gl2 = this.gl;
            var ext_2 = this.getQueryTimerExtensionWebGL2();
            gl2.endQuery(ext_2.TIME_ELAPSED_EXT);
            return;
        }
        var ext = this.getQueryTimerExtensionWebGL1();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    };
    GPGPUContext.prototype.isQueryAvailable = function (query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return true;
        }
        if (queryTimerVersion === 2) {
            var gl2 = this.gl;
            var ext = this.getQueryTimerExtensionWebGL2();
            var available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            if (this.disjoint == null) {
                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            }
            return available && !this.disjoint;
        }
        else {
            var ext = this.getQueryTimerExtensionWebGL1();
            var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
            if (this.disjoint == null) {
                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            }
            return available && !this.disjoint;
        }
    };
    GPGPUContext.prototype.pollQueryTime = function (query) {
        var _this = this;
        return new Promise(function (resolve) {
            var queryTimerVersion = environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION');
            _this.addItemToPoll(function () { return _this.isQueryAvailable(query, queryTimerVersion); }, function () { return resolve(_this.getQueryTime(query, queryTimerVersion)); });
        });
    };
    GPGPUContext.prototype.pollItems = function () {
        var index = binSearchLastTrue(this.itemsToPoll.map(function (x) { return x.isDoneFn; }));
        for (var i = 0; i <= index; ++i) {
            var resolveFn = this.itemsToPoll[i].resolveFn;
            resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index + 1);
    };
    GPGPUContext.prototype.addItemToPoll = function (isDoneFn, resolveFn) {
        var _this = this;
        this.itemsToPoll.push({ isDoneFn: isDoneFn, resolveFn: resolveFn });
        if (this.itemsToPoll.length > 1) {
            return;
        }
        util.repeatedTry(function () {
            _this.pollItems();
            return _this.itemsToPoll.length === 0;
        });
    };
    GPGPUContext.prototype.getQueryTime = function (query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return null;
        }
        if (queryTimerVersion === 2) {
            var gl2 = this.gl;
            var timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            return timeElapsedNanos / 1000000;
        }
        else {
            var ext = this.getQueryTimerExtensionWebGL1();
            var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
            return timeElapsedNanos / 1000000;
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(this.gl);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.downloadMatrixDriverSetup(texture);
        var result = downloadAndDecode();
        this.downloadMatrixDriverTeardown();
        return result;
    };
    GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.downloadMatrixDriverSetup(texture);
                        return [4, downloadAndDecode()];
                    case 1:
                        result = _a.sent();
                        this.downloadMatrixDriverTeardown();
                        return [2, result];
                }
            });
        });
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;
function binSearchLastTrue(arr) {
    var start = 0;
    var end = arr.length - 1;
    var best = -1;
    while (start <= end) {
        var mid = (start + end) >> 1;
        var isDone = arr[mid]();
        if (isDone) {
            best = mid;
            start = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
    return best;
}
exports.binSearchLastTrue = binSearchLastTrue;

},{"../../environment":48,"../../util":155,"./gpgpu_util":80,"./tex_util":97,"./webgl_util":102}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var shader_compiler = require("./shader_compiler");
var NAN_UNIFORM_NAME = 'NaN';
function shouldUploadNaNUniform() {
    return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
}
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = inputs.map(function (input, i) {
        var shapeInfo = {
            logicalShape: input.tensor.shape,
            texShape: input.texData.texShape
        };
        return { name: program.variableNames[i], shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.tensor.shape,
        texShape: output.texData.texShape
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    var webGLProgram = gpgpu.createProgram(source);
    var uniformLocations = {};
    for (var i = 0; i < program.variableNames.length; i++) {
        var uniformName = program.variableNames[i];
        uniformLocations[uniformName] =
            gpgpu.getUniformLocation(webGLProgram, uniformName);
    }
    if (shouldUploadNaNUniform()) {
        var throwIfNaNUniformIsNotUsed = false;
        uniformLocations[NAN_UNIFORM_NAME] = gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME, throwIfNaNUniformIsNotUsed);
    }
    return {
        program: program,
        source: source,
        webGLProgram: webGLProgram,
        uniformLocations: uniformLocations,
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
            ("was executed with " + inputs.length + " inputs"));
    }
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = inputs[i].tensor.shape;
        var texShapeB = inputs[i].texData.texShape;
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.texData.texture;
    var outTexShape = output.texData.texShape;
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.texData.texture;
        var variableName = binary.program.variableNames[i];
        var variableUniformLocation = binary.uniformLocations[variableName];
        gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
    });
    if (shouldUploadNaNUniform()) {
        gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
    }
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram();
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var keyInputs = '';
    inputs.concat(output).forEach(function (x) {
        keyInputs += x.tensor.shape + "_" + x.texData.texShape;
    });
    var keyUserCode = program.userCode;
    var keyBroadcast = (program.supportsBroadcasting === true).toString();
    var key = program.constructor.name;
    key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
    return key;
}
exports.makeShaderKey = makeShaderKey;

},{"../../environment":48,"../../util":155,"./shader_compiler":94}],80:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA;
        }
        return gl.RED;
    }
    return gl.RGBA;
}
function getTextureType(gl) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.UNSIGNED_BYTE;
    }
    return gl.FLOAT;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    var success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);
    return success &&
        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var unpackedArray;
    if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
        if (channelsPerTexture === 1) {
            unpackedArray = matrix;
        }
        else {
            unpackedArray =
                new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
            tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
        }
    }
    else {
        unpackedArray = tex_util.encodeFloatArray(matrix);
    }
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
var floatDownloadBuffer = null;
var byteDownloadBuffer = null;
function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    var neededSize = rows * columns * channelsPerTexture;
    if (isFloatTexture) {
        if (floatDownloadBuffer == null ||
            floatDownloadBuffer.length < neededSize) {
            floatDownloadBuffer = new Float32Array(neededSize);
        }
    }
    else {
        if (byteDownloadBuffer == null || byteDownloadBuffer.length < neededSize) {
            byteDownloadBuffer = new Uint8Array(neededSize);
        }
    }
    return (isFloatTexture ? floatDownloadBuffer : byteDownloadBuffer)
        .subarray(0, neededSize);
}
function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    if (isFloatTexture) {
        var matrix = new Float32Array(rows * columns);
        tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
        return matrix;
    }
    else {
        return tex_util.decodeToFloatArray(downloadTarget);
    }
}
function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
    return __awaiter(this, void 0, void 0, function () {
        var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    gl2 = gl;
                    channelsPerPixel = 4;
                    downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                    bufferSizeBytes = downloadTarget instanceof Float32Array ?
                        downloadTarget.length * 4 :
                        downloadTarget;
                    buffer = gl.createBuffer();
                    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });
                    webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW); });
                    webgl_util.callAndCheck(gl, function () {
                        return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
                    });
                    return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                case 1:
                    _a.sent();
                    return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
            }
        });
    });
}
exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerPixel = 4;
    var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });
    return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
    var size = rows * columns * 4;
    var downloadTarget = new Uint8Array(size);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget); });
    var packedRGBA = new Float32Array(size);
    for (var i = 0; i < downloadTarget.length; i++) {
        packedRGBA[i] = downloadTarget[i];
    }
    var matrix = new Float32Array(rows * columns * channels);
    tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
    return matrix;
}
exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"../../environment":48,"./tex_util":97,"./webgl_util":102}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var WhereProgram = (function () {
    function WhereProgram(cRank, shape, rank) {
        this.variableNames = ['c', 'a', 'b'];
        this.outputShape = shape;
        var cCoords;
        var abCoords;
        if (rank > 4) {
            throw Error("Where for rank " + rank + " is not yet supported");
        }
        if (rank === 1) {
            abCoords = "resRC";
            cCoords = "resRC";
        }
        else {
            var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
            var cCoordVars = [];
            var abCoordVars = [];
            for (var i = 0; i < shape.length; i++) {
                abCoordVars.push("" + currentCoords[i]);
                if (i < cRank) {
                    cCoordVars.push("" + currentCoords[i]);
                }
            }
            cCoords = cCoordVars.join();
            abCoords = abCoordVars.join();
        }
        var dtype = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        float cVal = getC(" + cCoords + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + abCoords + "));\n        } else {\n          setOutput(getB(" + abCoords + "));\n        }\n      }\n    ";
    }
    return WhereProgram;
}());
exports.WhereProgram = WhereProgram;

},{"./shader_compiler":94}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRNProgram = (function () {
    function LRNProgram(xShape, radius, bias, alpha, beta) {
        this.variableNames = ['x'];
        this.outputShape = [];
        var rad = radius;
        var maxD = xShape[3] - 1;
        this.outputShape = xShape;
        var powOperator;
        var basis = "float(" + bias + ") + float(" + alpha + ") * sum";
        if (beta === 0.5) {
            powOperator = "inversesqrt(" + basis + ")";
        }
        else if (beta === 1.0) {
            powOperator = "1.0/(" + basis + ")";
        }
        else {
            powOperator = "exp(log(" + basis + ") * float(-" + beta + "));";
        }
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + rad + "; j <= " + rad + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + maxD + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + powOperator + ";\n        setOutput(val);\n      }\n    ";
    }
    return LRNProgram;
}());
exports.LRNProgram = LRNProgram;

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MaxPool2DBackpropProgram = (function () {
    function MaxPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var lastIndex = filterHeight * filterWidth - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return MaxPool2DBackpropProgram;
}());
exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;

},{}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.variableNames = ['matrixA', 'matrixB'];
        var outerShapeA = transposeA ? aShape[1] : aShape[0];
        var outerShapeB = transposeB ? bShape[0] : bShape[1];
        var sharedDim = transposeA ? aShape[0] : aShape[1];
        this.outputShape = [outerShapeA, outerShapeB];
        var aSnippetFromOffset = function (vec4Offset, indexVar) {
            return transposeA ? indexVar + " + " + vec4Offset + ", aRow" :
                "aRow, " + indexVar + " + " + vec4Offset;
        };
        var bSnippetFromOffset = function (vec4Offset, indexVar) {
            return transposeB ? "bCol, " + indexVar + " + " + vec4Offset :
                indexVar + " + " + vec4Offset + ", bCol";
        };
        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
        var sharedDimVec4Remainder = sharedDim % 4;
        this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MultinomialProgram = (function () {
    function MultinomialProgram(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
    }
    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return MultinomialProgram;
}());
exports.MultinomialProgram = MultinomialProgram;

},{}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OneHotProgram = (function () {
    function OneHotProgram(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
    }
    return OneHotProgram;
}());
exports.OneHotProgram = OneHotProgram;

},{}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var PadProgram = (function () {
    function PadProgram(xShape, paddings, constantValue) {
        this.variableNames = ['x'];
        this.outputShape = paddings.map(function (p, i) { return p[0] + xShape[i] + p[1]; });
        var rank = xShape.length;
        var type = shader_compiler_1.getCoordsDataType(rank);
        var start = paddings.map(function (p) { return p[0]; }).join(',');
        var end = paddings.map(function (p, i) { return p[0] + xShape[i]; }).join(',');
        var unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);
        if (rank === 1) {
            this.userCode = "\n        int start = " + start + ";\n        int end = " + end + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + constantValue + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
            return;
        }
        this.userCode = "\n      " + type + " start = " + type + "(" + start + ");\n      " + type + " end = " + type + "(" + end + ");\n\n      void main() {\n        " + type + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + constantValue + "));\n        } else {\n          " + type + " coords = outC - start;\n          setOutput(getX(" + unpackedCoords + "));\n        }\n      }\n    ";
    }
    return PadProgram;
}());
exports.PadProgram = PadProgram;

},{"./shader_compiler":94}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool2DProgram = (function () {
    function Pool2DProgram(convInfo, poolType, computePositions) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        var isAvgPool = poolType === 'avg';
        var initializationValue = '0.0';
        if (!isAvgPool) {
            initializationValue = '-1.0 / 0.0';
        }
        if (computePositions) {
            var compareOp_1 = '>=';
            this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            return;
        }
        var compareOp = 'max';
        var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = "avgValue / count";
        }
        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        var filterWidthVec4Remainder = filterWidth % 4;
        var updateSnippet = "\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return Pool2DProgram;
}());
exports.Pool2DProgram = Pool2DProgram;

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceProgram = (function () {
    function ReduceProgram(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var isReduceSum = reduceType === 'sum';
        var initializationValue = '0.0';
        if (!isReduceSum) {
            if (reduceType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        var compareOp = reduceType === 'min' ? 'min' : 'max';
        var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = "sumValue";
        }
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        var checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return ReduceProgram;
}());
exports.ReduceProgram = ReduceProgram;

},{}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinearBackpropProgram = (function () {
    function ResizeBilinearBackpropProgram(dy, x, alignCorners) {
        this.variableNames = ['dy'];
        this.outputShape = [];
        this.outputShape = x.shape;
        var _a = x.shape, xHeight = _a[1], xWidth = _a[2];
        var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
        var effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        var effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        var heightScale = effectiveXSize[0] / effectiveYSize[0];
        var widthScale = effectiveXSize[1] / effectiveYSize[1];
        var invHeightScale = 1 / heightScale;
        var invWidthScale = 1 / widthScale;
        var winHeight = (Math.ceil(invHeightScale) * 2) + 2;
        var winWidth = (Math.ceil(invWidthScale) * 2) + 2;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + heightScale + ");\n        const float widthScale = float(" + widthScale + ");\n\n        const float invHeightScale = float(" + invHeightScale + ");\n        const float invWidthScale = float(" + invWidthScale + ");\n\n        const int winHeight = int(" + winHeight + ");\n        const int winWidth = int(" + winWidth + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + yHeight + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + yWidth + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (xHeight - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (xWidth - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
    }
    return ResizeBilinearBackpropProgram;
}());
exports.ResizeBilinearBackpropProgram = ResizeBilinearBackpropProgram;

},{}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinearProgram = (function () {
    function ResizeBilinearProgram(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];
        this.outputShape = [batch, newHeight, newWidth, depth];
        var effectiveInSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        var effectiveOutSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeBilinearProgram;
}());
exports.ResizeBilinearProgram = ResizeBilinearProgram;

},{}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeNearestNeighborProgram = (function () {
    function ResizeNearestNeighborProgram(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];
        this.outputShape = [batch, newHeight, newWidth, depth];
        var effectiveInSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
        var effectiveOutSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
        var roundBase = alignCorners ? '0.5' : '0.0';
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + roundBase + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeNearestNeighborProgram;
}());
exports.ResizeNearestNeighborProgram = ResizeNearestNeighborProgram;

},{}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var ReverseProgram = (function () {
    function ReverseProgram(xShape, axis) {
        this.variableNames = ['x'];
        var rank = xShape.length;
        if (rank > 4) {
            throw new Error("WebGL backend: Reverse of rank-" + rank + " tensor is not yet supported");
        }
        this.outputShape = xShape;
        if (rank === 1) {
            this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + xShape[0] + " - coord - 1));\n        }\n      ";
            return;
        }
        var getInCoord = function (i) {
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
                return xShape[i] + " - coords[" + i + "] - 1";
            }
            return "coords[" + i + "]";
        };
        var inCoords = xShape.map(function (_, i) { return getInCoord(i); }).join(',');
        var type = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + type + " coords = getOutputCoords();\n        setOutput(getX(" + inCoords + "));\n      }\n    ";
    }
    return ReverseProgram;
}());
exports.ReverseProgram = ReverseProgram;

},{"./shader_compiler":94}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var broadcast_util = require("../../ops/broadcast_util");
var tex_util = require("./tex_util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var sampleSnippet = getSampleSnippet();
    var setOutputSnippet = getSetOutputSnippet();
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
        outputSamplingSnippet, inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getSampleSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SAMPLE_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
}
function getSetOutputSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
}
function getSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        case 5:
            return getSampler5D(inInfo);
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var res = getSamplerFlat(inInfo);
    res += getSamplerFromInInfo(inInfo);
    if (broadcast ||
        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
    }
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        case 5:
            return getOutput5DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_5D_SNIPPET = "\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int row, int col, int depth,\n    int depth2, int depth3) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + \n              depth * stride2 + depth2 * stride3 + depth3;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    vec4 sampleValue = texture2D(textureSampler, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n";
var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  struct ivec5\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n  };\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n  " + SAMPLE_5D_SNIPPET + "\n";
function getOutputScalarCoords() {
    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
    }
    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function getOutput5DCoords(shape, texShape) {
    var stride3 = shape[4];
    var stride2 = shape[3] * stride3;
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + texShape[0] + ",\n                             " + texShape[1] + "));\n\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      index -= d * " + stride2 + ";\n\n      int d2 = index  / " + stride3 + ";\n      int d3 = index - d2 * " + stride3 + ";\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
    }
    if (shape[1] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
    }
    if (shape[0] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
    }
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function getSamplerScalar(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return sampleTexture(" + texName + ", halfCR);\n    }\n  ";
}
function getSampler1D(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
}
function getSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    if (texNumR === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sampleTexture(" + texName + ", uv);\n  }\n";
}
function getSampler3D(inputInfo) {
    var texShape = inputInfo.shapeInfo.texShape;
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col', 'depth'];
        return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
    }
    if (texNumC === stride0) {
        return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sampleTexture(" + texName + ", uv);\n        }\n      ";
    }
    if (texNumC === stride1) {
        return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sampleTexture(" + texName + ", uv);\n      }\n  ";
}
function getSampler4D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride2) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getSampler5D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride3 = shape[4];
    var stride2 = shape[3] * stride3;
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2', 'depth3'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " +\n                   depth2 * " + stride3 + " + depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride3) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " +\n                   depth * " + shape[3] + " + depth2;\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n      vec2 uv = UVfrom5D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", " + stride3 + ", row, col, depth, depth2, depth3);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getSamplerFlat(inputInfo) {
    var texName = inputInfo.name;
    var texShape = inputInfo.shapeInfo.texShape;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        return sampleTexture(" + texName + ", halfCR);\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var type = 'int';
    if (outRank === 2) {
        type = 'ivec2';
    }
    else if (outRank === 3) {
        type = 'ivec3';
    }
    else if (outRank === 4) {
        type = 'ivec4';
    }
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var rankDiff = outRank - inRank;
    var coordsSnippet;
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(function (d) { return "coords[" + (d + rankDiff) + "] = 0;"; }).join('\n');
    }
    var unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map(function (s, i) { return "coords[" + (i + rankDiff) + "]"; })
            .join(', ');
    }
    return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
    var inTexShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
    if (doBroadcast && !broadcastOverOuter) {
        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
    }
    var outTexShape = outShapeInfo.texShape;
    if (util.arraysEqual(inTexShape, outTexShape)) {
        return "\n      float " + funcName + "() {\n        return sampleTexture(" + texName + ", resultUV);\n      }\n    ";
    }
    var inSize = util.sizeFromShape(inTexShape);
    var broadcastSnippet = '';
    if (doBroadcast && broadcastOverOuter) {
        broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
    }
    return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexShape[1] + ";\n      int texC = index - texR * " + inTexShape[1] + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else if (rank === 5) {
        return 'ivec5';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;
function squeezeInputInfo(inInfo, squeezedShape) {
    var newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}

},{"../../environment":48,"../../ops/broadcast_util":107,"../../util":155,"./tex_util":97}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var SliceProgram = (function () {
    function SliceProgram(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getCoords(this.rank);
        this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
    }
    SliceProgram.prototype.getCustomSetupFunc = function (start) {
        var _this = this;
        if (start.length !== this.rank) {
            throw Error("The rank (" + this.rank + ") of the program must match the " +
                ("length of start (" + start.length + ")"));
        }
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (_this.startLoc == null) {
                    return;
                }
            }
            if (_this.rank === 1) {
                gpgpu.gl.uniform1i(_this.startLoc, start[0]);
            }
            else if (_this.rank === 2) {
                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
            }
            else if (_this.rank === 3) {
                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
            }
            else if (_this.rank === 4) {
                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
            }
            else {
                throw Error("Slicing for rank " + _this.rank + " is not yet supported");
            }
        };
    };
    return SliceProgram;
}());
exports.SliceProgram = SliceProgram;
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank === 2) {
        return 'sourceLoc.x, sourceLoc.y';
    }
    else if (rank === 3) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
    }
    else if (rank === 4) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
    }
    else {
        throw Error("Slicing for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":94}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var StridedSliceProgram = (function () {
    function StridedSliceProgram(begin, strides, shape) {
        this.variableNames = ['x'];
        this.outputShape = shape;
        this.rank = shape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var newCoords = '';
        if (this.rank === 1) {
            newCoords = 'coords * strides + begin';
        }
        else {
            newCoords =
                shape.map(function (_, i) { return "coords[" + i + "] * strides[" + i + "] + begin[" + i + "]"; })
                    .join(',');
        }
        this.userCode = "\n      " + dtype + " begin = " + dtype + "(" + begin + ");\n      " + dtype + " strides = " + dtype + "(" + strides + ");\n\n      void main() {\n        " + dtype + " coords = getOutputCoords();\n        setOutput(getX(" + newCoords + "));\n      }\n    ";
    }
    return StridedSliceProgram;
}());
exports.StridedSliceProgram = StridedSliceProgram;

},{"./shader_compiler":94}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureType;
(function (TextureType) {
    TextureType[TextureType["FLOAT"] = 0] = "FLOAT";
    TextureType[TextureType["UNSIGNED_BYTE"] = 1] = "UNSIGNED_BYTE";
})(TextureType = exports.TextureType || (exports.TextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
            ("" + channelsPerTexture));
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
            ("" + requiredSize));
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
exports.FLOAT_MAX = 20000;
exports.FLOAT_MIN = -exports.FLOAT_MAX;
var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
var FLOAT_POWERS = [1, 255, 255 * 255];
exports.BYTE_NAN_VALUE = 0;
function encodeFloatArray(floatArray) {
    var uintArray = new Uint8Array(floatArray.length * 4);
    var _loop_1 = function (i) {
        var value = floatArray[i / 4];
        if (isNaN(value)) {
            uintArray[i] = exports.BYTE_NAN_VALUE;
            uintArray[i + 1] = exports.BYTE_NAN_VALUE;
            uintArray[i + 2] = exports.BYTE_NAN_VALUE;
            uintArray[i + 3] = exports.BYTE_NAN_VALUE;
            return "continue";
        }
        var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
        var enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });
        var buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });
        uintArray[i] = Math.floor(normalizedValue);
        uintArray[i + 1] = buckets[0];
        uintArray[i + 2] = buckets[1];
        uintArray[i + 3] = buckets[2];
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_1(i);
    }
    return uintArray;
}
exports.encodeFloatArray = encodeFloatArray;
function decodeToFloatArray(uintArray) {
    var floatArray = new Float32Array(uintArray.length / 4);
    var _loop_2 = function (i) {
        if (uintArray[i] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
            floatArray[i / 4] = NaN;
            return "continue";
        }
        var dot = 0;
        FLOAT_DELTAS.forEach(function (delta, j) {
            dot += delta * uintArray[i + j];
        });
        var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
        floatArray[i / 4] = value;
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_2(i);
    }
    return floatArray;
}
exports.decodeToFloatArray = decodeToFloatArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    var requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += 4) {
        for (var c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tex_util_1 = require("./tex_util");
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextures = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC, texType) {
        if (texType === void 0) { texType = tex_util_1.TextureType.FLOAT; }
        var shapeKey = getKeyFromTextureShape(shapeRC, texType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextures)) {
            this.usedTextures[shapeKey] = [];
        }
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            var newTexture_1 = this.freeTextures[shapeKey].shift();
            this.usedTextures[shapeKey].push(newTexture_1);
            return newTexture_1;
        }
        this.numUsedTextures++;
        this.log();
        var newTexture = this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
        this.usedTextures[shapeKey].push(newTexture);
        return newTexture;
    };
    TextureManager.prototype.releaseTexture = function (texture, shape, texType) {
        if (texType === void 0) { texType = tex_util_1.TextureType.FLOAT; }
        var shapeKey = getKeyFromTextureShape(shape, texType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        var texList = this.usedTextures[shapeKey];
        var texIndex = texList.indexOf(texture);
        if (texIndex < 0) {
            throw new Error('Cannot release a texture that was never provided by this ' +
                'texture manager');
        }
        texList.splice(texIndex, 1);
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        var _this = this;
        if (this.freeTextures == null) {
            return;
        }
        for (var texShape in this.freeTextures) {
            this.freeTextures[texShape].forEach(function (tex) {
                _this.gpgpu.deleteMatrixTexture(tex);
            });
        }
        for (var texShape in this.usedTextures) {
            this.usedTextures[texShape].forEach(function (tex) {
                _this.gpgpu.deleteMatrixTexture(tex);
            });
        }
        this.freeTextures = null;
        this.usedTextures = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol, texType) {
    return shapeRowsCol[0] + "_" + shapeRowsCol[1] + "_" + texType;
}

},{"./tex_util":97}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TileProgram = (function () {
    function TileProgram(aShape, reps) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return TileProgram;
}());
exports.TileProgram = TileProgram;
function getSourceCoords(aShape) {
    var rank = aShape.length;
    if (rank > 5) {
        throw Error("Tile for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "imod(resRC, " + aShape[0] + ")";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
    }
    return sourceCoords.join();
}

},{"./shader_compiler":94}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TransposeProgram = (function () {
    function TransposeProgram(aShape, newDim) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var switched = getSwitchedCoords(newDim);
        this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
    }
    return TransposeProgram;
}());
exports.TransposeProgram = TransposeProgram;
function getSwitchedCoords(newDim) {
    var rank = newDim.length;
    if (rank > 5) {
        throw Error("Transpose for rank " + rank + " is not yet supported");
    }
    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];
    var switchedCoords = new Array(rank);
    for (var i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}

},{"./shader_compiler":94}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var erf_util = require("../../ops/erf_util");
var selu_util = require("../../ops/selu_util");
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
var CHECK_NAN_SNIPPET = "if (isNaN(x)) return x;";
exports.ABS = "return abs(x);";
exports.RELU = CHECK_NAN_SNIPPET + "\n  return (x < 0.0) ? 0.0 : x;\n";
exports.ELU = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
exports.SELU = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + selu_util.SELU_SCALEALPHA + ";\n  float scale = " + selu_util.SELU_SCALE + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
function STEP(alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    return CHECK_NAN_SNIPPET + ("\n    return x > 0.0 ? 1.0 : float(" + alpha + ");\n  ");
}
exports.STEP = STEP;
exports.NEG = "return -x;";
exports.CEIL = "return ceil(x);";
exports.FLOOR = "return floor(x);";
exports.SIGN = "\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n";
exports.ROUND = "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n";
exports.EXP = "return exp(x);";
exports.EXPM1 = "return exp(x) - 1.0;";
exports.LOG = "return log(x);";
exports.LOG1P = "return log(1.0 + x);";
exports.SQRT = "return sqrt(x);";
exports.RSQRT = "return inversesqrt(x);";
exports.SIGMOID = "return 1.0 / (1.0 + exp(-1.0 * x));";
exports.SOFTPLUS = "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n";
exports.SIN = "return sin(x);";
exports.COS = "return cos(x);";
exports.TAN = "return tan(x);";
exports.ASIN = "return asin(x);";
exports.ACOS = "return acos(x);";
exports.ATAN = CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
exports.ASINH = "return log(x + sqrt(x * x + 1.0));";
exports.ACOSH = "return log(x + sqrt(x * x - 1.0));";
exports.ATANH = "return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
exports.ERF = "\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = " + erf_util.ERF_P + ";\n  float a1 = " + erf_util.ERF_A1 + ";\n  float a2 = " + erf_util.ERF_A2 + ";\n  float a3 = " + erf_util.ERF_A3 + ";\n  float a4 = " + erf_util.ERF_A4 + ";\n  float a5 = " + erf_util.ERF_A5 + ";\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n";
exports.SQUARE = "return x * x;";
exports.RECIPROCAL = "return 1.0 / x;";
exports.LOGICAL_NOT = "return float(!(x >= 1.0));";
exports.TO_INT = "return float(int(x));";

},{"../../ops/erf_util":113,"../../ops/selu_util":130}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MAX_TEXTURE_SIZE = null;
var util = require("../../util");
var environment_1 = require("../../environment");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
    if (webglVersion === 2) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else if (webglVersion === 1) {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (webglVersion === 0 || gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return "Unknown error code " + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log("Couldn't parse line number in error: " + shaderInfoLog);
        console.log(shaderSource);
        return;
    }
    var lineNumber = +lineNumberRegexResult[1];
    var shaderLines = shaderSource.split('\n');
    var pad = shaderLines.length.toString().length + 2;
    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
        return util.rightPad((lineNumber + 1).toString(), pad) + line;
    });
    var maxLineLength = 0;
    for (var i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return 4;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = "[" + width + "x" + height + "]";
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = "[" + width + "x" + height + "]";
        var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    var loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
        return false;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
    return true;
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function getProgramUniformLocation(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
}
exports.getProgramUniformLocation = getProgramUniformLocation;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return "unknown error " + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
        throw new Error("textureUnit must be in " + textureUnitRange + ".");
    }
}
function getTextureShapeFromLogicalShape(gl, logShape) {
    if (logShape.length !== 2) {
        var squeezeResult = util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../environment":48,"../../util":155}],103:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var tensor_1 = require("../tensor");
var tensor_util = require("../tensor_util");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var concat_1 = require("./concat");
var operation_1 = require("./operation");
var rand_1 = require("./rand");
var reduction_ops_1 = require("./reduction_ops");
var ArrayOps = (function () {
    function ArrayOps() {
    }
    ArrayOps.tensor = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (shape != null && inferredShape.length !== 1) {
            util.assertShapesMatch(shape, inferredShape, "Error creating a new Tensor. " +
                ("Inferred shape (" + inferredShape + ") does not match the ") +
                ("provided shape (" + shape + "). "));
        }
        if (!util.isTypedArray(values) && !Array.isArray(values)) {
            values = [values];
        }
        shape = shape || inferredShape;
        return tensor_1.Tensor.make(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    ArrayOps.scalar = function (value, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (util.isTypedArray(value) || Array.isArray(value)) {
            throw new Error('Error creating a new Scalar: value must be a primitive ' +
                '(number|boolean)');
        }
        return ArrayOps.tensor(value, [], dtype);
    };
    ArrayOps.tensor1d = function (values, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 1) {
            throw new Error('tensor1d() requires values to be a flat/TypedArray');
        }
        return ArrayOps.tensor(values, inferredShape, dtype);
    };
    ArrayOps.tensor2d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (shape != null && shape.length !== 2) {
            throw new Error('tensor2d() requires shape to have two numbers');
        }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 2 && inferredShape.length !== 1) {
            throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');
        }
        if (inferredShape.length === 1 && shape == null) {
            throw new Error('tensor2d() requires shape to be provided when `values` ' +
                'are a flat/TypedArray');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.tensor3d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (shape != null && shape.length !== 3) {
            throw new Error('tensor3d() requires shape to have three numbers');
        }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 3 && inferredShape.length !== 1) {
            throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray');
        }
        if (inferredShape.length === 1 && shape == null) {
            throw new Error('tensor3d() requires shape to be provided when `values` ' +
                'are a flat array');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.tensor4d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (shape != null && shape.length !== 4) {
            throw new Error('tensor4d() requires shape to have four numbers');
        }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 4 && inferredShape.length !== 1) {
            throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray');
        }
        if (inferredShape.length === 1 && shape == null) {
            throw new Error('tensor4d() requires shape to be provided when `values` ' +
                'are a flat array');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.tensor5d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (shape != null && shape.length !== 5) {
            throw new Error('tensor5d() requires shape to have five numbers');
        }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 5 && inferredShape.length !== 1) {
            throw new Error('tensor5d() requires values to be \
           number[][][][][] or flat/TypedArray');
        }
        if (inferredShape.length === 1 && shape == null) {
            throw new Error('tensor5d() requires shape to be provided when `values` ' +
                'are a flat array');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.ones = function (shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = makeOnesTypedArray(util.sizeFromShape(shape), dtype);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.zeros = function (shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.fill = function (shape, value, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = util.getTypedArrayFromDType(dtype, util.sizeFromShape(shape));
        values.fill(value);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.onesLike = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'onesLike');
        return ArrayOps.ones(x.shape, x.dtype);
    };
    ArrayOps.zerosLike = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'zerosLike');
        return ArrayOps.zeros(x.shape, x.dtype);
    };
    ArrayOps.clone = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'clone');
        var der = function (dy) {
            return { x: function () { return dy.toFloat(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) {
            return tensor_1.Tensor.make(x.shape, { dataId: x.dataId }, x.dtype);
        }, { x: x }, der);
    };
    ArrayOps.eye = function (numRows, numColumns, batchShape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (numColumns == null) {
            numColumns = numRows;
        }
        var buffer = ArrayOps.buffer([numRows, numColumns], dtype);
        var n = numRows <= numColumns ? numRows : numColumns;
        for (var i = 0; i < n; ++i) {
            buffer.set(1, i, i);
        }
        var out = buffer.toTensor().as2D(numRows, numColumns);
        if (batchShape == null) {
            return out;
        }
        else {
            if (batchShape.length === 1) {
                return ArrayOps.tile(ArrayOps.expandDims(out, 0), [batchShape[0], 1, 1]);
            }
            else if (batchShape.length === 2) {
                return ArrayOps.tile(ArrayOps.expandDims(ArrayOps.expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
            }
            else {
                throw new Error("eye() currently supports only 1D and 2D " +
                    ("batchShapes, but received " + batchShape.length + "D."));
            }
        }
    };
    ArrayOps.randomNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        if (dtype != null && dtype === 'bool') {
            throw new Error("Unsupported data type " + dtype);
        }
        var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
        var res = ArrayOps.buffer(shape, dtype);
        for (var i = 0; i < res.values.length; i++) {
            res.values[i] = randGauss.nextValue();
        }
        return res.toTensor();
    };
    ArrayOps.truncatedNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        if (dtype != null && dtype === 'bool') {
            throw new Error("Unsupported data type " + dtype);
        }
        var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
        var res = ArrayOps.buffer(shape, dtype);
        for (var i = 0; i < res.values.length; i++) {
            res.values[i] = randGauss.nextValue();
        }
        return res.toTensor();
    };
    ArrayOps.randomUniform = function (shape, minval, maxval, dtype) {
        if (minval === void 0) { minval = 0; }
        if (maxval === void 0) { maxval = 1; }
        if (dtype === void 0) { dtype = 'float32'; }
        var res = ArrayOps.buffer(shape, dtype);
        for (var i = 0; i < res.values.length; i++) {
            res.values[i] = util.randUniform(minval, maxval);
        }
        return res.toTensor();
    };
    ArrayOps.rand = function (shape, randFunction, dtype) {
        var size = util.sizeFromShape(shape);
        var values = null;
        if (dtype == null || dtype === 'float32') {
            values = new Float32Array(size);
        }
        else if (dtype === 'int32') {
            values = new Int32Array(size);
        }
        else if (dtype === 'bool') {
            values = new Uint8Array(size);
        }
        else {
            throw new Error("Unknown data type " + dtype);
        }
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.multinomial = function (logits, numSamples, seed, normalized) {
        if (normalized === void 0) { normalized = false; }
        util.assertArgumentsAreTensors({ logits: logits }, 'multinomial');
        var numOutcomes = logits.size;
        var origRank = logits.rank;
        if (numOutcomes < 2) {
            throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
                (numOutcomes + "."));
        }
        if (origRank > 2) {
            throw new Error("Rank of probabilities must be 1 or 2, but is " + origRank);
        }
        seed = seed || Math.random();
        var logits2D = origRank === 1 ? logits.as2D(1, -1) : logits;
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.multinomial(logits2D, normalized, numSamples, seed); }, { logits2D: logits2D });
        return origRank === 1 ? res.as1D() : res;
    };
    ArrayOps.oneHot = function (indices, depth, onValue, offValue) {
        if (onValue === void 0) { onValue = 1; }
        if (offValue === void 0) { offValue = 0; }
        util.assert(indices.dtype === 'int32', 'Indices must be of dtype `int32`');
        if (depth < 2) {
            throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.oneHot(indices, depth, onValue, offValue); }, { indices: indices });
    };
    ArrayOps.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        if (numChannels > 4) {
            throw new Error('Cannot construct Tensor with more than 4 channels from pixels.');
        }
        return environment_1.ENV.engine.fromPixels(pixels, numChannels);
    };
    ArrayOps.toPixels = function (img, canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, height, width, depth, minTensor, maxTensor, min, max, data, multiplier, bytes, i, r, g, b, a, j, ctx, imageData;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        util.assertArgumentsAreTensors({ img: img }, 'toPixels');
                        if (img.rank !== 2 && img.rank !== 3) {
                            throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + img.rank + ".");
                        }
                        _a = img.shape.slice(0, 2), height = _a[0], width = _a[1];
                        depth = img.rank === 2 ? 1 : img.shape[2];
                        if (depth > 4 || depth === 2) {
                            throw new Error("toPixels only supports depth of size " +
                                ("1, 3 or 4 but got " + depth));
                        }
                        minTensor = img.min();
                        maxTensor = img.max();
                        return [4, minTensor.data()];
                    case 1:
                        min = (_b.sent())[0];
                        return [4, maxTensor.data()];
                    case 2:
                        max = (_b.sent())[0];
                        minTensor.dispose();
                        maxTensor.dispose();
                        if (img.dtype === 'float32') {
                            if (min < 0 || max > 1) {
                                throw new Error("Tensor values for a float32 Tensor must be in the " +
                                    ("range [0 - 1] but got range [" + min + " - " + max + "]."));
                            }
                        }
                        else if (img.dtype === 'int32') {
                            if (min < 0 || max > 255) {
                                throw new Error("Tensor values for a int32 Tensor must be in the " +
                                    ("range [0 - 255] but got range [" + min + " - " + max + "]."));
                            }
                        }
                        else {
                            throw new Error("Unsupported type for toPixels: " + img.dtype + "." +
                                " Please use float32 or int32 tensors.");
                        }
                        return [4, img.data()];
                    case 3:
                        data = _b.sent();
                        multiplier = img.dtype === 'float32' ? 255 : 1;
                        bytes = new Uint8ClampedArray(width * height * 4);
                        for (i = 0; i < height * width; ++i) {
                            r = void 0, g = void 0, b = void 0, a = void 0;
                            if (depth === 1) {
                                r = data[i] * multiplier;
                                g = data[i] * multiplier;
                                b = data[i] * multiplier;
                                a = 255;
                            }
                            else if (depth === 3) {
                                r = data[i * 3] * multiplier;
                                g = data[i * 3 + 1] * multiplier;
                                b = data[i * 3 + 2] * multiplier;
                                a = 255;
                            }
                            else if (depth === 4) {
                                r = data[i * 4] * multiplier;
                                g = data[i * 4 + 1] * multiplier;
                                b = data[i * 4 + 2] * multiplier;
                                a = data[i * 4 + 3] * multiplier;
                            }
                            j = i * 4;
                            bytes[j + 0] = Math.round(r);
                            bytes[j + 1] = Math.round(g);
                            bytes[j + 2] = Math.round(b);
                            bytes[j + 3] = Math.round(a);
                        }
                        if (canvas != null) {
                            canvas.width = width;
                            canvas.height = height;
                            ctx = canvas.getContext('2d');
                            imageData = new ImageData(bytes, width, height);
                            ctx.putImageData(imageData, 0, 0);
                        }
                        return [2, bytes];
                }
            });
        });
    };
    ArrayOps.reshape = function (x, shape) {
        util.assertArgumentsAreTensors({ x: x }, 'reshape');
        shape = util.inferFromImplicitShape(shape, x.size);
        util.assert(x.size === util.sizeFromShape(shape), 'new shape and old shape must have the same number of elements.');
        var grad = function (dy) {
            return { x: function () { return dy.reshape(x.shape); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.reshape(x, shape); }, { x: x }, grad);
    };
    ArrayOps.squeeze = function (x, axis) {
        util.assertArgumentsAreTensors({ x: x }, 'squeeze');
        return ArrayOps.reshape(x, util.squeezeShape(x.shape, axis).newShape);
    };
    ArrayOps.cast = function (x, dtype) {
        util.assertArgumentsAreTensors({ x: x }, 'cast');
        var grad = function (dy) {
            return { x: function () { return dy.clone(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cast(x, dtype); }, { x: x }, grad);
    };
    ArrayOps.tile = function (x, reps) {
        util.assertArgumentsAreTensors({ x: x }, 'tile');
        util.assert(x.rank === reps.length, "Error in transpose: rank of input " + x.rank + " " +
            ("must match length of reps " + reps + "."));
        var grad = function (dy) {
            var derX = function () {
                var xGrad = ArrayOps.zerosLike(x);
                if (x.rank === 1) {
                    for (var i = 0; i < reps[0]; ++i) {
                        xGrad = xGrad.add(dy.slice([i * x.shape[0]], [x.shape[0]]));
                    }
                }
                else if (x.rank === 2) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1]], [x.shape[0], x.shape[1]]));
                        }
                    }
                }
                else if (x.rank === 3) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            for (var k = 0; k < reps[2]; ++k) {
                                xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));
                            }
                        }
                    }
                }
                else if (x.rank === 4) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            for (var k = 0; k < reps[2]; ++k) {
                                for (var l = 0; l < reps[3]; ++l) {
                                    xGrad = xGrad.add(dy.slice([
                                        i * x.shape[0], j * x.shape[1], k * x.shape[2],
                                        l * x.shape[3]
                                    ], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));
                                }
                            }
                        }
                    }
                }
                else {
                    throw new Error("Gradient for tile operation is not implemented for rank-" +
                        (x.rank + " tensors yet."));
                }
                return xGrad;
            };
            return { x: derX };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.tile(x, reps); }, { x: x }, grad);
    };
    ArrayOps.gather = function (x, indices, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x, indices: indices }, 'gather');
        util.assert(indices.dtype === 'int32', 'Indices must be of dtype `int32`');
        axis = axis_util_1.parseAxisParam(axis, x.shape)[0];
        var grad = function (dy) {
            var derX = function () {
                return reduction_ops_1.ReductionOps.unsortedSegmentSum(dy, indices, x.shape[axis], axis);
            };
            return { x: derX };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.gather(x, indices, axis); }, { x: x }, grad);
    };
    ArrayOps.pad1d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 2, 'Invalid number of paddings. Must be length of 2.');
        return ArrayOps.pad(x, [paddings], constantValue);
    };
    ArrayOps.pad2d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 2 && paddings[0].length === 2 &&
            paddings[1].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad3d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 3 && paddings[0].length === 2 &&
            paddings[1].length === 2 && paddings[2].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad4d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 4 && paddings[0].length === 2 &&
            paddings[1].length === 2 && paddings[2].length === 2 &&
            paddings[3].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'pad');
        if (x.rank === 0) {
            throw new Error('pad(scalar) is not defined. Pass non-scalar to pad');
        }
        var begin = paddings.map(function (p) { return p[0]; });
        var grad = function (dy) {
            return { x: function () { return dy.slice(begin, x.shape); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.pad(x, paddings, constantValue); }, { x: x }, grad);
    };
    ArrayOps.stack = function (tensors, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ tensors: tensors }, 'stack');
        util.assert(tensors.length >= 1, 'Pass at least one tensor to tf.stack');
        if (tensors.length === 1) {
            return tensors[0].expandDims(axis);
        }
        var rank = tensors[0].rank;
        var shape = tensors[0].shape;
        var dtype = tensors[0].dtype;
        util.assert(axis <= rank, 'Axis must be <= rank of the tensor');
        tensors.forEach(function (t) {
            util.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');
        });
        tensors.forEach(function (t) {
            util.assert(dtype === t.dtype, 'All tensors passed to stack must have matching dtypes');
        });
        var expandedTensors = tensors.map(function (t) { return t.expandDims(axis); });
        return concat_1.ConcatOps.concat(expandedTensors, axis);
    };
    ArrayOps.unstack = function (value, axis) {
        if (axis === void 0) { axis = 0; }
        var num = value.shape[axis];
        var outputShape = Array(value.rank - 1).fill(0);
        var outIndex = 0;
        for (var i = 0; i < value.rank; i++) {
            if (i !== axis) {
                outputShape[outIndex] = value.shape[i];
                outIndex++;
            }
        }
        var splitSizes;
        splitSizes = Array(num).fill(1);
        var begin = Array(value.rank).fill(0);
        var size = value.shape.slice();
        return splitSizes.map(function (s) {
            size[axis] = s;
            var slice = value.slice(begin, size);
            begin[axis] += s;
            return slice.reshape(outputShape);
        });
    };
    ArrayOps.split = function (x, numOrSizeSplits, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'split');
        axis = axis_util_1.parseAxisParam(axis, x.shape)[0];
        var splitSizes;
        if (typeof (numOrSizeSplits) === 'number') {
            util.assert(x.shape[axis] % numOrSizeSplits === 0, 'Number of splits must evenly divide the axis.');
            splitSizes = Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
        }
        else {
            util.assert(x.shape[axis] === numOrSizeSplits.reduce(function (a, b) { return a + b; }), 'The sum of sizes must match the size of the axis dimension.');
            splitSizes = numOrSizeSplits;
        }
        var begin = Array(x.rank).fill(0);
        var size = x.shape.slice();
        return splitSizes.map(function (s) {
            size[axis] = s;
            var slice = x.slice(begin, size);
            begin[axis] += s;
            return slice;
        });
    };
    ArrayOps.cumsum = function (x, axis, exclusive, reverse) {
        if (axis === void 0) { axis = 0; }
        if (exclusive === void 0) { exclusive = false; }
        if (reverse === void 0) { reverse = false; }
        util.assertArgumentsAreTensors({ x: x }, 'cumsum');
        axis = axis | 0;
        var permutation = axis_util_1.getAxesPermutation([axis], x.rank);
        var permutedX = x;
        if (permutation != null) {
            permutedX = x.transpose(permutation);
        }
        var permutedAxis = axis_util_1.getInnerMostAxes(1, x.rank)[0];
        var grad = function (dy) {
            return { permutedX: function () { return dy.cumsum(axis, exclusive, !reverse); } };
        };
        var value = environment_1.ENV.engine.runKernel(function (backend) { return backend.cumsum(permutedX, permutedAxis, exclusive, reverse); }, { permutedX: permutedX }, grad);
        if (permutation != null) {
            value = value.transpose(permutation);
        }
        return value;
    };
    ArrayOps.expandDims = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'expandDims');
        util.assert(axis <= x.rank, 'Axis must be <= rank of the tensor');
        var newShape = x.shape.slice();
        newShape.splice(axis, 0, 1);
        return ArrayOps.reshape(x, newShape);
    };
    ArrayOps.linspace = function (start, stop, num) {
        if (num === 0) {
            throw new Error('Cannot request zero samples');
        }
        var step = (stop - start) / (num - 1);
        var values = makeZerosTypedArray(num, 'float32');
        values[0] = start;
        for (var i = 1; i < values.length; i++) {
            values[i] = values[i - 1] + step;
        }
        return ArrayOps.tensor1d(values, 'float32');
    };
    ArrayOps.range = function (start, stop, step, dtype) {
        if (step === void 0) { step = 1; }
        if (dtype === void 0) { dtype = 'float32'; }
        if (step === 0) {
            throw new Error('Cannot have a step of zero');
        }
        var sameStartStop = start === stop;
        var increasingRangeNegativeStep = start < stop && step < 0;
        var decreasingRangePositiveStep = stop < start && step > 1;
        if (sameStartStop || increasingRangeNegativeStep ||
            decreasingRangePositiveStep) {
            return ArrayOps.zeros([0], dtype);
        }
        var numElements = Math.abs(Math.ceil((stop - start) / step));
        var values = makeZerosTypedArray(numElements, dtype);
        if (stop < start && step === 1) {
            step = -1;
        }
        values[0] = start;
        for (var i = 1; i < values.length; i++) {
            values[i] = values[i - 1] + step;
        }
        return ArrayOps.tensor1d(values, dtype);
    };
    ArrayOps.buffer = function (shape, dtype, values) {
        if (dtype === void 0) { dtype = 'float32'; }
        return new tensor_1.TensorBuffer(shape, dtype, values);
    };
    ArrayOps.print = function (x, verbose) {
        if (verbose === void 0) { verbose = false; }
        console.log(tensor_util.tensorToString(x, verbose));
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "scalar", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor1d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor2d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor3d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor4d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor5d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "ones", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "zeros", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "fill", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "onesLike", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "zerosLike", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "clone", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "eye", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "randomNormal", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "truncatedNormal", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "randomUniform", null);
    __decorate([
        operation_1.operation
    ], ArrayOps, "rand", null);
    __decorate([
        operation_1.operation
    ], ArrayOps, "multinomial", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "oneHot", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "fromPixels", null);
    __decorate([
        doc_1.doc({ heading: 'Visualization' })
    ], ArrayOps, "toPixels", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "reshape", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' })
    ], ArrayOps, "squeeze", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "cast", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "tile", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "gather", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "pad", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "stack", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "unstack", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "split", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Scan' })
    ], ArrayOps, "cumsum", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "expandDims", null);
    __decorate([
        operation_1.operation,
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "linspace", null);
    __decorate([
        operation_1.operation,
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "range", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "buffer", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "print", null);
    return ArrayOps;
}());
exports.ArrayOps = ArrayOps;
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type $ {dtype}");
    }
}
function makeOnesTypedArray(size, dtype) {
    var array = makeZerosTypedArray(size, dtype);
    for (var i = 0; i < array.length; i++) {
        array[i] = 1;
    }
    return array;
}
function toTypedArray(a, dtype) {
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (Array.isArray(a)) {
        a = util.flatten(a);
    }
    return util.copyTypedArray(a, dtype);
}
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}

},{"../doc":46,"../environment":48,"../tensor":149,"../tensor_util":150,"../util":155,"./axis_util":104,"./concat":109,"./operation":123,"./rand":126,"./reduction_ops":128}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function axesAreInnerMostDims(axes, rank) {
    for (var i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
        }
    }
    return true;
}
exports.axesAreInnerMostDims = axesAreInnerMostDims;
function combineLocations(outputLoc, reduceLoc, axes) {
    var rank = outputLoc.length + reduceLoc.length;
    var loc = [];
    var outIdx = 0;
    var reduceIdx = 0;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
exports.combineLocations = combineLocations;
function computeOutAndReduceShapes(aShape, axes) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            outShape.push(aShape[dim]);
        }
    }
    var reduceShape = axes.map(function (dim) { return aShape[dim]; });
    return [outShape, reduceShape];
}
exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
function expandShapeToKeepDim(shape, axes) {
    var reduceSubShape = axes.map(function (x) { return 1; });
    return combineLocations(shape, reduceSubShape, axes);
}
exports.expandShapeToKeepDim = expandShapeToKeepDim;
function parseAxisParam(axis, shape) {
    var rank = shape.length;
    axis = axis == null ? shape.map(function (s, i) { return i; }) : [].concat(axis);
    util.assert(axis.every(function (ax) { return ax >= -rank && ax < rank; }), "All values in axis param must be in range [-" + rank + ", " + rank + ") but " +
        ("got axis " + axis));
    util.assert(axis.every(function (ax) { return util.isInt(ax); }), "All values in axis param must be integers but " +
        ("got axis " + axis));
    return axis.map(function (a) { return a < 0 ? rank + a : a; });
}
exports.parseAxisParam = parseAxisParam;
function assertAxesAreInnerMostDims(msg, axes, rank) {
    util.assert(axesAreInnerMostDims(axes, rank), msg + " supports only inner-most axes for now. " +
        ("Got axes " + axes + " and rank-" + rank + " input."));
}
exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
function getAxesPermutation(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
        return null;
    }
    var result = [];
    for (var i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
            result.push(i);
        }
    }
    axes.forEach(function (axis) { return result.push(axis); });
    return result;
}
exports.getAxesPermutation = getAxesPermutation;
function getUndoAxesPermutation(axes) {
    return axes.map(function (axis, i) { return [i, axis]; })
        .sort(function (a, b) { return a[1] - b[1]; })
        .map(function (x) { return x[0]; });
}
exports.getUndoAxesPermutation = getUndoAxesPermutation;
function getInnerMostAxes(numAxes, rank) {
    var res = [];
    for (var i = rank - numAxes; i < rank; ++i) {
        res.push(i);
    }
    return res;
}
exports.getInnerMostAxes = getInnerMostAxes;

},{"../util":155}],105:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var array_ops_1 = require("./array_ops");
var broadcast_util_1 = require("./broadcast_util");
var operation_1 = require("./operation");
var ops_1 = require("./ops");
var BatchNormOps = (function () {
    function BatchNormOps() {
    }
    BatchNormOps.batchNormalization2d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization3d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization4d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 4, "Error in batchNormalization4D: x must be rank 4 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 4 || mean.rank === 1, "Error in batchNormalization4D: mean must be rank 4 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 4 || variance.rank === 1, "Error in batchNormalization4D: variance must be rank 4 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 4 || scale.rank === 1, "Error in batchNormalization4D: scale must be rank 4 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 4 || offset.rank === 1, "Error in batchNormalization4D: offset must be rank 4 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assertArgumentsAreTensors({ x: x, mean: mean, variance: variance }, 'batchNormalization');
        if (scale != null) {
            util.assertArgumentsAreTensors({ scale: scale }, 'batchNormalization');
        }
        if (offset != null) {
            util.assertArgumentsAreTensors({ offset: offset }, 'batchNormalization');
        }
        util.assert(mean.rank === variance.rank, 'Batch normalization gradient requires mean and variance to have ' +
            'equal ranks.');
        util.assert(offset == null || mean.rank === offset.rank, 'Batch normalization gradient requires mean and offset to have ' +
            'equal ranks.');
        util.assert(scale == null || mean.rank === scale.rank, 'Batch normalization gradient requires mean and scale to have ' +
            'equal ranks.');
        var x4D;
        if (x.rank === 0 || x.rank === 1) {
            x4D = x.as4D(1, 1, 1, x.size);
        }
        else if (x.rank === 2) {
            x4D = x.as4D(1, 1, x.shape[0], x.shape[1]);
        }
        else if (x.rank === 3) {
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        else {
            x4D = x;
        }
        var der = function (dy) {
            var scaleValue = scale == null ? array_ops_1.ArrayOps.scalar(1) : scale;
            var reductionAxes = broadcast_util_1.getReductionAxes(mean.shape, x4D.shape);
            var tileShape = [];
            if (mean.rank === 1) {
                for (var i = 0; i < x4D.shape.length - 1; ++i) {
                    tileShape.push(x4D.shape[i]);
                }
                tileShape.push(1);
            }
            var xMinusMean = x.sub(mean);
            var dyTimesScaleValue = dy.mul(scaleValue);
            var oneOverSqrtVariance = ops_1.rsqrt(variance.add(array_ops_1.ArrayOps.scalar(varianceEpsilon)));
            var minusHalfRCube = oneOverSqrtVariance.mul(oneOverSqrtVariance)
                .mul(oneOverSqrtVariance)
                .mul(array_ops_1.ArrayOps.scalar(-0.5));
            var derX = function () {
                if (mean.rank === 1) {
                    return dy
                        .mul(array_ops_1.ArrayOps.tile(oneOverSqrtVariance.as4D(1, 1, 1, mean.shape[0]), tileShape))
                        .mul(scaleValue)
                        .reshape(x.shape);
                }
                else {
                    return dy.mul(oneOverSqrtVariance).mul(scaleValue).reshape(x.shape);
                }
            };
            var derMean = function () {
                var meanDer = oneOverSqrtVariance.mul(array_ops_1.ArrayOps.scalar(-1)).mul(dyTimesScaleValue);
                if (mean.rank === 1) {
                    meanDer = meanDer.sum(reductionAxes);
                }
                return meanDer.reshape(mean.shape);
            };
            var derVariance = function () {
                var varianceDer = minusHalfRCube.mul(xMinusMean).mul(dyTimesScaleValue);
                if (mean.rank === 1) {
                    varianceDer = varianceDer.sum(reductionAxes);
                }
                return varianceDer.reshape(mean.shape);
            };
            var derScale = function () {
                var xMinusMean2TimesRsqrt = xMinusMean.mul(oneOverSqrtVariance);
                var scaleDer = dy.mul(xMinusMean2TimesRsqrt);
                if (mean.rank === 1) {
                    scaleDer = scaleDer.sum(reductionAxes);
                }
                return scaleDer.reshape(mean.shape);
            };
            var derOffset = function () {
                var offsetDer = dy;
                if (mean.rank === 1) {
                    offsetDer = offsetDer.sum(reductionAxes);
                }
                return offsetDer.reshape(mean.shape);
            };
            return {
                x: derX,
                mean: derMean,
                variance: derVariance,
                scale: derScale,
                offset: derOffset
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.batchNormalization(x4D, batchnormReshape4D(mean), batchnormReshape4D(variance), varianceEpsilon, batchnormReshape4D(scale), batchnormReshape4D(offset)); }, { x: x, mean: mean, variance: variance, scale: scale, offset: offset }, der);
        return res.reshape(x.shape);
    };
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization2d", null);
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization3d", null);
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization4d", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' })
    ], BatchNormOps, "batchNormalization", null);
    return BatchNormOps;
}());
exports.BatchNormOps = BatchNormOps;
function batchnormReshape4D(x) {
    if (x == null) {
        return null;
    }
    if (x.rank === 0) {
        return x.as1D();
    }
    else if (x.rank === 1) {
        return x;
    }
    else if (x.rank === 2) {
        return x.as4D(1, 1, x.shape[0], x.shape[1]);
    }
    else if (x.rank === 3) {
        return x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
    }
    return x;
}

},{"../doc":46,"../environment":48,"../util":155,"./array_ops":103,"./broadcast_util":107,"./operation":123,"./ops":124}],106:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var types_1 = require("../types");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var ops_1 = require("./ops");
var BinaryOps = (function () {
    function BinaryOps() {
    }
    BinaryOps.add = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'add');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.add(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return a.add(b);
    };
    BinaryOps.sub = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'sub');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.neg().reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.subtract(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return a.sub(b);
    };
    BinaryOps.pow = function (base, exp) {
        util.assertArgumentsAreTensors({ base: base, exp: exp }, 'pow');
        var outShape = broadcast_util.assertAndGetBroadcastShape(base.shape, exp.shape);
        base = base.cast(types_1.upcastType(base.dtype, exp.dtype));
        exp = exp.cast(types_1.upcastType(base.dtype, exp.dtype));
        var grad = function (dy, saved) {
            var y = saved[0];
            var derBase = function () {
                var res = dy.mul(exp.toFloat().mul(y.div(base)));
                var reduceAxes = broadcast_util.getReductionAxes(base.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(base.shape);
            };
            var derExp = function () {
                var res = dy.mul(y.mul(base.log()).toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(exp.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(exp.shape);
            };
            return { base: derBase, exp: derExp };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.pow(base, exp)); }, { base: base, exp: exp }, grad);
    };
    BinaryOps.powStrict = function (base, exp) {
        util.assertShapesMatch(base.shape, exp.shape, 'Error in powStrict: ');
        return base.pow(exp);
    };
    BinaryOps.mul = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'mul');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy.mul(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(b.shape);
                }
                return res;
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.multiply(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.mulStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return a.mul(b);
    };
    BinaryOps.div = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'div');
        util.assertTypesMatch(a, b);
        var forwardFunc;
        if (a.dtype === 'int32' && b.dtype === 'int32') {
            return BinaryOps.floorDiv(a, b);
        }
        else {
            forwardFunc = function (backend) { return backend.realDivide(a, b); };
        }
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy.div(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes).reshape(b.shape);
                }
                var tmp = b.square();
                return res.div(tmp.toFloat()).neg();
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(forwardFunc, { a: a, b: b }, der);
    };
    BinaryOps.floorDiv = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'floorDiv');
        util.assertTypesMatch(a, b);
        var forwardFunc = function (backend) { return backend.floorDiv(a, b); };
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy.div(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes).reshape(b.shape);
                }
                var tmp = b.square();
                return res.div(tmp.toFloat()).neg();
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(forwardFunc, { a: a, b: b }, der);
    };
    BinaryOps.divStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return a.div(b);
    };
    BinaryOps.mod = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'mod');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return dy.sum(reduceAxes).reshape(a.shape);
                }
                return dy;
            };
            var derB = function () {
                var res = dy.mul(a.div(b).floor().neg());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(b.shape);
                }
                return res;
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.mod(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.modStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in modStrict: ');
        return a.mod(b);
    };
    BinaryOps.minimum = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'minimum');
        util.assertTypesMatch(a, b);
        if (a.dtype === 'bool') {
            a = a.toInt();
        }
        if (b.dtype === 'bool') {
            b = b.toInt();
        }
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () { return dy.mul(a.lessEqual(b).toFloat()); };
            var derB = function () { return dy.mul(a.greater(b).toFloat()); };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.minimum(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.minimumStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
        return a.minimum(b);
    };
    BinaryOps.maximum = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'maximum');
        util.assertTypesMatch(a, b);
        if (a.dtype === 'bool') {
            a = a.toInt();
        }
        if (b.dtype === 'bool') {
            b = b.toInt();
        }
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () { return dy.mul(a.greaterEqual(b).toFloat()); };
            var derB = function () { return dy.mul(a.less(b).toFloat()); };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.maximum(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.maximumStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
        return a.maximum(b);
    };
    BinaryOps.squaredDifference = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'squaredDifference');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var two = ops_1.scalar(2);
            var derA = function () { return dy.mul(a.sub(b).mul(two)); };
            var derB = function () { return dy.mul(b.sub(a).mul(two)); };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.squaredDifference(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.squaredDifferenceStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in squaredDifferenceStrict: ');
        return a.squaredDifference(b);
    };
    BinaryOps.atan2 = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'atan2');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var d = BinaryOps.add(ops_1.square(a), ops_1.square(b));
                var res = dy.mul(b.div(d));
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var d = BinaryOps.add(ops_1.square(a), ops_1.square(b));
                var res = ops_1.neg(dy.mul(a.div(d)));
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atan2(a, b); }, { a: a, b: b }, der);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "add", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "addStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "sub", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "subStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "pow", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "powStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "mul", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "mulStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "div", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "floorDiv", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "divStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "mod", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "modStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "minimum", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "minimumStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "maximum", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "maximumStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "squaredDifference", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "squaredDifferenceStrict", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "atan2", null);
    return BinaryOps;
}());
exports.BinaryOps = BinaryOps;

},{"../doc":46,"../environment":48,"../types":154,"../util":155,"./broadcast_util":107,"./operation":123,"./ops":124}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getBroadcastDims(inShape, outShape) {
    var inRank = inShape.length;
    var dims = [];
    for (var i = 0; i < inRank; i++) {
        var dim = inRank - 1 - i;
        var a = inShape[dim] || 1;
        var b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
            dims.unshift(dim);
        }
    }
    return dims;
}
exports.getBroadcastDims = getBroadcastDims;
function getReductionAxes(inShape, outShape) {
    var result = [];
    for (var i = 0; i < outShape.length; i++) {
        var inDim = inShape[inShape.length - i - 1];
        var outAxis = outShape.length - i - 1;
        var outDim = outShape[outAxis];
        if (inDim == null || (inDim === 1 && outDim > 1)) {
            result.unshift(outAxis);
        }
    }
    return result;
}
exports.getReductionAxes = getReductionAxes;
function broadcastDimsAreOuter(dims) {
    for (var i = 0; i < dims.length; i++) {
        if (dims[i] !== i) {
            return false;
        }
    }
    return true;
}
exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
function assertAndGetBroadcastShape(shapeA, shapeB) {
    var result = [];
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ".");
    var l = Math.max(shapeA.length, shapeB.length);
    for (var i = 0; i < l; i++) {
        var a = shapeA[shapeA.length - i - 1] || 1;
        var b = shapeB[shapeB.length - i - 1] || 1;
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.unshift(Math.max(a, b));
    }
    return result;
}
exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;

},{}],108:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var CompareOps = (function () {
    function CompareOps() {
    }
    CompareOps.notEqual = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'notEqual');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.notEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.notEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in notEqualStrict: ');
        return a.notEqual(b);
    };
    CompareOps.less = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'less');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.less(a, b); }, { a: a, b: b });
    };
    CompareOps.lessStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in lessStrict: ');
        return a.less(b);
    };
    CompareOps.equal = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'equal');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.equal(a, b); }, { a: a, b: b });
    };
    CompareOps.equalStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in equalStrict: ');
        return a.equal(b);
    };
    CompareOps.lessEqual = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'lessEqual');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.lessEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.lessEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in lessEqualStrict: ');
        return a.lessEqual(b);
    };
    CompareOps.greater = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'greater');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.greater(a, b); }, { a: a, b: b });
    };
    CompareOps.greaterStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in greaterStrict: ');
        return a.greater(b);
    };
    CompareOps.greaterEqual = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'greaterEqual');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.greaterEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.greaterEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in greaterEqualStrict: ');
        return a.greaterEqual(b);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "notEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "notEqualStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "less", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "lessStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "equal", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "equalStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "lessEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "lessEqualStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "greater", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "greaterStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "greaterEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "greaterEqualStrict", null);
    return CompareOps;
}());
exports.CompareOps = CompareOps;

},{"../doc":46,"../environment":48,"../util":155,"./broadcast_util":107,"./operation":123}],109:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var concat_util = require("./concat_util");
var operation_1 = require("./operation");
var ConcatOps = (function () {
    function ConcatOps() {
    }
    ConcatOps.concat1d = function (tensors) {
        return ConcatOps.concat(tensors, 0);
    };
    ConcatOps.concat2d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat3d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat4d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat = function (tensors, axis) {
        if (axis === void 0) { axis = 0; }
        util.assert(tensors.length >= 1, 'Pass at least one tensor to concat');
        util.assertArgumentsAreTensors({ tensors: tensors }, 'concat');
        var result = tensors[0];
        if (tensors.length === 1) {
            return result;
        }
        var axes = axis_util_1.parseAxisParam(axis, result.shape);
        for (var i = 1; i < tensors.length; ++i) {
            result = concat2Tensors(result, tensors[i], axes[0]);
        }
        return result;
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ConcatOps, "concat", null);
    return ConcatOps;
}());
exports.ConcatOps = ConcatOps;
function concat2Tensors(a, b, axis) {
    concat_util.assertParams(a.shape, b.shape, axis);
    var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
    var a2D = a.as2D(-1, util.sizeFromShape(a.shape.slice(axis)));
    var b2D = b.as2D(-1, util.sizeFromShape(b.shape.slice(axis)));
    var _a = concat_util.computeGradientSliceShapes(a2D.shape, b2D.shape), aBegin = _a.aBegin, aSize = _a.aSize, bBegin = _a.bBegin, bSize = _a.bSize;
    var der = function (dy) {
        return { a: function () { return dy.slice(aBegin, aSize); }, b: function () { return dy.slice(bBegin, bSize); } };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.concat(a2D, b2D); }, { a: a2D, b: b2D }, der);
    return res.reshape(outShape);
}

},{"../doc":46,"../environment":48,"../util":155,"./axis_util":104,"./concat_util":110,"./operation":123}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParams(aShape, bShape, axis) {
    var aRank = aShape.length;
    var bRank = bShape.length;
    util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " +
        "must be the same.");
    util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " +
        ("between 0 and " + (aRank - 1) + "."));
    for (var i = 0; i < aRank; i++) {
        util.assert((i === axis) || (aShape[i] === bShape[i]), "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " +
            ("(" + bShape + ") along the non-concatenated axis " + i + "."));
    }
}
exports.assertParams = assertParams;
function computeOutShape1D(x1Shape, x2Shape) {
    util.assert(x1Shape.length === 1 && x2Shape.length === 1, 'x1 and x2 should be 1d array.');
    var outputShape = x1Shape.slice();
    outputShape[0] += x2Shape[0];
    return outputShape;
}
exports.computeOutShape1D = computeOutShape1D;
function computeOutShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeOutShape = computeOutShape;
function computeGradientSliceShapes(aShape, bShape) {
    return {
        aBegin: [0, 0],
        aSize: aShape,
        bBegin: [0, aShape[1]],
        bSize: bShape
    };
}
exports.computeGradientSliceShapes = computeGradientSliceShapes;

},{"../util":155}],111:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var conv_util = require("./conv_util");
var operation_1 = require("./operation");
var ConvOps = (function () {
    function ConvOps() {
    }
    ConvOps.conv1d = function (x, filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NWC'; }
        if (dilation === void 0) { dilation = 1; }
        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv1d');
        var x3D = x;
        var reshapedTo3D = false;
        if (x.rank === 2) {
            reshapedTo3D = true;
            x3D = x.as3D(1, x.shape[0], x.shape[1]);
        }
        util.assert(x3D.rank === 3, "Error in conv1d: input must be rank 3, but got rank " + x3D.rank + ".");
        util.assert(filter.rank === 3, "Error in conv1d: filter must be rank 3, but got rank " +
            (filter.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv1d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        util.assert(x3D.shape[2] === filter.shape[1], "Error in conv1d: depth of input (" + x3D.shape[2] + ") must match " +
            ("input depth for filter " + filter.shape[1] + "."));
        util.assert(eitherStridesOrDilationsAreOne(stride, dilation), 'Error in conv1D: Either stride or dilation must be 1. ' +
            ("Got stride " + stride + " and dilation '" + dilation + "'"));
        util.assert(dataFormat === 'NWC', "Error in conv1d: got dataFormat of " + dataFormat + " but only NWC is currently supported.");
        var filter4D = filter.as4D(1, filter.shape[0], filter.shape[1], filter.shape[2]);
        var input4D = x3D.as4D(x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]);
        var strides = [1, stride];
        var dilations = [1, dilation];
        var conv2dDataFormat = 'NHWC';
        var res = ConvOps.conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);
        if (reshapedTo3D) {
            return res.as2D(res.shape[2], res.shape[3]);
        }
        return res.as3D(res.shape[0], res.shape[2], res.shape[3]);
    };
    ConvOps.conv2d = function (x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv2d');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in conv2d: input must be rank 4, but got rank " + x4D.rank + ".");
        util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        util.assert(x4D.shape[3] === filter.shape[2], "Error in conv2d: depth of input (" + x4D.shape[3] + ") must match " +
            ("input depth for filter " + filter.shape[2] + "."));
        util.assert(eitherStridesOrDilationsAreOne(strides, dilations), 'Error in conv2D: Either strides or dilations must be 1. ' +
            ("Got strides " + strides + " and dilations '" + dilations + "'"));
        util.assert(dataFormat === 'NHWC', "Error in conv2d: got dataFormat of " + dataFormat + " but only NHWC is currently supported.");
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode);
        var grad = function (dy) {
            util.assert(tupleValuesAreOne(dilations), 'Error in gradient of conv2D: dilation rates greater than 1 are not' +
                ("yet supported in gradients. Got dilations '" + dilations + "'"));
            return {
                x: function () { return ConvOps.conv2dDerInput(x4D.shape, dy, filter, strides, pad); },
                filter: function () {
                    return ConvOps.conv2dDerFilter(x4D, dy, filter.shape, strides, pad);
                }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2d(x4D, filter, convInfo); }, { x: x4D, filter: filter }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ConvOps.conv2dDerInput = function (xShape, dy, filter, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ dy: dy, filter: filter }, 'conv2dDerInput');
        util.assert(xShape.length === dy.rank, "Length of inShape " +
            ("(" + xShape.length + ") and rank of dy (" + dy.rank + ") must match"));
        var xShape4D = xShape;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (dy.rank === 3) {
            reshapedTo4D = true;
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
            xShape4D = [1, xShape[0], xShape[1], xShape[2]];
        }
        var inDepth = xShape4D[3];
        var outDepth = dy4D.shape[3];
        util.assert(xShape4D.length === 4, "Error in conv2dDerInput: inShape must be length 4, but got length " +
            (xShape4D.length + "."));
        util.assert(dy4D.rank === 4, "Error in conv2dDerInput: dy must be rank 4, but got " +
            ("rank " + dy4D.rank));
        util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
            ("rank " + filter.rank));
        util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
            ("match input depth for filter " + filter.shape[2] + "."));
        util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must " +
            ("match output depth for filter " + filter.shape[3] + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2dDerInput: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var dilations = 1;
        var convInfo = conv_util.computeConv2DInfo(xShape4D, filter.shape, strides, dilations, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerInput(dy4D, filter, convInfo); }, { dy4D: dy4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ConvOps.conv2dDerFilter = function (x, dy, filterShape, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ x: x, dy: dy }, 'conv2dDerFilter');
        var x4D = x;
        if (x.rank === 3) {
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        var dy4D = dy;
        if (dy4D.rank === 3) {
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in conv2dDerFilter: input must be rank 4, but got shape " +
            (x4D.shape + "."));
        util.assert(dy4D.rank === 4, "Error in conv2dDerFilter: dy must be rank 4, but got shape " +
            (dy4D.shape + "."));
        util.assert(filterShape.length === 4, "Error in conv2dDerFilter: filterShape must be length 4, but got " +
            (filterShape + "."));
        util.assert(x4D.shape[3] === filterShape[2], "Error in conv2dDerFilter: depth of input " + x4D.shape[3] + ") must " +
            ("match input depth in filter (" + filterShape[2] + "."));
        util.assert(dy4D.shape[3] === filterShape[3], "Error in conv2dDerFilter: depth of dy (" + dy4D.shape[3] + ") must " +
            ("match output depth for filter (" + filterShape[3] + ")."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2dDerFilter: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var dilations = 1;
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerFilter(x4D, dy4D, convInfo); }, { x4D: x4D, dy4D: dy4D });
    };
    ConvOps.conv2dTranspose = function (x, filter, outputShape, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv2dTranspose');
        return ConvOps.conv2dDerInput(outputShape, x, filter, strides, pad, dimRoundingMode);
    };
    ConvOps.depthwiseConv2d = function (x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'depthwiseConv2d');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in depthwiseConv2d: input must be rank 4, but got " +
            ("rank " + x4D.rank + "."));
        util.assert(filter.rank === 4, "Error in depthwiseConv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        util.assert(x4D.shape[3] === filter.shape[2], "Error in depthwiseConv2d: number of input channels " +
            ("(" + x4D.shape[3] + ") must match the inChannels dimension in ") +
            ("filter " + filter.shape[2] + "."));
        if (dilations == null) {
            dilations = [1, 1];
        }
        util.assert(eitherStridesOrDilationsAreOne(strides, dilations), 'Error in depthwiseConv2d: Either strides or dilations must be 1. ' +
            ("Got strides " + strides + " and dilations '" + dilations + "'"));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in depthwiseConv2d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode, true);
        var grad = function (dy) {
            util.assert(tupleValuesAreOne(dilations), 'Error in gradient of depthwiseConv2d: dilation rates greater than ' +
                ("1 are not yet supported. Got dilations '" + dilations + "'"));
            return {
                x: function () { return depthwiseConv2dDerInput(x4D.shape, dy, filter, convInfo); },
                filter: function () { return depthwiseConv2dDerFilter(x4D, dy, filter.shape, convInfo); },
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2D(x4D, filter, convInfo); }, { x: x4D, filter: filter }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ConvOps.separableConv2d = function (x, depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat) {
        if (dilation === void 0) { dilation = [1, 1]; }
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        util.assertArgumentsAreTensors({ x: x, depthwiseFilter: depthwiseFilter, pointwiseFilter: pointwiseFilter }, 'separableConv2d');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        if (dataFormat === 'NCHW') {
            throw new Error('separableConv2d currently does not support dataFormat NCHW; only ' +
                'NHWC is supported');
        }
        util.assert(x4D.rank === 4, "Error in separableConv2d: input must be rank 4, but got " +
            ("rank " + x4D.rank + "."));
        util.assert(depthwiseFilter.rank === 4, "Error in separableConv2d: depthwise filter must be rank 4, but got " +
            ("rank " + depthwiseFilter.rank + "."));
        util.assert(pointwiseFilter.rank === 4, "Error in separableConv2d: pointwise filter must be rank 4, but got " +
            ("rank " + depthwiseFilter.rank + "."));
        util.assert(pointwiseFilter.shape[0] === 1, "Error in separableConv2d: the first dimension of pointwise filter " +
            (" must be 1, but got " + pointwiseFilter.shape[0] + "."));
        util.assert(pointwiseFilter.shape[1] === 1, "Error in separableConv2d: the second dimension of pointwise filter " +
            (" must be 1, but got " + pointwiseFilter.shape[1] + "."));
        var inChannels = depthwiseFilter.shape[2];
        var channelMultiplier = depthwiseFilter.shape[3];
        util.assert(pointwiseFilter.shape[2] === inChannels * channelMultiplier, "Error in separableConv2d: the third dimension of pointwise filter " +
            ("must be " + inChannels * channelMultiplier + ", ") +
            ("but got " + pointwiseFilter.shape[2] + "."));
        var depthwise = ConvOps.depthwiseConv2d(x4D, depthwiseFilter, strides, pad, dataFormat, dilation);
        var pointwiseStride = 1;
        var res = ConvOps.conv2d(depthwise, pointwiseFilter, pointwiseStride, 'valid', dataFormat);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv1d", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv2d", null);
    __decorate([
        operation_1.operation
    ], ConvOps, "conv2dDerInput", null);
    __decorate([
        operation_1.operation
    ], ConvOps, "conv2dDerFilter", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv2dTranspose", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "depthwiseConv2d", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "separableConv2d", null);
    return ConvOps;
}());
exports.ConvOps = ConvOps;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function tupleValuesAreOne(param) {
    var _a = parseTupleParam(param), dimA = _a[0], dimB = _a[1];
    return dimA === 1 && dimB === 1;
}
function eitherStridesOrDilationsAreOne(strides, dilations) {
    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
}
function depthwiseConv2dDerInput(xShape, dy, filter, convInfo) {
    var dy4D = dy;
    var reshapedTo4D = false;
    if (dy.rank === 3) {
        reshapedTo4D = true;
        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
    }
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2DDerInput(dy4D, filter, convInfo); }, { dy4D: dy4D });
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function depthwiseConv2dDerFilter(x, dy, filterShape, convInfo) {
    var x4D = x;
    if (x.rank === 3) {
        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
    }
    var dy4D = dy;
    if (dy4D.rank === 3) {
        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
    }
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2DDerFilter(x4D, dy4D, convInfo); }, { x4D: x4D, dy4D: dy4D });
}

},{"../doc":46,"../environment":48,"../util":155,"./conv_util":112,"./operation":123}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computePool2DInfo(inShape, filterSize, strides, pad, roundingMode, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
    var filterShape;
    if (dataFormat === 'channelsLast') {
        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    }
    else if (dataFormat === 'channelsFirst') {
        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var dilations = 1;
    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);
}
exports.computePool2DInfo = computePool2DInfo;
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise, dataFormat) {
    if (depthwise === void 0) { depthwise = false; }
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = [-1, -1, -1, -1], batchSize = _a[0], inHeight = _a[1], inWidth = _a[2], inChannels = _a[3];
    if (dataFormat === 'channelsLast') {
        batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3];
    }
    else if (dataFormat === 'channelsFirst') {
        batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var filterHeight = filterShape[0], filterWidth = filterShape[1], filterChannels = filterShape[3];
    var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
    var _c = parseTupleParam(dilations), dilationHeight = _c[0], dilationWidth = _c[1];
    var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    var _d = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode), padInfo = _d.padInfo, outHeight = _d.outHeight, outWidth = _d.outWidth;
    var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    var outShape;
    if (dataFormat === 'channelsFirst') {
        outShape = [batchSize, outChannels, outHeight, outWidth];
    }
    else if (dataFormat === 'channelsLast') {
        outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
        batchSize: batchSize,
        dataFormat: dataFormat,
        inHeight: inHeight,
        inWidth: inWidth,
        inChannels: inChannels,
        outHeight: outHeight,
        outWidth: outWidth,
        outChannels: outChannels,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        dilationHeight: dilationHeight,
        dilationWidth: dilationWidth,
        inShape: inShape,
        outShape: outShape,
        filterShape: filterShape
    };
}
exports.computeConv2DInfo = computeConv2DInfo;
function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    var inputRows = inShape[0];
    var inputCols = inShape[1];
    var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, outDepth];
}
function computeDefaultPad(inputShape, fieldSize, stride, dilation) {
    if (dilation === void 0) { dilation = 1; }
    var effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) {
        return filterSize;
    }
    return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode) {
    var padInfo;
    var outHeight;
    var outWidth;
    if (typeof pad === 'number') {
        var padType = (pad === 0) ? 'VALID' : 'NUMBER';
        padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };
        var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        var top_1 = Math.floor(padAlongHeight / 2);
        var bottom = padAlongHeight - top_1;
        var left = Math.floor(padAlongWidth / 2);
        var right = padAlongWidth - left;
        padInfo = { top: top_1, bottom: bottom, left: left, right: right, type: 'SAME' };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: 'VALID' };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else {
        throw Error("Unknown padding parameter: " + pad);
    }
    return { padInfo: padInfo, outHeight: outHeight, outWidth: outWidth };
}
function conditionalRound(value, roundingMode) {
    if (!roundingMode) {
        return value;
    }
    switch (roundingMode) {
        case 'round':
            return Math.round(value);
        case 'ceil':
            return Math.ceil(value);
        case 'floor':
            return Math.floor(value);
        default:
            throw new Error("Unknown roundingMode " + roundingMode);
    }
}

},{"../util":155}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERF_P = 0.3275911;
exports.ERF_A1 = 0.254829592;
exports.ERF_A2 = -0.284496736;
exports.ERF_A3 = 1.421413741;
exports.ERF_A4 = -1.453152027;
exports.ERF_A5 = 1.061405429;

},{}],114:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var ImageOps = (function () {
    function ImageOps() {
    }
    ImageOps.resizeBilinear = function (images, size, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        util.assertArgumentsAreTensors({ images: images }, 'resizeBilinear');
        util.assert(images.rank === 3 || images.rank === 4, "Error in resizeBilinear: x must be rank 3 or 4, but got " +
            ("rank " + images.rank + "."));
        util.assert(size.length === 2, "Error in resizeBilinear: new shape must 2D, but got shape " +
            (size + "."));
        var batchImages = images;
        var reshapedTo4D = false;
        if (images.rank === 3) {
            reshapedTo4D = true;
            batchImages =
                images.as4D(1, images.shape[0], images.shape[1], images.shape[2]);
        }
        var newHeight = size[0], newWidth = size[1];
        var forward = function (backend, save) {
            return backend.resizeBilinear(batchImages, newHeight, newWidth, alignCorners);
        };
        var backward = function (dy, saved) {
            return {
                batchImages: function () { return environment_1.ENV.engine.runKernel(function (backend) {
                    return backend.resizeBilinearBackprop(dy, batchImages, alignCorners);
                }, {}); }
            };
        };
        var res = environment_1.ENV.engine.runKernel(forward, { batchImages: batchImages }, backward);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ImageOps.resizeNearestNeighbor = function (images, size, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        util.assertArgumentsAreTensors({ images: images }, 'resizeNearestNeighbor');
        util.assert(images.rank === 3 || images.rank === 4, "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got " +
            ("rank " + images.rank + "."));
        util.assert(size.length === 2, "Error in resizeNearestNeighbor: new shape must 2D, but got shape " +
            (size + "."));
        util.assert(images.dtype === 'float32' || images.dtype === 'int32', '`images` must have `int32` or `float32` as dtype');
        var batchImages = images;
        var reshapedTo4D = false;
        if (images.rank === 3) {
            reshapedTo4D = true;
            batchImages =
                images.as4D(1, images.shape[0], images.shape[1], images.shape[2]);
        }
        var newHeight = size[0], newWidth = size[1];
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.resizeNearestNeighbor(batchImages, newHeight, newWidth, alignCorners); }, { batchImages: batchImages });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Images', namespace: 'image' }),
        operation_1.operation
    ], ImageOps, "resizeBilinear", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Images', namespace: 'image' }),
        operation_1.operation
    ], ImageOps, "resizeNearestNeighbor", null);
    return ImageOps;
}());
exports.ImageOps = ImageOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123}],115:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var tracking_1 = require("../tracking");
var util_1 = require("../util");
var operation_1 = require("./operation");
var ops_1 = require("./ops");
var LinalgOps = (function () {
    function LinalgOps() {
    }
    LinalgOps.gramSchmidt = function (xs) {
        var inputIsTensor2D;
        if (Array.isArray(xs)) {
            inputIsTensor2D = false;
            util_1.assert(xs != null && xs.length > 0, 'Gram-Schmidt process: input must not be null, undefined, or empty');
            var dim = xs[0].shape[0];
            for (var i = 1; i < xs.length; ++i) {
                util_1.assert(xs[i].shape[0] === dim, 'Gram-Schmidt: Non-unique lengths found in the input vectors: ' +
                    ("(" + xs[i].shape[0] + " vs. " + dim + ")"));
            }
        }
        else {
            inputIsTensor2D = true;
            xs = ops_1.split(xs, xs.shape[0], 0).map(function (x) { return ops_1.squeeze(x, [0]); });
        }
        util_1.assert(xs.length <= xs[0].shape[0], "Gram-Schmidt: Number of vectors (" + xs.length + ") exceeds " +
            ("number of dimensions (" + xs[0].shape[0] + ")."));
        var ys = [];
        var xs1d = xs;
        var _loop_1 = function (i) {
            ys.push(tracking_1.Tracking.tidy(function () {
                var x = xs1d[i];
                if (i > 0) {
                    for (var j = 0; j < i; ++j) {
                        var proj = ops_1.sum(ys[j].mulStrict(x)).mul(ys[j]);
                        x = x.sub(proj);
                    }
                }
                return x.div(ops_1.norm(x, 'euclidean'));
            }));
        };
        for (var i = 0; i < xs.length; ++i) {
            _loop_1(i);
        }
        if (inputIsTensor2D) {
            return ops_1.stack(ys, 0);
        }
        else {
            return ys;
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Linear Algebra' }),
        operation_1.operation
    ], LinalgOps, "gramSchmidt", null);
    return LinalgOps;
}());
exports.LinalgOps = LinalgOps;

},{"../doc":46,"../tracking":152,"../util":155,"./operation":123,"./ops":124}],116:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var types = require("../types");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var LogicalOps = (function () {
    function LogicalOps() {
    }
    LogicalOps.logicalNot = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'logicalNot');
        util.assert(x.dtype === 'bool', 'Error Array must be of type bool.');
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalNot(x); }, { x: x });
    };
    LogicalOps.logicalAnd = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalAnd');
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalAnd(a, b); }, { a: a, b: b });
    };
    LogicalOps.logicalOr = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalOr');
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalOr(a, b); }, { a: a, b: b });
    };
    LogicalOps.logicalXor = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalXor');
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return LogicalOps.logicalOr(a, b).logicalAnd(LogicalOps.logicalAnd(a, b).logicalNot());
    };
    LogicalOps.where = function (condition, a, b) {
        util.assertArgumentsAreTensors({ condition: condition, a: a, b: b }, 'where');
        util.assert(condition.dtype === 'bool', 'Error Condition must be of type bool.');
        util.assertShapesMatch(a.shape, b.shape, 'Error in where: ');
        if (condition.rank === 1) {
            util.assert(condition.shape[0] === a.shape[0], 'The first dimension of `a` must match the size of `condition`.');
        }
        else {
            util.assertShapesMatch(condition.shape, b.shape, 'Error in where: ');
        }
        var dtype = types.upcastType(a.dtype, b.dtype);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.where(condition, a, b, dtype); }, { condition: condition, a: a, b: b });
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalNot", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalAnd", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalOr", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalXor", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "where", null);
    return LogicalOps;
}());
exports.LogicalOps = LogicalOps;

},{"../doc":46,"../environment":48,"../types":154,"../util":155,"./broadcast_util":107,"./operation":123}],117:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util = require("../util");
var operation_1 = require("./operation");
var ops = require("./ops");
var Reduction;
(function (Reduction) {
    Reduction[Reduction["NONE"] = 0] = "NONE";
    Reduction[Reduction["MEAN"] = 1] = "MEAN";
    Reduction[Reduction["SUM"] = 2] = "SUM";
    Reduction[Reduction["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Reduction = exports.Reduction || (exports.Reduction = {}));
var LossOps = (function () {
    function LossOps() {
    }
    LossOps.computeWeightedLoss = function (losses, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ losses: losses }, 'computeWeightedLoss');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'computeWeightedLoss');
        }
        var weightedLoss = (weights == null) ? losses : losses.mul(weights);
        if (reduction === Reduction.NONE) {
            return weightedLoss;
        }
        if (reduction === Reduction.SUM) {
            return weightedLoss.sum();
        }
        if (reduction === Reduction.MEAN) {
            return (weights == null) ? weightedLoss.mean() :
                weightedLoss.sum().div(weights.sum());
        }
        if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {
            if (weights == null) {
                return weightedLoss.sum().div(ops.scalar(losses.size));
            }
            else {
                var numNonZeros = weights.notEqual(ops.scalar(0)).sum().toFloat();
                return weightedLoss.sum().div(numNonZeros);
            }
        }
        throw Error("Unknown reduction: " + reduction);
    };
    LossOps.absoluteDifference = function (labels, predictions, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'absoluteDifference');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'absoluteDifference');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in absoluteDifference: ');
        var losses = labels.sub(predictions).abs();
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.meanSquaredError = function (labels, predictions, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'meanSquaredError');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'meanSquaredError');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in meanSquaredError: ');
        var losses = labels.squaredDifference(predictions);
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.cosineDistance = function (labels, predictions, axis, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'cosineDistance');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'cosineDistance');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in cosineDistance: ');
        var one = ops.scalar(1);
        var losses = one.sub(labels.mul(predictions).sum(axis, true));
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.hingeLoss = function (labels, predictions, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'hingeLoss');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'hingeLoss');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in hingeLoss: ');
        var one = ops.scalar(1);
        labels = ops.scalar(2).mul(labels).sub(one);
        var losses = one.sub(labels.mul(predictions)).relu();
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.logLoss = function (labels, predictions, weights, epsilon, reduction) {
        if (epsilon === void 0) { epsilon = 1e-7; }
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'logLoss');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'logLoss');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in logLoss: ');
        var one = ops.scalar(1);
        var epsilonScalar = ops.scalar(epsilon);
        var losses = labels.mul(predictions.add(epsilonScalar).log())
            .neg()
            .sub(one.sub(labels).mul(one.sub(predictions).add(epsilonScalar).log()));
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.huberLoss = function (labels, predictions, weights, delta, reduction) {
        if (delta === void 0) { delta = 1.0; }
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'huberLoss');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'huberLoss');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in huberLoss: ');
        var deltaScalar = ops.scalar(delta);
        var error = predictions.sub(labels).abs();
        var quadratic = ops.minimum(error, deltaScalar);
        var linear = error.sub(quadratic);
        var losses = ops.scalar(0.5).mul(quadratic.square()).add(deltaScalar.mul(linear));
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "computeWeightedLoss", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "absoluteDifference", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "meanSquaredError", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "cosineDistance", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "hingeLoss", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "logLoss", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "huberLoss", null);
    return LossOps;
}());
exports.LossOps = LossOps;

},{"../doc":46,"../util":155,"./operation":123,"./ops":124}],118:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var LRNOps = (function () {
    function LRNOps() {
    }
    LRNOps.localResponseNormalization = function (x, depthRadius, bias, alpha, beta) {
        if (depthRadius === void 0) { depthRadius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        util.assertArgumentsAreTensors({ x: x }, 'localResponseNormalization');
        util.assert(x.rank === 4 || x.rank === 3, "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + x.rank + ".");
        util.assert(util.isInt(depthRadius), "Error in localResponseNormalization: depthRadius must be an integer\n                     but got depthRadius " + depthRadius + ".");
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.localResponseNormalization4D(x4D, depthRadius, bias, alpha, beta); }, { x4D: x4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        else {
            return res;
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], LRNOps, "localResponseNormalization", null);
    return LRNOps;
}());
exports.LRNOps = LRNOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123}],119:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util = require("../util");
var operation_1 = require("./operation");
var LSTMOps = (function () {
    function LSTMOps() {
    }
    LSTMOps.multiRNNCell = function (lstmCells, data, c, h) {
        util.assertArgumentsAreTensors({ data: data, c: c, h: h }, 'multiRNNCell');
        var input = data;
        var newStates = [];
        for (var i = 0; i < lstmCells.length; i++) {
            var output = lstmCells[i](input, c[i], h[i]);
            newStates.push(output[0]);
            newStates.push(output[1]);
            input = output[1];
        }
        var newC = [];
        var newH = [];
        for (var i = 0; i < newStates.length; i += 2) {
            newC.push(newStates[i]);
            newH.push(newStates[i + 1]);
        }
        return [newC, newH];
    };
    LSTMOps.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        util.assertArgumentsAreTensors({ forgetBias: forgetBias, lstmKernel: lstmKernel, lstmBias: lstmBias, data: data, c: c, h: h }, 'basicLSTMCell');
        var combined = data.concat(h, 1);
        var weighted = combined.matMul(lstmKernel);
        var res = weighted.add(lstmBias);
        var batchSize = res.shape[0];
        var sliceCols = res.shape[1] / 4;
        var sliceSize = [batchSize, sliceCols];
        var i = res.slice([0, 0], sliceSize);
        var j = res.slice([0, sliceCols], sliceSize);
        var f = res.slice([0, sliceCols * 2], sliceSize);
        var o = res.slice([0, sliceCols * 3], sliceSize);
        var newC = i.sigmoid().mulStrict(j.tanh()).addStrict(c.mulStrict(forgetBias.add(f).sigmoid()));
        var newH = newC.tanh().mulStrict(o.sigmoid());
        return [newC, newH];
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'RNN' }),
        operation_1.operation
    ], LSTMOps, "multiRNNCell", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'RNN' }),
        operation_1.operation
    ], LSTMOps, "basicLSTMCell", null);
    return LSTMOps;
}());
exports.LSTMOps = LSTMOps;

},{"../doc":46,"../util":155,"./operation":123}],120:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var MatmulOps = (function () {
    function MatmulOps() {
    }
    MatmulOps.matMul = function (a, b, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        util.assertArgumentsAreTensors({ a: a, b: b }, 'matMul');
        var innerShapeA = transposeA ? a.shape[0] : a.shape[1];
        var innerShapeB = transposeB ? b.shape[1] : b.shape[0];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            (" and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of Tensors with shapes " + a.shape + " and ") +
            (b.shape + " and transposeA=" + transposeA) +
            (" and transposeB=" + transposeB + " must match."));
        var grad = function (dy) {
            if (!transposeA && !transposeB) {
                return {
                    a: function () { return dy.matMul(b.toFloat(), false, true); },
                    b: function () { return a.toFloat().matMul(dy, true, false); }
                };
            }
            else if (!transposeA && transposeB) {
                return {
                    a: function () { return dy.matMul(b.toFloat(), false, false); },
                    b: function () { return dy.matMul(a.toFloat(), true, false); }
                };
            }
            else if (transposeA && !transposeB) {
                return {
                    a: function () { return b.toFloat().matMul(dy, false, true); },
                    b: function () { return a.toFloat().matMul(dy, false, false); }
                };
            }
            else {
                return {
                    a: function () { return b.toFloat().matMul(dy, true, true); },
                    b: function () { return dy.matMul(a.toFloat(), true, true); }
                };
            }
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.matMul(a, b, transposeA, transposeB); }, { a: a, b: b }, grad);
    };
    MatmulOps.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " +
            ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
        return v.as2D(1, -1).matMul(matrix).as1D();
    };
    MatmulOps.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return matrix.matMul(v.as2D(-1, 1)).as1D();
    };
    MatmulOps.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return v1.as2D(1, -1).matMul(v2.as2D(-1, 1)).asScalar();
    };
    MatmulOps.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return v1.as2D(-1, 1).matMul(v2.as2D(1, -1));
    };
    MatmulOps.dot = function (t1, t2) {
        util.assert((t1.rank === 1 || t1.rank === 2) && (t2.rank === 1 || t2.rank === 2), "Error in dot: inputs must all be rank 1 or 2, but got ranks " +
            (t1.rank + " and " + t2.rank + "."));
        var t1Inner = (t1.rank === 1 ? t1.size : t1.shape[1]);
        var t2Inner = (t2.rank === 1 ? t2.size : t2.shape[0]);
        util.assert(t1Inner === t2Inner, "Error in dot: inner dimensions of inputs must match, but got " +
            (t1Inner + " and " + t2Inner + "."));
        if (t1.rank === 1 && t2.rank === 1) {
            return t1.as2D(1, -1).matMul(t2.as2D(-1, 1)).asScalar();
        }
        else if (t1.rank === 1 && t2.rank === 2) {
            return t1.as2D(1, -1).matMul(t2.as2D(t2.shape[0], t2.shape[1])).as1D();
        }
        else if (t1.rank === 2 && t2.rank === 1) {
            return t1.matMul(t2.as2D(-1, 1)).as1D();
        }
        else {
            return t1.matMul(t2.as2D(t2.shape[0], t2.shape[1]));
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], MatmulOps, "matMul", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "vectorTimesMatrix", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "matrixTimesVector", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "dotProduct", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], MatmulOps, "outerProduct", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], MatmulOps, "dot", null);
    return MatmulOps;
}());
exports.MatmulOps = MatmulOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123}],121:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util = require("../util");
var array_ops_1 = require("./array_ops");
var binary_ops_1 = require("./binary_ops");
var operation_1 = require("./operation");
var MovingAverageOps = (function () {
    function MovingAverageOps() {
    }
    MovingAverageOps.movingAverage = function (v, x, decay, step, zeroDebias) {
        if (zeroDebias === void 0) { zeroDebias = true; }
        util.assertArgumentsAreTensors({ v: v, x: x }, 'movingAverage');
        util.assertTypesMatch(v, x);
        util.assert(util.arraysEqual(v.shape, x.shape), 'Shape mismatch in v and x');
        var one = array_ops_1.ArrayOps.scalar(1);
        decay = typeof decay === 'number' ? array_ops_1.ArrayOps.scalar(decay) : decay;
        var oneMinusDecay = one.sub(decay);
        var update = x.sub(v).mul(oneMinusDecay);
        if (zeroDebias) {
            util.assert(step != null, 'When using zeroDebias: true, step is required.');
            step = typeof step === 'number' ? array_ops_1.ArrayOps.scalar(step) : step;
            update = update.div(one.sub(binary_ops_1.BinaryOps.pow(decay, step)));
        }
        return v.add(update);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Moving Average' }),
        operation_1.operation
    ], MovingAverageOps, "movingAverage", null);
    return MovingAverageOps;
}());
exports.MovingAverageOps = MovingAverageOps;

},{"../doc":46,"../util":155,"./array_ops":103,"./binary_ops":106,"./operation":123}],122:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var NormOps = (function () {
    function NormOps() {
    }
    NormOps.norm = function (x, ord, axis, keepDims) {
        if (ord === void 0) { ord = 'euclidean'; }
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'norm');
        var norm = normImpl(x, ord, axis);
        var keepDimsShape = norm.shape;
        if (keepDims) {
            var axes = axis_util.parseAxisParam(axis, x.shape);
            keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);
        }
        return norm.reshape(keepDimsShape);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], NormOps, "norm", null);
    return NormOps;
}());
exports.NormOps = NormOps;
function normImpl(x, p, axis) {
    if (axis === void 0) { axis = null; }
    if (x.rank === 0) {
        return x.abs();
    }
    if (x.rank !== 1 && axis === null) {
        return normImpl(x.reshape([-1]), p, axis);
    }
    if (x.rank === 1 || typeof axis === 'number' ||
        axis instanceof Array && axis.length === 1) {
        if (p === 1) {
            return x.abs().sum(axis);
        }
        if (p === Infinity) {
            return x.abs().max(axis);
        }
        if (p === -Infinity) {
            return x.abs().min(axis);
        }
        if (p === 'euclidean' || p === 2) {
            return x.abs().pow(ops.scalar(2, 'int32')).sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    if (axis instanceof Array && axis.length === 2) {
        if (p === 1) {
            return x.abs().sum(axis[0]).max(axis[1] - 1);
        }
        if (p === Infinity) {
            return x.abs().sum(axis[1]).max(axis[0]);
        }
        if (p === -Infinity) {
            return x.abs().sum(axis[1]).min(axis[0]);
        }
        if (p === 'fro' || p === 'euclidean') {
            return x.square().sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    throw new Error("Error in norm: invalid axis: " + axis);
}

},{"../doc":46,"../util":155,"./axis_util":104,"./operation":123,"./ops":124}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
function operation(target, name, descriptor) {
    var fn = descriptor.value;
    descriptor.value = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return globals_1.tidy(name, function () { return fn.apply(void 0, args); });
    };
    return descriptor;
}
exports.operation = operation;

},{"../globals":49}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var array_ops_1 = require("./array_ops");
var batchnorm_1 = require("./batchnorm");
var binary_ops_1 = require("./binary_ops");
var compare_1 = require("./compare");
var concat_1 = require("./concat");
var conv_1 = require("./conv");
var image_ops_1 = require("./image_ops");
var linalg_ops_1 = require("./linalg_ops");
var logical_ops_1 = require("./logical_ops");
var loss_ops_1 = require("./loss_ops");
var lrn_1 = require("./lrn");
var lstm_1 = require("./lstm");
var matmul_1 = require("./matmul");
var moving_average_1 = require("./moving_average");
var norm_1 = require("./norm");
var pool_1 = require("./pool");
var reduction_ops_1 = require("./reduction_ops");
var reverse_1 = require("./reverse");
var slice_1 = require("./slice");
var softmax_1 = require("./softmax");
var strided_slice_1 = require("./strided_slice");
var transpose_1 = require("./transpose");
var unary_ops_1 = require("./unary_ops");
exports.batchNormalization = batchnorm_1.BatchNormOps.batchNormalization;
exports.batchNormalization2d = batchnorm_1.BatchNormOps.batchNormalization2d;
exports.batchNormalization3d = batchnorm_1.BatchNormOps.batchNormalization3d;
exports.batchNormalization4d = batchnorm_1.BatchNormOps.batchNormalization4d;
exports.concat = concat_1.ConcatOps.concat;
exports.concat1d = concat_1.ConcatOps.concat1d;
exports.concat2d = concat_1.ConcatOps.concat2d;
exports.concat3d = concat_1.ConcatOps.concat3d;
exports.concat4d = concat_1.ConcatOps.concat4d;
exports.conv1d = conv_1.ConvOps.conv1d;
exports.conv2d = conv_1.ConvOps.conv2d;
exports.conv2dTranspose = conv_1.ConvOps.conv2dTranspose;
exports.depthwiseConv2d = conv_1.ConvOps.depthwiseConv2d;
exports.separableConv2d = conv_1.ConvOps.separableConv2d;
exports.matMul = matmul_1.MatmulOps.matMul;
exports.matrixTimesVector = matmul_1.MatmulOps.matrixTimesVector;
exports.outerProduct = matmul_1.MatmulOps.outerProduct;
exports.vectorTimesMatrix = matmul_1.MatmulOps.vectorTimesMatrix;
exports.dot = matmul_1.MatmulOps.dot;
exports.avgPool = pool_1.PoolOps.avgPool;
exports.maxPool = pool_1.PoolOps.maxPool;
exports.transpose = transpose_1.TransposeOps.transpose;
exports.reverse = reverse_1.ReverseOps.reverse;
exports.reverse1d = reverse_1.ReverseOps.reverse1d;
exports.reverse2d = reverse_1.ReverseOps.reverse2d;
exports.reverse3d = reverse_1.ReverseOps.reverse3d;
exports.reverse4d = reverse_1.ReverseOps.reverse4d;
exports.slice = slice_1.SliceOps.slice;
exports.slice1d = slice_1.SliceOps.slice1d;
exports.slice2d = slice_1.SliceOps.slice2d;
exports.slice3d = slice_1.SliceOps.slice3d;
exports.slice4d = slice_1.SliceOps.slice4d;
exports.stridedSlice = strided_slice_1.StridedSliceOps.stridedSlice;
exports.argMax = reduction_ops_1.ReductionOps.argMax;
exports.argMin = reduction_ops_1.ReductionOps.argMin;
exports.logSumExp = reduction_ops_1.ReductionOps.logSumExp;
exports.max = reduction_ops_1.ReductionOps.max;
exports.mean = reduction_ops_1.ReductionOps.mean;
exports.min = reduction_ops_1.ReductionOps.min;
exports.moments = reduction_ops_1.ReductionOps.moments;
exports.sum = reduction_ops_1.ReductionOps.sum;
exports.unsortedSegmentSum = reduction_ops_1.ReductionOps.unsortedSegmentSum;
exports.equal = compare_1.CompareOps.equal;
exports.equalStrict = compare_1.CompareOps.equalStrict;
exports.greater = compare_1.CompareOps.greater;
exports.greaterStrict = compare_1.CompareOps.greaterStrict;
exports.greaterEqual = compare_1.CompareOps.greaterEqual;
exports.greaterEqualStrict = compare_1.CompareOps.greaterEqualStrict;
exports.less = compare_1.CompareOps.less;
exports.lessStrict = compare_1.CompareOps.lessStrict;
exports.lessEqual = compare_1.CompareOps.lessEqual;
exports.lessEqualStrict = compare_1.CompareOps.lessEqualStrict;
exports.notEqual = compare_1.CompareOps.notEqual;
exports.notEqualStrict = compare_1.CompareOps.notEqualStrict;
exports.logicalNot = logical_ops_1.LogicalOps.logicalNot;
exports.logicalAnd = logical_ops_1.LogicalOps.logicalAnd;
exports.logicalOr = logical_ops_1.LogicalOps.logicalOr;
exports.logicalXor = logical_ops_1.LogicalOps.logicalXor;
exports.where = logical_ops_1.LogicalOps.where;
exports.abs = unary_ops_1.UnaryOps.abs;
exports.acos = unary_ops_1.UnaryOps.acos;
exports.acosh = unary_ops_1.UnaryOps.acosh;
exports.asin = unary_ops_1.UnaryOps.asin;
exports.asinh = unary_ops_1.UnaryOps.asinh;
exports.atan = unary_ops_1.UnaryOps.atan;
exports.atanh = unary_ops_1.UnaryOps.atanh;
exports.ceil = unary_ops_1.UnaryOps.ceil;
exports.clipByValue = unary_ops_1.UnaryOps.clipByValue;
exports.cos = unary_ops_1.UnaryOps.cos;
exports.cosh = unary_ops_1.UnaryOps.cosh;
exports.elu = unary_ops_1.UnaryOps.elu;
exports.exp = unary_ops_1.UnaryOps.exp;
exports.expm1 = unary_ops_1.UnaryOps.expm1;
exports.floor = unary_ops_1.UnaryOps.floor;
exports.sign = unary_ops_1.UnaryOps.sign;
exports.leakyRelu = unary_ops_1.UnaryOps.leakyRelu;
exports.log = unary_ops_1.UnaryOps.log;
exports.log1p = unary_ops_1.UnaryOps.log1p;
exports.logSigmoid = unary_ops_1.UnaryOps.logSigmoid;
exports.neg = unary_ops_1.UnaryOps.neg;
exports.prelu = unary_ops_1.UnaryOps.prelu;
exports.relu = unary_ops_1.UnaryOps.relu;
exports.reciprocal = unary_ops_1.UnaryOps.reciprocal;
exports.round = unary_ops_1.UnaryOps.round;
exports.selu = unary_ops_1.UnaryOps.selu;
exports.sigmoid = unary_ops_1.UnaryOps.sigmoid;
exports.sin = unary_ops_1.UnaryOps.sin;
exports.sinh = unary_ops_1.UnaryOps.sinh;
exports.softplus = unary_ops_1.UnaryOps.softplus;
exports.sqrt = unary_ops_1.UnaryOps.sqrt;
exports.rsqrt = unary_ops_1.UnaryOps.rsqrt;
exports.square = unary_ops_1.UnaryOps.square;
exports.step = unary_ops_1.UnaryOps.step;
exports.tan = unary_ops_1.UnaryOps.tan;
exports.tanh = unary_ops_1.UnaryOps.tanh;
exports.erf = unary_ops_1.UnaryOps.erf;
exports.add = binary_ops_1.BinaryOps.add;
exports.addStrict = binary_ops_1.BinaryOps.addStrict;
exports.atan2 = binary_ops_1.BinaryOps.atan2;
exports.div = binary_ops_1.BinaryOps.div;
exports.floorDiv = binary_ops_1.BinaryOps.floorDiv;
exports.divStrict = binary_ops_1.BinaryOps.divStrict;
exports.maximum = binary_ops_1.BinaryOps.maximum;
exports.maximumStrict = binary_ops_1.BinaryOps.maximumStrict;
exports.minimum = binary_ops_1.BinaryOps.minimum;
exports.minimumStrict = binary_ops_1.BinaryOps.minimumStrict;
exports.mod = binary_ops_1.BinaryOps.mod;
exports.modStrict = binary_ops_1.BinaryOps.modStrict;
exports.mul = binary_ops_1.BinaryOps.mul;
exports.mulStrict = binary_ops_1.BinaryOps.mulStrict;
exports.pow = binary_ops_1.BinaryOps.pow;
exports.powStrict = binary_ops_1.BinaryOps.powStrict;
exports.sub = binary_ops_1.BinaryOps.sub;
exports.subStrict = binary_ops_1.BinaryOps.subStrict;
exports.squaredDifference = binary_ops_1.BinaryOps.squaredDifference;
exports.squaredDifferenceStrict = binary_ops_1.BinaryOps.squaredDifferenceStrict;
exports.norm = norm_1.NormOps.norm;
exports.cast = array_ops_1.ArrayOps.cast;
exports.clone = array_ops_1.ArrayOps.clone;
exports.fromPixels = array_ops_1.ArrayOps.fromPixels;
exports.toPixels = array_ops_1.ArrayOps.toPixels;
exports.ones = array_ops_1.ArrayOps.ones;
exports.onesLike = array_ops_1.ArrayOps.onesLike;
exports.zeros = array_ops_1.ArrayOps.zeros;
exports.zerosLike = array_ops_1.ArrayOps.zerosLike;
exports.eye = array_ops_1.ArrayOps.eye;
exports.rand = array_ops_1.ArrayOps.rand;
exports.randomNormal = array_ops_1.ArrayOps.randomNormal;
exports.truncatedNormal = array_ops_1.ArrayOps.truncatedNormal;
exports.randomUniform = array_ops_1.ArrayOps.randomUniform;
exports.multinomial = array_ops_1.ArrayOps.multinomial;
exports.reshape = array_ops_1.ArrayOps.reshape;
exports.squeeze = array_ops_1.ArrayOps.squeeze;
exports.tile = array_ops_1.ArrayOps.tile;
exports.gather = array_ops_1.ArrayOps.gather;
exports.oneHot = array_ops_1.ArrayOps.oneHot;
exports.linspace = array_ops_1.ArrayOps.linspace;
exports.range = array_ops_1.ArrayOps.range;
exports.buffer = array_ops_1.ArrayOps.buffer;
exports.fill = array_ops_1.ArrayOps.fill;
exports.tensor = array_ops_1.ArrayOps.tensor;
exports.scalar = array_ops_1.ArrayOps.scalar;
exports.tensor1d = array_ops_1.ArrayOps.tensor1d;
exports.tensor2d = array_ops_1.ArrayOps.tensor2d;
exports.tensor3d = array_ops_1.ArrayOps.tensor3d;
exports.tensor4d = array_ops_1.ArrayOps.tensor4d;
exports.tensor5d = array_ops_1.ArrayOps.tensor5d;
exports.print = array_ops_1.ArrayOps.print;
exports.expandDims = array_ops_1.ArrayOps.expandDims;
exports.stack = array_ops_1.ArrayOps.stack;
exports.unstack = array_ops_1.ArrayOps.unstack;
exports.split = array_ops_1.ArrayOps.split;
exports.cumsum = array_ops_1.ArrayOps.cumsum;
exports.pad = array_ops_1.ArrayOps.pad;
exports.pad1d = array_ops_1.ArrayOps.pad1d;
exports.pad2d = array_ops_1.ArrayOps.pad2d;
exports.pad3d = array_ops_1.ArrayOps.pad3d;
exports.pad4d = array_ops_1.ArrayOps.pad4d;
exports.movingAverage = moving_average_1.MovingAverageOps.movingAverage;
exports.basicLSTMCell = lstm_1.LSTMOps.basicLSTMCell;
exports.multiRNNCell = lstm_1.LSTMOps.multiRNNCell;
exports.softmax = softmax_1.SoftmaxOps.softmax;
exports.localResponseNormalization = lrn_1.LRNOps.localResponseNormalization;
exports.linalg = linalg_ops_1.LinalgOps;
var operation_1 = require("./operation");
exports.operation = operation_1.operation;
var tensor_1 = require("../tensor");
var types_1 = require("../types");
[tensor_1.Tensor, types_1.Rank];
[loss_ops_1.Reduction];
exports.losses = {
    absoluteDifference: loss_ops_1.LossOps.absoluteDifference,
    computeWeightedLoss: loss_ops_1.LossOps.computeWeightedLoss,
    cosineDistance: loss_ops_1.LossOps.cosineDistance,
    hingeLoss: loss_ops_1.LossOps.hingeLoss,
    huberLoss: loss_ops_1.LossOps.huberLoss,
    logLoss: loss_ops_1.LossOps.logLoss,
    meanSquaredError: loss_ops_1.LossOps.meanSquaredError,
    softmaxCrossEntropy: softmax_1.SoftmaxOps.softmaxCrossEntropy
};
exports.image = {
    resizeBilinear: image_ops_1.ImageOps.resizeBilinear,
    resizeNearestNeighbor: image_ops_1.ImageOps.resizeNearestNeighbor,
};

},{"../tensor":149,"../types":154,"./array_ops":103,"./batchnorm":105,"./binary_ops":106,"./compare":108,"./concat":109,"./conv":111,"./image_ops":114,"./linalg_ops":115,"./logical_ops":116,"./loss_ops":117,"./lrn":118,"./lstm":119,"./matmul":120,"./moving_average":121,"./norm":122,"./operation":123,"./pool":125,"./reduction_ops":128,"./reverse":129,"./slice":131,"./softmax":133,"./strided_slice":134,"./transpose":135,"./unary_ops":136}],125:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var conv_util = require("./conv_util");
var operation_1 = require("./operation");
var PoolOps = (function () {
    function PoolOps() {
    }
    PoolOps.maxPool = function (x, filterSize, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ x: x }, 'maxPool');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in maxPool: input must be rank 4 but got rank " + x4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in maxPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad, dimRoundingMode);
        var grad = function (dy, saved) {
            var y4D = saved[0];
            return {
                x: function () { return PoolOps.maxPoolBackprop(dy, x4D, y4D, filterSize, strides, pad); }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.maxPool(x4D, convInfo)); }, { x: x4D }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    PoolOps.maxPoolBackprop = function (dy, input, output, filterSize, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ dy: dy, input: input, output: output }, 'maxPoolBackprop');
        util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
        util.assert(dy.rank === 4, "Error in maxPoolBackprop: dy must be rank 4 but got rank " +
            (dy.rank + "."));
        util.assert(input.rank === 4, "Error in maxPoolBackprop: input must be rank 4 but got rank " +
            (input.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in maxPoolBackprop: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(input.shape, filterSize, strides, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.maxPoolBackprop(dy, input, output, convInfo); }, { dy: dy, input: input });
        return res;
    };
    PoolOps.avgPool = function (x, filterSize, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ x: x }, 'avgPool');
        util.assert(x.dtype === 'float32', 'The input dtype to avgPool must be float32');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in avgPool: x must be rank 4 but got rank " + x4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in avgPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad);
        var grad = function (dy) {
            return {
                x: function () { return PoolOps.avgPoolBackprop(dy, x4D, filterSize, strides, pad); }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.avgPool(x4D, convInfo); }, { x: x4D }, grad);
        res = res.cast(x.dtype);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    PoolOps.avgPoolBackprop = function (dy, input, filterSize, strides, pad) {
        util.assertArgumentsAreTensors({ dy: dy, input: input }, 'avgPoolBackprop');
        util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
        var input4D = input;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(dy4D.rank === 4, "Error in avgPoolBackprop: dy must be rank 4 but got rank " +
            (dy4D.rank + "."));
        util.assert(input4D.rank === 4, "Error in avgPoolBackprop: input must be rank 4 but got rank " +
            (input4D.rank + "."));
        var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.avgPoolBackprop(dy4D, input4D, convInfo); }, { dy4D: dy4D, input4D: input4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], PoolOps, "maxPool", null);
    __decorate([
        operation_1.operation
    ], PoolOps, "maxPoolBackprop", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], PoolOps, "avgPool", null);
    __decorate([
        operation_1.operation
    ], PoolOps, "avgPoolBackprop", null);
    return PoolOps;
}());
exports.PoolOps = PoolOps;

},{"../doc":46,"../environment":48,"../util":155,"./conv_util":112,"./operation":123}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var MPRandGauss = (function () {
    function MPRandGauss(mean, stdDeviation, dtype, truncated, seed) {
        this.mean = mean;
        this.stdDev = stdDeviation;
        this.dtype = dtype;
        this.nextVal = NaN;
        this.truncated = truncated;
        if (this.truncated) {
            this.upper = this.mean + this.stdDev * 2;
            this.lower = this.mean - this.stdDev * 2;
        }
        var seedValue = seed ? seed : Math.random();
        this.random = seedrandom.alea(seedValue.toString());
    }
    MPRandGauss.prototype.nextValue = function () {
        if (!isNaN(this.nextVal)) {
            var value = this.nextVal;
            this.nextVal = NaN;
            return value;
        }
        var resultX, resultY;
        var isValid = false;
        while (!isValid) {
            var v1 = void 0, v2 = void 0, s = void 0;
            do {
                v1 = 2 * this.random() - 1;
                v2 = 2 * this.random() - 1;
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s === 0);
            var mul = Math.sqrt(-2.0 * Math.log(s) / s);
            resultX = this.mean + this.stdDev * v1 * mul;
            resultY = this.mean + this.stdDev * v2 * mul;
            if (!this.truncated || this.isValidTruncated(resultX)) {
                isValid = true;
            }
        }
        if (!this.truncated || this.isValidTruncated(resultY)) {
            this.nextVal = this.convertValue(resultY);
        }
        return this.convertValue(resultX);
    };
    MPRandGauss.prototype.convertValue = function (value) {
        if (this.dtype == null || this.dtype === 'float32') {
            return value;
        }
        return Math.round(value);
    };
    MPRandGauss.prototype.isValidTruncated = function (value) {
        return value <= this.upper && value >= this.lower;
    };
    return MPRandGauss;
}());
exports.MPRandGauss = MPRandGauss;

},{"seedrandom":208}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
    if (inSize <= exports.PARALLELIZE_THRESHOLD) {
        return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
exports.computeOptimalWindowSize = computeOptimalWindowSize;
function nearestDivisor(size, start) {
    for (var i = start; i < size; ++i) {
        if (size % i === 0) {
            return i;
        }
    }
    return size;
}

},{}],128:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var ReductionOps = (function () {
    function ReductionOps() {
    }
    ReductionOps.logSumExp = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'logSumExp');
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var xMax = x.max(axes, true);
        var a = x.sub(xMax);
        var b = a.exp();
        var c = b.sum(axes);
        var d = c.log();
        var res = xMax.reshape(d.shape).add(d);
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.sum = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'sum');
        if (x.dtype === 'bool') {
            x = x.toInt();
        }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var customOp = globals_1.customGrad(function (x) {
            var permutation = axis_util.getAxesPermutation(axes, x.rank);
            var reductionAxes = axes;
            var permutedX = x;
            if (permutation != null) {
                permutedX = x.transpose(permutation);
                reductionAxes =
                    axis_util.getInnerMostAxes(reductionAxes.length, x.rank);
            }
            var value = environment_1.ENV.engine.runKernel(function (backend) { return backend.sum(permutedX, reductionAxes); }, { permutedX: permutedX });
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(value.shape, axes);
                value = value.reshape(newShape);
            }
            var gradFunc = function (dy) {
                var expandedDyShape = x.shape.slice();
                axes.forEach(function (axis) {
                    expandedDyShape[axis] = 1;
                });
                var expandedDy = dy.reshape(expandedDyShape);
                var derX = expandedDy.mul(ops.ones(x.shape, 'float32'));
                return derX;
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(x);
    };
    ReductionOps.mean = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'mean');
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
        var reduceShape = shapes[1];
        var reduceSize = util.sizeFromShape(reduceShape);
        var customOp = globals_1.customGrad(function (x) {
            var reduceSizeScalar = ops.scalar(reduceSize);
            var xReduce = reduceSizeScalar.dtype === x.dtype ?
                x :
                x.cast(reduceSizeScalar.dtype);
            var res = xReduce.div(reduceSizeScalar);
            var value = res.sum(axis, keepDims);
            var gradFunc = function (dy) {
                var expandedDyShape = x.shape.slice();
                axes.forEach(function (axis) {
                    expandedDyShape[axis] = 1;
                });
                var expandedDy = dy.reshape(expandedDyShape);
                var derX = expandedDy.mul(ops.ones(x.shape, 'float32')).div(reduceSizeScalar);
                return derX;
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(x);
    };
    ReductionOps.min = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'min');
        var origAxes = axis_util.parseAxisParam(axis, x.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.min(x, axes); }, { x: x });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.max = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'max');
        var origAxes = axis_util.parseAxisParam(axis, x.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.max(x, axes); }, { x: x });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.argMin = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'argMin');
        if (axis == null) {
            axis = 0;
        }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.argMin(x, axes[0]); }, { x: x });
    };
    ReductionOps.argMax = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'argMax');
        if (axis == null) {
            axis = 0;
        }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.argMax(x, axes[0]); }, { x: x });
    };
    ReductionOps.moments = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'moments');
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var mean = x.mean(axes, keepDims);
        var keepDimsShape = mean.shape;
        if (!keepDims) {
            keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
        }
        var devSquared = x.toFloat().sub(mean.reshape(keepDimsShape)).square();
        var variance = devSquared.mean(axes, keepDims);
        return { mean: mean, variance: variance };
    };
    ReductionOps.unsortedSegmentSum = function (x, segmentIds, numSegments, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x, segmentIds: segmentIds }, 'unsortedSegmentSum');
        util.assert(segmentIds.dtype === 'int32', 'Segment Ids must be of dtype `int32`');
        axis = axis_util.parseAxisParam(axis, x.shape)[0];
        var res = [];
        var dim = segmentIds.shape[0];
        var newShape = [];
        for (var i = 0; i < x.shape.length; i++) {
            if (i === axis) {
                newShape.push(dim);
            }
            else {
                newShape.push(1);
            }
        }
        var reshapedSegmentIds = ops.reshape(segmentIds, newShape);
        for (var i = 0; i < numSegments; i++) {
            var segmentId = ops.scalar(i, 'int32');
            var mask = ops.equal(segmentId, reshapedSegmentIds).asType('float32');
            var sum = mask.mul(x).sum(axis);
            res.push(sum);
        }
        return ops.stack(res, axis);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "logSumExp", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "sum", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "mean", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "min", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "max", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "argMin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "argMax", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], ReductionOps, "moments", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "unsortedSegmentSum", null);
    return ReductionOps;
}());
exports.ReductionOps = ReductionOps;

},{"../doc":46,"../environment":48,"../globals":49,"../util":155,"./axis_util":104,"./operation":123,"./ops":124}],129:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var operation_1 = require("./operation");
var ReverseOps = (function () {
    function ReverseOps() {
    }
    ReverseOps.reverse1d = function (x) {
        util.assert(x.rank === 1, "Error in reverse1D: x must be rank 1 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, 0);
    };
    ReverseOps.reverse2d = function (x, axis) {
        util.assert(x.rank === 2, "Error in reverse2D: x must be rank 2 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse3d = function (x, axis) {
        util.assert(x.rank === 3, "Error in reverse3D: x must be rank 3 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse4d = function (x, axis) {
        util.assert(x.rank === 4, "Error in reverse4D: x must be rank 4 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse = function (x, axis) {
        util.assertArgumentsAreTensors({ x: x }, 'reverse');
        if (x.rank === 0) {
            return x.clone();
        }
        var axes = axis_util_1.parseAxisParam(axis, x.shape);
        var grad = function (dy) {
            return { x: function () { return dy.reverse(axes); } };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.reverse(x, axes); }, { x: x }, grad);
        return res.reshapeAs(x);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ReverseOps, "reverse", null);
    return ReverseOps;
}());
exports.ReverseOps = ReverseOps;

},{"../doc":46,"../environment":48,"../util":155,"./axis_util":104,"./operation":123}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SELU_SCALEALPHA = 1.7580993408473768599402175208123;
exports.SELU_SCALE = 1.0507009873554804934193349852946;

},{}],131:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var slice_util = require("./slice_util");
var SliceOps = (function () {
    function SliceOps() {
    }
    SliceOps.slice1d = function (x, begin, size) {
        util.assert(x.rank === 1, "slice1d expects a rank-1 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, [begin], [size]);
    };
    SliceOps.slice2d = function (x, begin, size) {
        util.assert(x.rank === 2, "slice1d expects a rank-2 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice3d = function (x, begin, size) {
        util.assert(x.rank === 3, "slice1d expects a rank-3 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice4d = function (x, begin, size) {
        util.assert(x.rank === 4, "slice1d expects a rank-4 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice = function (x, begin, size) {
        util.assertArgumentsAreTensors({ x: x }, 'slice');
        if (x.rank === 0) {
            throw new Error('Slicing scalar is not possible');
        }
        var begin_;
        if (typeof begin === 'number') {
            begin_ = [begin].concat(new Array(x.rank - 1).fill(0));
        }
        else if (begin.length < x.rank) {
            begin_ = begin.concat(new Array(x.rank - begin.length).fill(0));
        }
        else {
            begin_ = begin;
        }
        var size_;
        if (size == null) {
            size_ = new Array(x.rank).fill(-1);
        }
        else if (typeof size === 'number') {
            size_ = [size].concat(new Array(x.rank - 1).fill(-1));
        }
        else if (size.length < x.rank) {
            size_ = size.concat(new Array(x.rank - size.length).fill(-1));
        }
        else {
            size_ = size;
        }
        size_ = size_.map(function (d, i) {
            if (d >= 0) {
                return d;
            }
            else {
                util.assert(d === -1, 'Bad value in size');
                return x.shape[i] - begin_[i];
            }
        });
        slice_util.assertParamsValid(x, begin_, size_);
        var inputShape = x.shape;
        var grad = function (dy) {
            var paddings = [];
            for (var i = 0; i < dy.rank; i++) {
                paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);
            }
            return { x: function () { return dy.pad(paddings); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.slice(x, begin_, size_); }, { x: x }, grad);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], SliceOps, "slice", null);
    return SliceOps;
}());
exports.SliceOps = SliceOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123,"./slice_util":132}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParamsValid(input, begin, size) {
    util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    for (var i = 0; i < input.rank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
            ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
    }
}
exports.assertParamsValid = assertParamsValid;
function getStridedSlicedInfo(shape, begin, end, strides, beginMask, endMask) {
    if (beginMask === void 0) { beginMask = 0; }
    if (endMask === void 0) { endMask = 0; }
    var startIndex = [];
    var endIndex = [];
    for (var i = 0; i < shape.length; i++) {
        startIndex[i] = startForAxis(beginMask, begin, strides, shape, i);
        endIndex[i] = stopForAxis(endMask, end, strides, shape, i);
    }
    var size = new Array(shape.length).fill(0);
    size = size.map(function (d, i) {
        var count = 0;
        for (var start = startIndex[i]; !(strides[i] > 0 ? start >= endIndex[i] : start <= endIndex[i]); start += strides[i]) {
            count += 1;
        }
        return count;
    });
    return [startIndex, size];
}
exports.getStridedSlicedInfo = getStridedSlicedInfo;
function startForAxis(beginMask, startIndices, strides, inputShape, axis) {
    var start = startIndices[axis];
    if (beginMask & 1 << axis) {
        if (strides[axis] > 0) {
            start = Number.MIN_SAFE_INTEGER;
        }
        else {
            start = Number.MAX_SAFE_INTEGER;
        }
    }
    var axisSize = inputShape[axis];
    if (start < 0) {
        start += axisSize;
    }
    start = util.clamp(0, start, axisSize - 1);
    return start;
}
exports.startForAxis = startForAxis;
function stopForAxis(endMask, stopIndices, strides, inputShape, axis) {
    var stop = stopIndices[axis];
    if (endMask & (1 << axis)) {
        if (strides[axis] > 0) {
            stop = Number.MAX_SAFE_INTEGER;
        }
        else {
            stop = Number.MIN_SAFE_INTEGER;
        }
    }
    var axisSize = inputShape[axis];
    if (stop < 0) {
        stop += axisSize;
    }
    if (strides[axis] > 0) {
        stop = util.clamp(0, stop, axisSize);
    }
    else {
        stop = util.clamp(-1, stop, axisSize - 1);
    }
    return stop;
}
exports.stopForAxis = stopForAxis;

},{"../util":155}],133:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var globals_1 = require("../globals");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var SoftmaxOps = (function () {
    function SoftmaxOps() {
    }
    SoftmaxOps.softmax = function (logits, dim) {
        if (dim === void 0) { dim = -1; }
        util.assertArgumentsAreTensors({ logits: logits }, 'softmax');
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error('Softmax along a non-last dimension is not yet supported. ' +
                ("Logits was rank " + logits.rank + " and dim was " + dim));
        }
        var customOp = globals_1.customGrad(function (logits) {
            var keepDims = true;
            var lse = logits.logSumExp([dim], keepDims);
            var logResult = logits.toFloat().sub(lse);
            var y = logResult.exp();
            var gradFunc = function (dy) {
                var dyTimesY = dy.mul(y);
                var keepDims = true;
                return dyTimesY.sub(dyTimesY.sum([dim], keepDims).mul(y));
            };
            return { value: y, gradFunc: gradFunc };
        });
        return customOp(logits);
    };
    SoftmaxOps.softmaxCrossEntropy = function (labels, logits, dim) {
        if (dim === void 0) { dim = -1; }
        util.assertArgumentsAreTensors({ labels: labels, logits: logits }, 'softmaxCrossEntropy');
        util.assertShapesMatch(labels.shape, logits.shape, 'Error in softmaxCrossEntropy: ');
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error("Softmax cross entropy along a non-last dimension is not yet " +
                ("supported. Labels / logits was rank " + logits.rank + " ") +
                ("and dim was " + dim));
        }
        var customOp = globals_1.customGrad(function (labels, logits) {
            var predictedProbs = logits.softmax(dim);
            var costVector = ops.scalar(1e-5).add(predictedProbs).log().mul(labels).neg();
            var value = costVector.sum([dim]);
            var gradFunc = function (dy) {
                var dyShape = axis_util.expandShapeToKeepDim(dy.shape, [dim]);
                return [
                    dy.reshape(dyShape).mul(labels.toFloat().sub(predictedProbs)),
                    dy.reshape(dyShape).mul(predictedProbs.sub(labels.toFloat())),
                ];
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(labels, logits);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], SoftmaxOps, "softmax", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], SoftmaxOps, "softmaxCrossEntropy", null);
    return SoftmaxOps;
}());
exports.SoftmaxOps = SoftmaxOps;

},{"../doc":46,"../globals":49,"../util":155,"./axis_util":104,"./operation":123,"./ops":124}],134:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var StridedSliceOps = (function () {
    function StridedSliceOps() {
    }
    StridedSliceOps.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
        if (beginMask === void 0) { beginMask = 0; }
        if (endMask === void 0) { endMask = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'stridedSlice');
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.stridedSlice(x, begin, end, strides, beginMask, endMask); }, { x: x });
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], StridedSliceOps, "stridedSlice", null);
    return StridedSliceOps;
}());
exports.StridedSliceOps = StridedSliceOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123}],135:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var TransposeOps = (function () {
    function TransposeOps() {
    }
    TransposeOps.transpose = function (x, perm) {
        util.assertArgumentsAreTensors({ x: x }, 'transpose');
        if (perm == null) {
            perm = x.shape.map(function (s, i) { return i; }).reverse();
        }
        util.assert(x.rank === perm.length, "Error in transpose: rank of input " + x.rank + " " +
            ("must match length of perm " + perm + "."));
        perm.forEach(function (axis) {
            util.assert(axis >= 0 && axis < x.rank, "All entries in 'perm' must be between 0 and " + (x.rank - 1) +
                (" but got " + perm));
        });
        if (x.rank <= 1) {
            return x.clone();
        }
        var der = function (dy) {
            var undoPerm = axis_util.getUndoAxesPermutation(perm);
            return { x: function () { return dy.transpose(undoPerm); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.transpose(x, perm); }, { x: x }, der);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], TransposeOps, "transpose", null);
    return TransposeOps;
}());
exports.TransposeOps = TransposeOps;

},{"../doc":46,"../environment":48,"../util":155,"./axis_util":104,"./operation":123}],136:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var ops = require("./ops");
var ops_1 = require("./ops");
var selu_util = require("./selu_util");
var UnaryOps = (function () {
    function UnaryOps() {
    }
    UnaryOps.neg = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'neg');
        var grad = function (dy) {
            return { x: function () { return dy.neg(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.neg(x); }, { x: x }, grad);
    };
    UnaryOps.ceil = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'ceil');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.ceil(x); }, { x: x }, grad);
    };
    UnaryOps.floor = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'floor');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.floor(x); }, { x: x }, grad);
    };
    UnaryOps.sign = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sign');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sign(x); }, { x: x }, grad);
    };
    UnaryOps.round = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'round');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.round(x); }, { x: x }, grad);
    };
    UnaryOps.exp = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'exp');
        var bck = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return dy.mulStrict(y); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.exp(x)); }, { x: x }, bck);
    };
    UnaryOps.expm1 = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'expm1');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.exp()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.expm1(x); }, { x: x }, grad);
    };
    UnaryOps.log = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'log');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.toFloat()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.log(x); }, { x: x }, grad);
    };
    UnaryOps.log1p = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'log1p');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.add(ops.scalar(1))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.log1p(x); }, { x: x }, grad);
    };
    UnaryOps.sqrt = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sqrt');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.toFloat().sqrt().mul(ops.scalar(2))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sqrt(x); }, { x: x }, grad);
    };
    UnaryOps.rsqrt = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'rsqrt');
        var grad = function (dy) {
            return {
                x: function () { return dy.divStrict(x.pow(ops.scalar(1.5)).mul(ops.scalar(2))).neg(); }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.rsqrt(x); }, { x: x }, grad);
    };
    UnaryOps.square = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'square');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.toFloat().mul(ops.scalar(2))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.square(x); }, { x: x }, grad);
    };
    UnaryOps.reciprocal = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'reciprocal');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.square().neg()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.reciprocal(x); }, { x: x }, grad);
    };
    UnaryOps.abs = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'abs');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.toFloat().step(-1)); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.abs(x); }, { x: x }, grad);
    };
    UnaryOps.clipByValue = function (x, clipValueMin, clipValueMax) {
        util.assertArgumentsAreTensors({ x: x }, 'clipByValue');
        util.assert((clipValueMin <= clipValueMax), "Error in clip: min (" + clipValueMin + ") must be " +
            ("less than or equal to max (" + clipValueMax + ")."));
        var grad = function (dy) {
            return {
                x: function () { return dy.where(x.greaterEqual(ops.scalar(clipValueMin))
                    .logicalAnd(x.lessEqual(ops.scalar(clipValueMax))), ops_1.zerosLike(dy)); },
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.clip(x, clipValueMin, clipValueMax); }, { x: x }, grad);
    };
    UnaryOps.relu = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'relu');
        if (x.dtype === 'bool') {
            return x.toInt();
        }
        var grad = function (dy) {
            var stepRes = x.step();
            return { x: function () { return dy.mulStrict(stepRes.toFloat()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.relu(x); }, { x: x }, grad);
    };
    UnaryOps.elu = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'elu');
        var grad = function (dy, saved) {
            var y = saved[0];
            return {
                x: function () {
                    return environment_1.ENV.engine.runKernel(function (backend) { return backend.eluDer(dy, y); }, { dy: dy, y: y });
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.elu(x)); }, { x: x }, grad);
    };
    UnaryOps.selu = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'selu');
        var grad = function (dy) {
            return {
                x: function () {
                    var mask = x.greater(ops.scalar(0));
                    var scaleAlpha = ops.scalar(selu_util.SELU_SCALEALPHA);
                    var scale = ops.scalar(selu_util.SELU_SCALE);
                    var greaterThanZeroDer = dy.mul(scale);
                    var lessEqualZeroDer = dy.mul(scaleAlpha).mul(x.toFloat().exp());
                    return ops.where(mask, greaterThanZeroDer, lessEqualZeroDer);
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.selu(x); }, { x: x }, grad);
    };
    UnaryOps.leakyRelu = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        util.assertArgumentsAreTensors({ x: x }, 'leakyRelu');
        return ops.maximum(ops.scalar(alpha).mul(x), x);
    };
    UnaryOps.prelu = function (x, alpha) {
        util.assertArgumentsAreTensors({ x: x, alpha: alpha }, 'prelu');
        var zero = ops.scalar(0);
        return ops.maximum(zero, x).add(alpha.mul(ops.minimum(zero, x)));
    };
    UnaryOps.sigmoid = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sigmoid');
        var grad = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return dy.mulStrict(y.mul(ops.scalar(1).sub(y))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.sigmoid(x)); }, { x: x }, grad);
    };
    UnaryOps.logSigmoid = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'logSigmoid');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.neg().sigmoid()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.softplus(x.neg()).neg(); }, { x: x }, grad);
    };
    UnaryOps.softplus = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'softplus');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.sigmoid()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.softplus(x); }, { x: x }, grad);
    };
    UnaryOps.sin = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sin');
        var grad = function (dy) {
            return { x: function () { return x.toFloat().cos().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sin(x); }, { x: x }, grad);
    };
    UnaryOps.cos = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'cos');
        var grad = function (dy) {
            return { x: function () { return x.toFloat().sin().neg().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cos(x); }, { x: x }, grad);
    };
    UnaryOps.tan = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'tan');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.cos().square()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.tan(x); }, { x: x }, grad);
    };
    UnaryOps.asin = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'asin');
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(x.toFloat().square())));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.asin(x); }, { x: x }, grad);
    };
    UnaryOps.acos = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'acos');
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(x.toFloat().square())))
                        .neg();
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.acos(x); }, { x: x }, grad);
    };
    UnaryOps.atan = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'atan');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(ops.scalar(1).add(x.toFloat().square())); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atan(x); }, { x: x }, grad);
    };
    UnaryOps.sinh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sinh');
        var grad = function (dy) {
            return { x: function () { return x.toFloat().cosh().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sinh(x); }, { x: x }, grad);
    };
    UnaryOps.cosh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'cosh');
        var grad = function (dy) {
            return { x: function () { return x.toFloat().sinh().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cosh(x); }, { x: x }, grad);
    };
    UnaryOps.tanh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'tanh');
        var grad = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return ops.scalar(1).sub(y.square()).mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.tanh(x)); }, { x: x }, grad);
    };
    UnaryOps.asinh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'asinh');
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).add(x.toFloat().square())));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.asinh(x); }, { x: x }, grad);
    };
    UnaryOps.acosh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'acosh');
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(x.toFloat().square().sub(ops.scalar(1))));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.acosh(x); }, { x: x }, grad);
    };
    UnaryOps.atanh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'atanh');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(ops.scalar(1).sub(x.toFloat().square())); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atanh(x); }, { x: x }, grad);
    };
    UnaryOps.erf = function (x) {
        util.assert(x.dtype === 'int32' || x.dtype === 'float32', 'Input dtype must be `int32` or `float32`.');
        if (x.dtype === 'int32') {
            x = x.toFloat();
        }
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.mulStrict(ops.scalar(2 / Math.sqrt(Math.PI))
                        .mul(x.square().neg().exp()));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.erf(x); }, { x: x }, grad);
    };
    UnaryOps.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        util.assertArgumentsAreTensors({ x: x }, 'step');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.step(x, alpha); }, { x: x }, grad);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "neg", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "ceil", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "floor", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sign", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "round", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "exp", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "expm1", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "log", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "log1p", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sqrt", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "rsqrt", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "square", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "reciprocal", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "abs", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "clipByValue", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "relu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "elu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "selu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "leakyRelu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "prelu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sigmoid", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "logSigmoid", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "softplus", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "cos", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "tan", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "asin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "acos", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "atan", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sinh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "cosh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "tanh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "asinh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "acosh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "atanh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "erf", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "step", null);
    return UnaryOps;
}());
exports.UnaryOps = UnaryOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123,"./ops":124,"./selu_util":130}],137:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdadeltaOptimizer = (function (_super) {
    __extends(AdadeltaOptimizer, _super);
    function AdadeltaOptimizer(learningRate, rho, epsilon) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.rho = rho;
        _this.epsilon = epsilon;
        _this.accumulatedGrads = {};
        _this.accumulatedUpdates = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsilonScalar = globals_1.keep(ops_1.scalar(epsilon));
        _this.rhoScalar = globals_1.keep(ops_1.scalar(rho));
        _this.oneMinusRho = globals_1.keep(ops_1.scalar(1 - rho));
        return _this;
    }
    AdadeltaOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedGrads[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedGrads[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            if (this_1.accumulatedUpdates[variableName] == null) {
                var trainable_2 = false;
                globals_1.tidy(function () {
                    _this.accumulatedUpdates[variableName] =
                        ops_1.zerosLike(value).variable(trainable_2);
                });
            }
            var gradient = variableGradients[variableName];
            var accumulatedGrad = this_1.accumulatedGrads[variableName];
            var accumulatedUpdate = this_1.accumulatedUpdates[variableName];
            globals_1.tidy(function () {
                var newAccumulatedGrad = _this.rhoScalar.mul(accumulatedGrad)
                    .add(_this.oneMinusRho.mul(gradient.square()));
                var updates = accumulatedUpdate.add(_this.epsilonScalar)
                    .sqrt()
                    .div(accumulatedGrad.add(_this.epsilonScalar).sqrt())
                    .mul(gradient);
                var newAccumulatedUpdate = _this.rhoScalar.mul(accumulatedUpdate)
                    .add(_this.oneMinusRho.mul(updates.square()));
                _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                _this.accumulatedUpdates[variableName].assign(newAccumulatedUpdate);
                var newValue = _this.c.mul(updates).add(value);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    AdadeltaOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsilonScalar.dispose();
        this.rhoScalar.dispose();
        this.oneMinusRho.dispose();
        if (this.accumulatedUpdates != null) {
            Object.keys(this.accumulatedUpdates)
                .forEach(function (name) { return _this.accumulatedUpdates[name].dispose(); });
            Object.keys(this.accumulatedGrads)
                .forEach(function (name) { return _this.accumulatedGrads[name].dispose(); });
        }
    };
    AdadeltaOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            rho: this.rho,
            epsilon: this.epsilon
        };
    };
    AdadeltaOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.rho, config.epsilon);
    };
    AdadeltaOptimizer.className = 'AdadeltaOptimizer';
    return AdadeltaOptimizer;
}(optimizer_1.Optimizer));
exports.AdadeltaOptimizer = AdadeltaOptimizer;
serialization_1.SerializationMap.register(AdadeltaOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],138:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdagradOptimizer = (function (_super) {
    __extends(AdagradOptimizer, _super);
    function AdagradOptimizer(learningRate, initialAccumulatorValue) {
        if (initialAccumulatorValue === void 0) { initialAccumulatorValue = 0.1; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.initialAccumulatorValue = initialAccumulatorValue;
        _this.accumulatedGrads = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsilon = globals_1.keep(ops_1.scalar(1e-8));
        return _this;
    }
    AdagradOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedGrads[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedGrads[variableName] =
                        ops_1.fill(value.shape, _this.initialAccumulatorValue)
                            .variable(trainable_1);
                });
            }
            var gradient = variableGradients[variableName];
            var accumulatedGrad = this_1.accumulatedGrads[variableName];
            globals_1.tidy(function () {
                var newAccumulatedGrad = accumulatedGrad.add(gradient.square());
                _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                var newValue = _this.c
                    .mul(gradient.div(newAccumulatedGrad.add(_this.epsilon).sqrt()))
                    .add(value);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    AdagradOptimizer.prototype.dispose = function () {
        var _this = this;
        this.epsilon.dispose();
        this.c.dispose();
        if (this.accumulatedGrads != null) {
            Object.keys(this.accumulatedGrads)
                .forEach(function (name) { return _this.accumulatedGrads[name].dispose(); });
        }
    };
    AdagradOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            initialAccumulatorValue: this.initialAccumulatorValue,
        };
    };
    AdagradOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.initialAccumulatorValue);
    };
    AdagradOptimizer.className = 'AdagradOptimizer';
    return AdagradOptimizer;
}(optimizer_1.Optimizer));
exports.AdagradOptimizer = AdagradOptimizer;
serialization_1.SerializationMap.register(AdagradOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],139:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdamOptimizer = (function (_super) {
    __extends(AdamOptimizer, _super);
    function AdamOptimizer(learningRate, beta1, beta2, epsilon) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.epsilon = epsilon;
        _this.accumulatedFirstMoment = {};
        _this.accumulatedSecondMoment = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsScalar = globals_1.keep(ops_1.scalar(epsilon));
        _this.beta1Scalar = globals_1.keep(ops_1.scalar(beta1));
        _this.beta2Scalar = globals_1.keep(ops_1.scalar(beta2));
        globals_1.tidy(function () {
            _this.accBeta1 = ops_1.scalar(beta1).variable();
            _this.accBeta2 = ops_1.scalar(beta2).variable();
        });
        _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
        _this.oneMinusBeta2 = globals_1.keep(ops_1.scalar(1 - beta2));
        _this.one = globals_1.keep(ops_1.scalar(1));
        return _this;
    }
    AdamOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var oneMinusAccBeta2 = _this.one.sub(_this.accBeta2);
            for (var variableName in variableGradients) {
                var value = environment_1.ENV.engine.registeredVariables[variableName];
                if (_this.accumulatedFirstMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedFirstMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                if (_this.accumulatedSecondMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedSecondMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                var gradient = variableGradients[variableName];
                var firstMoment = _this.accumulatedFirstMoment[variableName];
                var secondMoment = _this.accumulatedSecondMoment[variableName];
                var newFirstMoment = _this.beta1Scalar.mul(firstMoment)
                    .add(_this.oneMinusBeta1.mul(gradient));
                var newSecondMoment = _this.beta2Scalar.mul(secondMoment)
                    .add(_this.oneMinusBeta2.mul(gradient.square()));
                var biasCorrectedFirstMoment = newFirstMoment.div(oneMinusAccBeta1);
                var biasCorrectedSecondMoment = newSecondMoment.div(oneMinusAccBeta2);
                _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                _this.accumulatedSecondMoment[variableName].assign(newSecondMoment);
                var newValue = _this.c
                    .mul(biasCorrectedFirstMoment.div(_this.epsScalar.add(biasCorrectedSecondMoment.sqrt())))
                    .add(value);
                value.assign(newValue);
            }
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar));
            _this.accBeta2.assign(_this.accBeta2.mul(_this.beta2Scalar));
        });
    };
    AdamOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsScalar.dispose();
        this.beta1Scalar.dispose();
        this.beta2Scalar.dispose();
        this.accBeta1.dispose();
        this.accBeta2.dispose();
        this.oneMinusBeta1.dispose();
        this.oneMinusBeta2.dispose();
        this.one.dispose();
        if (this.accumulatedFirstMoment != null) {
            Object.keys(this.accumulatedFirstMoment)
                .forEach(function (name) { return _this.accumulatedFirstMoment[name].dispose(); });
        }
        if (this.accumulatedSecondMoment != null) {
            Object.keys(this.accumulatedSecondMoment)
                .forEach(function (name) { return _this.accumulatedSecondMoment[name].dispose(); });
        }
    };
    AdamOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
        };
    };
    AdamOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.beta1, config.beta2, config.epsilon);
    };
    AdamOptimizer.className = 'AdamOptimizer';
    return AdamOptimizer;
}(optimizer_1.Optimizer));
exports.AdamOptimizer = AdamOptimizer;
serialization_1.SerializationMap.register(AdamOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],140:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdamaxOptimizer = (function (_super) {
    __extends(AdamaxOptimizer, _super);
    function AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (decay === void 0) { decay = 0.0; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.epsilon = epsilon;
        _this.decay = decay;
        _this.accumulatedFirstMoment = {};
        _this.accumulatedWeightedInfNorm = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsScalar = globals_1.keep(ops_1.scalar(epsilon));
        _this.beta1Scalar = globals_1.keep(ops_1.scalar(beta1));
        _this.beta2Scalar = globals_1.keep(ops_1.scalar(beta2));
        _this.decayScalar = globals_1.keep(ops_1.scalar(decay));
        globals_1.tidy(function () {
            _this.iteration = ops_1.scalar(0).variable();
            _this.accBeta1 = ops_1.scalar(beta1).variable();
        });
        _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
        _this.one = globals_1.keep(ops_1.scalar(1));
        return _this;
    }
    AdamaxOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var lr = _this.c.div(_this.one.add(_this.decayScalar.mul(_this.iteration)));
            for (var variableName in variableGradients) {
                var value = environment_1.ENV.engine.registeredVariables[variableName];
                if (_this.accumulatedFirstMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedFirstMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                if (_this.accumulatedWeightedInfNorm[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedWeightedInfNorm[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                var gradient = variableGradients[variableName];
                var firstMoment = _this.accumulatedFirstMoment[variableName];
                var weightedInfNorm = _this.accumulatedWeightedInfNorm[variableName];
                var newFirstMoment = _this.beta1Scalar.mul(firstMoment)
                    .add(_this.oneMinusBeta1.mul(gradient));
                var ut0 = _this.beta2Scalar.mul(weightedInfNorm);
                var ut1 = gradient.abs();
                var newWeightedInfNorm = ut0.maximum(ut1);
                _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                _this.accumulatedWeightedInfNorm[variableName].assign(newWeightedInfNorm);
                var newValue = lr.div(oneMinusAccBeta1)
                    .mul(newFirstMoment.div(_this.epsScalar.add(newWeightedInfNorm)))
                    .add(value);
                value.assign(newValue);
            }
            _this.iteration.assign(_this.iteration.add(_this.one));
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar));
        });
    };
    AdamaxOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsScalar.dispose();
        this.accBeta1.dispose();
        this.beta1Scalar.dispose();
        this.beta2Scalar.dispose();
        this.oneMinusBeta1.dispose();
        this.decayScalar.dispose();
        this.iteration.dispose();
        this.one.dispose();
        if (this.accumulatedFirstMoment != null) {
            Object.keys(this.accumulatedFirstMoment)
                .forEach(function (name) { return _this.accumulatedFirstMoment[name].dispose(); });
        }
        if (this.accumulatedWeightedInfNorm != null) {
            Object.keys(this.accumulatedWeightedInfNorm)
                .forEach(function (name) { return _this.accumulatedWeightedInfNorm[name].dispose(); });
        }
    };
    AdamaxOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
            decay: this.decay
        };
    };
    AdamaxOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.beta1, config.beta2, config.epsilon, config.decay);
    };
    AdamaxOptimizer.className = 'AdamaxOptimizer';
    return AdamaxOptimizer;
}(optimizer_1.Optimizer));
exports.AdamaxOptimizer = AdamaxOptimizer;
serialization_1.SerializationMap.register(AdamaxOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],141:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var sgd_optimizer_1 = require("./sgd_optimizer");
var MomentumOptimizer = (function (_super) {
    __extends(MomentumOptimizer, _super);
    function MomentumOptimizer(learningRate, momentum, useNesterov) {
        if (useNesterov === void 0) { useNesterov = false; }
        var _this = _super.call(this, learningRate) || this;
        _this.learningRate = learningRate;
        _this.momentum = momentum;
        _this.useNesterov = useNesterov;
        _this.m = ops_1.scalar(_this.momentum);
        _this.accumulations = {};
        return _this;
    }
    MomentumOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulations[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulations[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            var accumulation = this_1.accumulations[variableName];
            var gradient = variableGradients[variableName];
            globals_1.tidy(function () {
                var newValue;
                var newAccumulation = _this.m.mul(accumulation).add(gradient);
                if (_this.useNesterov) {
                    newValue =
                        _this.c.mul(gradient.add(newAccumulation.mul(_this.m))).add(value);
                }
                else {
                    newValue = _this.c.mul(newAccumulation).add(value);
                }
                _this.accumulations[variableName].assign(newAccumulation);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    MomentumOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.m.dispose();
        if (this.accumulations != null) {
            for (var variableName in this.accumulations) {
                this.accumulations[variableName].dispose();
            }
        }
    };
    MomentumOptimizer.prototype.setMomentum = function (momentum) {
        this.momentum = momentum;
    };
    MomentumOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            momentum: this.momentum,
            useNesterov: this.useNesterov
        };
    };
    MomentumOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.momentum, config.useNesterov);
    };
    MomentumOptimizer.className = 'MomentumOptimizer';
    return MomentumOptimizer;
}(sgd_optimizer_1.SGDOptimizer));
exports.MomentumOptimizer = MomentumOptimizer;
serialization_1.SerializationMap.register(MomentumOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./sgd_optimizer":145}],142:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var globals_1 = require("../globals");
var serialization_1 = require("../serialization");
var Optimizer = (function (_super) {
    __extends(Optimizer, _super);
    function Optimizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Optimizer.prototype.minimize = function (f, returnCost, varList) {
        if (returnCost === void 0) { returnCost = false; }
        var _a = this.computeGradients(f, varList), value = _a.value, grads = _a.grads;
        this.applyGradients(grads);
        var varNames = Object.keys(grads);
        varNames.forEach(function (varName) { return grads[varName].dispose(); });
        if (returnCost) {
            return value;
        }
        else {
            value.dispose();
            return null;
        }
    };
    Optimizer.prototype.computeGradients = function (f, varList) {
        return globals_1.variableGrads(f, varList);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers' })
    ], Optimizer.prototype, "minimize", null);
    Optimizer = __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Classes', namespace: 'train' })
    ], Optimizer);
    return Optimizer;
}(serialization_1.Serializable));
exports.Optimizer = Optimizer;

},{"../doc":46,"../globals":49,"../serialization":147}],143:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var adadelta_optimizer_1 = require("./adadelta_optimizer");
var adagrad_optimizer_1 = require("./adagrad_optimizer");
var adam_optimizer_1 = require("./adam_optimizer");
var adamax_optimizer_1 = require("./adamax_optimizer");
var momentum_optimizer_1 = require("./momentum_optimizer");
var rmsprop_optimizer_1 = require("./rmsprop_optimizer");
var sgd_optimizer_1 = require("./sgd_optimizer");
var OptimizerConstructors = (function () {
    function OptimizerConstructors() {
    }
    OptimizerConstructors.sgd = function (learningRate) {
        return new sgd_optimizer_1.SGDOptimizer(learningRate);
    };
    OptimizerConstructors.momentum = function (learningRate, momentum, useNesterov) {
        if (useNesterov === void 0) { useNesterov = false; }
        return new momentum_optimizer_1.MomentumOptimizer(learningRate, momentum, useNesterov);
    };
    OptimizerConstructors.rmsprop = function (learningRate, decay, momentum, epsilon, centered) {
        if (decay === void 0) { decay = .9; }
        if (momentum === void 0) { momentum = 0.0; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (centered === void 0) { centered = false; }
        return new rmsprop_optimizer_1.RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered);
    };
    OptimizerConstructors.adam = function (learningRate, beta1, beta2, epsilon) {
        if (learningRate === void 0) { learningRate = 0.001; }
        if (beta1 === void 0) { beta1 = 0.9; }
        if (beta2 === void 0) { beta2 = 0.999; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        return new adam_optimizer_1.AdamOptimizer(learningRate, beta1, beta2, epsilon);
    };
    OptimizerConstructors.adadelta = function (learningRate, rho, epsilon) {
        if (learningRate === void 0) { learningRate = .001; }
        if (rho === void 0) { rho = .95; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        return new adadelta_optimizer_1.AdadeltaOptimizer(learningRate, rho, epsilon);
    };
    OptimizerConstructors.adamax = function (learningRate, beta1, beta2, epsilon, decay) {
        if (learningRate === void 0) { learningRate = 0.002; }
        if (beta1 === void 0) { beta1 = 0.9; }
        if (beta2 === void 0) { beta2 = 0.999; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (decay === void 0) { decay = 0.0; }
        return new adamax_optimizer_1.AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay);
    };
    OptimizerConstructors.adagrad = function (learningRate, initialAccumulatorValue) {
        if (initialAccumulatorValue === void 0) { initialAccumulatorValue = 0.1; }
        return new adagrad_optimizer_1.AdagradOptimizer(learningRate, initialAccumulatorValue);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "sgd", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "momentum", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "rmsprop", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adam", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adadelta", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adamax", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adagrad", null);
    return OptimizerConstructors;
}());
exports.OptimizerConstructors = OptimizerConstructors;

},{"../doc":46,"./adadelta_optimizer":137,"./adagrad_optimizer":138,"./adam_optimizer":139,"./adamax_optimizer":140,"./momentum_optimizer":141,"./rmsprop_optimizer":144,"./sgd_optimizer":145}],144:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var RMSPropOptimizer = (function (_super) {
    __extends(RMSPropOptimizer, _super);
    function RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered) {
        if (decay === void 0) { decay = 0.9; }
        if (momentum === void 0) { momentum = 0.0; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (centered === void 0) { centered = false; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.decay = decay;
        _this.momentum = momentum;
        _this.epsilon = epsilon;
        _this.accumulatedMeanSquares = {};
        _this.accumulatedMeanGrads = {};
        _this.accumulatedMoments = {};
        _this.c = globals_1.keep(ops_1.scalar(learningRate));
        _this.epsilonScalar = globals_1.keep(ops_1.scalar(epsilon));
        _this.decayScalar = globals_1.keep(ops_1.scalar(decay));
        _this.momentumScalar = globals_1.keep(ops_1.scalar(momentum));
        _this.oneMinusDecay = globals_1.keep(ops_1.scalar(1 - decay));
        _this.centered = centered;
        return _this;
    }
    RMSPropOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedMeanSquares[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMeanSquares[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            if (this_1.accumulatedMeanGrads[variableName] == null && this_1.centered) {
                var trainable_2 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMeanGrads[variableName] =
                        ops_1.zerosLike(value).variable(trainable_2);
                });
            }
            if (this_1.accumulatedMoments[variableName] == null) {
                var trainable_3 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMoments[variableName] =
                        ops_1.zerosLike(value).variable(trainable_3);
                });
            }
            var accumulatedMeanSquare = this_1.accumulatedMeanSquares[variableName];
            var accumulatedMeanGrad = this_1.accumulatedMeanGrads[variableName];
            var accumulatedMoments = this_1.accumulatedMoments[variableName];
            var gradient = variableGradients[variableName];
            globals_1.tidy(function () {
                var newAccumulatedMeanSquare = _this.decayScalar.mul(accumulatedMeanSquare)
                    .add(_this.oneMinusDecay.mul(gradient.square()));
                if (_this.centered) {
                    var newAccumulatedMeanGrad = _this.decayScalar.mul(accumulatedMeanGrad)
                        .add(_this.oneMinusDecay.mul(gradient));
                    var newAccumulatedMoments = _this.momentumScalar.mul(accumulatedMoments)
                        .add(_this.c.mul(gradient).div(newAccumulatedMeanSquare
                        .sub(newAccumulatedMeanGrad.square().add(_this.epsilonScalar))
                        .sqrt()));
                    _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare);
                    _this.accumulatedMeanGrads[variableName].assign(newAccumulatedMeanGrad);
                    _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                    var newValue = value.sub(newAccumulatedMoments);
                    value.assign(newValue);
                }
                else {
                    var newAccumulatedMeanSquare_1 = _this.decayScalar.mul(accumulatedMeanSquare)
                        .add(_this.oneMinusDecay.mul(gradient.square()));
                    var newAccumulatedMoments = _this.momentumScalar.mul(accumulatedMoments)
                        .add(_this.c.mul(gradient).div(newAccumulatedMeanSquare_1.add(_this.epsilonScalar).sqrt()));
                    _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare_1);
                    _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                    var newValue = value.sub(newAccumulatedMoments);
                    value.assign(newValue);
                }
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    RMSPropOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsilonScalar.dispose();
        this.decayScalar.dispose();
        this.momentumScalar.dispose();
        this.oneMinusDecay.dispose();
        if (this.accumulatedMeanSquares != null) {
            Object.keys(this.accumulatedMeanSquares)
                .forEach(function (name) { return _this.accumulatedMeanSquares[name].dispose(); });
        }
        if (this.accumulatedMeanGrads != null && this.centered) {
            Object.keys(this.accumulatedMeanGrads)
                .forEach(function (name) { return _this.accumulatedMeanGrads[name].dispose(); });
        }
        if (this.accumulatedMoments != null) {
            Object.keys(this.accumulatedMoments)
                .forEach(function (name) { return _this.accumulatedMoments[name].dispose(); });
        }
    };
    RMSPropOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            decay: this.decay,
            momentum: this.momentum,
            epsilon: this.epsilon,
            centered: this.centered
        };
    };
    RMSPropOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.decay, config.momentum, config.epsilon, config.centered);
    };
    RMSPropOptimizer.className = 'RMSPropOptimizer';
    return RMSPropOptimizer;
}(optimizer_1.Optimizer));
exports.RMSPropOptimizer = RMSPropOptimizer;
serialization_1.SerializationMap.register(RMSPropOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate) {
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.setLearningRate(learningRate);
        return _this;
    }
    SGDOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var varNames = Object.keys(variableGradients);
        varNames.forEach(function (varName) {
            var gradient = variableGradients[varName];
            var value = environment_1.ENV.engine.registeredVariables[varName];
            globals_1.tidy(function () {
                var newValue = _this.c.mul(gradient).add(value);
                value.assign(newValue);
            });
        });
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
        if (this.c != null) {
            this.c.dispose();
        }
        this.c = globals_1.keep(ops_1.scalar(-learningRate));
    };
    SGDOptimizer.prototype.dispose = function () {
        this.c.dispose();
    };
    SGDOptimizer.prototype.getConfig = function () {
        return { learningRate: this.learningRate };
    };
    SGDOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate);
    };
    SGDOptimizer.className = 'SGDOptimizer';
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;
serialization_1.SerializationMap.register(SGDOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var Profiler = (function () {
    function Profiler(backendTimer, logger) {
        this.backendTimer = backendTimer;
        this.logger = logger;
        if (logger == null) {
            this.logger = new Logger();
        }
    }
    Profiler.prototype.profileKernel = function (name, f) {
        var _this = this;
        var result;
        var holdResultWrapperFn = function () {
            result = f();
        };
        var timer = this.backendTimer.time(holdResultWrapperFn);
        var vals = result.dataSync();
        util.checkForNaN(vals, result.dtype, name);
        timer.then(function (timing) {
            _this.logger.logKernelProfile(name, result, vals, timing.kernelMs);
        });
        return result;
    };
    return Profiler;
}());
exports.Profiler = Profiler;
var Logger = (function () {
    function Logger() {
    }
    Logger.prototype.logKernelProfile = function (name, result, vals, timeMs) {
        var time = util.rightPad(timeMs + "ms", 9);
        var paddedName = util.rightPad(name, 25);
        var rank = result.rank;
        var size = result.size;
        var shape = util.rightPad(result.shape.toString(), 14);
        console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
    };
    return Logger;
}());
exports.Logger = Logger;

},{"./util":155}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Serializable = (function () {
    function Serializable() {
    }
    Serializable.prototype.getClassName = function () {
        return this.constructor
            .className;
    };
    Serializable.fromConfig = function (cls, config) {
        return new cls(config);
    };
    return Serializable;
}());
exports.Serializable = Serializable;
var SerializationMap = (function () {
    function SerializationMap() {
        this.classNameMap = {};
    }
    SerializationMap.getMap = function () {
        if (SerializationMap.instance == null) {
            SerializationMap.instance = new SerializationMap();
        }
        return SerializationMap.instance;
    };
    SerializationMap.register = function (cls) {
        this.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
    };
    return SerializationMap;
}());
exports.SerializationMap = SerializationMap;

},{}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
function getFilteredNodesXToY(tape, xs, y) {
    var tensorsFromX = {};
    var nodesFromX = {};
    for (var i = 0; i < xs.length; i++) {
        tensorsFromX[xs[i].id] = true;
    }
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        var nodeInputs = node.inputs;
        for (var inputName in nodeInputs) {
            var input = nodeInputs[inputName];
            var anyInputFromX = false;
            for (var j = 0; j < xs.length; j++) {
                if (tensorsFromX[input.id]) {
                    tensorsFromX[node.output.id] = true;
                    anyInputFromX = true;
                    nodesFromX[node.id] = true;
                    break;
                }
            }
            if (anyInputFromX) {
                break;
            }
        }
    }
    var tensorsLeadToY = {};
    tensorsLeadToY[y.id] = true;
    var nodesToY = {};
    for (var i = tape.length - 1; i >= 0; i--) {
        var node = tape[i];
        var nodeInputs = node.inputs;
        var outputs = [];
        outputs.push(node.output);
        for (var j = 0; j < outputs.length; j++) {
            if (tensorsLeadToY[outputs[j].id]) {
                for (var inputName in nodeInputs) {
                    tensorsLeadToY[nodeInputs[inputName].id] = true;
                    nodesToY[node.id] = true;
                }
                break;
            }
        }
    }
    var filteredTape = [];
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
            var prunedInputs = {};
            for (var inputName in node.inputs) {
                var nodeInput = node.inputs[inputName];
                if (tensorsFromX[nodeInput.id]) {
                    prunedInputs[inputName] = nodeInput;
                }
            }
            var prunedNode = Object.assign({}, node);
            prunedNode.inputs = prunedInputs;
            prunedNode.output = node.output;
            filteredTape.push(prunedNode);
        }
    }
    return filteredTape;
}
exports.getFilteredNodesXToY = getFilteredNodesXToY;
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape) {
    for (var i = filteredTape.length - 1; i >= 0; i--) {
        var node = filteredTape[i];
        var dy = tensorAccumulatedGradientMap[node.output.id];
        if (node.gradient == null) {
            throw new Error("Cannot compute gradient: gradient function not found " +
                ("for " + node.name + "."));
        }
        var inputGradients = node.gradient(dy);
        for (var inputName in node.inputs) {
            if (!(inputName in inputGradients)) {
                throw new Error("Cannot backprop through input " + inputName + ". " +
                    ("Available gradients found: " + Object.keys(inputGradients) + "."));
            }
            var dx = inputGradients[inputName]();
            var x = node.inputs[inputName];
            if (!util.arraysEqual(dx.shape, x.shape)) {
                throw new Error("Error in gradient for op " + node.name + ". The gradient of input " +
                    ("'" + inputName + "' has shape '" + dx.shape + "', which does not match ") +
                    ("the shape of the input '" + x.shape + "'"));
            }
            if (tensorAccumulatedGradientMap[x.id] == null) {
                tensorAccumulatedGradientMap[x.id] = dx;
            }
            else {
                var curGradient = tensorAccumulatedGradientMap[x.id];
                tensorAccumulatedGradientMap[x.id] = curGradient.add(dx);
                curGradient.dispose();
            }
        }
    }
}
exports.backpropagateGradients = backpropagateGradients;

},{"./util":155}],149:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var ops = require("./ops/ops");
var tensor_util = require("./tensor_util");
var util = require("./util");
var TensorBuffer = (function () {
    function TensorBuffer(shape, dtype, values) {
        this.dtype = dtype;
        if (values != null) {
            var n = values.length;
            var size = util.sizeFromShape(shape);
            util.assert(n === size, "Length of values '" + n + "' does not match the size " +
                ("inferred by the shape '" + size + "'"));
        }
        this.shape = shape.slice();
        this.values =
            values || util.getTypedArrayFromDType(dtype, util.sizeFromShape(shape));
        this.strides = computeStrides(shape);
        this.size = util.sizeFromShape(shape);
    }
    TensorBuffer.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        util.assert(locs.length === this.rank, "The number of provided coordinates (" + locs.length + ") must " +
            ("match the rank (" + this.rank + ")"));
        var index = this.locToIndex(locs);
        this.values[index] = value;
    };
    TensorBuffer.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.values[index];
    };
    TensorBuffer.prototype.locToIndex = function (locs) {
        if (this.rank === 0) {
            return 0;
        }
        else if (this.rank === 1) {
            return locs[0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    TensorBuffer.prototype.indexToLoc = function (index) {
        if (this.rank === 0) {
            return [];
        }
        else if (this.rank === 1) {
            return [index];
        }
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    Object.defineProperty(TensorBuffer.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    TensorBuffer.prototype.toTensor = function () {
        return Tensor.make(this.shape, { values: this.values }, this.dtype);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "set", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "get", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "toTensor", null);
    TensorBuffer = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], TensorBuffer);
    return TensorBuffer;
}());
exports.TensorBuffer = TensorBuffer;
var Tensor = (function () {
    function Tensor(shape, dtype, values, dataId) {
        this.isDisposedInternal = false;
        this.size = util.sizeFromShape(shape);
        if (values != null) {
            util.assert(this.size === values.length, "Constructing tensor of shape (" + this.size + ") should match the " +
                ("length of values (" + values.length + ")"));
        }
        this.shape = shape.slice();
        this.dtype = dtype || 'float32';
        this.strides = computeStrides(shape);
        this.dataId = dataId != null ? dataId : {};
        this.id = Tensor_1.nextId++;
        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');
        environment_1.ENV.engine.registerTensor(this);
        if (values != null) {
            environment_1.ENV.engine.write(this.dataId, values);
        }
    }
    Tensor_1 = Tensor;
    Tensor.make = function (shape, data, dtype) {
        return new Tensor_1(shape, dtype, data.values, data.dataId);
    };
    Tensor.prototype.flatten = function () {
        this.throwIfDisposed();
        return this.as1D();
    };
    Tensor.prototype.asScalar = function () {
        this.throwIfDisposed();
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    Tensor.prototype.as1D = function () {
        this.throwIfDisposed();
        return this.reshape([this.size]);
    };
    Tensor.prototype.as2D = function (rows, columns) {
        this.throwIfDisposed();
        return this.reshape([rows, columns]);
    };
    Tensor.prototype.as3D = function (rows, columns, depth) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth]);
    };
    Tensor.prototype.as4D = function (rows, columns, depth, depth2) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth, depth2]);
    };
    Tensor.prototype.asType = function (dtype) {
        this.throwIfDisposed();
        return ops.cast(this, dtype);
    };
    Object.defineProperty(Tensor.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        util.assert(locs.length === this.rank, 'Number of coordinates in get() must match the rank of the tensor');
        this.throwIfDisposed();
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.dataSync()[index];
    };
    Tensor.prototype.buffer = function () {
        return ops.buffer(this.shape, this.dtype, this.dataSync());
    };
    Tensor.prototype.data = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.throwIfDisposed();
                return [2, environment_1.ENV.engine.read(this.dataId)];
            });
        });
    };
    Tensor.prototype.dataSync = function () {
        this.throwIfDisposed();
        return environment_1.ENV.engine.readSync(this.dataId);
    };
    Tensor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        environment_1.ENV.engine.disposeTensor(this);
        this.isDisposedInternal = true;
    };
    Object.defineProperty(Tensor.prototype, "isDisposed", {
        get: function () {
            return this.isDisposedInternal;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.throwIfDisposed = function () {
        if (this.isDisposed) {
            throw new Error("Tensor is disposed.");
        }
    };
    Tensor.prototype.toFloat = function () {
        return this.asType('float32');
    };
    Tensor.prototype.toInt = function () {
        return this.asType('int32');
    };
    Tensor.prototype.toBool = function () {
        return this.asType('bool');
    };
    Tensor.prototype.print = function (verbose) {
        if (verbose === void 0) { verbose = false; }
        return ops.print(this, verbose);
    };
    Tensor.prototype.reshape = function (newShape) {
        this.throwIfDisposed();
        return ops.reshape(this, newShape);
    };
    Tensor.prototype.reshapeAs = function (x) {
        this.throwIfDisposed();
        return this.reshape(x.shape);
    };
    Tensor.prototype.expandDims = function (axis) {
        if (axis === void 0) { axis = 0; }
        return ops.expandDims(this, axis);
    };
    Tensor.prototype.cumsum = function (axis, exclusive, reverse) {
        if (axis === void 0) { axis = 0; }
        if (exclusive === void 0) { exclusive = false; }
        if (reverse === void 0) { reverse = false; }
        return ops.cumsum(this, axis, exclusive, reverse);
    };
    Tensor.prototype.squeeze = function (axis) {
        this.throwIfDisposed();
        return ops.squeeze(this, axis);
    };
    Tensor.prototype.clone = function () {
        this.throwIfDisposed();
        return ops.clone(this);
    };
    Tensor.prototype.toString = function (verbose) {
        if (verbose === void 0) { verbose = false; }
        return tensor_util.tensorToString(this, verbose);
    };
    Tensor.prototype.tile = function (reps) {
        this.throwIfDisposed();
        return ops.tile(this, reps);
    };
    Tensor.prototype.gather = function (indices, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.gather(this, indices, axis);
    };
    Tensor.prototype.matMul = function (b, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.throwIfDisposed();
        return ops.matMul(this, b, transposeA, transposeB);
    };
    Tensor.prototype.dot = function (b) {
        this.throwIfDisposed();
        return ops.dot(this, b);
    };
    Tensor.prototype.norm = function (ord, axis, keepDims) {
        if (ord === void 0) { ord = 'euclidean'; }
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.norm(this, ord, axis, keepDims);
    };
    Tensor.prototype.slice = function (begin, size) {
        this.throwIfDisposed();
        return ops.slice(this, begin, size);
    };
    Tensor.prototype.reverse = function (axis) {
        this.throwIfDisposed();
        return ops.reverse(this, axis);
    };
    Tensor.prototype.concat = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.concat([this, x], axis);
    };
    Tensor.prototype.stack = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        return ops.stack([this, x], axis);
    };
    Tensor.prototype.unstack = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        return ops.unstack(this, axis);
    };
    Tensor.prototype.pad = function (paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        return ops.pad(this, paddings, constantValue);
    };
    Tensor.prototype.batchNormalization = function (mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        this.throwIfDisposed();
        return ops.batchNormalization(this, mean, variance, varianceEpsilon, scale, offset);
    };
    Tensor.prototype.logSumExp = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.logSumExp(this, axis, keepDims);
    };
    Tensor.prototype.sum = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.sum(this, axis, keepDims);
    };
    Tensor.prototype.mean = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.mean(this, axis, keepDims);
    };
    Tensor.prototype.min = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.min(this, axis, keepDims);
    };
    Tensor.prototype.max = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.max(this, axis, keepDims);
    };
    Tensor.prototype.argMin = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return ops.argMin(this, axis);
    };
    Tensor.prototype.argMax = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return ops.argMax(this, axis);
    };
    Tensor.prototype.cast = function (dtype) {
        this.throwIfDisposed();
        return ops.cast(this, dtype);
    };
    Tensor.prototype.add = function (x) {
        this.throwIfDisposed();
        return ops.add(this, x);
    };
    Tensor.prototype.addStrict = function (x) {
        this.throwIfDisposed();
        return ops.addStrict(this, x);
    };
    Tensor.prototype.sub = function (x) {
        this.throwIfDisposed();
        return ops.sub(this, x);
    };
    Tensor.prototype.subStrict = function (x) {
        this.throwIfDisposed();
        return ops.subStrict(this, x);
    };
    Tensor.prototype.pow = function (exp) {
        this.throwIfDisposed();
        return ops.pow(this, exp);
    };
    Tensor.prototype.powStrict = function (exp) {
        this.throwIfDisposed();
        return ops.powStrict(this, exp);
    };
    Tensor.prototype.mul = function (x) {
        this.throwIfDisposed();
        return ops.mul(this, x);
    };
    Tensor.prototype.mulStrict = function (x) {
        this.throwIfDisposed();
        return ops.mulStrict(this, x);
    };
    Tensor.prototype.div = function (x) {
        this.throwIfDisposed();
        return ops.div(this, x);
    };
    Tensor.prototype.floorDiv = function (x) {
        this.throwIfDisposed();
        return ops.floorDiv(this, x);
    };
    Tensor.prototype.divStrict = function (x) {
        this.throwIfDisposed();
        return ops.divStrict(this, x);
    };
    Tensor.prototype.minimum = function (x) {
        this.throwIfDisposed();
        return ops.minimum(this, x);
    };
    Tensor.prototype.minimumStrict = function (x) {
        this.throwIfDisposed();
        return ops.minimumStrict(this, x);
    };
    Tensor.prototype.maximum = function (x) {
        this.throwIfDisposed();
        return ops.maximum(this, x);
    };
    Tensor.prototype.maximumStrict = function (x) {
        this.throwIfDisposed();
        return ops.maximumStrict(this, x);
    };
    Tensor.prototype.mod = function (x) {
        this.throwIfDisposed();
        return ops.mod(this, x);
    };
    Tensor.prototype.modStrict = function (x) {
        this.throwIfDisposed();
        return ops.modStrict(this, x);
    };
    Tensor.prototype.squaredDifference = function (x) {
        this.throwIfDisposed();
        return ops.squaredDifference(this, x);
    };
    Tensor.prototype.squaredDifferenceStrict = function (x) {
        this.throwIfDisposed();
        return ops.squaredDifferenceStrict(this, x);
    };
    Tensor.prototype.transpose = function (perm) {
        this.throwIfDisposed();
        return ops.transpose(this, perm);
    };
    Tensor.prototype.notEqual = function (x) {
        this.throwIfDisposed();
        return ops.notEqual(this, x);
    };
    Tensor.prototype.notEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.notEqualStrict(this, x);
    };
    Tensor.prototype.less = function (x) {
        this.throwIfDisposed();
        return ops.less(this, x);
    };
    Tensor.prototype.lessStrict = function (x) {
        this.throwIfDisposed();
        return ops.lessStrict(this, x);
    };
    Tensor.prototype.equal = function (x) {
        this.throwIfDisposed();
        return ops.equal(this, x);
    };
    Tensor.prototype.equalStrict = function (x) {
        this.throwIfDisposed();
        return ops.equalStrict(this, x);
    };
    Tensor.prototype.lessEqual = function (x) {
        this.throwIfDisposed();
        return ops.lessEqual(this, x);
    };
    Tensor.prototype.lessEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.lessEqualStrict(this, x);
    };
    Tensor.prototype.greater = function (x) {
        this.throwIfDisposed();
        return ops.greater(this, x);
    };
    Tensor.prototype.greaterStrict = function (x) {
        this.throwIfDisposed();
        return ops.greaterStrict(this, x);
    };
    Tensor.prototype.greaterEqual = function (x) {
        this.throwIfDisposed();
        return ops.greaterEqual(this, x);
    };
    Tensor.prototype.greaterEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.greaterEqualStrict(this, x);
    };
    Tensor.prototype.logicalAnd = function (x) {
        this.throwIfDisposed();
        return ops.logicalAnd(this, x);
    };
    Tensor.prototype.logicalOr = function (x) {
        this.throwIfDisposed();
        return ops.logicalOr(this, x);
    };
    Tensor.prototype.logicalNot = function () {
        this.throwIfDisposed();
        return ops.logicalNot(this);
    };
    Tensor.prototype.logicalXor = function (x) {
        this.throwIfDisposed();
        return ops.logicalXor(this, x);
    };
    Tensor.prototype.where = function (condition, x) {
        this.throwIfDisposed();
        return ops.where(condition, this, x);
    };
    Tensor.prototype.neg = function () {
        this.throwIfDisposed();
        return ops.neg(this);
    };
    Tensor.prototype.ceil = function () {
        this.throwIfDisposed();
        return ops.ceil(this);
    };
    Tensor.prototype.floor = function () {
        this.throwIfDisposed();
        return ops.floor(this);
    };
    Tensor.prototype.sign = function () {
        this.throwIfDisposed();
        return ops.sign(this);
    };
    Tensor.prototype.exp = function () {
        this.throwIfDisposed();
        return ops.exp(this);
    };
    Tensor.prototype.expm1 = function () {
        this.throwIfDisposed();
        return ops.expm1(this);
    };
    Tensor.prototype.log = function () {
        this.throwIfDisposed();
        return ops.log(this);
    };
    Tensor.prototype.log1p = function () {
        this.throwIfDisposed();
        return ops.log1p(this);
    };
    Tensor.prototype.sqrt = function () {
        this.throwIfDisposed();
        return ops.sqrt(this);
    };
    Tensor.prototype.rsqrt = function () {
        this.throwIfDisposed();
        return ops.rsqrt(this);
    };
    Tensor.prototype.square = function () {
        this.throwIfDisposed();
        return ops.square(this);
    };
    Tensor.prototype.reciprocal = function () {
        this.throwIfDisposed();
        return ops.reciprocal(this);
    };
    Tensor.prototype.abs = function () {
        this.throwIfDisposed();
        return ops.abs(this);
    };
    Tensor.prototype.clipByValue = function (min, max) {
        this.throwIfDisposed();
        return ops.clipByValue(this, min, max);
    };
    Tensor.prototype.relu = function () {
        this.throwIfDisposed();
        return ops.relu(this);
    };
    Tensor.prototype.elu = function () {
        this.throwIfDisposed();
        return ops.elu(this);
    };
    Tensor.prototype.selu = function () {
        this.throwIfDisposed();
        return ops.selu(this);
    };
    Tensor.prototype.leakyRelu = function (alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        this.throwIfDisposed();
        return ops.leakyRelu(this, alpha);
    };
    Tensor.prototype.prelu = function (alpha) {
        this.throwIfDisposed();
        return ops.prelu(this, alpha);
    };
    Tensor.prototype.sigmoid = function () {
        this.throwIfDisposed();
        return ops.sigmoid(this);
    };
    Tensor.prototype.logSigmoid = function () {
        this.throwIfDisposed();
        return ops.logSigmoid(this);
    };
    Tensor.prototype.softplus = function () {
        this.throwIfDisposed();
        return ops.softplus(this);
    };
    Tensor.prototype.sin = function () {
        this.throwIfDisposed();
        return ops.sin(this);
    };
    Tensor.prototype.cos = function () {
        this.throwIfDisposed();
        return ops.cos(this);
    };
    Tensor.prototype.tan = function () {
        this.throwIfDisposed();
        return ops.tan(this);
    };
    Tensor.prototype.asin = function () {
        this.throwIfDisposed();
        return ops.asin(this);
    };
    Tensor.prototype.acos = function () {
        this.throwIfDisposed();
        return ops.acos(this);
    };
    Tensor.prototype.atan = function () {
        this.throwIfDisposed();
        return ops.atan(this);
    };
    Tensor.prototype.sinh = function () {
        this.throwIfDisposed();
        return ops.sinh(this);
    };
    Tensor.prototype.cosh = function () {
        this.throwIfDisposed();
        return ops.cosh(this);
    };
    Tensor.prototype.tanh = function () {
        this.throwIfDisposed();
        return ops.tanh(this);
    };
    Tensor.prototype.asinh = function () {
        this.throwIfDisposed();
        return ops.asinh(this);
    };
    Tensor.prototype.acosh = function () {
        this.throwIfDisposed();
        return ops.acosh(this);
    };
    Tensor.prototype.atanh = function () {
        this.throwIfDisposed();
        return ops.atanh(this);
    };
    Tensor.prototype.erf = function () {
        this.throwIfDisposed();
        return ops.erf(this);
    };
    Tensor.prototype.round = function () {
        this.throwIfDisposed();
        return ops.round(this);
    };
    Tensor.prototype.step = function (alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        this.throwIfDisposed();
        return ops.step(this, alpha);
    };
    Tensor.prototype.softmax = function (dim) {
        if (dim === void 0) { dim = -1; }
        this.throwIfDisposed();
        return ops.softmax(this, dim);
    };
    Tensor.prototype.resizeBilinear = function (newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        this.throwIfDisposed();
        return ops.image.resizeBilinear(this, newShape2D, alignCorners);
    };
    Tensor.prototype.resizeNearestNeighbor = function (newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        this.throwIfDisposed();
        return ops.image.resizeNearestNeighbor(this, newShape2D, alignCorners);
    };
    Tensor.prototype.conv1d = function (filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NWC'; }
        if (dilation === void 0) { dilation = 1; }
        this.throwIfDisposed();
        return ops.conv1d(this, filter, stride, pad, dataFormat, dilation, dimRoundingMode);
    };
    Tensor.prototype.conv2d = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        this.throwIfDisposed();
        return ops.conv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
    };
    Tensor.prototype.conv2dTranspose = function (filter, outputShape, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.conv2dTranspose(this, filter, outputShape, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.depthwiseConv2D = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        this.throwIfDisposed();
        return ops.depthwiseConv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
    };
    Tensor.prototype.avgPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.avgPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.maxPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.maxPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.localResponseNormalization = function (radius, bias, alpha, beta) {
        if (radius === void 0) { radius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        return ops.localResponseNormalization(this, radius, bias, alpha, beta);
    };
    Tensor.prototype.variable = function (trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        this.throwIfDisposed();
        return Variable.variable(this, trainable, name, dtype);
    };
    Tensor.prototype.unsortedSegmentSum = function (segmentIds, numSegments, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.unsortedSegmentSum(this, segmentIds, numSegments, axis);
    };
    Tensor.nextId = 0;
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "flatten", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "asScalar", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as1D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as2D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as3D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as4D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "asType", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "buffer", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "data", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "dataSync", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "dispose", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toFloat", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toInt", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toBool", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "print", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "reshape", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "reshapeAs", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "expandDims", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "cumsum", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "squeeze", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "clone", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toString", null);
    Tensor = Tensor_1 = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor);
    return Tensor;
    var Tensor_1;
}());
exports.Tensor = Tensor;
var Variable = (function (_super) {
    __extends(Variable, _super);
    function Variable(initialValue, trainable, name) {
        if (trainable === void 0) { trainable = true; }
        var _this = _super.call(this, initialValue.shape, initialValue.dtype, null, initialValue.dataId) || this;
        _this.trainable = trainable;
        _this.name = name;
        if (_this.name == null) {
            _this.name = Variable_1.nextVarId.toString();
            Variable_1.nextVarId++;
        }
        environment_1.ENV.engine.registerVariable(_this);
        return _this;
    }
    Variable_1 = Variable;
    Variable.variable = function (initialValue, trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        if (dtype != null && dtype !== initialValue.dtype) {
            initialValue = initialValue.asType(dtype);
        }
        return new Variable_1(initialValue, trainable, name);
    };
    Variable.prototype.assign = function (newValue) {
        if (newValue.dtype !== this.dtype) {
            throw new Error("dtype of the new value (" + newValue.dtype + ") and " +
                ("previous value (" + this.dtype + ") must match"));
        }
        if (!util.arraysEqual(newValue.shape, this.shape)) {
            throw new Error("shape of the new value (" + newValue.shape + ") and " +
                ("previous value (" + this.shape + ") must match"));
        }
        environment_1.ENV.engine.disposeTensor(this);
        this.dataId = newValue.dataId;
        environment_1.ENV.engine.registerTensor(this);
    };
    Variable.nextVarId = 0;
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Variable.prototype, "assign", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], Variable, "variable", null);
    Variable = Variable_1 = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Variable);
    return Variable;
    var Variable_1;
}(Tensor));
exports.Variable = Variable;
var variable = Variable.variable;
exports.variable = variable;
function computeStrides(shape) {
    var rank = shape.length;
    if (rank < 2) {
        return [];
    }
    var strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for (var i = rank - 3; i >= 0; --i) {
        strides[i] = strides[i + 1] * shape[i + 1];
    }
    return strides;
}

},{"./doc":46,"./environment":48,"./ops/ops":124,"./tensor_util":150,"./util":155}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var FORMAT_LIMIT_NUM_VALS = 20;
var FORMAT_NUM_FIRST_LAST_VALS = 3;
var FORMAT_NUM_SIG_DIGITS = 7;
function tensorToString(t, verbose) {
    var vals = t.dataSync();
    var padPerCol = computeMaxSizePerColumn(t);
    var valsLines = subTensorToString(vals, t.shape, t.strides, padPerCol);
    var lines = ['Tensor'];
    if (verbose) {
        lines.push("  dtype: " + t.dtype);
        lines.push("  rank: " + t.rank);
        lines.push("  shape: [" + t.shape + "]");
        lines.push("  values:");
    }
    lines.push(valsLines.map(function (l) { return '    ' + l; }).join('\n'));
    return lines.join('\n');
}
exports.tensorToString = tensorToString;
function computeMaxSizePerColumn(t) {
    var vals = t.dataSync();
    var n = t.size;
    var numCols = t.strides[t.strides.length - 1];
    var padPerCol = new Array(numCols).fill(0);
    if (t.rank > 1) {
        for (var row = 0; row < n / numCols; row++) {
            var offset = row * numCols;
            for (var j = 0; j < numCols; j++) {
                padPerCol[j] =
                    Math.max(padPerCol[j], valToString(vals[offset + j], 0).length);
            }
        }
    }
    return padPerCol;
}
function valToString(val, pad) {
    return util.rightPad(parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(), pad);
}
function subTensorToString(vals, shape, strides, padPerCol, isLast) {
    if (isLast === void 0) { isLast = true; }
    var size = shape[0];
    var rank = shape.length;
    if (rank === 0) {
        return [vals[0].toString()];
    }
    if (rank === 1) {
        if (size > FORMAT_LIMIT_NUM_VALS) {
            var firstVals = Array.from(vals.subarray(0, FORMAT_NUM_FIRST_LAST_VALS));
            var lastVals = Array.from(vals.subarray(size - FORMAT_NUM_FIRST_LAST_VALS, size));
            return [
                '[' + firstVals.map(function (x, i) { return valToString(x, padPerCol[i]); }).join(', ') +
                    ', ..., ' +
                    lastVals
                        .map(function (x, i) { return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i]); })
                        .join(', ') +
                    ']'
            ];
        }
        return [
            '[' +
                Array.from(vals).map(function (x, i) { return valToString(x, padPerCol[i]); }).join(', ') +
                ']'
        ];
    }
    var subshape = shape.slice(1);
    var substrides = strides.slice(1);
    var stride = strides[0];
    var lines = [];
    if (size > FORMAT_LIMIT_NUM_VALS) {
        for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, false));
        }
        lines.push('...');
        for (var i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1));
        }
    }
    else {
        for (var i = 0; i < size; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1));
        }
    }
    var sep = rank === 2 ? ',' : '';
    lines[0] = '[' + lines[0] + sep;
    for (var i = 1; i < lines.length - 1; i++) {
        lines[i] = ' ' + lines[i] + sep;
    }
    var newLineSep = ',\n';
    for (var i = 2; i < rank; i++) {
        newLineSep += '\n';
    }
    lines[lines.length - 1] =
        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);
    return lines;
}

},{"./util":155}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
var util = require("./util");
exports.WEBGL_ENVS = {
    'BACKEND': 'test-webgl'
};
exports.CPU_ENVS = {
    'BACKEND': 'test-cpu'
};
exports.ALL_ENVS = {};
exports.TEST_EPSILON = 1e-3;
function expectArraysClose(actual, expected, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!(actual instanceof tensor_1.Tensor) && !(expected instanceof tensor_1.Tensor)) {
        var aType = actual.constructor.name;
        var bType = expected.constructor.name;
        if (aType !== bType) {
            throw new Error("Arrays are of different type actual: " + aType + " " +
                ("vs expected: " + bType));
        }
    }
    else if (actual instanceof tensor_1.Tensor && expected instanceof tensor_1.Tensor) {
        if (actual.dtype !== expected.dtype) {
            throw new Error("Arrays are of different type actual: " + actual.dtype + " " +
                ("vs expected: " + expected.dtype + "."));
        }
        if (!util.arraysEqual(actual.shape, expected.shape)) {
            throw new Error("Arrays are of different shape actual: " + actual.shape + " " +
                ("vs expected: " + expected.shape + "."));
        }
    }
    var actualValues;
    var expectedValues;
    if (actual instanceof tensor_1.Tensor) {
        actualValues = actual.dataSync();
    }
    else {
        actualValues = actual;
    }
    if (expected instanceof tensor_1.Tensor) {
        expectedValues = expected.dataSync();
    }
    else {
        expectedValues = expected;
    }
    if (actualValues.length !== expectedValues.length) {
        throw new Error("Arrays have different lengths actual: " + actualValues.length + " vs " +
            ("expected: " + expectedValues.length + ".\n") +
            ("Actual:   " + actualValues + ".\n") +
            ("Expected: " + expectedValues + "."));
    }
    for (var i = 0; i < expectedValues.length; ++i) {
        var a = actualValues[i];
        var e = expectedValues[i];
        if (!areClose(a, Number(e), epsilon)) {
            throw new Error("Arrays differ: actual[" + i + "] = " + a + ", expected[" + i + "] = " + e + ".\n" +
                ("Actual:   " + actualValues + ".\n") +
                ("Expected: " + expectedValues + "."));
        }
    }
}
exports.expectArraysClose = expectArraysClose;
function expectPromiseToFail(fn, done) {
    fn().then(function () { return done.fail(); }, function () { return done(); });
}
exports.expectPromiseToFail = expectPromiseToFail;
function expectArraysEqual(actual, expected) {
    return expectArraysClose(actual, expected, 0);
}
exports.expectArraysEqual = expectArraysEqual;
function expectNumbersClose(a, e, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!areClose(a, e, epsilon)) {
        throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
    }
}
exports.expectNumbersClose = expectNumbersClose;
function areClose(a, e, epsilon) {
    if (isNaN(a) && isNaN(e)) {
        return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
        return false;
    }
    return true;
}
function expectValuesInRange(actual, low, high) {
    var actualVals;
    if (actual instanceof tensor_1.Tensor) {
        actualVals = actual.dataSync();
    }
    else {
        actualVals = actual;
    }
    for (var i = 0; i < actualVals.length; i++) {
        if (actualVals[i] < low || actualVals[i] > high) {
            throw new Error("Value out of range:" + actualVals[i] + " low: " + low + ", high: " + high);
        }
    }
}
exports.expectValuesInRange = expectValuesInRange;

},{"./tensor":149,"./util":155}],152:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var util_1 = require("./util");
var Tracking = (function () {
    function Tracking() {
    }
    Tracking.tidy = function (nameOrFn, fn, gradMode) {
        if (gradMode === void 0) { gradMode = false; }
        var name = null;
        if (fn == null) {
            if (typeof nameOrFn !== 'function') {
                throw new Error('Please provide a function to tidy()');
            }
            fn = nameOrFn;
        }
        else {
            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {
                throw new Error('When calling with two arguments, the first argument ' +
                    'to tidy() must be a string');
            }
            if (typeof fn !== 'function') {
                throw new Error('When calling with two arguments, the 2nd argument ' +
                    'to tidy() must be a function');
            }
            name = nameOrFn;
        }
        environment_1.ENV.engine.startScope(name, gradMode);
        var result = fn();
        if (result instanceof Promise) {
            console.error('Cannot return a Promise inside of tidy.');
        }
        environment_1.ENV.engine.endScope(result, gradMode);
        return result;
    };
    Tracking.dispose = function (container) {
        var tensors = util_1.getTensorsInContainer(container);
        tensors.forEach(function (tensor) { return tensor.dispose(); });
    };
    Tracking.keep = function (result) {
        return environment_1.ENV.engine.keep(result);
    };
    Tracking.time = function (f) {
        return environment_1.ENV.engine.time(f);
    };
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Tracking, "tidy", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Tracking, "dispose", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Tracking, "keep", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Timing' })
    ], Tracking, "time", null);
    return Tracking;
}());
exports.Tracking = Tracking;

},{"./doc":46,"./environment":48,"./util":155}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
var adam_optimizer_1 = require("./optimizers/adam_optimizer");
var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
var optimizer_constructors_1 = require("./optimizers/optimizer_constructors");
var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
[momentum_optimizer_1.MomentumOptimizer, sgd_optimizer_1.SGDOptimizer, adadelta_optimizer_1.AdadeltaOptimizer, adagrad_optimizer_1.AdagradOptimizer,
    rmsprop_optimizer_1.RMSPropOptimizer, adamax_optimizer_1.AdamaxOptimizer, adam_optimizer_1.AdamOptimizer];
exports.train = {
    sgd: optimizer_constructors_1.OptimizerConstructors.sgd,
    momentum: optimizer_constructors_1.OptimizerConstructors.momentum,
    adadelta: optimizer_constructors_1.OptimizerConstructors.adadelta,
    adagrad: optimizer_constructors_1.OptimizerConstructors.adagrad,
    rmsprop: optimizer_constructors_1.OptimizerConstructors.rmsprop,
    adamax: optimizer_constructors_1.OptimizerConstructors.adamax,
    adam: optimizer_constructors_1.OptimizerConstructors.adam
};

},{"./optimizers/adadelta_optimizer":137,"./optimizers/adagrad_optimizer":138,"./optimizers/adam_optimizer":139,"./optimizers/adamax_optimizer":140,"./optimizers/momentum_optimizer":141,"./optimizers/optimizer_constructors":143,"./optimizers/rmsprop_optimizer":144,"./optimizers/sgd_optimizer":145}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DType;
(function (DType) {
    DType["float32"] = "float32";
    DType["int32"] = "int32";
    DType["bool"] = "bool";
})(DType = exports.DType || (exports.DType = {}));
var Rank;
(function (Rank) {
    Rank["R0"] = "R0";
    Rank["R1"] = "R1";
    Rank["R2"] = "R2";
    Rank["R3"] = "R3";
    Rank["R4"] = "R4";
    Rank["R5"] = "R5";
})(Rank = exports.Rank || (exports.Rank = {}));
var UpcastInt32AndMap;
(function (UpcastInt32AndMap) {
    UpcastInt32AndMap["float32"] = "float32";
    UpcastInt32AndMap["int32"] = "int32";
    UpcastInt32AndMap["bool"] = "int32";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function (UpcastBoolAndMap) {
    UpcastBoolAndMap["float32"] = "float32";
    UpcastBoolAndMap["int32"] = "int32";
    UpcastBoolAndMap["bool"] = "bool";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function (UpcastFloat32AndMap) {
    UpcastFloat32AndMap["float32"] = "float32";
    UpcastFloat32AndMap["int32"] = "float32";
    UpcastFloat32AndMap["bool"] = "float32";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var upcastTypeMap = {
    float32: UpcastFloat32AndMap,
    int32: UpcastInt32AndMap,
    bool: UpcastBoolAndMap
};
function upcastType(typeA, typeB) {
    return upcastTypeMap[typeA][typeB];
}
exports.upcastType = upcastType;
function sumOutType(type) {
    return upcastType(type, 'int32');
}
exports.sumOutType = sumOutType;

},{}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
function assertArgumentIsTensor(x, argName, functionName) {
    assert(x instanceof tensor_1.Tensor, "Argument '" + argName + "' passed to '" + functionName + "' must be a Tensor, " +
        ("but got " + typeof x + "."));
}
function assertArgumentsAreTensors(args, functionName) {
    var _loop_1 = function (argName) {
        var arg = args[argName];
        if (Array.isArray(arg)) {
            arg.forEach(function (t, i) {
                assertArgumentIsTensor(t, argName + "[" + i + "]", functionName);
            });
        }
        else {
            assertArgumentIsTensor(arg, argName, functionName);
        }
    };
    for (var argName in args) {
        _loop_1(argName);
    }
}
exports.assertArgumentsAreTensors = assertArgumentsAreTensors;
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function assertTypesMatch(a, b) {
    assert(a.dtype === b.dtype, " The dtypes of the first(" + a.dtype + ") and" +
        (" second(" + b.dtype + ") input must match"));
}
exports.assertTypesMatch = assertTypesMatch;
function flatten(arr, ret) {
    if (ret === void 0) { ret = []; }
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; ++i) {
            flatten(arr[i], ret);
        }
    }
    else {
        ret.push(arr);
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(val) {
    if (isTypedArray(val)) {
        return [val.length];
    }
    if (!Array.isArray(val)) {
        return [];
    }
    var shape = [];
    while (val instanceof Array) {
        shape.push(val.length);
        val = val[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
exports.rightPad = rightPad;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
    return new Promise(function (resolve, reject) {
        var tryCount = 0;
        var tryFn = function () {
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            var nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        tryFn();
    });
}
exports.repeatedTry = repeatedTry;
function getQueryParams(queryString) {
    var params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
        var t = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            t[_i - 1] = arguments[_i];
        }
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
exports.getQueryParams = getQueryParams;
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function inferFromImplicitShape(shape, size) {
    var shapeProd = 1;
    var implicitIdx = -1;
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 0) {
            shapeProd *= shape[i];
        }
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " +
                    ("Found - 1 at dim " + implicitIdx + " and dim " + i));
            }
            implicitIdx = i;
        }
        else if (shape[i] <= 0) {
            throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i);
        }
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
            throw Error("Size(" + size + ") must match the product of shape " + shape);
        }
        return shape;
    }
    if (size % shapeProd !== 0) {
        throw Error("The implicit shape can't be a fractional number. " +
            ("Got " + size + " / " + shapeProd));
    }
    var newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
exports.inferFromImplicitShape = inferFromImplicitShape;
function squeezeShape(shape, axis) {
    var newShape = [];
    var keptDims = [];
    var j = 0;
    for (var i = 0; i < shape.length; ++i) {
        if (axis != null) {
            if (axis[j] === i && shape[i] > 1) {
                throw new Error("Can't squeeze axis " + i + " since its dim '" + shape[i] + "' is not 1");
            }
            if ((axis[j] == null || axis[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axis[j] <= i) {
                j++;
            }
        }
        if (shape[i] > 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;
function getTypedArrayFromDType(dtype, size) {
    var values = null;
    if (dtype == null || dtype === 'float32') {
        values = new Float32Array(size);
    }
    else if (dtype === 'int32') {
        values = new Int32Array(size);
    }
    else if (dtype === 'bool') {
        values = new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
    return values;
}
exports.getTypedArrayFromDType = getTypedArrayFromDType;
function isTensorInList(tensor, tensorList) {
    for (var i = 0; i < tensorList.length; i++) {
        if (tensorList[i].id === tensor.id) {
            return true;
        }
    }
    return false;
}
exports.isTensorInList = isTensorInList;
function checkForNaN(vals, dtype, name) {
    if (dtype !== 'float32') {
        return;
    }
    for (var i = 0; i < vals.length; i++) {
        if (isNaN(vals[i])) {
            throw Error("The result of the '" + name + "' has NaNs.");
        }
    }
}
exports.checkForNaN = checkForNaN;
function flattenNameArrayMap(nameArrayMap, keys) {
    var xs = [];
    if (nameArrayMap instanceof tensor_1.Tensor) {
        xs.push(nameArrayMap);
    }
    else {
        var xMap = nameArrayMap;
        for (var i = 0; i < keys.length; i++) {
            xs.push(xMap[keys[i]]);
        }
    }
    return xs;
}
exports.flattenNameArrayMap = flattenNameArrayMap;
function unflattenToNameArrayMap(keys, flatArrays) {
    if (keys.length !== flatArrays.length) {
        throw new Error("Cannot unflatten Tensor[], keys and arrays are not of same length.");
    }
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = flatArrays[i];
    }
    return result;
}
exports.unflattenToNameArrayMap = unflattenToNameArrayMap;
function hasEncodingLoss(oldType, newType) {
    if (newType === 'float32') {
        return false;
    }
    if (newType === 'int32' && oldType !== 'float32') {
        return false;
    }
    if (newType === 'bool' && oldType === 'bool') {
        return false;
    }
    return true;
}
exports.hasEncodingLoss = hasEncodingLoss;
function copyTypedArray(array, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(array);
    }
    else if (dtype === 'int32') {
        return new Int32Array(array);
    }
    else if (dtype === 'bool') {
        var bool = new Uint8Array(array.length);
        for (var i = 0; i < bool.length; ++i) {
            if (Math.round(array[i]) !== 0) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
exports.copyTypedArray = copyTypedArray;
function isTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array;
}
exports.isTypedArray = isTypedArray;
function bytesPerElement(dtype) {
    if (dtype === 'float32' || dtype === 'int32') {
        return 4;
    }
    else if (dtype === 'bool') {
        return 1;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.bytesPerElement = bytesPerElement;
function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
}
exports.isFunction = isFunction;
function getTensorsInContainer(result) {
    var list = [];
    var seen = new Set();
    walkTensorContainer(result, list, seen);
    return list;
}
exports.getTensorsInContainer = getTensorsInContainer;
function walkTensorContainer(container, list, seen) {
    if (container == null) {
        return;
    }
    if (container instanceof tensor_1.Tensor) {
        list.push(container);
        return;
    }
    if (!isIterable(container)) {
        return;
    }
    var iterable = container;
    for (var k in iterable) {
        var val = iterable[k];
        if (!seen.has(val)) {
            seen.add(val);
            walkTensorContainer(val, list, seen);
        }
    }
}
function isIterable(obj) {
    return Array.isArray(obj) || typeof obj === 'object';
}

},{"./tensor":149}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.11.6';
exports.version = version;

},{}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gpgpu_util = require("./kernels/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var webgl_util = require("./kernels/webgl/webgl_util");
exports.webgl_util = webgl_util;
var backend_webgl_1 = require("./kernels/backend_webgl");
exports.MathBackendWebGL = backend_webgl_1.MathBackendWebGL;
var gpgpu_context_1 = require("./kernels/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;

},{"./kernels/backend_webgl":64,"./kernels/webgl/gpgpu_context":78,"./kernels/webgl/gpgpu_util":80,"./kernels/webgl/webgl_util":102}],158:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var generic_utils_1 = require("./utils/generic_utils");
var Activation = (function (_super) {
    __extends(Activation, _super);
    function Activation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Activation.prototype.getConfig = function () {
        return {};
    };
    return Activation;
}(tfjs_core_1.serialization.Serializable));
exports.Activation = Activation;
var Elu = (function (_super) {
    __extends(Elu, _super);
    function Elu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Elu.prototype.apply = function (x, alpha) {
        if (alpha === void 0) { alpha = 1; }
        return K.elu(x, alpha);
    };
    Elu.className = 'elu';
    return Elu;
}(Activation));
exports.Elu = Elu;
tfjs_core_1.serialization.SerializationMap.register(Elu);
var Selu = (function (_super) {
    __extends(Selu, _super);
    function Selu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Selu.prototype.apply = function (x) {
        return tfc.selu(x);
    };
    Selu.className = 'selu';
    return Selu;
}(Activation));
exports.Selu = Selu;
tfjs_core_1.serialization.SerializationMap.register(Selu);
var Relu = (function (_super) {
    __extends(Relu, _super);
    function Relu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Relu.prototype.apply = function (x) {
        return tfc.relu(x);
    };
    Relu.className = 'relu';
    return Relu;
}(Activation));
exports.Relu = Relu;
tfjs_core_1.serialization.SerializationMap.register(Relu);
var Relu6 = (function (_super) {
    __extends(Relu6, _super);
    function Relu6() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Relu6.prototype.apply = function (x) {
        return tfjs_core_1.tidy(function () { return tfc.minimum(K.getScalar(6.0), tfc.relu(x)); });
    };
    Relu6.className = 'relu6';
    return Relu6;
}(Activation));
exports.Relu6 = Relu6;
tfjs_core_1.serialization.SerializationMap.register(Relu6);
var Linear = (function (_super) {
    __extends(Linear, _super);
    function Linear() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Linear.prototype.apply = function (x) {
        return x;
    };
    Linear.className = 'linear';
    return Linear;
}(Activation));
exports.Linear = Linear;
tfjs_core_1.serialization.SerializationMap.register(Linear);
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Sigmoid.prototype.apply = function (x) {
        return tfc.sigmoid(x);
    };
    Sigmoid.className = 'sigmoid';
    return Sigmoid;
}(Activation));
exports.Sigmoid = Sigmoid;
tfjs_core_1.serialization.SerializationMap.register(Sigmoid);
var HardSigmoid = (function (_super) {
    __extends(HardSigmoid, _super);
    function HardSigmoid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HardSigmoid.prototype.apply = function (x) {
        return K.hardSigmoid(x);
    };
    HardSigmoid.className = 'hardSigmoid';
    return HardSigmoid;
}(Activation));
exports.HardSigmoid = HardSigmoid;
tfjs_core_1.serialization.SerializationMap.register(HardSigmoid);
var Softplus = (function (_super) {
    __extends(Softplus, _super);
    function Softplus() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softplus.prototype.apply = function (x) {
        return tfc.softplus(x);
    };
    Softplus.className = 'softplus';
    return Softplus;
}(Activation));
exports.Softplus = Softplus;
tfjs_core_1.serialization.SerializationMap.register(Softplus);
var Softsign = (function (_super) {
    __extends(Softsign, _super);
    function Softsign() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softsign.prototype.apply = function (x) {
        return K.softsign(x);
    };
    Softsign.className = 'softsign';
    return Softsign;
}(Activation));
exports.Softsign = Softsign;
tfjs_core_1.serialization.SerializationMap.register(Softsign);
var Tanh = (function (_super) {
    __extends(Tanh, _super);
    function Tanh() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tanh.prototype.apply = function (x) {
        return tfc.tanh(x);
    };
    Tanh.className = 'tanh';
    return Tanh;
}(Activation));
exports.Tanh = Tanh;
tfjs_core_1.serialization.SerializationMap.register(Tanh);
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softmax.prototype.apply = function (x, axis) {
        if (axis === void 0) { axis = (-1); }
        return tfc.softmax(x, axis);
    };
    Softmax.className = 'softmax';
    return Softmax;
}(Activation));
exports.Softmax = Softmax;
tfjs_core_1.serialization.SerializationMap.register(Softmax);
function serializeActivation(activation) {
    return activation.getClassName();
}
exports.serializeActivation = serializeActivation;
function deserializeActivation(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'activation');
}
exports.deserializeActivation = deserializeActivation;
function getActivation(identifier) {
    if (identifier == null) {
        var config = { className: 'linear', config: {} };
        return deserializeActivation(config);
    }
    if (typeof identifier === 'string') {
        var config = { className: identifier, config: {} };
        return deserializeActivation(config);
    }
    else if (identifier instanceof Activation) {
        return identifier;
    }
    else {
        return deserializeActivation(identifier);
    }
}
exports.getActivation = getActivation;

},{"./backend/tfjs_backend":160,"./utils/generic_utils":190,"@tensorflow/tfjs-core":51}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _epsilon = 1e-7;
function epsilon() {
    return _epsilon;
}
exports.epsilon = epsilon;
function setEpsilon(e) {
    _epsilon = e;
}
exports.setEpsilon = setEpsilon;
function imageDataFormat() {
    return 'channelsLast';
}
exports.imageDataFormat = imageDataFormat;

},{}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../common");
var errors_1 = require("../errors");
var math_utils = require("../utils/math_utils");
var variables_1 = require("../variables");
var common_2 = require("./common");
var common_3 = require("./common");
var backend = 'webgl';
var DEFAULT_DTYPE = 'float32';
function disposeScalarCache() {
    for (var typeKey in scalarCache) {
        for (var key in scalarCache[typeKey]) {
            scalarCache[typeKey][key].dispose();
            delete scalarCache[typeKey][key];
        }
    }
}
exports.disposeScalarCache = disposeScalarCache;
function setBackend(requestedBackend) {
    tfc.setBackend(requestedBackend);
    backend = requestedBackend;
    disposeScalarCache();
}
exports.setBackend = setBackend;
function getBackend() {
    return backend;
}
exports.getBackend = getBackend;
var scalarCache = {
    float32: {},
    int32: {}
};
function getScalar(value, dtype) {
    if (dtype === undefined) {
        dtype = DEFAULT_DTYPE;
    }
    if (scalarCache[dtype][value] == null) {
        scalarCache[dtype][value] = tfjs_core_1.scalar(value, dtype);
        tfc.keep(scalarCache[dtype][value]);
    }
    return scalarCache[dtype][value];
}
exports.getScalar = getScalar;
exports.epsilon = common_2.epsilon;
function isBackendSymbolic() {
    return false;
}
exports.isBackendSymbolic = isBackendSymbolic;
function shape(x) {
    return x.shape;
}
exports.shape = shape;
function intShape(x) {
    return x.shape;
}
exports.intShape = intShape;
function dtype(x) {
    return (x instanceof tfjs_core_1.Tensor) ? DEFAULT_DTYPE : x.dtype;
}
exports.dtype = dtype;
function countParams(x) {
    var shape = x.shape;
    if (shape.length > 0) {
        return shape.reduce(function (a, b) { return a * b; });
    }
    else {
        return 1;
    }
}
exports.countParams = countParams;
function cast(x, dtype) {
    return x.asType(dtype);
}
exports.cast = cast;
function expandDims(x, axis) {
    if (axis === void 0) { axis = -1; }
    var outShape = shape(x).slice();
    if (axis < 0) {
        axis = outShape.length + axis + 1;
    }
    outShape.splice(axis, 0, 1);
    return x.reshape(outShape);
}
exports.expandDims = expandDims;
function repeat(x, n) {
    return tfjs_core_1.tidy(function () {
        if (x.shape.length !== 2) {
            throw new errors_1.ValueError("repeat() expects a rank-2 tensor, but received a " +
                ("rank-" + x.shape.length + " tensor."));
        }
        var y = expandDims(x, 1);
        return tile(y, [1, n, 1]);
    });
}
exports.repeat = repeat;
function flatten(x) {
    var newShape = [math_utils.arrayProd(x.shape)];
    return x.reshape(newShape);
}
exports.flatten = flatten;
function batchFlatten(x) {
    if (x.rank <= 1) {
        throw new errors_1.ValueError("batchFlatten requires a minimum rank of 2. Got rank: " + x.rank + ".");
    }
    var newShape = [x.shape[0], math_utils.arrayProd(x.shape, 1)];
    return x.reshape(newShape);
}
exports.batchFlatten = batchFlatten;
function sliceAlongFirstAxis(array, start, size) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                return tfc.slice2d(array, [start, 0], [size, array.shape[1]]);
            case 3:
                return tfc.slice3d(array, [start, 0, 0], [size, array.shape[1], array.shape[2]]);
            case 4:
                return tfc.slice4d(array, [start, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3]]);
            default:
                throw new errors_1.ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongFirstAxis = sliceAlongFirstAxis;
function sliceAlongLastAxis(array, start, size) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                return tfc.slice2d(array, [0, start], [array.shape[0], size]);
            case 3:
                return tfc.slice3d(array, [0, 0, start], [array.shape[0], array.shape[1], size]);
            case 4:
                return tfc.slice4d(array, [0, 0, 0, start], [array.shape[0], array.shape[1], array.shape[2], size]);
            default:
                throw new errors_1.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongLastAxis = sliceAlongLastAxis;
function sliceAlongAxis(array, start, size, axis) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            case 3:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return tfc.slice3d(array, [0, start, 0], [array.shape[0], size, array.shape[2]]);
                    case 3:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            case 4:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return tfc.slice4d(array, [0, start, 0, 0], [array.shape[0], size, array.shape[2], array.shape[3]]);
                    case 3:
                        return tfc.slice4d(array, [0, 0, start, 0], [array.shape[0], array.shape[1], size, array.shape[3]]);
                    case 4:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            default:
                throw new errors_1.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongAxis = sliceAlongAxis;
function concatenate(tensors, axis) {
    if (axis === void 0) { axis = -1; }
    var rank;
    if (axis < 0) {
        rank = tensors[0].rank;
        if (rank !== 0) {
            axis = rank;
        }
        else {
            axis = 0;
        }
    }
    if (axis === tensors[0].rank) {
        axis = -1;
    }
    return tfc.concat(tensors, axis);
}
exports.concatenate = concatenate;
function concatAlongFirstAxis(a, b) {
    switch (a.rank) {
        case 1:
            return tfc.concat1d([a, b]);
        case 2:
            return tfc.concat2d([a, b], 0);
        case 3:
            return tfc.concat3d([a, b], 0);
        case 4:
            return tfc.concat4d([a, b], 0);
        default:
            throw new errors_1.ValueError('concatAlongFirstAxis() received an unsupported tensor rank: ' +
                a.rank);
    }
}
exports.concatAlongFirstAxis = concatAlongFirstAxis;
function tile(x, n) {
    if (!Array.isArray(n)) {
        n = [n];
    }
    if (x.rank !== n.length) {
        throw new errors_1.ValueError("The length of input n (" + n.length + ") does not match " +
            ("the number of dimensions in input x (" + x.rank + ")"));
    }
    return tfc.tile(x, n);
}
exports.tile = tile;
function identity(x) {
    return x.clone();
}
exports.identity = identity;
function eyeVariable(size, dtype, name) {
    return new variables_1.LayerVariable(tfc.eye(size, size, null, dtype), dtype, name);
}
exports.eyeVariable = eyeVariable;
function scalarTimesArray(c, x) {
    return tfc.mul(c, x);
}
exports.scalarTimesArray = scalarTimesArray;
function scalarPlusArray(c, x) {
    return tfc.add(c, x);
}
exports.scalarPlusArray = scalarPlusArray;
function randomNormal(shape, mean, stddev, dtype, seed) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    return tfc.randomNormal(shape, mean, stddev, dtype, seed);
}
exports.randomNormal = randomNormal;
function dot(x, y) {
    if (y.rank !== 2) {
        throw new errors_1.NotImplementedError("dot support for y other than rank 2 is not yet implemented: " +
            ("y shape = " + shape));
    }
    else {
        if (x.rank === 2) {
            return tfc.matMul(x, y);
        }
        else if (x.rank === 3) {
            var xShape0 = x.shape[0];
            var xShape1 = x.shape[1];
            var xShape2 = x.shape[2];
            x = x.reshape([xShape0 * xShape1, xShape2]);
            return tfc.matMul(x, y).reshape([
                xShape0, xShape1, y.shape[1]
            ]);
        }
        else {
            throw new errors_1.NotImplementedError("dot support for x of rank " + x.rank + " is not yet implemented: " +
                ("x shape = " + shape));
        }
    }
}
exports.dot = dot;
function sign(x) {
    return tfjs_core_1.tidy(function () {
        var zerosLikeX = tfjs_core_1.zerosLike(x);
        var onesLikeX = tfjs_core_1.onesLike(x);
        return tfjs_core_1.where(tfc.equal(x, zerosLikeX), zerosLikeX, tfjs_core_1.where(tfc.greater(x, tfjs_core_1.zerosLike(x)), onesLikeX, scalarTimesArray(getScalar(-1), onesLikeX)));
    });
}
exports.sign = sign;
function qr(x) {
    var _a = tfjs_core_1.tidy(function () {
        if (x.shape.length !== 2) {
            throw new errors_1.ValueError("qr() requires a 2D Tensor, but got a " + x.shape.length + "D Tensor.");
        }
        if (x.shape[0] < x.shape[1]) {
            throw new errors_1.ValueError("qr() requires x.shape[0] >= x.shape[1], but got shape: [" + x.shape + "]");
        }
        var m = x.shape[0];
        var n = x.shape[1];
        var q = tfc.eye(m);
        var r = x.clone();
        var one2D = tfjs_core_1.tensor2d([[1]], [1, 1]);
        var w = one2D.clone();
        var _loop_1 = function (j) {
            var rTemp = r;
            var wTemp = w;
            var qTemp = q;
            _a = tfjs_core_1.tidy(function () {
                var rjEnd1 = r.slice([j, j], [m - j, 1]);
                var normX = tfc.norm(rjEnd1);
                var rjj = r.slice([j, j], [1, 1]);
                var s = tfc.neg(sign(rjj));
                var u1 = rjj.sub(tfc.mul(s, normX));
                var wPre = tfc.div(rjEnd1, u1);
                if (wPre.shape[0] === 1) {
                    w = one2D.clone();
                }
                else {
                    w = one2D.concat(wPre.slice([1, 0], [wPre.shape[0] - 1, wPre.shape[1]]), 0);
                }
                var tau = tfc.neg(tfc.div(tfc.matMul(s, u1), normX));
                var rjEndAll = r.slice([j, 0], [m - j, n]);
                var tauTimesW = tau.mul(w);
                if (j === 0) {
                    r = rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll)));
                }
                else {
                    r = r.slice([0, 0], [j, n])
                        .concat(rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll))), 0);
                }
                var qAllJEnd = q.slice([0, j], [m, q.shape[1] - j]);
                if (j === 0) {
                    q = qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose()));
                }
                else {
                    q = q.slice([0, 0], [m, j])
                        .concat(qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose())), 1);
                }
                return [w, r, q];
            }), w = _a[0], r = _a[1], q = _a[2];
            tfjs_core_1.dispose([rTemp, wTemp, qTemp]);
            var _a;
        };
        for (var j = 0; j < n; ++j) {
            _loop_1(j);
        }
        return [q, r];
    }), qOuter = _a[0], rOuter = _a[1];
    return [qOuter, rOuter];
}
exports.qr = qr;
function oneHot(indices, numClasses) {
    return tfjs_core_1.tidy(function () {
        if (indices.rank !== 1) {
            throw new Error('Only 1D one-hot tensors are supported in the ' +
                'deeplearn backend, at present.');
        }
        indices = indices.toInt();
        return tfc.oneHot(indices, numClasses).toFloat();
    });
}
exports.oneHot = oneHot;
function gather(reference, indices, axis) {
    return tfjs_core_1.tidy(function () {
        if (Array.isArray(indices)) {
            indices = tfjs_core_1.tensor1d(indices, 'int32');
        }
        else {
            indices = indices.toInt();
        }
        return tfc.gather(reference, indices, axis);
    });
}
exports.gather = gather;
function square(x) {
    return tfc.mulStrict(x, x);
}
exports.square = square;
function pow(x, a) {
    return tfjs_core_1.tidy(function () {
        if (typeof (a) === 'number') {
            a = tfjs_core_1.scalar(Math.round(a), 'int32');
        }
        if (a.dtype !== 'int32') {
            throw new errors_1.NotImplementedError("Non-int32 dtype (" + a.dtype + ") is not supported by pow() yet");
        }
        return tfc.pow(x, a);
    });
}
exports.pow = pow;
function biasAdd(x, bias, dataFormat) {
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_3.imageDataFormat();
        }
        common_1.checkDataFormat(dataFormat);
        if (bias.rank !== 1 && bias.rank !== x.rank) {
            throw new errors_1.ValueError('Unexpected bias dimensions: ' + bias.rank +
                '; expected it to be 1 or ' + x.rank);
        }
        var biasShape = bias.shape;
        var y;
        if (x.rank === 5) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1, 1, 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, 1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank === 4) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1, 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[2], biasShape[0], biasShape[1]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank === 3) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[1], biasShape[0]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank < 3) {
            y = x.add(bias);
        }
        else {
            throw new errors_1.ValueError("Unsupported input rank by biasAdd: " + x.rank);
        }
        return y;
    });
}
exports.biasAdd = biasAdd;
function elu(x, alpha) {
    if (alpha === void 0) { alpha = 1; }
    if (alpha !== 1) {
        throw new errors_1.NotImplementedError("Support for alpha values other than 1 (" + alpha + ") is not implemented " +
            "yet.");
    }
    return tfc.elu(x);
}
exports.elu = elu;
function softsign(x) {
    return tfjs_core_1.tidy(function () { return tfc.div(x, tfc.add(getScalar(1), tfc.abs(x))); });
}
exports.softsign = softsign;
function dropout(x, level, noiseShape, seed) {
    return tfjs_core_1.tidy(function () {
        if (noiseShape != null && !tfjs_core_1.util.arraysEqual(x.shape, noiseShape)) {
            throw new errors_1.NotImplementedError('Non-default noise shape is not implemented yet: ' +
                JSON.stringify(noiseShape));
        }
        if (seed != null) {
            throw new errors_1.NotImplementedError('seed is not implemented for dropout yet.');
        }
        var multiplier = tfc.step(tfc.add(tfc.neg(level), tfc.randomUniform(x.shape, 0, 1, 'float32')));
        multiplier = tfc.mul(tfc.div(getScalar(1), tfc.sub(getScalar(1), level)), multiplier);
        return tfc.mul(x, multiplier);
    });
}
exports.dropout = dropout;
function nameScope(name, fn) {
    return common_1.nameScope(name, fn);
}
exports.nameScope = nameScope;
function floatx() {
    return 'float32';
}
exports.floatx = floatx;
var _uidPrefixes = {};
function getUid(prefix) {
    if (prefix === void 0) { prefix = ''; }
    if (!(prefix in _uidPrefixes)) {
        _uidPrefixes[prefix] = 0;
    }
    _uidPrefixes[prefix] += 1;
    return prefix + _uidPrefixes[prefix].toString();
}
exports.getUid = getUid;
function hardSigmoid(x) {
    return tfjs_core_1.tidy(function () {
        var y = scalarPlusArray(getScalar(0.5), scalarTimesArray(getScalar(0.2), x));
        return tfc.clipByValue(y, 0, 1);
    });
}
exports.hardSigmoid = hardSigmoid;
function inTrainPhase(x, alt, training) {
    if (training === void 0) { training = false; }
    return training ? x() : alt();
}
exports.inTrainPhase = inTrainPhase;
function gradients(lossFn, variables) {
    var variableList = variables.map(function (variable) { return variable.read(); });
    var valudAndGrads = tfjs_core_1.variableGrads(lossFn, variableList);
    return variables.map(function (variable) { return valudAndGrads.grads[variable.name]; });
}
exports.gradients = gradients;

},{"../common":162,"../errors":167,"../utils/math_utils":191,"../variables":193,"./common":159,"@tensorflow/tfjs-core":51}],161:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var generic_utils = require("./utils/generic_utils");
var Callback = (function () {
    function Callback() {
        this.validationData = null;
        this.model = null;
    }
    Callback.prototype.setParams = function (params) {
        this.params = params;
    };
    Callback.prototype.setModel = function (model) {
        this.model = model;
    };
    Callback.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    return Callback;
}());
exports.Callback = Callback;
var CallbackList = (function () {
    function CallbackList(callbacks, queueLength) {
        if (queueLength === void 0) { queueLength = 10; }
        if (callbacks == null) {
            callbacks = [];
        }
        this.callbacks = callbacks;
        this.queueLength = queueLength;
    }
    CallbackList.prototype.append = function (callback) {
        this.callbacks.push(callback);
    };
    CallbackList.prototype.setParams = function (params) {
        for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback.setParams(params);
        }
    };
    CallbackList.prototype.setModel = function (model) {
        for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback.setModel(model);
        }
    };
    CallbackList.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onEpochBegin(epoch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onEpochEnd(epoch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onBatchBegin(batch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onBatchEnd(batch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onTrainBegin(logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onTrainEnd(logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    return CallbackList;
}());
exports.CallbackList = CallbackList;
var BaseLogger = (function (_super) {
    __extends(BaseLogger, _super);
    function BaseLogger() {
        return _super.call(this) || this;
    }
    BaseLogger.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.seen = 0;
                this.totals = {};
                return [2];
            });
        });
    };
    BaseLogger.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var batchSize, _loop_1, this_1, key;
            return __generator(this, function (_a) {
                if (logs == null) {
                    logs = {};
                }
                batchSize = logs['size'] == null ? 0 : logs['size'];
                this.seen += batchSize;
                _loop_1 = function (key) {
                    var value = logs[key];
                    if (typeof value === 'number') {
                        if (!this_1.totals.hasOwnProperty(key)) {
                            this_1.totals[key] = 0;
                        }
                        this_1.totals[key] = this_1.totals[key] + value * batchSize;
                    }
                    else {
                        var oldTotalsToDispose = void 0;
                        if (key in this_1.totals) {
                            oldTotalsToDispose = this_1.totals[key];
                        }
                        else {
                            this_1.totals[key] = K.getScalar(0);
                        }
                        this_1.totals[key] = tfjs_core_1.tidy(function () { return K.scalarPlusArray(_this.totals[key], tfjs_core_1.mul(value, K.getScalar(batchSize))); });
                        if (oldTotalsToDispose != null) {
                            oldTotalsToDispose.dispose();
                        }
                    }
                };
                this_1 = this;
                for (key in logs) {
                    _loop_1(key);
                }
                return [2];
            });
        });
    };
    BaseLogger.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var _loop_2, this_2, _i, _a, key;
            return __generator(this, function (_b) {
                if (logs != null) {
                    _loop_2 = function (key) {
                        if (this_2.totals[key] == null) {
                            return "continue";
                        }
                        if (typeof this_2.totals[key] === 'number') {
                            logs[key] = this_2.totals[key] / this_2.seen;
                        }
                        else {
                            tfjs_core_1.tidy(function () {
                                logs[key] =
                                    K.scalarTimesArray(tfjs_core_1.div(K.getScalar(1), K.getScalar(_this.seen)), _this.totals[key]);
                                _this.totals[key].dispose();
                                tfjs_core_1.keep(logs[key]);
                            });
                        }
                    };
                    this_2 = this;
                    for (_i = 0, _a = this.params['metrics']; _i < _a.length; _i++) {
                        key = _a[_i];
                        _loop_2(key);
                    }
                }
                return [2];
            });
        });
    };
    return BaseLogger;
}(Callback));
exports.BaseLogger = BaseLogger;
function resolveScalarsInLogs(logs) {
    return __awaiter(this, void 0, void 0, function () {
        var promises, keys, key, value, valueScalar, values, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (logs == null) {
                        return [2];
                    }
                    promises = [];
                    keys = [];
                    for (key in logs) {
                        value = logs[key];
                        if (typeof value !== 'number') {
                            valueScalar = value;
                            promises.push(valueScalar.data());
                            keys.push(key);
                        }
                    }
                    return [4, Promise.all(promises)];
                case 1:
                    values = _a.sent();
                    for (i = 0; i < values.length; ++i) {
                        logs[keys[i]] = values[i][0];
                    }
                    return [2];
            }
        });
    });
}
exports.resolveScalarsInLogs = resolveScalarsInLogs;
function disposeTensorsInLogs(logs) {
    if (logs == null) {
        return;
    }
    for (var key in logs) {
        var value = logs[key];
        if (typeof value !== 'number') {
            value.dispose();
        }
    }
}
exports.disposeTensorsInLogs = disposeTensorsInLogs;
var History = (function (_super) {
    __extends(History, _super);
    function History() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    History.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.epoch = [];
                this.history = {};
                return [2];
            });
        });
    };
    History.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var key;
            return __generator(this, function (_a) {
                if (logs == null) {
                    logs = {};
                }
                this.epoch.push(epoch);
                for (key in logs) {
                    if (this.history[key] == null) {
                        this.history[key] = [];
                    }
                    this.history[key].push(logs[key]);
                }
                return [2];
            });
        });
    };
    History.prototype.syncData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises, keys, indices, key, valueArray, i, valueScalar, values, n;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = [];
                        keys = [];
                        indices = [];
                        for (key in this.history) {
                            valueArray = this.history[key];
                            for (i = 0; i < valueArray.length; ++i) {
                                if (typeof valueArray[i] !== 'number') {
                                    valueScalar = valueArray[i];
                                    promises.push(valueScalar.data());
                                    keys.push(key);
                                    indices.push(i);
                                }
                            }
                        }
                        return [4, Promise.all(promises)];
                    case 1:
                        values = _a.sent();
                        for (n = 0; n < values.length; ++n) {
                            this.history[keys[n]][indices[n]].dispose();
                            this.history[keys[n]][indices[n]] = values[n][0];
                        }
                        return [2];
                }
            });
        });
    };
    return History;
}(Callback));
exports.History = History;
var CustomCallback = (function (_super) {
    __extends(CustomCallback, _super);
    function CustomCallback(config) {
        var _this = _super.call(this) || this;
        _this.trainBegin = config.onTrainBegin;
        _this.trainEnd = config.onTrainEnd;
        _this.epochBegin = config.onEpochBegin;
        _this.epochEnd = config.onEpochEnd;
        _this.batchBegin = config.onBatchBegin;
        _this.batchEnd = config.onBatchEnd;
        return _this;
    }
    CustomCallback.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.epochBegin != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.epochBegin(epoch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.epochEnd != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.epochEnd(epoch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.batchBegin != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.batchBegin(batch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.batchEnd != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.batchEnd(batch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.trainBegin != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.trainBegin(logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.trainEnd != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.trainEnd(logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    return CustomCallback;
}(Callback));
exports.CustomCallback = CustomCallback;
function standardizeCallbacks(callbacks) {
    if (callbacks == null) {
        return null;
    }
    if (callbacks instanceof Callback) {
        return [callbacks];
    }
    if (Array.isArray(callbacks) && callbacks[0] instanceof Callback) {
        return callbacks;
    }
    var callbackConfigs = generic_utils.toList(callbacks);
    return callbackConfigs.map(function (callbackConfig) { return new CustomCallback(callbackConfig); });
}
exports.standardizeCallbacks = standardizeCallbacks;

},{"./backend/tfjs_backend":160,"./utils/generic_utils":190,"@tensorflow/tfjs-core":51}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generic_utils_1 = require("./utils/generic_utils");
var nameMap = new Map();
exports.VALID_DATA_FORMAT_VALUES = ['channelsFirst', 'channelsLast'];
function checkDataFormat(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_DATA_FORMAT_VALUES, 'DataFormat', value);
}
exports.checkDataFormat = checkDataFormat;
exports.VALID_PADDING_MODE_VALUES = ['valid', 'same', 'causal'];
function checkPaddingMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_PADDING_MODE_VALUES, 'PaddingMode', value);
}
exports.checkPaddingMode = checkPaddingMode;
exports.VALID_POOL_MODE_VALUES = ['max', 'avg'];
function checkPoolMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_POOL_MODE_VALUES, 'PoolMode', value);
}
exports.checkPoolMode = checkPoolMode;
var _nameScopeStack = [];
var _nameScopeDivider = '/';
function nameScope(name, fn) {
    _nameScopeStack.push(name);
    try {
        var val = fn();
        _nameScopeStack.pop();
        return val;
    }
    catch (e) {
        _nameScopeStack.pop();
        throw e;
    }
}
exports.nameScope = nameScope;
function currentNameScopePrefix() {
    if (_nameScopeStack.length === 0) {
        return '';
    }
    else {
        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
    }
}
function getScopedTensorName(tensorName) {
    if (!isValidTensorName(tensorName)) {
        throw new Error('Not a valid tensor name: \'' + tensorName + '\'');
    }
    return currentNameScopePrefix() + tensorName;
}
exports.getScopedTensorName = getScopedTensorName;
function getUniqueTensorName(scopedName) {
    if (!isValidTensorName(scopedName)) {
        throw new Error('Not a valid tensor name: \'' + scopedName + '\'');
    }
    if (!nameMap.has(scopedName)) {
        nameMap.set(scopedName, 0);
    }
    var index = nameMap.get(scopedName);
    nameMap.set(scopedName, nameMap.get(scopedName) + 1);
    if (index > 0) {
        var result = scopedName + '_' + index;
        nameMap.set(result, 1);
        return result;
    }
    else {
        return scopedName;
    }
}
exports.getUniqueTensorName = getUniqueTensorName;
var tensorNameRegex = new RegExp(/^[A-Za-z][A-Za-z0-9\._\/]*$/);
function isValidTensorName(name) {
    return name.match(tensorNameRegex) ? true : false;
}
exports.isValidTensorName = isValidTensorName;

},{"./utils/generic_utils":190}],163:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var generic_utils_1 = require("./utils/generic_utils");
function calcL2Norms(w, axis) {
    return tfjs_core_1.tidy(function () { return tfc.sqrt(tfc.sum(K.square(w), axis, true)); });
}
var Constraint = (function (_super) {
    __extends(Constraint, _super);
    function Constraint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Constraint.prototype.getConfig = function () {
        return {};
    };
    Constraint = __decorate([
        tfjs_core_1.doc({ heading: 'Constraints', subheading: 'Classes', namespace: 'constraints' })
    ], Constraint);
    return Constraint;
}(tfjs_core_1.serialization.Serializable));
exports.Constraint = Constraint;
var MaxNorm = (function (_super) {
    __extends(MaxNorm, _super);
    function MaxNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultMaxValue = 2;
        _this.defaultAxis = 0;
        _this.maxValue =
            config.maxValue != null ? config.maxValue : _this.defaultMaxValue;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    MaxNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var norms = calcL2Norms(w, _this.axis);
            var desired = tfc.clipByValue(norms, 0, _this.maxValue);
            return tfc.mul(w, tfc.div(desired, K.scalarPlusArray(K.getScalar(K.epsilon()), norms)));
        });
    };
    MaxNorm.prototype.getConfig = function () {
        return { maxValue: this.maxValue, axis: this.axis };
    };
    MaxNorm.className = 'MaxNorm';
    return MaxNorm;
}(Constraint));
exports.MaxNorm = MaxNorm;
tfjs_core_1.serialization.SerializationMap.register(MaxNorm);
var UnitNorm = (function (_super) {
    __extends(UnitNorm, _super);
    function UnitNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultAxis = 0;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    UnitNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return tfc.div(w, K.scalarPlusArray(K.getScalar(K.epsilon()), calcL2Norms(w, _this.axis))); });
    };
    UnitNorm.prototype.getConfig = function () {
        return { axis: this.axis };
    };
    UnitNorm.className = 'UnitNorm';
    return UnitNorm;
}(Constraint));
exports.UnitNorm = UnitNorm;
tfjs_core_1.serialization.SerializationMap.register(UnitNorm);
var NonNeg = (function (_super) {
    __extends(NonNeg, _super);
    function NonNeg() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NonNeg.prototype.apply = function (w) {
        return tfc.relu(w);
    };
    NonNeg.className = 'NonNeg';
    return NonNeg;
}(Constraint));
exports.NonNeg = NonNeg;
tfjs_core_1.serialization.SerializationMap.register(NonNeg);
var MinMaxNorm = (function (_super) {
    __extends(MinMaxNorm, _super);
    function MinMaxNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultMinValue = 0.0;
        _this.defaultMaxValue = 1.0;
        _this.defaultRate = 1.0;
        _this.defaultAxis = 0;
        _this.minValue =
            config.minValue != null ? config.minValue : _this.defaultMinValue;
        _this.maxValue =
            config.maxValue != null ? config.maxValue : _this.defaultMaxValue;
        _this.rate = config.rate != null ? config.rate : _this.defaultRate;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    MinMaxNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var norms = calcL2Norms(w, _this.axis);
            var desired = tfc.add(K.scalarTimesArray(K.getScalar(_this.rate), tfc.clipByValue(norms, _this.minValue, _this.maxValue)), K.scalarTimesArray(K.getScalar(1.0 - _this.rate), norms));
            return tfc.mul(w, tfc.div(desired, K.scalarPlusArray(K.getScalar(K.epsilon()), norms)));
        });
    };
    MinMaxNorm.prototype.getConfig = function () {
        return {
            minValue: this.minValue,
            maxValue: this.maxValue,
            rate: this.rate,
            axis: this.axis
        };
    };
    MinMaxNorm.className = 'MinMaxNorm';
    return MinMaxNorm;
}(Constraint));
exports.MinMaxNorm = MinMaxNorm;
tfjs_core_1.serialization.SerializationMap.register(MinMaxNorm);
exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'maxNorm': 'MaxNorm',
    'minMaxNorm': 'MinMaxNorm',
    'nonNeg': 'NonNeg',
    'unitNorm': 'UnitNorm'
};
function serializeConstraint(constraint) {
    return generic_utils_1.serializeKerasObject(constraint);
}
exports.serializeConstraint = serializeConstraint;
function deserializeConstraint(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'constraint');
}
exports.deserializeConstraint = deserializeConstraint;
function getConstraint(identifier) {
    if (identifier == null) {
        return null;
    }
    if (typeof identifier === 'string') {
        var className = identifier in exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        var config = { className: className, config: {} };
        return deserializeConstraint(config);
    }
    else if (identifier instanceof Constraint) {
        return identifier;
    }
    else {
        return deserializeConstraint(identifier);
    }
}
exports.getConstraint = getConstraint;

},{"./backend/tfjs_backend":160,"./utils/generic_utils":190,"@tensorflow/tfjs-core":51}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
var topology_1 = require("./topology");
function assertFeedCompatibility(key, val) {
    if (key.dtype != null && key.dtype !== val.dtype) {
        throw new errors_1.ValueError("The dtype of the feed (" + val.dtype + ") is incompatible with that of " +
            ("the key '" + key.name + "' (" + key.dtype + ")."));
    }
    if (key.shape != null) {
        if (key.shape.length !== val.shape.length) {
            throw new errors_1.ValueError("The rank of feed (" + val.shape.length + ") does not match the rank of " +
                ("the key (" + key.shape.length + ")."));
        }
        for (var i = 0; i < key.shape.length; ++i) {
            if (key.shape[i] != null && key.shape[i] !== val.shape[i]) {
                throw new errors_1.ValueError("The " + i + "-th dimension of the feed (" + val.shape[i] + ") is " +
                    ("incompatible with that of the key (" + key.shape[i] + ")."));
            }
        }
    }
}
var FeedDict = (function () {
    function FeedDict(feeds) {
        this.id2Value = {};
        if (feeds instanceof FeedDict) {
            for (var id in feeds.id2Value) {
                this.id2Value[id] = feeds.id2Value[id];
            }
        }
        else {
            if (feeds == null) {
                return;
            }
            for (var _i = 0, feeds_1 = feeds; _i < feeds_1.length; _i++) {
                var feed = feeds_1[_i];
                this.add(feed.key, feed.value);
            }
        }
    }
    FeedDict.prototype.add = function (key, value) {
        assertFeedCompatibility(key, value);
        if (this.id2Value[key.id] == null) {
            this.id2Value[key.id] = value;
        }
        else {
            throw new errors_1.ValueError("Duplicate key: name=" + key.name + ", id=" + key.id);
        }
        return this;
    };
    FeedDict.prototype.addFeed = function (feed) {
        this.add(feed.key, feed.value);
    };
    FeedDict.prototype.hasKey = function (key) {
        return this.id2Value[key.id] != null;
    };
    FeedDict.prototype.getValue = function (key) {
        if (this.id2Value[key.id] == null) {
            throw new errors_1.ValueError("Nonexistent key: " + JSON.stringify(key));
        }
        else {
            return this.id2Value[key.id];
        }
    };
    return FeedDict;
}());
exports.FeedDict = FeedDict;
function execute(fetches, feedDict, kwargs) {
    var arrayFetches = Array.isArray(fetches);
    var fetchArray = arrayFetches ? fetches : [fetches];
    var outputs = [];
    var internalFeedDict = new FeedDict(feedDict);
    for (var _i = 0, fetchArray_1 = fetchArray; _i < fetchArray_1.length; _i++) {
        var fetch_1 = fetchArray_1[_i];
        outputs.push(executeInternal(fetch_1, internalFeedDict, kwargs));
    }
    return arrayFetches ? outputs : outputs[0];
}
exports.execute = execute;
function executeInternal(fetch, internalFeedDict, kwargs) {
    if (internalFeedDict.hasKey(fetch)) {
        return internalFeedDict.getValue(fetch);
    }
    if (fetch.sourceLayer instanceof topology_1.InputLayer) {
        throw new errors_1.ValueError("Missing a feed value for SymbolicTensor from InputLayer " +
            ("'" + topology_1.InputLayer.name + "'"));
    }
    var inputs = fetch.inputs;
    var inputValues = [];
    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
        var input = inputs_1[_i];
        var inputVal = executeInternal(input, internalFeedDict, kwargs);
        inputValues.push(inputVal);
    }
    var output = fetch.sourceLayer.apply(inputValues, kwargs);
    if (!Array.isArray(output)) {
        output = [output];
    }
    var layerOutputs = getNodeOutputs(fetch);
    var outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];
    for (var i = 0; i < outputSymbolicTensors.length; ++i) {
        internalFeedDict.add(outputSymbolicTensors[i], output[i]);
    }
    return output.length === 1 ? output[0] : output[fetch.outputTensorIndex];
}
function getNodeOutputs(fetch) {
    var layerOutputs;
    if (fetch.sourceLayer.inboundNodes.length === 1) {
        layerOutputs = fetch.sourceLayer.output;
    }
    else {
        var nodeIndex = null;
        for (var i = 0; i < fetch.sourceLayer.inboundNodes.length; ++i) {
            for (var _i = 0, _a = fetch.sourceLayer.inboundNodes[i]
                .outputTensors; _i < _a.length; _i++) {
                var outputTensor = _a[_i];
                if (outputTensor.id === fetch.id) {
                    nodeIndex = i;
                    break;
                }
            }
        }
        layerOutputs = fetch.sourceLayer.getOutputAt(nodeIndex);
    }
    return layerOutputs;
}

},{"../errors":167,"./topology":165}],165:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var errors_1 = require("../errors");
var serialization_1 = require("../layers/serialization");
var types_1 = require("../types");
var generic_utils = require("../utils/generic_utils");
var serialization_utils_1 = require("../utils/serialization_utils");
var variables_1 = require("../variables");
var version_1 = require("../version");
var InputSpec = (function () {
    function InputSpec(config) {
        this.dtype = config.dtype;
        this.shape = config.shape;
        if (config.shape != null) {
            this.ndim = config.shape.length;
        }
        else {
            this.ndim = config.ndim;
        }
        this.maxNDim = config.maxNDim;
        this.minNDim = config.minNDim;
        this.axes = config.axes || {};
    }
    return InputSpec;
}());
exports.InputSpec = InputSpec;
var _nextNodeID = 0;
var Node = (function () {
    function Node(config, callArgs) {
        this.callArgs = callArgs;
        this.id = _nextNodeID++;
        this.outboundLayer = config.outboundLayer;
        this.inboundLayers = config.inboundLayers;
        this.nodeIndices = config.nodeIndices;
        this.tensorIndices = config.tensorIndices;
        this.inputTensors = config.inputTensors;
        this.outputTensors = config.outputTensors;
        this.inputMasks = config.inputMasks;
        this.outputMasks = config.outputMasks;
        this.inputShapes = config.inputShapes;
        this.outputShapes = config.outputShapes;
        for (var _i = 0, _a = config.inboundLayers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer != null) {
                layer.outboundNodes.push(this);
            }
        }
        config.outboundLayer.inboundNodes.push(this);
    }
    Node.prototype.getConfig = function () {
        var inboundNames = [];
        for (var _i = 0, _a = this.inboundLayers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer != null) {
                inboundNames.push(layer.name);
            }
            else {
                inboundNames.push(null);
            }
        }
        return {
            outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
            inboundLayers: inboundNames,
            nodeIndices: this.nodeIndices,
            tensorIndices: this.tensorIndices
        };
    };
    return Node;
}());
exports.Node = Node;
var _nextLayerID = 0;
var Layer = (function (_super) {
    __extends(Layer, _super);
    function Layer(config) {
        var _this = _super.call(this) || this;
        _this._callHook = null;
        _this._addedWeightNames = [];
        _this._stateful = false;
        _this.id = _nextLayerID++;
        _this.activityRegularizer = null;
        _this.inputSpec = null;
        _this.supportsMasking = false;
        _this._trainableWeights = [];
        _this._nonTrainableWeights = [];
        _this._losses = [];
        _this._updates = [];
        _this._built = false;
        _this.inboundNodes = [];
        _this.outboundNodes = [];
        var name = config.name;
        if (!name) {
            var prefix = _this.getClassName();
            name = generic_utils.toSnakeCase(prefix) + '_' + K.getUid(prefix);
        }
        _this.name = name;
        _this.trainable = config.trainable == null ? true : config.trainable;
        _this.updatable = config.updatable == null ? true : config.updatable;
        if (config.inputShape != null || config.batchInputShape != null) {
            var batchInputShape = void 0;
            if (config.batchInputShape != null) {
                batchInputShape = config.batchInputShape;
            }
            else if (config.inputShape != null) {
                var batchSize = null;
                if (config.batchSize != null) {
                    batchSize = config.batchSize;
                }
                batchInputShape = [batchSize].concat(config.inputShape);
            }
            _this.batchInputShape = batchInputShape;
            var dtype = config.dtype;
            if (dtype == null) {
                dtype = config.inputDType;
            }
            if (dtype == null) {
                dtype = K.floatx();
            }
            _this.dtype = dtype;
        }
        if (config.weights != null) {
            _this.initialWeights = config.weights;
        }
        else {
            _this.initialWeights = null;
        }
        return _this;
    }
    Layer.nodeKey = function (layer, nodeIndex) {
        return layer.name + '_ib-' + nodeIndex.toString();
    };
    Layer.prototype.getNodeAtIndex = function (nodeIndex, attrName) {
        if (this.inboundNodes.length === 0) {
            throw new errors_1.RuntimeError('The layer has never been called ' +
                ("and thus has no defined " + attrName + "."));
        }
        if (this.inboundNodes.length <= nodeIndex) {
            throw new errors_1.ValueError("Asked to get " + attrName + " at node " + nodeIndex + ", " +
                ("but the layer has only " + this.inboundNodes.length + " inbound nodes."));
        }
        return this.inboundNodes[nodeIndex];
    };
    Layer.prototype.getInputAt = function (nodeIndex) {
        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'input').inputTensors);
    };
    Layer.prototype.getOutputAt = function (nodeIndex) {
        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'output').outputTensors);
    };
    Object.defineProperty(Layer.prototype, "input", {
        get: function () {
            if (this.inboundNodes.length > 1) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has multiple inbound nodes, ' +
                    'hence the notion of "layer input" ' +
                    'is ill-defined. ' +
                    'Use `getInputAt(nodeIndex)` instead.');
            }
            else if (this.inboundNodes.length === 0) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' is not connected, no input to return.');
            }
            return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'input').inputTensors);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "output", {
        get: function () {
            if (this.inboundNodes.length === 0) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has no inbound nodes.');
            }
            if (this.inboundNodes.length > 1) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has multiple inbound nodes, ' +
                    'hence the notion of "layer output" ' +
                    'is ill-defined. ' +
                    'Use `getOutputAt(nodeIndex)` instead.');
            }
            return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'output').outputTensors);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "losses", {
        get: function () {
            return this._losses;
        },
        enumerable: true,
        configurable: true
    });
    Layer.prototype.calculateLosses = function () {
        return this.losses.map(function (lossFn) { return lossFn(); });
    };
    Object.defineProperty(Layer.prototype, "updates", {
        get: function () {
            return this._updates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "built", {
        get: function () {
            return this._built;
        },
        set: function (built) {
            this._built = built;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "trainableWeights", {
        get: function () {
            if (this.trainable) {
                return this._trainableWeights;
            }
            else {
                return [];
            }
        },
        set: function (weights) {
            this._trainableWeights = weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "nonTrainableWeights", {
        get: function () {
            if (!this.trainable) {
                return this._trainableWeights.concat(this._nonTrainableWeights);
            }
            else {
                return this._nonTrainableWeights;
            }
        },
        set: function (weights) {
            this._nonTrainableWeights = weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "weights", {
        get: function () {
            return this.trainableWeights.concat(this.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "stateful", {
        get: function () {
            return this._stateful;
        },
        enumerable: true,
        configurable: true
    });
    Layer.prototype.assertInputCompatibility = function (inputs) {
        inputs = generic_utils.toList(inputs);
        if (this.inputSpec == null || this.inputSpec.length === 0) {
            return;
        }
        var inputSpec = generic_utils.toList(this.inputSpec);
        if (inputs.length !== inputSpec.length) {
            throw new errors_1.ValueError("Layer " + this.name + " expects " + inputSpec.length + " inputs, " +
                ("but it received " + inputs.length + " input tensors. ") +
                ("Input received: " + inputs));
        }
        for (var inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
            var x = inputs[inputIndex];
            var spec = inputSpec[inputIndex];
            if (spec == null) {
                continue;
            }
            var ndim = x.rank;
            if (spec.ndim != null) {
                if (ndim !== spec.ndim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + ": " +
                        ("expected ndim=" + spec.ndim + ", found ndim=" + ndim));
                }
            }
            if (spec.maxNDim != null) {
                if (ndim > spec.maxNDim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name +
                        (": expected max_ndim=" + spec.maxNDim + ", found ndim=" + ndim));
                }
            }
            if (spec.minNDim != null) {
                if (ndim < spec.minNDim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name +
                        (": expected min_ndim=" + spec.minNDim + ", found ndim=" + ndim + "."));
                }
            }
            if (spec.dtype != null) {
                if (K.dtype(x) !== spec.dtype) {
                    var xDType = K.dtype(x);
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + " " +
                        (": expected dtype=" + spec.dtype + ", found dtype=" + xDType + "."));
                }
            }
            if (spec.axes) {
                var xShape = K.intShape(x);
                for (var key in spec.axes) {
                    var axis = Number(key);
                    var value = spec.axes[key];
                    var xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];
                    if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {
                        throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " +
                            (this.name + ": expected axis " + axis + " of input shape to ") +
                            ("have value " + value + " but got shape " + xShape + "."));
                    }
                }
            }
            if (spec.shape != null) {
                var xShape = K.intShape(x);
                for (var i = 0; i < spec.shape.length; ++i) {
                    var specDim = spec.shape[i];
                    var dim = xShape[i];
                    if (specDim != null && dim != null) {
                        if (specDim !== dim) {
                            throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " +
                                (this.name + ": expected shape=" + spec.shape + ", ") +
                                'found shape=${xShape}.');
                        }
                    }
                }
            }
        }
    };
    Layer.prototype.call = function (inputs, kwargs) {
        return inputs;
    };
    Layer.prototype.invokeCallHook = function (inputs, kwargs) {
        if (this._callHook != null) {
            this._callHook(inputs, kwargs);
        }
    };
    Layer.prototype.setCallHook = function (callHook) {
        this._callHook = callHook;
    };
    Layer.prototype.clearCallHook = function () {
        this._callHook = null;
    };
    Layer.prototype.apply = function (inputs, kwargs) {
        var _this = this;
        kwargs = kwargs || {};
        var inputsList = generic_utils.toList(inputs);
        var allAreSymbolic = true;
        for (var _i = 0, inputsList_1 = inputsList; _i < inputsList_1.length; _i++) {
            var input = inputsList_1[_i];
            if (!(input instanceof types_1.SymbolicTensor)) {
                allAreSymbolic = false;
                break;
            }
        }
        var noneAreSymbolic = true;
        for (var _a = 0, inputsList_2 = inputsList; _a < inputsList_2.length; _a++) {
            var input = inputsList_2[_a];
            if (input instanceof types_1.SymbolicTensor) {
                noneAreSymbolic = false;
                break;
            }
        }
        if (allAreSymbolic === noneAreSymbolic) {
            throw new errors_1.ValueError('Arguments to apply() must be all ' +
                'SymbolicTensors or all Tensors');
        }
        return K.nameScope(this.name, function () {
            if (!_this.built) {
                _this.assertInputCompatibility(inputs);
                var inputShapes = [];
                for (var _i = 0, _a = generic_utils.toList(inputs); _i < _a.length; _i++) {
                    var xElem = _a[_i];
                    inputShapes.push(K.intShape(xElem));
                }
                _this.build(generic_utils.singletonOrArray(inputShapes));
                _this.built = true;
                if (_this.initialWeights) {
                    _this.setWeights(_this.initialWeights);
                }
            }
            _this.assertInputCompatibility(inputs);
            if (noneAreSymbolic) {
                var output = _this.call(inputs, kwargs);
                var outputList = generic_utils.toList(output);
                var outputListCopy = [];
                for (var _b = 0, outputList_1 = outputList; _b < outputList_1.length; _b++) {
                    var x = outputList_1[_b];
                    if (inputsList.indexOf(x) !== -1) {
                        x = K.identity(x);
                    }
                    outputListCopy.push(x);
                }
                output = generic_utils.singletonOrArray(outputListCopy);
                if (_this.activityRegularizer != null) {
                    throw new errors_1.NotImplementedError('Layer invocation in the presence of activity ' +
                        'regularizer(s) is not supported yet.');
                }
                return output;
            }
            else {
                var inputShape = collectInputShape(inputs);
                var outputShape = _this.computeOutputShape(inputShape);
                var output = void 0;
                var outputDType_1 = guessOutputDType(inputs);
                if (outputShape != null && outputShape.length > 0 &&
                    Array.isArray(outputShape[0])) {
                    output = outputShape
                        .map(function (shape, index) { return new types_1.SymbolicTensor(outputDType_1, shape, _this, generic_utils.toList(inputs), kwargs, _this.name, index); });
                }
                else {
                    output = new types_1.SymbolicTensor(outputDType_1, outputShape, _this, generic_utils.toList(inputs), kwargs, _this.name);
                }
                _this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);
                if (_this.activityRegularizer != null) {
                    throw new errors_1.NotImplementedError('Layer invocation in the presence of activity ' +
                        'regularizer(s) is not supported yet.');
                }
                return output;
            }
        });
    };
    Layer.prototype.build = function (inputShape) {
        this.built = true;
    };
    Layer.prototype.getWeights = function (trainableOnly) {
        if (trainableOnly === void 0) { trainableOnly = false; }
        return variables_1.batchGetValue(trainableOnly ? this.trainableWeights : this.weights);
    };
    Layer.prototype.setWeights = function (weights) {
        var _this = this;
        tfjs_core_1.tidy(function () {
            var params = _this.weights;
            if (params.length !== weights.length) {
                throw new errors_1.ValueError("You called setWeights(weights) on layer \"" + _this.name + "\" " +
                    ("with a weight list of length " + weights.length + ", ") +
                    ("but the layer was expecting " + params.length + " weights. ") +
                    ("Provided weights: " + weights + "..."));
            }
            if (params.length === 0) {
                return;
            }
            var weightValueTuples = [];
            var paramValues = variables_1.batchGetValue(params);
            for (var i = 0; i < paramValues.length; ++i) {
                var pv = paramValues[i];
                var p = params[i];
                var w = weights[i];
                if (!tfjs_core_1.util.arraysEqual(pv.shape, w.shape)) {
                    throw new errors_1.ValueError("Layer weight shape " + pv.shape + " " +
                        ("not compatible with provided weight shape " + w.shape));
                }
                weightValueTuples.push([p, w]);
            }
            variables_1.batchSetValue(weightValueTuples);
        });
    };
    Layer.prototype.addWeight = function (name, shape, dtype, initializer, regularizer, trainable, constraint) {
        if (this._addedWeightNames.indexOf(name) !== -1) {
            throw new errors_1.ValueError("Duplicate weight name " + name + " for layer " + this.name);
        }
        this._addedWeightNames.push(name);
        if (dtype == null) {
            dtype = K.floatx();
        }
        var weight = new variables_1.LayerVariable(initializer.apply(shape, dtype), dtype, name, trainable, constraint);
        if (regularizer != null) {
            this.addLoss(function () { return regularizer.apply(weight.read()); });
        }
        if (trainable == null) {
            trainable = true;
        }
        if (trainable) {
            this._trainableWeights.push(weight);
        }
        else {
            this._nonTrainableWeights.push(weight);
        }
        return weight;
    };
    Layer.prototype.addLoss = function (losses) {
        if (losses == null || Array.isArray(losses) && losses.length === 0) {
            return;
        }
        losses = generic_utils.toList(losses);
        if (this._losses !== undefined && this._losses !== null) {
            (_a = this.losses).push.apply(_a, losses);
        }
        var _a;
    };
    Layer.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    Layer.prototype.computeMask = function (inputs, mask) {
        var _this = this;
        if (!this.supportsMasking) {
            if (mask != null) {
                if (Array.isArray(mask)) {
                    mask.forEach(function (maskElement) {
                        if (maskElement != null) {
                            throw new TypeError("Layer " + _this.name + " does not support masking," +
                                'but was passed an inputMask.');
                        }
                    });
                }
                else {
                    throw new TypeError("Layer " + this.name + " does not support masking," +
                        'but was passed an inputMask.');
                }
            }
            return null;
        }
        return mask;
    };
    Layer.prototype.addInboundNode = function (inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs) {
        if (kwargs === void 0) { kwargs = null; }
        var inputTensorList = generic_utils.toList(inputTensors);
        outputTensors = generic_utils.toList(outputTensors);
        inputMasks = generic_utils.toList(inputMasks);
        outputMasks = generic_utils.toList(outputMasks);
        inputShapes = generic_utils.normalizeShapeList(inputShapes);
        outputShapes = generic_utils.normalizeShapeList(outputShapes);
        var inboundLayers = [];
        var nodeIndices = [];
        var tensorIndices = [];
        for (var _i = 0, inputTensorList_1 = inputTensorList; _i < inputTensorList_1.length; _i++) {
            var x = inputTensorList_1[_i];
            inboundLayers.push(x.sourceLayer);
            nodeIndices.push(x.nodeIndex);
            tensorIndices.push(x.tensorIndex);
        }
        new Node({
            outboundLayer: this,
            inboundLayers: inboundLayers,
            nodeIndices: nodeIndices,
            tensorIndices: tensorIndices,
            inputTensors: inputTensorList,
            outputTensors: outputTensors,
            inputMasks: inputMasks,
            outputMasks: outputMasks,
            inputShapes: inputShapes,
            outputShapes: outputShapes
        }, kwargs);
        for (var i = 0; i < outputTensors.length; i++) {
            outputTensors[i].sourceLayer = this;
            outputTensors[i].nodeIndex = this.inboundNodes.length - 1;
            outputTensors[i].tensorIndex = i;
        }
    };
    Layer.prototype.getConfig = function () {
        var config = { name: this.name, trainable: this.trainable };
        if (this.batchInputShape != null) {
            config['batchInputShape'] = this.batchInputShape;
        }
        if (this.dtype != null) {
            config['dtype'] = this.dtype;
        }
        return config;
    };
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', 'subheading': 'Classes' })
    ], Layer.prototype, "apply", null);
    Layer = __decorate([
        tfjs_core_1.doc({ heading: 'Layers', subheading: 'Classes', namespace: 'layers' })
    ], Layer);
    return Layer;
}(tfjs_core_1.serialization.Serializable));
exports.Layer = Layer;
function collectInputShape(inputTensors) {
    inputTensors =
        generic_utils.toList(inputTensors);
    var shapes = [];
    for (var _i = 0, inputTensors_1 = inputTensors; _i < inputTensors_1.length; _i++) {
        var x = inputTensors_1[_i];
        shapes.push(K.intShape(x));
    }
    return generic_utils.singletonOrArray(shapes);
}
function guessOutputDType(inputTensors) {
    return 'float32';
}
var InputLayer = (function (_super) {
    __extends(InputLayer, _super);
    function InputLayer(config) {
        var _this = _super.call(this, {
            dtype: config.dtype,
            name: config.name != null ? config.name : K.getUid('input').toString()
        }) || this;
        if (config.batchSize == null) {
            config.batchSize = null;
        }
        if (config.sparse == null) {
            config.sparse = false;
        }
        _this.trainable = false;
        _this.built = true;
        _this.sparse = config.sparse;
        if (config.inputShape != null && config.batchInputShape != null) {
            throw new errors_1.ValueError('Only provide the inputShape OR ' +
                'batchInputShape argument to inputLayer, not both at the same time.');
        }
        var batchInputShape = config.batchInputShape;
        if (batchInputShape == null) {
            if (config.inputShape == null) {
                throw new errors_1.ValueError('An InputLayer should be passed either a ' +
                    '`batchInputShape` or an `inputShape`.');
            }
            else {
                batchInputShape = [config.batchSize].concat(config.inputShape);
            }
        }
        else {
            if (config.batchSize != null) {
                throw new errors_1.ValueError('Cannot specify batchSize if batchInputShape is' +
                    'specified when creating an InputLayer.');
            }
        }
        var dtype = config.dtype || K.floatx();
        _this.batchInputShape = batchInputShape;
        _this.dtype = dtype;
        _this.inputSpec = [{ shape: batchInputShape }];
        var inputTensor = new types_1.SymbolicTensor(_this.dtype, _this.batchInputShape, _this, [], {}, _this.name);
        inputTensor.nodeIndex = 0;
        inputTensor.tensorIndex = 0;
        new Node({
            outboundLayer: _this,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: [inputTensor],
            outputTensors: [inputTensor],
            inputMasks: [null],
            outputMasks: [null],
            inputShapes: [batchInputShape],
            outputShapes: [batchInputShape]
        });
        return _this;
    }
    InputLayer.prototype.apply = function (inputs, kwargs) {
        throw new errors_1.ValueError('Cannot pass any input to an ' +
            ("InputLayer's apply() method. InputLayer name: " + this.name));
    };
    InputLayer.prototype.getConfig = function () {
        return {
            batchInputShape: this.batchInputShape,
            dtype: this.dtype,
            sparse: this.sparse,
            name: this.name
        };
    };
    InputLayer.className = 'InputLayer';
    return InputLayer;
}(Layer));
exports.InputLayer = InputLayer;
tfjs_core_1.serialization.SerializationMap.register(InputLayer);
function Input(config) {
    if (config.batchShape == null && config.shape == null) {
        throw new Error('Please provide to Input either a `shape`' +
            ' or a `batchShape` argument. Note that ' +
            '`shape` does not include the batch ' +
            'dimension.');
    }
    if (config.batchShape != null && config.shape != null) {
        throw new errors_1.ValueError('Please provide either a `shape` or `batchShape` ' +
            'argument to Input, but not both.');
    }
    var batchShape = config.batchShape;
    if (config.shape != null && batchShape == null) {
        batchShape = [null].concat(config.shape);
    }
    var dtype = config.dtype;
    if (dtype == null) {
        dtype = K.floatx();
    }
    var inputLayer = new InputLayer({
        batchInputShape: batchShape,
        name: config.name,
        dtype: dtype,
        sparse: config.sparse
    });
    var outputs = inputLayer.inboundNodes[0].outputTensors;
    return outputs[0];
}
exports.Input = Input;
var Container = (function (_super) {
    __extends(Container, _super);
    function Container(config) {
        var _this = _super.call(this, {}) || this;
        _this.containerNodes = new Set();
        _this.name = config.name;
        if (_this.name == null) {
            var prefix = _this.getClassName().toLowerCase();
            _this.name = K.getUid(prefix);
        }
        _this.supportsMasking = false;
        _this.trainable = true;
        _this.updatable = true;
        if (Array.isArray(config.inputs)) {
            _this.inputs = config.inputs.slice();
        }
        else {
            _this.inputs = [config.inputs];
        }
        if (Array.isArray(config.outputs)) {
            _this.outputs = config.outputs.slice();
        }
        else {
            _this.outputs = [config.outputs];
        }
        if (generic_utils.unique(_this.inputs).length !== _this.inputs.length) {
            throw new errors_1.ValueError('The list of inputs passed to the model is ' +
                'redundant. All inputs should only appear once. Found: ' +
                _this.inputs.map(function (x) { return x.name; }));
        }
        if (generic_utils.unique(_this.outputs).length !== _this.outputs.length) {
            console.warn('The list of outputs passed to the model is redundant. ' +
                'All outputs should only appear once. Found: ' +
                _this.outputs.map(function (x) { return x.name; }));
        }
        _this.inputLayers = [];
        _this.inputLayersNodeIndices = [];
        _this.inputLayersTensorIndices = [];
        _this.outputLayers = [];
        _this.outputLayersNodeIndices = [];
        _this.outputLayersTensorIndices = [];
        _this.layers = [];
        for (var _i = 0, _a = _this.outputs; _i < _a.length; _i++) {
            var x = _a[_i];
            var layer = x.sourceLayer;
            var nodeIndex = x.nodeIndex;
            var tensorIndex = x.tensorIndex;
            _this.outputLayers.push(layer);
            _this.outputLayersNodeIndices.push(nodeIndex);
            _this.outputLayersTensorIndices.push(tensorIndex);
        }
        for (var _b = 0, _c = _this.inputs; _b < _c.length; _b++) {
            var x = _c[_b];
            var layer = x.sourceLayer;
            var nodeIndex = x.nodeIndex;
            var tensorIndex = x.tensorIndex;
            generic_utils.assert(nodeIndex === 0, 'input layer has >1 nodes');
            generic_utils.assert(tensorIndex === 0, 'input layer has >1 tensors');
            _this.inputLayers.push(layer);
            _this.inputLayersNodeIndices.push(nodeIndex);
            _this.inputLayersTensorIndices.push(tensorIndex);
        }
        _this.inputNames = [];
        _this.outputNames = [];
        _this.feedInputShapes = [];
        _this.feedInputNames = [];
        _this.feedOutputNames = [];
        for (var i = 0; i < _this.inputLayers.length; i++) {
            var layer = _this.inputLayers[i];
            if (!(layer instanceof InputLayer)) {
                throw new TypeError('Input layers to a Model must be InputLayer objects. ' +
                    ("Received inputs: " + config.inputs + ". ") +
                    ("Input " + i + " (0-based) originates ") +
                    ("from layer type " + layer.getClassName() + "."));
            }
            _this.inputNames.push(layer.name);
            _this.feedInputShapes.push(layer.batchInputShape);
            _this.feedInputNames.push(layer.name);
        }
        for (var _d = 0, _e = _this.outputLayers; _d < _e.length; _d++) {
            var layer = _e[_d];
            _this.outputNames.push(layer.name);
        }
        _this.internalInputShapes = _this.inputs.map(function (x) { return x.shape; });
        _this.internalOutputShapes = _this.outputs.map(function (x) { return x.shape; });
        var nodesDepths = {};
        var nodeIDToNode = {};
        var layersDepths = {};
        var layerIDToLayer = {};
        var layerIndices = {};
        var nodesInDecreasingDepth = [];
        var buildMapOfGraph = function (tensor, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex) {
            if (layer == null || nodeIndex == null || tensorIndex == null) {
                layer = tensor.sourceLayer;
                nodeIndex = tensor.nodeIndex;
                tensorIndex = tensor.tensorIndex;
            }
            var node = layer.inboundNodes[nodeIndex];
            if (nodesInProgress.indexOf(node) !== -1) {
                throw new errors_1.RuntimeError("The tensor " + tensor.name + " at layer \"" + layer.name + "\" " +
                    'is part of a cycle.');
            }
            if (finishedNodes.indexOf(node) !== -1) {
                return;
            }
            _this.containerNodes.add(Container.nodeKey(layer, nodeIndex));
            if (!(layer.id in layerIndices)) {
                layerIndices[layer.id] = Object.keys(layerIndices).length;
            }
            if (nodesInProgress.indexOf(node) === -1) {
                nodesInProgress.push(node);
            }
            var numInboundLayers = node.inboundLayers.length;
            for (var i = 0; i < numInboundLayers; i++) {
                var x = node.inputTensors[i];
                var layer_1 = node.inboundLayers[i];
                var nodeIndex_1 = node.nodeIndices[i];
                var tensorIndex_1 = node.tensorIndices[i];
                buildMapOfGraph(x, finishedNodes, nodesInProgress, layer_1, nodeIndex_1, tensorIndex_1);
            }
            finishedNodes.push(node);
            while (nodesInProgress.indexOf(node) >= 0) {
                nodesInProgress.splice(nodesInProgress.indexOf(node), 1);
            }
            nodesInDecreasingDepth.push(node);
        };
        var finishedNodes = [];
        var nodesInProgress = [];
        for (var _f = 0, _g = _this.outputs; _f < _g.length; _f++) {
            var x = _g[_f];
            buildMapOfGraph(x, finishedNodes, nodesInProgress);
        }
        var reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();
        for (var _h = 0, reversedNodesInDecreasingDepth_1 = reversedNodesInDecreasingDepth; _h < reversedNodesInDecreasingDepth_1.length; _h++) {
            var node = reversedNodesInDecreasingDepth_1[_h];
            nodeIDToNode[node.id] = node;
            if (!(node.id in nodesDepths)) {
                nodesDepths[node.id] = 0;
            }
            var depth = nodesDepths[node.id];
            var previousDepth = (layersDepths[node.outboundLayer.id] == null ?
                0 :
                layersDepths[node.outboundLayer.id]);
            depth = Math.max(depth, previousDepth);
            layersDepths[node.outboundLayer.id] = depth;
            layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;
            nodesDepths[node.id] = depth;
            for (var i = 0; i < node.inboundLayers.length; i++) {
                var inboundLayer = node.inboundLayers[i];
                var nodeIndex = node.nodeIndices[i];
                var inboundNode = inboundLayer.inboundNodes[nodeIndex];
                var previousDepth_1 = (nodesDepths[inboundNode.id] == null ? 0 :
                    nodesDepths[inboundNode.id]);
                nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth_1);
                nodeIDToNode[inboundNode.id] = inboundNode;
            }
        }
        var nodesByDepth = {};
        for (var nodeID in nodesDepths) {
            var depth = nodesDepths[nodeID];
            if (!(depth in nodesByDepth)) {
                nodesByDepth[depth] = [];
            }
            nodesByDepth[depth].push(nodeIDToNode[nodeID]);
        }
        var layersByDepth = {};
        for (var layerID in layersDepths) {
            var depth = layersDepths[layerID];
            if (!(depth in layersByDepth)) {
                layersByDepth[depth] = [];
            }
            layersByDepth[depth].push(layerIDToLayer[layerID]);
        }
        var depthKeys = Object.keys(layersByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        _this.layers = [];
        for (var _j = 0, depthKeys_1 = depthKeys; _j < depthKeys_1.length; _j++) {
            var depth = depthKeys_1[_j];
            var layersForDepth = layersByDepth[depth];
            layersForDepth.sort(function (a, b) {
                var aIndex = layerIndices[a.id];
                var bIndex = layerIndices[b.id];
                if (aIndex < bIndex) {
                    return -1;
                }
                if (aIndex > bIndex) {
                    return 1;
                }
                return 0;
            });
            for (var _k = 0, layersForDepth_1 = layersForDepth; _k < layersForDepth_1.length; _k++) {
                var layer = layersForDepth_1[_k];
                _this.layers.push(layer);
            }
        }
        _this.layersByDepth = layersByDepth;
        depthKeys = Object.keys(nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        var computableTensors = _this.inputs.slice();
        var layersWithCompleteInput = [];
        for (var _l = 0, depthKeys_2 = depthKeys; _l < depthKeys_2.length; _l++) {
            var depth = depthKeys_2[_l];
            for (var _m = 0, _o = nodesByDepth[depth]; _m < _o.length; _m++) {
                var node = _o[_m];
                var layer = node.outboundLayer;
                if (layer != null) {
                    for (var _p = 0, _q = node.inputTensors; _p < _q.length; _p++) {
                        var x = _q[_p];
                        if (computableTensors.indexOf(x) === -1) {
                            throw new errors_1.RuntimeError("Graph disconnected: cannot obtain value for tensor " + x +
                                (" at layer \"" + layer.name + "\". ") +
                                'The following previous layers were accessed without ' +
                                ("issue: " + layersWithCompleteInput));
                        }
                    }
                    for (var _r = 0, _s = node.outputTensors; _r < _s.length; _r++) {
                        var x = _s[_r];
                        computableTensors.push(x);
                    }
                    layersWithCompleteInput.push(layer.name);
                }
            }
        }
        _this.nodesByDepth = nodesByDepth;
        var allNames = _this.layers.map(function (x) { return x.name; });
        var _loop_1 = function (name_1) {
            var numOccurrences = allNames.filter(function (x) { return x === name_1; }).length;
            if (numOccurrences !== 1) {
                throw new errors_1.RuntimeError("The name \"" + name_1 + "\" is used " + numOccurrences + " times " +
                    'in the model. All layer names should be unique. Layer names: ' +
                    JSON.stringify(allNames));
            }
        };
        for (var _t = 0, allNames_1 = allNames; _t < allNames_1.length; _t++) {
            var name_1 = allNames_1[_t];
            _loop_1(name_1);
        }
        _this.outboundNodes = [];
        _this.inboundNodes = [];
        new Node({
            outboundLayer: _this,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: _this.inputs,
            outputTensors: _this.outputs,
            inputMasks: _this.inputs.map(function (x) { return null; }),
            outputMasks: _this.outputs.map(function (x) { return null; }),
            inputShapes: _this.inputs.map(function (x) { return x.shape; }),
            outputShapes: _this.outputs.map(function (x) { return x.shape; })
        });
        _this.built = true;
        return _this;
    }
    Object.defineProperty(Container.prototype, "trainableWeights", {
        get: function () {
            if (this._trainableWeights.length > 0) {
                throw new errors_1.ValueError('Container instance unexpectedly contains _trainableWeights.' +
                    'The trainable weights of a Container are a union of the ' +
                    'trainable weights of its consituent Layers. Its own ' +
                    '_trainableWeights must remain an empty Array.');
            }
            if (!this.trainable) {
                return [];
            }
            var weights = [];
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                weights = weights.concat(layer.trainableWeights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "nonTrainableWeights", {
        get: function () {
            var weights = [];
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                weights.push.apply(weights, layer.nonTrainableWeights);
            }
            if (!this.trainable) {
                var trainableWeights = [];
                for (var _b = 0, _c = this.layers; _b < _c.length; _b++) {
                    var layer = _c[_b];
                    trainableWeights.push.apply(trainableWeights, layer.trainableWeights);
                }
                return trainableWeights.concat(weights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "weights", {
        get: function () {
            return this.trainableWeights.concat(this.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Container.prototype.loadWeights = function (weightsJSON, skipMismatch, isNamedTensorMap) {
        if (skipMismatch === void 0) { skipMismatch = false; }
        if (isNamedTensorMap === void 0) { isNamedTensorMap = false; }
        if (isNamedTensorMap) {
            loadWeightsFromNamedTensorMap(weightsJSON, this.layers);
        }
        else {
            loadWeightsFromJson(weightsJSON, this.layers, skipMismatch);
        }
    };
    Container.prototype.updatedConfig = function () {
        var theConfig = this.getConfig();
        var modelConfig = {
            className: this.getClassName(),
            config: theConfig,
            kerasVersion: "tfjs-layers " + version_1.version,
            backend: 'TensorFlow.js'
        };
        return modelConfig;
    };
    Container.prototype.toJSON = function (unused, returnString) {
        if (returnString === void 0) { returnString = true; }
        var modelConfig = serialization_utils_1.convertTsToPythonic(this.updatedConfig());
        return returnString ? JSON.stringify(modelConfig) : modelConfig;
    };
    Container.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.toList(inputs);
            var masks;
            if ('mask' in kwargs) {
                masks = generic_utils.toList(kwargs['mask']);
            }
            else {
                masks = generic_utils.pyListRepeat(null, inputs.length);
            }
            return _this.runInternalGraph(inputs, masks)[0];
        });
    };
    Container.prototype.computeMask = function (inputs, mask) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.toList(inputs);
            var masks;
            if (mask == null) {
                masks = generic_utils.pyListRepeat(null, inputs.length);
            }
            else {
                masks = generic_utils.toList(mask);
            }
            return _this.runInternalGraph(inputs, masks)[1];
        });
    };
    Container.prototype.computeOutputShape = function (inputShape) {
        var inputShapes = generic_utils.normalizeShapeList(inputShape);
        if (inputShapes.length !== this.inputLayers.length) {
            throw new errors_1.ValueError("Invalid inputShape argument " + inputShape + ": " +
                ("model has " + this.inputLayers.length + " tensor inputs."));
        }
        var layersToOutputShapes = {};
        for (var i = 0; i < inputShapes.length; i++) {
            var layer = this.inputLayers[i];
            var inputShape_1 = inputShapes[i];
            var shapeKey = layer.name + '_0_0';
            layersToOutputShapes[shapeKey] = inputShape_1;
        }
        var depthKeys = Object.keys(this.nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        if (depthKeys.length > 1) {
            for (var _i = 0, depthKeys_3 = depthKeys; _i < depthKeys_3.length; _i++) {
                var depth = depthKeys_3[_i];
                var nodes = this.nodesByDepth[depth];
                for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
                    var node = nodes_1[_a];
                    var layer = node.outboundLayer;
                    if (this.inputLayers.map(function (x) { return x.id; }).indexOf(layer.id) !== -1) {
                        continue;
                    }
                    var inputShapes_1 = [];
                    for (var j = 0; j < node.inboundLayers.length; j++) {
                        var inboundLayer = node.inboundLayers[j];
                        var nodeIndex_2 = node.nodeIndices[j];
                        var tensorIndex = node.tensorIndices[j];
                        var shapeKey = inboundLayer.name + "_" + nodeIndex_2 + "_" + tensorIndex;
                        var inputShape_2 = layersToOutputShapes[shapeKey];
                        inputShapes_1.push(inputShape_2);
                    }
                    var outputShape = layer.computeOutputShape(generic_utils.singletonOrArray(inputShapes_1));
                    var outputShapes_1 = generic_utils.normalizeShapeList(outputShape);
                    var nodeIndex = layer.inboundNodes.indexOf(node);
                    for (var j = 0; j < outputShapes_1.length; j++) {
                        var shapeKey = layer.name + "_" + nodeIndex + "_" + j;
                        layersToOutputShapes[shapeKey] = outputShapes_1[j];
                    }
                }
            }
        }
        var outputShapes = [];
        var outputShapeKeys = [];
        for (var i = 0; i < this.outputLayers.length; i++) {
            var layer = this.outputLayers[i];
            var nodeIndex = this.outputLayersNodeIndices[i];
            var tensorIndex = this.outputLayersTensorIndices[i];
            var shapeKey = layer.name + "_" + nodeIndex + "_" + tensorIndex;
            outputShapeKeys.push(shapeKey);
        }
        for (var i = 0; i < outputShapeKeys.length; i++) {
            var key = outputShapeKeys[i];
            generic_utils.assert(key in layersToOutputShapes);
            outputShapes.push(layersToOutputShapes[key]);
        }
        return generic_utils.singletonOrArray(outputShapes);
    };
    Container.prototype.runInternalGraph = function (inputs, masks) {
        if (masks == null) {
            masks = generic_utils.pyListRepeat(null, inputs.length);
        }
        var tensorMap = {};
        for (var i = 0; i < this.inputs.length; ++i) {
            var x = this.inputs[i];
            var y = inputs[i];
            var mask = masks[i];
            tensorMap[x.id] = [y, mask];
        }
        var depthKeys = Object.keys(this.nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        for (var _i = 0, depthKeys_4 = depthKeys; _i < depthKeys_4.length; _i++) {
            var depth = depthKeys_4[_i];
            var nodes = this.nodesByDepth[depth];
            for (var _a = 0, nodes_2 = nodes; _a < nodes_2.length; _a++) {
                var node = nodes_2[_a];
                var layer = node.outboundLayer;
                var referenceInputTensors = node.inputTensors;
                var referenceOutputTensors = node.outputTensors;
                var computedData = new Array();
                for (var _b = 0, referenceInputTensors_1 = referenceInputTensors; _b < referenceInputTensors_1.length; _b++) {
                    var x = referenceInputTensors_1[_b];
                    if (x.id in tensorMap) {
                        computedData.push(tensorMap[x.id]);
                    }
                }
                if (computedData.length === referenceInputTensors.length) {
                    var kwargs = {};
                    var computedTensors = void 0;
                    var computedMasks = void 0;
                    var outputTensors_1 = void 0;
                    var outputMasks_1 = void 0;
                    if (node.callArgs != null) {
                        kwargs = node.callArgs;
                    }
                    if (computedData.length === 1) {
                        var _c = computedData[0], computedTensor = _c[0], computedMask = _c[1];
                        if (kwargs.mask == null) {
                            kwargs['mask'] = computedMask;
                        }
                        outputTensors_1 =
                            generic_utils.toList(layer.call(computedTensor, kwargs));
                        outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensor, computedMask));
                        computedTensors = [computedTensor];
                        computedMasks = [computedMask];
                    }
                    else {
                        computedTensors = computedData.map(function (x) { return x[0]; });
                        computedMasks = computedData.map(function (x) { return x[1]; });
                        if (kwargs.mask == null) {
                            kwargs['mask'] = computedMasks;
                        }
                        outputTensors_1 =
                            generic_utils.toList(layer.call(computedTensors, kwargs));
                        outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensors, computedMasks));
                    }
                    if (layer.activityRegularizer) {
                        throw new errors_1.NotImplementedError('Model invocation with concrete Tensor value(s) in the ' +
                            'presence of activity regularizer(s) is not supported yet.');
                    }
                    for (var i = 0; i < referenceOutputTensors.length; ++i) {
                        var x = referenceOutputTensors[i];
                        var y = outputTensors_1[i];
                        var mask = outputMasks_1[i];
                        tensorMap[x.id] = [y, mask];
                    }
                }
            }
        }
        var outputTensors = [];
        var outputMasks = [];
        var outputShapes = [];
        for (var _d = 0, _e = this.outputs; _d < _e.length; _d++) {
            var x = _e[_d];
            generic_utils.assert(x.id in tensorMap, "Could not compute output " + x.name + " : " + x.id);
            var _f = tensorMap[x.id], tensor = _f[0], mask = _f[1];
            outputShapes.push(tensor.shape);
            outputTensors.push(tensor);
            outputMasks.push(mask);
        }
        return [outputTensors, outputMasks, outputShapes];
    };
    Container.prototype.buildNodeConversionMap = function (layers) {
        var nodeConversionMap = {};
        var keptNodes;
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            keptNodes = layer instanceof Container ? 1 : 0;
            for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
                var nodeKey = Container.nodeKey(layer, originalNodeIndex);
                if (nodeKey in this.containerNodes) {
                    nodeConversionMap[nodeKey] = keptNodes;
                    keptNodes += 1;
                }
            }
        }
        return nodeConversionMap;
    };
    Container.prototype.getLayer = function (name, index) {
        if (index != null) {
            if (this.layers.length <= index) {
                throw new errors_1.ValueError("Was asked to retrieve layer at index " + index + ", but model only " +
                    ("has " + this.layers.length + " layer(s)."));
            }
            else {
                return this.layers[index];
            }
        }
        else {
            if (name == null) {
                throw new errors_1.ValueError('Provide either a layer name or layer index');
            }
        }
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer.name === name) {
                return layer;
            }
        }
        throw new errors_1.ValueError("No such layer: " + name);
    };
    Container.prototype.calculateLosses = function () {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var losses = [];
            for (var _i = 0, _a = _this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                for (var nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {
                    var nodeKey = Container.nodeKey(layer, nodeIndex);
                    if (_this.containerNodes.has(nodeKey)) {
                        losses.push.apply(losses, layer.calculateLosses());
                    }
                }
            }
            return losses;
        });
    };
    Container.prototype.getConfig = function () {
        var config = { name: this.name };
        var nodeConversionMap = this.buildNodeConversionMap(this.layers);
        var layerConfigs = [];
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            var layerClassName = layer.getClassName();
            var layerConfig = layer.getConfig();
            var filteredInboundNodes = [];
            for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
                var node = layer.inboundNodes[originalNodeIndex];
                var nodeKey = Container.nodeKey(layer, originalNodeIndex);
                var kwargs = {};
                if (this.containerNodes.has(nodeKey)) {
                    if (node.callArgs) {
                        var testString = JSON.stringify(node.callArgs);
                        if (testString.indexOf('undefined') === -1) {
                            kwargs = node.callArgs;
                        }
                        else {
                            console.warn("Layer " + layer.name + " was passed " +
                                "non-serializable keyword arguments: " +
                                (node.callArgs + ". They will not be included ") +
                                "in the serialized model (and thus will be " +
                                "missing at deserialization time).");
                            kwargs = {};
                        }
                    }
                    if (node.inboundLayers.length > 0) {
                        var nodeData = [];
                        for (var i = 0; i < node.inboundLayers.length; i++) {
                            var inboundLayer = node.inboundLayers[i];
                            var nodeIndex = node.nodeIndices[i];
                            var tensorIndex = node.tensorIndices[i];
                            var nodeKey_1 = Container.nodeKey(inboundLayer, nodeIndex);
                            var newNodeIndex = nodeConversionMap[nodeKey_1];
                            if (newNodeIndex === null || newNodeIndex === undefined) {
                                newNodeIndex = 0;
                            }
                            nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);
                        }
                        filteredInboundNodes.push(nodeData);
                    }
                }
            }
            layerConfigs.push({
                name: layer.name,
                className: layerClassName,
                config: layerConfig,
                inboundNodes: filteredInboundNodes
            });
        }
        config['layers'] = layerConfigs;
        var modelInputs = [];
        for (var i = 0; i < this.inputLayers.length; i++) {
            var layer = this.inputLayers[i];
            var nodeIndex = this.inputLayersNodeIndices[i];
            var nodeKey = Container.nodeKey(layer, nodeIndex);
            if (!this.containerNodes.has(nodeKey)) {
                continue;
            }
            var newNodeIndex = nodeConversionMap[nodeKey];
            if (newNodeIndex === null || newNodeIndex === undefined) {
                newNodeIndex = 0;
            }
            var tensorIndex = this.inputLayersTensorIndices[i];
            modelInputs.push([layer.name, newNodeIndex, tensorIndex]);
        }
        config['inputLayers'] = modelInputs;
        var modelOutputs = [];
        for (var i = 0; i < this.outputLayers.length; i++) {
            var layer = this.outputLayers[i];
            var nodeIndex = this.outputLayersNodeIndices[i];
            var nodeKey = Container.nodeKey(layer, nodeIndex);
            if (!this.containerNodes.has(nodeKey)) {
                continue;
            }
            var newNodeIndex = nodeConversionMap[nodeKey];
            if (newNodeIndex === null || newNodeIndex === undefined) {
                newNodeIndex = 0;
            }
            var tensorIndex = this.outputLayersTensorIndices[i];
            modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);
        }
        config['outputLayers'] = modelOutputs;
        return config;
    };
    Container.fromConfig = function (cls, config) {
        var createdLayers = {};
        var unprocessedNodes = {};
        function addUnprocessedNode(layer, nodeData) {
            if (!(layer.name in unprocessedNodes)) {
                unprocessedNodes[layer.name] = [nodeData];
            }
            else {
                unprocessedNodes[layer.name].push(nodeData);
            }
        }
        function processNode(layer, nodeData) {
            var inputTensors = [];
            var kwargs;
            for (var _i = 0, nodeData_1 = nodeData; _i < nodeData_1.length; _i++) {
                var inputData = nodeData_1[_i];
                var inboundLayerName = inputData[0];
                var inboundNodeIndex = inputData[1];
                var inboundTensorIndex = inputData[2];
                if (inputData.length === 3) {
                    kwargs = {};
                }
                else if (inputData.length === 4) {
                    kwargs = inputData[3];
                }
                else {
                    throw new errors_1.ValueError("Improperly formatted model config for layer " + JSON.stringify(layer) + ": " + JSON.stringify(inputData));
                }
                if (!(inboundLayerName in createdLayers)) {
                    addUnprocessedNode(layer, nodeData);
                    return;
                }
                var inboundLayer = createdLayers[inboundLayerName];
                if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {
                    addUnprocessedNode(layer, nodeData);
                    return;
                }
                var inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];
                inputTensors.push(inboundNode.outputTensors[inboundTensorIndex]);
            }
            if (inputTensors.length > 0) {
                layer.apply(generic_utils.singletonOrArray(inputTensors), kwargs);
            }
        }
        function processLayer(layerData) {
            var layerName = layerData.name;
            var layer = serialization_1.deserialize(layerData, config.customObjects != null ?
                config.customObjects :
                {});
            createdLayers[layerName] = layer;
            var inboundNodesData = layerData.inboundNodes;
            for (var _i = 0, inboundNodesData_1 = inboundNodesData; _i < inboundNodesData_1.length; _i++) {
                var nodeData = inboundNodesData_1[_i];
                if (!(nodeData instanceof Array)) {
                    throw new errors_1.ValueError("Corrupted configuration, expected array for nodeData: " + nodeData);
                }
                addUnprocessedNode(layer, nodeData);
            }
        }
        var name = config.name;
        var layersFromConfig = config.layers;
        for (var _i = 0, layersFromConfig_1 = layersFromConfig; _i < layersFromConfig_1.length; _i++) {
            var layerData = layersFromConfig_1[_i];
            processLayer(layerData);
        }
        while (!generic_utils.isObjectEmpty(unprocessedNodes)) {
            for (var _a = 0, layersFromConfig_2 = layersFromConfig; _a < layersFromConfig_2.length; _a++) {
                var layerData = layersFromConfig_2[_a];
                var layer = createdLayers[layerData.name];
                if (layer.name in unprocessedNodes) {
                    for (var _b = 0, _c = unprocessedNodes[layer.name]; _b < _c.length; _b++) {
                        var nodeData = _c[_b];
                        processNode(layer, nodeData);
                    }
                    delete unprocessedNodes[layer.name];
                }
            }
        }
        var inputTensors = [];
        var outputTensors = [];
        var inputLayersFromConfig = config.inputLayers;
        for (var _d = 0, inputLayersFromConfig_1 = inputLayersFromConfig; _d < inputLayersFromConfig_1.length; _d++) {
            var layerData = inputLayersFromConfig_1[_d];
            var layerName = layerData[0];
            var nodeIndex = layerData[1];
            var tensorIndex = layerData[2];
            generic_utils.assert(layerName in createdLayers);
            var layer = createdLayers[layerName];
            var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
            inputTensors.push(layerOutputTensors[tensorIndex]);
        }
        var outputLayersFromConfig = config.outputLayers;
        for (var _e = 0, outputLayersFromConfig_1 = outputLayersFromConfig; _e < outputLayersFromConfig_1.length; _e++) {
            var layerData = outputLayersFromConfig_1[_e];
            var layerName = layerData[0];
            var nodeIndex = layerData[1];
            var tensorIndex = layerData[2];
            generic_utils.assert(layerName in createdLayers);
            var layer = createdLayers[layerName];
            var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
            outputTensors.push(layerOutputTensors[tensorIndex]);
        }
        return new cls({ inputs: inputTensors, outputs: outputTensors, name: name });
    };
    Object.defineProperty(Container.prototype, "stateful", {
        get: function () {
            if (this._stateful) {
                throw new errors_1.ValueError('Container instance unexpectedly has _stateful = true. The ' +
                    'statefulness of a Container is determined by the Layers it ' +
                    'contains. Its _stateful property must remain the default false.');
            }
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                if (layer.stateful) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Classes',
            namespace: 'layers',
            subclasses: ['Model']
        })
    ], Container.prototype, "getLayer", null);
    return Container;
}(Layer));
exports.Container = Container;
function getSourceInputs(tensor, layer, nodeIndex) {
    if (layer == null || (nodeIndex != null && nodeIndex > 0)) {
        layer = tensor.sourceLayer;
        nodeIndex = tensor.nodeIndex;
    }
    if (layer.inboundNodes.length === 0) {
        return [tensor];
    }
    else {
        var node = layer.inboundNodes[nodeIndex];
        if (node.inboundLayers.length === 0) {
            return node.inputTensors;
        }
        else {
            var sourceTensors = [];
            for (var i = 0; i < node.inboundLayers.length; i++) {
                var x = node.inputTensors[i];
                var layer_2 = node.inboundLayers[i];
                var nodeIndex_3 = node.nodeIndices[i];
                var previousSources = getSourceInputs(x, layer_2, nodeIndex_3);
                for (var _i = 0, previousSources_1 = previousSources; _i < previousSources_1.length; _i++) {
                    var x_1 = previousSources_1[_i];
                    if (sourceTensors.indexOf(x_1) === -1) {
                        sourceTensors.push(x_1);
                    }
                }
            }
            return sourceTensors;
        }
    }
}
exports.getSourceInputs = getSourceInputs;
function loadTensor(dtype, shape, value) {
    var dataType = generic_utils.stringToDType(dtype);
    return tfjs_core_1.Tensor.make(shape, { values: shape.length === 0 ? value : tfjs_core_1.util.flatten(value) }, dataType);
}
function preprocessWeightsForLoading(layer, weights, originalKerasVersion, originalBackend) {
    if (!originalKerasVersion.startsWith('2.')) {
        throw new errors_1.ValueError('Unsupported Keras version in weights being loaded: ' +
            originalKerasVersion);
    }
    return weights;
}
function loadWeightsFromNamedTensorMap(weights, layers) {
    var nameToWeight = {};
    var totalWeightsCount = 0;
    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
        var layer = layers_1[_i];
        for (var _a = 0, _b = layer.weights; _a < _b.length; _a++) {
            var weight = _b[_a];
            if (nameToWeight[weight.originalName] != null) {
                throw new errors_1.ValueError("Duplicate weight name: " + weight.originalName);
            }
            nameToWeight[weight.originalName] = weight;
            totalWeightsCount++;
        }
    }
    var weightValueTuples = [];
    for (var name_2 in weights) {
        weightValueTuples.push([nameToWeight[name_2], weights[name_2]]);
        delete nameToWeight[name_2];
    }
    var unsetNames = [];
    for (var name_3 in nameToWeight) {
        unsetNames.push(name_3);
    }
    if (unsetNames.length > 0) {
        throw new errors_1.ValueError(unsetNames.length + " of " + totalWeightsCount + " weights are not set: " +
            ("" + unsetNames));
    }
    variables_1.batchSetValue(weightValueTuples);
}
exports.loadWeightsFromNamedTensorMap = loadWeightsFromNamedTensorMap;
function loadWeightsFromJson(weightsJSON, layers, skipMismatch) {
    if (skipMismatch === void 0) { skipMismatch = false; }
    var originalKerasVersion = weightsJSON['keras_version'];
    var originalBackend = weightsJSON['backend'];
    var layerNames = layers.map(function (layer) { return layer.name; });
    var index = {};
    for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {
        var layer = layers_2[_i];
        if (layer.name != null) {
            if (index[layer.name] == null) {
                index[layer.name] = [];
            }
            index[layer.name].push(layer);
        }
    }
    var nameToWeights = weightsJSON['weights'];
    var weightValueTuples = [];
    for (var k = 0; k < layerNames.length; ++k) {
        var name_4 = layerNames[k];
        var layerWeights = nameToWeights[name_4];
        if (layerWeights == null) {
            layerWeights = [];
        }
        var weightValues = [];
        for (var n = 0; n < layerWeights.length; ++n) {
            var weightEntry = layerWeights[n];
            weightValues.push(new variables_1.LayerVariable(loadTensor(weightEntry['dtype'], weightEntry['shape'], weightEntry['value'])));
        }
        for (var _a = 0, _b = index[name_4]; _a < _b.length; _a++) {
            var layer = _b[_a];
            var symbolicWeights = layer.weights;
            weightValues = preprocessWeightsForLoading(layer, weightValues, originalKerasVersion, originalBackend);
            if (weightValues.length !== symbolicWeights.length) {
                if (skipMismatch) {
                    console.warn("Skipping loading of weights of layer " + layer.name + " " +
                        ("due to mismatch in number of weights: (" + weightValues.length + " ") +
                        ("vs " + symbolicWeights.length + ")."));
                }
                else {
                    throw new errors_1.ValueError("Layer #" + k + " (named \"" + layer.name + "\") expects " +
                        (symbolicWeights.length + " weight(s), but the saved weights ") +
                        ("have " + weightValues.length + " element(s)."));
                }
            }
            for (var i = 0; i < weightValues.length; ++i) {
                if (skipMismatch) {
                    if (!tfjs_core_1.util.arraysEqual(symbolicWeights[i].shape, weightValues[i].shape)) {
                        console.warn("Skipping loading of weights for layer " + layer.name + " due " +
                            ("to mismatch in shape (" + symbolicWeights[i].shape + " vs ") +
                            (weightValues[i].shape + ")"));
                        continue;
                    }
                }
                weightValueTuples.push([symbolicWeights[i], weightValues[i].read()]);
            }
        }
    }
    variables_1.batchSetValue(weightValueTuples);
}
exports.loadWeightsFromJson = loadWeightsFromJson;

},{"../backend/tfjs_backend":160,"../errors":167,"../layers/serialization":181,"../types":188,"../utils/generic_utils":190,"../utils/serialization_utils":192,"../variables":193,"../version":194,"@tensorflow/tfjs-core":51}],166:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var callbacks_1 = require("../callbacks");
var errors_1 = require("../errors");
var losses = require("../losses");
var Metrics = require("../metrics");
var optimizers = require("../optimizers");
var generic_utils_1 = require("../utils/generic_utils");
var math_utils_1 = require("../utils/math_utils");
var executor_1 = require("./executor");
var topology_1 = require("./topology");
function isDataTensor(x) {
    return x instanceof tfjs_core_1.Tensor;
}
exports.isDataTensor = isDataTensor;
function isDataArray(x) {
    return Array.isArray(x);
}
exports.isDataArray = isDataArray;
function isDataDict(x) {
    return !isDataTensor(x) && !isDataArray(x);
}
exports.isDataDict = isDataDict;
function standardizeInputData(data, names, shapes, checkBatchAxis, exceptionPrefix) {
    if (checkBatchAxis === void 0) { checkBatchAxis = true; }
    if (exceptionPrefix === void 0) { exceptionPrefix = ''; }
    if (names == null || names.length === 0) {
        if (data != null) {
            var gotUnexpectedData = false;
            if (isDataArray(data) && data.length > 0) {
                gotUnexpectedData = true;
            }
            else if (isDataDict(data)) {
                for (var key in data) {
                    if (data.hasOwnProperty(key)) {
                        gotUnexpectedData = true;
                        break;
                    }
                }
            }
            else {
                gotUnexpectedData = true;
            }
            if (gotUnexpectedData) {
                throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + " expected no data, " +
                    ("but got " + data));
            }
        }
        return [];
    }
    if (data == null) {
        return names.map(function (name) { return null; });
    }
    var arrays;
    if (isDataDict(data)) {
        data = data;
        arrays = [];
        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
            var name_1 = names_1[_i];
            if (data[name_1] == null) {
                throw new errors_1.ValueError("No data provided for \"" + name_1 + "\". Need data for each key in: " +
                    ("" + names));
            }
            arrays.push(data[name_1]);
        }
    }
    else if (isDataArray(data)) {
        data = data;
        if (data.length !== names.length) {
            throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + ": the Array of " +
                "Tensors that you are passing to your model is not the size the " +
                ("model expected. Expected to see " + names.length + " Tensor(s), but ") +
                ("instead got the following list of Tensor(s): " + data));
        }
        arrays = data;
    }
    else {
        data = data;
        if (names.length > 1) {
            throw new errors_1.ValueError("The model " + exceptionPrefix + " expects " + names.length + " Tensor(s), " +
                ("but only received one Tensor. Found: Tensor with shape " + data.shape));
        }
        arrays = [data];
    }
    for (var i = 0; i < names.length; ++i) {
        var array = arrays[i];
        if (array.shape.length === 1) {
            arrays[i] = K.expandDims(array, 1);
        }
    }
    if (shapes != null) {
        for (var i = 0; i < names.length; ++i) {
            if (shapes[i] == null) {
                continue;
            }
            var array = arrays[i];
            if (array.shape.length !== shapes[i].length) {
                throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                    ("to have " + shapes[i].length + " dimension(s). but got array with ") +
                    ("shape " + array.shape));
            }
            for (var j = 0; j < shapes[i].length; ++j) {
                if (j === 0 && !checkBatchAxis) {
                    continue;
                }
                var dim = array.shape[j];
                var refDim = shapes[i][j];
                if (refDim != null && refDim >= 0 && dim !== refDim) {
                    throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                        ("to have shape [" + shapes[i] + "], but got array with shape ") +
                        ("[" + array.shape + "]."));
                }
            }
        }
    }
    return arrays;
}
exports.standardizeInputData = standardizeInputData;
function checkArrayLengths(inputs, targets, weights) {
    var setX = generic_utils_1.unique(inputs.map(function (input) { return input.shape[0]; }));
    setX.sort();
    var setY = generic_utils_1.unique(targets.map(function (target) { return target.shape[0]; }));
    setY.sort();
    if (setX.length > 1) {
        throw new errors_1.ValueError("All input Tensors (x) should have the same number of samples. " +
            "Got array shapes: " +
            ("" + JSON.stringify(inputs.map(function (input) { return input.shape; }))));
    }
    if (setY.length > 1) {
        throw new errors_1.ValueError("All target Tensors (y) should have the same number of samples. " +
            "Got array shapes: " +
            ("" + JSON.stringify(targets.map(function (target) { return target.shape; }))));
    }
    if (setX.length > 0 && setY.length > 0 && !tfjs_core_1.util.arraysEqual(setX, setY)) {
        throw new errors_1.ValueError("Input Tensors should have the same number of samples as target " +
            ("Tensors. Found " + setX[0] + " input sample(s) and " + setY[0] + " target ") +
            "sample(s).");
    }
}
exports.checkArrayLengths = checkArrayLengths;
function checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {
    var keyLosses = [
        losses.meanSquaredError, losses.binaryCrossentropy,
        losses.categoricalCrossentropy
    ];
    for (var i = 0; i < targets.length; ++i) {
        var y = targets[i];
        var loss = lossFns[i];
        var shape = outputShapes[i];
        if (loss == null) {
            continue;
        }
        if (loss === losses.categoricalCrossentropy) {
            if (y.shape[y.shape.length - 1] === 1) {
                throw new errors_1.ValueError("You are passing a target array of shape " + y.shape + " while using " +
                    "a loss 'categorical_crossentropy'. 'categorical_crossentropy'" +
                    "expects targets to be binary matrices (1s and 0s) of shape " +
                    "[samples, classes].");
            }
        }
        if (keyLosses.indexOf(loss) !== -1) {
            var slicedYShape = y.shape.slice(1);
            var slicedShape = shape.slice(1);
            for (var j = 0; j < slicedYShape.length; ++j) {
                var targetDim = slicedYShape[j];
                var outDim = slicedShape[j];
                if (outDim != null && targetDim !== outDim) {
                    throw new errors_1.ValueError("A target Tensor with shape " + y.shape + " was passed for an " +
                        ("output of shape " + shape + ", while using a loss function that ") +
                        "expects targets to have the same shape as the output.");
                }
            }
        }
    }
}
function makeBatches(size, batchSize) {
    var output = [];
    var batchStart = 0;
    var batchEnd = null;
    while (batchStart < size) {
        batchEnd = batchStart + batchSize;
        if (batchEnd >= size) {
            batchEnd = size;
        }
        output.push([batchStart, batchEnd]);
        batchStart = batchEnd;
    }
    return output;
}
exports.makeBatches = makeBatches;
function sliceArrays(arrays, start, stop) {
    if (arrays == null) {
        return [null];
    }
    else if (Array.isArray(arrays)) {
        return arrays.map(function (array) { return K.sliceAlongFirstAxis(array, start, stop - start); });
    }
    else {
        return K.sliceAlongFirstAxis(arrays, start, stop - start);
    }
}
function sliceArraysByIndices(arrays, indices) {
    return tfc.tidy(function () {
        if (arrays == null) {
            return null;
        }
        else if (Array.isArray(arrays)) {
            return arrays.map(function (array) { return sliceArraysByIndices(array, indices); });
        }
        else {
            return K.gather(arrays, indices.dtype === 'int32' ? indices : indices.toInt());
        }
    });
}
exports.sliceArraysByIndices = sliceArraysByIndices;
function checkInputData(data, names, shapes, checkBatchAxis, exceptionPrefix) {
    if (checkBatchAxis === void 0) { checkBatchAxis = true; }
    if (exceptionPrefix === void 0) { exceptionPrefix = ''; }
    var arrays;
    if (Array.isArray(data)) {
        if (data.length !== names.length) {
            throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + ": the Array of " +
                "Tensors that you are passing to your model is not the size the " +
                ("the model expected. Expected to see " + names.length + " Tensor(s),") +
                (" but instead got " + data.length + " Tensors(s)."));
        }
        arrays = data;
    }
    else {
        if (names.length > 1) {
            throw new errors_1.ValueError("The model expects " + names.length + " " + exceptionPrefix + " Tensors, " +
                "but only received one Tensor. Found: array with shape " +
                (JSON.stringify(data.shape) + "."));
        }
        arrays = [data];
    }
    if (shapes != null) {
        for (var i = 0; i < names.length; ++i) {
            if (shapes[i] == null) {
                continue;
            }
            var array = arrays[i];
            if (array.shape.length !== shapes[i].length) {
                throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                    ("to have " + shapes[i].length + " dimension(s), but got array with ") +
                    ("shape " + JSON.stringify(array.shape)));
            }
            for (var j = 0; j < shapes[i].length; ++j) {
                if (j === 0 && !checkBatchAxis) {
                    continue;
                }
                var dim = array.shape[j];
                var refDim = shapes[i][j];
                if (refDim != null) {
                    if (refDim !== dim) {
                        throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " +
                            (names[i] + " to have shape " + JSON.stringify(shapes[i]) + " but ") +
                            ("got array with shape " + JSON.stringify(array.shape) + "."));
                    }
                }
            }
        }
    }
}
function collectMetrics(metrics, outputNames) {
    if (metrics == null || Array.isArray(metrics) && metrics.length === 0) {
        return outputNames.map(function (name) { return []; });
    }
    if (Array.isArray(metrics)) {
        return outputNames.map(function (name) { return metrics; });
    }
    else if (metrics != null) {
        var nestedMetrics = [];
        for (var _i = 0, outputNames_1 = outputNames; _i < outputNames_1.length; _i++) {
            var name_2 = outputNames_1[_i];
            var outputMetrics = metrics.hasOwnProperty(name_2) ? metrics[name_2] : [];
            if (!Array.isArray(outputMetrics)) {
                outputMetrics = [outputMetrics];
            }
            nestedMetrics.push(outputMetrics);
        }
        return nestedMetrics;
    }
    else {
        throw new TypeError('Type of metrics argument not understood. Expected an Array or ' +
            'Object, found: ' + metrics);
    }
}
var ModelLoggingVerbosity;
(function (ModelLoggingVerbosity) {
    ModelLoggingVerbosity[ModelLoggingVerbosity["SILENT"] = 0] = "SILENT";
    ModelLoggingVerbosity[ModelLoggingVerbosity["VERBOSE"] = 1] = "VERBOSE";
})(ModelLoggingVerbosity = exports.ModelLoggingVerbosity || (exports.ModelLoggingVerbosity = {}));
var Model = (function (_super) {
    __extends(Model, _super);
    function Model(config) {
        return _super.call(this, config) || this;
    }
    Model.prototype.compile = function (config) {
        var _this = this;
        if (config.loss == null) {
            config.loss = [];
        }
        this.loss = config.loss;
        if (typeof config.optimizer === 'string') {
            this.optimizer = optimizers.getOptimizer(config.optimizer);
        }
        else {
            if (!(config.optimizer instanceof tfjs_core_1.Optimizer)) {
                throw new errors_1.ValueError("User-defined optimizer must be an instance of tf.Optimizer.");
            }
            this.optimizer = config.optimizer;
        }
        var lossFunctions = [];
        if (!Array.isArray(config.loss) && typeof config.loss !== 'string' &&
            typeof config.loss !== 'function') {
            config.loss = config.loss;
            for (var name_3 in config.loss) {
                if (this.outputNames.indexOf(name_3) === -1) {
                    throw new errors_1.ValueError("Unknown entry in loss dictionary: \"" + name_3 + "\". Only expect the " +
                        ("following keys: " + this.outputNames));
                }
            }
            for (var name_4 in this.outputNames) {
                if (config.loss[name_4] == null) {
                    console.warn("Output \"" + name_4 + "\" is missing from loss dictionary. We assume " +
                        "this was done on purpose, and we will not be expecting data " +
                        ("to be passed to " + name_4 + " during training"));
                }
                lossFunctions.push(losses.get(config.loss[name_4]));
            }
        }
        else if (Array.isArray(config.loss)) {
            if (config.loss.length !== this.outputs.length) {
                throw new errors_1.ValueError("When passing an Array as loss, it should have one entry per " +
                    ("model output. The model has " + this.outputs.length + " output(s), ") +
                    ("but you passed loss=" + config.loss + "."));
            }
            var theLosses = config.loss;
            lossFunctions = theLosses.map(function (l) { return losses.get(l); });
        }
        else {
            var lossFunction_1 = losses.get(config.loss);
            this.outputs.map(function (layer) {
                lossFunctions.push(lossFunction_1);
            });
        }
        this.lossFunctions = lossFunctions;
        this.feedOutputNames = [];
        this.feedOutputShapes = [];
        this.feedLossFns = [];
        for (var i = 0; i < this.outputs.length; ++i) {
            var shape = this.internalOutputShapes[i];
            var name_5 = this.outputNames[i];
            this.feedOutputNames.push(name_5);
            this.feedOutputShapes.push(shape);
            this.feedLossFns.push(this.lossFunctions[i]);
        }
        var skipTargetIndices = [];
        this.metrics = config.metrics;
        this.metricsNames = ['loss'];
        this.metricsTensors = [];
        K.nameScope('loss', function () {
            for (var i = 0; i < _this.outputs.length; ++i) {
                if (skipTargetIndices.indexOf(i) !== -1) {
                    continue;
                }
                var weightedLoss = _this.lossFunctions[i];
                if (_this.outputs.length > 1) {
                    _this.metricsTensors.push([weightedLoss, i]);
                    _this.metricsNames.push(_this.outputNames[i] + '_loss');
                }
            }
        });
        var nestedMetrics = collectMetrics(config.metrics, this.outputNames);
        var appendMetric = function (outputIndex, metricName, metricTensor) {
            if (_this.outputNames.length > 1) {
                metricName = _this.outputNames[outputIndex] + '_' + metricName;
            }
            _this.metricsNames.push(metricName);
            _this.metricsTensors.push([metricTensor, outputIndex]);
        };
        K.nameScope('metric', function () {
            var _loop_1 = function (i) {
                if (skipTargetIndices.indexOf(i) !== -1) {
                    return "continue";
                }
                var outputMetrics = nestedMetrics[i];
                var handleMetrics = function (metrics) {
                    var metricNamePrefix = '';
                    var metricName;
                    var accFn;
                    var weightedMetricFn;
                    var _loop_2 = function (metric) {
                        if (['accuracy', 'acc', 'crossentropy', 'ce'].indexOf(metric) !==
                            -1) {
                            var outputShape = _this.internalOutputShapes[i];
                            if (outputShape[outputShape.length - 1] === 1 ||
                                _this.lossFunctions[i] === losses.binaryCrossentropy) {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.binaryAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.binaryCrossentropy;
                                }
                            }
                            else if (_this.lossFunctions[i] ===
                                losses.sparseCategoricalCrossentropy) {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.sparseCategoricalAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.sparseCategoricalCrossentropy;
                                }
                            }
                            else {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.categoricalAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.categoricalCrossentropy;
                                }
                            }
                            var suffix = void 0;
                            if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                suffix = 'acc';
                            }
                            else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                suffix = 'ce';
                            }
                            weightedMetricFn = accFn;
                            metricName = metricNamePrefix + suffix;
                        }
                        else {
                            var metricFn = Metrics.get(metric);
                            weightedMetricFn = metricFn;
                            metricName = metricNamePrefix + metric;
                        }
                        var metricResult;
                        K.nameScope(metricName, function () {
                            metricResult = weightedMetricFn;
                        });
                        appendMetric(i, metricName, metricResult);
                    };
                    for (var _i = 0, metrics_1 = metrics; _i < metrics_1.length; _i++) {
                        var metric = metrics_1[_i];
                        _loop_2(metric);
                    }
                };
                handleMetrics(outputMetrics);
            };
            for (var i = 0; i < _this.outputs.length; ++i) {
                _loop_1(i);
            }
        });
        this.collectedTrainableWeights = this.trainableWeights;
    };
    Model.prototype.checkTrainableWeightsConsistency = function () {
        if (this.collectedTrainableWeights == null) {
            return;
        }
        if (this.trainableWeights.length !==
            this.collectedTrainableWeights.length) {
            console.warn('Discrepancy between trainableweights and collected trainable ' +
                'weights. Did you set `model.trainable` without calling ' +
                '`model.compile()` afterwards?');
        }
    };
    Model.prototype.evaluate = function (x, y, config) {
        if (config === void 0) { config = {}; }
        var batchSize = config.batchSize == null ? 32 : config.batchSize;
        var standardizedOuts = this.standardizeUserData(x, y, true, batchSize);
        var ins = standardizedOuts[0].concat(standardizedOuts[1]);
        this.makeTestFunction();
        var f = this.testFunction;
        var testOuts = this.testLoop(f, ins, batchSize, config.verbose, config.steps);
        return generic_utils_1.singletonOrArray(testOuts);
    };
    Model.prototype.checkNumSamples = function (ins, batchSize, steps, stepsName) {
        if (stepsName === void 0) { stepsName = 'steps'; }
        var numSamples;
        if (steps != null) {
            numSamples = null;
            if (batchSize != null) {
                throw new errors_1.ValueError("If " + stepsName + " is set, batchSize must be null or undefined." +
                    ("Got batchSize = " + batchSize));
            }
        }
        else if (ins != null) {
            if (Array.isArray(ins)) {
                numSamples = ins[0].shape[0];
            }
            else {
                numSamples = ins.shape[0];
            }
        }
        else {
            throw new errors_1.ValueError("Either the input data should have a defined shape, or " +
                (stepsName + " shoud be specified."));
        }
        return numSamples;
    };
    Model.prototype.predictLoop = function (ins, batchSize, verbose) {
        var _this = this;
        if (batchSize === void 0) { batchSize = 32; }
        if (verbose === void 0) { verbose = false; }
        var numSamples = this.checkNumSamples(ins);
        if (verbose) {
            throw new errors_1.NotImplementedError('Verbose predictLoop() is not implemented yet.');
        }
        var batches = makeBatches(numSamples, batchSize);
        var outs = [];
        var _loop_3 = function (batchIndex) {
            var batchOuts = tfc.tidy(function () {
                var batchStart = batches[batchIndex][0];
                var batchEnd = batches[batchIndex][1];
                var insBatch = sliceArrays(ins, batchStart, batchEnd);
                var feeds = [];
                if (Array.isArray(insBatch)) {
                    for (var i = 0; i < insBatch.length; ++i) {
                        feeds.push({ key: _this.inputs[i], value: insBatch[i] });
                    }
                }
                else {
                    feeds.push({ key: _this.inputs[0], value: insBatch });
                }
                var feedDict = new executor_1.FeedDict(feeds);
                return executor_1.execute(_this.outputs, feedDict);
            });
            if (batchIndex === 0) {
                for (var _i = 0, batchOuts_1 = batchOuts; _i < batchOuts_1.length; _i++) {
                    var batchOut = batchOuts_1[_i];
                    outs.push(batchOut);
                }
            }
            else {
                for (var i = 0; i < batchOuts.length; ++i) {
                    outs[i] = K.concatAlongFirstAxis(outs[i], batchOuts[i]);
                }
            }
        };
        for (var batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
            _loop_3(batchIndex);
        }
        return generic_utils_1.singletonOrArray(outs);
    };
    Model.prototype.predict = function (x, config) {
        if (config === void 0) { config = {}; }
        checkInputData(x, this.inputNames, this.feedInputShapes, false);
        var batchSize = config.batchSize == null ? 32 : config.batchSize;
        return this.predictLoop(x, batchSize);
    };
    Model.prototype.predictOnBatch = function (x) {
        checkInputData(x, this.inputNames, this.feedInputShapes, true);
        return this.predictLoop(x, x.shape[0]);
    };
    Model.prototype.standardizeUserData = function (x, y, checkBatchAxis, batchSize) {
        if (checkBatchAxis === void 0) { checkBatchAxis = true; }
        if (this.optimizer == null) {
            throw new errors_1.RuntimeError('You must compile a model before training/testing. Use ' +
                'Model.compile(modelCompileConfig).');
        }
        var outputShapes = [];
        for (var i = 0; i < this.feedOutputShapes.length; ++i) {
            var outputShape = this.feedOutputShapes[i];
            var lossFn = this.feedLossFns[i];
            if (lossFn === losses.sparseCategoricalCrossentropy) {
                outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]));
            }
            else {
                outputShapes.push(outputShape);
            }
        }
        x = standardizeInputData(x, this.feedInputNames, this.feedInputShapes, false, 'input');
        y = standardizeInputData(y, this.feedOutputNames, outputShapes, false, 'target');
        checkArrayLengths(x, y, null);
        checkLossAndTargetCompatibility(y, this.feedLossFns, this.feedOutputShapes);
        if (this.stateful && batchSize != null && batchSize > 0) {
            if (x[0].shape[0] % batchSize !== 0) {
                throw new errors_1.ValueError("In a stateful network, you should only pass inputs with a " +
                    "number of samples that is divisible by the batch size " +
                    (batchSize + ". Found: " + x[0].shape[0] + " sample(s)."));
            }
        }
        return [x, y, null];
    };
    Model.prototype.fitLoop = function (f, ins, outLabels, batchSize, epochs, verbose, callbacks, valF, valIns, shuffle, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {
        if (initialEpoch === void 0) { initialEpoch = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var doValidation, numTrainSamples, indexArray, callbackList, _loop_4, this_1, epoch, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (batchSize == null) {
                            batchSize = 32;
                        }
                        if (epochs == null) {
                            epochs = 1;
                        }
                        if (shuffle == null) {
                            shuffle = true;
                        }
                        if (initialEpoch == null) {
                            initialEpoch = 0;
                        }
                        doValidation = false;
                        if (valF != null && valIns != null) {
                            doValidation = true;
                        }
                        if (validationSteps != null) {
                            doValidation = true;
                            if (stepsPerEpoch == null) {
                                throw new errors_1.ValueError('Can only use `validationSteps` when doing step-wise training, ' +
                                    'i.e., `stepsPerEpoch` must be set.');
                            }
                        }
                        numTrainSamples = this.checkNumSamples(ins, batchSize, stepsPerEpoch, 'steps_per_epoch');
                        if (numTrainSamples != null) {
                            indexArray = math_utils_1.range(0, numTrainSamples);
                        }
                        this.history = new callbacks_1.History();
                        if (callbacks == null) {
                            callbacks = [new callbacks_1.BaseLogger()];
                        }
                        else {
                            callbacks = [new callbacks_1.BaseLogger()].concat(callbacks);
                        }
                        callbacks = callbacks.concat([this.history]);
                        if (verbose > 0) {
                            throw new errors_1.NotImplementedError('Verbose mode is not implemented yet.');
                        }
                        callbackList = new callbacks_1.CallbackList(callbacks);
                        callbackList.setModel(this);
                        callbackList.setParams({
                            epochs: epochs,
                            steps: stepsPerEpoch,
                            verbose: verbose,
                            doValidation: doValidation,
                            metrics: callbackMetrics,
                        });
                        return [4, callbackList.onTrainBegin()];
                    case 1:
                        _a.sent();
                        this.stopTraining = false;
                        _loop_4 = function (epoch) {
                            var epochLogs, epochIndexArray1D_1, batches_1, _loop_5, batchIndex, state_2;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4, callbackList.onEpochBegin(epoch)];
                                    case 1:
                                        _a.sent();
                                        epochLogs = {};
                                        if (!(stepsPerEpoch != null)) return [3, 2];
                                        throw new errors_1.NotImplementedError('stepsPerEpoch mode is not implemented yet.');
                                    case 2:
                                        if (shuffle === 'batch') {
                                            throw new errors_1.NotImplementedError('batch shuffling is not implemneted yet');
                                        }
                                        else if (shuffle) {
                                            tfjs_core_1.util.shuffle(indexArray);
                                        }
                                        epochIndexArray1D_1 = tfjs_core_1.tensor1d(indexArray);
                                        batches_1 = makeBatches(numTrainSamples, batchSize);
                                        _loop_5 = function (batchIndex) {
                                            var batchLogs;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        batchLogs = {};
                                                        return [4, callbackList.onBatchBegin(batchIndex, batchLogs)];
                                                    case 1:
                                                        _a.sent();
                                                        tfc.tidy(function () {
                                                            var batchStart = batches_1[batchIndex][0];
                                                            var batchEnd = batches_1[batchIndex][1];
                                                            var batchIds = K.sliceAlongFirstAxis(epochIndexArray1D_1, batchStart, batchEnd - batchStart);
                                                            batchLogs['batch'] = batchIndex;
                                                            batchLogs['size'] = batchEnd - batchStart;
                                                            var insBatch = sliceArraysByIndices(ins, batchIds);
                                                            var outs = f(insBatch);
                                                            for (var i = 0; i < outLabels.length; ++i) {
                                                                var label = outLabels[i];
                                                                var out = outs[i];
                                                                batchLogs[label] = out;
                                                                tfc.keep(out);
                                                            }
                                                            if (batchIndex === batches_1.length - 1) {
                                                                if (doValidation) {
                                                                    var valOuts = _this.testLoop(valF, valIns, batchSize);
                                                                    for (var i = 0; i < outLabels.length; ++i) {
                                                                        var label = outLabels[i];
                                                                        var out = valOuts[i];
                                                                        tfc.keep(out);
                                                                        epochLogs['val_' + label] = out;
                                                                    }
                                                                }
                                                            }
                                                        });
                                                        return [4, callbackList.onBatchEnd(batchIndex, batchLogs)];
                                                    case 2:
                                                        _a.sent();
                                                        callbacks_1.disposeTensorsInLogs(batchLogs);
                                                        if (this_1.stopTraining) {
                                                            return [2, "break"];
                                                        }
                                                        return [2];
                                                }
                                            });
                                        };
                                        batchIndex = 0;
                                        _a.label = 3;
                                    case 3:
                                        if (!(batchIndex < batches_1.length)) return [3, 6];
                                        return [5, _loop_5(batchIndex)];
                                    case 4:
                                        state_2 = _a.sent();
                                        if (state_2 === "break")
                                            return [3, 6];
                                        _a.label = 5;
                                    case 5:
                                        ++batchIndex;
                                        return [3, 3];
                                    case 6:
                                        epochIndexArray1D_1.dispose();
                                        _a.label = 7;
                                    case 7: return [4, callbackList.onEpochEnd(epoch, epochLogs)];
                                    case 8:
                                        _a.sent();
                                        if (this_1.stopTraining) {
                                            return [2, "break"];
                                        }
                                        return [2];
                                }
                            });
                        };
                        this_1 = this;
                        epoch = initialEpoch;
                        _a.label = 2;
                    case 2:
                        if (!(epoch < epochs)) return [3, 5];
                        return [5, _loop_4(epoch)];
                    case 3:
                        state_1 = _a.sent();
                        if (state_1 === "break")
                            return [3, 5];
                        _a.label = 4;
                    case 4:
                        ++epoch;
                        return [3, 2];
                    case 5: return [4, callbackList.onTrainEnd()];
                    case 6:
                        _a.sent();
                        return [4, this.history.syncData()];
                    case 7:
                        _a.sent();
                        return [2, this.history];
                }
            });
        });
    };
    Model.prototype.testLoop = function (f, ins, batchSize, verbose, steps) {
        if (verbose === void 0) { verbose = 0; }
        var numSamples = this.checkNumSamples(ins, batchSize, steps, 'steps');
        var outs = [];
        if (verbose === 1) {
            throw new errors_1.NotImplementedError('Verbose mode is not implemented yet.');
        }
        if (steps != null) {
            throw new errors_1.NotImplementedError('steps mode in testLoop() is not implemented yet');
        }
        else {
            var batches = makeBatches(numSamples, batchSize);
            var indexArray = tfjs_core_1.tensor1d(math_utils_1.range(0, numSamples));
            for (var batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
                var batchStart = batches[batchIndex][0];
                var batchEnd = batches[batchIndex][1];
                var batchIds = K.sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);
                var insBatch = sliceArraysByIndices(ins, batchIds);
                var batchOuts = f(insBatch);
                if (batchIndex === 0) {
                    for (var i = 0; i < batchOuts.length; ++i) {
                        outs.push(K.getScalar(0));
                    }
                }
                for (var i = 0; i < batchOuts.length; ++i) {
                    var batchOut = batchOuts[i];
                    outs[i] =
                        tfc.add(outs[i], K.scalarTimesArray(K.getScalar(batchEnd - batchStart), batchOut));
                }
            }
            for (var i = 0; i < outs.length; ++i) {
                outs[i] = tfc.div(outs[i], K.getScalar(numSamples));
            }
        }
        return outs;
    };
    Model.prototype.getDedupedMetricsNames = function () {
        var outLabels = this.metricsNames;
        var dedupedOutLabels = [];
        for (var i = 0; i < outLabels.length; ++i) {
            var label = outLabels[i];
            var newLabel = label;
            if (generic_utils_1.count(outLabels, label) > 1) {
                var dupIndex = generic_utils_1.count(outLabels.slice(0, i), label);
                newLabel += "_" + dupIndex;
            }
            dedupedOutLabels.push(newLabel);
        }
        return dedupedOutLabels;
    };
    Model.prototype.makeTestFunction = function () {
        var _this = this;
        this.testFunction = function (data) {
            return tfc.tidy(function () {
                var valOutputs = [];
                var totalLoss;
                var inputs = data.slice(0, _this.inputs.length);
                var targets = data.slice(_this.inputs.length, _this.inputs.length + _this.outputs.length);
                var feeds = [];
                for (var i = 0; i < _this.inputs.length; ++i) {
                    feeds.push({ key: _this.inputs[i], value: inputs[i] });
                }
                var feedDict = new executor_1.FeedDict(feeds);
                var outputs = executor_1.execute(_this.outputs, feedDict);
                for (var i = 0; i < _this.lossFunctions.length; ++i) {
                    var lossFunction = _this.lossFunctions[i];
                    var loss = tfc.mean(lossFunction(targets[i], outputs[i]));
                    if (i === 0) {
                        totalLoss = loss;
                    }
                    else {
                        totalLoss = tfc.add(totalLoss, loss);
                    }
                    valOutputs.push(totalLoss);
                }
                for (var i = 0; i < _this.metricsTensors.length; ++i) {
                    var metric = _this.metricsTensors[i][0];
                    var outputIndex = _this.metricsTensors[i][1];
                    var meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));
                    valOutputs.push(meanMetric);
                }
                return valOutputs;
            });
        };
    };
    Model.prototype.fit = function (x, y, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var batchSize, standardizedOuts, inputs, targets, doValidation, valX, valY, valIns, needValidationDisposal, valStandardized, splitAt, originalBatchSize, ins, trainFunction, outLabels, valFunction, callbackMetrics, callbacks, out;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        batchSize = config.batchSize == null ? 32 : config.batchSize;
                        standardizedOuts = this.standardizeUserData(x, y, false, batchSize);
                        inputs = standardizedOuts[0];
                        targets = standardizedOuts[1];
                        doValidation = false;
                        needValidationDisposal = false;
                        if (config.validationData != null && config.validationData.length > 0) {
                            doValidation = true;
                            if (config.validationData.length === 2) {
                                valX = config.validationData[0];
                                valY = config.validationData[1];
                            }
                            else if (config.validationData.length === 3) {
                                throw new errors_1.NotImplementedError('validationData including sample weights is not supported yet.');
                            }
                            else {
                                throw new errors_1.ValueError("When passing validation data, it must contain 2 (valX, valY) " +
                                    "or 3 (valX, valY, valSampleWeight) items; " +
                                    (config.validationData + " is invalid."));
                            }
                            valStandardized = this.standardizeUserData(valX, valY, true, batchSize);
                            valX = valStandardized[0];
                            valY = valStandardized[1];
                            valIns = valX.concat(valY);
                        }
                        else if (config.validationSplit != null && config.validationSplit > 0 &&
                            config.validationSplit < 1) {
                            doValidation = true;
                            splitAt = Math.floor(inputs[0].shape[0] * (1 - config.validationSplit));
                            originalBatchSize = inputs[0].shape[0];
                            valX = sliceArrays(inputs, splitAt, originalBatchSize);
                            inputs = sliceArrays(inputs, 0, splitAt);
                            valY = sliceArrays(targets, splitAt, originalBatchSize);
                            targets = sliceArrays(targets, 0, splitAt);
                            needValidationDisposal = true;
                            valIns = valX.concat(valY);
                        }
                        else if (config.validationSteps != null) {
                            doValidation = true;
                        }
                        ins = inputs.concat(targets);
                        this.checkTrainableWeightsConsistency();
                        trainFunction = function (data) {
                            var losses = [];
                            var lossValues = [];
                            var inputs = data.slice(0, _this.inputs.length);
                            var targets = data.slice(_this.inputs.length, _this.inputs.length + _this.outputs.length);
                            var metricsValues = [];
                            var totalLossFunction = function () {
                                var feeds = [];
                                for (var i = 0; i < _this.inputs.length; ++i) {
                                    feeds.push({ key: _this.inputs[i], value: inputs[i] });
                                }
                                var feedDict = new executor_1.FeedDict(feeds);
                                var outputs = executor_1.execute(_this.outputs, feedDict, { 'training': true });
                                var totalLoss;
                                for (var i = 0; i < _this.lossFunctions.length; ++i) {
                                    var lossFunction = _this.lossFunctions[i];
                                    var loss = lossFunction(targets[i], outputs[i]);
                                    losses.push(loss);
                                    var meanLoss = tfc.mean(loss);
                                    lossValues.push(meanLoss);
                                    if (i === 0) {
                                        totalLoss = loss;
                                    }
                                    else {
                                        totalLoss = tfc.add(totalLoss, loss);
                                    }
                                }
                                for (var i = 0; i < _this.metricsTensors.length; ++i) {
                                    var metric = _this.metricsTensors[i][0];
                                    var outputIndex = _this.metricsTensors[i][1];
                                    var meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));
                                    tfc.keep(meanMetric);
                                    metricsValues.push(meanMetric);
                                }
                                totalLoss = tfc.mean(totalLoss);
                                _this.calculateLosses().forEach(function (regularizerLoss) {
                                    totalLoss = tfc.add(totalLoss, regularizerLoss);
                                });
                                return totalLoss;
                            };
                            var variables = _this.collectedTrainableWeights.map(function (param) { return param.read(); });
                            var returnCost = true;
                            var totalLossValue = _this.optimizer.minimize(totalLossFunction, returnCost, variables);
                            return [totalLossValue].concat(metricsValues);
                        };
                        outLabels = this.getDedupedMetricsNames();
                        if (doValidation) {
                            this.makeTestFunction();
                            valFunction = this.testFunction;
                            callbackMetrics =
                                outLabels.slice().concat(outLabels.map(function (n) { return 'val_' + n; }));
                        }
                        else {
                            valFunction = null;
                            valIns = [];
                            callbackMetrics = outLabels.slice();
                        }
                        callbacks = callbacks_1.standardizeCallbacks(config.callbacks);
                        return [4, this.fitLoop(trainFunction, ins, outLabels, batchSize, config.epochs, config.verbose, callbacks, valFunction, valIns, config.shuffle, callbackMetrics, null, null, null)];
                    case 1:
                        out = _a.sent();
                        if (needValidationDisposal) {
                            valIns.forEach(function (tensor) { return tensor.dispose(); });
                            inputs.forEach(function (tensor) { return tensor.dispose(); });
                            targets.forEach(function (tensor) { return tensor.dispose(); });
                        }
                        return [2, out];
                }
            });
        });
    };
    Model.prototype.getNamedWeights = function (config) {
        var namedWeights = {};
        var trainableOnly = config != null && config.trainableOnly;
        var weights = trainableOnly ? this.trainableWeights : this.weights;
        var weightValues = this.getWeights(trainableOnly);
        for (var i = 0; i < weights.length; ++i) {
            if (trainableOnly && !weights[i].trainable) {
                continue;
            }
            namedWeights[weights[i].originalName] = weightValues[i];
        }
        return namedWeights;
    };
    Model.prototype.save = function (handlerOrURL, config) {
        return __awaiter(this, void 0, void 0, function () {
            var handlers, weightDataAndSpecs, returnString, unusedArg, modelConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof handlerOrURL === 'string') {
                            handlers = tfjs_core_1.io.getSaveHandlers(handlerOrURL);
                            if (handlers.length === 0) {
                                throw new errors_1.ValueError("Cannot find any save handlers for URL '" + handlerOrURL + "'");
                            }
                            else if (handlers.length > 1) {
                                throw new errors_1.ValueError("Found more than one (" + handlers.length + ") save handlers for " +
                                    ("URL '" + handlerOrURL + "'"));
                            }
                            handlerOrURL = handlers[0];
                        }
                        if (handlerOrURL.save == null) {
                            throw new errors_1.ValueError('Model.save() cannot proceed because the IOHandler provided does ' +
                                'not have the `save` attribute defined.');
                        }
                        return [4, tfjs_core_1.io.encodeWeights(this.getNamedWeights(config))];
                    case 1:
                        weightDataAndSpecs = _a.sent();
                        returnString = false;
                        unusedArg = null;
                        modelConfig = this.toJSON(unusedArg, returnString);
                        return [2, handlerOrURL.save({
                                modelTopology: modelConfig,
                                weightData: weightDataAndSpecs.data,
                                weightSpecs: weightDataAndSpecs.specs
                            })];
                }
            });
        });
    };
    Model.className = 'Model';
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [0] })
    ], Model.prototype, "compile", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })
    ], Model.prototype, "evaluate", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [1] })
    ], Model.prototype, "predict", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes' })
    ], Model.prototype, "predictOnBatch", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })
    ], Model.prototype, "fit", null);
    Model = __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes' })
    ], Model);
    return Model;
}(topology_1.Container));
exports.Model = Model;
tfjs_core_1.serialization.SerializationMap.register(Model);

},{"../backend/tfjs_backend":160,"../callbacks":161,"../errors":167,"../losses":183,"../metrics":184,"../optimizers":186,"../utils/generic_utils":190,"../utils/math_utils":191,"./executor":164,"./topology":165,"@tensorflow/tfjs-core":51}],167:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AttributeError = (function (_super) {
    __extends(AttributeError, _super);
    function AttributeError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, AttributeError.prototype);
        return _this;
    }
    return AttributeError;
}(Error));
exports.AttributeError = AttributeError;
var RuntimeError = (function (_super) {
    __extends(RuntimeError, _super);
    function RuntimeError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, RuntimeError.prototype);
        return _this;
    }
    return RuntimeError;
}(Error));
exports.RuntimeError = RuntimeError;
var ValueError = (function (_super) {
    __extends(ValueError, _super);
    function ValueError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ValueError.prototype);
        return _this;
    }
    return ValueError;
}(Error));
exports.ValueError = ValueError;
var NotImplementedError = (function (_super) {
    __extends(NotImplementedError, _super);
    function NotImplementedError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, NotImplementedError.prototype);
        return _this;
    }
    return NotImplementedError;
}(Error));
exports.NotImplementedError = NotImplementedError;
var AssertionError = (function (_super) {
    __extends(AssertionError, _super);
    function AssertionError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, AssertionError.prototype);
        return _this;
    }
    return AssertionError;
}(Error));
exports.AssertionError = AssertionError;
var IndexError = (function (_super) {
    __extends(IndexError, _super);
    function IndexError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, IndexError.prototype);
        return _this;
    }
    return IndexError;
}(Error));
exports.IndexError = IndexError;

},{}],168:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var constraints_1 = require("./constraints");
var topology_1 = require("./engine/topology");
var training_1 = require("./engine/training");
var initializers_1 = require("./initializers");
var advanced_activations_1 = require("./layers/advanced_activations");
var convolutional_1 = require("./layers/convolutional");
var convolutional_depthwise_1 = require("./layers/convolutional_depthwise");
var core_1 = require("./layers/core");
var embeddings_1 = require("./layers/embeddings");
var merge_1 = require("./layers/merge");
var normalization_1 = require("./layers/normalization");
var padding_1 = require("./layers/padding");
var pooling_1 = require("./layers/pooling");
var recurrent_1 = require("./layers/recurrent");
var wrappers_1 = require("./layers/wrappers");
var losses_1 = require("./losses");
var metrics_1 = require("./metrics");
var models_1 = require("./models");
var regularizers_1 = require("./regularizers");
var ModelExports = (function () {
    function ModelExports() {
    }
    ModelExports.model = function (config) {
        return new training_1.Model(config);
    };
    ModelExports.sequential = function (config) {
        return new models_1.Sequential(config);
    };
    ModelExports.loadModel = function (pathOrIOHandler) {
        return models_1.loadModelInternal(pathOrIOHandler);
    };
    ModelExports.input = function (config) {
        return topology_1.Input(config);
    };
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Creation', configParamIndices: [0] })
    ], ModelExports, "model", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Creation', configParamIndices: [0] })
    ], ModelExports, "sequential", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Models',
            subheading: 'Loading',
            useDocsFrom: 'loadModelInternal'
        })
    ], ModelExports, "loadModel", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Models',
            subheading: 'Inputs',
            useDocsFrom: 'Input',
            configParamIndices: [0]
        })
    ], ModelExports, "input", null);
    return ModelExports;
}());
exports.ModelExports = ModelExports;
var LayerExports = (function () {
    function LayerExports() {
    }
    LayerExports.inputLayer = function (config) {
        return new topology_1.InputLayer(config);
    };
    LayerExports.elu = function (config) {
        return new advanced_activations_1.ELU(config);
    };
    LayerExports.leakyReLU = function (config) {
        return new advanced_activations_1.LeakyReLU(config);
    };
    LayerExports.softmax = function (config) {
        return new advanced_activations_1.Softmax(config);
    };
    LayerExports.thresholdedReLU = function (config) {
        return new advanced_activations_1.ThresholdedReLU(config);
    };
    LayerExports.conv1d = function (config) {
        return new convolutional_1.Conv1D(config);
    };
    LayerExports.conv2d = function (config) {
        return new convolutional_1.Conv2D(config);
    };
    LayerExports.conv2dTranspose = function (config) {
        return new convolutional_1.Conv2DTranspose(config);
    };
    LayerExports.separableConv2d = function (config) {
        return new convolutional_1.SeparableConv2D(config);
    };
    LayerExports.cropping2D = function (config) {
        return new convolutional_1.Cropping2D(config);
    };
    LayerExports.upSampling2d = function (config) {
        return new convolutional_1.UpSampling2D(config);
    };
    LayerExports.depthwiseConv2d = function (config) {
        return new convolutional_depthwise_1.DepthwiseConv2D(config);
    };
    LayerExports.activation = function (config) {
        return new core_1.Activation(config);
    };
    LayerExports.dense = function (config) {
        return new core_1.Dense(config);
    };
    LayerExports.dropout = function (config) {
        return new core_1.Dropout(config);
    };
    LayerExports.flatten = function (config) {
        return new core_1.Flatten(config);
    };
    LayerExports.repeatVector = function (config) {
        return new core_1.RepeatVector(config);
    };
    LayerExports.reshape = function (config) {
        return new core_1.Reshape(config);
    };
    LayerExports.embedding = function (config) {
        return new embeddings_1.Embedding(config);
    };
    LayerExports.add = function (config) {
        return new merge_1.Add(config);
    };
    LayerExports.average = function (config) {
        return new merge_1.Average(config);
    };
    LayerExports.concatenate = function (config) {
        return new merge_1.Concatenate(config);
    };
    LayerExports.maximum = function (config) {
        return new merge_1.Maximum(config);
    };
    LayerExports.minimum = function (config) {
        return new merge_1.Minimum(config);
    };
    LayerExports.multiply = function (config) {
        return new merge_1.Multiply(config);
    };
    LayerExports.batchNormalization = function (config) {
        return new normalization_1.BatchNormalization(config);
    };
    LayerExports.zeroPadding2d = function (config) {
        return new padding_1.ZeroPadding2D(config);
    };
    LayerExports.averagePooling1d = function (config) {
        return new pooling_1.AveragePooling1D(config);
    };
    LayerExports.avgPool1d = function (config) {
        return LayerExports.averagePooling1d(config);
    };
    LayerExports.avgPooling1d = function (config) {
        return LayerExports.averagePooling1d(config);
    };
    LayerExports.averagePooling2d = function (config) {
        return new pooling_1.AveragePooling2D(config);
    };
    LayerExports.avgPool2d = function (config) {
        return LayerExports.averagePooling2d(config);
    };
    LayerExports.avgPooling2d = function (config) {
        return LayerExports.averagePooling2d(config);
    };
    LayerExports.globalAveragePooling1d = function (config) {
        return new pooling_1.GlobalAveragePooling1D(config);
    };
    LayerExports.globalAveragePooling2d = function (config) {
        return new pooling_1.GlobalAveragePooling2D(config);
    };
    LayerExports.globalMaxPooling1d = function (config) {
        return new pooling_1.GlobalMaxPooling1D(config);
    };
    LayerExports.globalMaxPooling2d = function (config) {
        return new pooling_1.GlobalMaxPooling2D(config);
    };
    LayerExports.maxPooling1d = function (config) {
        return new pooling_1.MaxPooling1D(config);
    };
    LayerExports.maxPooling2d = function (config) {
        return new pooling_1.MaxPooling2D(config);
    };
    LayerExports.gru = function (config) {
        return new recurrent_1.GRU(config);
    };
    LayerExports.gruCell = function (config) {
        return new recurrent_1.GRUCell(config);
    };
    LayerExports.lstm = function (config) {
        return new recurrent_1.LSTM(config);
    };
    LayerExports.lstmCell = function (config) {
        return new recurrent_1.LSTMCell(config);
    };
    LayerExports.simpleRNN = function (config) {
        return new recurrent_1.SimpleRNN(config);
    };
    LayerExports.simpleRNNCell = function (config) {
        return new recurrent_1.SimpleRNNCell(config);
    };
    LayerExports.rnn = function (config) {
        return new recurrent_1.RNN(config);
    };
    LayerExports.stackedRNNCells = function (config) {
        return new recurrent_1.StackedRNNCells(config);
    };
    LayerExports.bidirectional = function (config) {
        return new wrappers_1.Bidirectional(config);
    };
    LayerExports.timeDistributed = function (config) {
        return new wrappers_1.TimeDistributed(config);
    };
    LayerExports.Layer = topology_1.Layer;
    LayerExports.RNN = recurrent_1.RNN;
    LayerExports.RNNCell = recurrent_1.RNNCell;
    LayerExports.input = ModelExports.input;
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Inputs',
            namespace: 'layers',
            useDocsFrom: 'InputLayer',
            configParamIndices: [0]
        })
    ], LayerExports, "inputLayer", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Advanced Activation',
            namespace: 'layers',
            useDocsFrom: 'ELU',
            configParamIndices: [0]
        })
    ], LayerExports, "elu", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Advanced Activation',
            namespace: 'layers',
            useDocsFrom: 'LeakyReLU',
            configParamIndices: [0]
        })
    ], LayerExports, "leakyReLU", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Advanced Activation',
            namespace: 'layers',
            useDocsFrom: 'Softmax',
            configParamIndices: [0]
        })
    ], LayerExports, "softmax", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Advanced Activation',
            namespace: 'layers',
            useDocsFrom: 'ThresholdedReLU',
            configParamIndices: [0]
        })
    ], LayerExports, "thresholdedReLU", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'Conv1D',
            configParamIndices: [0]
        })
    ], LayerExports, "conv1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'Conv2D',
            configParamIndices: [0]
        })
    ], LayerExports, "conv2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'Conv2DTranspose',
            configParamIndices: [0]
        })
    ], LayerExports, "conv2dTranspose", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'SeparableConv2D',
            configParamIndices: [0]
        })
    ], LayerExports, "separableConv2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'Cropping2D',
            configParamIndices: [0]
        })
    ], LayerExports, "cropping2D", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'UpSampling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "upSampling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'DepthwiseConv2D',
            configParamIndices: [0]
        })
    ], LayerExports, "depthwiseConv2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Activation',
            configParamIndices: [0]
        })
    ], LayerExports, "activation", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Dense',
            configParamIndices: [0]
        })
    ], LayerExports, "dense", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Dropout',
            configParamIndices: [0]
        })
    ], LayerExports, "dropout", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Flatten',
            configParamIndices: [0]
        })
    ], LayerExports, "flatten", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'RepeatVector',
            configParamIndices: [0]
        })
    ], LayerExports, "repeatVector", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Reshape',
            configParamIndices: [0]
        })
    ], LayerExports, "reshape", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Embedding',
            configParamIndices: [0]
        })
    ], LayerExports, "embedding", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Add',
            configParamIndices: [0]
        })
    ], LayerExports, "add", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Average',
            configParamIndices: [0]
        })
    ], LayerExports, "average", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Concatenate',
            configParamIndices: [0]
        })
    ], LayerExports, "concatenate", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Maximum',
            configParamIndices: [0]
        })
    ], LayerExports, "maximum", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Minimum',
            configParamIndices: [0]
        })
    ], LayerExports, "minimum", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Multiply',
            configParamIndices: [0]
        })
    ], LayerExports, "multiply", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Normalization',
            namespace: 'layers',
            useDocsFrom: 'BatchNormalization',
            configParamIndices: [0]
        })
    ], LayerExports, "batchNormalization", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Padding',
            namespace: 'layers',
            useDocsFrom: 'ZeroPadding2D',
            configParamIndices: [0]
        })
    ], LayerExports, "zeroPadding2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'AveragePooling1D',
            configParamIndices: [0]
        })
    ], LayerExports, "averagePooling1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'AveragePooling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "averagePooling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'GlobalAveragePooling1D',
            configParamIndices: [0]
        })
    ], LayerExports, "globalAveragePooling1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'GlobalAveragePooling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "globalAveragePooling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'GlobalMaxPooling1D',
            configParamIndices: [0]
        })
    ], LayerExports, "globalMaxPooling1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'GlobalMaxPooling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "globalMaxPooling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'MaxPooling1D',
            configParamIndices: [0]
        })
    ], LayerExports, "maxPooling1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'MaxPooling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "maxPooling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'GRU',
            configParamIndices: [0]
        })
    ], LayerExports, "gru", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'GRUCell',
            configParamIndices: [0]
        })
    ], LayerExports, "gruCell", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'LSTM',
            configParamIndices: [0]
        })
    ], LayerExports, "lstm", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'LSTMCell',
            configParamIndices: [0]
        })
    ], LayerExports, "lstmCell", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'SimpleRNN',
            configParamIndices: [0]
        })
    ], LayerExports, "simpleRNN", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'SimpleRNNCell',
            configParamIndices: [0]
        })
    ], LayerExports, "simpleRNNCell", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'RNN',
            configParamIndices: [0]
        })
    ], LayerExports, "rnn", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'RNN',
            configParamIndices: [0]
        })
    ], LayerExports, "stackedRNNCells", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Wrapper',
            namespace: 'layers',
            useDocsFrom: 'Bidirectional',
            configParamIndices: [0]
        })
    ], LayerExports, "bidirectional", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Wrapper',
            namespace: 'layers',
            useDocsFrom: 'TimeDistributed',
            configParamIndices: [0]
        })
    ], LayerExports, "timeDistributed", null);
    return LayerExports;
}());
exports.LayerExports = LayerExports;
var ConstraintExports = (function () {
    function ConstraintExports() {
    }
    ConstraintExports.maxNorm = function (config) {
        return new constraints_1.MaxNorm(config);
    };
    ConstraintExports.unitNorm = function (config) {
        return new constraints_1.UnitNorm(config);
    };
    ConstraintExports.nonNeg = function () {
        return new constraints_1.NonNeg();
    };
    ConstraintExports.minMaxNorm = function (config) {
        return new constraints_1.MinMaxNorm(config);
    };
    __decorate([
        tfjs_core_1.doc({
            heading: 'Constraints',
            namespace: 'constraints',
            useDocsFrom: 'MaxNorm',
            configParamIndices: [0]
        })
    ], ConstraintExports, "maxNorm", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Constraints',
            namespace: 'constraints',
            useDocsFrom: 'UnitNorm',
            configParamIndices: [0]
        })
    ], ConstraintExports, "unitNorm", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Constraints', namespace: 'constraints', useDocsFrom: 'NonNeg' })
    ], ConstraintExports, "nonNeg", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Constraints',
            namespace: 'constraints',
            useDocsFrom: 'MinMaxNormConfig',
            configParamIndices: [0]
        })
    ], ConstraintExports, "minMaxNorm", null);
    return ConstraintExports;
}());
exports.ConstraintExports = ConstraintExports;
var InitializerExports = (function () {
    function InitializerExports() {
    }
    InitializerExports.zeros = function () {
        return new initializers_1.Zeros();
    };
    InitializerExports.ones = function () {
        return new initializers_1.Ones();
    };
    InitializerExports.constant = function (config) {
        return new initializers_1.Constant(config);
    };
    InitializerExports.randomUniform = function (config) {
        return new initializers_1.RandomUniform(config);
    };
    InitializerExports.randomNormal = function (config) {
        return new initializers_1.RandomNormal(config);
    };
    InitializerExports.truncatedNormal = function (config) {
        return new initializers_1.TruncatedNormal(config);
    };
    InitializerExports.identity = function (config) {
        return new initializers_1.Identity(config);
    };
    InitializerExports.varianceScaling = function (config) {
        return new initializers_1.VarianceScaling(config);
    };
    InitializerExports.glorotUniform = function (config) {
        return new initializers_1.GlorotUniform(config);
    };
    InitializerExports.glorotNormal = function (config) {
        return new initializers_1.GlorotNormal(config);
    };
    InitializerExports.heNormal = function (config) {
        return new initializers_1.HeNormal(config);
    };
    InitializerExports.leCunNormal = function (config) {
        return new initializers_1.LeCunNormal(config);
    };
    InitializerExports.orthogonal = function (config) {
        return new initializers_1.Orthogonal(config);
    };
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'Zeros'
        })
    ], InitializerExports, "zeros", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Initializers', namespace: 'initializers', useDocsFrom: 'Ones' })
    ], InitializerExports, "ones", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'Constant',
            configParamIndices: [0]
        })
    ], InitializerExports, "constant", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'RandomUniform',
            configParamIndices: [0]
        })
    ], InitializerExports, "randomUniform", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'RandomNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "randomNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'TruncatedNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "truncatedNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'Identity',
            configParamIndices: [0]
        })
    ], InitializerExports, "identity", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'VarianceScaling',
            configParamIndices: [0]
        })
    ], InitializerExports, "varianceScaling", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'GlorotUniform',
            configParamIndices: [0]
        })
    ], InitializerExports, "glorotUniform", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'GlorotNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "glorotNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'HeNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "heNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'LeCunNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "leCunNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'Orthogonal',
            configParamIndices: [0]
        })
    ], InitializerExports, "orthogonal", null);
    return InitializerExports;
}());
exports.InitializerExports = InitializerExports;
var MetricExports = (function () {
    function MetricExports() {
    }
    MetricExports.binaryAccuracy = function (yTrue, yPred) {
        return metrics_1.binaryAccuracy(yTrue, yPred);
    };
    MetricExports.binaryCrossentropy = function (yTrue, yPred) {
        return metrics_1.binaryCrossentropy(yTrue, yPred);
    };
    MetricExports.categoricalAccuracy = function (yTrue, yPred) {
        return metrics_1.categoricalAccuracy(yTrue, yPred);
    };
    MetricExports.categoricalCrossentropy = function (yTrue, yPred) {
        return losses_1.categoricalCrossentropy(yTrue, yPred);
    };
    MetricExports.cosineProximity = function (yTrue, yPred) {
        return losses_1.cosineProximity(yTrue, yPred);
    };
    MetricExports.prototype.meanAbsoluteError = function (yTrue, yPred) {
        return losses_1.meanAbsoluteError(yTrue, yPred);
    };
    MetricExports.prototype.meanAbsolutePercentageError = function (yTrue, yPred) {
        return losses_1.meanAbsolutePercentageError(yTrue, yPred);
    };
    MetricExports.prototype.MAPE = function (yTrue, yPred) {
        return losses_1.meanAbsolutePercentageError(yTrue, yPred);
    };
    MetricExports.prototype.mape = function (yTrue, yPred) {
        return losses_1.meanAbsolutePercentageError(yTrue, yPred);
    };
    MetricExports.meanSquaredError = function (yTrue, yPred) {
        return losses_1.meanSquaredError(yTrue, yPred);
    };
    MetricExports.MSE = function (yTrue, yPred) {
        return losses_1.meanSquaredError(yTrue, yPred);
    };
    MetricExports.mse = function (yTrue, yPred) {
        return losses_1.meanSquaredError(yTrue, yPred);
    };
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'meanAbsoluteError'
        })
    ], MetricExports.prototype, "meanAbsoluteError", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'meanAbsolutePercentageError'
        })
    ], MetricExports.prototype, "meanAbsolutePercentageError", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Metrics', namespace: 'metrics', useDocsFrom: 'binaryAccuracy' })
    ], MetricExports, "binaryAccuracy", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'binaryCrossentropy'
        })
    ], MetricExports, "binaryCrossentropy", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'categoricalAccuracy'
        })
    ], MetricExports, "categoricalAccuracy", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'categoricalCrossentropy'
        })
    ], MetricExports, "categoricalCrossentropy", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'cosineProximity'
        })
    ], MetricExports, "cosineProximity", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'meanSquaredError'
        })
    ], MetricExports, "meanSquaredError", null);
    return MetricExports;
}());
exports.MetricExports = MetricExports;
var RegularizerExports = (function () {
    function RegularizerExports() {
    }
    RegularizerExports.l1l2 = function (config) {
        return new regularizers_1.L1L2(config);
    };
    RegularizerExports.l1 = function (config) {
        return regularizers_1.l1(config);
    };
    RegularizerExports.l2 = function (config) {
        return regularizers_1.l2(config);
    };
    __decorate([
        tfjs_core_1.doc({
            heading: 'Regularizers',
            namespace: 'regularizers',
            useDocsFrom: 'L1L2',
            configParamIndices: [0]
        })
    ], RegularizerExports, "l1l2", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Regularizers',
            namespace: 'regularizers',
            useDocsFrom: 'L1L2',
            configParamIndices: [0]
        })
    ], RegularizerExports, "l1", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Regularizers',
            namespace: 'regularizers',
            useDocsFrom: 'L1L2',
            configParamIndices: [0]
        })
    ], RegularizerExports, "l2", null);
    return RegularizerExports;
}());
exports.RegularizerExports = RegularizerExports;

},{"./constraints":163,"./engine/topology":165,"./engine/training":166,"./initializers":170,"./layers/advanced_activations":171,"./layers/convolutional":172,"./layers/convolutional_depthwise":173,"./layers/core":174,"./layers/embeddings":175,"./layers/merge":176,"./layers/normalization":177,"./layers/padding":178,"./layers/pooling":179,"./layers/recurrent":180,"./layers/wrappers":182,"./losses":183,"./metrics":184,"./models":185,"./regularizers":187,"@tensorflow/tfjs-core":51}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var exports_1 = require("./exports");
var callbacks_1 = require("./callbacks");
exports.Callback = callbacks_1.Callback;
exports.CallbackList = callbacks_1.CallbackList;
exports.CustomCallback = callbacks_1.CustomCallback;
var training_1 = require("./engine/training");
exports.Model = training_1.Model;
var recurrent_1 = require("./layers/recurrent");
exports.RNN = recurrent_1.RNN;
var models_1 = require("./models");
exports.Sequential = models_1.Sequential;
var types_1 = require("./types");
exports.SymbolicTensor = types_1.SymbolicTensor;
var version_1 = require("./version");
exports.version_layers = version_1.version;
exports.model = exports_1.ModelExports.model;
exports.sequential = exports_1.ModelExports.sequential;
exports.loadModel = exports_1.ModelExports.loadModel;
exports.input = exports_1.ModelExports.input;
exports.layers = exports_1.LayerExports;
exports.constraints = exports_1.ConstraintExports;
exports.initializers = exports_1.InitializerExports;
exports.metrics = exports_1.MetricExports;
exports.regularizers = exports_1.RegularizerExports;

},{"./callbacks":161,"./engine/training":166,"./exports":168,"./layers/recurrent":180,"./models":185,"./types":188,"./version":194}],170:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var common_1 = require("./common");
var errors_1 = require("./errors");
var generic_utils_1 = require("./utils/generic_utils");
var math_utils_1 = require("./utils/math_utils");
exports.VALID_FAN_MODE_VALUES = ['fanIn', 'fanOut', 'fanAvg'];
function checkFanMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_FAN_MODE_VALUES, 'FanMode', value);
}
exports.checkFanMode = checkFanMode;
exports.VALID_DISTRIBUTION_VALUES = ['normal', 'uniform'];
function checkDistribution(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_DISTRIBUTION_VALUES, 'Distribution', value);
}
exports.checkDistribution = checkDistribution;
var Initializer = (function (_super) {
    __extends(Initializer, _super);
    function Initializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Initializer.prototype.fromConfigUsesCustomObjects = function () {
        return false;
    };
    Initializer.prototype.getConfig = function () {
        return {};
    };
    Initializer = __decorate([
        tfjs_core_1.doc({ heading: 'Initializers', subheading: 'Classes', namespace: 'initializers' })
    ], Initializer);
    return Initializer;
}(tfjs_core_1.serialization.Serializable));
exports.Initializer = Initializer;
var Zeros = (function (_super) {
    __extends(Zeros, _super);
    function Zeros() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Zeros.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.zeros(shape, dtype);
    };
    Zeros.className = 'Zeros';
    return Zeros;
}(Initializer));
exports.Zeros = Zeros;
tfjs_core_1.serialization.SerializationMap.register(Zeros);
var Ones = (function (_super) {
    __extends(Ones, _super);
    function Ones() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Ones.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.ones(shape, dtype);
    };
    Ones.className = 'Ones';
    return Ones;
}(Initializer));
exports.Ones = Ones;
tfjs_core_1.serialization.SerializationMap.register(Ones);
var Constant = (function (_super) {
    __extends(Constant, _super);
    function Constant(config) {
        var _this = _super.call(this) || this;
        _this.value = config.value;
        return _this;
    }
    Constant.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return K.scalarTimesArray(tfjs_core_1.scalar(_this.value), tfjs_core_1.ones(shape, dtype)); });
    };
    Constant.prototype.getConfig = function () {
        return {
            value: this.value,
        };
    };
    Constant.className = 'Constant';
    return Constant;
}(Initializer));
exports.Constant = Constant;
tfjs_core_1.serialization.SerializationMap.register(Constant);
var RandomUniform = (function (_super) {
    __extends(RandomUniform, _super);
    function RandomUniform(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MINVAL = -0.05;
        _this.DEFAULT_MAXVAL = 0.05;
        _this.minval = config.minval || _this.DEFAULT_MINVAL;
        _this.maxval = config.maxval || _this.DEFAULT_MAXVAL;
        _this.seed = config.seed;
        return _this;
    }
    RandomUniform.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.randomUniform(shape, this.minval, this.maxval, dtype);
    };
    RandomUniform.prototype.getConfig = function () {
        return { minval: this.minval, maxval: this.maxval, seed: this.seed };
    };
    RandomUniform.className = 'RandomUniform';
    return RandomUniform;
}(Initializer));
exports.RandomUniform = RandomUniform;
tfjs_core_1.serialization.SerializationMap.register(RandomUniform);
var RandomNormal = (function (_super) {
    __extends(RandomNormal, _super);
    function RandomNormal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MEAN = 0.;
        _this.DEFAULT_STDDEV = 0.05;
        _this.mean = config.mean || _this.DEFAULT_MEAN;
        _this.stddev = config.stddev || _this.DEFAULT_STDDEV;
        _this.seed = config.seed;
        return _this;
    }
    RandomNormal.prototype.apply = function (shape, dtype) {
        if (dtype === 'bool') {
            throw new errors_1.NotImplementedError("randomNormal does not support dType bool.");
        }
        return K.randomNormal(shape, this.mean, this.stddev, dtype, this.seed);
    };
    RandomNormal.prototype.getConfig = function () {
        return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    };
    RandomNormal.className = 'RandomNormal';
    return RandomNormal;
}(Initializer));
exports.RandomNormal = RandomNormal;
tfjs_core_1.serialization.SerializationMap.register(RandomNormal);
var TruncatedNormal = (function (_super) {
    __extends(TruncatedNormal, _super);
    function TruncatedNormal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MEAN = 0.;
        _this.DEFAULT_STDDEV = 0.05;
        _this.mean = config.mean || _this.DEFAULT_MEAN;
        _this.stddev = config.stddev || _this.DEFAULT_STDDEV;
        _this.seed = config.seed;
        return _this;
    }
    TruncatedNormal.prototype.apply = function (shape, dtype) {
        if (dtype === 'bool') {
            throw new errors_1.NotImplementedError("truncatedNormal does not support dType bool.");
        }
        return tfjs_core_1.truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed);
    };
    TruncatedNormal.prototype.getConfig = function () {
        return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    };
    TruncatedNormal.className = 'TruncatedNormal';
    return TruncatedNormal;
}(Initializer));
exports.TruncatedNormal = TruncatedNormal;
tfjs_core_1.serialization.SerializationMap.register(TruncatedNormal);
var Identity = (function (_super) {
    __extends(Identity, _super);
    function Identity(config) {
        var _this = _super.call(this) || this;
        _this.gain = config.gain != null ? tfjs_core_1.scalar(config.gain) : K.getScalar(1.0);
        return _this;
    }
    Identity.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (shape.length !== 2 || shape[0] !== shape[1]) {
                throw new errors_1.ValueError('Identity matrix initializer can only be used for' +
                    ' 2D square matrices.');
            }
            else {
                return K.scalarTimesArray(_this.gain, tfjs_core_1.eye(shape[0]));
            }
        });
    };
    Identity.prototype.getConfig = function () {
        return { gain: this.gain.get() };
    };
    Identity.className = 'Identity';
    return Identity;
}(Initializer));
exports.Identity = Identity;
tfjs_core_1.serialization.SerializationMap.register(Identity);
function computeFans(shape, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var fanIn;
    var fanOut;
    common_1.checkDataFormat(dataFormat);
    if (shape.length === 2) {
        fanIn = shape[0];
        fanOut = shape[1];
    }
    else if ([3, 4, 5].indexOf(shape.length) !== -1) {
        if (dataFormat === 'channelsFirst') {
            var receptiveFieldSize = math_utils_1.arrayProd(shape, 2);
            fanIn = shape[1] * receptiveFieldSize;
            fanOut = shape[0] * receptiveFieldSize;
        }
        else if (dataFormat === 'channelsLast') {
            var receptiveFieldSize = math_utils_1.arrayProd(shape, 0, shape.length - 2);
            fanIn = shape[shape.length - 2] * receptiveFieldSize;
            fanOut = shape[shape.length - 1] * receptiveFieldSize;
        }
    }
    else {
        var shapeProd = math_utils_1.arrayProd(shape);
        fanIn = Math.sqrt(shapeProd);
        fanOut = Math.sqrt(shapeProd);
    }
    return [fanIn, fanOut];
}
var VarianceScaling = (function (_super) {
    __extends(VarianceScaling, _super);
    function VarianceScaling(config) {
        var _this = _super.call(this) || this;
        if (config.scale < 0.0) {
            throw new errors_1.ValueError("scale must be a positive float. Got: " + config.scale);
        }
        _this.scale = config.scale == null ? 1.0 : config.scale;
        _this.mode = config.mode;
        checkFanMode(_this.mode);
        _this.distribution = config.distribution;
        checkDistribution(_this.distribution);
        _this.seed = config.seed;
        return _this;
    }
    VarianceScaling.prototype.apply = function (shape, dtype) {
        var fans = computeFans(shape);
        var fanIn = fans[0];
        var fanOut = fans[1];
        var scale = this.scale;
        if (this.mode === 'fanIn') {
            scale /= Math.max(1, fanIn);
        }
        else if (this.mode === 'fanOut') {
            scale /= Math.max(1, fanOut);
        }
        else {
            scale /= Math.max(1, (fanIn + fanOut) / 2);
        }
        if (this.distribution === 'normal') {
            var stddev = Math.sqrt(scale);
            if (dtype === 'bool') {
                throw new errors_1.NotImplementedError(this.getClassName() + " does not support dType bool.");
            }
            return tfjs_core_1.truncatedNormal(shape, 0, stddev, dtype, this.seed);
        }
        else {
            var limit = Math.sqrt(3 * scale);
            return tfjs_core_1.randomUniform(shape, -limit, limit, dtype);
        }
    };
    VarianceScaling.prototype.getConfig = function () {
        return {
            scale: this.scale,
            mode: this.mode,
            distribution: this.distribution,
            seed: this.seed
        };
    };
    VarianceScaling.className = 'VarianceScaling';
    return VarianceScaling;
}(Initializer));
exports.VarianceScaling = VarianceScaling;
tfjs_core_1.serialization.SerializationMap.register(VarianceScaling);
var GlorotUniform = (function (_super) {
    __extends(GlorotUniform, _super);
    function GlorotUniform(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanAvg',
            distribution: 'uniform',
            seed: config == null ? null : config.seed
        }) || this;
    }
    GlorotUniform.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return GlorotUniform;
}(VarianceScaling));
exports.GlorotUniform = GlorotUniform;
var GlorotNormal = (function (_super) {
    __extends(GlorotNormal, _super);
    function GlorotNormal(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanAvg',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    GlorotNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return GlorotNormal;
}(VarianceScaling));
exports.GlorotNormal = GlorotNormal;
var HeNormal = (function (_super) {
    __extends(HeNormal, _super);
    function HeNormal(config) {
        return _super.call(this, {
            scale: 2.0,
            mode: 'fanIn',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    HeNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return HeNormal;
}(VarianceScaling));
exports.HeNormal = HeNormal;
var LeCunNormal = (function (_super) {
    __extends(LeCunNormal, _super);
    function LeCunNormal(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanIn',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    LeCunNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return LeCunNormal;
}(VarianceScaling));
exports.LeCunNormal = LeCunNormal;
var Orthogonal = (function (_super) {
    __extends(Orthogonal, _super);
    function Orthogonal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_GAIN = 1;
        _this.gain = config.gain == null ? _this.DEFAULT_GAIN : config.gain;
        _this.seed = config.seed;
        if (_this.seed != null) {
            throw new errors_1.NotImplementedError('Random seed is not implemented for Orthogonal Initializer yet.');
        }
        return _this;
    }
    Orthogonal.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (shape.length !== 2) {
                throw new errors_1.NotImplementedError('The Orthogonal Initializer does not support non-2D shapes yet.');
            }
            if (shape[0] * shape[1] > 2000) {
                console.warn("Orthogonal initializer is being called on a matrix with more " +
                    ("than 2000 (" + shape[0] * shape[1] + ") elements: ") +
                    "Slowness may result.");
            }
            var normalizedShape = shape[0] > shape[1] ? [shape[1], shape[0]] : shape;
            var a = K.randomNormal(normalizedShape, 0, 1, 'float32');
            var q = tfjs_core_1.linalg.gramSchmidt(a);
            if (shape[0] > shape[1]) {
                q = q.transpose();
            }
            return K.scalarTimesArray(K.getScalar(_this.gain), q);
        });
    };
    Orthogonal.prototype.getConfig = function () {
        return {
            gain: this.gain,
            seed: this.seed,
        };
    };
    Orthogonal.className = 'Orthogonal';
    return Orthogonal;
}(Initializer));
exports.Orthogonal = Orthogonal;
tfjs_core_1.serialization.SerializationMap.register(Orthogonal);
exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'constant': 'Constant',
    'glorotNormal': 'GlorotNormal',
    'glorotUniform': 'GlorotUniform',
    'heNormal': 'HeNormal',
    'identity': 'Identity',
    'leCunNormal': 'LeCunNormal',
    'ones': 'Ones',
    'orthogonal': 'Orthogonal',
    'randomNormal': 'RandomNormal',
    'randomUniform': 'RandomUniform',
    'truncatedNormal': 'TruncatedNormal',
    'varianceScaling': 'VarianceScaling',
    'zeros': 'Zeros'
};
function deserializeInitializer(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'initializer');
}
function serializeInitializer(initializer) {
    return generic_utils_1.serializeKerasObject(initializer);
}
exports.serializeInitializer = serializeInitializer;
function getInitializer(identifier) {
    if (typeof identifier === 'string') {
        var className = identifier in exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        if (className === 'GlorotUniform') {
            return new GlorotUniform();
        }
        else if (className === 'GlorotNormal') {
            return new GlorotNormal();
        }
        else if (className === 'HeNormal') {
            return new HeNormal();
        }
        else if (className === 'LeCunNormal') {
            return new LeCunNormal();
        }
        else {
            var config = { className: className, config: {} };
            return deserializeInitializer(config);
        }
    }
    else if (identifier instanceof Initializer) {
        return identifier;
    }
    else {
        return deserializeInitializer(identifier);
    }
}
exports.getInitializer = getInitializer;

},{"./backend/tfjs_backend":160,"./common":162,"./errors":167,"./utils/generic_utils":190,"./utils/math_utils":191,"@tensorflow/tfjs-core":51}],171:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var tfjs_backend_1 = require("../backend/tfjs_backend");
var tfjs_backend_2 = require("../backend/tfjs_backend");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils = require("../utils/generic_utils");
var LeakyReLU = (function (_super) {
    __extends(LeakyReLU, _super);
    function LeakyReLU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_ALPHA = 0.3;
        if (config == null) {
            config = {};
        }
        _this.alpha = config.alpha == null ? _this.DEFAULT_ALPHA : config.alpha;
        return _this;
    }
    LeakyReLU.prototype.call = function (inputs, kwargs) {
        var x = generic_utils.getExactlyOneTensor(inputs);
        return tfjs_core_1.leakyRelu(x, this.alpha);
    };
    LeakyReLU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    LeakyReLU.prototype.getConfig = function () {
        var config = { alpha: this.alpha };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    LeakyReLU.className = 'LeakyReLU';
    return LeakyReLU;
}(topology_1.Layer));
exports.LeakyReLU = LeakyReLU;
tfjs_core_1.serialization.SerializationMap.register(LeakyReLU);
var ELU = (function (_super) {
    __extends(ELU, _super);
    function ELU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_ALPHA = 1.0;
        if (config == null) {
            config = {};
        }
        if (config.alpha != null && config.alpha !== _this.DEFAULT_ALPHA) {
            throw new errors_1.NotImplementedError("Non-default alpha value (" + config.alpha + ") is not supported by the " +
                "ELU layer yet.");
        }
        _this.alpha = config.alpha == null ? _this.DEFAULT_ALPHA : config.alpha;
        return _this;
    }
    ELU.prototype.call = function (inputs, kwargs) {
        var x = generic_utils.getExactlyOneTensor(inputs);
        return tfjs_core_1.elu(x);
    };
    ELU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    ELU.prototype.getConfig = function () {
        var config = { alpha: this.alpha };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ELU.className = 'ELU';
    return ELU;
}(topology_1.Layer));
exports.ELU = ELU;
tfjs_core_1.serialization.SerializationMap.register(ELU);
var ThresholdedReLU = (function (_super) {
    __extends(ThresholdedReLU, _super);
    function ThresholdedReLU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_THETA = 1.0;
        if (config == null) {
            config = {};
        }
        _this.theta = config.theta == null ? _this.DEFAULT_THETA : config.theta;
        _this.thetaTensor = tfjs_backend_2.getScalar(_this.theta);
        return _this;
    }
    ThresholdedReLU.prototype.call = function (inputs, kwargs) {
        var x = generic_utils.getExactlyOneTensor(inputs);
        return x.mul(tfjs_backend_1.cast(x.greater(this.thetaTensor), 'float32'));
    };
    ThresholdedReLU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    ThresholdedReLU.prototype.getConfig = function () {
        var config = { theta: this.theta };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ThresholdedReLU.className = 'ThresholdedReLU';
    return ThresholdedReLU;
}(topology_1.Layer));
exports.ThresholdedReLU = ThresholdedReLU;
tfjs_core_1.serialization.SerializationMap.register(ThresholdedReLU);
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_AXIS = 1.0;
        if (config == null) {
            config = {};
        }
        _this.softmax = new activations_1.Softmax().apply;
        _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;
        return _this;
    }
    Softmax.prototype.call = function (inputs, kwargs) {
        var x = generic_utils.getExactlyOneTensor(inputs);
        return this.softmax(x, this.axis);
    };
    Softmax.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    Softmax.prototype.getConfig = function () {
        var config = { axis: this.axis };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Softmax.className = 'Softmax';
    return Softmax;
}(topology_1.Layer));
exports.Softmax = Softmax;
tfjs_core_1.serialization.SerializationMap.register(Softmax);

},{"../activations":158,"../backend/tfjs_backend":160,"../engine/topology":165,"../errors":167,"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],172:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var conv_utils_1 = require("../utils/conv_utils");
var generic_utils = require("../utils/generic_utils");
function preprocessConv2DInput(x, dataFormat) {
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        if (dataFormat === 'channelsFirst') {
            return tfc.transpose(x, [0, 2, 3, 1]);
        }
        else {
            return x;
        }
    });
}
exports.preprocessConv2DInput = preprocessConv2DInput;
function conv1dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = 1; }
    if (padding === void 0) { padding = 'valid'; }
    if (dilationRate === void 0) { dilationRate = 1; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        if (x.shape.length !== 3) {
            throw new errors_1.ValueError("The input of a conv1dWithBias operation should be 3, but is " +
                (x.shape.length + " instead."));
        }
        if (kernel.shape.length !== 3) {
            throw new errors_1.ValueError("The kernel for a conv1dWithBias operation should be 3, but is " +
                (kernel.shape.length + " instead"));
        }
        if (bias != null && bias.shape.length !== 1) {
            throw new errors_1.ValueError("The bias for a conv1dWithBias operation should be 1, but is " +
                (kernel.shape.length + " instead"));
        }
        if (dataFormat === 'channelsFirst') {
            x = tfc.transpose(x, [0, 2, 1]);
        }
        if (padding === 'causal') {
            throw new errors_1.NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' +
                'implemented yet.');
        }
        var y = tfc.conv1d(x, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NWC', dilationRate);
        if (bias != null) {
            y = K.biasAdd(y, bias);
        }
        return y;
    });
}
exports.conv1dWithBias = conv1dWithBias;
function conv1d(x, kernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = 1; }
    if (padding === void 0) { padding = 'valid'; }
    if (dilationRate === void 0) { dilationRate = 1; }
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        return conv1dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);
    });
}
exports.conv1d = conv1d;
function conv2d(x, kernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        return conv2dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);
    });
}
exports.conv2d = conv2d;
function conv2dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        if (x.rank !== 3 && x.rank !== 4) {
            throw new errors_1.ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received " +
                (x.rank + "."));
        }
        if (kernel.rank !== 3 && kernel.rank !== 4) {
            throw new errors_1.ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received " +
                (x.rank + "."));
        }
        var y = preprocessConv2DInput(x, dataFormat);
        if (padding === 'causal') {
            throw new errors_1.NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' +
                'implemented yet.');
        }
        y = tfc.conv2d(y, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NHWC', dilationRate);
        if (bias != null) {
            y = K.biasAdd(y, bias);
        }
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.conv2dWithBias = conv2dWithBias;
var Conv = (function (_super) {
    __extends(Conv, _super);
    function Conv(rank, config) {
        var _this = _super.call(this, config) || this;
        _this.kernel = null;
        _this.bias = null;
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.rank = rank;
        if (_this.rank !== 1 && _this.rank !== 2) {
            throw new errors_1.NotImplementedError("Convolution layer for rank other than 1 or 2 (" + _this.rank + ") is " +
                "not implemented yet.");
        }
        _this.filters = config.filters;
        _this.kernelSize = conv_utils_1.normalizeArray(config.kernelSize, rank, 'kernelSize');
        _this.strides = conv_utils_1.normalizeArray(config.strides == null ? 1 : config.strides, rank, 'strides');
        _this.padding = config.padding == null ? 'valid' : config.padding;
        common_2.checkPaddingMode(_this.padding);
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        _this.dilationRate = config.dilationRate == null ? 1 : config.dilationRate;
        if (_this.rank === 1 &&
            (Array.isArray(_this.dilationRate) &&
                _this.dilationRate.length !== 1)) {
            throw new errors_1.ValueError("dilationRate must be a number or an array of a single number " +
                "for 1D convolution, but received " +
                ("" + JSON.stringify(_this.dilationRate)));
        }
        if (_this.rank === 2) {
            if (typeof _this.dilationRate === 'number') {
                _this.dilationRate = [_this.dilationRate, _this.dilationRate];
            }
            else if (_this.dilationRate.length !== 2) {
                throw new errors_1.ValueError("dilationRate must be a number or array of two numbers for 2D " +
                    ("convolution, but received " + JSON.stringify(_this.dilationRate)));
            }
        }
        _this.activation = activations_1.getActivation(config.activation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        return _this;
    }
    Conv.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
            throw new errors_1.ValueError("The channel dimension of the input should be defined. " +
                ("Found " + inputShape[channelAxis]));
        }
        var inputDim = inputShape[channelAxis];
        var kernelShape = this.kernelSize.concat([inputDim, this.filters]);
        this.kernel = this.addWeight('kernel', kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec = [{ ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a) }];
        this.built = true;
        var _a;
    };
    Conv.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.getExactlyOneTensor(inputs);
            var outputs;
            var biasValue = _this.bias == null ? null : _this.bias.read();
            if (_this.rank === 1) {
                outputs = conv1dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides[0], _this.padding, _this.dataFormat, _this.dilationRate);
            }
            else if (_this.rank === 2) {
                outputs = conv2dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides, _this.padding, _this.dataFormat, _this.dilationRate);
            }
            else if (_this.rank === 3) {
                throw new errors_1.NotImplementedError('3D convolution is not implemented yet.');
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    Conv.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var newSpace = [];
        var space = (this.dataFormat === 'channelsLast') ?
            inputShape.slice(1, inputShape.length - 1) :
            inputShape.slice(2);
        for (var i = 0; i < space.length; ++i) {
            var newDim = conv_utils_1.convOutputLength(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === 'number' ? this.dilationRate :
                this.dilationRate[i]);
            newSpace.push(newDim);
        }
        var outputShape = [inputShape[0]];
        if (this.dataFormat === 'channelsLast') {
            outputShape = outputShape.concat(newSpace);
            outputShape.push(this.filters);
        }
        else {
            outputShape.push(this.filters);
            outputShape = outputShape.concat(newSpace);
        }
        return outputShape;
    };
    Conv.prototype.getConfig = function () {
        var config = {
            rank: this.rank,
            filters: this.filters,
            kernelSize: this.kernelSize,
            strides: this.strides,
            padding: this.padding,
            dataFormat: this.dataFormat,
            dilationRate: this.dilationRate,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return Conv;
}(topology_1.Layer));
exports.Conv = Conv;
var Conv2D = (function (_super) {
    __extends(Conv2D, _super);
    function Conv2D(config) {
        return _super.call(this, 2, config) || this;
    }
    Conv2D.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        return config;
    };
    Conv2D.className = 'Conv2D';
    return Conv2D;
}(Conv));
exports.Conv2D = Conv2D;
tfjs_core_1.serialization.SerializationMap.register(Conv2D);
var Conv2DTranspose = (function (_super) {
    __extends(Conv2DTranspose, _super);
    function Conv2DTranspose(config) {
        var _this = _super.call(this, config) || this;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        if (_this.padding !== 'same' && _this.padding !== 'valid') {
            throw new errors_1.ValueError("Conv2DTranspose currently supports only padding modes 'same' " +
                ("and 'valid', but received padding mode " + _this.padding));
        }
        return _this;
    }
    Conv2DTranspose.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        if (inputShape.length !== 4) {
            throw new errors_1.ValueError('Input should have rank 4; Received input shape: ' +
                JSON.stringify(inputShape));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
            throw new errors_1.ValueError('The channel dimension of the inputs should be defined. ' +
                'Found `None`.');
        }
        var inputDim = inputShape[channelAxis];
        var kernelShape = this.kernelSize.concat([this.filters, inputDim]);
        this.kernel = this.addWeight('kernel', kernelShape, 'float32', this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: 4, axes: (_a = {}, _a[channelAxis] = inputDim, _a) })];
        this.built = true;
        var _a;
    };
    Conv2DTranspose.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfc.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (input.shape.length !== 4) {
                throw new errors_1.ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but " +
                    ("received a tensor of rank-" + input.shape.length));
            }
            var inputShape = input.shape;
            var batchSize = inputShape[0];
            var hAxis;
            var wAxis;
            if (_this.dataFormat === 'channelsFirst') {
                hAxis = 2;
                wAxis = 3;
            }
            else {
                hAxis = 1;
                wAxis = 2;
            }
            var height = inputShape[hAxis];
            var width = inputShape[wAxis];
            var kernelH = _this.kernelSize[0];
            var kernelW = _this.kernelSize[1];
            var strideH = _this.strides[0];
            var strideW = _this.strides[1];
            var outHeight = conv_utils_1.deconvLength(height, strideH, kernelH, _this.padding);
            var outWidth = conv_utils_1.deconvLength(width, strideW, kernelW, _this.padding);
            var outputShape = [batchSize, outHeight, outWidth, _this.filters];
            if (_this.dataFormat !== 'channelsLast') {
                input = tfc.transpose(input, [0, 2, 3, 1]);
            }
            var outputs = tfc.conv2dTranspose(input, _this.kernel.read(), outputShape, _this.strides, _this.padding);
            if (_this.dataFormat !== 'channelsLast') {
                outputs = tfc.transpose(outputs, [0, 3, 1, 2]);
            }
            if (_this.bias != null) {
                outputs =
                    K.biasAdd(outputs, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    Conv2DTranspose.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var outputShape = inputShape.slice();
        var channelAxis;
        var heightAxis;
        var widthAxis;
        if (this.dataFormat === 'channelsFirst') {
            channelAxis = 1;
            heightAxis = 2;
            widthAxis = 3;
        }
        else {
            channelAxis = 3;
            heightAxis = 1;
            widthAxis = 2;
        }
        var kernelH = this.kernelSize[0];
        var kernelW = this.kernelSize[1];
        var strideH = this.strides[0];
        var strideW = this.strides[1];
        outputShape[channelAxis] = this.filters;
        outputShape[heightAxis] =
            conv_utils_1.deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
        outputShape[widthAxis] =
            conv_utils_1.deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
        return outputShape;
    };
    Conv2DTranspose.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['dilationRate'];
        return config;
    };
    Conv2DTranspose.className = 'Conv2DTranspose';
    return Conv2DTranspose;
}(Conv2D));
exports.Conv2DTranspose = Conv2DTranspose;
tfjs_core_1.serialization.SerializationMap.register(Conv2DTranspose);
var SeparableConv = (function (_super) {
    __extends(SeparableConv, _super);
    function SeparableConv(rank, config) {
        var _this = _super.call(this, rank, config) || this;
        _this.DEFAULT_DEPTHWISE_INITIALIZER = 'glorotUniform';
        _this.DEFAULT_POINTWISE_INITIALIZER = 'glorotUniform';
        _this.depthwiseKernel = null;
        _this.pointwiseKernel = null;
        if (config.filters == null) {
            throw new errors_1.ValueError('The `filters` configuration field is required by SeparableConv, ' +
                'but is unspecified.');
        }
        if (config.kernelInitializer != null || config.kernelRegularizer != null ||
            config.kernelConstraint != null) {
            throw new errors_1.ValueError('Fields kernelInitializer, kernelRegularizer and kernelConstraint ' +
                'are invalid for SeparableConv2D. Use depthwiseInitializer, ' +
                'depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, ' +
                'pointwiseRegularizer and pointwiseConstraint instead.');
        }
        if (config.padding != null && config.padding !== 'same' &&
            config.padding !== 'valid') {
            throw new errors_1.ValueError("SeparableConv" + _this.rank + "D supports only padding modes: " +
                ("'same' and 'valid', but received " + JSON.stringify(config.padding)));
        }
        _this.depthMultiplier =
            config.depthMultiplier == null ? 1 : config.depthMultiplier;
        _this.depthwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_DEPTHWISE_INITIALIZER);
        _this.depthwiseRegularizer = regularizers_1.getRegularizer(config.depthwiseRegularizer);
        _this.depthwiseConstraint = constraints_1.getConstraint(config.depthwiseConstraint);
        _this.pointwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_POINTWISE_INITIALIZER);
        _this.pointwiseRegularizer = regularizers_1.getRegularizer(config.pointwiseRegularizer);
        _this.pointwiseConstraint = constraints_1.getConstraint(config.pointwiseConstraint);
        return _this;
    }
    SeparableConv.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        if (inputShape.length < this.rank + 2) {
            throw new errors_1.ValueError("Inputs to SeparableConv" + this.rank + "D should have rank " +
                (this.rank + 2 + ", but received input shape: ") +
                ("" + JSON.stringify(inputShape)));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
            throw new errors_1.ValueError("The channel dimension of the inputs should be defined, " +
                ("but found " + JSON.stringify(inputShape[channelAxis])));
        }
        var inputDim = inputShape[channelAxis];
        var depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);
        var pointwiseKernelShape = [];
        for (var i = 0; i < this.rank; ++i) {
            pointwiseKernelShape.push(1);
        }
        pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);
        var trainable = true;
        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, 'float32', this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);
        this.pointwiseKernel = this.addWeight('pointwise_kernel', pointwiseKernelShape, 'float32', this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a) })];
        this.built = true;
        var _a;
    };
    SeparableConv.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.getExactlyOneTensor(inputs);
            var output;
            if (_this.rank === 1) {
                throw new errors_1.NotImplementedError('1D separable convolution is not implemented yet.');
            }
            else if (_this.rank === 2) {
                if (_this.dataFormat === 'channelsFirst') {
                    inputs = tfc.transpose(inputs, [0, 2, 3, 1]);
                }
                output = tfc.separableConv2d(inputs, _this.depthwiseKernel.read(), _this.pointwiseKernel.read(), _this.strides, _this.padding, _this.dilationRate, 'NHWC');
            }
            if (_this.useBias) {
                output = K.biasAdd(output, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            if (_this.dataFormat === 'channelsFirst') {
                output = tfc.transpose(output, [0, 3, 1, 2]);
            }
            return output;
        });
    };
    SeparableConv.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        delete config['kernelInitializer'];
        delete config['kernelRegularizer'];
        delete config['kernelConstraint'];
        config['depthwiseInitializer'] =
            initializers_1.serializeInitializer(this.depthwiseInitializer);
        config['pointwiseInitializer'] =
            initializers_1.serializeInitializer(this.pointwiseInitializer);
        config['depthwiseRegularizer'] =
            regularizers_1.serializeRegularizer(this.depthwiseRegularizer);
        config['pointwiseRegularizer'] =
            regularizers_1.serializeRegularizer(this.pointwiseRegularizer);
        config['depthwiseConstraint'] =
            constraints_1.serializeConstraint(this.depthwiseConstraint);
        config['pointwiseConstraint'] =
            constraints_1.serializeConstraint(this.pointwiseConstraint);
        return config;
    };
    SeparableConv.className = 'SeparableConv';
    return SeparableConv;
}(Conv));
exports.SeparableConv = SeparableConv;
var SeparableConv2D = (function (_super) {
    __extends(SeparableConv2D, _super);
    function SeparableConv2D(config) {
        return _super.call(this, 2, config) || this;
    }
    SeparableConv2D.className = 'SeparableConv2D';
    return SeparableConv2D;
}(SeparableConv));
exports.SeparableConv2D = SeparableConv2D;
tfjs_core_1.serialization.SerializationMap.register(SeparableConv2D);
var Conv1D = (function (_super) {
    __extends(Conv1D, _super);
    function Conv1D(config) {
        var _this = _super.call(this, 1, config) || this;
        _this.inputSpec = [{ ndim: 3 }];
        return _this;
    }
    Conv1D.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        delete config['dataFormat'];
        return config;
    };
    Conv1D.className = 'Conv1D';
    return Conv1D;
}(Conv));
exports.Conv1D = Conv1D;
tfjs_core_1.serialization.SerializationMap.register(Conv1D);
var Cropping2D = (function (_super) {
    __extends(Cropping2D, _super);
    function Cropping2D(config) {
        var _this = _super.call(this, config) || this;
        if (typeof config.cropping === 'number')
            _this.cropping = [
                [config.cropping, config.cropping], [config.cropping, config.cropping]
            ];
        else if (typeof config.cropping[0] === 'number')
            _this.cropping = [
                [config.cropping[0], config.cropping[0]],
                [config.cropping[1], config.cropping[1]]
            ];
        else
            _this.cropping = config.cropping;
        _this.dataFormat =
            config.dataFormat === undefined ? 'channelsLast' : config.dataFormat;
        _this.inputSpec = [{ ndim: 4 }];
        return _this;
    }
    Cropping2D.prototype.computeOutputShape = function (inputShape) {
        if (this.dataFormat === 'channelsFirst')
            return [
                inputShape[0], inputShape[1],
                inputShape[2] - this.cropping[0][0] - this.cropping[0][1],
                inputShape[2] - this.cropping[1][0] - this.cropping[1][1]
            ];
        else
            return [
                inputShape[0],
                inputShape[1] - this.cropping[0][0] - this.cropping[0][1],
                inputShape[2] - this.cropping[1][0] - this.cropping[1][1], inputShape[3]
            ];
    };
    Cropping2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[1] - _this.cropping[0][0] - _this.cropping[0][1], 2);
                return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[2] - _this.cropping[1][1] - _this.cropping[1][0], 3);
            }
            else {
                var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[2] - _this.cropping[0][0] - _this.cropping[0][1], 3);
                return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[3] - _this.cropping[1][1] - _this.cropping[1][0], 4);
            }
        });
    };
    Cropping2D.prototype.getConfig = function () {
        var config = { cropping: this.cropping, dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Cropping2D.className = 'Cropping2D';
    return Cropping2D;
}(topology_1.Layer));
exports.Cropping2D = Cropping2D;
tfjs_core_1.serialization.SerializationMap.register(Cropping2D);
var UpSampling2D = (function (_super) {
    __extends(UpSampling2D, _super);
    function UpSampling2D(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_SIZE = [2, 2];
        _this.inputSpec = [{ ndim: 4 }];
        _this.size = config.size === undefined ? _this.DEFAULT_SIZE : config.size;
        _this.dataFormat =
            config.dataFormat === undefined ? 'channelsLast' : config.dataFormat;
        return _this;
    }
    UpSampling2D.prototype.computeOutputShape = function (inputShape) {
        if (this.dataFormat === 'channelsFirst') {
            var height = this.size[0] * inputShape[2];
            var width = this.size[1] * inputShape[3];
            return [inputShape[0], inputShape[1], height, width];
        }
        else {
            var height = this.size[0] * inputShape[1];
            var width = this.size[1] * inputShape[2];
            return [inputShape[0], height, width, inputShape[3]];
        }
    };
    UpSampling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfc.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            var inputShape = input.shape;
            if (_this.dataFormat === 'channelsFirst') {
                input = tfc.transpose(input, [0, 2, 3, 1]);
                var height = _this.size[0] * inputShape[2];
                var width = _this.size[1] * inputShape[3];
                var resized = input.resizeNearestNeighbor([height, width]);
                return tfc.transpose(resized, [0, 3, 1, 2]);
            }
            else {
                var height = _this.size[0] * inputShape[1];
                var width = _this.size[1] * inputShape[2];
                return input.resizeNearestNeighbor([height, width]);
            }
        });
    };
    UpSampling2D.prototype.getConfig = function () {
        var config = { size: this.size, dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    UpSampling2D.className = 'UpSampling2D';
    return UpSampling2D;
}(topology_1.Layer));
exports.UpSampling2D = UpSampling2D;
tfjs_core_1.serialization.SerializationMap.register(UpSampling2D);

},{"../activations":158,"../backend/common":159,"../backend/tfjs_backend":160,"../common":162,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/conv_utils":189,"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],173:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var constraints_1 = require("../constraints");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var conv_utils_1 = require("../utils/conv_utils");
var generic_utils_1 = require("../utils/generic_utils");
var convolutional_1 = require("./convolutional");
function depthwiseConv2d(x, depthwiseKernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        var y = convolutional_1.preprocessConv2DInput(x, dataFormat);
        if (x.rank !== 4) {
            throw new errors_1.ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead " +
                (x.rank + "-D"));
        }
        if (depthwiseKernel.rank !== 4) {
            throw new errors_1.ValueError("depthwiseKernel is required to be 4-D, but is instead " +
                (depthwiseKernel.rank + "-D"));
        }
        y = tfc.depthwiseConv2d(y, depthwiseKernel, strides, padding === 'same' ? 'same' : 'valid', 'NHWC', dilationRate);
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.depthwiseConv2d = depthwiseConv2d;
var DepthwiseConv2D = (function (_super) {
    __extends(DepthwiseConv2D, _super);
    function DepthwiseConv2D(config) {
        var _this = _super.call(this, config) || this;
        _this.depthwiseKernel = null;
        _this.depthMultiplier =
            config.depthMultiplier == null ? 1 : config.depthMultiplier;
        _this.depthwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.depthwiseConstraint = constraints_1.getConstraint(config.depthwiseConstraint);
        _this.depthwiseRegularizer = regularizers_1.getRegularizer(config.depthwiseRegularizer);
        return _this;
    }
    DepthwiseConv2D.prototype.build = function (inputShape) {
        inputShape = generic_utils_1.getExactlyOneShape(inputShape);
        if (inputShape.length < 4) {
            throw new errors_1.ValueError("Inputs to DepthwiseConv2D should have rank 4. " +
                ("Received input shape: " + JSON.stringify(inputShape) + "."));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : 3;
        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
            throw new errors_1.ValueError('The channel dimension of the inputs to DepthwiseConv2D should ' +
                ("be defined, but is not (" + inputShape[channelAxis] + ")."));
        }
        var inputDim = inputShape[channelAxis];
        var depthwiseKernelShape = [
            this.kernelSize[0], this.kernelSize[1], inputDim, this.depthMultiplier
        ];
        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    DepthwiseConv2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils_1.getExactlyOneTensor(inputs);
            var outputs = depthwiseConv2d(inputs, _this.depthwiseKernel.read(), _this.strides, _this.padding, _this.dataFormat, null);
            if (_this.useBias) {
                outputs = K.biasAdd(outputs, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    DepthwiseConv2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils_1.getExactlyOneShape(inputShape);
        var rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];
        var cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];
        var outFilters = this.dataFormat === 'channelsFirst' ?
            inputShape[1] * this.depthMultiplier :
            inputShape[3] * this.depthMultiplier;
        var outRows = conv_utils_1.convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);
        var outCols = conv_utils_1.convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === 'channelsFirst') {
            return [inputShape[0], outFilters, outRows, outCols];
        }
        else {
            return [inputShape[0], outRows, outCols, outFilters];
        }
    };
    DepthwiseConv2D.className = 'DepthwiseConv2D';
    return DepthwiseConv2D;
}(convolutional_1.Conv2D));
exports.DepthwiseConv2D = DepthwiseConv2D;
tfjs_core_1.serialization.SerializationMap.register(DepthwiseConv2D);

},{"../backend/common":159,"../backend/tfjs_backend":160,"../common":162,"../constraints":163,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/conv_utils":189,"../utils/generic_utils":190,"./convolutional":172,"@tensorflow/tfjs-core":51}],174:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var generic_utils = require("../utils/generic_utils");
var generic_utils_1 = require("../utils/generic_utils");
var math_utils = require("../utils/math_utils");
var Dropout = (function (_super) {
    __extends(Dropout, _super);
    function Dropout(config) {
        var _this = _super.call(this, config) || this;
        _this.rate = Math.max(Math.min(config.rate, 1), 0);
        _this.rateScalar = K.getScalar(_this.rate);
        _this.noiseShape = config.noiseShape;
        _this.seed = config.seed;
        if (_this.seed != null) {
            throw new errors_1.NotImplementedError('Non-default seed is not implemented in Dropout layer yet: ' +
                _this.seed);
        }
        _this.supportsMasking = true;
        return _this;
    }
    Dropout.prototype.getNoiseShape = function (input) {
        if (this.noiseShape == null) {
            return this.noiseShape;
        }
        var inputShape = input.shape;
        var noiseShape = [];
        for (var i = 0; i < this.noiseShape.length; ++i) {
            noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);
        }
        return noiseShape;
    };
    Dropout.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (_this.noiseShape != null &&
                !tfjs_core_1.util.arraysEqual(input.shape, _this.noiseShape)) {
                throw new errors_1.NotImplementedError('Non-default noise shape is not implemented in Dropout ' +
                    'layer yet: ' + JSON.stringify(_this.noiseShape));
            }
            if (0 < _this.rate && _this.rate < 1) {
                var training = kwargs['training'] == null ? false : kwargs['training'];
                var noiseShape_1 = _this.getNoiseShape(input);
                var output = K.inTrainPhase(function () { return K.dropout(input, _this.rateScalar, noiseShape_1, _this.seed); }, function () { return input; }, training);
                return output;
            }
            return inputs;
        });
    };
    Dropout.prototype.getConfig = function () {
        var config = {
            rate: this.rate,
            noiseShape: this.noiseShape,
            seed: this.seed,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Dropout.className = 'Dropout';
    return Dropout;
}(topology_1.Layer));
exports.Dropout = Dropout;
tfjs_core_1.serialization.SerializationMap.register(Dropout);
var Dense = (function (_super) {
    __extends(Dense, _super);
    function Dense(config) {
        var _this = _super.call(this, config) || this;
        _this.activation = null;
        _this.useBias = true;
        _this.kernel = null;
        _this.bias = null;
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        if (config.batchInputShape == null && config.inputShape == null &&
            config.inputDim != null) {
            var batchSize = null;
            if (config.batchSize != null) {
                batchSize = config.batchSize;
            }
            _this.batchInputShape = [batchSize, config.inputDim];
        }
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation);
        if (config.useBias != null) {
            _this.useBias = config.useBias;
        }
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        _this.inputSpec = [{ minNDim: 2 }];
        return _this;
    }
    Dense.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var inputLastDim = inputShape[inputShape.length - 1];
        if (this.kernel == null) {
            this.kernel = this.addWeight('kernel', [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
            if (this.useBias) {
                this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
            }
        }
        this.inputSpec = [{ minNDim: 2, axes: (_a = {}, _a[-1] = inputLastDim, _a) }];
        this.built = true;
        var _a;
    };
    Dense.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var outputShape = inputShape.slice();
        outputShape[outputShape.length - 1] = this.units;
        return outputShape;
    };
    Dense.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            var output = K.dot(input, _this.kernel.read());
            if (_this.bias != null) {
                output = K.biasAdd(output, _this.bias.read());
            }
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            return output;
        });
    };
    Dense.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Dense.className = 'Dense';
    return Dense;
}(topology_1.Layer));
exports.Dense = Dense;
tfjs_core_1.serialization.SerializationMap.register(Dense);
var Flatten = (function (_super) {
    __extends(Flatten, _super);
    function Flatten(config) {
        var _this = _super.call(this, config || {}) || this;
        _this.inputSpec = [{ minNDim: 3 }];
        return _this;
    }
    Flatten.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        for (var _i = 0, _a = inputShape.slice(1); _i < _a.length; _i++) {
            var dim = _a[_i];
            if (dim == null) {
                throw new errors_1.ValueError("The shape of the input to \"Flatten\" is not fully defined " +
                    ("(got " + inputShape.slice(1) + "). Make sure to pass a complete ") +
                    "\"input_shape\" or \"batch_input_shape\" argument to the first " +
                    "layer in your model.");
            }
        }
        return [inputShape[0], math_utils.arrayProd(inputShape, 1)];
    };
    Flatten.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            return K.batchFlatten(generic_utils.getExactlyOneTensor(inputs));
        });
    };
    Flatten.className = 'Flatten';
    return Flatten;
}(topology_1.Layer));
exports.Flatten = Flatten;
tfjs_core_1.serialization.SerializationMap.register(Flatten);
var Activation = (function (_super) {
    __extends(Activation, _super);
    function Activation(config) {
        var _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        _this.activation = activations_1.getActivation(config.activation);
        return _this;
    }
    Activation.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            return _this.activation.apply(input);
        });
    };
    Activation.prototype.getConfig = function () {
        var config = { activation: activations_1.serializeActivation(this.activation) };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Activation.className = 'Activation';
    return Activation;
}(topology_1.Layer));
exports.Activation = Activation;
tfjs_core_1.serialization.SerializationMap.register(Activation);
var RepeatVector = (function (_super) {
    __extends(RepeatVector, _super);
    function RepeatVector(config) {
        var _this = _super.call(this, config) || this;
        _this.n = config.n;
        _this.inputSpec = [{ ndim: 2 }];
        return _this;
    }
    RepeatVector.prototype.computeOutputShape = function (inputShape) {
        return [inputShape[0], this.n, inputShape[1]];
    };
    RepeatVector.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils_1.getExactlyOneTensor(inputs);
            return K.repeat(inputs, _this.n);
        });
    };
    RepeatVector.prototype.getConfig = function () {
        var config = {
            n: this.n,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    RepeatVector.className = 'RepeatVector';
    return RepeatVector;
}(topology_1.Layer));
exports.RepeatVector = RepeatVector;
tfjs_core_1.serialization.SerializationMap.register(RepeatVector);
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(config) {
        var _this = _super.call(this, config) || this;
        _this.targetShape = config.targetShape;
        for (var i = 0; i < _this.targetShape.length; ++i) {
            if (_this.isUnknown(_this.targetShape[i])) {
                _this.targetShape[i] = null;
            }
        }
        return _this;
    }
    Reshape.prototype.isUnknown = function (dim) {
        return dim < 0 || dim == null;
    };
    Reshape.prototype.fixUnknownDimension = function (inputShape, outputShape) {
        var errorMsg = 'Total size of new array must be unchanged.';
        var finalShape = outputShape.slice();
        var known = 1;
        var unknown = null;
        for (var i = 0; i < finalShape.length; ++i) {
            var dim = finalShape[i];
            if (this.isUnknown(dim)) {
                if (unknown === null) {
                    unknown = i;
                }
                else {
                    throw new errors_1.ValueError('Can only specifiy one unknown dimension.');
                }
            }
            else {
                known *= dim;
            }
        }
        var originalSize = math_utils.arrayProd(inputShape);
        if (unknown !== null) {
            if (known === 0 || originalSize % known !== 0) {
                throw new errors_1.ValueError(errorMsg);
            }
            finalShape[unknown] = originalSize / known;
        }
        else if (originalSize !== known) {
            throw new errors_1.ValueError(errorMsg);
        }
        return finalShape;
    };
    Reshape.prototype.computeOutputShape = function (inputShape) {
        var anyUnknownDims = false;
        for (var i = 0; i < inputShape.length; ++i) {
            if (this.isUnknown(inputShape[i])) {
                anyUnknownDims = true;
                break;
            }
        }
        if (anyUnknownDims) {
            return inputShape.slice(0, 1).concat(this.targetShape);
        }
        else {
            return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
        }
    };
    Reshape.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            var inputShape = K.shape(input);
            var outputShape = inputShape.slice(0, 1).concat(_this.fixUnknownDimension(inputShape.slice(1), _this.targetShape));
            return input.reshape(outputShape);
        });
    };
    Reshape.prototype.getConfig = function () {
        var config = {
            targetShape: this.targetShape,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Reshape.className = 'Reshape';
    return Reshape;
}(topology_1.Layer));
exports.Reshape = Reshape;
tfjs_core_1.serialization.SerializationMap.register(Reshape);

},{"../activations":158,"../backend/tfjs_backend":160,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/generic_utils":190,"../utils/math_utils":191,"@tensorflow/tfjs-core":51}],175:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var generic_utils = require("../utils/generic_utils");
var generic_utils_1 = require("../utils/generic_utils");
var Embedding = (function (_super) {
    __extends(Embedding, _super);
    function Embedding(config) {
        var _this = _super.call(this, config) || this;
        _this.embeddings = null;
        _this.DEFAULT_EMBEDDINGS_INITIALIZER = 'randomUniform';
        if (config.batchInputShape == null && config.inputShape == null) {
            var batchSize = null;
            if (config.batchSize != null) {
                batchSize = config.batchSize;
            }
            if (config.inputLength == null) {
                _this.batchInputShape = [batchSize, null];
            }
            else {
                _this.batchInputShape =
                    [batchSize].concat(generic_utils.toList(config.inputLength));
            }
        }
        _this.inputDim = config.inputDim;
        _this.outputDim = config.outputDim;
        _this.embeddingsInitializer = initializers_1.getInitializer(config.embeddingsInitializer || _this.DEFAULT_EMBEDDINGS_INITIALIZER);
        _this.embeddingsRegularizer = regularizers_1.getRegularizer(config.embeddingsRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        _this.embeddingsConstraint = constraints_1.getConstraint(config.embeddingsConstraint);
        _this.maskZero = config.maskZero;
        _this.inputLength = config.inputLength;
        return _this;
    }
    Embedding.prototype.build = function (inputShape) {
        this.embeddings = this.addWeight('embeddings', [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
        this.built = true;
    };
    Embedding.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for Embedding yet');
    };
    Embedding.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        if (this.inputLength == null) {
            return inputShape.concat([this.outputDim]);
        }
        var inLens = generic_utils.toList(this.inputLength);
        if (inLens.length !== inputShape.length - 1) {
            throw new errors_1.ValueError("\"inputLength\" is " + this.inputLength + ", but received " +
                ("input shape has shape " + inputShape));
        }
        else {
            var i = 0;
            for (var k = 0; k < inLens.length; ++k) {
                var s1 = inLens[k];
                var s2 = inputShape[k + 1];
                if ((s1 != null) && (s2 != null) && (s1 !== s2)) {
                    throw new errors_1.ValueError("\"inputLength\" is " + this.inputLength + ", but received " +
                        ("input shape has shape " + inputShape));
                }
                else if (s1 == null) {
                    inLens[i] = s2;
                }
                i++;
            }
        }
        return [inputShape[0]].concat(inLens, [this.outputDim]);
    };
    Embedding.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (K.dtype(input) !== 'int32') {
                input = K.cast(input, 'int32');
            }
            var output = K.gather(_this.embeddings.read(), input.as1D());
            return output.reshape(generic_utils_1.getExactlyOneShape(_this.computeOutputShape(input.shape)));
        });
    };
    Embedding.prototype.getConfig = function () {
        var config = {
            inputDim: this.inputDim,
            outputDim: this.outputDim,
            embeddingsInitializer: initializers_1.serializeInitializer(this.embeddingsInitializer),
            embeddingsRegularizer: regularizers_1.serializeRegularizer(this.embeddingsRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            embeddingsConstraint: constraints_1.serializeConstraint(this.embeddingsConstraint),
            maskZero: this.maskZero,
            inputLength: this.inputLength
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Embedding.className = 'Embedding';
    return Embedding;
}(topology_1.Layer));
exports.Embedding = Embedding;
tfjs_core_1.serialization.SerializationMap.register(Embedding);

},{"../backend/tfjs_backend":160,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],176:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils = require("../utils/generic_utils");
var mathUtils = require("../utils/math_utils");
var Merge = (function (_super) {
    __extends(Merge, _super);
    function Merge(config) {
        var _this = _super.call(this, config || {}) || this;
        _this.supportsMasking = true;
        return _this;
    }
    Merge.prototype.mergeFunction = function (inputs) {
        throw new errors_1.NotImplementedError();
    };
    Merge.prototype.computeElementwiseOpOutputShape = function (shape1, shape2) {
        if (shape1 == null || shape2 == null) {
            return null;
        }
        else if (shape1.length < shape2.length) {
            return this.computeElementwiseOpOutputShape(shape2, shape1);
        }
        else if (shape2.length === 0) {
            return shape1;
        }
        var outputShape = shape1.slice(0, shape1.length - shape2.length);
        for (var k = 0; k < shape2.length; ++k) {
            var i = shape1[shape1.length - shape2.length + k];
            var j = shape2[k];
            if (i == null || j == null || i < 0 || j < 0) {
                outputShape.push(null);
            }
            else if (i === 1) {
                outputShape.push(j);
            }
            else if (j === 1) {
                outputShape.push(i);
            }
            else {
                if (i !== j) {
                    throw new errors_1.ValueError('Operands could not be broadcast together with shapes ' +
                        JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));
                }
                outputShape.push(i);
            }
        }
        return outputShape;
    };
    Merge.prototype.build = function (inputShape) {
        if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {
            inputShape = [generic_utils.getExactlyOneShape(inputShape)];
        }
        inputShape = inputShape;
        if (inputShape.length < 2) {
            throw new errors_1.ValueError('A merge layer should be called on an Array of at least 2 inputs.' +
                (" Got " + inputShape.length + " input(s)."));
        }
        var batchSizes = [];
        for (var _i = 0, inputShape_1 = inputShape; _i < inputShape_1.length; _i++) {
            var shape = inputShape_1[_i];
            if (shape != null && shape[0] !== null) {
                batchSizes.push(shape[0]);
            }
        }
        batchSizes = generic_utils.unique(batchSizes);
        if (batchSizes.length > 1) {
            throw new errors_1.ValueError("Can not merge tensors with different batch sizes. " +
                ("Got tensors with shapes: " + JSON.stringify(inputShape) + "."));
        }
        var outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);
        for (var i = 1; i < inputShape.length; ++i) {
            var shape = inputShape[i] == null ? null : inputShape[i].slice(1);
            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
        }
        var allRanks = inputShape.map(function (shape) { return shape.length; });
        if (inputShape.indexOf(null) === -1 &&
            generic_utils.unique(allRanks).length === 1) {
            this.reshapeRequired = false;
        }
        else {
            this.reshapeRequired = true;
        }
    };
    Merge.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            if (_this.reshapeRequired) {
                var reshapedInputs = [];
                var inputDims = inputs.map(function (input) { return input.rank; });
                if (inputDims.indexOf(null) === -1) {
                    var maxNDim = mathUtils.max(inputDims);
                    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                        var x = inputs_1[_i];
                        var xNDim = x.rank;
                        for (var k = 0; k < maxNDim - xNDim; ++k) {
                            x = K.expandDims(x, 1);
                        }
                        reshapedInputs.push(x);
                    }
                    return _this.mergeFunction(reshapedInputs);
                }
                else {
                    var transposed = false;
                    for (var _a = 0, inputs_2 = inputs; _a < inputs_2.length; _a++) {
                        var x = inputs_2[_a];
                        var xNDim = x.rank;
                        if (xNDim == null) {
                            var xShape = K.shape(x);
                            var batchSize = xShape[0];
                            var newShape = xShape.slice(1).concat([batchSize]);
                            var xTransposed = x.reshape([batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));
                            xTransposed = tfc.transpose(xTransposed, [1, 0]);
                            xTransposed = xTransposed.reshape(newShape);
                            reshapedInputs.push(xTransposed);
                            transposed = true;
                        }
                        else if (xNDim > 1) {
                            var dims = mathUtils.range(1, xNDim).concat([0]);
                            reshapedInputs.push(tfc.transpose(x, dims));
                            transposed = true;
                        }
                        else {
                            reshapedInputs.push(x);
                        }
                    }
                    var y = _this.mergeFunction(reshapedInputs);
                    var yNDim = y.rank;
                    if (transposed) {
                        if (yNDim == null) {
                            var yShape = K.shape(y);
                            var yNDim_1 = yShape.length;
                            var batchSize = yShape[yNDim_1 - 1];
                            var newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));
                            y = tfc.transpose(y.reshape([-1, batchSize]), [1, 0])
                                .reshape(newShape);
                        }
                        else if (yNDim > 1) {
                            var dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));
                            y = tfc.transpose(y, dims);
                        }
                    }
                    return y;
                }
            }
            else {
                return _this.mergeFunction(inputs);
            }
        });
    };
    Merge.prototype.computeOutputShape = function (inputShape) {
        inputShape = inputShape;
        var outputShape;
        if (inputShape[0] == null) {
            outputShape = null;
        }
        else {
            outputShape = inputShape[0].slice(1);
        }
        for (var i = 1; i < inputShape.length; ++i) {
            var shape = inputShape[i] == null ? null : inputShape[i].slice(1);
            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
        }
        var batchSizes = [];
        for (var _i = 0, inputShape_2 = inputShape; _i < inputShape_2.length; _i++) {
            var shape = inputShape_2[_i];
            if (shape != null && shape[0] !== null) {
                batchSizes.push(shape[0]);
            }
        }
        batchSizes = generic_utils.unique(batchSizes);
        if (batchSizes.length === 1) {
            outputShape = batchSizes.concat(outputShape);
        }
        else {
            outputShape = [null].concat(outputShape);
        }
        return outputShape;
    };
    return Merge;
}(topology_1.Layer));
exports.Merge = Merge;
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(config) {
        return _super.call(this, config) || this;
    }
    Add.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = tfc.zeros(inputs[0].shape);
            for (var _i = 0, inputs_3 = inputs; _i < inputs_3.length; _i++) {
                var input = inputs_3[_i];
                output = tfc.add(output, input);
            }
            return output;
        });
    };
    Add.className = 'Add';
    return Add;
}(Merge));
exports.Add = Add;
tfjs_core_1.serialization.SerializationMap.register(Add);
function add(config) {
    if (Array.isArray(config)) {
        var layer = new Add({});
        return layer.apply(config);
    }
    else {
        return new Add(config);
    }
}
exports.add = add;
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(config) {
        return _super.call(this, config) || this;
    }
    Multiply.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = tfc.ones(inputs[0].shape);
            for (var _i = 0, inputs_4 = inputs; _i < inputs_4.length; _i++) {
                var input = inputs_4[_i];
                output = tfc.mul(output, input);
            }
            return output;
        });
    };
    Multiply.className = 'Multiply';
    return Multiply;
}(Merge));
exports.Multiply = Multiply;
tfjs_core_1.serialization.SerializationMap.register(Multiply);
function multiply(config) {
    if (Array.isArray(config)) {
        var layer = new Multiply({});
        return layer.apply(config);
    }
    else {
        return new Multiply(config);
    }
}
exports.multiply = multiply;
var Average = (function (_super) {
    __extends(Average, _super);
    function Average(config) {
        return _super.call(this, config) || this;
    }
    Average.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = tfc.zeros(inputs[0].shape);
            for (var _i = 0, inputs_5 = inputs; _i < inputs_5.length; _i++) {
                var input = inputs_5[_i];
                output = tfc.add(output, input);
            }
            return K.scalarTimesArray(K.getScalar(1 / inputs.length), output);
        });
    };
    Average.className = 'Average';
    return Average;
}(Merge));
exports.Average = Average;
tfjs_core_1.serialization.SerializationMap.register(Average);
function average(config) {
    if (Array.isArray(config)) {
        var layer = new Average({});
        return layer.apply(config);
    }
    else {
        return new Average(config);
    }
}
exports.average = average;
var Maximum = (function (_super) {
    __extends(Maximum, _super);
    function Maximum(config) {
        return _super.call(this, config) || this;
    }
    Maximum.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0];
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.maximum(output, inputs[i]);
            }
            return output;
        });
    };
    Maximum.className = 'Maximum';
    return Maximum;
}(Merge));
exports.Maximum = Maximum;
tfjs_core_1.serialization.SerializationMap.register(Maximum);
function maximum(config) {
    if (Array.isArray(config)) {
        var layer = new Maximum({});
        return layer.apply(config);
    }
    else {
        return new Maximum(config);
    }
}
exports.maximum = maximum;
var Minimum = (function (_super) {
    __extends(Minimum, _super);
    function Minimum(config) {
        return _super.call(this, config) || this;
    }
    Minimum.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0];
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.minimum(output, inputs[i]);
            }
            return output;
        });
    };
    Minimum.className = 'Minimum';
    return Minimum;
}(Merge));
exports.Minimum = Minimum;
tfjs_core_1.serialization.SerializationMap.register(Minimum);
function minimum(config) {
    if (Array.isArray(config)) {
        var layer = new Minimum({});
        return layer.apply(config);
    }
    else {
        return new Minimum(config);
    }
}
exports.minimum = minimum;
var Concatenate = (function (_super) {
    __extends(Concatenate, _super);
    function Concatenate(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_AXIS = -1;
        if (config == null) {
            config = {};
        }
        _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;
        _this.supportsMasking = true;
        _this.reshapeRequired = false;
        return _this;
    }
    Concatenate.prototype.build = function (inputShape) {
        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) ||
            inputShape.length === 1) {
            throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of at least 2 ' +
                'inputs');
        }
        inputShape = inputShape;
        var allNoneShape = true;
        for (var _i = 0, inputShape_3 = inputShape; _i < inputShape_3.length; _i++) {
            var shape = inputShape_3[_i];
            if (shape != null) {
                allNoneShape = false;
                break;
            }
        }
        if (allNoneShape) {
            return;
        }
        var shapeSet = [];
        for (var i = 0; i < inputShape.length; ++i) {
            var shapeWithoutConcatAxis = inputShape[i].slice();
            shapeWithoutConcatAxis.splice(this.axis, 1);
            var exists = false;
            for (var _a = 0, shapeSet_1 = shapeSet; _a < shapeSet_1.length; _a++) {
                var shape = shapeSet_1[_a];
                if (tfjs_core_1.util.arraysEqual(shape, shapeWithoutConcatAxis)) {
                    exists = true;
                    break;
                }
            }
            if (!exists) {
                shapeSet.push(shapeWithoutConcatAxis);
            }
        }
        if (shapeSet.length > 1) {
            throw new errors_1.ValueError('A `Concatenate` layer requires inputs with matching shapes ' +
                'except for the concat axis. Got input shapes: ' +
                JSON.stringify(inputShape));
        }
    };
    Concatenate.prototype.mergeFunction = function (inputs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            return K.concatenate(inputs, _this.axis);
        });
    };
    Concatenate.prototype.computeOutputShape = function (inputShape) {
        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {
            throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of inputs.');
        }
        var inputShapes = inputShape;
        var outputShape = inputShapes[0].slice();
        var axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;
        for (var _i = 0, _a = inputShapes.slice(1); _i < _a.length; _i++) {
            var shape = _a[_i];
            if (outputShape[axis] == null || shape[axis] == null) {
                outputShape[axis] = null;
                break;
            }
            outputShape[axis] += shape[axis];
        }
        return outputShape;
    };
    Concatenate.prototype.getConfig = function () {
        var config = {
            'axis': this.axis,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Concatenate.className = 'Concatenate';
    return Concatenate;
}(Merge));
exports.Concatenate = Concatenate;
tfjs_core_1.serialization.SerializationMap.register(Concatenate);
function concatenate(config) {
    if (Array.isArray(config)) {
        var layer = new Concatenate({});
        return layer.apply(config);
    }
    else {
        return new Concatenate(config);
    }
}
exports.concatenate = concatenate;

},{"../backend/tfjs_backend":160,"../engine/topology":165,"../errors":167,"../utils/generic_utils":190,"../utils/math_utils":191,"@tensorflow/tfjs-core":51}],177:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var generic_utils = require("../utils/generic_utils");
var math_utils = require("../utils/math_utils");
function batchNormalization(x, mean, variance, beta, gamma, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    var out;
    if (x.rank === 2) {
        out = tfc.batchNormalization2d(x, mean, variance, epsilon, gamma, beta);
    }
    else if (x.rank === 3) {
        out = tfc.batchNormalization3d(x, mean, variance, epsilon, gamma, beta);
    }
    else if (x.rank === 4) {
        out = tfc.batchNormalization4d(x, mean, variance, epsilon, gamma, beta);
    }
    else {
        throw new errors_1.NotImplementedError("batchNormalization is not implememnted for array of rank " + x.rank + " " +
            "yet");
    }
    return out;
}
exports.batchNormalization = batchNormalization;
function regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    return tfjs_core_1.tidy(function () {
        var meanAndVariance = tfc.moments(x, reductionAxes);
        var mean = meanAndVariance.mean;
        var variance = meanAndVariance.variance;
        var normed = batchNormalization(x, mean, variance, beta, gamma, epsilon);
        return [normed, mean, variance];
    });
}
function broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    return tfjs_core_1.tidy(function () {
        var meanAndVariance = tfc.moments(x, reductionAxes);
        var mean = meanAndVariance.mean;
        var variance = meanAndVariance.variance;
        var targetShape = [];
        for (var _i = 0, _a = math_utils.range(0, x.rank); _i < _a.length; _i++) {
            var axis = _a[_i];
            if (reductionAxes.indexOf(axis) !== -1) {
                targetShape.push(1);
            }
            else {
                targetShape.push(x.shape[axis]);
            }
        }
        var broadcastMean = mean.reshape(targetShape);
        var broadcastVariance = variance.reshape(targetShape);
        var broadcastGamma = gamma == null ? null : gamma.reshape(targetShape);
        var broadcastBeta = beta == null ? null : beta.reshape(targetShape);
        var normed = batchNormalization(x, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon);
        return [normed, mean, variance];
    });
}
function normalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    if (tfjs_core_1.util.arraysEqual(reductionAxes.slice().sort(), math_utils.range(0, x.rank - 1))) {
        return regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon);
    }
    else {
        return broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon);
    }
}
exports.normalizeBatchInTraining = normalizeBatchInTraining;
var BatchNormalization = (function (_super) {
    __extends(BatchNormalization, _super);
    function BatchNormalization(config) {
        var _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        _this.axis = config.axis == null ? -1 : config.axis;
        _this.momentum = config.momentum == null ? 0.99 : config.momentum;
        _this.epsilon = config.epsilon == null ? 1e-3 : config.epsilon;
        _this.center = config.center == null ? true : config.center;
        _this.scale = config.scale == null ? true : config.scale;
        _this.betaInitializer = initializers_1.getInitializer(config.betaInitializer || 'zeros');
        _this.gammaInitializer = initializers_1.getInitializer(config.gammaInitializer || 'ones');
        _this.movingMeanInitializer =
            initializers_1.getInitializer(config.movingMeanInitializer || 'zeros');
        _this.movingVarianceInitializer =
            initializers_1.getInitializer(config.movingVarianceInitializer || 'ones');
        _this.betaConstraint = constraints_1.getConstraint(config.betaConstraint);
        _this.gammaConstraint = constraints_1.getConstraint(config.gammaConstraint);
        _this.betaRegularizer = regularizers_1.getRegularizer(config.betaRegularizer);
        _this.gammaRegularizer = regularizers_1.getRegularizer(config.gammaRegularizer);
        _this.stepCount = 0;
        return _this;
    }
    BatchNormalization.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var axis = this.axis >= 0 ? this.axis : (this.axis + inputShape.length);
        var dim = inputShape[axis];
        if (dim == null) {
            throw new errors_1.ValueError("Axis " + axis + " of input tensor should have a defined dimension but " +
                "the layer received an input with shape " +
                (JSON.stringify(inputShape) + "."));
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: inputShape.length, axes: (_a = {}, _a[axis] = dim, _a) })];
        var shape = [dim];
        if (this.scale) {
            this.gamma = this.addWeight('gamma', shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);
        }
        if (this.center) {
            this.beta = this.addWeight('beta', shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);
        }
        this.movingMean = this.addWeight('moving_mean', shape, null, this.movingMeanInitializer, null, false);
        this.movingVariance = this.addWeight('moving_variance', shape, null, this.movingVarianceInitializer, null, false);
        this.built = true;
        var _a;
    };
    BatchNormalization.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var training = kwargs['training'] == null ? false : kwargs['training'];
            var input = generic_utils.getExactlyOneTensor(inputs);
            var inputShape = K.shape(input);
            var ndim = inputShape.length;
            var reductionAxes = math_utils.range(0, ndim);
            var axis = _this.axis >= 0 ? _this.axis : (_this.axis + ndim);
            reductionAxes.splice(axis, 1);
            var broadcastShape = generic_utils.pyListRepeat(1, ndim);
            broadcastShape[axis] = inputShape[axis];
            var sortedReductionAxes = reductionAxes.slice();
            sortedReductionAxes.sort();
            var needsBroadcasting = !tfjs_core_1.util.arraysEqual(sortedReductionAxes, math_utils.range(0, ndim).slice(0, ndim - 1));
            var normalizeInference = function () {
                if (needsBroadcasting) {
                    var broadcastMovingMean = _this.movingMean.read().reshape(broadcastShape);
                    var broadcastMovingVariance = _this.movingVariance.read().reshape(broadcastShape);
                    var broadcastBeta = _this.center ? _this.beta.read().reshape(broadcastShape) : null;
                    var broadcastGamma = _this.scale ? _this.gamma.read().reshape(broadcastShape) : null;
                    return batchNormalization(input, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, _this.epsilon);
                }
                else {
                    return batchNormalization(input, _this.movingMean.read(), _this.movingVariance.read(), _this.beta == null ? null : _this.beta.read(), _this.gamma == null ? null : _this.gamma.read(), _this.epsilon);
                }
            };
            if (!training) {
                return normalizeInference();
            }
            var _a = normalizeBatchInTraining(input, _this.gamma.read(), _this.beta.read(), reductionAxes, _this.epsilon), normedTraining = _a[0], mean = _a[1], variance = _a[2];
            var sampleSize = math_utils.arrayProd(reductionAxes.map(function (axis) { return input.shape[axis]; }));
            var varianceDebiased = variance.mul(K.getScalar(sampleSize / (sampleSize - (1 + _this.epsilon))));
            var updateMovingMeanAndVariance = function () {
                _this.stepCount++;
                var newMovingMean = tfc.movingAverage(_this.movingMean.read(), mean, _this.momentum, _this.stepCount);
                _this.movingMean.write(newMovingMean);
                var newMovingVariance = tfc.movingAverage(_this.movingVariance.read(), varianceDebiased, _this.momentum, _this.stepCount);
                _this.movingVariance.write(newMovingVariance);
            };
            updateMovingMeanAndVariance();
            return normedTraining;
        });
    };
    BatchNormalization.prototype.getConfig = function () {
        var config = {
            axis: this.axis,
            momentum: this.momentum,
            epsilon: this.epsilon,
            center: this.center,
            scale: this.scale,
            betaInitializer: initializers_1.serializeInitializer(this.betaInitializer),
            gammaInitializer: initializers_1.serializeInitializer(this.gammaInitializer),
            movingMeanInitializer: initializers_1.serializeInitializer(this.movingMeanInitializer),
            movingVarianceInitializer: initializers_1.serializeInitializer(this.movingVarianceInitializer),
            betaRegularizer: regularizers_1.serializeRegularizer(this.betaRegularizer),
            gammaRegularizer: regularizers_1.serializeRegularizer(this.gammaRegularizer),
            betaConstraint: constraints_1.serializeConstraint(this.betaConstraint),
            gammaConstraint: constraints_1.serializeConstraint(this.gammaConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    BatchNormalization.className = 'BatchNormalization';
    return BatchNormalization;
}(topology_1.Layer));
exports.BatchNormalization = BatchNormalization;
tfjs_core_1.serialization.SerializationMap.register(BatchNormalization);

},{"../backend/tfjs_backend":160,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/generic_utils":190,"../utils/math_utils":191,"@tensorflow/tfjs-core":51}],178:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils_1 = require("../utils/generic_utils");
function temporalPadding(x, padding) {
    return tfjs_core_1.tidy(function () {
        if (x.rank !== 3) {
            throw new errors_1.ValueError("temporalPadding expects input tensor to be 3-D, but received a " +
                (x.rank + "-D tensor."));
        }
        if (padding == null) {
            padding = [1, 1];
        }
        if (padding.length !== 2) {
            throw new errors_1.ValueError("temporalPadding expects input padding pattern to be a length-2 " +
                ("array, but received a length-" + padding.length + " array."));
        }
        var pattern = [[0, 0], padding, [0, 0]];
        return tfc.pad(x, pattern);
    });
}
exports.temporalPadding = temporalPadding;
function spatial2dPadding(x, padding, dataFormat) {
    return tfjs_core_1.tidy(function () {
        if (x.rank !== 4) {
            throw new errors_1.ValueError("temporalPadding expects input tensor to be 4-D, but received a " +
                (x.rank + "-D tensor."));
        }
        if (padding == null) {
            padding = [[1, 1], [1, 1]];
        }
        if (padding.length !== 2 || padding[0].length !== 2 ||
            padding[1].length !== 2) {
            throw new errors_1.ValueError('spatial2dPadding expects `padding` to be an Array of two Arrays, ' +
                'each of which is an Array of two integers.');
        }
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {
            throw new errors_1.ValueError("Unknown data format: " + dataFormat + ". " +
                "Supported data formats are 'channelsLast' and 'channelsFirst.");
        }
        var pattern;
        if (dataFormat === 'channelsFirst') {
            pattern = [[0, 0], [0, 0], padding[0], padding[1]];
        }
        else {
            pattern = [[0, 0], padding[0], padding[1], [0, 0]];
        }
        return tfc.pad(x, pattern);
    });
}
exports.spatial2dPadding = spatial2dPadding;
var ZeroPadding2D = (function (_super) {
    __extends(ZeroPadding2D, _super);
    function ZeroPadding2D(config) {
        var _this = this;
        if (config == null) {
            config = {};
        }
        _this = _super.call(this, config) || this;
        _this.dataFormat =
            config.dataFormat == null ? common_1.imageDataFormat() : config.dataFormat;
        if (config.padding == null) {
            _this.padding = [[1, 1], [1, 1]];
        }
        else if (typeof config.padding === 'number') {
            _this.padding =
                [[config.padding, config.padding], [config.padding, config.padding]];
        }
        else {
            config.padding = config.padding;
            if (config.padding.length !== 2) {
                throw new errors_1.ValueError("ZeroPadding2D expects padding to be a length-2 array, but " +
                    ("received a length-" + config.padding.length + " array."));
            }
            var heightPadding = void 0;
            var widthPadding = void 0;
            if (typeof config.padding[0] === 'number') {
                heightPadding =
                    [config.padding[0], config.padding[0]];
                widthPadding =
                    [config.padding[1], config.padding[1]];
            }
            else {
                config.padding = config.padding;
                if (config.padding[0].length !== 2) {
                    throw new errors_1.ValueError("ZeroPadding2D expects height padding to be a length-2 array, " +
                        ("but received a length-" + config.padding[0].length + " array."));
                }
                heightPadding = config.padding[0];
                if (config.padding[1].length !== 2) {
                    throw new errors_1.ValueError("ZeroPadding2D expects width padding to be a length-2 array, " +
                        ("but received a length-" + config.padding[1].length + " array."));
                }
                widthPadding = config.padding[1];
            }
            _this.padding = [heightPadding, widthPadding];
        }
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    ZeroPadding2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils_1.getExactlyOneShape(inputShape);
        var rows;
        var cols;
        if (this.dataFormat === 'channelsFirst') {
            if (inputShape[2] != null && inputShape[2] >= 0) {
                rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];
            }
            else {
                rows = null;
            }
            if (inputShape[3] != null && inputShape[3] >= 0) {
                cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];
            }
            else {
                cols = null;
            }
            return [inputShape[0], inputShape[1], rows, cols];
        }
        else {
            if (inputShape[1] != null && inputShape[1] >= 0) {
                rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];
            }
            else {
                rows = null;
            }
            if (inputShape[2] != null && inputShape[2] >= 0) {
                cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];
            }
            else {
                cols = null;
            }
            return [inputShape[0], rows, cols, inputShape[3]];
        }
    };
    ZeroPadding2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return spatial2dPadding(generic_utils_1.getExactlyOneTensor(inputs), _this.padding, _this.dataFormat); });
    };
    ZeroPadding2D.prototype.getConfig = function () {
        var config = {
            padding: this.padding,
            dataFormat: this.dataFormat,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ZeroPadding2D.className = 'ZeroPadding2D';
    return ZeroPadding2D;
}(topology_1.Layer));
exports.ZeroPadding2D = ZeroPadding2D;
tfjs_core_1.serialization.SerializationMap.register(ZeroPadding2D);

},{"../backend/common":159,"../engine/topology":165,"../errors":167,"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],179:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var topology_1 = require("../engine/topology");
var topology_2 = require("../engine/topology");
var errors_1 = require("../errors");
var conv_utils_1 = require("../utils/conv_utils");
var generic_utils = require("../utils/generic_utils");
var convolutional_1 = require("./convolutional");
function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPoolMode(poolMode);
        common_2.checkPaddingMode(padding);
        if (strides == null) {
            strides = [1, 1];
        }
        if (padding == null) {
            padding = 'valid';
        }
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        if (poolMode == null) {
            poolMode = 'max';
        }
        x = convolutional_1.preprocessConv2DInput(x, dataFormat);
        var y;
        var paddingString = (padding === 'same') ? 'same' : 'valid';
        if (poolMode === 'max') {
            y = tfc.maxPool(x, poolSize, strides, paddingString);
        }
        else {
            y = tfc.avgPool(x, poolSize, strides, paddingString);
        }
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.pool2d = pool2d;
var Pooling1D = (function (_super) {
    __extends(Pooling1D, _super);
    function Pooling1D(config) {
        var _this = this;
        if (config.poolSize == null) {
            config.poolSize = 2;
        }
        _this = _super.call(this, config) || this;
        if (typeof config.poolSize === 'number') {
            _this.poolSize = [config.poolSize];
        }
        else if (Array.isArray(config.poolSize) &&
            config.poolSize.length === 1 &&
            typeof config.poolSize[0] === 'number') {
            _this.poolSize = config.poolSize;
        }
        else {
            throw new errors_1.ValueError("poolSize for 1D convolutional layer must be a number or an " +
                "Array of a single number, but received " +
                ("" + JSON.stringify(config.poolSize)));
        }
        if (config.strides == null) {
            _this.strides = _this.poolSize;
        }
        else {
            if (typeof config.strides === 'number') {
                _this.strides = [config.strides];
            }
            else if (Array.isArray(config.strides) &&
                config.strides.length === 1 &&
                typeof config.strides[0] === 'number') {
                _this.strides = config.strides;
            }
            else {
                throw new errors_1.ValueError("strides for 1D convolutional layer must be a number or an " +
                    "Array of a single number, but received " +
                    ("" + JSON.stringify(config.strides)));
            }
        }
        _this.padding = config.padding == null ? 'valid' : config.padding;
        common_2.checkPaddingMode(_this.padding);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        return _this;
    }
    Pooling1D.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var length = conv_utils_1.convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);
        return [inputShape[0], length, inputShape[2]];
    };
    Pooling1D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            inputs = K.expandDims(generic_utils.getExactlyOneTensor(inputs), 2);
            var output = _this.poolingFunction(generic_utils.getExactlyOneTensor(inputs), [_this.poolSize[0], 1], [_this.strides[0], 1], _this.padding, 'channelsLast');
            return tfc.squeeze(output, [2]);
        });
    };
    Pooling1D.prototype.getConfig = function () {
        var config = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return Pooling1D;
}(topology_2.Layer));
exports.Pooling1D = Pooling1D;
var MaxPooling1D = (function (_super) {
    __extends(MaxPooling1D, _super);
    function MaxPooling1D(config) {
        return _super.call(this, config) || this;
    }
    MaxPooling1D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');
    };
    MaxPooling1D.className = 'MaxPooling1D';
    return MaxPooling1D;
}(Pooling1D));
exports.MaxPooling1D = MaxPooling1D;
tfjs_core_1.serialization.SerializationMap.register(MaxPooling1D);
var AveragePooling1D = (function (_super) {
    __extends(AveragePooling1D, _super);
    function AveragePooling1D(config) {
        return _super.call(this, config) || this;
    }
    AveragePooling1D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');
    };
    AveragePooling1D.className = 'AveragePooling1D';
    return AveragePooling1D;
}(Pooling1D));
exports.AveragePooling1D = AveragePooling1D;
tfjs_core_1.serialization.SerializationMap.register(AveragePooling1D);
var Pooling2D = (function (_super) {
    __extends(Pooling2D, _super);
    function Pooling2D(config) {
        var _this = this;
        if (config.poolSize == null) {
            config.poolSize = [2, 2];
        }
        _this = _super.call(this, config) || this;
        _this.poolSize = Array.isArray(config.poolSize) ?
            config.poolSize :
            [config.poolSize, config.poolSize];
        _this.strides = config.strides == null ? _this.poolSize : config.strides;
        _this.padding = config.padding == null ? 'valid' : config.padding;
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        common_2.checkPaddingMode(_this.padding);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    Pooling2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];
        var cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];
        rows =
            conv_utils_1.convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);
        cols =
            conv_utils_1.convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === 'channelsFirst') {
            return [inputShape[0], inputShape[1], rows, cols];
        }
        else {
            return [inputShape[0], rows, cols, inputShape[3]];
        }
    };
    Pooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            return _this.poolingFunction(generic_utils.getExactlyOneTensor(inputs), _this.poolSize, _this.strides, _this.padding, _this.dataFormat);
        });
    };
    Pooling2D.prototype.getConfig = function () {
        var config = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
            dataFormat: this.dataFormat
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return Pooling2D;
}(topology_2.Layer));
exports.Pooling2D = Pooling2D;
var MaxPooling2D = (function (_super) {
    __extends(MaxPooling2D, _super);
    function MaxPooling2D(config) {
        return _super.call(this, config) || this;
    }
    MaxPooling2D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');
    };
    MaxPooling2D.className = 'MaxPooling2D';
    return MaxPooling2D;
}(Pooling2D));
exports.MaxPooling2D = MaxPooling2D;
tfjs_core_1.serialization.SerializationMap.register(MaxPooling2D);
var AveragePooling2D = (function (_super) {
    __extends(AveragePooling2D, _super);
    function AveragePooling2D(config) {
        return _super.call(this, config) || this;
    }
    AveragePooling2D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');
    };
    AveragePooling2D.className = 'AveragePooling2D';
    return AveragePooling2D;
}(Pooling2D));
exports.AveragePooling2D = AveragePooling2D;
tfjs_core_1.serialization.SerializationMap.register(AveragePooling2D);
var GlobalPooling1D = (function (_super) {
    __extends(GlobalPooling1D, _super);
    function GlobalPooling1D(config) {
        var _this = _super.call(this, config) || this;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        return _this;
    }
    GlobalPooling1D.prototype.computeOutputShape = function (inputShape) {
        return [inputShape[0], inputShape[2]];
    };
    GlobalPooling1D.prototype.call = function (inputs, kwargs) {
        throw new errors_1.NotImplementedError();
    };
    return GlobalPooling1D;
}(topology_2.Layer));
exports.GlobalPooling1D = GlobalPooling1D;
var GlobalAveragePooling1D = (function (_super) {
    __extends(GlobalAveragePooling1D, _super);
    function GlobalAveragePooling1D(config) {
        return _super.call(this, config) || this;
    }
    GlobalAveragePooling1D.prototype.call = function (inputs, kwargs) {
        return tfjs_core_1.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            return tfc.mean(input, 1);
        });
    };
    GlobalAveragePooling1D.className = 'GlobalAveragePooling1D';
    return GlobalAveragePooling1D;
}(GlobalPooling1D));
exports.GlobalAveragePooling1D = GlobalAveragePooling1D;
tfjs_core_1.serialization.SerializationMap.register(GlobalAveragePooling1D);
var GlobalMaxPooling1D = (function (_super) {
    __extends(GlobalMaxPooling1D, _super);
    function GlobalMaxPooling1D(config) {
        return _super.call(this, config) || this;
    }
    GlobalMaxPooling1D.prototype.call = function (inputs, kwargs) {
        return tfjs_core_1.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            return tfc.max(input, 1);
        });
    };
    GlobalMaxPooling1D.className = 'GlobalMaxPooling1D';
    return GlobalMaxPooling1D;
}(GlobalPooling1D));
exports.GlobalMaxPooling1D = GlobalMaxPooling1D;
tfjs_core_1.serialization.SerializationMap.register(GlobalMaxPooling1D);
var GlobalPooling2D = (function (_super) {
    __extends(GlobalPooling2D, _super);
    function GlobalPooling2D(config) {
        var _this = _super.call(this, config) || this;
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    GlobalPooling2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = inputShape;
        if (this.dataFormat === 'channelsLast') {
            return [inputShape[0], inputShape[3]];
        }
        else {
            return [inputShape[0], inputShape[1]];
        }
    };
    GlobalPooling2D.prototype.call = function (inputs, kwargs) {
        throw new errors_1.NotImplementedError();
    };
    GlobalPooling2D.prototype.getConfig = function () {
        var config = { dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return GlobalPooling2D;
}(topology_2.Layer));
exports.GlobalPooling2D = GlobalPooling2D;
var GlobalAveragePooling2D = (function (_super) {
    __extends(GlobalAveragePooling2D, _super);
    function GlobalAveragePooling2D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalAveragePooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                return tfc.mean(input, [1, 2]);
            }
            else {
                return tfc.mean(input, [2, 3]);
            }
        });
    };
    GlobalAveragePooling2D.className = 'GlobalAveragePooling2D';
    return GlobalAveragePooling2D;
}(GlobalPooling2D));
exports.GlobalAveragePooling2D = GlobalAveragePooling2D;
tfjs_core_1.serialization.SerializationMap.register(GlobalAveragePooling2D);
var GlobalMaxPooling2D = (function (_super) {
    __extends(GlobalMaxPooling2D, _super);
    function GlobalMaxPooling2D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalMaxPooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                return tfc.max(input, [1, 2]);
            }
            else {
                return tfc.max(input, [2, 3]);
            }
        });
    };
    GlobalMaxPooling2D.className = 'GlobalMaxPooling2D';
    return GlobalMaxPooling2D;
}(GlobalPooling2D));
exports.GlobalMaxPooling2D = GlobalMaxPooling2D;
tfjs_core_1.serialization.SerializationMap.register(GlobalMaxPooling2D);

},{"../backend/common":159,"../backend/tfjs_backend":160,"../common":162,"../engine/topology":165,"../errors":167,"../utils/conv_utils":189,"../utils/generic_utils":190,"./convolutional":172,"@tensorflow/tfjs-core":51}],180:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var topology_2 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var types_1 = require("../types");
var generic_utils = require("../utils/generic_utils");
var math_utils = require("../utils/math_utils");
var variables_1 = require("../variables");
var serialization_1 = require("./serialization");
function rnn(stepFunction, inputs, initialStates, goBackwards, mask, constants, unroll, inputLength) {
    if (goBackwards === void 0) { goBackwards = false; }
    if (unroll === void 0) { unroll = false; }
    var ndim = inputs.shape.length;
    if (ndim < 3) {
        throw new errors_1.ValueError("Input should be at least 3D, but is " + ndim + "D.");
    }
    var axes = [1, 0].concat(math_utils.range(2, ndim));
    inputs = tfc.transpose(inputs, axes);
    if (mask != null) {
        throw new errors_1.NotImplementedError('The rnn() function of the deeplearn.js backend does not support ' +
            'masking yet.');
    }
    if (constants != null) {
        throw new errors_1.NotImplementedError('The rnn() functoin of the deeplearn.js backend does not support ' +
            'constants yet.');
    }
    if (unroll) {
        console.warn('Backend rnn(): the unroll = true option is not applicable to the ' +
            'imperative deeplearn.js backend.');
    }
    if (goBackwards) {
        inputs = tfc.reverse(inputs, 0);
    }
    var outputs;
    var lastOutput;
    var states = initialStates;
    var timeSteps = inputs.shape[0];
    for (var t = 0; t < timeSteps; ++t) {
        var currentInput = K.sliceAlongFirstAxis(inputs, t, 1);
        currentInput = currentInput.reshape(currentInput.shape.slice(1));
        var stepOutputs = stepFunction(currentInput, states);
        lastOutput = stepOutputs[0];
        if (t === 0) {
            outputs = lastOutput.reshape([1].concat(lastOutput.shape));
        }
        else {
            outputs = K.concatAlongFirstAxis(outputs, lastOutput.reshape([1].concat(lastOutput.shape)));
        }
        states = stepOutputs[1];
    }
    return [
        lastOutput,
        tfc.transpose(outputs, [1, 0].concat(math_utils.range(2, outputs.shape.length))),
        states
    ];
}
exports.rnn = rnn;
var RNN = (function (_super) {
    __extends(RNN, _super);
    function RNN(config) {
        var _this = _super.call(this, config) || this;
        var cell;
        if (config.cell == null) {
            throw new errors_1.ValueError('cell property is missing for the constructor of RNN.');
        }
        else if (Array.isArray(config.cell)) {
            cell = new StackedRNNCells({ cells: config.cell });
        }
        else {
            cell = config.cell;
        }
        if (cell.stateSize == null) {
            throw new errors_1.ValueError('The RNN cell should have an attribute `stateSize` (tuple of ' +
                'integers, one integer per RNN state).');
        }
        _this.cell = cell;
        _this.returnSequences =
            config.returnSequences == null ? false : config.returnSequences;
        _this.returnState = config.returnState == null ? false : config.returnState;
        _this.goBackwards = config.goBackwards == null ? false : config.goBackwards;
        _this._stateful = config.stateful == null ? false : config.stateful;
        _this.unroll = config.unroll == null ? false : config.unroll;
        _this.supportsMasking = true;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        _this.stateSpec = null;
        _this.states = null;
        _this.numConstants = null;
        return _this;
    }
    RNN.prototype.getStates = function () {
        if (this.states == null) {
            var numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
            return math_utils.range(0, numStates).map(function (x) { return null; });
        }
        else {
            return this.states;
        }
    };
    RNN.prototype.setStates = function (states) {
        this.states = states;
    };
    RNN.prototype.computeOutputShape = function (inputShape) {
        if (generic_utils.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var stateSize = this.cell.stateSize;
        if (!Array.isArray(stateSize)) {
            stateSize = [stateSize];
        }
        var outputDim = stateSize[0];
        var outputShape;
        if (this.returnSequences) {
            outputShape = [inputShape[0], inputShape[1], outputDim];
        }
        else {
            outputShape = [inputShape[0], outputDim];
        }
        if (this.returnState) {
            var stateShape = [];
            for (var _i = 0, stateSize_1 = stateSize; _i < stateSize_1.length; _i++) {
                var dim = stateSize_1[_i];
                stateShape.push([inputShape[0], dim]);
            }
            return [outputShape].concat(stateShape);
        }
        else {
            return outputShape;
        }
    };
    RNN.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for RNN yet');
    };
    RNN.prototype.build = function (inputShape) {
        var constantShape = null;
        if (this.numConstants != null) {
            throw new errors_1.NotImplementedError('Constants support is not implemented in RNN yet.');
        }
        if (generic_utils.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var batchSize = this.stateful ? inputShape[0] : null;
        var inputDim = inputShape[inputShape.length - 1];
        this.inputSpec[0] = new topology_1.InputSpec({ shape: [batchSize, null, inputDim] });
        var stepInputShape = [inputShape[0]].concat(inputShape.slice(2));
        if (constantShape != null) {
            throw new errors_1.NotImplementedError('Constants support is not implemented in RNN yet.');
        }
        else {
            this.cell.build(stepInputShape);
        }
        var stateSize;
        if (Array.isArray(this.cell.stateSize)) {
            stateSize = this.cell.stateSize;
        }
        else {
            stateSize = [this.cell.stateSize];
        }
        if (this.stateSpec != null) {
            if (!tfjs_core_1.util.arraysEqual(this.stateSpec.map(function (spec) { return spec.shape[spec.shape.length - 1]; }), stateSize)) {
                throw new errors_1.ValueError("An initialState was passed that is not compatible with " +
                    ("cell.stateSize. Received stateSpec=" + this.stateSpec + "; ") +
                    ("However cell.stateSize is " + this.cell.stateSize));
            }
        }
        else {
            this.stateSpec =
                stateSize.map(function (dim) { return new topology_1.InputSpec({ shape: [null, dim] }); });
        }
        if (this.stateful) {
            throw new errors_1.NotImplementedError('stateful RNN layer is not implemented yet');
        }
    };
    RNN.prototype.resetStates = function (states) {
        var _this = this;
        tfjs_core_1.tidy(function () {
            if (!_this.stateful) {
                throw new errors_1.AttributeError('Cannot call resetState() on an RNN Layer that is not stateful.');
            }
            var batchSize = _this.inputSpec[0].shape[0];
            if (batchSize == null) {
                throw new errors_1.ValueError('If an RNN is stateful, it needs to know its batch size. Specify ' +
                    'the batch size of your input tensors: \n' +
                    '- If using a Sequential model, specify the batch size by ' +
                    'passing a `batchInputShape` option to your first layer.\n' +
                    '- If using the functional API, specify the batch size by ' +
                    'passing a `batchShape` option to your Input layer.');
            }
            if (_this.states == null) {
                if (Array.isArray(_this.cell.stateSize)) {
                    _this.states =
                        _this.cell.stateSize.map(function (dim) { return tfc.zeros([batchSize, dim]); });
                }
                else {
                    _this.states = [tfc.zeros([batchSize, _this.cell.stateSize])];
                }
            }
            else if (states == null) {
                if (Array.isArray(_this.cell.stateSize)) {
                    _this.states =
                        _this.cell.stateSize.map(function (dim) { return tfc.zeros([batchSize, dim]); });
                }
                else {
                    _this.states[0] = tfc.zeros([batchSize, _this.cell.stateSize]);
                }
            }
            else {
                if (!Array.isArray(states)) {
                    states = [states];
                }
                if (states.length !== _this.states.length) {
                    throw new errors_1.ValueError("Layer " + _this.name + " expects " + _this.states.length + " state(s), " +
                        ("but it received " + states.length + " state value(s). Input ") +
                        ("received: " + states));
                }
                for (var index = 0; index < _this.states.length; ++index) {
                    var value = states[index];
                    var dim = Array.isArray(_this.cell.stateSize) ?
                        _this.cell.stateSize[index] :
                        _this.cell.stateSize;
                    var expectedShape = [batchSize, dim];
                    if (!tfjs_core_1.util.arraysEqual(value.shape, expectedShape)) {
                        throw new errors_1.ValueError("State " + index + " is incompatible with layer " + _this.name + ": " +
                            ("expected shape=" + expectedShape + ", received shape=" + value.shape));
                    }
                    _this.states[index] = value;
                }
            }
        });
    };
    RNN.prototype.standardizeArgs = function (inputs, initialState, constants) {
        if (Array.isArray(inputs)) {
            if (initialState != null || constants != null) {
                throw new errors_1.ValueError('When inputs is an array, neither initialState or constants ' +
                    'should be provided');
            }
            if (this.numConstants != null) {
                constants =
                    inputs.slice(inputs.length - this.numConstants, inputs.length);
                inputs = inputs.slice(0, inputs.length - this.numConstants);
            }
            if (inputs.length > 1) {
                initialState = inputs.slice(1, inputs.length);
            }
            inputs = inputs[0];
        }
        function toListOrNull(x) {
            if (x == null || Array.isArray(x)) {
                return x;
            }
            else {
                return [x];
            }
        }
        initialState = toListOrNull(initialState);
        constants = toListOrNull(constants);
        return { inputs: inputs, initialState: initialState, constants: constants };
    };
    RNN.prototype.apply = function (inputs, kwargs) {
        var initialState = kwargs == null ? null : kwargs['initialState'];
        var constants = kwargs == null ? null : kwargs['constants'];
        if (kwargs == null) {
            kwargs = {};
        }
        var standardized = this.standardizeArgs(inputs, initialState, constants);
        inputs = standardized.inputs;
        initialState = standardized.initialState;
        constants = standardized.constants;
        var additionalInputs = [];
        var additionalSpecs = [];
        if (initialState != null) {
            kwargs['initialState'] = initialState;
            additionalInputs = additionalInputs.concat(initialState);
            this.stateSpec = [];
            for (var _i = 0, initialState_1 = initialState; _i < initialState_1.length; _i++) {
                var state = initialState_1[_i];
                this.stateSpec.push(new topology_1.InputSpec({ shape: state.shape }));
            }
            additionalSpecs = additionalSpecs.concat(this.stateSpec);
        }
        if (constants != null) {
            kwargs['constants'] = constants;
            additionalInputs = additionalInputs.concat(constants);
            this.numConstants = constants.length;
        }
        var isTensor = additionalInputs[0] instanceof types_1.SymbolicTensor;
        if (isTensor) {
            var fullInput = [inputs].concat(additionalInputs);
            var fullInputSpec = this.inputSpec.concat(additionalSpecs);
            var originalInputSpec = this.inputSpec;
            this.inputSpec = fullInputSpec;
            var output = _super.prototype.apply.call(this, fullInput, kwargs);
            this.inputSpec = originalInputSpec;
            return output;
        }
        else {
            return _super.prototype.apply.call(this, inputs, kwargs);
        }
    };
    RNN.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            inputs = generic_utils.getExactlyOneTensor(inputs);
            if (initialState == null) {
                if (_this.stateful) {
                    throw new errors_1.NotImplementedError('stateful RNN layer is not implemented yet.');
                }
                else {
                    initialState = _this.getInitialState(inputs);
                }
            }
            if (mask != null) {
                throw new errors_1.NotImplementedError('Masking is not implemented for RNN yet');
            }
            var numStates = Array.isArray(_this.cell.stateSize) ? _this.cell.stateSize.length : 1;
            if (initialState.length !== numStates) {
                throw new errors_1.ValueError("RNN Layer has " + numStates + " state(s) but was passed " +
                    (initialState.length + " initial state(s)."));
            }
            var inputShape = inputs.shape;
            var timesteps = inputShape[1];
            if (_this.unroll) {
                console.warn('Ignoring unroll = true for RNN layer, due to imperative backend.');
            }
            var cellCallKwargs = { training: training };
            var step = function (inputs, states) {
                var outputs = _this.cell.call([inputs].concat(states), cellCallKwargs);
                return [outputs[0], outputs.slice(1)];
            };
            var rnnOutputs = rnn(step, inputs, initialState, _this.goBackwards, null, null, _this.unroll, timesteps);
            var lastOutput = rnnOutputs[0];
            var outputs = rnnOutputs[1];
            var states = rnnOutputs[2];
            if (_this.stateful) {
                throw new errors_1.NotImplementedError('stateful RNN layer is not implemented yet');
            }
            var output = _this.returnSequences ? outputs : lastOutput;
            if (_this.returnState) {
                return [output].concat(states);
            }
            else {
                return output;
            }
        });
    };
    RNN.prototype.getInitialState = function (inputs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var initialState = tfc.zeros(inputs.shape);
            initialState = tfc.sum(initialState, [1, 2]);
            initialState = K.expandDims(initialState);
            if (Array.isArray(_this.cell.stateSize)) {
                return _this.cell.stateSize.map(function (dim) { return dim > 1 ? K.tile(initialState, [1, dim]) : initialState; });
            }
            else {
                return _this.cell.stateSize > 1 ?
                    [K.tile(initialState, [1, _this.cell.stateSize])] :
                    [initialState];
            }
        });
    };
    Object.defineProperty(RNN.prototype, "trainableWeights", {
        get: function () {
            if (!this.trainable) {
                return [];
            }
            return this.cell.trainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RNN.prototype, "nonTrainableWeights", {
        get: function () {
            if (!this.trainable) {
                return this.cell.weights;
            }
            return this.cell.nonTrainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    RNN.prototype.getConfig = function () {
        var config = {
            returnSequences: this.returnSequences,
            returnState: this.returnState,
            goBackwards: this.goBackwards,
            stateful: this.stateful,
            unroll: this.unroll,
        };
        if (this.numConstants != null) {
            config.numConstants = this.numConstants;
        }
        var cellConfig = this.cell.getConfig();
        config.cell = {
            className: this.cell.getClassName(),
            config: cellConfig,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    RNN.className = 'RNN';
    return RNN;
}(topology_2.Layer));
exports.RNN = RNN;
tfjs_core_1.serialization.SerializationMap.register(RNN);
var RNNCell = (function (_super) {
    __extends(RNNCell, _super);
    function RNNCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RNNCell = __decorate([
        tfjs_core_1.doc({ heading: 'Layers', subheading: 'Classes' })
    ], RNNCell);
    return RNNCell;
}(topology_2.Layer));
exports.RNNCell = RNNCell;
var SimpleRNNCell = (function (_super) {
    __extends(SimpleRNNCell, _super);
    function SimpleRNNCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation == null ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.stateSize = _this.units;
        return _this;
    }
    SimpleRNNCell.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        this.kernel = this.addWeight('kernel', [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    SimpleRNNCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            if (inputs.length !== 2) {
                throw new errors_1.ValueError("SimpleRNNCell expects 2 input Tensors, got " + inputs.length + ".");
            }
            var prevOutput = inputs[1];
            inputs = inputs[0];
            if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                throw new errors_1.NotImplementedError('Dropout is not implemented for SimpleRNNCell yet');
            }
            var h = K.dot(inputs, _this.kernel.read());
            if (_this.bias != null) {
                h = K.biasAdd(h, _this.bias.read());
            }
            var output = tfc.add(h, K.dot(prevOutput, _this.recurrentKernel.read()));
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            return [output, output];
        });
    };
    SimpleRNNCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    SimpleRNNCell.className = 'SimpleRNNCell';
    return SimpleRNNCell;
}(RNNCell));
exports.SimpleRNNCell = SimpleRNNCell;
tfjs_core_1.serialization.SerializationMap.register(SimpleRNNCell);
var SimpleRNN = (function (_super) {
    __extends(SimpleRNN, _super);
    function SimpleRNN(config) {
        var _this = this;
        config.cell = new SimpleRNNCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    SimpleRNN.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(SimpleRNN.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    SimpleRNN.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    SimpleRNN.className = 'SimpleRNN';
    return SimpleRNN;
}(RNN));
exports.SimpleRNN = SimpleRNN;
tfjs_core_1.serialization.SerializationMap.register(SimpleRNN);
var GRUCell = (function (_super) {
    __extends(GRUCell, _super);
    function GRUCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.recurrentActivation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_RECURRENT_ACTIVATION :
            config.recurrentActivation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.implementation = config.implementation;
        _this.stateSize = _this.units;
        return _this;
    }
    GRUCell.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var inputDim = inputShape[inputShape.length - 1];
        this.kernel = this.addWeight('kernel', [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    GRUCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                throw new errors_1.NotImplementedError('Dropout is not implemented for GRUCell yet');
            }
            inputs = inputs;
            if (inputs.length !== 2) {
                throw new errors_1.ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got " +
                    (inputs.length + "."));
            }
            var hTMinus1 = inputs[1];
            inputs = inputs[0];
            var z;
            var r;
            var hh;
            if (_this.implementation === 1) {
                var kernelZ = K.sliceAlongLastAxis(_this.kernel.read(), 0, _this.units);
                var kernelR = K.sliceAlongLastAxis(_this.kernel.read(), _this.units, _this.units);
                var kernelH = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 2, _this.units);
                var recurrentKernelZ = K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, _this.units);
                var recurrentKernelR = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units, _this.units);
                var recurrentKernelH = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 2, _this.units);
                var inputsZ = inputs;
                var inputsR = inputs;
                var inputsH = inputs;
                var xZ = K.dot(inputsZ, kernelZ);
                var xR = K.dot(inputsR, kernelR);
                var xH = K.dot(inputsH, kernelH);
                if (_this.useBias) {
                    var biasZ = K.sliceAlongFirstAxis(_this.bias.read(), 0, _this.units);
                    var biasR = K.sliceAlongFirstAxis(_this.bias.read(), _this.units, _this.units);
                    var biasH = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 2, _this.units);
                    xZ = K.biasAdd(xZ, biasZ);
                    xR = K.biasAdd(xR, biasR);
                    xH = K.biasAdd(xH, biasH);
                }
                var hTMinus1Z = hTMinus1;
                var hTMinus1R = hTMinus1;
                var hTMinus1H = hTMinus1;
                z = _this.recurrentActivation.apply(tfc.add(xZ, K.dot(hTMinus1Z, recurrentKernelZ)));
                r = _this.recurrentActivation.apply(tfc.add(xR, K.dot(hTMinus1R, recurrentKernelR)));
                hh = _this.activation.apply(tfc.add(xH, K.dot(tfc.mul(r, hTMinus1H), recurrentKernelH)));
            }
            else {
                var matrixX = K.dot(inputs, _this.kernel.read());
                if (_this.useBias) {
                    matrixX = K.biasAdd(matrixX, _this.bias.read());
                }
                var matrixInner = K.dot(hTMinus1, K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, 2 * _this.units));
                var xZ = K.sliceAlongLastAxis(matrixX, 0, _this.units);
                var xR = K.sliceAlongLastAxis(matrixX, _this.units, _this.units);
                var recurrentZ = K.sliceAlongLastAxis(matrixInner, 0, _this.units);
                var recurrentR = K.sliceAlongLastAxis(matrixInner, _this.units, _this.units);
                z = _this.recurrentActivation.apply(tfc.add(xZ, recurrentZ));
                r = _this.recurrentActivation.apply(tfc.add(xR, recurrentR));
                var xH = K.sliceAlongLastAxis(matrixX, 2 * _this.units, _this.units);
                var recurrentH = K.dot(tfc.mul(r, hTMinus1), K.sliceAlongLastAxis(_this.recurrentKernel.read(), 2 * _this.units, _this.units));
                hh = _this.activation.apply(tfc.add(xH, recurrentH));
            }
            var h = tfc.add(tfc.mul(z, hTMinus1), tfc.mul(K.scalarPlusArray(K.getScalar(1), tfc.neg(z)), hh));
            return [h, h];
        });
    };
    GRUCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    GRUCell.className = 'GRUCell';
    return GRUCell;
}(RNNCell));
exports.GRUCell = GRUCell;
tfjs_core_1.serialization.SerializationMap.register(GRUCell);
var GRU = (function (_super) {
    __extends(GRU, _super);
    function GRU(config) {
        var _this = this;
        if (config.implementation === 0) {
            console.warn('`implementation=0` has been deprecated, and now defaults to ' +
                '`implementation=1`. Please update your layer call.');
        }
        config.cell = new GRUCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    GRU.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(GRU.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "implementation", {
        get: function () {
            return this.cell.implementation;
        },
        enumerable: true,
        configurable: true
    });
    GRU.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    GRU.fromConfig = function (cls, config) {
        if (config['implmentation'] === 0) {
            config['implementation'] = 1;
        }
        return new cls(config);
    };
    GRU.className = 'GRU';
    return GRU;
}(RNN));
exports.GRU = GRU;
tfjs_core_1.serialization.SerializationMap.register(GRU);
var LSTMCell = (function (_super) {
    __extends(LSTMCell, _super);
    function LSTMCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.recurrentActivation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_RECURRENT_ACTIVATION :
            config.recurrentActivation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.unitForgetBias = config.unitForgetBias;
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.implementation = config.implementation;
        _this.stateSize = [_this.units, _this.units];
        return _this;
    }
    LSTMCell.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var inputDim = inputShape[inputShape.length - 1];
        this.kernel = this.addWeight('kernel', [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        var biasInitializer;
        if (this.useBias) {
            if (this.unitForgetBias) {
                var capturedBiasInit_1 = this.biasInitializer;
                var capturedUnits_1 = this.units;
                biasInitializer = new (_a = (function (_super) {
                        __extends(CustomInit, _super);
                        function CustomInit() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        CustomInit.prototype.apply = function (shape, dtype) {
                            var bI = capturedBiasInit_1.apply([capturedUnits_1]);
                            var bF = (new initializers_1.Ones()).apply([capturedUnits_1]);
                            var bCAndH = capturedBiasInit_1.apply([capturedUnits_1 * 2]);
                            return K.concatAlongFirstAxis(K.concatAlongFirstAxis(bI, bF), bCAndH);
                        };
                        return CustomInit;
                    }(initializers_1.Initializer)),
                    _a.className = 'CustomInit',
                    _a)();
            }
            else {
                biasInitializer = this.biasInitializer;
            }
            this.bias = this.addWeight('bias', [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
        var _a;
    };
    LSTMCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                throw new errors_1.NotImplementedError('Dropout is not implemented for LSTMCell yet');
            }
            inputs = inputs;
            if (inputs.length !== 3) {
                throw new errors_1.ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got " +
                    (inputs.length + "."));
            }
            var hTMinus1 = inputs[1];
            var cTMinus1 = inputs[2];
            inputs = inputs[0];
            var i;
            var f;
            var c;
            var o;
            if (_this.implementation === 1) {
                var kernelI = K.sliceAlongLastAxis(_this.kernel.read(), 0, _this.units);
                var kernelF = K.sliceAlongLastAxis(_this.kernel.read(), _this.units, _this.units);
                var kernelC = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 2, _this.units);
                var kernelO = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 3, _this.units);
                var recurrentKernelI = K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, _this.units);
                var recurrentKernelF = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units, _this.units);
                var recurrentKernelC = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 2, _this.units);
                var recurrentKernelO = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 3, _this.units);
                var inputsI = inputs;
                var inputsF = inputs;
                var inputsC = inputs;
                var inputsO = inputs;
                var xI = K.dot(inputsI, kernelI);
                var xF = K.dot(inputsF, kernelF);
                var xC = K.dot(inputsC, kernelC);
                var xO = K.dot(inputsO, kernelO);
                if (_this.useBias) {
                    var biasI = K.sliceAlongFirstAxis(_this.bias.read(), 0, _this.units);
                    var biasF = K.sliceAlongFirstAxis(_this.bias.read(), _this.units, _this.units);
                    var biasC = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 2, _this.units);
                    var biasO = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 3, _this.units);
                    xI = K.biasAdd(xI, biasI);
                    xF = K.biasAdd(xF, biasF);
                    xC = K.biasAdd(xC, biasC);
                    xO = K.biasAdd(xO, biasO);
                }
                var hTMinus1I = hTMinus1;
                var hTMinus1F = hTMinus1;
                var hTMinus1C = hTMinus1;
                var hTMinus1O = hTMinus1;
                i = _this.recurrentActivation.apply(tfc.add(xI, K.dot(hTMinus1I, recurrentKernelI)));
                f = _this.recurrentActivation.apply(tfc.add(xF, K.dot(hTMinus1F, recurrentKernelF)));
                c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(tfc.add(xC, K.dot(hTMinus1C, recurrentKernelC)))));
                o = _this.recurrentActivation.apply(tfc.add(xO, K.dot(hTMinus1O, recurrentKernelO)));
            }
            else {
                var z = K.dot(inputs, _this.kernel.read());
                z = tfc.add(z, K.dot(hTMinus1, _this.recurrentKernel.read()));
                if (_this.useBias) {
                    z = K.biasAdd(z, _this.bias.read());
                }
                var z0 = K.sliceAlongLastAxis(z, 0, _this.units);
                var z1 = K.sliceAlongLastAxis(z, _this.units, _this.units);
                var z2 = K.sliceAlongLastAxis(z, _this.units * 2, _this.units);
                var z3 = K.sliceAlongLastAxis(z, _this.units * 3, _this.units);
                i = _this.recurrentActivation.apply(z0);
                f = _this.recurrentActivation.apply(z1);
                c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(z2)));
                o = _this.recurrentActivation.apply(z3);
            }
            var h = tfc.mul(o, _this.activation.apply(c));
            return [h, h, c];
        });
    };
    LSTMCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            unitForgetBias: this.unitForgetBias,
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    LSTMCell.className = 'LSTMCell';
    return LSTMCell;
}(RNNCell));
exports.LSTMCell = LSTMCell;
tfjs_core_1.serialization.SerializationMap.register(LSTMCell);
var LSTM = (function (_super) {
    __extends(LSTM, _super);
    function LSTM(config) {
        var _this = this;
        if (config.implementation === 0) {
            console.warn('`implementation=0` has been deprecated, and now defaults to ' +
                '`implementation=1`. Please update your layer call.');
        }
        config.cell = new LSTMCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    LSTM.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(LSTM.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "unitForgetBias", {
        get: function () {
            return this.cell.unitForgetBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "implementation", {
        get: function () {
            return this.cell.implementation;
        },
        enumerable: true,
        configurable: true
    });
    LSTM.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            unitForgetBias: this.unitForgetBias,
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    LSTM.fromConfig = function (cls, config) {
        if (config['implmentation'] === 0) {
            config['implementation'] = 1;
        }
        return new cls(config);
    };
    LSTM.className = 'LSTM';
    return LSTM;
}(RNN));
exports.LSTM = LSTM;
tfjs_core_1.serialization.SerializationMap.register(LSTM);
var StackedRNNCells = (function (_super) {
    __extends(StackedRNNCells, _super);
    function StackedRNNCells(config) {
        var _this = _super.call(this, config) || this;
        _this.cells = config.cells;
        return _this;
    }
    Object.defineProperty(StackedRNNCells.prototype, "stateSize", {
        get: function () {
            var stateSize = [];
            for (var _i = 0, _a = this.cells.slice().reverse(); _i < _a.length; _i++) {
                var cell = _a[_i];
                if (Array.isArray(cell.stateSize)) {
                    stateSize.push.apply(stateSize, cell.stateSize);
                }
                else {
                    stateSize.push(cell.stateSize);
                }
            }
            return stateSize;
        },
        enumerable: true,
        configurable: true
    });
    StackedRNNCells.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            var states = inputs.slice(1);
            var nestedStates = [];
            for (var _i = 0, _a = _this.cells.slice().reverse(); _i < _a.length; _i++) {
                var cell = _a[_i];
                if (Array.isArray(cell.stateSize)) {
                    nestedStates.push(states.splice(0, cell.stateSize.length));
                }
                else {
                    nestedStates.push(states.splice(0, 1));
                }
            }
            nestedStates.reverse();
            var newNestedStates = [];
            var callInputs;
            for (var i = 0; i < _this.cells.length; ++i) {
                var cell = _this.cells[i];
                states = nestedStates[i];
                if (i === 0) {
                    callInputs = [inputs[0]].concat(states);
                }
                else {
                    callInputs = [callInputs[0]].concat(states);
                }
                callInputs = cell.call(callInputs, kwargs);
                newNestedStates.push(callInputs.slice(1));
            }
            states = [];
            for (var _b = 0, _c = newNestedStates.slice().reverse(); _b < _c.length; _b++) {
                var cellStates = _c[_b];
                states.push.apply(states, cellStates);
            }
            return [callInputs[0]].concat(states);
        });
    };
    StackedRNNCells.prototype.build = function (inputShape) {
        if (generic_utils.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var outputDim;
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            cell.build(inputShape);
            if (Array.isArray(cell.stateSize)) {
                outputDim = cell.stateSize[0];
            }
            else {
                outputDim = cell.stateSize;
            }
            inputShape = [inputShape[0], outputDim];
        }
        this.built = true;
    };
    StackedRNNCells.prototype.getConfig = function () {
        var cellConfigs = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            cellConfigs.push({
                'className': this.getClassName(),
                'config': cell.getConfig(),
            });
        }
        var config = { 'cells': cellConfigs };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    StackedRNNCells.fromConfig = function (cls, config, customObjects) {
        if (customObjects === void 0) { customObjects = {}; }
        var cells = [];
        for (var _i = 0, _a = config['cells']; _i < _a.length; _i++) {
            var cellConfig = _a[_i];
            cells.push(serialization_1.deserialize(cellConfig, customObjects));
        }
        return new cls({ cells: cells });
    };
    Object.defineProperty(StackedRNNCells.prototype, "trainableWeights", {
        get: function () {
            if (!this.trainable) {
                return [];
            }
            var weights = [];
            for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                var cell = _a[_i];
                weights.push.apply(weights, cell.trainableWeights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackedRNNCells.prototype, "nonTrainableWeights", {
        get: function () {
            var weights = [];
            for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                var cell = _a[_i];
                weights.push.apply(weights, cell.nonTrainableWeights);
            }
            if (!this.trainable) {
                var trainableWeights = [];
                for (var _b = 0, _c = this.cells; _b < _c.length; _b++) {
                    var cell = _c[_b];
                    trainableWeights.push.apply(trainableWeights, cell.trainableWeights);
                }
                return trainableWeights.concat(weights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    StackedRNNCells.prototype.getWeights = function () {
        var weights = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            weights.push.apply(weights, cell.weights);
        }
        return variables_1.batchGetValue(weights);
    };
    StackedRNNCells.prototype.setWeights = function (weights) {
        var tuples = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            var numParams = cell.weights.length;
            var inputWeights = weights.splice(numParams);
            for (var i = 0; i < cell.weights.length; ++i) {
                tuples.push([cell.weights[i], inputWeights[i]]);
            }
        }
        variables_1.batchSetValue(tuples);
    };
    StackedRNNCells.className = 'StackedRNNCells';
    return StackedRNNCells;
}(RNNCell));
exports.StackedRNNCells = StackedRNNCells;
tfjs_core_1.serialization.SerializationMap.register(StackedRNNCells);

},{"../activations":158,"../backend/tfjs_backend":160,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../types":188,"../utils/generic_utils":190,"../utils/math_utils":191,"../variables":193,"./serialization":181,"@tensorflow/tfjs-core":51}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var generic_utils_1 = require("../utils/generic_utils");
function deserialize(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'layer');
}
exports.deserialize = deserialize;

},{"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],182:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils = require("../utils/generic_utils");
var recurrent_1 = require("./recurrent");
var serialization_1 = require("./serialization");
var Wrapper = (function (_super) {
    __extends(Wrapper, _super);
    function Wrapper(config) {
        var _this = _super.call(this, config) || this;
        _this.layer = config.layer;
        return _this;
    }
    Wrapper.prototype.build = function (inputShape) {
        this.built = true;
    };
    Object.defineProperty(Wrapper.prototype, "trainable", {
        get: function () {
            if (this.layer != null) {
                return this.layer.trainable;
            }
            else {
                return false;
            }
        },
        set: function (value) {
            if (this.layer != null) {
                this.layer.trainable = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "trainableWeights", {
        get: function () {
            return this.layer.trainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "nonTrainableWeights", {
        get: function () {
            return this.layer.nonTrainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "updates", {
        get: function () {
            return this.layer._updates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "losses", {
        get: function () {
            return this.layer.losses;
        },
        enumerable: true,
        configurable: true
    });
    Wrapper.prototype.getWeights = function () {
        return this.layer.getWeights();
    };
    Wrapper.prototype.setWeights = function (weights) {
        this.layer.setWeights(weights);
    };
    Wrapper.prototype.getConfig = function () {
        var config = {
            'layer': {
                'className': this.layer.getClassName(),
                'config': this.layer.getConfig(),
            }
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Wrapper.fromConfig = function (cls, config, customObjects) {
        if (customObjects === void 0) { customObjects = {}; }
        var layerConfig = config['layer'];
        var layer = serialization_1.deserialize(layerConfig, customObjects);
        delete config['layer'];
        var newConfig = { layer: layer };
        Object.assign(newConfig, config);
        return new cls(newConfig);
    };
    return Wrapper;
}(topology_1.Layer));
exports.Wrapper = Wrapper;
var TimeDistributed = (function (_super) {
    __extends(TimeDistributed, _super);
    function TimeDistributed(config) {
        var _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        return _this;
    }
    TimeDistributed.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        if (inputShape.length < 3) {
            throw new errors_1.ValueError("TimeDistributed layer expects an input shape >= 3D, but received " +
                ("input shape " + JSON.stringify(inputShape)));
        }
        this.inputSpec = [{ shape: inputShape }];
        var childInputShape = [inputShape[0]].concat(inputShape.slice(2));
        if (!this.layer.built) {
            this.layer.build(childInputShape);
            this.layer.built = true;
        }
        _super.prototype.build.call(this, inputShape);
    };
    TimeDistributed.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var childInputShape = [inputShape[0]].concat(inputShape.slice(2));
        var childOutputShape = this.layer.computeOutputShape(childInputShape);
        var timesteps = inputShape[1];
        return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));
    };
    TimeDistributed.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.getExactlyOneTensor(inputs);
            var step = function (inputs, states) {
                var output = _this.layer.call(inputs, kwargs);
                return [output, []];
            };
            var rnnOutputs = recurrent_1.rnn(step, inputs, [], false, null, null, false, inputs.shape[1]);
            var y = rnnOutputs[1];
            return y;
        });
    };
    TimeDistributed.className = 'TimeDistributed';
    return TimeDistributed;
}(Wrapper));
exports.TimeDistributed = TimeDistributed;
tfjs_core_1.serialization.SerializationMap.register(TimeDistributed);
exports.VALID_BIDIRECTIONAL_MERGE_MODES = ['sum', 'mul', 'concat', 'ave'];
function checkBidirectionalMergeMode(value) {
    generic_utils.checkStringTypeUnionValue(exports.VALID_BIDIRECTIONAL_MERGE_MODES, 'BidirectionalMergeMode', value);
}
exports.checkBidirectionalMergeMode = checkBidirectionalMergeMode;
var Bidirectional = (function (_super) {
    __extends(Bidirectional, _super);
    function Bidirectional(config) {
        var _this = _super.call(this, config) || this;
        var layerConfig = config.layer.getConfig();
        _this.forwardLayer =
            serialization_1.deserialize({ className: config.layer.getClassName(), config: layerConfig });
        layerConfig['goBackwards'] =
            layerConfig['goBackwards'] === true ? false : true;
        _this.backwardLayer =
            serialization_1.deserialize({ className: config.layer.getClassName(), config: layerConfig });
        _this.forwardLayer.name = 'forward_' + _this.forwardLayer.name;
        _this.backwardLayer.name = 'backward_' + _this.backwardLayer.name;
        checkBidirectionalMergeMode(config.mergeMode);
        _this.mergeMode = config.mergeMode;
        if (config.weights) {
            throw new errors_1.NotImplementedError('weights support is not implemented for Bidirectional layer yet.');
        }
        _this._stateful = config.layer.stateful;
        _this.returnSequences = config.layer.returnSequences;
        _this.returnState = config.layer.returnState;
        _this.supportsMasking = true;
        _this._trainable = true;
        _this.inputSpec = config.layer.inputSpec;
        return _this;
    }
    Object.defineProperty(Bidirectional.prototype, "trainable", {
        get: function () {
            return this._trainable;
        },
        set: function (value) {
            this._trainable = value;
            if (this.forwardLayer != null) {
                this.forwardLayer.trainable = value;
            }
            if (this.backwardLayer != null) {
                this.backwardLayer.trainable = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Bidirectional.prototype.getWeights = function () {
        return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    };
    Bidirectional.prototype.setWeights = function (weights) {
        var numWeights = weights.length;
        var numeightsOver2 = Math.floor(numWeights / 2);
        this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));
        this.backwardLayer.setWeights(weights.slice(numeightsOver2));
    };
    Bidirectional.prototype.computeOutputShape = function (inputShape) {
        var layerShapes = this.forwardLayer.computeOutputShape(inputShape);
        if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {
            layerShapes = [layerShapes];
        }
        layerShapes = layerShapes;
        var outputShape;
        var outputShapes;
        var stateShape;
        if (this.returnState) {
            stateShape = layerShapes.slice(1);
            outputShape = layerShapes[0];
        }
        else {
            outputShape = layerShapes[0];
        }
        outputShape = outputShape;
        if (this.mergeMode === 'concat') {
            outputShape[outputShape.length - 1] *= 2;
            outputShapes = [outputShape];
        }
        else if (this.mergeMode == null) {
            outputShapes = [outputShape, outputShape.slice()];
        }
        else {
            outputShapes = [outputShape];
        }
        if (this.returnState) {
            if (this.mergeMode == null) {
                return outputShapes.concat(stateShape).concat(stateShape.slice());
            }
            return [outputShape].concat(stateShape).concat(stateShape.slice());
        }
        return generic_utils.singletonOrArray(outputShapes);
    };
    Bidirectional.prototype.apply = function (inputs, kwargs) {
        var initialState = null;
        if (kwargs != null) {
            initialState = kwargs['initialState'];
        }
        if (Array.isArray(inputs)) {
            initialState = inputs.slice(1);
            inputs = inputs[0];
        }
        if (initialState == null || initialState.length === 0) {
            var applyOutputs = _super.prototype.apply.call(this, inputs, kwargs);
            return applyOutputs;
        }
        else {
            throw new errors_1.NotImplementedError('The support for initial states is not implemented for ' +
                'Bidirectional layers yet.');
        }
    };
    Bidirectional.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (kwargs['mask'] != null) {
                throw new errors_1.NotImplementedError('The support for masking is not implemented for ' +
                    'Bidirectional layers yet.');
            }
            if (kwargs['initialState'] != null) {
                throw new errors_1.NotImplementedError('The support for initial states is not implemented for ' +
                    'Bidirectional layers yet.');
            }
            var y = _this.forwardLayer.call(inputs, kwargs);
            var yRev = _this.backwardLayer.call(inputs, kwargs);
            var states;
            if (_this.returnState) {
                if (Array.isArray(y)) {
                    states = y.slice(1).concat(yRev.slice(1));
                }
                else {
                }
                y = y[0];
                yRev = yRev[0];
            }
            if (_this.returnSequences) {
                yRev = tfc.reverse(yRev, 1);
            }
            var output;
            if (_this.mergeMode === 'concat') {
                output = K.concatenate([y, yRev]);
            }
            else if (_this.mergeMode === 'sum') {
                output = tfc.add(y, yRev);
            }
            else if (_this.mergeMode === 'ave') {
                output = K.scalarTimesArray(K.getScalar(0.5), tfc.add(y, yRev));
            }
            else if (_this.mergeMode === 'mul') {
                output = tfc.mul(y, yRev);
            }
            else if (_this.mergeMode == null) {
                output = [y, yRev];
            }
            if (_this.returnState) {
                if (_this.mergeMode == null) {
                    return output.concat(states);
                }
                return [output].concat(states);
            }
            return output;
        });
    };
    Bidirectional.prototype.resetStates = function (states) {
        this.forwardLayer.resetStates();
        this.backwardLayer.resetStates();
    };
    Bidirectional.prototype.build = function (inputShape) {
        var _this = this;
        K.nameScope(this.forwardLayer.name, function () {
            _this.forwardLayer.build(inputShape);
        });
        K.nameScope(this.backwardLayer.name, function () {
            _this.backwardLayer.build(inputShape);
        });
        this.built = true;
    };
    Object.defineProperty(Bidirectional.prototype, "trainableWeights", {
        get: function () {
            return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bidirectional.prototype, "nonTrainableWeights", {
        get: function () {
            return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Bidirectional.prototype.getConfig = function () {
        var config = {
            'mergeMode': this.mergeMode,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Bidirectional.fromConfig = function (cls, config) {
        var rnnLayer = serialization_1.deserialize(config['layer']);
        delete config['layer'];
        if (config['numConstants'] != null) {
            throw new errors_1.NotImplementedError("Deserialization of a Bidirectional layer with numConstants " +
                "present is not supported yet.");
        }
        var newConfig = config;
        newConfig['layer'] = rnnLayer;
        return new cls(newConfig);
    };
    Bidirectional.className = 'Bidirectional';
    return Bidirectional;
}(Wrapper));
exports.Bidirectional = Bidirectional;
tfjs_core_1.serialization.SerializationMap.register(Bidirectional);

},{"../backend/tfjs_backend":160,"../engine/topology":165,"../errors":167,"../utils/generic_utils":190,"./recurrent":180,"./serialization":181,"@tensorflow/tfjs-core":51}],183:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var errors_1 = require("./errors");
function l2Normalize(x, axis) {
    return tfjs_core_1.tidy(function () {
        var squareSum = tfc.sum(K.square(x), axis, true);
        var epsilonTensor = K.scalarTimesArray(tfjs_core_1.scalar(K.epsilon()), tfc.onesLike(x));
        var norm = tfc.sqrt(tfc.maximum(squareSum, epsilonTensor));
        return tfc.div(x, norm);
    });
}
exports.l2Normalize = l2Normalize;
function meanSquaredError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return tfc.mean(K.square(tfc.sub(yPred, yTrue)), -1); });
}
exports.meanSquaredError = meanSquaredError;
function meanAbsoluteError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return tfc.mean(tfc.abs(tfc.sub(yPred, yTrue)), -1); });
}
exports.meanAbsoluteError = meanAbsoluteError;
function meanAbsolutePercentageError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var diff = tfc.sub(yTrue, yPred);
        var clippedTrue = tfc.clipByValue(tfc.abs(yTrue), K.epsilon(), Number.MAX_VALUE);
        var absResult = tfc.abs(tfc.div(diff, clippedTrue));
        return K.scalarTimesArray(K.getScalar(100.0), tfc.mean(absResult, -1));
    });
}
exports.meanAbsolutePercentageError = meanAbsolutePercentageError;
function meanSquaredLogarithmicError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var one = K.getScalar(1.0);
        var clippedPred = tfc.clipByValue(yPred, K.epsilon(), Number.MAX_VALUE);
        var firstLog = tfc.log(K.scalarPlusArray(one, clippedPred));
        var clippedTrue = tfc.clipByValue(yTrue, K.epsilon(), Number.MAX_VALUE);
        var secondLog = tfc.log(K.scalarPlusArray(one, clippedTrue));
        return tfc.mean(K.square(tfc.sub(firstLog, secondLog)), -1);
    });
}
exports.meanSquaredLogarithmicError = meanSquaredLogarithmicError;
function squaredHinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = K.getScalar(0.0);
        var one = K.getScalar(1.0);
        var maxResult = tfc.maximum(zeroTensor, tfc.sub(one, tfc.mul(yTrue, yPred)));
        return tfc.mean(K.square(maxResult), -1);
    });
}
exports.squaredHinge = squaredHinge;
function hinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = K.getScalar(0.0);
        var one = K.getScalar(1.0);
        var maxResult = tfc.maximum(zeroTensor, tfc.sub(one, tfc.mul(yTrue, yPred)));
        return tfc.mean(maxResult, -1);
    });
}
exports.hinge = hinge;
function categoricalHinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = K.getScalar(0.0);
        var one = K.getScalar(1.0);
        var pos = tfc.sum(tfc.mul(yTrue, yPred), -1);
        var neg = tfc.max(tfc.mul(tfc.sub(one, yTrue), yPred), -1);
        return tfc.maximum(zeroTensor, K.scalarPlusArray(one, tfc.sub(neg, pos)));
    });
}
exports.categoricalHinge = categoricalHinge;
function logcosh(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var log2 = K.getScalar(Math.log(2.0));
        var predictionDiff = tfc.sub(yPred, yTrue);
        var logcoshResult = tfc.sub(tfc.add(predictionDiff, tfc.softplus(K.scalarTimesArray(K.getScalar(-2.0), predictionDiff))), log2);
        return tfc.mean(logcoshResult, -1);
    });
}
exports.logcosh = logcosh;
function categoricalCrossentropy(target, output, fromLogits) {
    if (fromLogits === void 0) { fromLogits = false; }
    return tfjs_core_1.tidy(function () {
        if (fromLogits) {
            output = tfc.softmax(output);
        }
        else {
            var outputSum = tfc.sum(output, K.shape(output).length - 1, true);
            output = tfc.div(output, outputSum);
        }
        output = tfc.clipByValue(output, K.epsilon(), 1 - K.epsilon());
        return tfc.neg(tfc.sum(tfc.mul(target.toFloat(), tfc.log(output)), K.shape(output).length - 1));
    });
}
exports.categoricalCrossentropy = categoricalCrossentropy;
function sparseCategoricalCrossentropy(target, output, fromLogits) {
    if (fromLogits === void 0) { fromLogits = false; }
    return tfjs_core_1.tidy(function () {
        var flatTarget = tfc.floor(K.flatten(target)).toInt();
        var outputShape = K.shape(output);
        var oneHotTarget = tfc.oneHot(flatTarget, outputShape[outputShape.length - 1])
            .reshape(outputShape);
        return categoricalCrossentropy(oneHotTarget, output, fromLogits);
    });
}
exports.sparseCategoricalCrossentropy = sparseCategoricalCrossentropy;
function sigmoidCrossEntropyWithLogits(target, output) {
    return tfjs_core_1.tidy(function () {
        var maxOutput = tfc.maximum(output, tfc.zerosLike(output));
        var outputXTarget = tfc.mul(output, target);
        var sigmoidOutput = tfc.log(tfc.add(K.getScalar(1), tfc.exp(tfc.neg(tfc.abs(output)))));
        var result = tfc.add(tfc.sub(maxOutput, outputXTarget), sigmoidOutput);
        return result;
    });
}
exports.sigmoidCrossEntropyWithLogits = sigmoidCrossEntropyWithLogits;
function binaryCrossentropy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var y;
        y = tfc.clipByValue(yPred, K.epsilon(), 1 - K.epsilon());
        y = tfc.log(tfc.div(y, tfc.sub(tfc.onesLike(y), y)));
        return tfc.mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1);
    });
}
exports.binaryCrossentropy = binaryCrossentropy;
function kullbackLeiblerDivergence(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var clippedTrue = tfc.clipByValue(yTrue, K.epsilon(), 1);
        var clippedPred = tfc.clipByValue(yPred, K.epsilon(), 1);
        return tfc.sum(tfc.mul(yTrue, tfc.log(tfc.div(clippedTrue, clippedPred))), -1);
    });
}
exports.kullbackLeiblerDivergence = kullbackLeiblerDivergence;
function poisson(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var logPred = tfc.log(K.scalarPlusArray(K.getScalar(K.epsilon()), yPred));
        return tfc.mean(tfc.sub(yPred, tfc.mul(yTrue, logPred)), -1);
    });
}
exports.poisson = poisson;
function cosineProximity(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var trueNormalized = l2Normalize(yTrue, -1);
        var predNormalized = l2Normalize(yPred, -1);
        var trueXPred = tfc.mul(trueNormalized, predNormalized);
        return tfc.neg(tfc.sum(trueXPred, -1));
    });
}
exports.cosineProximity = cosineProximity;
exports.mse = meanSquaredError;
exports.MSE = meanSquaredError;
exports.mae = meanAbsoluteError;
exports.MAE = meanAbsoluteError;
exports.mape = meanAbsolutePercentageError;
exports.MAPE = meanAbsolutePercentageError;
exports.msle = meanSquaredLogarithmicError;
exports.MSLE = meanSquaredLogarithmicError;
exports.kld = kullbackLeiblerDivergence;
exports.KLD = kullbackLeiblerDivergence;
exports.cosine = cosineProximity;
function get(identifierOrFn) {
    var lossesMap = {
        meanSquaredError: meanSquaredError,
        meanAbsoluteError: meanAbsoluteError,
        meanAbsolutePercentageError: meanAbsolutePercentageError,
        meanSquaredLogarithmicError: meanSquaredLogarithmicError,
        squaredHinge: squaredHinge,
        hinge: hinge,
        categoricalHinge: categoricalHinge,
        logcosh: logcosh,
        categoricalCrossentropy: categoricalCrossentropy,
        sparseCategoricalCrossentropy: sparseCategoricalCrossentropy,
        binaryCrossentropy: binaryCrossentropy,
        kullbackLeiblerDivergence: kullbackLeiblerDivergence,
        poisson: poisson,
        cosineProximity: cosineProximity
    };
    if (typeof identifierOrFn === 'string') {
        if (identifierOrFn in lossesMap) {
            return lossesMap[identifierOrFn];
        }
        throw new errors_1.ValueError("Unknown loss " + identifierOrFn);
    }
    else {
        return identifierOrFn;
    }
}
exports.get = get;

},{"./backend/tfjs_backend":160,"./errors":167,"@tensorflow/tfjs-core":51}],184:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var errors_1 = require("./errors");
var losses_1 = require("./losses");
var losses_2 = require("./losses");
function binaryAccuracy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var threshold = K.scalarTimesArray(K.getScalar(0.5), tfc.onesLike(yPred));
        var yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);
        return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);
    });
}
exports.binaryAccuracy = binaryAccuracy;
function categoricalAccuracy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'); });
}
exports.categoricalAccuracy = categoricalAccuracy;
function binaryCrossentropy(yTrue, yPred) {
    return losses_2.binaryCrossentropy(yTrue, yPred);
}
exports.binaryCrossentropy = binaryCrossentropy;
function sparseCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.sparseCategoricalAccuracy = sparseCategoricalAccuracy;
function topKCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.topKCategoricalAccuracy = topKCategoricalAccuracy;
function sparseTopKCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.sparseTopKCategoricalAccuracy = sparseTopKCategoricalAccuracy;
exports.mse = losses_1.meanSquaredError;
exports.MSE = losses_1.meanSquaredError;
exports.mae = losses_1.meanAbsoluteError;
exports.MAE = losses_1.meanAbsoluteError;
exports.mape = losses_1.meanAbsolutePercentageError;
exports.MAPE = losses_1.meanAbsolutePercentageError;
exports.categoricalCrossentropy = losses_1.categoricalCrossentropy;
exports.cosine = losses_1.cosineProximity;
exports.sparseCategoricalCrossentropy = losses_1.sparseCategoricalCrossentropy;
function get(identifier) {
    var metricsMap = {
        binaryAccuracy: binaryAccuracy,
        categoricalAccuracy: categoricalAccuracy,
        categoricalCrossentropy: exports.categoricalCrossentropy,
        sparseCategoricalCrossentropy: exports.sparseCategoricalCrossentropy,
        mse: exports.mse,
        MSE: exports.MSE,
        mae: exports.mae,
        MAE: exports.MAE,
        mape: exports.mape,
        MAPE: exports.MAPE,
        cosine: exports.cosine,
    };
    if (typeof identifier === 'string' && identifier in metricsMap) {
        return metricsMap[identifier];
    }
    else if (typeof identifier !== 'string' && identifier != null) {
        return identifier;
    }
    else {
        throw new errors_1.ValueError("Unknown metric " + identifier);
    }
}
exports.get = get;

},{"./backend/tfjs_backend":160,"./errors":167,"./losses":183,"@tensorflow/tfjs-core":51}],185:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var topology_1 = require("./engine/topology");
var training_1 = require("./engine/training");
var errors_1 = require("./errors");
var serialization_1 = require("./layers/serialization");
var generic_utils = require("./utils/generic_utils");
var serialization_utils_1 = require("./utils/serialization_utils");
function modelFromJSON(modelAndWeightsConfig, customObjects) {
    return __awaiter(this, void 0, void 0, function () {
        var modelTopology, tsConfig, model, weightValues, uniqueWeightValues, _i, _a, weight, skipMismatches, isNamedTensorMap;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    modelTopology = modelAndWeightsConfig.modelTopology;
                    if (modelTopology['model_config'] != null) {
                        modelTopology = modelTopology['model_config'];
                    }
                    tsConfig = serialization_utils_1.convertPythonicToTs(modelTopology);
                    model = serialization_1.deserialize(tsConfig, customObjects);
                    if (!(modelAndWeightsConfig.weightsManifest != null)) return [3, 2];
                    return [4, tfjs_core_1.io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(function (weight) { return weight.originalName; }))];
                case 1:
                    weightValues = _b.sent();
                    uniqueWeightValues = {};
                    for (_i = 0, _a = model.weights; _i < _a.length; _i++) {
                        weight = _a[_i];
                        uniqueWeightValues[weight.originalName] =
                            weightValues[weight.originalName];
                    }
                    skipMismatches = null;
                    isNamedTensorMap = true;
                    model.loadWeights(uniqueWeightValues, skipMismatches, isNamedTensorMap);
                    _b.label = 2;
                case 2: return [2, model];
            }
        });
    });
}
exports.modelFromJSON = modelFromJSON;
function loadModelInternal(pathOrIOHandler) {
    return __awaiter(this, void 0, void 0, function () {
        var handlers;
        return __generator(this, function (_a) {
            if (typeof pathOrIOHandler === 'string') {
                handlers = tfjs_core_1.io.getLoadHandlers(pathOrIOHandler);
                if (handlers.length === 0) {
                    handlers.push(tfjs_core_1.io.browserHTTPRequest(pathOrIOHandler));
                }
                else if (handlers.length > 1) {
                    throw new errors_1.ValueError("Found more than one (" + handlers.length + ") load handlers for " +
                        ("URL '" + pathOrIOHandler + "'"));
                }
                pathOrIOHandler = handlers[0];
            }
            return [2, loadModelFromIOHandler(pathOrIOHandler)];
        });
    });
}
exports.loadModelInternal = loadModelInternal;
function loadModelFromIOHandler(handler, customObjects) {
    return __awaiter(this, void 0, void 0, function () {
        var artifacts, modelTopology, model, skipMismatch, isNamedTensorMap;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (handler.load == null) {
                        throw new errors_1.ValueError('Cannot proceed with model loading because the IOHandler provided ' +
                            'does not have the `load` method implemented.');
                    }
                    return [4, handler.load()];
                case 1:
                    artifacts = _a.sent();
                    modelTopology = artifacts.modelTopology;
                    if (modelTopology['model_config'] != null) {
                        modelTopology = modelTopology['model_config'];
                    }
                    model = serialization_1.deserialize(serialization_utils_1.convertPythonicToTs(modelTopology), customObjects);
                    if (artifacts.weightData != null) {
                        if (artifacts.weightSpecs == null) {
                            throw new errors_1.ValueError('Model artifacts contains weight data, but not weight specs. ' +
                                'Therefore loading of weights cannot proceed.');
                        }
                        skipMismatch = false;
                        isNamedTensorMap = true;
                        model.loadWeights(tfjs_core_1.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs), skipMismatch, isNamedTensorMap);
                    }
                    return [2, model];
            }
        });
    });
}
exports.loadModelFromIOHandler = loadModelFromIOHandler;
var Sequential = (function (_super) {
    __extends(Sequential, _super);
    function Sequential(config) {
        var _this = _super.call(this, { inputs: [], outputs: [] }) || this;
        config = config || {};
        _this.trainable = true;
        _this._updatable = true;
        _this.built = false;
        _this.name = (config.name != null) ? config.name : K.getUid('sequential_');
        if (config.layers != null) {
            for (var _i = 0, _a = config.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                _this.add(layer);
            }
        }
        return _this;
    }
    Sequential_1 = Sequential;
    Sequential.prototype.add = function (layer) {
        var isLayerModelInstance = layer instanceof Sequential_1 || layer instanceof training_1.Model;
        var modelLayer;
        if (isLayerModelInstance) {
            modelLayer = layer;
            if (modelLayer.outputs.length !== 1) {
                throw new errors_1.ValueError('All layers in a Sequential model ' +
                    'should have a single output tensor. ' +
                    'For multi-output layers, ' +
                    'use the functional API.');
            }
            if (modelLayer.inputs.length !== 1) {
                throw new errors_1.ValueError('All layers in a Sequential model ' +
                    'should have a single input tensor. ' +
                    'For multi-input layers, ' +
                    'use the functional API.');
            }
        }
        if (this.outputs.length === 0) {
            if (layer.inboundNodes.length === 0) {
                if (layer.batchInputShape == null) {
                    throw new errors_1.ValueError('The first layer in a Sequential model must ' +
                        'get an `inputShape` or `batchInputShape` argument.');
                }
                var x = topology_1.Input({
                    batchShape: layer.batchInputShape,
                    dtype: layer.dtype,
                    name: layer.name + '_input'
                });
                layer.apply(x);
            }
            if (isLayerModelInstance) {
                this.outputs = modelLayer.outputs;
                this.inputs = modelLayer.inputs;
            }
            else {
                if (layer.inboundNodes.length !== 1) {
                    throw new errors_1.ValueError('A layer added to a Sequential model must not already be ' +
                        ("connected somewhere else. Model received layer " + layer.name + " ") +
                        ("which has " + layer.inboundNodes.length + " pre-existing inbound ") +
                        'connections.');
                }
                if (layer.inboundNodes[0].outputTensors.length !== 1) {
                    throw new errors_1.ValueError('All layers in a Sequential model ' +
                        'should have a single output tensor. ' +
                        'For multi-output layers, ' +
                        'use the functional API.');
                }
                this.outputs = [layer.inboundNodes[0].outputTensors[0]];
                this.inputs = topology_1.getSourceInputs(this.outputs[0]);
            }
            new topology_1.Node({
                outboundLayer: this,
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: this.inputs,
                outputTensors: this.outputs,
                inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),
                outputMasks: [null],
                inputShapes: this.inputs.map(function (x) { return x.shape; }),
                outputShapes: this.outputs[0].shape
            });
        }
        else {
            var outputTensor = layer.apply(this.outputs[0]);
            if (Array.isArray(outputTensor)) {
                throw new TypeError('All layers in a Sequential model ' +
                    'should have a single output tensor. ' +
                    'For multi-output layers, ' +
                    'use the functional API.');
            }
            this.outputs = [outputTensor];
            this.inboundNodes[0].outputTensors = this.outputs;
            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
        this.layers.push(layer);
        this.built = false;
    };
    Sequential.prototype.pop = function () {
        if (this.layers.length === 0) {
            throw new TypeError('There are no layers in the model.');
        }
        this.layers.pop();
        if (this.layers.length === 0) {
            this.outputs = [];
            this.inboundNodes = [];
            this.outboundNodes = [];
        }
        else {
            var lastLayerIndex = this.layers.length - 1;
            this.layers[lastLayerIndex].outboundNodes = [];
            this.outputs = [this.layers[lastLayerIndex].output];
            this.inboundNodes[0].outputTensors = this.outputs;
            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
    };
    Sequential.prototype.call = function (inputs, kwargs) {
        if (this.model == null) {
            this.build();
        }
        return this.model.call(inputs, kwargs);
    };
    Sequential.prototype.build = function (inputShape) {
        generic_utils.getExactlyOneShape(inputShape);
        if (this.inputs.length === 0 || this.outputs.length === 0) {
            throw new TypeError('Sequential model cannot be built: model is empty.' +
                ' Add some layers first.');
        }
        this.model = new training_1.Model({
            inputs: this.inputs,
            outputs: this.outputs[0],
            name: this.name + '_model'
        });
        this.model.trainable = this.trainable;
        this.model.updatable = this.updatable;
        this.supportsMasking = this.model.supportsMasking;
        this.inputLayers = this.model.inputLayers;
        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
        this.outputLayers = this.model.outputLayers;
        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
        this.nodesByDepth = this.model.nodesByDepth;
        this.containerNodes = this.model.containerNodes;
        this.outputNames = this.model.outputNames;
        this.inputNames = this.model.inputNames;
        this.built = true;
    };
    Sequential.prototype.setWeights = function (weights) {
        if (this.model == null) {
            this.build();
        }
        this.model.setWeights(weights);
    };
    Object.defineProperty(Sequential.prototype, "updatable", {
        get: function () {
            return this._updatable;
        },
        set: function (value) {
            if (this.built) {
                this.model.updatable = value;
            }
            this._updatable = value;
        },
        enumerable: true,
        configurable: true
    });
    Sequential.prototype.evaluate = function (x, y, config) {
        if (config === void 0) { config = {}; }
        if (!this.built) {
            throw new errors_1.RuntimeError('The model needs to be compiled before being used.');
        }
        return this.model.evaluate(x, y, config);
    };
    Sequential.prototype.predict = function (x, config) {
        if (config === void 0) { config = {}; }
        if (this.model == null) {
            this.build();
        }
        return this.model.predict(x, config);
    };
    Sequential.prototype.predictOnBatch = function (x) {
        if (this.model == null) {
            this.build();
        }
        return this.model.predictOnBatch(x);
    };
    Sequential.prototype.compile = function (config) {
        this.build();
        this.model.compile(config);
        this.optimizer = this.model.optimizer;
        this.loss = this.model.loss;
        this.metrics = this.model.metrics;
        this.metricsTensors = this.model.metricsTensors;
        this.metricsNames = this.model.metricsNames;
    };
    Sequential.prototype.fit = function (x, y, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.built) {
                    throw new errors_1.RuntimeError('The model needs to be compiled before ' +
                        'being used.');
                }
                return [2, this.model.fit(x, y, config)];
            });
        });
    };
    Sequential.fromConfig = function (cls, config) {
        var model = new cls({});
        if (!(model instanceof Sequential_1)) {
            throw new errors_1.ValueError("Sequential.fromConfig called on non-Sequential input: " + model);
        }
        if (!(config instanceof Array)) {
            throw new errors_1.ValueError("Sequential.fromConfig called without an array of configs");
        }
        if (!(config[0].className != null) || config[0]['className'] === 'Merge') {
            throw new errors_1.ValueError('Legacy serialization format not supported yet.');
        }
        for (var _i = 0, _a = config; _i < _a.length; _i++) {
            var conf = _a[_i];
            var layer = serialization_1.deserialize(conf);
            model.add(layer);
        }
        return model;
    };
    Sequential.prototype.getConfig = function () {
        var config = [];
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            config.push({
                className: layer.getClassName(),
                config: layer.getConfig(),
            });
        }
        return config;
    };
    Sequential.className = 'Sequential';
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes' })
    ], Sequential.prototype, "add", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })
    ], Sequential.prototype, "evaluate", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [1] })
    ], Sequential.prototype, "predict", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })
    ], Sequential.prototype, "fit", null);
    Sequential = Sequential_1 = __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes' })
    ], Sequential);
    return Sequential;
    var Sequential_1;
}(training_1.Model));
exports.Sequential = Sequential;
tfjs_core_1.serialization.SerializationMap.register(Sequential);

},{"./backend/tfjs_backend":160,"./engine/topology":165,"./engine/training":166,"./errors":167,"./layers/serialization":181,"./utils/generic_utils":190,"./utils/serialization_utils":192,"@tensorflow/tfjs-core":51}],186:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var errors_1 = require("./errors");
function getOptimizer(identifier) {
    var optimizerMap = {
        'Adagrad': function () { return tfjs_core_1.train.adagrad(.01); },
        'Adam': function () { return tfjs_core_1.train.adam(.001, .9, .999, K.epsilon()); },
        'RMSProp': function () { return tfjs_core_1.train.rmsprop(.001, .9, null, K.epsilon()); },
        'SGD': function () { return tfjs_core_1.train.sgd(.01); }
    };
    optimizerMap['adagrad'] = optimizerMap['Adagrad'];
    optimizerMap['adam'] = optimizerMap['Adam'];
    optimizerMap['rmsprop'] = optimizerMap['RMSProp'];
    optimizerMap['sgd'] = optimizerMap['SGD'];
    if (identifier in optimizerMap) {
        return optimizerMap[identifier]();
    }
    throw new errors_1.ValueError("Unknown Optimizer " + identifier);
}
exports.getOptimizer = getOptimizer;

},{"./backend/tfjs_backend":160,"./errors":167,"@tensorflow/tfjs-core":51}],187:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var generic_utils_1 = require("./utils/generic_utils");
var Regularizer = (function (_super) {
    __extends(Regularizer, _super);
    function Regularizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Regularizer;
}(tfjs_core_1.serialization.Serializable));
exports.Regularizer = Regularizer;
var L1L2 = (function (_super) {
    __extends(L1L2, _super);
    function L1L2(config) {
        var _this = _super.call(this) || this;
        var l1 = config == null || config.l1 == null ? 0.01 : config.l1;
        var l2 = config == null || config.l2 == null ? 0.01 : config.l2;
        _this.hasL1 = l1 !== 0;
        _this.hasL2 = l2 !== 0;
        _this.l1 = K.getScalar(l1);
        _this.l2 = K.getScalar(l2);
        return _this;
    }
    L1L2.prototype.apply = function (x) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var regularization = tfjs_core_1.zeros([1]);
            if (_this.hasL1) {
                regularization =
                    tfjs_core_1.add(regularization, tfjs_core_1.sum(K.scalarTimesArray(_this.l1, tfjs_core_1.abs(x))));
            }
            if (_this.hasL2) {
                regularization =
                    tfjs_core_1.add(regularization, tfjs_core_1.sum(K.scalarTimesArray(_this.l2, K.square(x))));
            }
            return regularization.asScalar();
        });
    };
    L1L2.prototype.getConfig = function () {
        return { 'l1': this.l1.dataSync()[0], 'l2': this.l2.dataSync()[0] };
    };
    L1L2.fromConfig = function (cls, config) {
        return new cls({ l1: config.l1, l2: config.l2 });
    };
    L1L2.className = 'L1L2';
    L1L2 = __decorate([
        tfjs_core_1.doc({ heading: 'Regularizers', namespace: 'regularizers' })
    ], L1L2);
    return L1L2;
}(Regularizer));
exports.L1L2 = L1L2;
tfjs_core_1.serialization.SerializationMap.register(L1L2);
function l1(config) {
    return new L1L2({ l1: config != null ? config.l1 : null, l2: 0 });
}
exports.l1 = l1;
function l2(config) {
    return new L1L2({ l2: config != null ? config.l2 : null, l1: 0 });
}
exports.l2 = l2;
exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'l1l2': 'L1L2'
};
function serializeRegularizer(constraint) {
    return generic_utils_1.serializeKerasObject(constraint);
}
exports.serializeRegularizer = serializeRegularizer;
function deserializeRegularizer(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'regularizer');
}
exports.deserializeRegularizer = deserializeRegularizer;
function getRegularizer(identifier) {
    if (identifier == null) {
        return null;
    }
    if (typeof identifier === 'string') {
        var className = identifier in exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        var config = { className: className, config: {} };
        return deserializeRegularizer(config);
    }
    else if (identifier instanceof Regularizer) {
        return identifier;
    }
    else {
        return deserializeRegularizer(identifier);
    }
}
exports.getRegularizer = getRegularizer;

},{"./backend/tfjs_backend":160,"./utils/generic_utils":190,"@tensorflow/tfjs-core":51}],188:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("./common");
var _nextUniqueTensorId = 0;
function getNextUniqueTensorId() {
    return _nextUniqueTensorId++;
}
exports.getNextUniqueTensorId = getNextUniqueTensorId;
var SymbolicTensor = (function () {
    function SymbolicTensor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {
        this.dtype = dtype;
        this.shape = shape;
        this.sourceLayer = sourceLayer;
        this.inputs = inputs;
        this.callArgs = callArgs;
        this.outputTensorIndex = outputTensorIndex;
        this.id = getNextUniqueTensorId();
        if (name != null) {
            this.originalName = common_1.getScopedTensorName(name);
            this.name = common_1.getUniqueTensorName(this.originalName);
        }
        this.rank = shape.length;
    }
    SymbolicTensor = __decorate([
        tfjs_core_1.doc({ heading: 'Models', 'subheading': 'Classes' })
    ], SymbolicTensor);
    return SymbolicTensor;
}());
exports.SymbolicTensor = SymbolicTensor;

},{"./common":162,"@tensorflow/tfjs-core":51}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
var generic_utils_1 = require("./generic_utils");
var math_utils_1 = require("./math_utils");
function normalizeArray(value, n, name) {
    if (typeof value === 'number') {
        return generic_utils_1.pyListRepeat(value, n);
    }
    else {
        if (value.length !== n) {
            throw new errors_1.ValueError("The " + name + " argument must be a tuple of " + n + " integers. Received: " +
                (value.length + " elements."));
        }
        for (var i = 0; i < n; ++i) {
            var singleValue = value[i];
            if (!math_utils_1.isInteger(singleValue)) {
                throw new errors_1.ValueError("The " + name + " argument must be a tuple of " + n + " integers. Received: " +
                    (JSON.stringify(value) + " including a non-integer number ") +
                    ("" + singleValue));
            }
        }
        return value;
    }
}
exports.normalizeArray = normalizeArray;
function convOutputLength(inputLength, filterSize, padding, stride, dilation) {
    if (dilation === void 0) { dilation = 1; }
    if (inputLength == null) {
        return inputLength;
    }
    var dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);
    var outputLength;
    if (padding === 'same') {
        outputLength = inputLength;
    }
    else {
        outputLength = inputLength - dilatedFilterSize + 1;
    }
    return Math.floor((outputLength + stride - 1) / stride);
}
exports.convOutputLength = convOutputLength;
function deconvLength(dimSize, strideSize, kernelSize, padding) {
    if (dimSize == null) {
        return null;
    }
    if (padding === 'valid') {
        dimSize = dimSize * strideSize + math_utils_1.max([kernelSize - strideSize, 0]);
    }
    else if (padding === 'same') {
        dimSize = dimSize * strideSize;
    }
    else {
        throw new errors_1.ValueError("Unsupport padding mode: " + padding + ".");
    }
    return dimSize;
}
exports.deconvLength = deconvLength;

},{"../errors":167,"./generic_utils":190,"./math_utils":191}],190:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
function pyListRepeat(value, numValues) {
    if (Array.isArray(value)) {
        var newArray = [];
        for (var i = 0; i < numValues; i++) {
            newArray = newArray.concat(value);
        }
        return newArray;
    }
    else {
        var newArray = new Array(numValues);
        newArray.fill(value);
        return newArray;
    }
}
exports.pyListRepeat = pyListRepeat;
function assert(val, message) {
    if (!val) {
        throw new errors_1.AssertionError(message);
    }
}
exports.assert = assert;
function count(array, refernce) {
    var counter = 0;
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var item = array_1[_i];
        if (item === refernce) {
            counter++;
        }
    }
    return counter;
}
exports.count = count;
function singletonOrArray(xs) {
    if (xs.length === 1) {
        return xs[0];
    }
    return xs;
}
exports.singletonOrArray = singletonOrArray;
function toList(x) {
    if (Array.isArray(x)) {
        return x;
    }
    return [x];
}
exports.toList = toList;
function objectListUid(objs) {
    var objectList = toList(objs);
    var retVal = '';
    for (var _i = 0, objectList_1 = objectList; _i < objectList_1.length; _i++) {
        var obj = objectList_1[_i];
        if (obj.id == null) {
            throw new errors_1.ValueError("Object " + obj + " passed to objectListUid without an id");
        }
        if (retVal !== '') {
            retVal = retVal + ', ';
        }
        retVal = retVal + Math.abs(obj.id);
    }
    return retVal;
}
exports.objectListUid = objectListUid;
function isArrayOfShapes(x) {
    return Array.isArray(x) && Array.isArray(x[0]);
}
exports.isArrayOfShapes = isArrayOfShapes;
function normalizeShapeList(x) {
    if (x.length === 0) {
        return [];
    }
    if (!Array.isArray(x[0])) {
        return [x];
    }
    return x;
}
exports.normalizeShapeList = normalizeShapeList;
function toSnakeCase(name) {
    var intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, '$1_$2');
    var insecure = intermediate.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
    if (insecure[0] !== '_') {
        return insecure;
    }
    return 'private' + insecure;
}
exports.toSnakeCase = toSnakeCase;
function toCamelCase(identifier) {
    if (identifier.length <= 1) {
        return identifier;
    }
    if (identifier.indexOf('_') === -1) {
        return identifier;
    }
    return identifier.replace(/[_]+(\w|$)/g, function (m, p1) { return p1.toUpperCase(); });
}
exports.toCamelCase = toCamelCase;
var _GLOBAL_CUSTOM_OBJECTS = {};
function serializeKerasObject(instance) {
    if (instance === null || instance === undefined) {
        return null;
    }
    return { className: instance.getClassName(), config: instance.getConfig() };
}
exports.serializeKerasObject = serializeKerasObject;
function deserializeKerasObject(identifier, moduleObjects, customObjects, printableModuleName) {
    if (moduleObjects === void 0) { moduleObjects = {}; }
    if (customObjects === void 0) { customObjects = {}; }
    if (printableModuleName === void 0) { printableModuleName = 'object'; }
    if (typeof identifier === 'string') {
        var functionName = identifier;
        var fn = void 0;
        if (functionName in customObjects) {
            fn = customObjects[functionName];
        }
        else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {
            fn = _GLOBAL_CUSTOM_OBJECTS[functionName];
        }
        else {
            fn = moduleObjects[functionName];
            if (fn == null) {
                throw new errors_1.ValueError("Unknown " + printableModuleName + ": " + identifier);
            }
        }
        return fn;
    }
    else {
        var config = identifier;
        if (config.className == null || config.config == null) {
            throw new errors_1.ValueError(printableModuleName + ": Improper config format: " +
                (JSON.stringify(config) + ".\n") +
                "'className' and 'config' must set.");
        }
        var className = config.className;
        var cls = void 0, fromConfig = void 0;
        if (className in customObjects) {
            _a = customObjects.get(className), cls = _a[0], fromConfig = _a[1];
        }
        else if (className in _GLOBAL_CUSTOM_OBJECTS) {
            _b = _GLOBAL_CUSTOM_OBJECTS.className, cls = _b[0], fromConfig = _b[1];
        }
        else if (className in moduleObjects) {
            _c = moduleObjects[className], cls = _c[0], fromConfig = _c[1];
        }
        if (cls == null) {
            throw new errors_1.ValueError("Unknown " + printableModuleName + ": " + className);
        }
        if (fromConfig != null) {
            var customObjectsCombined = {};
            for (var _i = 0, _d = Object.keys(_GLOBAL_CUSTOM_OBJECTS); _i < _d.length; _i++) {
                var key = _d[_i];
                customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];
            }
            for (var _e = 0, _f = Object.keys(customObjects); _e < _f.length; _e++) {
                var key = _f[_e];
                customObjectsCombined[key] = customObjects[key];
            }
            var nestedConfig = config.config;
            nestedConfig.customObjects = customObjectsCombined;
            var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
            for (var _g = 0, _h = Object.keys(customObjects); _g < _h.length; _g++) {
                var key = _h[_g];
                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
            }
            var returnObj = fromConfig(cls, config.config);
            _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);
            return returnObj;
        }
        else {
            var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
            for (var _j = 0, _k = Object.keys(customObjects); _j < _k.length; _j++) {
                var key = _k[_j];
                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
            }
            var returnObj = new cls(config.config);
            _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);
            return returnObj;
        }
    }
    var _a, _b, _c;
}
exports.deserializeKerasObject = deserializeKerasObject;
function getExactlyOneTensor(xs) {
    var x;
    if (Array.isArray(xs)) {
        if (xs.length !== 1) {
            throw new errors_1.ValueError("Expected Tensor length to be 1; got " + xs.length);
        }
        x = xs[0];
    }
    else {
        x = xs;
    }
    return x;
}
exports.getExactlyOneTensor = getExactlyOneTensor;
function getExactlyOneShape(shapes) {
    if (Array.isArray(shapes) && Array.isArray(shapes[0])) {
        if (shapes.length === 1) {
            shapes = shapes;
            return shapes[0];
        }
        else {
            throw new errors_1.ValueError("Expected exactly 1 Shape; got " + shapes.length);
        }
    }
    else {
        return shapes;
    }
}
exports.getExactlyOneShape = getExactlyOneShape;
function numberCompare(a, b) {
    return (a < b) ? -1 : ((a > b) ? 1 : 0);
}
exports.numberCompare = numberCompare;
function reverseNumberCompare(a, b) {
    return -1 * numberCompare(a, b);
}
exports.reverseNumberCompare = reverseNumberCompare;
function stringToDType(dtype) {
    switch (dtype) {
        case 'float32':
            return 'float32';
        default:
            throw new errors_1.ValueError("Invalid dtype: " + dtype);
    }
}
exports.stringToDType = stringToDType;
function stringsEqual(xs, ys) {
    if (xs == null || ys == null) {
        return xs === ys;
    }
    if (xs.length !== ys.length) {
        return false;
    }
    for (var i = 0; i < xs.length; ++i) {
        if (xs[i] !== ys[i]) {
            return false;
        }
    }
    return true;
}
exports.stringsEqual = stringsEqual;
function unique(xs) {
    if (xs == null) {
        return xs;
    }
    var out = [];
    for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {
        var x = xs_1[_i];
        if (out.indexOf(x) === -1) {
            out.push(x);
        }
    }
    return out;
}
exports.unique = unique;
function isObjectEmpty(obj) {
    if (obj == null) {
        throw new errors_1.ValueError("Invalid value in obj: " + JSON.stringify(obj));
    }
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
exports.isObjectEmpty = isObjectEmpty;
function checkStringTypeUnionValue(values, label, value) {
    if (value == null) {
        return;
    }
    if (values.indexOf(value) < 0) {
        throw new errors_1.ValueError(value + " is not a valid " + label + ".  Valid values are " + values + " or null/undefined.");
    }
}
exports.checkStringTypeUnionValue = checkStringTypeUnionValue;

},{"../errors":167}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var errors_1 = require("../errors");
function isInteger(x) {
    return x === parseInt(x.toString(), 10);
}
exports.isInteger = isInteger;
function arrayProd(array, begin, end) {
    if (begin == null) {
        begin = 0;
    }
    if (end == null) {
        end = array.length;
    }
    var prod = 1;
    for (var i = begin; i < end; ++i) {
        prod *= array[i];
    }
    return prod;
}
exports.arrayProd = arrayProd;
function toArray1D(array) {
    array = Array.isArray(array) ? new Float32Array(array) : array;
    return tfjs_core_1.tensor1d(array);
}
function min(array) {
    return tfc.min(toArray1D(array)).dataSync()[0];
}
exports.min = min;
function max(array) {
    return tfc.max(toArray1D(array)).dataSync()[0];
}
exports.max = max;
function sum(array) {
    return tfc.sum(toArray1D(array)).dataSync()[0];
}
exports.sum = sum;
function mean(array) {
    return sum(array) / array.length;
}
exports.mean = mean;
function variance(array) {
    var demeaned = tfc.sub(toArray1D(array), tfjs_core_1.scalar(mean(array)));
    var sumSquare = tfc.sum(tfc.mulStrict(demeaned, demeaned)).dataSync()[0];
    return sumSquare / array.length;
}
exports.variance = variance;
function median(array) {
    var arraySorted = array.slice().sort(function (a, b) { return a - b; });
    var lowIdx = Math.floor((arraySorted.length - 1) / 2);
    var highIdx = Math.ceil((arraySorted.length - 1) / 2);
    if (lowIdx === highIdx) {
        return arraySorted[lowIdx];
    }
    return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;
}
exports.median = median;
function range(begin, end) {
    if (end < begin) {
        throw new errors_1.ValueError("end (" + end + ") < begin (" + begin + ") is forbidden.");
    }
    var out = [];
    for (var i = begin; i < end; ++i) {
        out.push(i);
    }
    return out;
}
exports.range = range;

},{"../errors":167,"@tensorflow/tfjs-core":51}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generic_utils = require("../utils/generic_utils");
function isArrayItemInputOrOutputName(key, index, value) {
    return (key === 'inboundNodes' || key === 'outputLayers' ||
        key === 'inputLayers') &&
        index === 0 && typeof value === 'string';
}
function convertPythonicToTs(pythonicConfig, key) {
    if (pythonicConfig === null) {
        return null;
    }
    else if (typeof pythonicConfig === 'string') {
        return generic_utils.toCamelCase(pythonicConfig);
    }
    else if ((typeof pythonicConfig === 'number') ||
        (typeof pythonicConfig === 'boolean')) {
        return pythonicConfig;
    }
    else if (pythonicConfig instanceof Array) {
        var tsArray = [];
        var arrayLength = pythonicConfig.length;
        for (var i = 0; i < arrayLength; ++i) {
            var item = pythonicConfig[i];
            if (isArrayItemInputOrOutputName(key, i, item)) {
                tsArray.push(item);
            }
            else {
                tsArray.push(convertPythonicToTs(item, key));
            }
        }
        return tsArray;
    }
    else {
        var tsDict = {};
        for (var _i = 0, _a = Object.keys(pythonicConfig); _i < _a.length; _i++) {
            var pythonicKey = _a[_i];
            var pythonicValue = pythonicConfig[pythonicKey];
            if (pythonicKey === 'name' && typeof pythonicValue === 'string') {
                tsDict[pythonicKey] = pythonicValue;
            }
            else {
                var tsKey = generic_utils.toCamelCase(pythonicKey);
                tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);
            }
        }
        return tsDict;
    }
}
exports.convertPythonicToTs = convertPythonicToTs;
function convertTsToPythonic(tsConfig, key) {
    if (tsConfig === null || tsConfig === undefined) {
        return null;
    }
    else if (typeof tsConfig === 'string') {
        return generic_utils.toSnakeCase(tsConfig);
    }
    else if ((typeof tsConfig === 'number') || (typeof tsConfig === 'boolean')) {
        return tsConfig;
    }
    else if (tsConfig instanceof Array) {
        var pyArray = [];
        var arrayLength = tsConfig.length;
        for (var i = 0; i < arrayLength; ++i) {
            var item = tsConfig[i];
            if (isArrayItemInputOrOutputName(key, i, item)) {
                pyArray.push(item);
            }
            else {
                pyArray.push(convertTsToPythonic(item, key));
            }
        }
        return pyArray;
    }
    else {
        var pyDict = {};
        for (var _i = 0, _a = Object.keys(tsConfig); _i < _a.length; _i++) {
            var tsKey = _a[_i];
            var tsValue = tsConfig[tsKey];
            var pyKey = generic_utils.toSnakeCase(tsKey);
            if ((tsKey === 'name' || tsKey === 'className') &&
                typeof tsValue === 'string') {
                pyDict[pyKey] = tsValue;
            }
            else {
                pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);
            }
        }
        return pyDict;
    }
}
exports.convertTsToPythonic = convertTsToPythonic;

},{"../utils/generic_utils":190}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_backend_1 = require("./backend/tfjs_backend");
var common_1 = require("./common");
var errors_1 = require("./errors");
var types_1 = require("./types");
var DEFAULT_VARIABLE_NAME_PREFIX = 'Variable';
var LayerVariable = (function () {
    function LayerVariable(val, dtype, name, trainable, constraint) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (name === void 0) { name = DEFAULT_VARIABLE_NAME_PREFIX; }
        if (trainable === void 0) { trainable = true; }
        if (constraint === void 0) { constraint = null; }
        this.dtype = dtype == null ? 'float32' : dtype;
        this.shape = val.shape;
        this.id = types_1.getNextUniqueTensorId();
        name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;
        this.originalName = common_1.getScopedTensorName(name);
        this.name = common_1.getUniqueTensorName(this.originalName);
        this.trainable = trainable;
        this.constraint = constraint;
        this.val = tfc.variable(val, this.trainable, this.name, this.dtype);
    }
    LayerVariable.prototype.read = function () {
        return this.val;
    };
    LayerVariable.prototype.write = function (newVal) {
        checkShapesMatch(this.val, newVal);
        this.val.assign(newVal);
        if (this.constraint != null) {
            this.val.assign(this.constraint.apply(this.val));
        }
        return this;
    };
    return LayerVariable;
}());
exports.LayerVariable = LayerVariable;
function checkShapesMatch(x, y) {
    if (x.shape.toString() !== y.shape.toString()) {
        throw new Error('Shape mismatch: ' + JSON.stringify(x.shape) + ' vs. ' +
            JSON.stringify(y.shape));
    }
}
function variable(x, dtype, name, constraint) {
    return new LayerVariable(x, dtype, name, true, constraint);
}
exports.variable = variable;
function zerosVariable(shape, dtype, name) {
    return new LayerVariable(tfc.zeros(shape), dtype, name);
}
exports.zerosVariable = zerosVariable;
function zerosLike(x, dtype, name) {
    return new LayerVariable(tfc.zerosLike(x), dtype, name);
}
exports.zerosLike = zerosLike;
function onesVariable(shape, dtype, name) {
    var allocated = tfc.ones(shape);
    return new LayerVariable(allocated, dtype, name);
}
exports.onesVariable = onesVariable;
function onesLike(x, dtype, name) {
    var allocated = tfc.onesLike(x);
    return new LayerVariable(allocated, dtype, name);
}
exports.onesLike = onesLike;
function eyeVariable(size, dtype, name) {
    return new LayerVariable(tfc.eye(size), dtype, name);
}
exports.eyeVariable = eyeVariable;
function randomUniformVariable(shape, minval, maxval, dtype, seed, name) {
    if (name === void 0) { name = 'randomUniform'; }
    return new LayerVariable(tfc.randomUniform(shape, minval, maxval, dtype), dtype, name);
}
exports.randomUniformVariable = randomUniformVariable;
function truncatedNormalVariable(shape, mean, stddev, dtype, seed, name) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    if (name === void 0) { name = 'truncatedNormal'; }
    if (dtype === 'bool') {
        throw new errors_1.NotImplementedError("randomNormal does not support dType bool.");
    }
    return new LayerVariable(tfc.truncatedNormal(shape, mean, stddev, dtype, seed), dtype, name);
}
exports.truncatedNormalVariable = truncatedNormalVariable;
function randomNormalVariable(shape, mean, stddev, dtype, seed, name) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    if (name === void 0) { name = 'randomNormal'; }
    if (dtype === 'bool') {
        throw new errors_1.NotImplementedError("randomNormalVariable does not support dType bool.");
    }
    return new LayerVariable(tfjs_backend_1.randomNormal(shape, mean, stddev, dtype, seed), dtype, name);
}
exports.randomNormalVariable = randomNormalVariable;
function update(x, xNew) {
    return x.write(xNew);
}
exports.update = update;
function updateAdd(x, increment) {
    return x.write(tfc.add(x.read(), increment));
}
exports.updateAdd = updateAdd;
function updateSub(x, decrement) {
    return x.write(tfc.sub(x.read(), decrement));
}
exports.updateSub = updateSub;
function batchGetValue(xs) {
    return xs.map(function (x) { return x.read(); });
}
exports.batchGetValue = batchGetValue;
function batchSetValue(variablesAndValues) {
    variablesAndValues.map(function (variableAndValue) {
        var variable = variableAndValue[0];
        variable.write(variableAndValue[1]);
    });
}
exports.batchSetValue = batchSetValue;

},{"./backend/tfjs_backend":160,"./common":162,"./errors":167,"./types":188,"@tensorflow/tfjs-core":51}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.6.6';
exports.version = version;

},{}],195:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("@tensorflow/tfjs-core"));
__export(require("@tensorflow/tfjs-layers"));
__export(require("@tensorflow/tfjs-converter"));
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var tfjs_layers_1 = require("@tensorflow/tfjs-layers");
var tfjs_converter_1 = require("@tensorflow/tfjs-converter");
var version_1 = require("./version");
exports.version = {
    'tfjs-core': tfjs_core_1.version_core,
    'tfjs-layers': tfjs_layers_1.version_layers,
    'tfjs-converter': tfjs_converter_1.version_converter,
    'tfjs': version_1.version
};

},{"./version":196,"@tensorflow/tfjs-converter":13,"@tensorflow/tfjs-core":51,"@tensorflow/tfjs-layers":169}],196:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"dup":156}],197:[function(require,module,exports){
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");

},{"./src/index-minimal":198}],198:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Configure serialization
protobuf.Writer._configure(protobuf.BufferWriter);
configure();

},{"./reader":199,"./reader_buffer":200,"./roots":201,"./rpc":202,"./util/minimal":205,"./writer":206,"./writer_buffer":207}],199:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            do { // eslint-disable-line no-constant-condition
                if ((wireType = this.uint32() & 7) === 4)
                    break;
                this.skipType(wireType);
            } while (true);
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":205}],200:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

},{"./reader":199,"./util/minimal":205}],201:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],202:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":203}],203:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":205}],204:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":205}],205:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./longbits":204,"@protobufjs/aspromise":2,"@protobufjs/base64":3,"@protobufjs/eventemitter":4,"@protobufjs/float":5,"@protobufjs/inquire":6,"@protobufjs/pool":7,"@protobufjs/utf8":8}],206:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};

},{"./util/minimal":205}],207:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

},{"./util/minimal":205,"./writer":206}],208:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":209,"./lib/tychei":210,"./lib/xor128":211,"./lib/xor4096":212,"./lib/xorshift7":213,"./lib/xorwow":214,"./seedrandom":215}],209:[function(require,module,exports){
// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],210:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],211:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],212:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],213:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],214:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],215:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":216}],216:[function(require,module,exports){

},{}],217:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],218:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],219:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],220:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],221:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":219,"./encode":220}],222:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":223,"punycode":218,"querystring":221}],223:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImZ1bmN0aW9uYWxfYXV0b2VuY29kZXIuanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Jhc2U2NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvaW5xdWlyZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9kYXRhL2NvbXBpbGVkX2FwaS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L2V4ZWN1dG9yL2V4ZWN1dGlvbl9jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3QvZXhlY3V0b3IvZnJvemVuX21vZGVsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3QvZXhlY3V0b3IvZ3JhcGhfZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL2FyaXRobWV0aWNfZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL2V4ZWN1dG9ycy9iYXNpY19tYXRoX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9leGVjdXRvcnMvY29udHJvbF9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL2NvbnZvbHV0aW9uX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9leGVjdXRvcnMvY3JlYXRpb25fZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL2V4ZWN1dG9ycy9ncmFwaF9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL2ltYWdlX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9leGVjdXRvcnMvbG9naWNhbF9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL21hdHJpY2VzX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9leGVjdXRvcnMvbm9ybWFsaXphdGlvbl9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL3JlZHVjdGlvbl9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL3NsaWNlX2pvaW5fZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL2V4ZWN1dG9ycy90cmFuc2Zvcm1hdGlvbl9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L2FyaXRobWV0aWMuanNvbiIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvb3BfbGlzdC9iYXNpY19tYXRoLmpzb24iLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wX2xpc3QvY29udHJvbC5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L2NvbnZvbHV0aW9uLmpzb24iLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wX2xpc3QvY3JlYXRpb24uanNvbiIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvb3BfbGlzdC9ncmFwaC5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L2ltYWdlLmpzb24iLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wX2xpc3QvbG9naWNhbC5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L21hdHJpY2VzLmpzb24iLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wX2xpc3Qvbm9ybWFsaXphdGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L3JlZHVjdGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L3NsaWNlX2pvaW4uanNvbiIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvb3BfbGlzdC90cmFuc2Zvcm1hdGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcGVyYXRpb25fZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wZXJhdGlvbl9tYXBwZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2Jyb3dzZXJfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9kZXZpY2VfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9kb2MuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2Vudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvZ3JhZGllbnRzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2lvL2Jyb3dzZXJfZmlsZXMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvaW8vYnJvd3Nlcl9odHRwLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2lvL2luZGV4ZWRfZGIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvaW8vaW8uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvaW8vaW9fdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvaW8vbG9jYWxfc3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9pby9tb2RlbF9tYW5hZ2VtZW50LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2lvL3JvdXRlcl9yZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9pby90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9pby93ZWlnaHRzX2xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL2JhY2tlbmRfY3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvYmFja2VuZF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvYmFja2VuZF93ZWJnbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL2FyZ21pbm1heF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9hdmdfcG9vbF9iYWNrcHJvcF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9iYXRjaG5vcm1fZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvYmluYXJ5b3BfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvY2xpcF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9jb25jYXRfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvY29udl9iYWNrcHJvcF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9jb252X2JhY2twcm9wX2dwdV9kZXB0aHdpc2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9jb252X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL2N1bXN1bV9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9mcm9tX3BpeGVsc19ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9nYXRoZXJfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvZ3BncHVfY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL2dwZ3B1X21hdGguanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9ncGdwdV91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvbG9naWNhbF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9scm5fZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvbWF4X3Bvb2xfYmFja3Byb3BfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvbXVsbWF0X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL211bHRpbm9taWFsX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL29uZWhvdF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9wYWRfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvcG9vbF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9yZWR1Y2VfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvcmVzaXplX2JpbGluZWFyX2JhY2twcm9wX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9yZXNpemVfbmVhcmVzdF9uZWlnaGJvcl9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9yZXZlcnNlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3NoYWRlcl9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3NsaWNlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3N0cmlkZWRfc2xpY2VfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvdGV4X3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC90ZXh0dXJlX21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC90aWxlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3RyYW5zcG9zZV9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC91bmFyeW9wX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3dlYmdsX3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2FycmF5X29wcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvYXhpc191dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9iYXRjaG5vcm0uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2JpbmFyeV9vcHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2Jyb2FkY2FzdF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9jb21wYXJlLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9jb25jYXQuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2NvbmNhdF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9jb252LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9jb252X3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2VyZl91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9pbWFnZV9vcHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2xpbmFsZ19vcHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2xvZ2ljYWxfb3BzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9sb3NzX29wcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvbHJuLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9sc3RtLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9tYXRtdWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL21vdmluZ19hdmVyYWdlLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9ub3JtLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9vcGVyYXRpb24uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL29wcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvcmFuZC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvcmVkdWNlX3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3JlZHVjdGlvbl9vcHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3JldmVyc2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3NlbHVfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvc2xpY2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3NsaWNlX3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3NvZnRtYXguanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3N0cmlkZWRfc2xpY2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3RyYW5zcG9zZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvdW5hcnlfb3BzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wdGltaXplcnMvYWRhZGVsdGFfb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9hZGFtX29wdGltaXplci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHRpbWl6ZXJzL2FkYW1heF9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9tb21lbnR1bV9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9vcHRpbWl6ZXJfY29uc3RydWN0b3JzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3Byb2ZpbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3NlcmlhbGl6YXRpb24uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGFwZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC90ZW5zb3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGVuc29yX3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGVzdF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3RyYWNraW5nLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3RyYWluLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC93ZWJnbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2FjdGl2YXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvYmFja2VuZC9jb21tb24uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9iYWNrZW5kL3RmanNfYmFja2VuZC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2NhbGxiYWNrcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2NvbnN0cmFpbnRzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZW5naW5lL2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZW5naW5lL3RvcG9sb2d5LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZW5naW5lL3RyYWluaW5nLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZXhwb3J0cy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvaW5pdGlhbGl6ZXJzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL2FkdmFuY2VkX2FjdGl2YXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL2NvbnZvbHV0aW9uYWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9sYXllcnMvY29udm9sdXRpb25hbF9kZXB0aHdpc2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9sYXllcnMvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2xheWVycy9lbWJlZGRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL21lcmdlLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL25vcm1hbGl6YXRpb24uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9sYXllcnMvcGFkZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2xheWVycy9wb29saW5nLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL3JlY3VycmVudC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2xheWVycy9zZXJpYWxpemF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL3dyYXBwZXJzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbG9zc2VzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbWV0cmljcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L21vZGVscy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L29wdGltaXplcnMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9yZWd1bGFyaXplcnMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L3V0aWxzL2NvbnZfdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC91dGlscy9nZW5lcmljX3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvdXRpbHMvbWF0aF91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L3V0aWxzL3NlcmlhbGl6YXRpb25fdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC92YXJpYWJsZXMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3IxMjguanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3JzaGlmdDcuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2akRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Q0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFrREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNya0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImNvbnN0IHRmID0gcmVxdWlyZSgnQHRlbnNvcmZsb3cvdGZqcycpXG5cblxudGVzdGluZyA9IHRydWVcblxuaWYodGVzdGluZyl7XG4gIHdpbmRvdy50ZiA9IHRmXG4gIHZhciBzID0gMTAgXG4gIHZhciBleWUgPSB0Zi5leWUocykubXVsKHRmLnNjYWxhcigyKSlcbiAgZXllID0gZXllLm1hdE11bChjcmVhdGVSb2xsTWF0cml4KHMsIC0xKSlcbiAgLy9leWUucHJpbnQoKVxuICAvL3RmLmJhdGNoTm9ybWFsaXphdGlvbihleWUsdGYuemVyb3NMaWtlKGV5ZSksIHRmLm9uZXNMaWtlKGV5ZSkubXVsKHRmLnRlbnNvcihbMV0pKSkucHJpbnQoKVxuICB0Zi5saW5hbGcuZ3JhbVNjaG1pZHQoZXllKS5wcmludCgpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIG5leHRUaWNrKGZuKXsgYXdhaXQgdGYubmV4dEZyYW1lKCk7IGZuKCl9XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvbGxNYXRyaXgocywgdCl7XG5cbiAgcmV0dXJuIHJvbGwocywgdClcblxuICBmdW5jdGlvbiByb2xsKHMsIHQpeyBcbiAgICBsID0gcyAqIHNcbiAgICB2YXIgb25lID0gdCA+IDAgPyByb2xsUmlnaHRPbmUobCkgOiByb2xsTGVmdE9uZShNYXRoLmFicyhsKSlcbiAgICB2YXIgcm0gPSB0Zi5leWUoTWF0aC5zcXJ0KGwpKVxuICAgIGZvcih2YXIgeCA9IDA7IHggPCBNYXRoLmFicyh0KTsgeCsrKXtcbiAgICAgICBybSA9IHRmLm1hdE11bChybSwgb25lKVxuICAgIH1cbiAgICByZXR1cm4gcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvbGxMZWZ0T25lKGwpe1xuICAgIHZhciBhID0gbmV3IEZsb2F0MzJBcnJheShsKVxuICAgIHZhciBuID0gTWF0aC5zcXJ0KGwpXG4gICAgYS5maWxsKDApXG4gICAgYS5mb3JFYWNoKChlLGksYSkgPT4gKGkgLSBuKSAlIChuICsgMSkgPT09IDAgPyBhW2ldID0gMSA6IGFbaV0gPSAwKVxuICAgIGFbbiAtIDFdID0gMVxuICAgIHJldHVybiB0Zi50ZW5zb3IoYSwgW24sbl0sICdmbG9hdDMyJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvbGxSaWdodE9uZShsKXtcbiAgICB2YXIgYSA9IG5ldyBGbG9hdDMyQXJyYXkobClcbiAgICB2YXIgbiA9IE1hdGguc3FydChsKVxuICAgIGEuZmlsbCgwKVxuICAgIGEuZm9yRWFjaCgoZSxpLGEpID0+IChpIC0gMSkgJSAobiArIDEpID09PSAwID8gYVtpXSA9IDEgOiBhW2ldID0gMClcbiAgICBhW2wgLSBuXSA9IDFcbiAgICByZXR1cm4gdGYudGVuc29yKGEsIFtuLG5dLCAnZmxvYXQzMicpXG4gIH1cblxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gYXNQcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuYXNQcm9taXNlfS5cclxuICogQHR5cGVkZWYgYXNQcm9taXNlQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgQWRkaXRpb25hbCBhcmd1bWVudHNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2UgZnJvbSBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7YXNQcm9taXNlQ2FsbGJhY2t9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHsqfSBjdHggRnVuY3Rpb24gY29udGV4dFxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBGdW5jdGlvbiBhcmd1bWVudHNcclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2lmaWVkIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eC8qLCB2YXJhcmdzICovKSB7XHJcbiAgICB2YXIgcGFyYW1zICA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgb2Zmc2V0ICA9IDAsXHJcbiAgICAgICAgaW5kZXggICA9IDIsXHJcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIvKiwgdmFyYXJncyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeSk7XHJcblxyXG4vKipcclxuICogUmVhZHMgLyB3cml0ZXMgZmxvYXRzIC8gZG91YmxlcyBmcm9tIC8gdG8gYnVmZmVycy5cclxuICogQG5hbWUgdXRpbC5mbG9hdFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8vIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoZSBwdXJwb3NlIG9mIG5vZGUtYmFzZWQgdGVzdGluZyBpbiBtb2RpZmllZCBnbG9iYWwgZW52aXJvbm1lbnRzXHJcbmZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0cykge1xyXG5cclxuICAgIC8vIGZsb2F0OiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoWyAtMCBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjMyLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4YlszXSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfY3B5IDogd3JpdGVGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX3JldiA6IHdyaXRlRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAvLyBmbG9hdDogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfaWVlZTc1NCh3cml0ZVVpbnQsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQzMjg5MzQ0LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpIC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDEuMTc1NDk0MzUwODIyMjg3NWUtMzgpIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBNYXRoLnJvdW5kKHZhbCAvIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSkpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgdWludCA9IHJlYWRVaW50KGJ1ZiwgcG9zKSxcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAodWludCA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHVpbnQgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDI1NVxyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFKTtcclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8vIGRvdWJsZTogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KFstMF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmNjQuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzddID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzddO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9jcHkgOiByZWFkRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfcmV2IDogcmVhZERvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgIC8vIGRvdWJsZTogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KSB7IC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjE0NjQzNTA3MikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHsgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgbWFudGlzc2EgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMTAyNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgKiA0NTAzNTk5NjI3MzcwNDk2ID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGxvID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYwKSxcclxuICAgICAgICAgICAgICAgIGhpID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IGhpID4+PiAyMCAmIDIwNDcsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IDQyOTQ5NjcyOTYgKiAoaGkgJiAxMDQ4NTc1KSArIGxvO1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDdcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogNWUtMzI0ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG59XHJcblxyXG4vLyB1aW50IGhlbHBlcnNcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludExFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsID4+PiAyNDtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsICAgICAgICAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRMRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF1cclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50QkUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdIDw8IDI0XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10pID4+PiAwO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XHJcblxyXG4vKipcclxuICogUmVxdWlyZXMgYSBtb2R1bGUgb25seSBpZiBhdmFpbGFibGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE1vZHVsZSB0byByZXF1aXJlXHJcbiAqIEByZXR1cm5zIHs/T2JqZWN0fSBSZXF1aXJlZCBtb2R1bGUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZW1wdHksIG90aGVyd2lzZSBgbnVsbGBcclxuICovXHJcbmZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxyXG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsIi8qZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlLCBuby1jb250cm9sLXJlZ2V4LCBuby1wcm90b3R5cGUtYnVpbHRpbnMqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkcHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpO1xuXG52YXIgJFJlYWRlciA9ICRwcm90b2J1Zi5SZWFkZXIsICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5cbnZhciAkcm9vdCA9ICRwcm90b2J1Zi5yb290c1tcImRlZmF1bHRcIl0gfHwgKCRwcm90b2J1Zi5yb290c1tcImRlZmF1bHRcIl0gPSB7fSk7XG5cbiRyb290LnRlbnNvcmZsb3cgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdGVuc29yZmxvdyA9IHt9O1xuXG4gICAgdGVuc29yZmxvdy5BbnkgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gQW55KHApIHtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFueS5wcm90b3R5cGUudHlwZVVybCA9IFwiXCI7XG4gICAgICAgIEFueS5wcm90b3R5cGUudmFsdWUgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgICAgIEFueS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5BbnkoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLnR5cGVVcmwgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG0udmFsdWUgPSByLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQW55O1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LkRhdGFUeXBlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiRFRfSU5WQUxJRFwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJEVF9GTE9BVFwiXSA9IDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJEVF9ET1VCTEVcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiRFRfSU5UMzJcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiRFRfVUlOVDhcIl0gPSA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiRFRfSU5UMTZcIl0gPSA1O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiRFRfSU5UOFwiXSA9IDY7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzddID0gXCJEVF9TVFJJTkdcIl0gPSA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiRFRfQ09NUExFWDY0XCJdID0gODtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIkRUX0lOVDY0XCJdID0gOTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJEVF9CT09MXCJdID0gMTA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExXSA9IFwiRFRfUUlOVDhcIl0gPSAxMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTJdID0gXCJEVF9RVUlOVDhcIl0gPSAxMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTNdID0gXCJEVF9RSU5UMzJcIl0gPSAxMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTRdID0gXCJEVF9CRkxPQVQxNlwiXSA9IDE0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMDFdID0gXCJEVF9GTE9BVF9SRUZcIl0gPSAxMDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwMl0gPSBcIkRUX0RPVUJMRV9SRUZcIl0gPSAxMDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwM10gPSBcIkRUX0lOVDMyX1JFRlwiXSA9IDEwMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTA0XSA9IFwiRFRfVUlOVDhfUkVGXCJdID0gMTA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMDVdID0gXCJEVF9JTlQxNl9SRUZcIl0gPSAxMDU7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwNl0gPSBcIkRUX0lOVDhfUkVGXCJdID0gMTA2O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMDddID0gXCJEVF9TVFJJTkdfUkVGXCJdID0gMTA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMDhdID0gXCJEVF9DT01QTEVYNjRfUkVGXCJdID0gMTA4O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMDldID0gXCJEVF9JTlQ2NF9SRUZcIl0gPSAxMDk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExMF0gPSBcIkRUX0JPT0xfUkVGXCJdID0gMTEwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMTFdID0gXCJEVF9RSU5UOF9SRUZcIl0gPSAxMTE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExMl0gPSBcIkRUX1FVSU5UOF9SRUZcIl0gPSAxMTI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExM10gPSBcIkRUX1FJTlQzMl9SRUZcIl0gPSAxMTM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExNF0gPSBcIkRUX0JGTE9BVDE2X1JFRlwiXSA9IDExNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5UZW5zb3JTaGFwZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBUZW5zb3JTaGFwZShwKSB7XG4gICAgICAgICAgICB0aGlzLmRpbSA9IFtdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgVGVuc29yU2hhcGUucHJvdG90eXBlLmRpbSA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRlbnNvclNoYXBlLnByb3RvdHlwZS51bmtub3duUmFuayA9IGZhbHNlO1xuXG4gICAgICAgIFRlbnNvclNoYXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LlRlbnNvclNoYXBlKCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5kaW0gJiYgbS5kaW0ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZGltID0gW107XG4gICAgICAgICAgICAgICAgICAgIG0uZGltLnB1c2goJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5EaW0uZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtLnVua25vd25SYW5rID0gci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBUZW5zb3JTaGFwZS5EaW0gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIERpbShwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBEaW0ucHJvdG90eXBlLnNpemUgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcbiAgICAgICAgICAgIERpbS5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5cbiAgICAgICAgICAgIERpbS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5EaW0oKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2l6ZSA9IHIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLm5hbWUgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIERpbTtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gVGVuc29yU2hhcGU7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuVGVuc29yID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvcihwKSB7XG4gICAgICAgICAgICB0aGlzLmZsb2F0VmFsID0gW107XG4gICAgICAgICAgICB0aGlzLmRvdWJsZVZhbCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnRWYWwgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nVmFsID0gW107XG4gICAgICAgICAgICB0aGlzLnNjb21wbGV4VmFsID0gW107XG4gICAgICAgICAgICB0aGlzLmludDY0VmFsID0gW107XG4gICAgICAgICAgICB0aGlzLmJvb2xWYWwgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudWludDMyVmFsID0gW107XG4gICAgICAgICAgICB0aGlzLnVpbnQ2NFZhbCA9IFtdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgVGVuc29yLnByb3RvdHlwZS5kdHlwZSA9IDA7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUudGVuc29yU2hhcGUgPSBudWxsO1xuICAgICAgICBUZW5zb3IucHJvdG90eXBlLnZlcnNpb25OdW1iZXIgPSAwO1xuICAgICAgICBUZW5zb3IucHJvdG90eXBlLnRlbnNvckNvbnRlbnQgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuICAgICAgICBUZW5zb3IucHJvdG90eXBlLmZsb2F0VmFsID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGVuc29yLnByb3RvdHlwZS5kb3VibGVWYWwgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBUZW5zb3IucHJvdG90eXBlLmludFZhbCA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUuc3RyaW5nVmFsID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGVuc29yLnByb3RvdHlwZS5zY29tcGxleFZhbCA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUuaW50NjRWYWwgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBUZW5zb3IucHJvdG90eXBlLmJvb2xWYWwgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBUZW5zb3IucHJvdG90eXBlLnVpbnQzMlZhbCA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUudWludDY0VmFsID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICBUZW5zb3IuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuVGVuc29yKCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbS5kdHlwZSA9IHIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtLnRlbnNvclNoYXBlID0gJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbS52ZXJzaW9uTnVtYmVyID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG0udGVuc29yQ29udGVudCA9IHIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLmZsb2F0VmFsICYmIG0uZmxvYXRWYWwubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZmxvYXRWYWwgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0ICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uZmxvYXRWYWwucHVzaChyLmZsb2F0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZmxvYXRWYWwucHVzaChyLmZsb2F0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uZG91YmxlVmFsICYmIG0uZG91YmxlVmFsLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmRvdWJsZVZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5kb3VibGVWYWwucHVzaChyLmRvdWJsZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmRvdWJsZVZhbC5wdXNoKHIuZG91YmxlKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uaW50VmFsICYmIG0uaW50VmFsLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmludFZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5pbnRWYWwucHVzaChyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uaW50VmFsLnB1c2goci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnN0cmluZ1ZhbCAmJiBtLnN0cmluZ1ZhbC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zdHJpbmdWYWwgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbS5zdHJpbmdWYWwucHVzaChyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uc2NvbXBsZXhWYWwgJiYgbS5zY29tcGxleFZhbC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zY29tcGxleFZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zY29tcGxleFZhbC5wdXNoKHIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zY29tcGxleFZhbC5wdXNoKHIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uaW50NjRWYWwgJiYgbS5pbnQ2NFZhbC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5pbnQ2NFZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5pbnQ2NFZhbC5wdXNoKHIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5pbnQ2NFZhbC5wdXNoKHIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uYm9vbFZhbCAmJiBtLmJvb2xWYWwubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYm9vbFZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5ib29sVmFsLnB1c2goci5ib29sKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYm9vbFZhbC5wdXNoKHIuYm9vbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS51aW50MzJWYWwgJiYgbS51aW50MzJWYWwubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udWludDMyVmFsID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnVpbnQzMlZhbC5wdXNoKHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udWludDMyVmFsLnB1c2goci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0udWludDY0VmFsICYmIG0udWludDY0VmFsLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnVpbnQ2NFZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS51aW50NjRWYWwucHVzaChyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnVpbnQ2NFZhbC5wdXNoKHIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvcjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5BdHRyVmFsdWUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gQXR0clZhbHVlKHApIHtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIEF0dHJWYWx1ZS5wcm90b3R5cGUubGlzdCA9IG51bGw7XG4gICAgICAgIEF0dHJWYWx1ZS5wcm90b3R5cGUucyA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG4gICAgICAgIEF0dHJWYWx1ZS5wcm90b3R5cGUuaSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuICAgICAgICBBdHRyVmFsdWUucHJvdG90eXBlLmYgPSAwO1xuICAgICAgICBBdHRyVmFsdWUucHJvdG90eXBlLmIgPSBmYWxzZTtcbiAgICAgICAgQXR0clZhbHVlLnByb3RvdHlwZS50eXBlID0gMDtcbiAgICAgICAgQXR0clZhbHVlLnByb3RvdHlwZS5zaGFwZSA9IG51bGw7XG4gICAgICAgIEF0dHJWYWx1ZS5wcm90b3R5cGUudGVuc29yID0gbnVsbDtcbiAgICAgICAgQXR0clZhbHVlLnByb3RvdHlwZS5wbGFjZWhvbGRlciA9IFwiXCI7XG4gICAgICAgIEF0dHJWYWx1ZS5wcm90b3R5cGUuZnVuYyA9IG51bGw7XG5cbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXR0clZhbHVlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcImxpc3RcIiwgXCJzXCIsIFwiaVwiLCBcImZcIiwgXCJiXCIsIFwidHlwZVwiLCBcInNoYXBlXCIsIFwidGVuc29yXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJmdW5jXCJdKSxcbiAgICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcblxuICAgICAgICBBdHRyVmFsdWUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlKCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbS5saXN0ID0gJHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUuTGlzdFZhbHVlLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtLnMgPSByLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbS5pID0gci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG0uZiA9IHIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtLmIgPSByLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPSByLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbS5zaGFwZSA9ICRyb290LnRlbnNvcmZsb3cuVGVuc29yU2hhcGUuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG0udGVuc29yID0gJHJvb3QudGVuc29yZmxvdy5UZW5zb3IuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIG0ucGxhY2Vob2xkZXIgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBtLmZ1bmMgPSAkcm9vdC50ZW5zb3JmbG93Lk5hbWVBdHRyTGlzdC5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBBdHRyVmFsdWUuTGlzdFZhbHVlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBMaXN0VmFsdWUocCkge1xuICAgICAgICAgICAgICAgIHRoaXMucyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuaSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZiA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYiA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlbnNvciA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZnVuYyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTGlzdFZhbHVlLnByb3RvdHlwZS5zID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUuaSA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgICAgICBMaXN0VmFsdWUucHJvdG90eXBlLmYgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICAgICAgTGlzdFZhbHVlLnByb3RvdHlwZS5iID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUudHlwZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgICAgICBMaXN0VmFsdWUucHJvdG90eXBlLnNoYXBlID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUudGVuc29yID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUuZnVuYyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgIExpc3RWYWx1ZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUuTGlzdFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnMgJiYgbS5zLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnMucHVzaChyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG0uaSAmJiBtLmkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmkucHVzaChyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5pLnB1c2goci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLmYgJiYgbS5mLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5mID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5mLnB1c2goci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uZi5wdXNoKHIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5iICYmIG0uYi5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uYiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0ICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uYi5wdXNoKHIuYm9vbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uYi5wdXNoKHIuYm9vbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnR5cGUgJiYgbS50eXBlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlLnB1c2goci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udHlwZS5wdXNoKHIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5zaGFwZSAmJiBtLnNoYXBlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zaGFwZS5wdXNoKCRyb290LnRlbnNvcmZsb3cuVGVuc29yU2hhcGUuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnRlbnNvciAmJiBtLnRlbnNvci5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udGVuc29yID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnRlbnNvci5wdXNoKCRyb290LnRlbnNvcmZsb3cuVGVuc29yLmRlY29kZShyLCByLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5mdW5jICYmIG0uZnVuYy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uZnVuYyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5mdW5jLnB1c2goJHJvb3QudGVuc29yZmxvdy5OYW1lQXR0ckxpc3QuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBMaXN0VmFsdWU7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIEF0dHJWYWx1ZTtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5OYW1lQXR0ckxpc3QgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gTmFtZUF0dHJMaXN0KHApIHtcbiAgICAgICAgICAgIHRoaXMuYXR0ciA9IHt9O1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgTmFtZUF0dHJMaXN0LnByb3RvdHlwZS5uYW1lID0gXCJcIjtcbiAgICAgICAgTmFtZUF0dHJMaXN0LnByb3RvdHlwZS5hdHRyID0gJHV0aWwuZW1wdHlPYmplY3Q7XG5cbiAgICAgICAgTmFtZUF0dHJMaXN0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93Lk5hbWVBdHRyTGlzdCgpLCBrO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0ubmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwKCkucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLmF0dHIgPT09ICR1dGlsLmVtcHR5T2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hdHRyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGsgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICByLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBtLmF0dHJba10gPSAkcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gTmFtZUF0dHJMaXN0O1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93Lk5vZGVEZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gTm9kZURlZihwKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLmF0dHIgPSB7fTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGVEZWYucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuICAgICAgICBOb2RlRGVmLnByb3RvdHlwZS5vcCA9IFwiXCI7XG4gICAgICAgIE5vZGVEZWYucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgTm9kZURlZi5wcm90b3R5cGUuZGV2aWNlID0gXCJcIjtcbiAgICAgICAgTm9kZURlZi5wcm90b3R5cGUuYXR0ciA9ICR1dGlsLmVtcHR5T2JqZWN0O1xuXG4gICAgICAgIE5vZGVEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuTm9kZURlZigpLCBrO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0ubmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbS5vcCA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5pbnB1dCAmJiBtLmlucHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIG0uaW5wdXQucHVzaChyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtLmRldmljZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwKCkucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLmF0dHIgPT09ICR1dGlsLmVtcHR5T2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hdHRyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGsgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICByLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBtLmF0dHJba10gPSAkcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gTm9kZURlZjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5WZXJzaW9uRGVmID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIFZlcnNpb25EZWYocCkge1xuICAgICAgICAgICAgdGhpcy5iYWRDb25zdW1lcnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIFZlcnNpb25EZWYucHJvdG90eXBlLnByb2R1Y2VyID0gMDtcbiAgICAgICAgVmVyc2lvbkRlZi5wcm90b3R5cGUubWluQ29uc3VtZXIgPSAwO1xuICAgICAgICBWZXJzaW9uRGVmLnByb3RvdHlwZS5iYWRDb25zdW1lcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIFZlcnNpb25EZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuVmVyc2lvbkRlZigpO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0ucHJvZHVjZXIgPSByLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbS5taW5Db25zdW1lciA9IHIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLmJhZENvbnN1bWVycyAmJiBtLmJhZENvbnN1bWVycy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5iYWRDb25zdW1lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0ICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uYmFkQ29uc3VtZXJzLnB1c2goci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmJhZENvbnN1bWVycy5wdXNoKHIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVmVyc2lvbkRlZjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5HcmFwaERlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBHcmFwaERlZihwKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUgPSBbXTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIEdyYXBoRGVmLnByb3RvdHlwZS5ub2RlID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgR3JhcGhEZWYucHJvdG90eXBlLnZlcnNpb25zID0gbnVsbDtcbiAgICAgICAgR3JhcGhEZWYucHJvdG90eXBlLmxpYnJhcnkgPSBudWxsO1xuXG4gICAgICAgIEdyYXBoRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LkdyYXBoRGVmKCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5ub2RlICYmIG0ubm9kZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5ub2RlID0gW107XG4gICAgICAgICAgICAgICAgICAgIG0ubm9kZS5wdXNoKCRyb290LnRlbnNvcmZsb3cuTm9kZURlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG0udmVyc2lvbnMgPSAkcm9vdC50ZW5zb3JmbG93LlZlcnNpb25EZWYuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG0ubGlicmFyeSA9ICRyb290LnRlbnNvcmZsb3cuRnVuY3Rpb25EZWZMaWJyYXJ5LmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBHcmFwaERlZjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIENvbGxlY3Rpb25EZWYocCkge1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgQ29sbGVjdGlvbkRlZi5wcm90b3R5cGUubm9kZUxpc3QgPSBudWxsO1xuICAgICAgICBDb2xsZWN0aW9uRGVmLnByb3RvdHlwZS5ieXRlc0xpc3QgPSBudWxsO1xuICAgICAgICBDb2xsZWN0aW9uRGVmLnByb3RvdHlwZS5pbnQ2NExpc3QgPSBudWxsO1xuICAgICAgICBDb2xsZWN0aW9uRGVmLnByb3RvdHlwZS5mbG9hdExpc3QgPSBudWxsO1xuICAgICAgICBDb2xsZWN0aW9uRGVmLnByb3RvdHlwZS5hbnlMaXN0ID0gbnVsbDtcblxuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xsZWN0aW9uRGVmLnByb3RvdHlwZSwgXCJraW5kXCIsIHtcbiAgICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wibm9kZUxpc3RcIiwgXCJieXRlc0xpc3RcIiwgXCJpbnQ2NExpc3RcIiwgXCJmbG9hdExpc3RcIiwgXCJhbnlMaXN0XCJdKSxcbiAgICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcblxuICAgICAgICBDb2xsZWN0aW9uRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLm5vZGVMaXN0ID0gJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLk5vZGVMaXN0LmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtLmJ5dGVzTGlzdCA9ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5CeXRlc0xpc3QuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG0uaW50NjRMaXN0ID0gJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLkludDY0TGlzdC5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbS5mbG9hdExpc3QgPSAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuRmxvYXRMaXN0LmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtLmFueUxpc3QgPSAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuQW55TGlzdC5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBDb2xsZWN0aW9uRGVmLk5vZGVMaXN0ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBOb2RlTGlzdChwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTm9kZUxpc3QucHJvdG90eXBlLnZhbHVlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgTm9kZUxpc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5Ob2RlTGlzdCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS52YWx1ZSAmJiBtLnZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZS5wdXNoKHIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIE5vZGVMaXN0O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIENvbGxlY3Rpb25EZWYuQnl0ZXNMaXN0ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBCeXRlc0xpc3QocCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJ5dGVzTGlzdC5wcm90b3R5cGUudmFsdWUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICBCeXRlc0xpc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5CeXRlc0xpc3QoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG0udmFsdWUgJiYgbS52YWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udmFsdWUucHVzaChyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVzTGlzdDtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBDb2xsZWN0aW9uRGVmLkludDY0TGlzdCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW50NjRMaXN0KHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBJbnQ2NExpc3QucHJvdG90eXBlLnZhbHVlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgSW50NjRMaXN0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuSW50NjRMaXN0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnZhbHVlICYmIG0udmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZS5wdXNoKHIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlLnB1c2goci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBJbnQ2NExpc3Q7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgQ29sbGVjdGlvbkRlZi5GbG9hdExpc3QgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEZsb2F0TGlzdChwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRmxvYXRMaXN0LnByb3RvdHlwZS52YWx1ZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgIEZsb2F0TGlzdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLkZsb2F0TGlzdCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS52YWx1ZSAmJiBtLnZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0ICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udmFsdWUucHVzaChyLmZsb2F0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZS5wdXNoKHIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gRmxvYXRMaXN0O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIENvbGxlY3Rpb25EZWYuQW55TGlzdCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQW55TGlzdChwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQW55TGlzdC5wcm90b3R5cGUudmFsdWUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICBBbnlMaXN0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuQW55TGlzdCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS52YWx1ZSAmJiBtLnZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZS5wdXNoKCRyb290LnRlbnNvcmZsb3cuQW55LmRlY29kZShyLCByLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gQW55TGlzdDtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gQ29sbGVjdGlvbkRlZjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5TYXZlckRlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBTYXZlckRlZihwKSB7XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBTYXZlckRlZi5wcm90b3R5cGUuZmlsZW5hbWVUZW5zb3JOYW1lID0gXCJcIjtcbiAgICAgICAgU2F2ZXJEZWYucHJvdG90eXBlLnNhdmVUZW5zb3JOYW1lID0gXCJcIjtcbiAgICAgICAgU2F2ZXJEZWYucHJvdG90eXBlLnJlc3RvcmVPcE5hbWUgPSBcIlwiO1xuICAgICAgICBTYXZlckRlZi5wcm90b3R5cGUubWF4VG9LZWVwID0gMDtcbiAgICAgICAgU2F2ZXJEZWYucHJvdG90eXBlLnNoYXJkZWQgPSBmYWxzZTtcbiAgICAgICAgU2F2ZXJEZWYucHJvdG90eXBlLmtlZXBDaGVja3BvaW50RXZlcnlOSG91cnMgPSAwO1xuICAgICAgICBTYXZlckRlZi5wcm90b3R5cGUudmVyc2lvbiA9IDA7XG5cbiAgICAgICAgU2F2ZXJEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuU2F2ZXJEZWYoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLmZpbGVuYW1lVGVuc29yTmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbS5zYXZlVGVuc29yTmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbS5yZXN0b3JlT3BOYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtLm1heFRvS2VlcCA9IHIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtLnNoYXJkZWQgPSByLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtLmtlZXBDaGVja3BvaW50RXZlcnlOSG91cnMgPSByLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbS52ZXJzaW9uID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgU2F2ZXJEZWYuQ2hlY2twb2ludEZvcm1hdFZlcnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIkxFR0FDWVwiXSA9IDA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiVjFcIl0gPSAxO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIlYyXCJdID0gMjtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIFNhdmVyRGVmO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LlRlbnNvckluZm8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gVGVuc29ySW5mbyhwKSB7XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBUZW5zb3JJbmZvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcbiAgICAgICAgVGVuc29ySW5mby5wcm90b3R5cGUuY29vU3BhcnNlID0gbnVsbDtcbiAgICAgICAgVGVuc29ySW5mby5wcm90b3R5cGUuZHR5cGUgPSAwO1xuICAgICAgICBUZW5zb3JJbmZvLnByb3RvdHlwZS50ZW5zb3JTaGFwZSA9IG51bGw7XG5cbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVuc29ySW5mby5wcm90b3R5cGUsIFwiZW5jb2RpbmdcIiwge1xuICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJuYW1lXCIsIFwiY29vU3BhcnNlXCJdKSxcbiAgICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcblxuICAgICAgICBUZW5zb3JJbmZvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LlRlbnNvckluZm8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLm5hbWUgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG0uY29vU3BhcnNlID0gJHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLkNvb1NwYXJzZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbS5kdHlwZSA9IHIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtLnRlbnNvclNoYXBlID0gJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBUZW5zb3JJbmZvLkNvb1NwYXJzZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ29vU3BhcnNlKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIENvb1NwYXJzZS5wcm90b3R5cGUudmFsdWVzVGVuc29yTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBDb29TcGFyc2UucHJvdG90eXBlLmluZGljZXNUZW5zb3JOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIENvb1NwYXJzZS5wcm90b3R5cGUuZGVuc2VTaGFwZVRlbnNvck5hbWUgPSBcIlwiO1xuXG4gICAgICAgICAgICBDb29TcGFyc2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuVGVuc29ySW5mby5Db29TcGFyc2UoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udmFsdWVzVGVuc29yTmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5pbmRpY2VzVGVuc29yTmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5kZW5zZVNoYXBlVGVuc29yTmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gQ29vU3BhcnNlO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBUZW5zb3JJbmZvO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LlNpZ25hdHVyZURlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBTaWduYXR1cmVEZWYocCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0cyA9IHt9O1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgU2lnbmF0dXJlRGVmLnByb3RvdHlwZS5pbnB1dHMgPSAkdXRpbC5lbXB0eU9iamVjdDtcbiAgICAgICAgU2lnbmF0dXJlRGVmLnByb3RvdHlwZS5vdXRwdXRzID0gJHV0aWwuZW1wdHlPYmplY3Q7XG4gICAgICAgIFNpZ25hdHVyZURlZi5wcm90b3R5cGUubWV0aG9kTmFtZSA9IFwiXCI7XG5cbiAgICAgICAgU2lnbmF0dXJlRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LlNpZ25hdHVyZURlZigpLCBrO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcCgpLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5pbnB1dHMgPT09ICR1dGlsLmVtcHR5T2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5pbnB1dHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgayA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHIucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIG0uaW5wdXRzW2tdID0gJHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByLnNraXAoKS5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0ub3V0cHV0cyA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm91dHB1dHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgayA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHIucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIG0ub3V0cHV0c1trXSA9ICRyb290LnRlbnNvcmZsb3cuVGVuc29ySW5mby5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbS5tZXRob2ROYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBTaWduYXR1cmVEZWY7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuQXNzZXRGaWxlRGVmID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIEFzc2V0RmlsZURlZihwKSB7XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBBc3NldEZpbGVEZWYucHJvdG90eXBlLnRlbnNvckluZm8gPSBudWxsO1xuICAgICAgICBBc3NldEZpbGVEZWYucHJvdG90eXBlLmZpbGVuYW1lID0gXCJcIjtcblxuICAgICAgICBBc3NldEZpbGVEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuQXNzZXRGaWxlRGVmKCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbS50ZW5zb3JJbmZvID0gJHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtLmZpbGVuYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBBc3NldEZpbGVEZWY7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuT3BEZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gT3BEZWYocCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEFyZyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRBcmcgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYXR0ciA9IFtdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgT3BEZWYucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuICAgICAgICBPcERlZi5wcm90b3R5cGUuaW5wdXRBcmcgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBPcERlZi5wcm90b3R5cGUub3V0cHV0QXJnID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgT3BEZWYucHJvdG90eXBlLmF0dHIgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBPcERlZi5wcm90b3R5cGUuZGVwcmVjYXRpb24gPSBudWxsO1xuICAgICAgICBPcERlZi5wcm90b3R5cGUuc3VtbWFyeSA9IFwiXCI7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IFwiXCI7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5pc0NvbW11dGF0aXZlID0gZmFsc2U7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5pc0FnZ3JlZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBPcERlZi5wcm90b3R5cGUuaXNTdGF0ZWZ1bCA9IGZhbHNlO1xuICAgICAgICBPcERlZi5wcm90b3R5cGUuYWxsb3dzVW5pbml0aWFsaXplZElucHV0ID0gZmFsc2U7XG5cbiAgICAgICAgT3BEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuT3BEZWYoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLm5hbWUgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uaW5wdXRBcmcgJiYgbS5pbnB1dEFyZy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5pbnB1dEFyZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLmlucHV0QXJnLnB1c2goJHJvb3QudGVuc29yZmxvdy5PcERlZi5BcmdEZWYuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLm91dHB1dEFyZyAmJiBtLm91dHB1dEFyZy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5vdXRwdXRBcmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbS5vdXRwdXRBcmcucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLkFyZ0RlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uYXR0ciAmJiBtLmF0dHIubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYXR0ciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLmF0dHIucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLkF0dHJEZWYuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBtLmRlcHJlY2F0aW9uID0gJHJvb3QudGVuc29yZmxvdy5PcERlZi5PcERlcHJlY2F0aW9uLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtLnN1bW1hcnkgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG0uZGVzY3JpcHRpb24gPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICBtLmlzQ29tbXV0YXRpdmUgPSByLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgbS5pc0FnZ3JlZ2F0ZSA9IHIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICBtLmlzU3RhdGVmdWwgPSByLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgbS5hbGxvd3NVbmluaXRpYWxpemVkSW5wdXQgPSByLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIE9wRGVmLkFyZ0RlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQXJnRGVmKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFyZ0RlZi5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBBcmdEZWYucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICAgICAgICAgIEFyZ0RlZi5wcm90b3R5cGUudHlwZSA9IDA7XG4gICAgICAgICAgICBBcmdEZWYucHJvdG90eXBlLnR5cGVBdHRyID0gXCJcIjtcbiAgICAgICAgICAgIEFyZ0RlZi5wcm90b3R5cGUubnVtYmVyQXR0ciA9IFwiXCI7XG4gICAgICAgICAgICBBcmdEZWYucHJvdG90eXBlLnR5cGVMaXN0QXR0ciA9IFwiXCI7XG4gICAgICAgICAgICBBcmdEZWYucHJvdG90eXBlLmlzUmVmID0gZmFsc2U7XG5cbiAgICAgICAgICAgIEFyZ0RlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5PcERlZi5BcmdEZWYoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5kZXNjcmlwdGlvbiA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udHlwZUF0dHIgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubnVtYmVyQXR0ciA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlTGlzdEF0dHIgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmlzUmVmID0gci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gQXJnRGVmO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIE9wRGVmLkF0dHJEZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEF0dHJEZWYocCkge1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXR0ckRlZi5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBBdHRyRGVmLnByb3RvdHlwZS50eXBlID0gXCJcIjtcbiAgICAgICAgICAgIEF0dHJEZWYucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBBdHRyRGVmLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IFwiXCI7XG4gICAgICAgICAgICBBdHRyRGVmLnByb3RvdHlwZS5oYXNNaW5pbXVtID0gZmFsc2U7XG4gICAgICAgICAgICBBdHRyRGVmLnByb3RvdHlwZS5taW5pbXVtID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG4gICAgICAgICAgICBBdHRyRGVmLnByb3RvdHlwZS5hbGxvd2VkVmFsdWVzID0gbnVsbDtcblxuICAgICAgICAgICAgQXR0ckRlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5PcERlZi5BdHRyRGVmKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLm5hbWUgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udHlwZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5kZWZhdWx0VmFsdWUgPSAkcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5kZXNjcmlwdGlvbiA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5oYXNNaW5pbXVtID0gci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5taW5pbXVtID0gci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYWxsb3dlZFZhbHVlcyA9ICRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBBdHRyRGVmO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIE9wRGVmLk9wRGVwcmVjYXRpb24gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE9wRGVwcmVjYXRpb24ocCkge1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT3BEZXByZWNhdGlvbi5wcm90b3R5cGUudmVyc2lvbiA9IDA7XG4gICAgICAgICAgICBPcERlcHJlY2F0aW9uLnByb3RvdHlwZS5leHBsYW5hdGlvbiA9IFwiXCI7XG5cbiAgICAgICAgICAgIE9wRGVwcmVjYXRpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuT3BEZWYuT3BEZXByZWNhdGlvbigpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS52ZXJzaW9uID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZXhwbGFuYXRpb24gPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIE9wRGVwcmVjYXRpb247XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIE9wRGVmO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93Lk9wTGlzdCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBPcExpc3QocCkge1xuICAgICAgICAgICAgdGhpcy5vcCA9IFtdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgT3BMaXN0LnByb3RvdHlwZS5vcCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgT3BMaXN0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93Lk9wTGlzdCgpO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0ub3AgJiYgbS5vcC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5vcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLm9wLnB1c2goJHJvb3QudGVuc29yZmxvdy5PcERlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIE9wTGlzdDtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5NZXRhR3JhcGhEZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gTWV0YUdyYXBoRGVmKHApIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbkRlZiA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVEZWYgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXRGaWxlRGVmID0gW107XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBNZXRhR3JhcGhEZWYucHJvdG90eXBlLm1ldGFJbmZvRGVmID0gbnVsbDtcbiAgICAgICAgTWV0YUdyYXBoRGVmLnByb3RvdHlwZS5ncmFwaERlZiA9IG51bGw7XG4gICAgICAgIE1ldGFHcmFwaERlZi5wcm90b3R5cGUuc2F2ZXJEZWYgPSBudWxsO1xuICAgICAgICBNZXRhR3JhcGhEZWYucHJvdG90eXBlLmNvbGxlY3Rpb25EZWYgPSAkdXRpbC5lbXB0eU9iamVjdDtcbiAgICAgICAgTWV0YUdyYXBoRGVmLnByb3RvdHlwZS5zaWduYXR1cmVEZWYgPSAkdXRpbC5lbXB0eU9iamVjdDtcbiAgICAgICAgTWV0YUdyYXBoRGVmLnByb3RvdHlwZS5hc3NldEZpbGVEZWYgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIE1ldGFHcmFwaERlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5NZXRhR3JhcGhEZWYoKSwgaztcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLm1ldGFJbmZvRGVmID0gJHJvb3QudGVuc29yZmxvdy5NZXRhR3JhcGhEZWYuTWV0YUluZm9EZWYuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG0uZ3JhcGhEZWYgPSAkcm9vdC50ZW5zb3JmbG93LkdyYXBoRGVmLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtLnNhdmVyRGVmID0gJHJvb3QudGVuc29yZmxvdy5TYXZlckRlZi5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwKCkucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLmNvbGxlY3Rpb25EZWYgPT09ICR1dGlsLmVtcHR5T2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5jb2xsZWN0aW9uRGVmID0ge307XG4gICAgICAgICAgICAgICAgICAgIGsgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICByLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBtLmNvbGxlY3Rpb25EZWZba10gPSAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcCgpLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5zaWduYXR1cmVEZWYgPT09ICR1dGlsLmVtcHR5T2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zaWduYXR1cmVEZWYgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgayA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHIucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIG0uc2lnbmF0dXJlRGVmW2tdID0gJHJvb3QudGVuc29yZmxvdy5TaWduYXR1cmVEZWYuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uYXNzZXRGaWxlRGVmICYmIG0uYXNzZXRGaWxlRGVmLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmFzc2V0RmlsZURlZiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLmFzc2V0RmlsZURlZi5wdXNoKCRyb290LnRlbnNvcmZsb3cuQXNzZXRGaWxlRGVmLmRlY29kZShyLCByLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBNZXRhR3JhcGhEZWYuTWV0YUluZm9EZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE1ldGFJbmZvRGVmKHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE1ldGFJbmZvRGVmLnByb3RvdHlwZS5tZXRhR3JhcGhWZXJzaW9uID0gXCJcIjtcbiAgICAgICAgICAgIE1ldGFJbmZvRGVmLnByb3RvdHlwZS5zdHJpcHBlZE9wTGlzdCA9IG51bGw7XG4gICAgICAgICAgICBNZXRhSW5mb0RlZi5wcm90b3R5cGUuYW55SW5mbyA9IG51bGw7XG4gICAgICAgICAgICBNZXRhSW5mb0RlZi5wcm90b3R5cGUudGFncyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgICAgICBNZXRhSW5mb0RlZi5wcm90b3R5cGUudGVuc29yZmxvd1ZlcnNpb24gPSBcIlwiO1xuICAgICAgICAgICAgTWV0YUluZm9EZWYucHJvdG90eXBlLnRlbnNvcmZsb3dHaXRWZXJzaW9uID0gXCJcIjtcblxuICAgICAgICAgICAgTWV0YUluZm9EZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuTWV0YUdyYXBoRGVmLk1ldGFJbmZvRGVmKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLm1ldGFHcmFwaFZlcnNpb24gPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc3RyaXBwZWRPcExpc3QgPSAkcm9vdC50ZW5zb3JmbG93Lk9wTGlzdC5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hbnlJbmZvID0gJHJvb3QudGVuc29yZmxvdy5BbnkuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG0udGFncyAmJiBtLnRhZ3MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnRhZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udGFncy5wdXNoKHIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udGVuc29yZmxvd1ZlcnNpb24gPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udGVuc29yZmxvd0dpdFZlcnNpb24gPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIE1ldGFJbmZvRGVmO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBNZXRhR3JhcGhEZWY7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuU2F2ZWRNb2RlbCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBTYXZlZE1vZGVsKHApIHtcbiAgICAgICAgICAgIHRoaXMubWV0YUdyYXBocyA9IFtdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgU2F2ZWRNb2RlbC5wcm90b3R5cGUuc2F2ZWRNb2RlbFNjaGVtYVZlcnNpb24gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcbiAgICAgICAgU2F2ZWRNb2RlbC5wcm90b3R5cGUubWV0YUdyYXBocyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgU2F2ZWRNb2RlbC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5TYXZlZE1vZGVsKCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbS5zYXZlZE1vZGVsU2NoZW1hVmVyc2lvbiA9IHIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLm1ldGFHcmFwaHMgJiYgbS5tZXRhR3JhcGhzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm1ldGFHcmFwaHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbS5tZXRhR3JhcGhzLnB1c2goJHJvb3QudGVuc29yZmxvdy5NZXRhR3JhcGhEZWYuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBTYXZlZE1vZGVsO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LkZ1bmN0aW9uRGVmTGlicmFyeSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBGdW5jdGlvbkRlZkxpYnJhcnkocCkge1xuICAgICAgICAgICAgdGhpc1tcImZ1bmN0aW9uXCJdID0gW107XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50ID0gW107XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBGdW5jdGlvbkRlZkxpYnJhcnkucHJvdG90eXBlW1wiZnVuY3Rpb25cIl0gPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBGdW5jdGlvbkRlZkxpYnJhcnkucHJvdG90eXBlLmdyYWRpZW50ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICBGdW5jdGlvbkRlZkxpYnJhcnkuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuRnVuY3Rpb25EZWZMaWJyYXJ5KCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobVtcImZ1bmN0aW9uXCJdICYmIG1bXCJmdW5jdGlvblwiXS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbVtcImZ1bmN0aW9uXCJdID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1bXCJmdW5jdGlvblwiXS5wdXNoKCRyb290LnRlbnNvcmZsb3cuRnVuY3Rpb25EZWYuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLmdyYWRpZW50ICYmIG0uZ3JhZGllbnQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZ3JhZGllbnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbS5ncmFkaWVudC5wdXNoKCRyb290LnRlbnNvcmZsb3cuR3JhZGllbnREZWYuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBGdW5jdGlvbkRlZkxpYnJhcnk7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuRnVuY3Rpb25EZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gRnVuY3Rpb25EZWYocCkge1xuICAgICAgICAgICAgdGhpcy5hdHRyID0ge307XG4gICAgICAgICAgICB0aGlzLm5vZGVEZWYgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucmV0ID0ge307XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBGdW5jdGlvbkRlZi5wcm90b3R5cGUuc2lnbmF0dXJlID0gbnVsbDtcbiAgICAgICAgRnVuY3Rpb25EZWYucHJvdG90eXBlLmF0dHIgPSAkdXRpbC5lbXB0eU9iamVjdDtcbiAgICAgICAgRnVuY3Rpb25EZWYucHJvdG90eXBlLm5vZGVEZWYgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBGdW5jdGlvbkRlZi5wcm90b3R5cGUucmV0ID0gJHV0aWwuZW1wdHlPYmplY3Q7XG5cbiAgICAgICAgRnVuY3Rpb25EZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuRnVuY3Rpb25EZWYoKSwgaztcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLnNpZ25hdHVyZSA9ICRyb290LnRlbnNvcmZsb3cuT3BEZWYuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcCgpLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5hdHRyID09PSAkdXRpbC5lbXB0eU9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBrID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgci5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgbS5hdHRyW2tdID0gJHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0ubm9kZURlZiAmJiBtLm5vZGVEZWYubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubm9kZURlZiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLm5vZGVEZWYucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk5vZGVEZWYuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXAoKS5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0ucmV0ID09PSAkdXRpbC5lbXB0eU9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucmV0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGsgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICByLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBtLnJldFtrXSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRnVuY3Rpb25EZWY7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuR3JhZGllbnREZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gR3JhZGllbnREZWYocCkge1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgR3JhZGllbnREZWYucHJvdG90eXBlLmZ1bmN0aW9uTmFtZSA9IFwiXCI7XG4gICAgICAgIEdyYWRpZW50RGVmLnByb3RvdHlwZS5ncmFkaWVudEZ1bmMgPSBcIlwiO1xuXG4gICAgICAgIEdyYWRpZW50RGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LkdyYWRpZW50RGVmKCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbS5mdW5jdGlvbk5hbWUgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG0uZ3JhZGllbnRGdW5jID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBHcmFkaWVudERlZjtcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIHRlbnNvcmZsb3c7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRyb290O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXhlY3V0aW9uQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhlY3V0aW9uQ29udGV4dCh3ZWlnaHRNYXApIHtcbiAgICAgICAgdGhpcy53ZWlnaHRNYXAgPSB3ZWlnaHRNYXA7XG4gICAgICAgIHRoaXMucm9vdENvbnRleHQgPSB7IGlkOiAwLCBmcmFtZU5hbWU6ICcnLCBpdGVyYXRpb25JZDogMCB9O1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gW3RoaXMucm9vdENvbnRleHRdO1xuICAgICAgICB0aGlzLmxhc3RJZCA9IDA7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpO1xuICAgIH1cbiAgICBFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5uZXdGcmFtZSA9IGZ1bmN0aW9uIChpZCwgZnJhbWVOYW1lKSB7XG4gICAgICAgIHJldHVybiB7IGlkOiBpZCwgZnJhbWVOYW1lOiBmcmFtZU5hbWUsIGl0ZXJhdGlvbklkOiAwIH07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudENvbnRleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb250ZXh0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dHMgIT09IGNvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cyA9IGNvbnRleHRzO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudENvbnRleHRJZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzWzBdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudENvbnRleHRJZHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHMuc2xpY2UoMCwgdGhpcy5jb250ZXh0cy5sZW5ndGggLSBpKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyhjb250ZXh0cykpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzLnB1c2goJycpO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q29udGV4dElkcyA9IG5hbWVzO1xuICAgIH07XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuY29udGV4dElkZm9yQ29udGV4dHMgPSBmdW5jdGlvbiAoY29udGV4dHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRzID9cbiAgICAgICAgICAgIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gKGNvbnRleHQuaWQgPT09IDAgJiYgY29udGV4dC5pdGVyYXRpb25JZCA9PT0gMCkgP1xuICAgICAgICAgICAgICAgICcnIDpcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZyYW1lTmFtZSArIFwiLVwiICsgY29udGV4dC5pdGVyYXRpb25JZDsgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLycpIDpcbiAgICAgICAgICAgICcnO1xuICAgIH07XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuZW50ZXJGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUlkKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RJZCsrO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0cyA9IHRoaXMuY29udGV4dHMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMucHVzaCh0aGlzLm5ld0ZyYW1lKHRoaXMubGFzdElkLCBmcmFtZUlkKSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29udGV4dElkcy51bnNoaWZ0KHRoaXMuY29udGV4dElkZm9yQ29udGV4dHModGhpcy5jb250ZXh0cykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5leGl0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRzICYmIHRoaXMuY29udGV4dHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0cyA9IHRoaXMuY29udGV4dHMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMuc3BsaWNlKC0xKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRleHRJZHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4aXQgZnJhbWUsIHRoZSBjb250ZXh0IGlzIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLm5leHRJdGVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRzICYmIHRoaXMuY29udGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0cyA9IHRoaXMuY29udGV4dHMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMubGFzdElkKys7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICBjb250ZXh0Lml0ZXJhdGlvbklkICs9IDE7XG4gICAgICAgICAgICBjb250ZXh0LmlkID0gdGhpcy5sYXN0SWQ7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLnNwbGljZSgtMSwgMSwgY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29udGV4dElkcy5zcGxpY2UoMCwgMSwgdGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbmNyZWFzZSBmcmFtZSBpdGVyYXRpb24sIHRoZSBjb250ZXh0IGlzIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmdldFdlaWdodCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodE1hcFtuYW1lXTtcbiAgICB9O1xuICAgIHJldHVybiBFeGVjdXRpb25Db250ZXh0O1xufSgpKTtcbmV4cG9ydHMuRXhlY3V0aW9uQ29udGV4dCA9IEV4ZWN1dGlvbkNvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGVjdXRpb25fY29udGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgVXJsID0gcmVxdWlyZShcInVybFwiKTtcbnZhciBjb21waWxlZF9hcGlfMSA9IHJlcXVpcmUoXCIuLi9kYXRhL2NvbXBpbGVkX2FwaVwiKTtcbnZhciBvcGVyYXRpb25fbWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vb3BlcmF0aW9ucy9vcGVyYXRpb25fbWFwcGVyXCIpO1xudmFyIGdyYXBoX2V4ZWN1dG9yXzEgPSByZXF1aXJlKFwiLi9ncmFwaF9leGVjdXRvclwiKTtcbnZhciBGcm96ZW5Nb2RlbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJvemVuTW9kZWwobW9kZWxVcmwsIHdlaWdodE1hbmlmZXN0VXJsLCByZXF1ZXN0T3B0aW9uKSB7XG4gICAgICAgIHRoaXMubW9kZWxVcmwgPSBtb2RlbFVybDtcbiAgICAgICAgdGhpcy53ZWlnaHRNYW5pZmVzdFVybCA9IHdlaWdodE1hbmlmZXN0VXJsO1xuICAgICAgICB0aGlzLnJlcXVlc3RPcHRpb24gPSByZXF1ZXN0T3B0aW9uO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAnbi9hJztcbiAgICAgICAgdGhpcy5wYXRoUHJlZml4ID0gdGhpcy5nZXRQYXRoUHJlZml4KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcm96ZW5Nb2RlbC5wcm90b3R5cGUsIFwibW9kZWxWZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJvemVuTW9kZWwucHJvdG90eXBlLCBcImlucHV0Tm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLmlucHV0Tm9kZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcm96ZW5Nb2RlbC5wcm90b3R5cGUsIFwib3V0cHV0Tm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dE5vZGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGcm96ZW5Nb2RlbC5wcm90b3R5cGUuZ2V0UGF0aFByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybCA9IFVybC5wYXJzZSh0aGlzLndlaWdodE1hbmlmZXN0VXJsKTtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdXJsLnBhdGhuYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIHNlZ21lbnRzLnNwbGljZSgtMSk7XG4gICAgICAgIHVybC5wYXRobmFtZSA9IHNlZ21lbnRzLmpvaW4oJy8nKTtcbiAgICAgICAgcmV0dXJuIFVybC5mb3JtYXQodXJsKSArICcvJztcbiAgICB9O1xuICAgIEZyb3plbk1vZGVsLnByb3RvdHlwZS5sb2FkUmVtb3RlUHJvdG9GaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIF9hLCBfYiwgX2MsIGVycm9yXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzAsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBmZXRjaCh0aGlzLm1vZGVsVXJsLCB0aGlzLnJlcXVlc3RPcHRpb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IGNvbXBpbGVkX2FwaV8xLnRlbnNvcmZsb3cuR3JhcGhEZWYpLmRlY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gVWludDhBcnJheS5iaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCByZXNwb25zZS5hcnJheUJ1ZmZlcigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIsIF9iLmFwcGx5KF9hLCBbbmV3IChfYy5hcHBseShVaW50OEFycmF5LCBbdm9pZCAwLCBfZC5zZW50KCldKSkoKV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLm1vZGVsVXJsICsgXCIgbm90IGZvdW5kLiBcIiArIGVycm9yXzEpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRnJvemVuTW9kZWwucHJvdG90eXBlLmxvYWRXZWlnaHRNYW5pZmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hbmlmZXN0LCBfYSwgZXJyb3JfMjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGZldGNoKHRoaXMud2VpZ2h0TWFuaWZlc3RVcmwsIHRoaXMucmVxdWVzdE9wdGlvbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbWFuaWZlc3QuY2xvbmUoKS5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS53ZWlnaHRNYW5pZmVzdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy53ZWlnaHRNYW5pZmVzdFVybCArIFwiIG5vdCBmb3VuZC4gXCIgKyBlcnJvcl8yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZyb3plbk1vZGVsLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ3JhcGhQcm9taXNlLCBtYW5pZmVzdFByb21pc2UsIGdyYXBoLCB3ZWlnaHRNYXA7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaFByb21pc2UgPSB0aGlzLmxvYWRSZW1vdGVQcm90b0ZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0UHJvbWlzZSA9IHRoaXMubG9hZFdlaWdodE1hbmlmZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIFByb21pc2UuYWxsKFtncmFwaFByb21pc2UsIG1hbmlmZXN0UHJvbWlzZV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGggPSAoX2Euc2VudCgpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IGdyYXBoLnZlcnNpb25zLnByb2R1Y2VyICsgXCIuXCIgKyBncmFwaC52ZXJzaW9ucy5taW5Db25zdW1lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGZjLmlvLmxvYWRXZWlnaHRzKHRoaXMud2VpZ2h0TWFuaWZlc3QsIHRoaXMucGF0aFByZWZpeCwgdW5kZWZpbmVkLCB0aGlzLnJlcXVlc3RPcHRpb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0TWFwID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjdXRvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGdyYXBoX2V4ZWN1dG9yXzEuR3JhcGhFeGVjdXRvcihvcGVyYXRpb25fbWFwcGVyXzEuT3BlcmF0aW9uTWFwcGVyLkluc3RhbmNlLnRyYW5zZm9ybUdyYXBoKGdyYXBoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcCA9IHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcCh3ZWlnaHRNYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0cnVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGcm96ZW5Nb2RlbC5wcm90b3R5cGUucHJlZGljdCA9IGZ1bmN0aW9uIChpbnB1dHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlKGlucHV0cywgdGhpcy5vdXRwdXROb2Rlcyk7XG4gICAgfTtcbiAgICBGcm96ZW5Nb2RlbC5wcm90b3R5cGUuY29uc3RydWN0VGVuc29yTWFwID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICB2YXIgaW5wdXRBcnJheSA9IGlucHV0cyBpbnN0YW5jZW9mIHRmYy5UZW5zb3IgPyBbaW5wdXRzXSA6IGlucHV0cztcbiAgICAgICAgaWYgKGlucHV0QXJyYXkubGVuZ3RoICE9PSB0aGlzLmlucHV0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHRlbnNvciBjb3VudCBtaXNtYXRjaCwnICtcbiAgICAgICAgICAgICAgICAoXCJ0aGUgZnJvemVuIG1vZGVsIGhhcyBcIiArIHRoaXMuaW5wdXROb2Rlcy5sZW5ndGggKyBcIiBwbGFjZWhvbGRlcnMsIFwiKSArXG4gICAgICAgICAgICAgICAgKFwid2hpbGUgdGhlcmUgYXJlIFwiICsgaW5wdXRBcnJheS5sZW5ndGggKyBcIiBpbnB1dCB0ZW5zb3JzLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXROb2Rlcy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgaW5wdXROYW1lLCBpKSB7XG4gICAgICAgICAgICBtYXBbaW5wdXROYW1lXSA9IGlucHV0QXJyYXlbaV07XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBGcm96ZW5Nb2RlbC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dHMpIHtcbiAgICAgICAgb3V0cHV0cyA9IG91dHB1dHMgfHwgdGhpcy5vdXRwdXROb2RlcztcbiAgICAgICAgaWYgKGlucHV0cyBpbnN0YW5jZW9mIHRmYy5UZW5zb3IgfHwgQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSB0aGlzLmNvbnN0cnVjdFRlbnNvck1hcChpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4ZWN1dG9yLmlzQ29udHJvbEZsb3dNb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbW9kZWwgY29udGFpbnMgY29udHJvbCBmbG93IG9wcywgJyArXG4gICAgICAgICAgICAgICAgJ3BsZWFzZSB1c2UgZXhlY3V0ZUFzeW5jIG1ldGhvZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmV4ZWN1dG9yLmV4ZWN1dGUodGhpcy5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwKGlucHV0cyksIG91dHB1dHMpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShvdXRwdXRzKSAmJiBvdXRwdXRzLmxlbmd0aCA+IDEpID9cbiAgICAgICAgICAgIG91dHB1dHMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiByZXN1bHRbbm9kZV07IH0pIDpcbiAgICAgICAgICAgIHJlc3VsdFtrZXlzWzBdXTtcbiAgICB9O1xuICAgIEZyb3plbk1vZGVsLnByb3RvdHlwZS5leGVjdXRlQXN5bmMgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGtleXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZXhlY3V0b3IuaXNDb250cm9sRmxvd01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbW9kZWwgZG9lcyBub3QgY29udGFpbiBjb250cm9sIGZsb3cgb3BzLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BsZWFzZSB1c2UgZXhlY3V0ZSBtZXRob2QgZm9yIGJldHRlciBwZXJmb3JtYW5jZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHMgPSBvdXRwdXRzIHx8IHRoaXMub3V0cHV0Tm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzIGluc3RhbmNlb2YgdGZjLlRlbnNvciB8fCBBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMgPSB0aGlzLmNvbnN0cnVjdFRlbnNvck1hcChpbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmV4ZWN1dG9yLmV4ZWN1dGVBc3luYyh0aGlzLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAoaW5wdXRzKSwgb3V0cHV0cyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgQXJyYXkuaXNBcnJheShvdXRwdXRzKSAmJiBvdXRwdXRzLmxlbmd0aCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gcmVzdWx0W25vZGVdOyB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXlzWzBdXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRnJvemVuTW9kZWwucHJvdG90eXBlLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApLnJlZHVjZShmdW5jdGlvbiAobmV3TWFwLCBrZXkpIHtcbiAgICAgICAgICAgIG5ld01hcFtrZXldID0gW21hcFtrZXldXTtcbiAgICAgICAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIEZyb3plbk1vZGVsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV4ZWN1dG9yLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBGcm96ZW5Nb2RlbDtcbn0oKSk7XG5leHBvcnRzLkZyb3plbk1vZGVsID0gRnJvemVuTW9kZWw7XG5mdW5jdGlvbiBsb2FkRnJvemVuTW9kZWwobW9kZWxVcmwsIHdlaWdodHNNYW5pZmVzdFVybCwgcmVxdWVzdE9wdGlvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZGVsO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IG5ldyBGcm96ZW5Nb2RlbChtb2RlbFVybCwgd2VpZ2h0c01hbmlmZXN0VXJsLCByZXF1ZXN0T3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5sb2FkKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG1vZGVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRGcm96ZW5Nb2RlbCA9IGxvYWRGcm96ZW5Nb2RlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb3plbl9tb2RlbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vb3BlcmF0aW9ucy9leGVjdXRvcnMvdXRpbHNcIik7XG52YXIgb3BlcmF0aW9uX2V4ZWN1dG9yXzEgPSByZXF1aXJlKFwiLi4vb3BlcmF0aW9ucy9vcGVyYXRpb25fZXhlY3V0b3JcIik7XG52YXIgZXhlY3V0aW9uX2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGlvbl9jb250ZXh0XCIpO1xudmFyIEdyYXBoRXhlY3V0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoRXhlY3V0b3IoZ3JhcGgpIHtcbiAgICAgICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgICAgICB0aGlzLmNvbXBpbGVkT3JkZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fd2VpZ2h0TWFwID0ge307XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gZ3JhcGgucGxhY2Vob2xkZXJzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5uYW1lOyB9KTtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gZ3JhcGgub3V0cHV0cy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubmFtZTsgfSk7XG4gICAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhFeGVjdXRvci5wcm90b3R5cGUsIFwid2VpZ2h0TWFwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2VpZ2h0TWFwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh3ZWlnaHRNYXApIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRJZHMgPSBPYmplY3Qua2V5cyh3ZWlnaHRNYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB3ZWlnaHRNYXBba2V5XS5tYXAoZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmlkOyB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLndlaWdodElkcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgd2VpZ2h0SWRzKTtcbiAgICAgICAgICAgIHRoaXMuX3dlaWdodE1hcCA9IHdlaWdodE1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLCBcImlucHV0Tm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsYWNlaG9sZGVycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLCBcIm91dHB1dE5vZGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhFeGVjdXRvci5wcm90b3R5cGUsIFwiaXNDb250cm9sRmxvd01vZGVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFwaC53aXRoQ29udHJvbEZsb3c7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyYXBoLndpdGhDb250cm9sRmxvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuZ3JhcGguaW5wdXRzLnNsaWNlKCk7XG4gICAgICAgIHZhciB2aXNpdGVkID0ge307XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdmlzaXRlZFtub2RlLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWRPcmRlci5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbY2hpbGROb2RlLm5hbWVdICYmIGNoaWxkTm9kZS5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IHV0aWxzXzEuZ2V0Tm9kZU5hbWVBbmRJbmRleChuYW1lKVswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0ZWRbbm9kZU5hbWVdO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGVja0lucHV0KGlucHV0cyk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IGV4ZWN1dGlvbl9jb250ZXh0XzEuRXhlY3V0aW9uQ29udGV4dChfdGhpcy5fd2VpZ2h0TWFwKTtcbiAgICAgICAgICAgIHZhciB0ZW5zb3JzID0gX3RoaXMuY29tcGlsZWRPcmRlci5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgbm9kZSkge1xuICAgICAgICAgICAgICAgIG1hcFtub2RlLm5hbWVdID0gb3BlcmF0aW9uX2V4ZWN1dG9yXzEuZXhlY3V0ZU9wKG5vZGUsIG1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgIH0sIF9fYXNzaWduKHt9LCBfdGhpcy53ZWlnaHRNYXAsIGlucHV0cykpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbmRPdXRwdXRzKHRlbnNvcnMsIGNvbnRleHQsIG91dHB1dHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLmV4ZWN1dGVBc3luYyA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb250ZXh0LCB0ZW5zb3JzLCByZXN1bHRzLCBvdXRwdXRJZHMsIGlucHV0SWRBcnJheSwgaW5wdXRJZHM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gbmV3IGV4ZWN1dGlvbl9jb250ZXh0XzEuRXhlY3V0aW9uQ29udGV4dCh0aGlzLl93ZWlnaHRNYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmV4ZWN1dGVXaXRoQ29udHJvbEZsb3coaW5wdXRzLCBjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvcnMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gdGhpcy5maW5kT3V0cHV0cyh0ZW5zb3JzLCBjb250ZXh0LCBvdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dElkcyA9IE9iamVjdC5rZXlzKHJlc3VsdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiByZXN1bHRzW2tleV0uaWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRJZEFycmF5ID0gT2JqZWN0LmtleXMoaW5wdXRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaW5wdXRzW2tleV0ubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuaWQ7IH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0SWRzID0gW10uY29uY2F0LmFwcGx5KFtdLCBpbnB1dElkQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGVuc29ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbnNvckFycmF5ID0gdGVuc29yc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckFycmF5LmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVuc29yICYmIG91dHB1dElkcy5pbmRleE9mKHRlbnNvci5pZCkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dElkcy5pbmRleE9mKHRlbnNvci5pZCkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53ZWlnaHRJZHMuaW5kZXhPZih0ZW5zb3IuaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3VsdHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLmV4ZWN1dGVXaXRoQ29udHJvbEZsb3cgPSBmdW5jdGlvbiAoaW5wdXRzLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFjaywgdGVuc29yTWFwLCBhZGRlZCwgaXRlbSwgdGVuc29ycywgbm9kZU5hbWUsIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrID0gdGhpcy5ncmFwaC5pbnB1dHMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgY29udGV4dHM6IGNvbnRleHQuY3VycmVudENvbnRleHQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yTWFwID0gX19hc3NpZ24oe30sIHRoaXMud2VpZ2h0TWFwLCBpbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3RhY2subGVuZ3RoID4gMCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRDb250ZXh0ID0gaXRlbS5jb250ZXh0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvcnMgPSBvcGVyYXRpb25fZXhlY3V0b3JfMS5leGVjdXRlT3AoaXRlbS5ub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUgPSB1dGlsc18xLmdldE5vZGVOYW1lQW5kSW5kZXgoaXRlbS5ub2RlLm5hbWUsIGNvbnRleHQpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0ZW5zb3JNYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IG5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0ZW5zb3JzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2FbX2JdID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5ub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IHV0aWxzXzEuZ2V0Tm9kZU5hbWVBbmRJbmRleChjaGlsZE5vZGUubmFtZSwgY29udGV4dClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGRlZFtub2RlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5vcCA9PT0gJ21lcmdlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pbnB1dE5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF1dGlsc18xLmdldFRlbnNvcihuYW1lLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZFtub2RlTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goeyBjb250ZXh0czogY29udGV4dC5jdXJyZW50Q29udGV4dCwgbm9kZTogY2hpbGROb2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkTm9kZS5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF1dGlsc18xLmdldFRlbnNvcihuYW1lLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRbbm9kZU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goeyBjb250ZXh0czogY29udGV4dC5jdXJyZW50Q29udGV4dCwgbm9kZTogY2hpbGROb2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiwgdGVuc29yTWFwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5maW5kT3V0cHV0cyA9IGZ1bmN0aW9uICh0ZW5zb3JNYXAsIGNvbnRleHQsIG91dHB1dHMpIHtcbiAgICAgICAgaWYgKG91dHB1dHMgJiYgIShvdXRwdXRzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBvdXRwdXRzID0gW291dHB1dHNdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0ZWRPdXRwdXRzID0gKG91dHB1dHMgfHwgdGhpcy5ncmFwaC5vdXRwdXRzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5uYW1lOyB9KSk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0ZWRPdXRwdXRzLnJlZHVjZShmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG4gICAgICAgICAgICBtYXBbbmFtZV0gPSB1dGlsc18xLmdldFRlbnNvcihuYW1lLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy53ZWlnaHRNYXApXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBfdGhpcy53ZWlnaHRNYXBba2V5XS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3IpIHsgcmV0dXJuIHRlbnNvci5kaXNwb3NlKCk7IH0pOyB9KTtcbiAgICB9O1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLmNoZWNrSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpbnB1dEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dHMpO1xuICAgICAgICB2YXIgbWlzc2luZyA9IFtdO1xuICAgICAgICB2YXIgZXh0cmEgPSBbXTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKGlucHV0S2V5cy5pbmRleE9mKG5hbWUpID09PSAtMSlcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dEtleXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnBsYWNlaG9sZGVycy5pbmRleE9mKG5hbWUpID09PSAtMSlcbiAgICAgICAgICAgICAgICBleHRyYS5wdXNoKG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMgdGhlIGtleXMgXCIgK1xuICAgICAgICAgICAgICAgIChcIltcIiArIGlucHV0S2V5cyArIFwiXSwgYnV0IGlzIG1pc3NpbmcgdGhlIHJlcXVpcmVkIGtleXM6IFtcIiArIG1pc3NpbmcgKyBcIl0uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMgXCIgK1xuICAgICAgICAgICAgICAgIChcInVudXNlZCBrZXlzOiBbXCIgKyBleHRyYSArIFwiXS4gUGxlYXNlIHByb3ZpZGUgb25seSB0aGUgZm9sbG93aW5nIGtleXM6IFwiKSArXG4gICAgICAgICAgICAgICAgKFwiW1wiICsgdGhpcy5wbGFjZWhvbGRlcnMgKyBcIl0uXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoRXhlY3V0b3I7XG59KCkpO1xuZXhwb3J0cy5HcmFwaEV4ZWN1dG9yID0gR3JhcGhFeGVjdXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZyb3plbl9tb2RlbF8xID0gcmVxdWlyZShcIi4vZXhlY3V0b3IvZnJvemVuX21vZGVsXCIpO1xuZXhwb3J0cy5Gcm96ZW5Nb2RlbCA9IGZyb3plbl9tb2RlbF8xLkZyb3plbk1vZGVsO1xuZXhwb3J0cy5sb2FkRnJvemVuTW9kZWwgPSBmcm96ZW5fbW9kZWxfMS5sb2FkRnJvemVuTW9kZWw7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMudmVyc2lvbl9jb252ZXJ0ZXIgPSB2ZXJzaW9uXzEudmVyc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ2FkZCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmFkZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbW9kJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm1vZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ211bCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5tdWwodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdkaXYnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5kaXYodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N1Yic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnN1Yih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWluaW11bSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm1pbmltdW0odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21heGltdW0nOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5tYXhpbXVtKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwb3cnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5wb3codXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NxdWFyZWREaWZmZXJlbmNlJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc3F1YXJlZERpZmZlcmVuY2UodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkNBVEVHT1JZID0gJ2FyaXRobWV0aWMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJpdGhtZXRpY19leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdhYnMnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuYWJzKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnYWNvcyc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5hY29zKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnYWNvc2gnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuYWNvc2godXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdhc2luJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmFzaW4odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdhc2luaCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5hc2luaCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2F0YW4nOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuYXRhbih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2F0YW5oJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmF0YW5oKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5jZWlsKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnY29zJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmNvcyh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2Nvc2gnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuY29zaCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2VsdSc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5lbHUodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdlcmYnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZXJmKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnZXhwJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmV4cCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2V4cG0xJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZXhwbTEodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmZsb29yKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnbG9nJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmxvZyh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2xvZzFwJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubG9nMXAodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25lZyc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5uZWcodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdyZWNpcHJvY2FsJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMucmVjaXByb2NhbCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVsdSc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5yZWx1KHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAncm91bmQnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5yb3VuZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc2VsdSc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zZWx1KHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnc2lnbW9pZCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zaWdtb2lkKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnc2luJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNpbih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ3NpZ24nOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zaWduKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzaW5oJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc2luaCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc29mdHBsdXMnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zb2Z0cGx1cyh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3FydCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNxcnQodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NxdWFyZSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNxdWFyZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFuaCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnRhbmgodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Rhbic6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy50YW4odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdjbGlwQnlWYWx1ZSc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5jbGlwQnlWYWx1ZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2NsaXBWYWx1ZU1pbicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnY2xpcFZhbHVlTWF4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdyc3FydCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5kaXYodGZjLnNjYWxhcigxLjAsICdmbG9hdDMyJyksIHRmYy5zcXJ0KHV0aWxzXzEuZ2V0VGVuc29yKG5vZGUuaW5wdXROYW1lc1swXSwgdGVuc29yTWFwLCBjb250ZXh0KSkpXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuQ0FURUdPUlkgPSAnYmFzaWNfbWF0aCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNpY19tYXRoX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBwcmVkLCBkYXRhXzEsIGlucHV0TmFtZSwgZnJhbWVJZCwgZGF0YSwgdGVuc29yLCBpbnB1dDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBub2RlLm9wO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsb29wQ29uZCc6IHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzd2l0Y2gnOiByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWVyZ2UnOiByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW50ZXInOiByZXR1cm4gWzMsIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXhpdCc6IHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXh0SXRlcmF0aW9uJzogcmV0dXJuIFszLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDhdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBbdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdwcmVkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KV1dO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcHJlZCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncHJlZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfMSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZGF0YScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcHJlZC5kYXRhKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyLCAoX2Iuc2VudCgpKVswXSA/IFt1bmRlZmluZWQsIGRhdGFfMV0gOiBbZGF0YV8xLCB1bmRlZmluZWRdXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0TmFtZSA9IG5vZGUuaW5wdXROYW1lcy5maW5kKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB1dGlsc18xLmdldFRlbnNvcihuYW1lLCB0ZW5zb3JNYXAsIGNvbnRleHQpICE9PSB1bmRlZmluZWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGlucHV0TmFtZSA/IFt1dGlsc18xLmdldFRlbnNvcihpbnB1dE5hbWUsIHRlbnNvck1hcCwgY29udGV4dCldIDogdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSWQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2ZyYW1lTmFtZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3RlbnNvcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW50ZXJGcmFtZShmcmFtZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBbZGF0YV1dO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd0ZW5zb3InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmV4aXRGcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFt0ZW5zb3JdXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd0ZW5zb3InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5leHRJdGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBbaW5wdXRdXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5leGVjdXRlT3AgPSBleGVjdXRlT3A7XG5leHBvcnRzLkNBVEVHT1JZID0gJ2NvbnRyb2wnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbF9leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdjb252MWQnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzdHJpZGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkYXRhRm9ybWF0ID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkYXRhRm9ybWF0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGRpbGF0aW9uID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkaWxhdGlvbicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5jb252MWQodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdmaWx0ZXInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBzdHJpZGUsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb24pXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb252MmQnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzdHJpZGVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBwYWQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3BhZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgZGF0YUZvcm1hdCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZGF0YUZvcm1hdCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBkaWxhdGlvbnMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2RpbGF0aW9ucycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5jb252MmQodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdmaWx0ZXInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBbc3RyaWRlWzFdLCBzdHJpZGVbMl1dLCBwYWQsIGRhdGFGb3JtYXQsIFtkaWxhdGlvbnNbMF0sIGRpbGF0aW9uc1sxXV0pXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb252MmRUcmFuc3Bvc2UnOiB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ291dHB1dFNoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0cmlkZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmNvbnYyZFRyYW5zcG9zZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2ZpbHRlcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHNoYXBlLCBbc3RyaWRlWzFdLCBzdHJpZGVbMl1dLCBwYWQpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkZXB0aHdpc2VDb252MmQnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzdHJpZGVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBwYWQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3BhZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgZGlsYXRpb25zID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkaWxhdGlvbnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGRhdGFGb3JtYXQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2RhdGFGb3JtYXQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpXG4gICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5kZXB0aHdpc2VDb252MmQodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdpbnB1dCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZmlsdGVyJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgW3N0cmlkZVsxXSwgc3RyaWRlWzJdXSwgcGFkLCBkYXRhRm9ybWF0LCBbZGlsYXRpb25zWzBdLCBkaWxhdGlvbnNbMV1dKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXZnUG9vbCc6IHtcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0cmlkZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZXJuZWxTaXplID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdrZXJuZWxTaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmF2Z1Bvb2wodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgW2tlcm5lbFNpemVbMV0sIGtlcm5lbFNpemVbMl1dLCBbc3RyaWRlWzFdLCBzdHJpZGVbMl1dLCBwYWQpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtYXhQb29sJzoge1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdwYWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlcm5lbFNpemUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2tlcm5lbFNpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubWF4UG9vbCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBba2VybmVsU2l6ZVsxXSwga2VybmVsU2l6ZVsyXV0sIFtzdHJpZGVbMV0sIHN0cmlkZVsyXV0sIHBhZCldO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkNBVEVHT1JZID0gJ2NvbnZvbHV0aW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZvbHV0aW9uX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ2ZpbGwnOiB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3NoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgndmFsdWUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZmlsbChzaGFwZSwgdmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaW5zcGFjZSc6IHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RhcnQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0b3BfMSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RvcCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgbnVtID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdudW0nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubGluc3BhY2Uoc3RhcnQsIHN0b3BfMSwgbnVtKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnb25lSG90Jzoge1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2luZGljZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkZXB0aCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgb25WYWx1ZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnb25WYWx1ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgb2ZmVmFsdWUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ29mZlZhbHVlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm9uZUhvdChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdvbmVzJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMub25lcyh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3NoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdvbmVzTGlrZSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm9uZXNMaWtlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyYW5kb21Vbmlmb3JtJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMucmFuZG9tVW5pZm9ybSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3NoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdtaW52YWwnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ21heHZhbCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZHR5cGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmFuZ2UnOiB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0YXJ0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzdG9wXzIgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0b3AnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0ZXAnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMucmFuZ2Uoc3RhcnQsIHN0b3BfMiwgc3RlcCwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0cnVuY2F0ZWROb3JtYWwnOiB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3NoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBtZWFuID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdtZWFuJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzdGREZXYgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0ZERldicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc2VlZCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2VlZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy50cnVuY2F0ZWROb3JtYWwoc2hhcGUsIG1lYW4sIHN0ZERldiwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHNlZWQpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd6ZXJvcyc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnplcm9zKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2R0eXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3plcm9zTGlrZSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnplcm9zTGlrZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuQ0FURUdPUlkgPSAnY3JlYXRpb24nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRpb25fZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmV4ZWN1dGVPcCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnY29uc3QnOiB7XG4gICAgICAgICAgICByZXR1cm4gdGVuc29yTWFwW25vZGUubmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncGxhY2Vob2xkZXInOlxuICAgICAgICAgICAgdmFyIGRlZiA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZGVmYXVsdCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3V0aWxzXzEuZ2V0VGVuc29yKG5vZGUubmFtZSwgdGVuc29yTWFwLCBjb250ZXh0KSB8fCBkZWZdO1xuICAgICAgICBjYXNlICdpZGVudGl0eSc6XG4gICAgICAgIGNhc2UgJ3N0b3BHcmFkaWVudCc6XG4gICAgICAgIGNhc2UgJ2Zha2VRdWFudFdpdGhNaW5NYXhWYXJzJzpcbiAgICAgICAgICAgIHJldHVybiBbdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KV07XG4gICAgICAgIGNhc2UgJ3NuYXBzaG90JzpcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3NuYXBzaG90LmNsb25lKCldO1xuICAgICAgICBjYXNlICdzaGFwZSc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy50ZW5zb3IxZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLnNoYXBlLCAnaW50MzInKV07XG4gICAgICAgIGNhc2UgJ25vb3AnOlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBjYXNlICdwcmludCc6XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2RhdGEnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ21lc3NhZ2UnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN1bW1hcml6ZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3VtbWFyaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGdyYXBoIGhhcyBhIHRmLnByaW50KCkgb3BlcmF0aW9uLCcgK1xuICAgICAgICAgICAgICAgICd1c3VhbGx5IHVzZWQgZm9yIGRlYnVnZ2luZywgd2hpY2ggc2xvd3MgZG93biBwZXJmb3JtYW5jZS4nKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YVswXS5kYXRhU3luYygpKS5zbGljZSgwLCBzdW1tYXJpemUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdncmFwaCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFwaF9leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdyZXNpemVCaWxpbmVhcic6IHtcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2ltYWdlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgYWxpZ25Db3JuZXJzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhbGlnbkNvcm5lcnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuaW1hZ2UucmVzaXplQmlsaW5lYXIoaW1hZ2VzLCBbc2l6ZVswXSwgc2l6ZVsxXV0sIGFsaWduQ29ybmVycyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Jlc2l6ZU5lYXJlc3ROZWlnaGJvcic6IHtcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2ltYWdlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgYWxpZ25Db3JuZXJzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhbGlnbkNvcm5lcnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuaW1hZ2UucmVzaXplTmVhcmVzdE5laWdoYm9yKGltYWdlcywgW3NpemVbMF0sIHNpemVbMV1dLCBhbGlnbkNvcm5lcnMpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdpbWFnZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZV9leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdlcXVhbCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmVxdWFsKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdub3RFcXVhbCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm5vdEVxdWFsKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdncmVhdGVyJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZ3JlYXRlcih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3JlYXRlckVxdWFsJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZ3JlYXRlckVxdWFsKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsZXNzJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubGVzcyh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbGVzc0VxdWFsJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubGVzc0VxdWFsKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsb2dpY2FsQW5kJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubG9naWNhbEFuZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbG9naWNhbE5vdCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmxvZ2ljYWxOb3QodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2xvZ2ljYWxPcic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmxvZ2ljYWxPcih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnd2hlcmUnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy53aGVyZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2NvbmRpdGlvbicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdsb2dpY2FsJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2ljYWxfZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmV4ZWN1dGVPcCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnbWF0TXVsJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm1hdE11bCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3RyYW5zcG9zZUEnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3RyYW5zcG9zZUInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ3RyYW5zcG9zZSc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy50cmFuc3Bvc2UodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdwZXJtJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdtYXRyaWNlcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaWNlc19leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdiYXRjaE5vcm1hbGl6YXRpb24nOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5iYXRjaE5vcm1hbGl6YXRpb24odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdtZWFuJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd2YXJpYW5jZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZXBzaWxvbicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2NhbGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ29mZnNldCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncmFkaXVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiaWFzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhbHBoYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYmV0YScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzb2Z0bWF4Jzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc29mdG1heCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuQ0FURUdPUlkgPSAnbm9ybWFsaXphdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemF0aW9uX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ21heCc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgna2VlcERpbXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubWF4KHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMsIGtlZXBEaW1zKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWVhbic6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgna2VlcERpbXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubWVhbih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzLCBrZWVwRGltcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21pbic6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgna2VlcERpbXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubWluKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMsIGtlZXBEaW1zKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3VtJzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdrZWVwRGltcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zdW0odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcywga2VlcERpbXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhcmdNYXgnOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5hcmdNYXgodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FyZ01pbic6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmFyZ01pbih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzKV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuQ0FURUdPUlkgPSAncmVkdWN0aW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjdGlvbl9leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdjb25jYXQnOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd0ZW5zb3JzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmNvbmNhdChpbnB1dHMsIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdnYXRoZXInOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2luZGljZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZ2F0aGVyKGlucHV0LCBpbmRpY2VzLCBheGlzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmV2ZXJzZSc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5yZXZlcnNlKGlucHV0LCBheGlzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc2xpY2UnOiB7XG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2JlZ2luJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzaXplID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNsaWNlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGJlZ2luLCBzaXplKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RyaWRlZFNsaWNlJzoge1xuICAgICAgICAgICAgdmFyIGJlZ2luID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiZWdpbicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdlbmQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0cmlkZXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0cmlkZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGJlZ2luTWFzayA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYmVnaW5NYXNrJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBlbmRNYXNrID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdlbmRNYXNrJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnN0cmlkZWRTbGljZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBiZWdpbiwgZW5kLCBzdHJpZGVzLCBiZWdpbk1hc2ssIGVuZE1hc2spXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzdGFjayc6IHtcbiAgICAgICAgICAgIHJldHVybiB0ZmMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciB0ZW5zb3JzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd0ZW5zb3JzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSB0ZW5zb3JzWzBdLnNoYXBlO1xuICAgICAgICAgICAgICAgIHZhciBzcXVlZXplZFNoYXBlID0gdGVuc29yc1swXS5zcXVlZXplKCkuc2hhcGU7XG4gICAgICAgICAgICAgICAgdmFyIG1hcHBlZCA9IHRlbnNvcnMubWFwKGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbWVTaGFwZSA9IHRmYy51dGlsLmFycmF5c0VxdWFsKHRlbnNvci5zaGFwZSwgc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVTaGFwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRmYy51dGlsLmFycmF5c0VxdWFsKHRlbnNvci5zcXVlZXplKCkuc2hhcGUsIHNxdWVlemVkU2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBpbnB1dCB0ZW5zb3JzIHNoYXBlIGRvZXMgbm90IG1hdGNoJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhbWVTaGFwZSA/IHRlbnNvciA6IHRlbnNvci5yZXNoYXBlKHNoYXBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RmYy5zdGFjayhtYXBwZWQsIGF4aXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RpbGUnOiB7XG4gICAgICAgICAgICB2YXIgcmVwcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncmVwcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy50aWxlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHJlcHMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzcGxpdCc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBudW1PclNpemVTcGxpdHMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ251bU9yU2l6ZVNwbGl0cycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdGZjLnNwbGl0KHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIG51bU9yU2l6ZVNwbGl0cywgYXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuQ0FURUdPUlkgPSAnc2xpY2Vfam9pbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGljZV9qb2luX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ2Nhc3QnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5jYXN0KHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZHR5cGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZXhwYW5kRGltcyc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gbm9kZS5wYXJhbXNbJ2F4aXMnXS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmV4cGFuZERpbXModXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NxdWVlemUnOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IG5vZGUucGFyYW1zWydheGlzJ10udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zcXVlZXplKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZXNoYXBlJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMucmVzaGFwZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3NoYXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3BhZCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnBhZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLnNwbGl0KHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncGFkZGluZycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIDIpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2NvbnN0YW50VmFsdWUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuQ0FURUdPUlkgPSAndHJhbnNmb3JtYXRpb24nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtYXRpb25fZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRQYXJhbVZhbHVlKHBhcmFtTmFtZSwgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgdmFyIHBhcmFtID0gbm9kZS5wYXJhbXNbcGFyYW1OYW1lXTtcbiAgICBpZiAocGFyYW0gJiYgcGFyYW0uaW5wdXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJhbS50eXBlID09PSAndGVuc29yJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbnNvcihub2RlLmlucHV0TmFtZXNbcGFyYW0uaW5wdXRJbmRleF0sIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09ICd0ZW5zb3JzJykge1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IHBhcmFtLmlucHV0SW5kZXggPT09IDAgP1xuICAgICAgICAgICAgICAgIChwYXJhbS5pbnB1dFBhcmFtTGVuZ3RoID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnB1dE5hbWVzIDpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnB1dE5hbWVzLnNsaWNlKHBhcmFtLmlucHV0SW5kZXgsIC1wYXJhbS5pbnB1dFBhcmFtTGVuZ3RoKSkgOlxuICAgICAgICAgICAgICAgIG5vZGUuaW5wdXROYW1lcy5zcGxpY2UocGFyYW0uaW5wdXRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2V0VGVuc29yKG5hbWUsIHRlbnNvck1hcCwgY29udGV4dCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0VGVuc29yKG5vZGUuaW5wdXROYW1lcy5zbGljZShwYXJhbS5pbnB1dEluZGV4KVswXSwgdGVuc29yTWFwLCBjb250ZXh0KVxuICAgICAgICAgICAgLmRhdGFTeW5jKCkpO1xuICAgICAgICByZXR1cm4gcGFyYW0udHlwZSA9PT0gJ251bWJlcicgPyBkYXRhWzBdIDogZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtICYmIHBhcmFtLnZhbHVlO1xufVxuZXhwb3J0cy5nZXRQYXJhbVZhbHVlID0gZ2V0UGFyYW1WYWx1ZTtcbmZ1bmN0aW9uIGdldFRlbnNvcihuYW1lLCB0ZW5zb3JzTWFwLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hID0gcGFyc2VOb2RlTmFtZShuYW1lKSwgbm9kZU5hbWUgPSBfYVswXSwgaW5kZXggPSBfYVsxXTtcbiAgICB2YXIgY29udGV4dElkID0gY29udGV4dC5jdXJyZW50Q29udGV4dElkcy5maW5kKGZ1bmN0aW9uIChjb250ZXh0SWQpIHtcbiAgICAgICAgcmV0dXJuICEhdGVuc29yc01hcFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobm9kZU5hbWUsIGNvbnRleHRJZCldO1xuICAgIH0pO1xuICAgIHJldHVybiBjb250ZXh0SWQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRlbnNvcnNNYXBbZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKG5vZGVOYW1lLCBjb250ZXh0SWQpXVtpbmRleF0gOlxuICAgICAgICB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmdldFRlbnNvciA9IGdldFRlbnNvcjtcbmZ1bmN0aW9uIGdldE5vZGVOYW1lQW5kSW5kZXgoaW5wdXROYW1lLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hID0gcGFyc2VOb2RlTmFtZShpbnB1dE5hbWUpLCBub2RlTmFtZSA9IF9hWzBdLCBpbmRleCA9IF9hWzFdO1xuICAgIHJldHVybiBbXG4gICAgICAgIGdldE5vZGVOYW1lV2l0aENvbnRleHRJZChub2RlTmFtZSwgY29udGV4dCAmJiBjb250ZXh0LmN1cnJlbnRDb250ZXh0SWQpLFxuICAgICAgICBpbmRleFxuICAgIF07XG59XG5leHBvcnRzLmdldE5vZGVOYW1lQW5kSW5kZXggPSBnZXROb2RlTmFtZUFuZEluZGV4O1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKG5hbWUsIGNvbnRleHRJZCkge1xuICAgIHJldHVybiAhIWNvbnRleHRJZCA/IG5hbWUgKyBcIi1cIiArIGNvbnRleHRJZCA6IG5hbWU7XG59XG5mdW5jdGlvbiBwYXJzZU5vZGVOYW1lKG5hbWUpIHtcbiAgICB2YXIgaW5kZXggPSBuYW1lLmxhc3RJbmRleE9mKCc6Jyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgcmV0dXJuIFtuYW1lLCAwXTtcbiAgICB2YXIgbm9kZU5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgcmV0dXJuIFtub2RlTmFtZSwgTnVtYmVyKG5hbWUuc3Vic3RyaW5nKGluZGV4ICsgMSkpXTtcbn1cbmV4cG9ydHMucGFyc2VOb2RlTmFtZSA9IHBhcnNlTm9kZU5hbWU7XG5mdW5jdGlvbiBzcGxpdChhcnIsIHNpemUpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IHNpemUpIHtcbiAgICAgICAgcmVzLnB1c2goYXJyLnNsaWNlKGksIGkgKyBzaXplKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQWRkXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImFkZFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJhcml0aG1ldGljXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkJpYXNBZGRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYWRkXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU3ViXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInN1YlwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJhcml0aG1ldGljXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJlYWxEaXZcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZGl2XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRGl2XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImRpdlwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJhcml0aG1ldGljXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk11bFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJtdWxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYXJpdGhtZXRpY1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJNYXhpbXVtXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm1heGltdW1cIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYXJpdGhtZXRpY1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk1pbmltdW1cIixcbiAgICBcImRsT3BOYW1lXCI6IFwibWluaW11bVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJhcml0aG1ldGljXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUG93XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInBvd1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJhcml0aG1ldGljXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNxdWFyZWREaWZmZXJlbmNlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInNxdWFyZWREaWZmZXJlbmNlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTW9kXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm1vZFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJhcml0aG1ldGljXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQWJzXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImFic1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQWNvc1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJhY29zXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBc2luXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImFzaW5cIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcImF0YW5cIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYXRhblwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQ2VpbFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjZWlsXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJDbGlwQnlWYWx1ZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjbGlwQnlWYWx1ZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImNsaXBfdmFsdWVfbWluXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJjbGlwVmFsdWVNaW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJjbGlwX3ZhbHVlX21heFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiY2xpcFZhbHVlTWF4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNvc1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjb3NcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNvc2hcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiY29zaFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRWx1XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImVsdVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRXhwXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImV4cFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRmxvb3JcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZmxvb3JcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkxvZ1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJsb2dcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk5lZ1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJuZWdcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJlbHVcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicmVsdVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmVsdTZcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiY2xpcEJ5VmFsdWVcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiY2xpcFZhbHVlTWluXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiY2xpcFZhbHVlTWF4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiA2XG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNlbHVcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic2VsdVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU2lnbW9pZFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzaWdtb2lkXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTaW5cIixcbiAgICBcImRsT3BOYW1lXCI6IFwic2luXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTaW5oXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInNpbmhcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNxcnRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3FydFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUnNxcnRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicnNxcnRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNxdWFyZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzcXVhcmVcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlRhblwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJ0YW5cIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlRhbmhcIixcbiAgICBcImRsT3BOYW1lXCI6IFwidGFuaFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU2lnblwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzaWduXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJSb3VuZFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyb3VuZFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRXhwbTFcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZXhwbTFcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkxvZzFwXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImxvZzFwXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJSZWNpcHJvY2FsXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInJlY2lwcm9jYWxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJlY2lwcm9jYWxcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicmVjaXByb2NhbFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU29mdHBsdXNcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic29mdHBsdXNcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkFzaW5oXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImFzaW5oXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBY29zaFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJhY29zaFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQXRhbmhcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYXRhbmhcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkVyZlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJlcmZcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTG9vcENvbmRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibG9vcENvbmRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udHJvbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInByZWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU3dpdGNoXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInN3aXRjaFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb250cm9sXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGF0YVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInByZWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTWVyZ2VcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibWVyZ2VcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udHJvbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJ0ZklucHV0UGFyYW1MZW5ndGhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInRlbnNvcnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yc1wiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkVudGVyXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImVudGVyXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNvbnRyb2xcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ0ZW5zb3JcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZnJhbWVfbmFtZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZnJhbWVOYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiaXNfY29uc3RhbnRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImlzQ29uc3RhbnRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkV4aXRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZXhpdFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb250cm9sXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidGVuc29yXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJOZXh0SXRlcmF0aW9uXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm5leHRJdGVyYXRpb25cIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udHJvbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInRlbnNvclwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBdmdQb29sXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImF2Z1Bvb2xcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udm9sdXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwicGFkZGluZ1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicGFkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGF0YV9mb3JtYXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFGb3JtYXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJrc2l6ZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwia2VybmVsU2l6ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJNYXhQb29sXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm1heFBvb2xcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udm9sdXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwicGFkZGluZ1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicGFkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGF0YV9mb3JtYXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFGb3JtYXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJrc2l6ZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwia2VybmVsU2l6ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJDb252MURcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiY29udjFkXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNvbnZvbHV0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImZpbHRlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInN0cmlkZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RyaWRlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwicGFkZGluZ1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicGFkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGF0YV9mb3JtYXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFGb3JtYXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IFwiTldDXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGlsYXRpb25cIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRpbGF0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAxXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNvbnYyRFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjb252MmRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udm9sdXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZmlsdGVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInN0cmlkZXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInN0cmlkZXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInBhZGRpbmdcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInBhZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInVzZUN1ZG5uT25HcHVcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInVzZUN1ZG5uT25HcHVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGF0YV9mb3JtYXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFGb3JtYXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IFwiTkhXQ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGlsYXRpb25zXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkaWxhdGlvbnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJDb252MkRCYWNrcHJvcElucHV0XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImNvbnYyZFRyYW5zcG9zZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb252b2x1dGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJmaWx0ZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJvdXRwdXRTaGFwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwicGFkZGluZ1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicGFkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGF0YV9mb3JtYXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFGb3JtYXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRGVwdGh3aXNlQ29udjJkXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImRlcHRod2lzZUNvbnYyZFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb252b2x1dGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImlucHV0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZmlsdGVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwicGFkZGluZ1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicGFkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGF0YV9mb3JtYXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFGb3JtYXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IFwiTkhXQ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGlsYXRpb25zXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkaWxhdGlvbnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJEZXB0aHdpc2VDb252MmROYXRpdmVcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZGVwdGh3aXNlQ29udjJkXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNvbnZvbHV0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiaW5wdXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJmaWx0ZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJwYWRkaW5nXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJwYWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkYXRhX2Zvcm1hdFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGF0YUZvcm1hdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogXCJOSFdDXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkaWxhdGlvbnNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRpbGF0aW9uc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRmlsbFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJmaWxsXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2hhcGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInZhbHVlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJMaW5TcGFjZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJsaW5zcGFjZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjcmVhdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInN0YXJ0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RvcFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm51bVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiT25lSG90XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm9uZUhvdFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjcmVhdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImluZGljZXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkZXB0aFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm9uVmFsdWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDFcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDMsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJvZmZWYWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk9uZXNcIixcbiAgICBcImRsT3BOYW1lXCI6IFwib25lc1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjcmVhdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNoYXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk9uZXNMaWtlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm9uZXNMaWtlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJhbmRvbVVuaWZvcm1cIixcbiAgICBcImRsT3BOYW1lXCI6IFwicmFuZG9tVW5pZm9ybVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjcmVhdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNoYXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJtaW52YWxcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm1pbnZhbFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIm1heHZhbFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwibWF4dmFsXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAxXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzZWVkXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzZWVkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic2VlZDJcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNlZWQyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJSYW5nZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyYW5nZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjcmVhdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInN0YXJ0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RvcFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInN0ZXBcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUaWR4XCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcInRydW5jYXRlZE5vcm1hbFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJ0cnVuY2F0ZWROb3JtYWxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY3JlYXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzaGFwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwibWVhbnNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm1lYW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDAuMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInN0ZGRldlwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RkRGV2XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAxLjBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzZWVkXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzZWVkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic2VlZDJcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNlZWQyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlplcm9zXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInplcm9zXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2hhcGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiWmVyb3NMaWtlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInplcm9zTGlrZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjcmVhdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUGxhY2Vob2xkZXJXaXRoRGVmYXVsdFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJwbGFjZWhvbGRlclwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJncmFwaFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRlZmF1bHRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUGxhY2Vob2xkZXJcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiZ3JhcGhcIlxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNvbnN0XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImNvbnN0XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImdyYXBoXCJcbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJJZGVudGl0eVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJpZGVudGl0eVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJncmFwaFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU25hcHNob3RcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic25hcHNob3RcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiZ3JhcGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNoYXBlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInNoYXBlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImdyYXBoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJQcmludFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJwcmludFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJncmFwaFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwidGZJbnB1dFBhcmFtTGVuZ3RoXCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkYXRhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvcnNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJmaXJzdF9uXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJmaXJzdE5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwibm90U3VwcHJ0ZWRcIjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInN1bW1hcml6ZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3VtbWFyaXplXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAzXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk5vT3BcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibm9vcFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJncmFwaFwiLFxuICAgIFwicGFyYW1zXCI6IFtdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU3RvcEdyYWRpZW50XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInN0b3BHcmFkaWVudFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJncmFwaFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRmFrZVF1YW50V2l0aE1pbk1heFZhcnNcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZmFrZVF1YW50V2l0aE1pbk1heFZhcnNcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiZ3JhcGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwibWluXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJtaW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJtYXhcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm1heFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfVxuICAgIF1cbiAgfVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJlc2l6ZUJpbGluZWFyXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInJlc2l6ZUJpbGluZWFyXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImltYWdlXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiaW1hZ2VzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2l6ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYWxpZ25fY29ybmVyc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYWxpZ25Db3JuZXJzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmVzaXplTmVhcmVzdE5laWdoYm9yXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJpbWFnZVwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImltYWdlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNpemVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImFsaWduX2Nvcm5lcnNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFsaWduQ29ybmVyc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRXF1YWxcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZXF1YWxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibG9naWNhbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJOb3RFcXVhbFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJub3RFcXVhbFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJsb2dpY2FsXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkdyZWF0ZXJcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZ3JlYXRlclwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJsb2dpY2FsXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkdyZWF0ZXJFcXVhbFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJncmVhdGVyRXF1YWxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibG9naWNhbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJMZXNzXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImxlc3NcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibG9naWNhbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJMZXNzRXF1YWxcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibGVzc0VxdWFsXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImxvZ2ljYWxcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTG9naWNhbEFuZFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJsb2dpY2FsQW5kXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImxvZ2ljYWxcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTG9naWNhbE5vdFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJsb2dpY2FsTm90XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImxvZ2ljYWxcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJMb2dpY2FsT3JcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibG9naWNhbE9yXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImxvZ2ljYWxcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU2VsZWN0XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIndoZXJlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImxvZ2ljYWxcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJjb25kaXRpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAyLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJNYXRNdWxcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibWF0TXVsXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcIm1hdHJpY2VzXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJ0cmFuc3Bvc2VfYVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidHJhbnNwb3NlQVwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IGZhbHNlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwidHJhbnNwb3NlX2JcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInRyYW5zcG9zZUJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiVHJhbnNwb3NlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInRyYW5zcG9zZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJtYXRyaWNlc1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJwZXJtXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJwZXJtXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRnVzZWRCYXRjaE5vcm1cIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcIm5vcm1hbGl6YXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2NhbGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJvZmZzZXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDMsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJtZWFuXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiA0LFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidmFyaWFuY2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJlcHNpbG9uXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJlcHNpbG9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwLjAwMVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImRhdGFfZm9ybWF0XCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkYXRhRm9ybWF0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkZ1c2VkQmF0Y2hOb3JtVjJcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcIm5vcm1hbGl6YXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2NhbGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJvZmZzZXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDMsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJtZWFuXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiA0LFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidmFyaWFuY2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJlcHNpbG9uXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJlcHNpbG9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwLjAwMVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImRhdGFfZm9ybWF0XCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkYXRhRm9ybWF0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkxSTlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvblwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJub3JtYWxpemF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImRlcHRoX3JhZGl1c1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicmFkaXVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiA1XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYmlhc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYmlhc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMS4wXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYWxwaGFcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFscGhhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAxLjBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJiZXRhXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiZXRhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwLjVcbiAgICAgIH1cbiAgICBdXG4gIH0sICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNvZnRtYXhcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic29mdG1heFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJub3JtYWxpemF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfVxuICAgIF1cbiAgfVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk1heFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJtYXhcIixcbiAgICBcImNhdGVnb3J5XCI6IFwicmVkdWN0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImtlZXBfZGltc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwia2VlcERpbXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk1lYW5cIixcbiAgICBcImRsT3BOYW1lXCI6IFwibWVhblwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJyZWR1Y3Rpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwia2VlcF9kaW1zXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJrZWVwRGltc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTWluXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm1pblwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJyZWR1Y3Rpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwia2VlcF9kaW1zXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJrZWVwRGltc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU3VtXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInN1bVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJyZWR1Y3Rpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwia2VlcF9kaW1zXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJrZWVwRGltc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQXJnTWF4XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImFyZ01heFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJyZWR1Y3Rpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBcmdNaW5cIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYXJnTWluXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInJlZHVjdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQ29uY2F0VjJcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiY29uY2F0XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInNsaWNlX2pvaW5cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwidGZJbnB1dFBhcmFtTGVuZ3RoXCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ0ZW5zb3JzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvcnNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogLTEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNvbmNhdFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjb25jYXRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJ0ZklucHV0UGFyYW1MZW5ndGhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInRlbnNvcnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJHYXRoZXJWMlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJnYXRoZXJcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJpbmRpY2VzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJHYXRoZXJcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZ2F0aGVyXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInNsaWNlX2pvaW5cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiaW5kaWNlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJ2YWxpZGF0ZV9pbmRpY2VzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ2YWxpZGF0ZUluZGljZXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJldmVyc2VcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicmV2ZXJzZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJzbGljZV9qb2luXCIsXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJldmVyc2VWMlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyZXZlcnNlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInNsaWNlX2pvaW5cIixcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU2xpY2VcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic2xpY2VcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYmVnaW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNpemVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTdHJpZGVkU2xpY2VcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3RyaWRlZFNsaWNlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInNsaWNlX2pvaW5cIixcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJlZ2luXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJlbmRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMyxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInN0cmlkZXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImJlZ2luX21hc2tcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJlZ2luTWFza1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImVuZF9tYXNrXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJlbmRNYXNrXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlBhY2tcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3RhY2tcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwidGZJbnB1dFBhcmFtTGVuZ3RoXCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ0ZW5zb3JzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvcnNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDBcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiVGlsZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJ0aWxlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInNsaWNlX2pvaW5cIixcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInJlcHNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTcGxpdFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzcGxpdFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJzbGljZV9qb2luXCIsXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwibnVtX3NwbGl0XCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJudW1PclNpemVTcGxpdHNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDFcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJDYXN0XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImNhc3RcIixcbiAgICBcImNhdGVnb3J5XCI6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiU3JjVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2R0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJEc3RUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkV4cGFuZERpbXNcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZXhwYW5kRGltc1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcInRmUGFyYW1OYW1lRGVwcmVjYXRlZFwiOiBcImRpbVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJQYWRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicGFkXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJwYWRkaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJjb25zdGFudF92YWx1ZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiY29uc3RhbnRWYWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJQYWRWMlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJwYWRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInBhZGRpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImNvbnN0YW50VmFsdWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDBcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmVzaGFwZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyZXNoYXBlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzaGFwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNxdWVlemVcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3F1ZWV6ZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInRmUGFyYW1OYW1lRGVwcmVjYXRlZFwiOiBcInNxdWVlemVfZGltc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcml0aG1ldGljID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL2FyaXRobWV0aWNfZXhlY3V0b3JcIik7XG52YXIgYmFzaWNNYXRoID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL2Jhc2ljX21hdGhfZXhlY3V0b3JcIik7XG52YXIgY29udHJvbCA9IHJlcXVpcmUoXCIuL2V4ZWN1dG9ycy9jb250cm9sX2V4ZWN1dG9yXCIpO1xudmFyIGNvbnZvbHV0aW9uID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL2NvbnZvbHV0aW9uX2V4ZWN1dG9yXCIpO1xudmFyIGNyZWF0aW9uID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL2NyZWF0aW9uX2V4ZWN1dG9yXCIpO1xudmFyIGdyYXBoID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL2dyYXBoX2V4ZWN1dG9yXCIpO1xudmFyIGltYWdlID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL2ltYWdlX2V4ZWN1dG9yXCIpO1xudmFyIGxvZ2ljYWwgPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvbG9naWNhbF9leGVjdXRvclwiKTtcbnZhciBtYXRyaWNlcyA9IHJlcXVpcmUoXCIuL2V4ZWN1dG9ycy9tYXRyaWNlc19leGVjdXRvclwiKTtcbnZhciBub3JtYWxpemF0aW9uID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL25vcm1hbGl6YXRpb25fZXhlY3V0b3JcIik7XG52YXIgcmVkdWN0aW9uID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL3JlZHVjdGlvbl9leGVjdXRvclwiKTtcbnZhciBzbGljZUpvaW4gPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvc2xpY2Vfam9pbl9leGVjdXRvclwiKTtcbnZhciB0cmFuc2Zvcm1hdGlvbiA9IHJlcXVpcmUoXCIuL2V4ZWN1dG9ycy90cmFuc2Zvcm1hdGlvbl9leGVjdXRvclwiKTtcbmZ1bmN0aW9uIGV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUuY2F0ZWdvcnkpIHtcbiAgICAgICAgY2FzZSAnYXJpdGhtZXRpYyc6XG4gICAgICAgICAgICByZXR1cm4gYXJpdGhtZXRpYy5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnYmFzaWNfbWF0aCc6XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNNYXRoLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdjb250cm9sJzpcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdjb252b2x1dGlvbic6XG4gICAgICAgICAgICByZXR1cm4gY29udm9sdXRpb24uZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2NyZWF0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGlvbi5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIGltYWdlLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdncmFwaCc6XG4gICAgICAgICAgICByZXR1cm4gZ3JhcGguZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2xvZ2ljYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGxvZ2ljYWwuZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ21hdHJpY2VzJzpcbiAgICAgICAgICAgIHJldHVybiBtYXRyaWNlcy5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnbm9ybWFsaXphdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXphdGlvbi5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAncmVkdWN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiByZWR1Y3Rpb24uZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ3NsaWNlX2pvaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHNsaWNlSm9pbi5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAndHJhbnNmb3JtYXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmV4ZWN1dGVPcCA9IGV4ZWN1dGVPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdGlvbl9leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21waWxlZF9hcGlfMSA9IHJlcXVpcmUoXCIuLi9kYXRhL2NvbXBpbGVkX2FwaVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL3V0aWxzXCIpO1xudmFyIGFyaXRobWV0aWMgPSByZXF1aXJlKFwiLi9vcF9saXN0L2FyaXRobWV0aWMuanNvblwiKTtcbnZhciBiYXNpY01hdGggPSByZXF1aXJlKFwiLi9vcF9saXN0L2Jhc2ljX21hdGguanNvblwiKTtcbnZhciBjb250cm9sID0gcmVxdWlyZShcIi4vb3BfbGlzdC9jb250cm9sLmpzb25cIik7XG52YXIgY29udm9sdXRpb24gPSByZXF1aXJlKFwiLi9vcF9saXN0L2NvbnZvbHV0aW9uLmpzb25cIik7XG52YXIgY3JlYXRpb24gPSByZXF1aXJlKFwiLi9vcF9saXN0L2NyZWF0aW9uLmpzb25cIik7XG52YXIgZ3JhcGggPSByZXF1aXJlKFwiLi9vcF9saXN0L2dyYXBoLmpzb25cIik7XG52YXIgaW1hZ2UgPSByZXF1aXJlKFwiLi9vcF9saXN0L2ltYWdlLmpzb25cIik7XG52YXIgbG9naWNhbCA9IHJlcXVpcmUoXCIuL29wX2xpc3QvbG9naWNhbC5qc29uXCIpO1xudmFyIG1hdHJpY2VzID0gcmVxdWlyZShcIi4vb3BfbGlzdC9tYXRyaWNlcy5qc29uXCIpO1xudmFyIG5vcm1hbGl6YXRpb24gPSByZXF1aXJlKFwiLi9vcF9saXN0L25vcm1hbGl6YXRpb24uanNvblwiKTtcbnZhciByZWR1Y3Rpb24gPSByZXF1aXJlKFwiLi9vcF9saXN0L3JlZHVjdGlvbi5qc29uXCIpO1xudmFyIHNsaWNlSm9pbiA9IHJlcXVpcmUoXCIuL29wX2xpc3Qvc2xpY2Vfam9pbi5qc29uXCIpO1xudmFyIHRyYW5zZm9ybWF0aW9uID0gcmVxdWlyZShcIi4vb3BfbGlzdC90cmFuc2Zvcm1hdGlvbi5qc29uXCIpO1xudmFyIENPTlRST0xfRkxPV19PUFMgPSBbJ1N3aXRjaCcsICdNZXJnZScsICdFbnRlcicsICdFeGl0JywgJ05leHRJdGVyYXRpb24nXTtcbnZhciBPcGVyYXRpb25NYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wZXJhdGlvbk1hcHBlcigpIHtcbiAgICAgICAgdmFyIG9wcyA9IFtcbiAgICAgICAgICAgIGFyaXRobWV0aWMsIGJhc2ljTWF0aCwgY29udHJvbCwgY29udm9sdXRpb24sIGNyZWF0aW9uLCBsb2dpY2FsLCBpbWFnZSxcbiAgICAgICAgICAgIGdyYXBoLCBtYXRyaWNlcywgbm9ybWFsaXphdGlvbiwgcmVkdWN0aW9uLCBzbGljZUpvaW4sIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgIF07XG4gICAgICAgIHZhciBtYXBwZXJzSnNvbiA9IFtdLmNvbmNhdC5hcHBseShbXSwgb3BzLm1hcChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmRlZmF1bHQgPyBvcC5kZWZhdWx0IDogb3A7IH0pKTtcbiAgICAgICAgdGhpcy5vcE1hcHBlcnMgPSBtYXBwZXJzSnNvbi5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgbWFwcGVyKSB7XG4gICAgICAgICAgICBtYXBbbWFwcGVyLnRmT3BOYW1lXSA9IG1hcHBlcjtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wZXJhdGlvbk1hcHBlciwgXCJJbnN0YW5jZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlIHx8ICh0aGlzLl9pbnN0YW5jZSA9IG5ldyB0aGlzKCkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPcGVyYXRpb25NYXBwZXIucHJvdG90eXBlLmlzQ29udHJvbEZsb3cgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gQ09OVFJPTF9GTE9XX09QUy5zb21lKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AgPT09IG5vZGUub3A7IH0pO1xuICAgIH07XG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS50cmFuc2Zvcm1HcmFwaCA9IGZ1bmN0aW9uIChncmFwaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGZOb2RlcyA9IGdyYXBoLm5vZGU7XG4gICAgICAgIHZhciB3aXRoQ29udHJvbEZsb3cgPSBmYWxzZTtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVycyA9IFtdO1xuICAgICAgICB2YXIgbm9kZXMgPSB0Zk5vZGVzLnJlZHVjZShmdW5jdGlvbiAobWFwLCBub2RlKSB7XG4gICAgICAgICAgICBtYXBbbm9kZS5uYW1lXSA9IF90aGlzLm1hcE5vZGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNDb250cm9sRmxvdyhub2RlKSlcbiAgICAgICAgICAgICAgICB3aXRoQ29udHJvbEZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5vZGUub3AgPT09ICdQbGFjZWhvbGRlcicpXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJzLnB1c2gobWFwW25vZGUubmFtZV0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgaW5wdXRzID0gW107XG4gICAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKG5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNba2V5XTtcbiAgICAgICAgICAgIG5vZGUuaW5wdXROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gdXRpbHNfMS5nZXROb2RlTmFtZUFuZEluZGV4KG5hbWUpWzBdO1xuICAgICAgICAgICAgICAgIG5vZGUuaW5wdXRzLnB1c2gobm9kZXNbbm9kZU5hbWVdKTtcbiAgICAgICAgICAgICAgICBub2Rlc1tub2RlTmFtZV0uY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5vZGUuaW5wdXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBub2Rlczogbm9kZXMsIGlucHV0czogaW5wdXRzLCBvdXRwdXRzOiBvdXRwdXRzLCBwbGFjZWhvbGRlcnM6IHBsYWNlaG9sZGVycywgd2l0aENvbnRyb2xGbG93OiB3aXRoQ29udHJvbEZsb3cgfTtcbiAgICB9O1xuICAgIE9wZXJhdGlvbk1hcHBlci5wcm90b3R5cGUubWFwTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtYXBwZXIgPSB0aGlzLm9wTWFwcGVyc1tub2RlLm9wXTtcbiAgICAgICAgaWYgKG1hcHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvcmZsb3cgT3AgaXMgbm90IHN1cHBvcnRlZDogJyArIG5vZGUub3ApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdOb2RlID0ge1xuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgb3A6IG1hcHBlci5kbE9wTmFtZSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBtYXBwZXIuY2F0ZWdvcnksXG4gICAgICAgICAgICBpbnB1dE5hbWVzOiAobm9kZS5pbnB1dCB8fFxuICAgICAgICAgICAgICAgIFtdKS5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5zdGFydHNXaXRoKCdeJykgPyBpbnB1dC5zdWJzdHIoMSkgOiBpbnB1dDsgfSksXG4gICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgcGFyYW1zOiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAoISFtYXBwZXIucGFyYW1zKSB7XG4gICAgICAgICAgICBuZXdOb2RlLnBhcmFtcyA9IG1hcHBlci5wYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChtYXAsIHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0SW5kZXggPSBwYXJhbS50ZklucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0UGFyYW1MZW5ndGggPSBwYXJhbS50ZklucHV0UGFyYW1MZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBwYXJhbS50eXBlO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmdldFN0cmluZ1BhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWUsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgISFwYXJhbS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5nZXRTdHJpbmdQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0TnVtYmVyUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZlBhcmFtTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmdldE51bWJlclBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcltdJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmdldE51bWVyaWNBcnJheVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWUsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgISFwYXJhbS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5nZXROdW1lcmljQXJyYXlQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmdldEJvb2xQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmUGFyYW1OYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEhcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0Qm9vbFBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NoYXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmdldFRlbnNvclNoYXBlUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZlBhcmFtTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmdldFRlbnNvclNoYXBlUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZHR5cGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0RHR5cGVQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmUGFyYW1OYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEhcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0RHR5cGVQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZW5zb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGVuc29ycyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBhcmFtIHR5cGU6IFwiICsgcGFyYW0udHlwZSArIFwiIGZvciBvcDogXCIgKyBub2RlLm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBbcGFyYW0uZGxQYXJhbU5hbWVdID0geyB2YWx1ZTogdmFsdWUsIGlucHV0SW5kZXg6IGlucHV0SW5kZXgsIHR5cGU6IHR5cGUsIGlucHV0UGFyYW1MZW5ndGg6IGlucHV0UGFyYW1MZW5ndGggfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH07XG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS5nZXRTdHJpbmdQYXJhbSA9IGZ1bmN0aW9uIChhdHRycywgbmFtZSwgZGVmLCBrZWVwQ2FzZSkge1xuICAgICAgICBpZiAoa2VlcENhc2UgPT09IHZvaWQgMCkgeyBrZWVwQ2FzZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBwYXJhbSA9IGF0dHJzW25hbWVdO1xuICAgICAgICBpZiAocGFyYW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBwYXJhbS5zKTtcbiAgICAgICAgICAgIHJldHVybiBrZWVwQ2FzZSA/IHZhbHVlIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmO1xuICAgIH07XG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS5nZXRCb29sUGFyYW0gPSBmdW5jdGlvbiAoYXR0cnMsIG5hbWUsIGRlZikge1xuICAgICAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIHBhcmFtID8gcGFyYW0uYiA6IGRlZjtcbiAgICB9O1xuICAgIE9wZXJhdGlvbk1hcHBlci5wcm90b3R5cGUuZ2V0TnVtYmVyUGFyYW0gPSBmdW5jdGlvbiAoYXR0cnMsIG5hbWUsIGRlZikge1xuICAgICAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgdmFyIHZhbHVlID0gKHBhcmFtID8gKChwYXJhbS5mICE9PSB1bmRlZmluZWQpID8gcGFyYW0uZiA6IHBhcmFtLmkpIDogZGVmKTtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSA/IHZhbHVlIDogdmFsdWVbJ3RvSW50J10oKTtcbiAgICB9O1xuICAgIE9wZXJhdGlvbk1hcHBlci5wcm90b3R5cGUuZ2V0RHR5cGVQYXJhbSA9IGZ1bmN0aW9uIChhdHRycywgbmFtZSwgZGVmKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IGF0dHJzW25hbWVdO1xuICAgICAgICBpZiAocGFyYW0gJiYgcGFyYW0udHlwZSkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBjb21waWxlZF9hcGlfMS50ZW5zb3JmbG93LkRhdGFUeXBlLkRUX0ZMT0FUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgICAgICAgICAgICAgIGNhc2UgY29tcGlsZWRfYXBpXzEudGVuc29yZmxvdy5EYXRhVHlwZS5EVF9JTlQzMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgICAgICAgICAgICAgY2FzZSBjb21waWxlZF9hcGlfMS50ZW5zb3JmbG93LkRhdGFUeXBlLkRUX0JPT0w6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmO1xuICAgIH07XG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS5nZXRUZW5zb3JTaGFwZVBhcmFtID0gZnVuY3Rpb24gKGF0dHJzLCBuYW1lLCBkZWYpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gYXR0cnNbbmFtZV07XG4gICAgICAgIGlmIChwYXJhbSAmJiBwYXJhbS5zaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtLnNoYXBlLmRpbS5tYXAoZnVuY3Rpb24gKGRpbSkgeyByZXR1cm4gZGltLnNpemU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfTtcbiAgICBPcGVyYXRpb25NYXBwZXIucHJvdG90eXBlLmdldE51bWVyaWNBcnJheVBhcmFtID0gZnVuY3Rpb24gKGF0dHJzLCBuYW1lLCBkZWYpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gYXR0cnNbbmFtZV07XG4gICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgcmV0dXJuICgocGFyYW0ubGlzdC5mICYmIHBhcmFtLmxpc3QuZi5sZW5ndGggPyBwYXJhbS5saXN0LmYgOlxuICAgICAgICAgICAgICAgIHBhcmFtLmxpc3QuaSkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gKHR5cGVvZiB2ID09PSAnbnVtYmVyJykgPyB2IDogdlsndG9JbnQnXSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmO1xuICAgIH07XG4gICAgcmV0dXJuIE9wZXJhdGlvbk1hcHBlcjtcbn0oKSk7XG5leHBvcnRzLk9wZXJhdGlvbk1hcHBlciA9IE9wZXJhdGlvbk1hcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdGlvbl9tYXBwZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmVyc2lvbiA9ICcwLjQuMSc7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuL2RvY1wiKTtcbnZhciBCcm93c2VyVXRpbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlclV0aWwoKSB7XG4gICAgfVxuICAgIEJyb3dzZXJVdGlsLm5leHRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9KTsgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1BlcmZvcm1hbmNlJywgc3ViaGVhZGluZzogJ1RpbWluZycgfSlcbiAgICBdLCBCcm93c2VyVXRpbCwgXCJuZXh0RnJhbWVcIiwgbnVsbCk7XG4gICAgcmV0dXJuIEJyb3dzZXJVdGlsO1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlclV0aWwgPSBCcm93c2VyVXRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICAgIHZhciBhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYTtcbiAgICByZXR1cm4gLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pXG4gICAgICAgIC50ZXN0KGEpIHx8XG4gICAgICAgIC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pXG4gICAgICAgICAgICAudGVzdChhLnN1YnN0cigwLCA0KSk7XG59XG5leHBvcnRzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXZpY2VfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGRvYyhpbmZvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmRvYyA9IGRvYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wcy9vcHNcIik7XG52YXIgcHJvZmlsZXJfMSA9IHJlcXVpcmUoXCIuL3Byb2ZpbGVyXCIpO1xudmFyIHRhcGVfMSA9IHJlcXVpcmUoXCIuL3RhcGVcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi90ZW5zb3JcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgRW5naW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmdpbmUoYmFja2VuZCwgc2FmZU1vZGUpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdGhpcy5zYWZlTW9kZSA9IHNhZmVNb2RlO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZDb3VudGVyID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5uZXh0VGFwZU5vZGVJZCA9IDA7XG4gICAgICAgIHRoaXMubnVtQnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLm51bVRlbnNvcnMgPSAwO1xuICAgICAgICB0aGlzLm51bURhdGFCdWZmZXJzID0gMDtcbiAgICAgICAgdGhpcy5ncmFkaWVudFNjb3BlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmN1c3RvbUdyYWRpZW50RGVwdGggPSAwO1xuICAgICAgICB0aGlzLmtlZXBUZW5zb3JzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlID0geyB0cmFjazogW10gfTtcbiAgICAgICAgdGhpcy5zY29wZVN0YWNrID0gW3RoaXMuYWN0aXZlU2NvcGVdO1xuICAgICAgICB0aGlzLnByb2ZpbGVyID0gbmV3IHByb2ZpbGVyXzEuUHJvZmlsZXIoYmFja2VuZCk7XG4gICAgfVxuICAgIEVuZ2luZS5wcm90b3R5cGUucnVuS2VybmVsID0gZnVuY3Rpb24gKGZvcndhcmRGdW5jLCBpbnB1dHMsIGJhY2t3YXJkc0Z1bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHNhdmVkID0gW107XG4gICAgICAgIHZhciBzYXZlRnVuYyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBzYXZlZC5wdXNoKHgpO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzY29wZU5hbWUgPSB0aGlzLmFjdGl2ZVNjb3BlLm5hbWU7XG4gICAgICAgIHRoaXMuY3VzdG9tR3JhZGllbnREZXB0aCsrO1xuICAgICAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnREVCVUcnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZm9yd2FyZEZ1bmModGhpcy5iYWNrZW5kLCBzYXZlRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2ZpbGVyLnByb2ZpbGVLZXJuZWwoc2NvcGVOYW1lLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3J3YXJkRnVuYyhfdGhpcy5iYWNrZW5kLCBzYXZlRnVuYyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VzdG9tR3JhZGllbnREZXB0aC0tO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvcmQoKSkge1xuICAgICAgICAgICAgdmFyIHRhcGVOb2RlID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLm5leHRUYXBlTm9kZUlkKyssXG4gICAgICAgICAgICAgICAgbmFtZTogc2NvcGVOYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcmVzdWx0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChiYWNrd2FyZHNGdW5jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXBlTm9kZS5ncmFkaWVudCA9IGZ1bmN0aW9uIChkeSkgeyByZXR1cm4gYmFja3dhcmRzRnVuYyhkeSwgc2F2ZWQpOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYXBlLnB1c2godGFwZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyVGVuc29yID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHJlZkNvdW50ID0gdGhpcy5yZWZDb3VudGVyLmhhcyhhLmRhdGFJZCkgPyB0aGlzLnJlZkNvdW50ZXIuZ2V0KGEuZGF0YUlkKSA6IDA7XG4gICAgICAgIHRoaXMubnVtVGVuc29ycysrO1xuICAgICAgICBpZiAocmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubnVtRGF0YUJ1ZmZlcnMrKztcbiAgICAgICAgICAgIHRoaXMubnVtQnl0ZXMgKz1cbiAgICAgICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoYS5zaGFwZSkgKiB1dGlsLmJ5dGVzUGVyRWxlbWVudChhLmR0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZC5yZWdpc3RlcihhLmRhdGFJZCwgYS5zaGFwZSwgYS5kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZDb3VudGVyLnNldChhLmRhdGFJZCwgcmVmQ291bnQgKyAxKTtcbiAgICAgICAgaWYgKCEoYSBpbnN0YW5jZW9mIHRlbnNvcl8xLlZhcmlhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy50cmFjayhhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlclZhcmlhYmxlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1t2Lm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIHdpdGggbmFtZSBcIiArIHYubmFtZSArIFwiIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3YubmFtZV0gPSB2O1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5kaXNwb3NlVGVuc29yID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZkNvdW50ZXIuaGFzKGEuZGF0YUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVtVGVuc29ycy0tO1xuICAgICAgICB2YXIgcmVmQ291bnQgPSB0aGlzLnJlZkNvdW50ZXIuZ2V0KGEuZGF0YUlkKTtcbiAgICAgICAgaWYgKHJlZkNvdW50IDw9IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVmQ291bnRlci5kZWxldGUoYS5kYXRhSWQpO1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kLmRpc3Bvc2VEYXRhKGEuZGF0YUlkKTtcbiAgICAgICAgICAgIHRoaXMubnVtRGF0YUJ1ZmZlcnMtLTtcbiAgICAgICAgICAgIHRoaXMubnVtQnl0ZXMgLT1cbiAgICAgICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoYS5zaGFwZSkgKiB1dGlsLmJ5dGVzUGVyRWxlbWVudChhLmR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmQ291bnRlci5zZXQoYS5kYXRhSWQsIHJlZkNvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuZGlzcG9zZVZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdmFyTmFtZSBpbiB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3Zhck5hbWVdO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlVGVuc29yKHYpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJOYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5tZW1vcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmZvID0gdGhpcy5iYWNrZW5kLm1lbW9yeSgpO1xuICAgICAgICBpbmZvLm51bVRlbnNvcnMgPSB0aGlzLm51bVRlbnNvcnM7XG4gICAgICAgIGluZm8ubnVtRGF0YUJ1ZmZlcnMgPSB0aGlzLm51bURhdGFCdWZmZXJzO1xuICAgICAgICBpbmZvLm51bUJ5dGVzID0gdGhpcy5udW1CeXRlcztcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLnNob3VsZFJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVGFwZSAhPSBudWxsICYmIHRoaXMuY3VzdG9tR3JhZGllbnREZXB0aCA9PT0gMDtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkVGFwZU5vZGUgPSBmdW5jdGlvbiAoaW5wdXRzLCByZXN1bHQsIGdyYWRpZW50c0Z1bmMpIHtcbiAgICAgICAgdmFyIGlucHV0c01hcCA9IHt9O1xuICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGlkeCkge1xuICAgICAgICAgICAgaW5wdXRzTWFwW2lkeF0gPSBpbnB1dDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBncmFkaWVudCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGdyYWRpZW50c0Z1bmMoZHkpO1xuICAgICAgICAgICAgdmFyIHJlc01hcCA9IHt9O1xuICAgICAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24gKHIsIGlkeCkge1xuICAgICAgICAgICAgICAgIHJlc01hcFtpZHhdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcjsgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc01hcDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhcGVOb2RlID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMubmV4dFRhcGVOb2RlSWQrKyxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuYWN0aXZlU2NvcGUubmFtZSxcbiAgICAgICAgICAgIGlucHV0czogaW5wdXRzTWFwLFxuICAgICAgICAgICAgb3V0cHV0OiByZXN1bHQsXG4gICAgICAgICAgICBncmFkaWVudDogZ3JhZGllbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3RpdmVUYXBlLnB1c2godGFwZU5vZGUpO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5rZWVwID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5zY29wZVN0YWNrLmxlbmd0aCA9PT0gMSAmJiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuc2FmZU1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2FmZSBtb2RlIGlzIE9OLiBFbmNsb3NlIGFsbCB0ZW5zb3Igb3BlcmF0aW9ucyBpbnNpZGUgdGYudGlkeSgpOiAnICtcbiAgICAgICAgICAgICAgICAndGYudGlkeSgoKSA9PiB7Li4ufSkgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VlcFRlbnNvcnMuYWRkKHJlc3VsdC5pZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLnN0YXJ0U2NvcGUgPSBmdW5jdGlvbiAobmFtZSwgZ3JhZGllbnRzTW9kZSkge1xuICAgICAgICBpZiAoZ3JhZGllbnRzTW9kZSA9PT0gdm9pZCAwKSB7IGdyYWRpZW50c01vZGUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZ3JhZGllbnRzTW9kZSAmJiB0aGlzLmdyYWRpZW50U2NvcGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYXBlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyYWRpZW50c01vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTY29wZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjb3BlSW5mbyA9IHsgdHJhY2s6IFtdIH07XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBzY29wZUluZm8ubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZVN0YWNrLnB1c2goc2NvcGVJbmZvKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZSA9IHNjb3BlSW5mbztcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuZW5kU2NvcGUgPSBmdW5jdGlvbiAocmVzdWx0LCBncmFkaWVudHNNb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChncmFkaWVudHNNb2RlID09PSB2b2lkIDApIHsgZ3JhZGllbnRzTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChncmFkaWVudHNNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U2NvcGVDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnRTY29wZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUYXBlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVuc29yc1RvS2VlcCA9IG5ldyBTZXQodGhpcy5rZWVwVGVuc29ycyk7XG4gICAgICAgIHZhciB0ZW5zb3JzVG9UcmFja0luUGFyZW50ID0gdXRpbC5nZXRUZW5zb3JzSW5Db250YWluZXIocmVzdWx0KTtcbiAgICAgICAgdGVuc29yc1RvVHJhY2tJblBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3IpIHsgcmV0dXJuIHRlbnNvcnNUb0tlZXAuYWRkKHRlbnNvci5pZCk7IH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlU2NvcGUudHJhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW5zb3IgPSB0aGlzLmFjdGl2ZVNjb3BlLnRyYWNrW2ldO1xuICAgICAgICAgICAgaWYgKHRlbnNvcnNUb0tlZXAuaGFzKHRlbnNvci5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbnNvcnNUb1RyYWNrSW5QYXJlbnQucHVzaCh0ZW5zb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkU2NvcGUgPSB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGUgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoID09PSAwID9cbiAgICAgICAgICAgIHsgdHJhY2s6IFtdIH0gOlxuICAgICAgICAgICAgdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdGVuc29yc1RvVHJhY2tJblBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMua2VlcFRlbnNvcnMuaGFzKHRlbnNvci5pZCkgJiZcbiAgICAgICAgICAgICAgICB1dGlsLmlzVGVuc29ySW5MaXN0KHRlbnNvciwgb2xkU2NvcGUudHJhY2spKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2sodGVuc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLmdyYWRpZW50cyA9IGZ1bmN0aW9uIChmLCB4cywgZHksIGFsbG93Tm9HcmFkaWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFsbG93Tm9HcmFkaWVudHMgPT09IHZvaWQgMCkgeyBhbGxvd05vR3JhZGllbnRzID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeHMubGVuZ3RoID4gMCwgJ2dyYWRpZW50cygpIHJlY2VpdmVkIGFuIGVtcHR5IGxpc3Qgb2YgeHMuJyk7XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudGlkeSgnZ3JhZGllbnRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHkgPSBmKCk7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh5IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yLCAnVGhlIHJlc3VsdCB5IHJldHVybmVkIGJ5IGYoKSBtdXN0IGJlIGEgdGVuc29yLicpO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkVGFwZSA9IHRhcGVfMS5nZXRGaWx0ZXJlZE5vZGVzWFRvWShfdGhpcy5hY3RpdmVUYXBlLCB4cywgeSk7XG4gICAgICAgICAgICBpZiAoIWFsbG93Tm9HcmFkaWVudHMgJiYgZmlsdGVyZWRUYXBlLmxlbmd0aCA9PT0gMCAmJiB4cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoYXQgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4ICcgK1xuICAgICAgICAgICAgICAgICAgICAndG8geS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZEdyYWRpZW50TWFwID0ge307XG4gICAgICAgICAgICBhY2N1bXVsYXRlZEdyYWRpZW50TWFwW3kuaWRdID0gKGR5ID09IG51bGwpID8gb3BzLm9uZXMoeS5zaGFwZSkgOiBkeTtcbiAgICAgICAgICAgIHRhcGVfMS5iYWNrcHJvcGFnYXRlR3JhZGllbnRzKGFjY3VtdWxhdGVkR3JhZGllbnRNYXAsIGZpbHRlcmVkVGFwZSk7XG4gICAgICAgICAgICB2YXIgZ3JhZHMgPSB4cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF07IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHksIGdyYWRzOiBncmFkcyB9O1xuICAgICAgICB9LCB0cnVlKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuY3VzdG9tR3JhZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsLmFzc2VydChpbnB1dHMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3I7IH0pLCAnVGhlIGFyZ3MgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikoeDEsIHgyLC4uLikgbXVzdCBhbGwgYmUgdGVuc29ycycpO1xuICAgICAgICAgICAgX3RoaXMuY3VzdG9tR3JhZGllbnREZXB0aCsrO1xuICAgICAgICAgICAgdmFyIGdyYWRpZW50c0Z1bmM7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnRzTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2xvYmFsc18xLnRpZHkoZi5uYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZi5hcHBseSh2b2lkIDAsIGlucHV0cyksIHZhbHVlID0gX2EudmFsdWUsIGdyYWRGdW5jID0gX2EuZ3JhZEZ1bmM7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnQodmFsdWUgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aGVyZSBgb2JqLnZhbHVlYCBpcyBhIHRlbnNvcicpO1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihncmFkRnVuYyksICdUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50c0Z1bmMgPSBncmFkRnVuYztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LCBncmFkaWVudHNNb2RlKTtcbiAgICAgICAgICAgIF90aGlzLmN1c3RvbUdyYWRpZW50RGVwdGgtLTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zaG91bGRSZWNvcmQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBncmFkRnVuYyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gZ3JhZGllbnRzRnVuYyhkeSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmFkcyA9IEFycmF5LmlzQXJyYXkocmVzKSA/IHJlcyA6IFtyZXNdO1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydChncmFkcy5sZW5ndGggPT09IGlucHV0cy5sZW5ndGgsICdUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNhbWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyIG9mIHRlbnNvcnMgYXMgaW5wdXRzIHBhc3NlZCB0byBmKC4uLikuJyk7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGdyYWRzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yOyB9KSwgJ1RoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGxpc3Qgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25seSB0ZW5zb3JzLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JhZHM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRUYXBlTm9kZShpbnB1dHMsIHJlc3VsdCwgZ3JhZEZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLndyaXRlKGRhdGFJZCwgdmFsdWVzKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUucmVhZFN5bmMgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQucmVhZFN5bmMoZGF0YUlkKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5yZWFkKGRhdGFJZCk7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLmZyb21QaXhlbHMgPSBmdW5jdGlvbiAocGl4ZWxzLCBudW1DaGFubmVscykge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmZyb21QaXhlbHMocGl4ZWxzLCBudW1DaGFubmVscyk7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0LCB0aW1pbmdJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5iYWNrZW5kLnRpbWUocXVlcnkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGltaW5nSW5mbyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWluZ0luZm8ud2FsbE1zID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGltaW5nSW5mb107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVTdGFjay5sZW5ndGggPT09IDEgJiYgdGhpcy5zYWZlTW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYWZlIG1vZGUgaXMgT04uIEVuY2xvc2UgYWxsIHRlbnNvciBvcGVyYXRpb25zIGluc2lkZSB0Zi50aWR5KCk6ICcgK1xuICAgICAgICAgICAgICAgICd0Zi50aWR5KCgpID0+IHtvcCgpOy4uLn0pOyB0byBhdm9pZCBtZW1vcnkgbGVha3MuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZS50cmFjay5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gRW5naW5lO1xufSgpKTtcbmV4cG9ydHMuRW5naW5lID0gRW5naW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5naW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRldmljZV91dGlsID0gcmVxdWlyZShcIi4vZGV2aWNlX3V0aWxcIik7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi9kb2NcIik7XG52YXIgZW5naW5lXzEgPSByZXF1aXJlKFwiLi9lbmdpbmVcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk5VTUJFUlwiXSA9IDBdID0gXCJOVU1CRVJcIjtcbiAgICBUeXBlW1R5cGVbXCJCT09MRUFOXCJdID0gMV0gPSBcIkJPT0xFQU5cIjtcbiAgICBUeXBlW1R5cGVbXCJTVFJJTkdcIl0gPSAyXSA9IFwiU1RSSU5HXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xuZXhwb3J0cy5VUkxfUFJPUEVSVElFUyA9IFtcbiAgICB7IG5hbWU6ICdERUJVRycsIHR5cGU6IFR5cGUuQk9PTEVBTiB9LCB7IG5hbWU6ICdJU19CUk9XU0VSJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nLCB0eXBlOiBUeXBlLk5VTUJFUiB9LFxuICAgIHsgbmFtZTogJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRScsIHR5cGU6IFR5cGUuQk9PTEVBTiB9LFxuICAgIHsgbmFtZTogJ1dFQkdMX1ZFUlNJT04nLCB0eXBlOiBUeXBlLk5VTUJFUiB9LFxuICAgIHsgbmFtZTogJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcsIHR5cGU6IFR5cGUuQk9PTEVBTiB9LCB7XG4gICAgICAgIG5hbWU6ICdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJyxcbiAgICAgICAgdHlwZTogVHlwZS5CT09MRUFOXG4gICAgfSxcbiAgICB7IG5hbWU6ICdCQUNLRU5EJywgdHlwZTogVHlwZS5TVFJJTkcgfVxuXTtcbmZ1bmN0aW9uIGhhc0V4dGVuc2lvbihnbCwgZXh0ZW5zaW9uTmFtZSkge1xuICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7XG4gICAgcmV0dXJuIGV4dCAhPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDAgfHwgIWV4cG9ydHMuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBXZWJHTCByZW5kZXJpbmcgY29udGV4dCwgV2ViR0wgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICAgIHZhciB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gKHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fFxuICAgICAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKSk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xufVxuZnVuY3Rpb24gbG9zZUNvbnRleHQoZ2wpIHtcbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbG9zZUNvbnRleHRFeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgICAgICBpZiAobG9zZUNvbnRleHRFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gV0VCR0xfbG9zZV9jb250ZXh0IG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXZWJHTFZlcnNpb25FbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIHZhciBnbCA9IGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFdlYkdMRGlzam9pbnRRdWVyeVRpbWVyVmVyc2lvbih3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgcXVlcnlUaW1lclZlcnNpb247XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgaWYgKGhhc0V4dGVuc2lvbihnbCwgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKSAmJlxuICAgICAgICB3ZWJHTFZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgcXVlcnlUaW1lclZlcnNpb24gPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXNFeHRlbnNpb24oZ2wsICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknKSkge1xuICAgICAgICBxdWVyeVRpbWVyVmVyc2lvbiA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBxdWVyeVRpbWVyVmVyc2lvbiA9IDA7XG4gICAgfVxuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5VGltZXJWZXJzaW9uO1xufVxuZnVuY3Rpb24gaXNGbG9hdFRleHR1cmVSZWFkUGl4ZWxzRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICBpZiAoIWhhc0V4dGVuc2lvbihnbCwgJ09FU190ZXh0dXJlX2Zsb2F0JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNFeHRlbnNpb24oZ2wsICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIHZhciBpbnRlcm5hbEZvcm1hdCA9IHdlYkdMVmVyc2lvbiA9PT0gMiA/IGdsLlJHQkEzMkYgOiBnbC5SR0JBO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIHZhciBmcmFtZUJ1ZmZlckNvbXBsZXRlID0gKGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCAxLCAxLCBnbC5SR0JBLCBnbC5GTE9BVCwgbmV3IEZsb2F0MzJBcnJheSg0KSk7XG4gICAgdmFyIHJlYWRQaXhlbHNOb0Vycm9yID0gZ2wuZ2V0RXJyb3IoKSA9PT0gZ2wuTk9fRVJST1I7XG4gICAgbG9zZUNvbnRleHQoZ2wpO1xuICAgIHJldHVybiBmcmFtZUJ1ZmZlckNvbXBsZXRlICYmIHJlYWRQaXhlbHNOb0Vycm9yO1xufVxuZnVuY3Rpb24gaXNXZWJHTEdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbkVuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAod2ViR0xWZXJzaW9uICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgdmFyIGlzRW5hYmxlZCA9IGhhc0V4dGVuc2lvbihnbCwgJ1dFQkdMX2dldF9idWZmZXJfc3ViX2RhdGFfYXN5bmMnKTtcbiAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgcmV0dXJuIGlzRW5hYmxlZDtcbn1cbnZhciBFbnZpcm9ubWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW52aXJvbm1lbnQoZmVhdHVyZXMpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0ge307XG4gICAgICAgIGlmIChmZWF0dXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0KCdERUJVRycpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsICcgK1xuICAgICAgICAgICAgICAgICdiZSBkb3dubG9hZGVkIHRvIENQVSBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gJyArXG4gICAgICAgICAgICAgICAgJ1RoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVudmlyb25tZW50LnNldEJhY2tlbmQgPSBmdW5jdGlvbiAoYmFja2VuZFR5cGUsIHNhZmVNb2RlKSB7XG4gICAgICAgIGlmIChzYWZlTW9kZSA9PT0gdm9pZCAwKSB7IHNhZmVNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKCEoYmFja2VuZFR5cGUgaW4gZXhwb3J0cy5FTlYucmVnaXN0cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kIHR5cGUgJ1wiICsgYmFja2VuZFR5cGUgKyBcIicgbm90IGZvdW5kIGluIHJlZ2lzdHJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMuRU5WLmluaXRCYWNrZW5kKGJhY2tlbmRUeXBlLCBzYWZlTW9kZSk7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5nZXRCYWNrZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBleHBvcnRzLkVOVi5pbml0RGVmYXVsdEJhY2tlbmQoKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuRU5WLmN1cnJlbnRCYWNrZW5kO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQuZGlzcG9zZVZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXhwb3J0cy5FTlYuZW5naW5lLmRpc3Bvc2VWYXJpYWJsZXMoKTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50Lm1lbW9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuRU5WLmVuZ2luZS5tZW1vcnkoKTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmVhdHVyZSBpbiB0aGlzLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1tmZWF0dXJlXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZlYXR1cmVzW2ZlYXR1cmVdID0gdGhpcy5ldmFsdWF0ZUZlYXR1cmUoZmVhdHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzW2ZlYXR1cmVdO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChmZWF0dXJlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZlYXR1cmVzW2ZlYXR1cmVdID0gdmFsdWU7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0QmVzdEJhY2tlbmRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGJhY2tlbmQgZm91bmQgaW4gcmVnaXN0cnkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvcnRlZEJhY2tlbmRzID0gT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIGVudHJ5OiBfdGhpcy5yZWdpc3RyeVtuYW1lXSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmVudHJ5LnByaW9yaXR5IC0gYS5lbnRyeS5wcmlvcml0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzb3J0ZWRCYWNrZW5kc1swXS5uYW1lO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmV2YWx1YXRlRmVhdHVyZSA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlID09PSAnREVCVUcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ0lTX0JST1dTRVInKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ0lTX05PREUnKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdCQUNLRU5EJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVzdEJhY2tlbmRUeXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykge1xuICAgICAgICAgICAgdmFyIHdlYkdMVmVyc2lvbiA9IHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJyk7XG4gICAgICAgICAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uKHdlYkdMVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA+IDAgJiZcbiAgICAgICAgICAgICAgICAhZGV2aWNlX3V0aWwuaXNNb2JpbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfVkVSU0lPTicpIHtcbiAgICAgICAgICAgIGlmIChpc1dlYkdMVmVyc2lvbkVuYWJsZWQoMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzV2ViR0xWZXJzaW9uRW5hYmxlZCgxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkKHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykge1xuICAgICAgICAgICAgcmV0dXJuIGlzV2ViR0xHZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb25FbmFibGVkKHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZmVhdHVyZSBcIiArIGZlYXR1cmUgKyBcIi5cIik7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuc2V0RmVhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gZ2V0RmVhdHVyZXNGcm9tVVJMKCk7XG4gICAgICAgIGlmICh0aGlzLmdsb2JhbEVuZ2luZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbEVuZ2luZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5pbml0QmFja2VuZCA9IGZ1bmN0aW9uIChiYWNrZW5kVHlwZSwgc2FmZU1vZGUpIHtcbiAgICAgICAgaWYgKHNhZmVNb2RlID09PSB2b2lkIDApIHsgc2FmZU1vZGUgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmN1cnJlbnRCYWNrZW5kID0gYmFja2VuZFR5cGU7XG4gICAgICAgIHZhciBiYWNrZW5kID0gZXhwb3J0cy5FTlYuZmluZEJhY2tlbmQoYmFja2VuZFR5cGUpO1xuICAgICAgICB0aGlzLmdsb2JhbEVuZ2luZSA9IG5ldyBlbmdpbmVfMS5FbmdpbmUoYmFja2VuZCwgc2FmZU1vZGUpO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmZpbmRCYWNrZW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiB0aGlzLnJlZ2lzdHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnlbbmFtZV0uYmFja2VuZDtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5yZWdpc3RlckJhY2tlbmQgPSBmdW5jdGlvbiAobmFtZSwgZmFjdG9yeSwgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSAxOyB9XG4gICAgICAgIGlmIChuYW1lIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCIgYmFja2VuZCB3YXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYmFja2VuZCA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cnlbbmFtZV0gPSB7IGJhY2tlbmQ6IGJhY2tlbmQsIHByaW9yaXR5OiBwcmlvcml0eSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmVnaXN0cmF0aW9uIG9mIGJhY2tlbmQgXCIgKyBuYW1lICsgXCIgZmFpbGVkXCIpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5yZW1vdmVCYWNrZW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiB0aGlzLnJlZ2lzdHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyBcIiBiYWNrZW5kIG5vdCBmb3VuZCBpbiByZWdpc3RyeVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdHJ5W25hbWVdLmJhY2tlbmQuZGlzcG9zZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5yZWdpc3RyeVtuYW1lXTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnZpcm9ubWVudC5wcm90b3R5cGUsIFwiZW5naW5lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREZWZhdWx0QmFja2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsRW5naW5lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuaW5pdERlZmF1bHRCYWNrZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5nbG9iYWxFbmdpbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbml0QmFja2VuZChleHBvcnRzLkVOVi5nZXQoJ0JBQ0tFTkQnKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ0Vudmlyb25tZW50JyB9KVxuICAgIF0sIEVudmlyb25tZW50LCBcInNldEJhY2tlbmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdFbnZpcm9ubWVudCcgfSlcbiAgICBdLCBFbnZpcm9ubWVudCwgXCJnZXRCYWNrZW5kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnRW52aXJvbm1lbnQnIH0pXG4gICAgXSwgRW52aXJvbm1lbnQsIFwiZGlzcG9zZVZhcmlhYmxlc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1BlcmZvcm1hbmNlJywgc3ViaGVhZGluZzogJ01lbW9yeScgfSlcbiAgICBdLCBFbnZpcm9ubWVudCwgXCJtZW1vcnlcIiwgbnVsbCk7XG4gICAgcmV0dXJuIEVudmlyb25tZW50O1xufSgpKTtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBFbnZpcm9ubWVudDtcbnZhciBURU5TT1JGTE9XSlNfRkxBR1NfUFJFRklYID0gJ3RmanNmbGFncyc7XG5mdW5jdGlvbiBnZXRGZWF0dXJlc0Zyb21VUkwoKSB7XG4gICAgdmFyIGZlYXR1cmVzID0ge307XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cubG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG4gICAgdmFyIHVybFBhcmFtcyA9IHV0aWwuZ2V0UXVlcnlQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgaWYgKFRFTlNPUkZMT1dKU19GTEFHU19QUkVGSVggaW4gdXJsUGFyYW1zKSB7XG4gICAgICAgIHZhciB1cmxGbGFnc18xID0ge307XG4gICAgICAgIHZhciBrZXlWYWx1ZXMgPSB1cmxQYXJhbXNbVEVOU09SRkxPV0pTX0ZMQUdTX1BSRUZJWF0uc3BsaXQoJywnKTtcbiAgICAgICAga2V5VmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKGtleVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBrZXlWYWx1ZS5zcGxpdCgnOicpLCBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgIHVybEZsYWdzXzFba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZXhwb3J0cy5VUkxfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uICh1cmxQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKHVybFByb3BlcnR5Lm5hbWUgaW4gdXJsRmxhZ3NfMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiICsgdXJsUHJvcGVydHkubmFtZSArIFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXSkpO1xuICAgICAgICAgICAgICAgIGlmICh1cmxQcm9wZXJ0eS50eXBlID09PSBUeXBlLk5VTUJFUikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1t1cmxQcm9wZXJ0eS5uYW1lXSA9ICt1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1cmxQcm9wZXJ0eS50eXBlID09PSBUeXBlLkJPT0xFQU4pIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXNbdXJsUHJvcGVydHkubmFtZV0gPSB1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdID09PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVybFByb3BlcnR5LnR5cGUgPT09IFR5cGUuU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzW3VybFByb3BlcnR5Lm5hbWVdID0gdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gVVJMIHBhcmFtOiBcIiArIHVybFByb3BlcnR5Lm5hbWUgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsTmFtZXNwYWNlKCkge1xuICAgIHZhciBucztcbiAgICBpZiAodHlwZW9mICh3aW5kb3cpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBucyA9IHdpbmRvdztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChnbG9iYWwpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBucyA9IGdsb2JhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSBnbG9iYWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBucztcbn1cbmZ1bmN0aW9uIGdldE9yTWFrZUVudmlyb25tZW50KCkge1xuICAgIHZhciBucyA9IGdldEdsb2JhbE5hbWVzcGFjZSgpO1xuICAgIG5zLkVOViA9IG5zLkVOViB8fCBuZXcgRW52aXJvbm1lbnQoZ2V0RmVhdHVyZXNGcm9tVVJMKCkpO1xuICAgIHJldHVybiBucy5FTlY7XG59XG5leHBvcnRzLkVOViA9IGdldE9yTWFrZUVudmlyb25tZW50KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZpcm9ubWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFkaWVudHNfMSA9IHJlcXVpcmUoXCIuL2dyYWRpZW50c1wiKTtcbnZhciB0cmFja2luZ18xID0gcmVxdWlyZShcIi4vdHJhY2tpbmdcIik7XG5leHBvcnRzLnRpZHkgPSB0cmFja2luZ18xLlRyYWNraW5nLnRpZHk7XG5leHBvcnRzLmtlZXAgPSB0cmFja2luZ18xLlRyYWNraW5nLmtlZXA7XG5leHBvcnRzLmRpc3Bvc2UgPSB0cmFja2luZ18xLlRyYWNraW5nLmRpc3Bvc2U7XG5leHBvcnRzLnRpbWUgPSB0cmFja2luZ18xLlRyYWNraW5nLnRpbWU7XG5leHBvcnRzLmdyYWQgPSBncmFkaWVudHNfMS5HcmFkaWVudHMuZ3JhZDtcbmV4cG9ydHMudmFsdWVBbmRHcmFkID0gZ3JhZGllbnRzXzEuR3JhZGllbnRzLnZhbHVlQW5kR3JhZDtcbmV4cG9ydHMuZ3JhZHMgPSBncmFkaWVudHNfMS5HcmFkaWVudHMuZ3JhZHM7XG5leHBvcnRzLnZhbHVlQW5kR3JhZHMgPSBncmFkaWVudHNfMS5HcmFkaWVudHMudmFsdWVBbmRHcmFkcztcbmV4cG9ydHMudmFyaWFibGVHcmFkcyA9IGdyYWRpZW50c18xLkdyYWRpZW50cy52YXJpYWJsZUdyYWRzO1xuZXhwb3J0cy5jdXN0b21HcmFkID0gZ3JhZGllbnRzXzEuR3JhZGllbnRzLmN1c3RvbUdyYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4vdGVuc29yXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIEdyYWRpZW50cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhZGllbnRzKCkge1xuICAgIH1cbiAgICBHcmFkaWVudHMuZ3JhZFNjb3BlID0gZnVuY3Rpb24gKG5hbWVPclNjb3BlRm4sIHNjb3BlRm4pIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbHNfMS50aWR5KG5hbWVPclNjb3BlRm4sIHNjb3BlRm4sIHRydWUpO1xuICAgIH07XG4gICAgR3JhZGllbnRzLmdyYWQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzRnVuY3Rpb24oZiksICdUaGUgZiBwYXNzZWQgaW4gZ3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBkeSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoeCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSB4IHBhc3NlZCBpbiBncmFkKGYpKHgpIG11c3QgYmUgYSB0ZW5zb3InKTtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGR5ID09IG51bGwgfHwgZHkgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgZHkgcGFzc2VkIGluIGdyYWQoZikoeCwgZHkpIG11c3QgYmUgYSB0ZW5zb3InKTtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmdyYWRpZW50cyhmdW5jdGlvbiAoKSB7IHJldHVybiBmKHgpOyB9LCBbeF0sIGR5KSwgdmFsdWUgPSBfYS52YWx1ZSwgZ3JhZHMgPSBfYS5ncmFkcztcbiAgICAgICAgICAgICAgICBpZiAoZHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHZhbHVlLnNoYXBlLCBkeS5zaGFwZSwgJ1RoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZChmKSh4LCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuZWQgYnkgZih4KScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGVja0dyYWRzKGdyYWRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JhZHNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEdyYWRpZW50cy5ncmFkcyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiBncmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzLCBkeSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcjsgfSksICdUaGUgYXJncyBwYXNzZWQgaW4gZ3JhZHMoZikoYXJncykgbXVzdCBiZSBhbiBhcnJheSBvZiB0ZW5zb3JzJyk7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChkeSA9PSBudWxsIHx8IGR5IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yLCAnVGhlIGR5IHBhc3NlZCBpbiBncmFkcyhmKShhcmdzLCBkeSkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZ3JhZGllbnRzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYuYXBwbHkodm9pZCAwLCBhcmdzKTsgfSwgYXJncywgZHkpLCB2YWx1ZSA9IF9hLnZhbHVlLCBncmFkcyA9IF9hLmdyYWRzO1xuICAgICAgICAgICAgICAgIGlmIChkeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2godmFsdWUuc2hhcGUsIGR5LnNoYXBlLCAnVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrR3JhZHMoZ3JhZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBncmFkcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgR3JhZGllbnRzLnZhbHVlQW5kR3JhZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgZHkpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHggaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgeCBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgpIG11c3QgYmUgYSB0ZW5zb3InKTtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGR5ID09IG51bGwgfHwgZHkgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSh4LCBkeSkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgdmFyIF9hID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmdyYWRpZW50cyhmdW5jdGlvbiAoKSB7IHJldHVybiBmKHgpOyB9LCBbeF0sIGR5KSwgZ3JhZHMgPSBfYS5ncmFkcywgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIGNoZWNrR3JhZHMoZ3JhZHMpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZ3JhZDogZ3JhZHNbMF0sIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgR3JhZGllbnRzLnZhbHVlQW5kR3JhZHMgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzRnVuY3Rpb24oZiksICdUaGUgZiBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzLCBkeSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcjsgfSksICdUaGUgYXJncyBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzKSBtdXN0IGJlIGFycmF5IG9mIHRlbnNvcnMnKTtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGR5ID09IG51bGwgfHwgZHkgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncywgZHkpIG11c3QgYmUgYSB0ZW5zb3InKTtcbiAgICAgICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZ3JhZGllbnRzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYuYXBwbHkodm9pZCAwLCBhcmdzKTsgfSwgYXJncywgZHkpO1xuICAgICAgICAgICAgaWYgKGR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHJlcy52YWx1ZS5zaGFwZSwgZHkuc2hhcGUsICdUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0dyYWRzKHJlcy5ncmFkcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgR3JhZGllbnRzLnZhcmlhYmxlR3JhZHMgPSBmdW5jdGlvbiAoZiwgdmFyTGlzdCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzRnVuY3Rpb24oZiksICdUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodmFyTGlzdCA9PSBudWxsIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhckxpc3QpICYmIHZhckxpc3QuZXZlcnkoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgaW5zdGFuY2VvZiB0ZW5zb3JfMS5WYXJpYWJsZTsgfSksICdUaGUgdmFyTGlzdCBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmLCB2YXJMaXN0KSBtdXN0IGJlIGFuIGFycmF5ICcgK1xuICAgICAgICAgICAgJ29mIHZhcmlhYmxlcycpO1xuICAgICAgICBpZiAodmFyTGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXJMaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciB2YXJOYW1lIGluIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyTGlzdC5wdXNoKGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3Zhck5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWxWYXJDb3VudCA9IHZhckxpc3QubGVuZ3RoO1xuICAgICAgICB2YXJMaXN0ID0gdmFyTGlzdC5maWx0ZXIoZnVuY3Rpb24gKHZhcmlhYmxlKSB7IHJldHVybiB2YXJpYWJsZS50cmFpbmFibGU7IH0pO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJMaXN0Lmxlbmd0aCA+IDAsIFwidmFyaWFibGVHcmFkcygpIGV4cGVjdHMgYXQgbGVhc3Qgb25lIG9mIHRoZSBpbnB1dCB2YXJpYWJsZXMgdG8gYmUgXCIgK1xuICAgICAgICAgICAgKFwidHJhaW5hYmxlLCBidXQgbm9uZSBvZiB0aGUgXCIgKyBvcmlnaW5hbFZhckNvdW50ICsgXCIgdmFyaWFibGVzIGlzIFwiKSArXG4gICAgICAgICAgICBcInRyYWluYWJsZS5cIik7XG4gICAgICAgIHZhciBhbGxvd05vR3JhZGllbnRzID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmdyYWRpZW50cyhmLCB2YXJMaXN0LCBudWxsLCBhbGxvd05vR3JhZGllbnRzKSwgdmFsdWUgPSBfYS52YWx1ZSwgZ3JhZHMgPSBfYS5ncmFkcztcbiAgICAgICAgdXRpbC5hc3NlcnQoZ3JhZHMuc29tZShmdW5jdGlvbiAoZykgeyByZXR1cm4gZyAhPSBudWxsOyB9KSwgJ0Nhbm5vdCBmaW5kIGEgY29ubmVjdGlvbiBiZXR3ZWVuIGFueSB2YXJpYWJsZSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgJyArXG4gICAgICAgICAgICAnbG9zcyBmdW5jdGlvbiB5PWYoeCkuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIG9wZXJhdGlvbnMgdGhhdCB1c2UgJyArXG4gICAgICAgICAgICAndmFyaWFibGVzIGFyZSBpbnNpZGUgdGhlIGZ1bmN0aW9uIGYgcGFzc2VkIHRvIG1pbmltaXplKCkuJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhbHVlLnJhbmsgPT09IDAsIFwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCByZXR1cm4gYSBzY2FsYXIsIGJ1dCBpdCBcIiArXG4gICAgICAgICAgICAoXCJyZXR1cm5lZCBhIHJhbmstXCIgKyB2YWx1ZS5yYW5rICsgXCIgdGVuc29yXCIpKTtcbiAgICAgICAgdmFyIG5hbWVkR3JhZHMgPSB7fTtcbiAgICAgICAgdmFyTGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICBpZiAoZ3JhZHNbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5hbWVkR3JhZHNbdi5uYW1lXSA9IGdyYWRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBncmFkczogbmFtZWRHcmFkcyB9O1xuICAgIH07XG4gICAgR3JhZGllbnRzLmN1c3RvbUdyYWQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmN1c3RvbUdyYWQoZik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0dyYWRpZW50cycgfSlcbiAgICBdLCBHcmFkaWVudHMsIFwiZ3JhZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0dyYWRpZW50cycgfSlcbiAgICBdLCBHcmFkaWVudHMsIFwiZ3JhZHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdHcmFkaWVudHMnIH0pXG4gICAgXSwgR3JhZGllbnRzLCBcInZhbHVlQW5kR3JhZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0dyYWRpZW50cycgfSlcbiAgICBdLCBHcmFkaWVudHMsIFwidmFsdWVBbmRHcmFkc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0dyYWRpZW50cycgfSlcbiAgICBdLCBHcmFkaWVudHMsIFwidmFyaWFibGVHcmFkc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0dyYWRpZW50cycgfSlcbiAgICBdLCBHcmFkaWVudHMsIFwiY3VzdG9tR3JhZFwiLCBudWxsKTtcbiAgICByZXR1cm4gR3JhZGllbnRzO1xufSgpKTtcbmV4cG9ydHMuR3JhZGllbnRzID0gR3JhZGllbnRzO1xuZnVuY3Rpb24gY2hlY2tHcmFkcyhncmFkcykge1xuICAgIHZhciBudW1OdWxsR3JhZGllbnRzID0gZ3JhZHMuZmlsdGVyKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnID09IG51bGw7IH0pLmxlbmd0aDtcbiAgICBpZiAobnVtTnVsbEdyYWRpZW50cyA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgb2YgeT1mKHgpIHdpdGggcmVzcGVjdCB0byB4LiBNYWtlIHN1cmUgdGhhdFxcbiAgICB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggdG8geS5cIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhZGllbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnJlcXVpcmUoXCIuL2tlcm5lbHMvYmFja2VuZF93ZWJnbFwiKTtcbnJlcXVpcmUoXCIuL2tlcm5lbHMvYmFja2VuZF9jcHVcIik7XG52YXIgYnJvd3Nlcl91dGlsXzEgPSByZXF1aXJlKFwiLi9icm93c2VyX3V0aWxcIik7XG52YXIgZW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbmV4cG9ydHMuZW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudDtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgaW8gPSByZXF1aXJlKFwiLi9pby9pb1wiKTtcbmV4cG9ydHMuaW8gPSBpbztcbnZhciBzZXJpYWxpemF0aW9uID0gcmVxdWlyZShcIi4vc2VyaWFsaXphdGlvblwiKTtcbmV4cG9ydHMuc2VyaWFsaXphdGlvbiA9IHNlcmlhbGl6YXRpb247XG52YXIgdGVzdF91dGlsID0gcmVxdWlyZShcIi4vdGVzdF91dGlsXCIpO1xuZXhwb3J0cy50ZXN0X3V0aWwgPSB0ZXN0X3V0aWw7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5leHBvcnRzLnV0aWwgPSB1dGlsO1xudmFyIHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5leHBvcnRzLnZlcnNpb25fY29yZSA9IHZlcnNpb25fMS52ZXJzaW9uO1xudmFyIHdlYmdsID0gcmVxdWlyZShcIi4vd2ViZ2xcIik7XG5leHBvcnRzLndlYmdsID0gd2ViZ2w7XG52YXIgYWRhZGVsdGFfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYWRlbHRhX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhZGVsdGFPcHRpbWl6ZXIgPSBhZGFkZWx0YV9vcHRpbWl6ZXJfMS5BZGFkZWx0YU9wdGltaXplcjtcbnZhciBhZGFncmFkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9hZGFncmFkX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhZ3JhZE9wdGltaXplciA9IGFkYWdyYWRfb3B0aW1pemVyXzEuQWRhZ3JhZE9wdGltaXplcjtcbnZhciBhZGFtX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9hZGFtX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhbU9wdGltaXplciA9IGFkYW1fb3B0aW1pemVyXzEuQWRhbU9wdGltaXplcjtcbnZhciBhZGFtYXhfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYW1heF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYW1heE9wdGltaXplciA9IGFkYW1heF9vcHRpbWl6ZXJfMS5BZGFtYXhPcHRpbWl6ZXI7XG52YXIgbW9tZW50dW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL21vbWVudHVtX29wdGltaXplclwiKTtcbmV4cG9ydHMuTW9tZW50dW1PcHRpbWl6ZXIgPSBtb21lbnR1bV9vcHRpbWl6ZXJfMS5Nb21lbnR1bU9wdGltaXplcjtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5PcHRpbWl6ZXIgPSBvcHRpbWl6ZXJfMS5PcHRpbWl6ZXI7XG52YXIgcm1zcHJvcF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLlJNU1Byb3BPcHRpbWl6ZXIgPSBybXNwcm9wX29wdGltaXplcl8xLlJNU1Byb3BPcHRpbWl6ZXI7XG52YXIgc2dkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4vdGVuc29yXCIpO1xuZXhwb3J0cy5UZW5zb3IgPSB0ZW5zb3JfMS5UZW5zb3I7XG5leHBvcnRzLlRlbnNvckJ1ZmZlciA9IHRlbnNvcl8xLlRlbnNvckJ1ZmZlcjtcbmV4cG9ydHMudmFyaWFibGUgPSB0ZW5zb3JfMS52YXJpYWJsZTtcbmV4cG9ydHMuVmFyaWFibGUgPSB0ZW5zb3JfMS5WYXJpYWJsZTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5leHBvcnRzLlJhbmsgPSB0eXBlc18xLlJhbms7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9vcHMvb3BzXCIpKTtcbnZhciBsb3NzX29wc18xID0gcmVxdWlyZShcIi4vb3BzL2xvc3Nfb3BzXCIpO1xuZXhwb3J0cy5SZWR1Y3Rpb24gPSBsb3NzX29wc18xLlJlZHVjdGlvbjtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYWluXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2dsb2JhbHNcIikpO1xudmFyIGVudmlyb25tZW50XzIgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbmV4cG9ydHMuRU5WID0gZW52aXJvbm1lbnRfMi5FTlY7XG5leHBvcnRzLkVudmlyb25tZW50ID0gZW52aXJvbm1lbnRfMi5FbnZpcm9ubWVudDtcbmV4cG9ydHMuc2V0QmFja2VuZCA9IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQuc2V0QmFja2VuZDtcbmV4cG9ydHMuZ2V0QmFja2VuZCA9IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQuZ2V0QmFja2VuZDtcbmV4cG9ydHMuZGlzcG9zZVZhcmlhYmxlcyA9IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQuZGlzcG9zZVZhcmlhYmxlcztcbmV4cG9ydHMubWVtb3J5ID0gZW52aXJvbm1lbnRfMS5FbnZpcm9ubWVudC5tZW1vcnk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi9kb2NcIik7XG5leHBvcnRzLmRvYyA9IGRvY18xLmRvYztcbmV4cG9ydHMubmV4dEZyYW1lID0gYnJvd3Nlcl91dGlsXzEuQnJvd3NlclV0aWwubmV4dEZyYW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGlvX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9pb191dGlsc1wiKTtcbnZhciByb3V0ZXJfcmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3JvdXRlcl9yZWdpc3RyeVwiKTtcbnZhciBERUZBVUxUX0ZJTEVfTkFNRV9QUkVGSVggPSAnbW9kZWwnO1xudmFyIERFRkFVTFRfSlNPTl9FWFRFTlNJT05fTkFNRSA9ICcuanNvbic7XG52YXIgREVGQVVMVF9XRUlHSFRfREFUQV9FWFRFTlNJT05fTkFNRSA9ICcud2VpZ2h0cy5iaW4nO1xudmFyIEJyb3dzZXJEb3dubG9hZHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJEb3dubG9hZHMoZmlsZU5hbWVQcmVmaXgpIHtcbiAgICAgICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmlnZ2VyRG93bmxvYWRzKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgICAgICAgICAnaXMgbm90IGEgYnJvd3Nlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZU5hbWVQcmVmaXguc3RhcnRzV2l0aChCcm93c2VyRG93bmxvYWRzLlVSTF9TQ0hFTUUpKSB7XG4gICAgICAgICAgICBmaWxlTmFtZVByZWZpeCA9IGZpbGVOYW1lUHJlZml4LnNsaWNlKEJyb3dzZXJEb3dubG9hZHMuVVJMX1NDSEVNRS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlTmFtZVByZWZpeCA9PSBudWxsIHx8IGZpbGVOYW1lUHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZmlsZU5hbWVQcmVmaXggPSBERUZBVUxUX0ZJTEVfTkFNRV9QUkVGSVg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbFRvcG9sb2d5RmlsZU5hbWUgPSBmaWxlTmFtZVByZWZpeCArIERFRkFVTFRfSlNPTl9FWFRFTlNJT05fTkFNRTtcbiAgICAgICAgdGhpcy53ZWlnaHREYXRhRmlsZU5hbWUgPVxuICAgICAgICAgICAgZmlsZU5hbWVQcmVmaXggKyBERUZBVUxUX1dFSUdIVF9EQVRBX0VYVEVOU0lPTl9OQU1FO1xuICAgIH1cbiAgICBCcm93c2VyRG93bmxvYWRzLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKG1vZGVsQXJ0aWZhY3RzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRzVVJMLCB3ZWlnaHRzTWFuaWZlc3QsIG1vZGVsVG9wb2xvZ3lBbmRXZWlnaHRNYW5pZmVzdCwgbW9kZWxUb3BvbG9neUFuZFdlaWdodE1hbmlmZXN0VVJMLCBqc29uQW5jaG9yLCB3ZWlnaHREYXRhQW5jaG9yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHdlaWdodHNVUkwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbbW9kZWxBcnRpZmFjdHMud2VpZ2h0RGF0YV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb3dubG9hZFRyaWdnZXIuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luIGJpbmFyeSBmb3JtYXRzIHlldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdCA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsnLi8nICsgdGhpcy53ZWlnaHREYXRhRmlsZU5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHM6IG1vZGVsQXJ0aWZhY3RzLndlaWdodFNwZWNzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb3BvbG9neUFuZFdlaWdodE1hbmlmZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxUb3BvbG9neTogbW9kZWxBcnRpZmFjdHMubW9kZWxUb3BvbG9neSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdDogd2VpZ2h0c01hbmlmZXN0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9wb2xvZ3lBbmRXZWlnaHRNYW5pZmVzdFVSTCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShtb2RlbFRvcG9sb2d5QW5kV2VpZ2h0TWFuaWZlc3QpXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSkpO1xuICAgICAgICAgICAgICAgICAgICBqc29uQW5jaG9yID0gdGhpcy5qc29uQW5jaG9yID09IG51bGwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5qc29uQW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICBqc29uQW5jaG9yLmRvd25sb2FkID0gdGhpcy5tb2RlbFRvcG9sb2d5RmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGpzb25BbmNob3IuaHJlZiA9IG1vZGVsVG9wb2xvZ3lBbmRXZWlnaHRNYW5pZmVzdFVSTDtcbiAgICAgICAgICAgICAgICAgICAganNvbkFuY2hvci5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxBcnRpZmFjdHMud2VpZ2h0RGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHREYXRhQW5jaG9yID0gdGhpcy53ZWlnaHREYXRhQW5jaG9yID09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWlnaHREYXRhQW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RGF0YUFuY2hvci5kb3dubG9hZCA9IHRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RGF0YUFuY2hvci5ocmVmID0gd2VpZ2h0c1VSTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodERhdGFBbmNob3IuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgbW9kZWxBcnRpZmFjdHNJbmZvOiBpb191dGlsc18xLmdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04obW9kZWxBcnRpZmFjdHMpIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnJvd3NlckRvd25sb2Fkcy5VUkxfU0NIRU1FID0gJ2Rvd25sb2FkczovLyc7XG4gICAgcmV0dXJuIEJyb3dzZXJEb3dubG9hZHM7XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VyRG93bmxvYWRzID0gQnJvd3NlckRvd25sb2FkcztcbnZhciBCcm93c2VyRmlsZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJGaWxlcyhmaWxlcykge1xuICAgICAgICBpZiAoZmlsZXMgPT0gbnVsbCB8fCBmaWxlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgYnJvd3NlckZpbGVzLCBhdCBsZWFzdCAxIGZpbGUgaXMgcmVxdWlyZWQsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgcmVjZWl2ZWQgXCIgKyBmaWxlcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsZXMgPSBmaWxlcztcbiAgICB9XG4gICAgQnJvd3NlckZpbGVzLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGpzb25GaWxlLCB3ZWlnaHRGaWxlcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBqc29uRmlsZSA9IHRoaXMuZmlsZXNbMF07XG4gICAgICAgICAgICAgICAgd2VpZ2h0RmlsZXMgPSB0aGlzLmZpbGVzLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpzb25SZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAganNvblJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxKU09OID0gSlNPTi5wYXJzZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxUb3BvbG9neSA9IG1vZGVsSlNPTi5tb2RlbFRvcG9sb2d5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFRvcG9sb2d5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIm1vZGVsVG9wb2xvZ3kgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIgKyBqc29uRmlsZS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlaWdodEZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgbW9kZWxUb3BvbG9neTogbW9kZWxUb3BvbG9neSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodHNNYW5pZmVzdCA9IG1vZGVsSlNPTi53ZWlnaHRzTWFuaWZlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlaWdodHNNYW5pZmVzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ3ZWlnaHRNYW5pZmVzdCBmaWVsZCBpcyBtaXNzaW5nIGZyb20gZmlsZSBcIiArIGpzb25GaWxlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aFRvRmlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoVG9GaWxlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcyh3ZWlnaHRzTWFuaWZlc3QsIHdlaWdodEZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0U3BlY3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyRmlsZUJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzTWFuaWZlc3QuZm9yRWFjaChmdW5jdGlvbiAod2VpZ2h0c0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNHcm91cC5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyRmlsZUJ1ZmZlcnMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodFNwZWNzLnB1c2guYXBwbHkod2VpZ2h0U3BlY3MsIHdlaWdodHNHcm91cC53ZWlnaHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzTWFuaWZlc3QuZm9yRWFjaChmdW5jdGlvbiAod2VpZ2h0c0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNHcm91cC5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0RmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRGaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHREYXRhID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXRocy5pbmRleE9mKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlckZpbGVCdWZmZXJzW2luZGV4XSA9IHdlaWdodERhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlckZpbGVCdWZmZXJzLmluZGV4T2YobnVsbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxUb3BvbG9neTogbW9kZWxUb3BvbG9neSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodFNwZWNzOiB3ZWlnaHRTcGVjcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodERhdGE6IGlvX3V0aWxzXzEuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMocGVyRmlsZUJ1ZmZlcnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RmlsZVJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIHdlaWdodHMgZGF0YSBmcm9tIGZpbGUgb2YgcGF0aCAnXCIgKyBwYXRoICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihwYXRoVG9GaWxlW3BhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAganNvblJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIHJlYWQgbW9kZWwgdG9wb2xvZ3kgYW5kIHdlaWdodHMgbWFuaWZlc3QgSlNPTiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImZyb20gZmlsZSAnXCIgKyBqc29uRmlsZS5uYW1lICsgXCInLiBCcm93c2VyRmlsZXMgc3VwcG9ydHMgbG9hZGluZyBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIktlcmFzLXN0eWxlIHRmLk1vZGVsIGFydGlmYWN0cyBvbmx5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAganNvblJlYWRlci5yZWFkQXNUZXh0KGpzb25GaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnJvd3NlckZpbGVzLnByb3RvdHlwZS5jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXMgPSBmdW5jdGlvbiAobWFuaWZlc3QsIGZpbGVzKSB7XG4gICAgICAgIHZhciBiYXNlbmFtZXMgPSBbXTtcbiAgICAgICAgdmFyIGZpbGVOYW1lcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gaW9fdXRpbHNfMS5iYXNlbmFtZShmaWxlLm5hbWUpOyB9KTtcbiAgICAgICAgdmFyIHBhdGhUb0ZpbGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBtYW5pZmVzdF8xID0gbWFuaWZlc3Q7IF9pIDwgbWFuaWZlc3RfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IG1hbmlmZXN0XzFbX2ldO1xuICAgICAgICAgICAgZ3JvdXAucGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoQmFzZW5hbWUgPSBpb191dGlsc18xLmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlbmFtZXMuaW5kZXhPZihwYXRoQmFzZW5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgZmlsZSBiYXNlbmFtZSBmb3VuZCBpbiB3ZWlnaHRzIG1hbmlmZXN0OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCInXCIgKyBwYXRoQmFzZW5hbWUgKyBcIidcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXNlbmFtZXMucHVzaChwYXRoQmFzZW5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZXMuaW5kZXhPZihwYXRoQmFzZW5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgZmlsZSB3aXRoIGJhc2VuYW1lICdcIiArIHBhdGhCYXNlbmFtZSArIFwiJyBpcyBub3QgcHJvdmlkZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aFRvRmlsZVtwYXRoXSA9IGZpbGVzW2ZpbGVOYW1lcy5pbmRleE9mKHBhdGhCYXNlbmFtZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlbmFtZXMubGVuZ3RoICE9PSBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZmlsZXMgaW4gd2VpZ2h0cyBtYW5pZmVzdCBcIiArXG4gICAgICAgICAgICAgICAgKFwiKFwiICsgYmFzZW5hbWVzLmxlbmd0aCArIFwiKSBhbmQgdGhlIG51bWJlciBvZiB3ZWlnaHQgZmlsZXMgcHJvdmlkZWQgXCIpICtcbiAgICAgICAgICAgICAgICAoXCIoXCIgKyBmaWxlcy5sZW5ndGggKyBcIikuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aFRvRmlsZTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyRmlsZXM7XG59KCkpO1xuZXhwb3J0cy5icm93c2VyRG93bmxvYWRzUm91dGVyID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdJU19CUk9XU0VSJykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoQnJvd3NlckRvd25sb2Fkcy5VUkxfU0NIRU1FKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJEb3dubG9hZHModXJsLnNsaWNlKEJyb3dzZXJEb3dubG9hZHMuVVJMX1NDSEVNRS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbnJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGV4cG9ydHMuYnJvd3NlckRvd25sb2Fkc1JvdXRlcik7XG5mdW5jdGlvbiBicm93c2VyRG93bmxvYWRzKGZpbGVOYW1lUHJlZml4KSB7XG4gICAgaWYgKGZpbGVOYW1lUHJlZml4ID09PSB2b2lkIDApIHsgZmlsZU5hbWVQcmVmaXggPSAnbW9kZWwnOyB9XG4gICAgcmV0dXJuIG5ldyBCcm93c2VyRG93bmxvYWRzKGZpbGVOYW1lUHJlZml4KTtcbn1cbmV4cG9ydHMuYnJvd3NlckRvd25sb2FkcyA9IGJyb3dzZXJEb3dubG9hZHM7XG5mdW5jdGlvbiBicm93c2VyRmlsZXMoZmlsZXMpIHtcbiAgICByZXR1cm4gbmV3IEJyb3dzZXJGaWxlcyhmaWxlcyk7XG59XG5leHBvcnRzLmJyb3dzZXJGaWxlcyA9IGJyb3dzZXJGaWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJfZmlsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGlvX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9pb191dGlsc1wiKTtcbnZhciByb3V0ZXJfcmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3JvdXRlcl9yZWdpc3RyeVwiKTtcbnZhciB3ZWlnaHRzX2xvYWRlcl8xID0gcmVxdWlyZShcIi4vd2VpZ2h0c19sb2FkZXJcIik7XG52YXIgQnJvd3NlckhUVFBSZXF1ZXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VySFRUUFJlcXVlc3QocGF0aCwgcmVxdWVzdEluaXQpIHtcbiAgICAgICAgdGhpcy5ERUZBVUxUX01FVEhPRCA9ICdQT1NUJztcbiAgICAgICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdicm93c2VySFRUUFJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZCBvdXRzaWRlIHRoZSB3ZWIgYnJvd3Nlci4nKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsXzEuYXNzZXJ0KHBhdGggIT0gbnVsbCAmJiBwYXRoLmxlbmd0aCA+IDAsICdVUkwgcGF0aCBmb3IgYnJvd3NlckhUVFBSZXF1ZXN0IG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciAnICtcbiAgICAgICAgICAgICdlbXB0eS4nKTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgaWYgKHJlcXVlc3RJbml0ICE9IG51bGwgJiYgcmVxdWVzdEluaXQuYm9keSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVlc3RJbml0IGlzIGV4cGVjdGVkIHRvIGhhdmUgbm8gcHJlLWV4aXN0aW5nIGJvZHksIGJ1dCBoYXMgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdEluaXQgPSByZXF1ZXN0SW5pdCB8fCB7fTtcbiAgICB9XG4gICAgQnJvd3NlckhUVFBSZXF1ZXN0LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKG1vZGVsQXJ0aWZhY3RzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbml0LCB3ZWlnaHRzTWFuaWZlc3QsIG1vZGVsVG9wb2xvZ3lBbmRXZWlnaHRNYW5pZmVzdCwgcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxBcnRpZmFjdHMubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VySFRUUFJlcXVlc3Quc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW4gYmluYXJ5IGZvcm1hdHMgeWV0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IHRoaXMuREVGQVVMVF9NRVRIT0QgfSwgdGhpcy5yZXF1ZXN0SW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0LmJvZHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdCA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzOiBbJy4vbW9kZWwud2VpZ2h0cy5iaW4nXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0czogbW9kZWxBcnRpZmFjdHMud2VpZ2h0U3BlY3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5QW5kV2VpZ2h0TWFuaWZlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxUb3BvbG9neTogbW9kZWxBcnRpZmFjdHMubW9kZWxUb3BvbG9neSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzTWFuaWZlc3Q6IHdlaWdodHNNYW5pZmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQuYm9keS5hcHBlbmQoJ21vZGVsLmpzb24nLCBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkobW9kZWxUb3BvbG9neUFuZFdlaWdodE1hbmlmZXN0KV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pLCAnbW9kZWwuanNvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsQXJ0aWZhY3RzLndlaWdodERhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQuYm9keS5hcHBlbmQoJ21vZGVsLndlaWdodHMuYmluJywgbmV3IEJsb2IoW21vZGVsQXJ0aWZhY3RzLndlaWdodERhdGFdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH0pLCAnbW9kZWwud2VpZ2h0cy5iaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZmV0Y2godGhpcy5wYXRoLCBpbml0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbEFydGlmYWN0c0luZm86IGlvX3V0aWxzXzEuZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTihtb2RlbEFydGlmYWN0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZXM6IFtyZXNwb25zZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBmYWlsZWQgZHVlIHRvIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlLnN0YXR1cyArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJyb3dzZXJIVFRQUmVxdWVzdC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsQ29uZmlnUmVxdWVzdCwgbW9kZWxDb25maWcsIG1vZGVsVG9wb2xvZ3ksIHdlaWdodHNNYW5pZmVzdCwgd2VpZ2h0U3BlY3MsIHdlaWdodERhdGEsIHdlaWdodHNNYW5pZmVzdF8xLCBfaSwgd2VpZ2h0c01hbmlmZXN0XzIsIGVudHJ5LCBwYXRoUHJlZml4XzEsIGZldGNoVVJMc18xLCBfYTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBmZXRjaCh0aGlzLnBhdGgsIHRoaXMucmVxdWVzdEluaXQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxDb25maWdSZXF1ZXN0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbENvbmZpZ1JlcXVlc3QuanNvbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxDb25maWcgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5ID0gbW9kZWxDb25maWdbJ21vZGVsVG9wb2xvZ3knXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdCA9IG1vZGVsQ29uZmlnWyd3ZWlnaHRzTWFuaWZlc3QnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFRvcG9sb2d5ID09IG51bGwgJiYgd2VpZ2h0c01hbmlmZXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgSlNPTiBmcm9tIEhUVFAgcGF0aCBcIiArIHRoaXMucGF0aCArIFwiIGNvbnRhaW5zIG5laXRoZXIgbW9kZWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRvcG9sb2d5IG9yIG1hbmlmZXN0IGZvciB3ZWlnaHRzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHdlaWdodHNNYW5pZmVzdCAhPSBudWxsKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdF8xID0gbW9kZWxDb25maWdbJ3dlaWdodHNNYW5pZmVzdCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0U3BlY3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCB3ZWlnaHRzTWFuaWZlc3RfMiA9IHdlaWdodHNNYW5pZmVzdF8xOyBfaSA8IHdlaWdodHNNYW5pZmVzdF8yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gd2VpZ2h0c01hbmlmZXN0XzJbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodFNwZWNzLnB1c2guYXBwbHkod2VpZ2h0U3BlY3MsIGVudHJ5LndlaWdodHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFByZWZpeF8xID0gdGhpcy5wYXRoLnN1YnN0cmluZygwLCB0aGlzLnBhdGgubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGhQcmVmaXhfMS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFByZWZpeF8xID0gcGF0aFByZWZpeF8xICsgJy8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hVUkxzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdF8xLmZvckVhY2goZnVuY3Rpb24gKHdlaWdodHNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNHcm91cC5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoVVJMc18xLnB1c2gocGF0aFByZWZpeF8xICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gaW9fdXRpbHNfMS5jb25jYXRlbmF0ZUFycmF5QnVmZmVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgd2VpZ2h0c19sb2FkZXJfMS5sb2FkV2VpZ2h0c0FzQXJyYXlCdWZmZXIoZmV0Y2hVUkxzXzEsIHRoaXMucmVxdWVzdEluaXQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RGF0YSA9IF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiwgeyBtb2RlbFRvcG9sb2d5OiBtb2RlbFRvcG9sb2d5LCB3ZWlnaHRTcGVjczogd2VpZ2h0U3BlY3MsIHdlaWdodERhdGE6IHdlaWdodERhdGEgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnJvd3NlckhUVFBSZXF1ZXN0LlVSTF9TQ0hFTUVTID0gWydodHRwOi8vJywgJ2h0dHBzOi8vJ107XG4gICAgcmV0dXJuIEJyb3dzZXJIVFRQUmVxdWVzdDtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJIVFRQUmVxdWVzdCA9IEJyb3dzZXJIVFRQUmVxdWVzdDtcbmV4cG9ydHMuaHR0cFJlcXVlc3RSb3V0ZXIgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBCcm93c2VySFRUUFJlcXVlc3QuVVJMX1NDSEVNRVM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1lID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKHNjaGVtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3NlckhUVFBSZXF1ZXN0KHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbnJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGV4cG9ydHMuaHR0cFJlcXVlc3RSb3V0ZXIpO1xucm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXIoZXhwb3J0cy5odHRwUmVxdWVzdFJvdXRlcik7XG5mdW5jdGlvbiBicm93c2VySFRUUFJlcXVlc3QocGF0aCwgcmVxdWVzdEluaXQpIHtcbiAgICByZXR1cm4gbmV3IEJyb3dzZXJIVFRQUmVxdWVzdChwYXRoLCByZXF1ZXN0SW5pdCk7XG59XG5leHBvcnRzLmJyb3dzZXJIVFRQUmVxdWVzdCA9IGJyb3dzZXJIVFRQUmVxdWVzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJfaHR0cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgaW9fdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2lvX3V0aWxzXCIpO1xudmFyIG1vZGVsX21hbmFnZW1lbnRfMSA9IHJlcXVpcmUoXCIuL21vZGVsX21hbmFnZW1lbnRcIik7XG52YXIgcm91dGVyX3JlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9yb3V0ZXJfcmVnaXN0cnlcIik7XG52YXIgREFUQUJBU0VfTkFNRSA9ICd0ZW5zb3JmbG93anMnO1xudmFyIERBVEFCQVNFX1ZFUlNJT04gPSAxO1xudmFyIE1PREVMX1NUT1JFX05BTUUgPSAnbW9kZWxzX3N0b3JlJztcbnZhciBJTkZPX1NUT1JFX05BTUUgPSAnbW9kZWxfaW5mb19zdG9yZSc7XG5mdW5jdGlvbiBkZWxldGVEYXRhYmFzZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZGJGYWN0b3J5O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBpZGJGYWN0b3J5ID0gZ2V0SW5kZXhlZERCRmFjdG9yeSgpO1xuICAgICAgICAgICAgcmV0dXJuIFsyLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVSZXF1ZXN0ID0gaWRiRmFjdG9yeS5kZWxldGVEYXRhYmFzZShEQVRBQkFTRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gcmVqZWN0KGVycm9yKTsgfTtcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWxldGVEYXRhYmFzZSA9IGRlbGV0ZURhdGFiYXNlO1xuZnVuY3Rpb24gZ2V0SW5kZXhlZERCRmFjdG9yeSgpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIG9idGFpbiBJbmRleGVkREIgZmFjdG9yeSBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50JyArXG4gICAgICAgICAgICAnaXMgbm90IGEgd2ViIGJyb3dzZXIuJyk7XG4gICAgfVxuICAgIHZhciB0aGVXaW5kb3cgPSB3aW5kb3c7XG4gICAgdmFyIGZhY3RvcnkgPSB0aGVXaW5kb3cuaW5kZXhlZERCIHx8IHRoZVdpbmRvdy5tb3pJbmRleGVkREIgfHxcbiAgICAgICAgdGhlV2luZG93LndlYmtpdEluZGV4ZWREQiB8fCB0aGVXaW5kb3cubXNJbmRleGVkREIgfHxcbiAgICAgICAgdGhlV2luZG93LnNoaW1JbmRleGVkREI7XG4gICAgaWYgKGZhY3RvcnkgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgSW5kZXhlZERCLicpO1xuICAgIH1cbiAgICByZXR1cm4gZmFjdG9yeTtcbn1cbmZ1bmN0aW9uIHNldFVwRGF0YWJhc2Uob3BlblJlcXVlc3QpIHtcbiAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoTU9ERUxfU1RPUkVfTkFNRSwgeyBrZXlQYXRoOiAnbW9kZWxQYXRoJyB9KTtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUsIHsga2V5UGF0aDogJ21vZGVsUGF0aCcgfSk7XG59XG52YXIgQnJvd3NlckluZGV4ZWREQiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckluZGV4ZWREQihtb2RlbFBhdGgpIHtcbiAgICAgICAgdGhpcy5pbmRleGVkREIgPSBnZXRJbmRleGVkREJGYWN0b3J5KCk7XG4gICAgICAgIGlmIChtb2RlbFBhdGggPT0gbnVsbCB8fCAhbW9kZWxQYXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciBJbmRleGVkREIsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbFBhdGggPSBtb2RlbFBhdGg7XG4gICAgfVxuICAgIEJyb3dzZXJJbmRleGVkREIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAobW9kZWxBcnRpZmFjdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCwgbW9kZWxBcnRpZmFjdHMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJyb3dzZXJJbmRleGVkREIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZGF0YWJhc2VBY3Rpb24odGhpcy5tb2RlbFBhdGgpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJyb3dzZXJJbmRleGVkREIucHJvdG90eXBlLmRhdGFiYXNlQWN0aW9uID0gZnVuY3Rpb24gKG1vZGVsUGF0aCwgbW9kZWxBcnRpZmFjdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBvcGVuUmVxdWVzdCA9IF90aGlzLmluZGV4ZWREQi5vcGVuKERBVEFCQVNFX05BTUUsIERBVEFCQVNFX1ZFUlNJT04pO1xuICAgICAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0VXBEYXRhYmFzZShvcGVuUmVxdWVzdCk7IH07XG4gICAgICAgICAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbEFydGlmYWN0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbFR4ID0gZGIudHJhbnNhY3Rpb24oTU9ERUxfU1RPUkVfTkFNRSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbFN0b3JlID0gbW9kZWxUeC5vYmplY3RTdG9yZShNT0RFTF9TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldFJlcXVlc3RfMSA9IG1vZGVsU3RvcmUuZ2V0KF90aGlzLm1vZGVsUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGdldFJlcXVlc3RfMS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UmVxdWVzdF8xLnJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIgKyBfdGhpcy5tb2RlbFBhdGggKyBcIicgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImluIEluZGV4ZWREQi5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShnZXRSZXF1ZXN0XzEucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UmVxdWVzdF8xLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGdldFJlcXVlc3RfMS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVHgub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiLmNsb3NlKCk7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxBcnRpZmFjdHNJbmZvXzEgPSBpb191dGlsc18xLmdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04obW9kZWxBcnRpZmFjdHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mb1R4XzEgPSBkYi50cmFuc2FjdGlvbihJTkZPX1NUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm9TdG9yZV8xID0gaW5mb1R4XzEub2JqZWN0U3RvcmUoSU5GT19TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB1dEluZm9SZXF1ZXN0XzEgPSBpbmZvU3RvcmVfMS5wdXQoeyBtb2RlbFBhdGg6IF90aGlzLm1vZGVsUGF0aCwgbW9kZWxBcnRpZmFjdHNJbmZvOiBtb2RlbEFydGlmYWN0c0luZm9fMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsVHhfMTtcbiAgICAgICAgICAgICAgICAgICAgcHV0SW5mb1JlcXVlc3RfMS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFR4XzEgPSBkYi50cmFuc2FjdGlvbihNT0RFTF9TVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxTdG9yZSA9IG1vZGVsVHhfMS5vYmplY3RTdG9yZShNT0RFTF9TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXRNb2RlbFJlcXVlc3QgPSBtb2RlbFN0b3JlLnB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxQYXRoOiBfdGhpcy5tb2RlbFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxBcnRpZmFjdHM6IG1vZGVsQXJ0aWZhY3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsQXJ0aWZhY3RzSW5mbzogbW9kZWxBcnRpZmFjdHNJbmZvXzFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TW9kZWxSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoeyBtb2RlbEFydGlmYWN0c0luZm86IG1vZGVsQXJ0aWZhY3RzSW5mb18xIH0pOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TW9kZWxSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvU3RvcmVfMSA9IGluZm9UeF8xLm9iamVjdFN0b3JlKElORk9fU1RPUkVfTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZUluZm9SZXF1ZXN0ID0gaW5mb1N0b3JlXzEuZGVsZXRlKF90aGlzLm1vZGVsUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlSW5mb1JlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHB1dE1vZGVsUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJbmZvUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QocHV0TW9kZWxSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcHV0SW5mb1JlcXVlc3RfMS5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChwdXRJbmZvUmVxdWVzdF8xLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW5mb1R4XzEub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFR4XzEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFR4XzEub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiLmNsb3NlKCk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIHJlamVjdChvcGVuUmVxdWVzdC5lcnJvcik7IH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnJvd3NlckluZGV4ZWREQi5VUkxfU0NIRU1FID0gJ2luZGV4ZWRkYjovLyc7XG4gICAgcmV0dXJuIEJyb3dzZXJJbmRleGVkREI7XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VySW5kZXhlZERCID0gQnJvd3NlckluZGV4ZWREQjtcbmV4cG9ydHMuaW5kZXhlZERCUm91dGVyID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdJU19CUk9XU0VSJykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoQnJvd3NlckluZGV4ZWREQi5VUkxfU0NIRU1FKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJJbmRleGVkREIodXJsLnNsaWNlKEJyb3dzZXJJbmRleGVkREIuVVJMX1NDSEVNRS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbnJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyKGV4cG9ydHMuaW5kZXhlZERCUm91dGVyKTtcbnJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJMb2FkUm91dGVyKGV4cG9ydHMuaW5kZXhlZERCUm91dGVyKTtcbmZ1bmN0aW9uIGJyb3dzZXJJbmRleGVkREIobW9kZWxQYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBCcm93c2VySW5kZXhlZERCKG1vZGVsUGF0aCk7XG59XG5leHBvcnRzLmJyb3dzZXJJbmRleGVkREIgPSBicm93c2VySW5kZXhlZERCO1xuZnVuY3Rpb24gbWF5YmVTdHJpcFNjaGVtZShrZXkpIHtcbiAgICByZXR1cm4ga2V5LnN0YXJ0c1dpdGgoQnJvd3NlckluZGV4ZWREQi5VUkxfU0NIRU1FKSA/XG4gICAgICAgIGtleS5zbGljZShCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUubGVuZ3RoKSA6XG4gICAgICAgIGtleTtcbn1cbnZhciBCcm93c2VySW5kZXhlZERCTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckluZGV4ZWREQk1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlZERCID0gZ2V0SW5kZXhlZERCRmFjdG9yeSgpO1xuICAgIH1cbiAgICBCcm93c2VySW5kZXhlZERCTWFuYWdlci5wcm90b3R5cGUubGlzdE1vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuUmVxdWVzdCA9IF90aGlzLmluZGV4ZWREQi5vcGVuKERBVEFCQVNFX05BTUUsIERBVEFCQVNFX1ZFUlNJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0VXBEYXRhYmFzZShvcGVuUmVxdWVzdCk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eCA9IGRiLnRyYW5zYWN0aW9uKElORk9fU1RPUkVfTkFNRSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHgub2JqZWN0U3RvcmUoSU5GT19TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0QWxsSW5mb1JlcXVlc3QgPSBzdG9yZS5nZXRBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBbGxJbmZvUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGdldEFsbEluZm9SZXF1ZXN0LnJlc3VsdDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2l0ZW0ubW9kZWxQYXRoXSA9IGl0ZW0ubW9kZWxBcnRpZmFjdHNJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbEluZm9SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChnZXRBbGxJbmZvUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIuY2xvc2UoKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiByZWplY3Qob3BlblJlcXVlc3QuZXJyb3IpOyB9O1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VySW5kZXhlZERCTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlTW9kZWwgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBtYXliZVN0cmlwU2NoZW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gX3RoaXMuaW5kZXhlZERCLm9wZW4oREFUQUJBU0VfTkFNRSwgREFUQUJBU0VfVkVSU0lPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRVcERhdGFiYXNlKG9wZW5SZXF1ZXN0KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm9UeCA9IGRiLnRyYW5zYWN0aW9uKElORk9fU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvU3RvcmUgPSBpbmZvVHgub2JqZWN0U3RvcmUoSU5GT19TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0SW5mb1JlcXVlc3QgPSBpbmZvU3RvcmUuZ2V0KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbFR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEluZm9SZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldEluZm9SZXF1ZXN0LnJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJ1wiICsgcGF0aCArIFwiJyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbiBJbmRleGVkREIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVJbmZvUmVxdWVzdCA9IGluZm9TdG9yZS5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlTW9kZWxEYXRhXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxUeCA9IGRiLnRyYW5zYWN0aW9uKE1PREVMX1NUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxTdG9yZSA9IG1vZGVsVHgub2JqZWN0U3RvcmUoTU9ERUxfU1RPUkVfTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZU1vZGVsUmVxdWVzdCA9IG1vZGVsU3RvcmUuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZU1vZGVsUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldEluZm9SZXF1ZXN0LnJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTW9kZWxSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChnZXRJbmZvUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJbmZvUmVxdWVzdC5vbnN1Y2Nlc3MgPSBkZWxldGVNb2RlbERhdGFfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUluZm9SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVNb2RlbERhdGFfMSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChnZXRJbmZvUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRJbmZvUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZ2V0SW5mb1JlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb1R4Lm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFR4Lm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkYi5jbG9zZSgpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiByZWplY3Qob3BlblJlcXVlc3QuZXJyb3IpOyB9O1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnJvd3NlckluZGV4ZWREQk1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VySW5kZXhlZERCTWFuYWdlciA9IEJyb3dzZXJJbmRleGVkREJNYW5hZ2VyO1xuaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW9kZWxfbWFuYWdlbWVudF8xLk1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkucmVnaXN0ZXJNYW5hZ2VyKEJyb3dzZXJJbmRleGVkREIuVVJMX1NDSEVNRSwgbmV3IEJyb3dzZXJJbmRleGVkREJNYW5hZ2VyKCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXhlZF9kYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnJlcXVpcmUoXCIuL2luZGV4ZWRfZGJcIik7XG5yZXF1aXJlKFwiLi9sb2NhbF9zdG9yYWdlXCIpO1xudmFyIGJyb3dzZXJfZmlsZXNfMSA9IHJlcXVpcmUoXCIuL2Jyb3dzZXJfZmlsZXNcIik7XG5leHBvcnRzLmJyb3dzZXJGaWxlcyA9IGJyb3dzZXJfZmlsZXNfMS5icm93c2VyRmlsZXM7XG52YXIgYnJvd3Nlcl9odHRwXzEgPSByZXF1aXJlKFwiLi9icm93c2VyX2h0dHBcIik7XG5leHBvcnRzLmJyb3dzZXJIVFRQUmVxdWVzdCA9IGJyb3dzZXJfaHR0cF8xLmJyb3dzZXJIVFRQUmVxdWVzdDtcbnZhciBpb191dGlsc18xID0gcmVxdWlyZShcIi4vaW9fdXRpbHNcIik7XG5leHBvcnRzLmRlY29kZVdlaWdodHMgPSBpb191dGlsc18xLmRlY29kZVdlaWdodHM7XG5leHBvcnRzLmVuY29kZVdlaWdodHMgPSBpb191dGlsc18xLmVuY29kZVdlaWdodHM7XG5leHBvcnRzLmdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04gPSBpb191dGlsc18xLmdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT047XG52YXIgbW9kZWxfbWFuYWdlbWVudF8xID0gcmVxdWlyZShcIi4vbW9kZWxfbWFuYWdlbWVudFwiKTtcbnZhciByb3V0ZXJfcmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3JvdXRlcl9yZWdpc3RyeVwiKTtcbnZhciB3ZWlnaHRzX2xvYWRlcl8xID0gcmVxdWlyZShcIi4vd2VpZ2h0c19sb2FkZXJcIik7XG5leHBvcnRzLmxvYWRXZWlnaHRzID0gd2VpZ2h0c19sb2FkZXJfMS5sb2FkV2VpZ2h0cztcbnZhciByZWdpc3RlclNhdmVSb3V0ZXIgPSByb3V0ZXJfcmVnaXN0cnlfMS5JT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyU2F2ZVJvdXRlcjtcbmV4cG9ydHMucmVnaXN0ZXJTYXZlUm91dGVyID0gcmVnaXN0ZXJTYXZlUm91dGVyO1xudmFyIHJlZ2lzdGVyTG9hZFJvdXRlciA9IHJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJMb2FkUm91dGVyO1xuZXhwb3J0cy5yZWdpc3RlckxvYWRSb3V0ZXIgPSByZWdpc3RlckxvYWRSb3V0ZXI7XG52YXIgZ2V0U2F2ZUhhbmRsZXJzID0gcm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5nZXRTYXZlSGFuZGxlcnM7XG5leHBvcnRzLmdldFNhdmVIYW5kbGVycyA9IGdldFNhdmVIYW5kbGVycztcbnZhciBnZXRMb2FkSGFuZGxlcnMgPSByb3V0ZXJfcmVnaXN0cnlfMS5JT1JvdXRlclJlZ2lzdHJ5LmdldExvYWRIYW5kbGVycztcbmV4cG9ydHMuZ2V0TG9hZEhhbmRsZXJzID0gZ2V0TG9hZEhhbmRsZXJzO1xudmFyIGNvcHlNb2RlbCA9IG1vZGVsX21hbmFnZW1lbnRfMS5Nb2RlbE1hbmFnZW1lbnQuY29weU1vZGVsO1xuZXhwb3J0cy5jb3B5TW9kZWwgPSBjb3B5TW9kZWw7XG52YXIgbGlzdE1vZGVscyA9IG1vZGVsX21hbmFnZW1lbnRfMS5Nb2RlbE1hbmFnZW1lbnQubGlzdE1vZGVscztcbmV4cG9ydHMubGlzdE1vZGVscyA9IGxpc3RNb2RlbHM7XG52YXIgbW92ZU1vZGVsID0gbW9kZWxfbWFuYWdlbWVudF8xLk1vZGVsTWFuYWdlbWVudC5tb3ZlTW9kZWw7XG5leHBvcnRzLm1vdmVNb2RlbCA9IG1vdmVNb2RlbDtcbnZhciByZW1vdmVNb2RlbCA9IG1vZGVsX21hbmFnZW1lbnRfMS5Nb2RlbE1hbmFnZW1lbnQucmVtb3ZlTW9kZWw7XG5leHBvcnRzLnJlbW92ZU1vZGVsID0gcmVtb3ZlTW9kZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFycmF5X29wc18xID0gcmVxdWlyZShcIi4uL29wcy9hcnJheV9vcHNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuZnVuY3Rpb24gZW5jb2RlV2VpZ2h0cyh0ZW5zb3JzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3BlY3MsIGRhdGFQcm9taXNlcywgbmFtZV8xLCB0LCB0ZW5zb3JWYWx1ZXM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHNwZWNzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWVfMSBpbiB0ZW5zb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gdGVuc29yc1tuYW1lXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQuZHR5cGUgIT09ICdmbG9hdDMyJyAmJiB0LmR0eXBlICE9PSAnaW50MzInICYmIHQuZHR5cGUgIT09ICdib29sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIgKyBuYW1lXzEgKyBcIic6IFwiICsgdC5kdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjcy5wdXNoKHsgbmFtZTogbmFtZV8xLCBzaGFwZTogdC5zaGFwZSwgZHR5cGU6IHQuZHR5cGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvbWlzZXMucHVzaCh0LmRhdGEoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBQcm9taXNlLmFsbChkYXRhUHJvbWlzZXMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvclZhbHVlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGRhdGE6IGNvbmNhdGVuYXRlVHlwZWRBcnJheXModGVuc29yVmFsdWVzKSwgc3BlY3M6IHNwZWNzIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZW5jb2RlV2VpZ2h0cyA9IGVuY29kZVdlaWdodHM7XG5mdW5jdGlvbiBkZWNvZGVXZWlnaHRzKGJ1ZmZlciwgc3BlY3MpIHtcbiAgICB2YXIgb3V0ID0ge307XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzcGVjc18xID0gc3BlY3M7IF9pIDwgc3BlY3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNwZWMgPSBzcGVjc18xW19pXTtcbiAgICAgICAgdmFyIG5hbWVfMiA9IHNwZWMubmFtZTtcbiAgICAgICAgdmFyIGR0eXBlID0gc3BlYy5kdHlwZTtcbiAgICAgICAgdmFyIHNoYXBlID0gc3BlYy5zaGFwZTtcbiAgICAgICAgaWYgKHNwZWMucXVhbnRpemF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY29kZVdlaWdodHMgZG9lcyBub3Qgc3VwcG9ydCBxdWFudGl6YXRpb24geWV0LCBidXQgZW5jb3VudGVyZWQgXCIgK1xuICAgICAgICAgICAgICAgIChcIndlaWdodCAnXCIgKyBuYW1lXzIgKyBcIiB3aXRoIHF1YW50aXphdGlvbi4nXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IHV0aWxfMS5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgdmFsdWUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50ZW5zb3IobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIG9mZnNldCwgc2l6ZSksIHNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgICAgYXJyYXlfb3BzXzEuQXJyYXlPcHMudGVuc29yKG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSwgc2hhcGUsICdpbnQzMicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICBhcnJheV9vcHNfMS5BcnJheU9wcy50ZW5zb3IobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIHNpemUpLCBzaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIgKyBuYW1lXzIgKyBcIic6IFwiICsgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIG91dFtuYW1lXzJdID0gdmFsdWU7XG4gICAgICAgIG9mZnNldCArPSBzaXplICogdHlwZXNfMS5EVFlQRV9WQUxVRV9TSVpFX01BUFtkdHlwZV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLmRlY29kZVdlaWdodHMgPSBkZWNvZGVXZWlnaHRzO1xuZnVuY3Rpb24gY29uY2F0ZW5hdGVUeXBlZEFycmF5cyh4cykge1xuICAgIGlmICh4cyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHZhbHVlOiBcIiArIEpTT04uc3RyaW5naWZ5KHhzKSk7XG4gICAgfVxuICAgIHZhciB0b3RhbEJ5dGVMZW5ndGggPSAwO1xuICAgIHhzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgeCBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHtcbiAgICAgICAgICAgIHRvdGFsQnl0ZUxlbmd0aCArPSB4Lmxlbmd0aCAqIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRvdGFsQnl0ZUxlbmd0aCArPSB4Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFR5cGVkQXJyYXkgc3VidHlwZTogXCIgKyB4LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHkgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVMZW5ndGgpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHhzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeS5zZXQobmV3IFVpbnQ4QXJyYXkoeC5idWZmZXIpLCBvZmZzZXQpO1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB4IGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHgubGVuZ3RoICogNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCArPSB4Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB5LmJ1ZmZlcjtcbn1cbmV4cG9ydHMuY29uY2F0ZW5hdGVUeXBlZEFycmF5cyA9IGNvbmNhdGVuYXRlVHlwZWRBcnJheXM7XG5mdW5jdGlvbiBzdHJpbmdCeXRlTGVuZ3RoKHN0cikge1xuICAgIHJldHVybiBuZXcgQmxvYihbc3RyXSkuc2l6ZTtcbn1cbmV4cG9ydHMuc3RyaW5nQnl0ZUxlbmd0aCA9IHN0cmluZ0J5dGVMZW5ndGg7XG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGJ1ZmZlcikge1xuICAgIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkpO1xufVxuZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nID0gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZztcbmZ1bmN0aW9uIGJhc2U2NFN0cmluZ1RvQXJyYXlCdWZmZXIoc3RyKSB7XG4gICAgdmFyIHMgPSBhdG9iKHN0cik7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYnVmZmVyLnNldChbcy5jaGFyQ29kZUF0KGkpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xufVxuZXhwb3J0cy5iYXNlNjRTdHJpbmdUb0FycmF5QnVmZmVyID0gYmFzZTY0U3RyaW5nVG9BcnJheUJ1ZmZlcjtcbmZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKGJ1ZmZlcnMpIHtcbiAgICB2YXIgdG90YWxCeXRlTGVuZ3RoID0gMDtcbiAgICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICB0b3RhbEJ5dGVMZW5ndGggKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfSk7XG4gICAgdmFyIHRlbXAgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVMZW5ndGgpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHRlbXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGVtcC5idWZmZXI7XG59XG5leHBvcnRzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzID0gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnM7XG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gICAgdmFyIFNFUEFSQVRPUiA9ICcvJztcbiAgICBwYXRoID0gcGF0aC50cmltKCk7XG4gICAgd2hpbGUgKHBhdGguZW5kc1dpdGgoU0VQQVJBVE9SKSkge1xuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIgaXRlbXMgPSBwYXRoLnNwbGl0KFNFUEFSQVRPUik7XG4gICAgcmV0dXJuIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xufVxuZXhwb3J0cy5iYXNlbmFtZSA9IGJhc2VuYW1lO1xuZnVuY3Rpb24gZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTihtb2RlbEFydGlmYWN0cykge1xuICAgIGlmIChtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBKU09OIG1vZGVsIHRvcG9sb2d5LCByZWNlaXZlZCBBcnJheUJ1ZmZlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZVNhdmVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICBtb2RlbFRvcG9sb2d5VHlwZTogJ0pTT04nLFxuICAgICAgICBtb2RlbFRvcG9sb2d5Qnl0ZXM6IG1vZGVsQXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3kgPT0gbnVsbCA/XG4gICAgICAgICAgICAwIDpcbiAgICAgICAgICAgIHN0cmluZ0J5dGVMZW5ndGgoSlNPTi5zdHJpbmdpZnkobW9kZWxBcnRpZmFjdHMubW9kZWxUb3BvbG9neSkpLFxuICAgICAgICB3ZWlnaHRTcGVjc0J5dGVzOiBtb2RlbEFydGlmYWN0cy53ZWlnaHRTcGVjcyA9PSBudWxsID9cbiAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgc3RyaW5nQnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShtb2RlbEFydGlmYWN0cy53ZWlnaHRTcGVjcykpLFxuICAgICAgICB3ZWlnaHREYXRhQnl0ZXM6IG1vZGVsQXJ0aWZhY3RzLndlaWdodERhdGEgPT0gbnVsbCA/XG4gICAgICAgICAgICAwIDpcbiAgICAgICAgICAgIG1vZGVsQXJ0aWZhY3RzLndlaWdodERhdGEuYnl0ZUxlbmd0aCxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OID0gZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlvX3V0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBpb191dGlsc18xID0gcmVxdWlyZShcIi4vaW9fdXRpbHNcIik7XG52YXIgbW9kZWxfbWFuYWdlbWVudF8xID0gcmVxdWlyZShcIi4vbW9kZWxfbWFuYWdlbWVudFwiKTtcbnZhciByb3V0ZXJfcmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3JvdXRlcl9yZWdpc3RyeVwiKTtcbnZhciBQQVRIX1NFUEFSQVRPUiA9ICcvJztcbnZhciBQQVRIX1BSRUZJWCA9ICd0ZW5zb3JmbG93anNfbW9kZWxzJztcbnZhciBJTkZPX1NVRkZJWCA9ICdpbmZvJztcbnZhciBNT0RFTF9UT1BPTE9HWV9TVUZGSVggPSAnbW9kZWxfdG9wb2xvZ3knO1xudmFyIFdFSUdIVF9TUEVDU19TVUZGSVggPSAnd2VpZ2h0X3NwZWNzJztcbnZhciBXRUlHSFRfREFUQV9TVUZGSVggPSAnd2VpZ2h0X2RhdGEnO1xuZnVuY3Rpb24gcHVyZ2VMb2NhbFN0b3JhZ2VBcnRpZmFjdHMoKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSB8fCB0eXBlb2Ygd2luZG93LmxvY2FsU3RvcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdXJnZUxvY2FsU3RvcmFnZU1vZGVscygpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgbG9jYWwgc3RvcmFnZSBpcyAnICtcbiAgICAgICAgICAgICd1bmF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gICAgdmFyIExTID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICB2YXIgcHVyZ2VkTW9kZWxQYXRocyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTFMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IExTLmtleShpKTtcbiAgICAgICAgdmFyIHByZWZpeCA9IFBBVEhfUFJFRklYICsgUEFUSF9TRVBBUkFUT1I7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChwcmVmaXgpICYmIGtleS5sZW5ndGggPiBwcmVmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBMUy5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICB2YXIgbW9kZWxOYW1lID0gZ2V0TW9kZWxQYXRoRnJvbUtleShrZXkpO1xuICAgICAgICAgICAgaWYgKHB1cmdlZE1vZGVsUGF0aHMuaW5kZXhPZihtb2RlbE5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHB1cmdlZE1vZGVsUGF0aHMucHVzaChtb2RlbE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwdXJnZWRNb2RlbFBhdGhzO1xufVxuZXhwb3J0cy5wdXJnZUxvY2FsU3RvcmFnZUFydGlmYWN0cyA9IHB1cmdlTG9jYWxTdG9yYWdlQXJ0aWZhY3RzO1xuZnVuY3Rpb24gZ2V0TW9kZWxLZXlzKHBhdGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmZvOiBbUEFUSF9QUkVGSVgsIHBhdGgsIElORk9fU1VGRklYXS5qb2luKFBBVEhfU0VQQVJBVE9SKSxcbiAgICAgICAgdG9wb2xvZ3k6IFtQQVRIX1BSRUZJWCwgcGF0aCwgTU9ERUxfVE9QT0xPR1lfU1VGRklYXS5qb2luKFBBVEhfU0VQQVJBVE9SKSxcbiAgICAgICAgd2VpZ2h0U3BlY3M6IFtQQVRIX1BSRUZJWCwgcGF0aCwgV0VJR0hUX1NQRUNTX1NVRkZJWF0uam9pbihQQVRIX1NFUEFSQVRPUiksXG4gICAgICAgIHdlaWdodERhdGE6IFtQQVRIX1BSRUZJWCwgcGF0aCwgV0VJR0hUX0RBVEFfU1VGRklYXS5qb2luKFBBVEhfU0VQQVJBVE9SKVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRNb2RlbFBhdGhGcm9tS2V5KGtleSkge1xuICAgIHZhciBpdGVtcyA9IGtleS5zcGxpdChQQVRIX1NFUEFSQVRPUik7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgZm9ybWF0OiBcIiArIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtcy5zbGljZSgxLCBpdGVtcy5sZW5ndGggLSAxKS5qb2luKFBBVEhfU0VQQVJBVE9SKTtcbn1cbmZ1bmN0aW9uIG1heWJlU3RyaXBTY2hlbWUoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKEJyb3dzZXJMb2NhbFN0b3JhZ2UuVVJMX1NDSEVNRSkgP1xuICAgICAgICBrZXkuc2xpY2UoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FLmxlbmd0aCkgOlxuICAgICAgICBrZXk7XG59XG52YXIgQnJvd3NlckxvY2FsU3RvcmFnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckxvY2FsU3RvcmFnZShtb2RlbFBhdGgpIHtcbiAgICAgICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSB8fCB0eXBlb2Ygd2luZG93LmxvY2FsU3RvcmFnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBsb2NhbCBzdG9yYWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuTFMgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICBpZiAobW9kZWxQYXRoID09IG51bGwgfHwgIW1vZGVsUGF0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgbG9jYWwgc3RvcmFnZSwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsUGF0aCA9IG1vZGVsUGF0aDtcbiAgICAgICAgdGhpcy5rZXlzID0gZ2V0TW9kZWxLZXlzKHRoaXMubW9kZWxQYXRoKTtcbiAgICB9XG4gICAgQnJvd3NlckxvY2FsU3RvcmFnZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChtb2RlbEFydGlmYWN0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9wb2xvZ3ksIHdlaWdodFNwZWNzLCBtb2RlbEFydGlmYWN0c0luZm8sIGtleTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWxBcnRpZmFjdHMubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlckxvY2FsU3RvcmFnZS5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW4gYmluYXJ5IGZvcm1hdHMgeWV0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wb2xvZ3kgPSBKU09OLnN0cmluZ2lmeShtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5KTtcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0U3BlY3MgPSBKU09OLnN0cmluZ2lmeShtb2RlbEFydGlmYWN0cy53ZWlnaHRTcGVjcyk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsQXJ0aWZhY3RzSW5mbyA9IGlvX3V0aWxzXzEuZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTihtb2RlbEFydGlmYWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLmluZm8sIEpTT04uc3RyaW5naWZ5KG1vZGVsQXJ0aWZhY3RzSW5mbykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy50b3BvbG9neSwgdG9wb2xvZ3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcywgd2VpZ2h0U3BlY3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhLCBpb191dGlsc18xLmFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcobW9kZWxBcnRpZmFjdHMud2VpZ2h0RGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IG1vZGVsQXJ0aWZhY3RzSW5mbzogbW9kZWxBcnRpZmFjdHNJbmZvIH1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHRoaXMua2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBtb2RlbCAnXCIgKyB0aGlzLm1vZGVsUGF0aCArIFwiJyB0byBsb2NhbCBzdG9yYWdlOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaXplIHF1b3RhIGJlaW5nIGV4Y2VlZGVkIGlzIGEgcG9zc2libGUgY2F1c2Ugb2YgdGhpcyBmYWlsdXJlOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwibW9kZWxUb3BvbG9neUJ5dGVzPVwiICsgbW9kZWxBcnRpZmFjdHNJbmZvLm1vZGVsVG9wb2xvZ3lCeXRlcyArIFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIndlaWdodFNwZWNzQnl0ZXM9XCIgKyBtb2RlbEFydGlmYWN0c0luZm8ud2VpZ2h0U3BlY3NCeXRlcyArIFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIndlaWdodERhdGFCeXRlcz1cIiArIG1vZGVsQXJ0aWZhY3RzSW5mby53ZWlnaHREYXRhQnl0ZXMgKyBcIi5cIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYWxTdG9yYWdlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5mbywgb3V0LCB0b3BvbG9neSwgd2VpZ2h0U3BlY3MsIHdlaWdodERhdGFCYXNlNjQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaW5mbyA9IEpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy5pbmZvKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGVyZSBpcyBubyBtb2RlbCB3aXRoIG5hbWUgJ1wiICsgdGhpcy5tb2RlbFBhdGggKyBcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmZvLm1vZGVsVG9wb2xvZ3lUeXBlICE9PSAnSlNPTicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyTG9jYWxTdG9yYWdlIGRvZXMgbm90IHN1cHBvcnQgbG9hZGluZyBub24tSlNPTiBtb2RlbCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b3BvbG9neSB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgICAgIHRvcG9sb2d5ID0gSlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRvcG9sb2d5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHRvcG9sb2d5IG9mIG1vZGVsICdcIiArIHRoaXMubW9kZWxQYXRoICsgXCInIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaXMgbWlzc2luZy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC5tb2RlbFRvcG9sb2d5ID0gdG9wb2xvZ3k7XG4gICAgICAgICAgICAgICAgd2VpZ2h0U3BlY3MgPSBKU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MpKTtcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0U3BlY3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgd2VpZ2h0IHNwZWNzIG9mIG1vZGVsICdcIiArIHRoaXMubW9kZWxQYXRoICsgXCInIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJlIG1pc3NpbmcuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQud2VpZ2h0U3BlY3MgPSB3ZWlnaHRTcGVjcztcbiAgICAgICAgICAgICAgICB3ZWlnaHREYXRhQmFzZTY0ID0gdGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0RGF0YUJhc2U2NCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSBiaW5hcnkgd2VpZ2h0IHZhbHVlcyBvZiBtb2RlbCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCInXCIgKyB0aGlzLm1vZGVsUGF0aCArIFwiJyBhcmUgbWlzc2luZy5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQud2VpZ2h0RGF0YSA9IGlvX3V0aWxzXzEuYmFzZTY0U3RyaW5nVG9BcnJheUJ1ZmZlcih3ZWlnaHREYXRhQmFzZTY0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG91dF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYWxTdG9yYWdlLlVSTF9TQ0hFTUUgPSAnbG9jYWxzdG9yYWdlOi8vJztcbiAgICByZXR1cm4gQnJvd3NlckxvY2FsU3RvcmFnZTtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJMb2NhbFN0b3JhZ2UgPSBCcm93c2VyTG9jYWxTdG9yYWdlO1xuZXhwb3J0cy5sb2NhbFN0b3JhZ2VSb3V0ZXIgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChCcm93c2VyTG9jYWxTdG9yYWdlLlVSTF9TQ0hFTUUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJvd3NlckxvY2FsU3RvcmFnZSh1cmwuc2xpY2UoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xucm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlclNhdmVSb3V0ZXIoZXhwb3J0cy5sb2NhbFN0b3JhZ2VSb3V0ZXIpO1xucm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXIoZXhwb3J0cy5sb2NhbFN0b3JhZ2VSb3V0ZXIpO1xuZnVuY3Rpb24gYnJvd3NlckxvY2FsU3RvcmFnZShtb2RlbFBhdGgpIHtcbiAgICByZXR1cm4gbmV3IEJyb3dzZXJMb2NhbFN0b3JhZ2UobW9kZWxQYXRoKTtcbn1cbmV4cG9ydHMuYnJvd3NlckxvY2FsU3RvcmFnZSA9IGJyb3dzZXJMb2NhbFN0b3JhZ2U7XG52YXIgQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJMb2NhbFN0b3JhZ2VNYW5hZ2VyKCkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KGVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpLCAnQ3VycmVudCBlbnZpcm9ubWVudCBpcyBub3QgYSB3ZWIgYnJvd3NlcicpO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJywgJ0N1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBsb2NhbFN0b3JhZ2UnKTtcbiAgICAgICAgdGhpcy5MUyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgfVxuICAgIEJyb3dzZXJMb2NhbFN0b3JhZ2VNYW5hZ2VyLnByb3RvdHlwZS5saXN0TW9kZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3V0LCBwcmVmaXgsIHN1ZmZpeCwgaSwga2V5LCBtb2RlbFBhdGg7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gUEFUSF9QUkVGSVggKyBQQVRIX1NFUEFSQVRPUjtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBQQVRIX1NFUEFSQVRPUiArIElORk9fU1VGRklYO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLkxTLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuTFMua2V5KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocHJlZml4KSAmJiBrZXkuZW5kc1dpdGgoc3VmZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxQYXRoID0gZ2V0TW9kZWxQYXRoRnJvbUtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W21vZGVsUGF0aF0gPSBKU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbShrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG91dF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYWxTdG9yYWdlTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlTW9kZWwgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIga2V5cywgaW5mbztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gbWF5YmVTdHJpcFNjaGVtZShwYXRoKTtcbiAgICAgICAgICAgICAgICBrZXlzID0gZ2V0TW9kZWxLZXlzKHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLkxTLmdldEl0ZW0oa2V5cy5pbmZvKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIGF0IHBhdGggJ1wiICsgcGF0aCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5mbyA9IEpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKGtleXMuaW5mbykpO1xuICAgICAgICAgICAgICAgIHRoaXMuTFMucmVtb3ZlSXRlbShrZXlzLmluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuTFMucmVtb3ZlSXRlbShrZXlzLnRvcG9sb2d5KTtcbiAgICAgICAgICAgICAgICB0aGlzLkxTLnJlbW92ZUl0ZW0oa2V5cy53ZWlnaHRTcGVjcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5MUy5yZW1vdmVJdGVtKGtleXMud2VpZ2h0RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBpbmZvXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VyTG9jYWxTdG9yYWdlTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJMb2NhbFN0b3JhZ2VNYW5hZ2VyID0gQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXI7XG5pZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdJU19CUk9XU0VSJykpIHtcbiAgICB0cnkge1xuICAgICAgICBtb2RlbF9tYW5hZ2VtZW50XzEuTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5yZWdpc3Rlck1hbmFnZXIoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FLCBuZXcgQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXIoKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbF9zdG9yYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHJvdXRlcl9yZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vcm91dGVyX3JlZ2lzdHJ5XCIpO1xudmFyIFVSTF9TQ0hFTUVfU1VGRklYID0gJzovLyc7XG52YXIgTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeSgpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VycyA9IHt9O1xuICAgIH1cbiAgICBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5pbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5Lmluc3RhbmNlID0gbmV3IE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5pbnN0YW5jZTtcbiAgICB9O1xuICAgIE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkucmVnaXN0ZXJNYW5hZ2VyID0gZnVuY3Rpb24gKHNjaGVtZSwgbWFuYWdlcikge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHNjaGVtZSAhPSBudWxsLCAnc2NoZW1lIG11c3Qgbm90IGJlIHVuZGVmaW5lZCBvciBudWxsLicpO1xuICAgICAgICBpZiAoc2NoZW1lLmVuZHNXaXRoKFVSTF9TQ0hFTUVfU1VGRklYKSkge1xuICAgICAgICAgICAgc2NoZW1lID0gc2NoZW1lLnNsaWNlKDAsIHNjaGVtZS5pbmRleE9mKFVSTF9TQ0hFTUVfU1VGRklYKSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbF8xLmFzc2VydChzY2hlbWUubGVuZ3RoID4gMCwgJ3NjaGVtZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuJyk7XG4gICAgICAgIHZhciByZWdpc3RyeSA9IE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdXRpbF8xLmFzc2VydChyZWdpc3RyeS5tYW5hZ2Vyc1tzY2hlbWVdID09IG51bGwsIFwiQSBtb2RlbCBzdG9yZSBtYW5hZ2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3Igc2NoZW1lICdcIiArIHNjaGVtZSArIFwiJy5cIik7XG4gICAgICAgIHJlZ2lzdHJ5Lm1hbmFnZXJzW3NjaGVtZV0gPSBtYW5hZ2VyO1xuICAgIH07XG4gICAgTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRNYW5hZ2VyID0gZnVuY3Rpb24gKHNjaGVtZSkge1xuICAgICAgICB2YXIgbWFuYWdlciA9IHRoaXMuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vyc1tzY2hlbWVdO1xuICAgICAgICBpZiAobWFuYWdlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCBtYW5hZ2VyIGZvciBzY2hlbWUgJ1wiICsgc2NoZW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH07XG4gICAgTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRTY2hlbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRJbnN0YW5jZSgpLm1hbmFnZXJzKTtcbiAgICB9O1xuICAgIHJldHVybiBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5O1xufSgpKTtcbmV4cG9ydHMuTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeSA9IE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnk7XG5mdW5jdGlvbiBwYXJzZVVSTCh1cmwpIHtcbiAgICBpZiAodXJsLmluZGV4T2YoVVJMX1NDSEVNRV9TVUZGSVgpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdXJsIHN0cmluZyBwcm92aWRlZCBkb2VzIG5vdCBjb250YWluIGEgc2NoZW1lLiBcIiArXG4gICAgICAgICAgICBcIlN1cHBvcnRlZCBzY2hlbWVzIGFyZTogXCIgK1xuICAgICAgICAgICAgKFwiXCIgKyBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldFNjaGVtZXMoKS5qb2luKCcsJykpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiB1cmwuc3BsaXQoVVJMX1NDSEVNRV9TVUZGSVgpWzBdLFxuICAgICAgICBwYXRoOiB1cmwuc3BsaXQoVVJMX1NDSEVNRV9TVUZGSVgpWzFdLFxuICAgIH07XG59XG5mdW5jdGlvbiBjbG9uZU1vZGVsSW50ZXJuYWwoc291cmNlVVJMLCBkZXN0VVJMLCBkZWxldGVTb3VyY2UpIHtcbiAgICBpZiAoZGVsZXRlU291cmNlID09PSB2b2lkIDApIHsgZGVsZXRlU291cmNlID0gZmFsc2U7IH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2FkSGFuZGxlcnMsIGxvYWRIYW5kbGVyLCBzYXZlSGFuZGxlcnMsIHNhdmVIYW5kbGVyLCBzb3VyY2VTY2hlbWUsIHNvdXJjZVBhdGgsIHNhbWVNZWRpdW0sIG1vZGVsQXJ0aWZhY3RzLCBzYXZlUmVzdWx0O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHNvdXJjZVVSTCAhPT0gZGVzdFVSTCwgXCJPbGQgcGF0aCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lOiAnXCIgKyBzb3VyY2VVUkwgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRIYW5kbGVycyA9IHJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkuZ2V0TG9hZEhhbmRsZXJzKHNvdXJjZVVSTCk7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQobG9hZEhhbmRsZXJzLmxlbmd0aCA+IDAsIFwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBsb2FkIGhhbmRsZXIgaXMgZm91bmQgZm9yIHNvdXJjZSBVUkwgXCIgKyBzb3VyY2VVUkwgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQobG9hZEhhbmRsZXJzLmxlbmd0aCA8IDIsIFwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIiArIGxvYWRIYW5kbGVycy5sZW5ndGggKyBcIikgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwibG9hZCBoYW5kbGVycyBmb3Igc291cmNlIFVSTCBcIiArIHNvdXJjZVVSTCArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRIYW5kbGVyID0gbG9hZEhhbmRsZXJzWzBdO1xuICAgICAgICAgICAgICAgICAgICBzYXZlSGFuZGxlcnMgPSByb3V0ZXJfcmVnaXN0cnlfMS5JT1JvdXRlclJlZ2lzdHJ5LmdldFNhdmVIYW5kbGVycyhkZXN0VVJMKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydChzYXZlSGFuZGxlcnMubGVuZ3RoID4gMCwgXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIHNhdmUgaGFuZGxlciBpcyBmb3VuZCBmb3IgZGVzdGluYXRpb24gVVJMIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChkZXN0VVJMICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydChzYXZlSGFuZGxlcnMubGVuZ3RoIDwgMiwgXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG1vcmUgdGhhbiBvbmUgKFwiICsgbG9hZEhhbmRsZXJzLmxlbmd0aCArIFwiKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJzYXZlIGhhbmRsZXJzIGZvciBkZXN0aW5hdGlvbiBVUkwgXCIgKyBkZXN0VVJMICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUhhbmRsZXIgPSBzYXZlSGFuZGxlcnNbMF07XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNjaGVtZSA9IHBhcnNlVVJMKHNvdXJjZVVSTCkuc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VQYXRoID0gcGFyc2VVUkwoc291cmNlVVJMKS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICBzYW1lTWVkaXVtID0gc291cmNlU2NoZW1lID09PSBwYXJzZVVSTChzb3VyY2VVUkwpLnNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBsb2FkSGFuZGxlci5sb2FkKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxBcnRpZmFjdHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlbGV0ZVNvdXJjZSAmJiBzYW1lTWVkaXVtKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldE1hbmFnZXIoc291cmNlU2NoZW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVNb2RlbChzb3VyY2VQYXRoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCwgc2F2ZUhhbmRsZXIuc2F2ZShtb2RlbEFydGlmYWN0cyldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVsZXRlU291cmNlICYmICFzYW1lTWVkaXVtKSkgcmV0dXJuIFszLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldE1hbmFnZXIoc291cmNlU2NoZW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVNb2RlbChzb3VyY2VQYXRoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiwgc2F2ZVJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbnZhciBNb2RlbE1hbmFnZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGVsTWFuYWdlbWVudCgpIHtcbiAgICB9XG4gICAgTW9kZWxNYW5hZ2VtZW50Lmxpc3RNb2RlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWVzLCBvdXQsIF9pLCBzY2hlbWVzXzEsIHNjaGVtZSwgc2NoZW1lT3V0LCBwYXRoLCB1cmw7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWVzID0gTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRTY2hlbWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgc2NoZW1lc18xID0gc2NoZW1lcztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBzY2hlbWVzXzEubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtZSA9IHNjaGVtZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0TWFuYWdlcihzY2hlbWUpLmxpc3RNb2RlbHMoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtZU91dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocGF0aCBpbiBzY2hlbWVPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBzY2hlbWUgKyBVUkxfU0NIRU1FX1NVRkZJWCArIHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W3VybF0gPSBzY2hlbWVPdXRbcGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiwgb3V0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNb2RlbE1hbmFnZW1lbnQucmVtb3ZlTW9kZWwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWVBbmRQYXRoLCBtYW5hZ2VyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1lQW5kUGF0aCA9IHBhcnNlVVJMKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyID0gTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRNYW5hZ2VyKHNjaGVtZUFuZFBhdGguc2NoZW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbWFuYWdlci5yZW1vdmVNb2RlbChzY2hlbWVBbmRQYXRoLnBhdGgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTW9kZWxNYW5hZ2VtZW50LmNvcHlNb2RlbCA9IGZ1bmN0aW9uIChzb3VyY2VVUkwsIGRlc3RVUkwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlbGV0ZVNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVNvdXJjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjbG9uZU1vZGVsSW50ZXJuYWwoc291cmNlVVJMLCBkZXN0VVJMLCBkZWxldGVTb3VyY2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTW9kZWxNYW5hZ2VtZW50Lm1vdmVNb2RlbCA9IGZ1bmN0aW9uIChzb3VyY2VVUkwsIGRlc3RVUkwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlbGV0ZVNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVNvdXJjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGNsb25lTW9kZWxJbnRlcm5hbChzb3VyY2VVUkwsIGRlc3RVUkwsIGRlbGV0ZVNvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdNYW5hZ2VtZW50JywgbmFtZXNwYWNlOiAnaW8nIH0pXG4gICAgXSwgTW9kZWxNYW5hZ2VtZW50LCBcImxpc3RNb2RlbHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnTWFuYWdlbWVudCcsIG5hbWVzcGFjZTogJ2lvJyB9KVxuICAgIF0sIE1vZGVsTWFuYWdlbWVudCwgXCJyZW1vdmVNb2RlbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdNYW5hZ2VtZW50JywgbmFtZXNwYWNlOiAnaW8nIH0pXG4gICAgXSwgTW9kZWxNYW5hZ2VtZW50LCBcImNvcHlNb2RlbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdNYW5hZ2VtZW50JywgbmFtZXNwYWNlOiAnaW8nIH0pXG4gICAgXSwgTW9kZWxNYW5hZ2VtZW50LCBcIm1vdmVNb2RlbFwiLCBudWxsKTtcbiAgICByZXR1cm4gTW9kZWxNYW5hZ2VtZW50O1xufSgpKTtcbmV4cG9ydHMuTW9kZWxNYW5hZ2VtZW50ID0gTW9kZWxNYW5hZ2VtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWxfbWFuYWdlbWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJT1JvdXRlclJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJT1JvdXRlclJlZ2lzdHJ5KCkge1xuICAgICAgICB0aGlzLnNhdmVSb3V0ZXJzID0gW107XG4gICAgICAgIHRoaXMubG9hZFJvdXRlcnMgPSBbXTtcbiAgICB9XG4gICAgSU9Sb3V0ZXJSZWdpc3RyeS5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElPUm91dGVyUmVnaXN0cnkuaW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgSU9Sb3V0ZXJSZWdpc3RyeS5pbnN0YW5jZSA9IG5ldyBJT1JvdXRlclJlZ2lzdHJ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIElPUm91dGVyUmVnaXN0cnkuaW5zdGFuY2U7XG4gICAgfTtcbiAgICBJT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyU2F2ZVJvdXRlciA9IGZ1bmN0aW9uIChzYXZlUm91dGVyKSB7XG4gICAgICAgIElPUm91dGVyUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycy5wdXNoKHNhdmVSb3V0ZXIpO1xuICAgIH07XG4gICAgSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXIgPSBmdW5jdGlvbiAobG9hZFJvdXRlcikge1xuICAgICAgICBJT1JvdXRlclJlZ2lzdHJ5LmdldEluc3RhbmNlKCkubG9hZFJvdXRlcnMucHVzaChsb2FkUm91dGVyKTtcbiAgICB9O1xuICAgIElPUm91dGVyUmVnaXN0cnkuZ2V0U2F2ZUhhbmRsZXJzID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gSU9Sb3V0ZXJSZWdpc3RyeS5nZXRIYW5kbGVycyh1cmwsICdzYXZlJyk7XG4gICAgfTtcbiAgICBJT1JvdXRlclJlZ2lzdHJ5LmdldExvYWRIYW5kbGVycyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIElPUm91dGVyUmVnaXN0cnkuZ2V0SGFuZGxlcnModXJsLCAnbG9hZCcpO1xuICAgIH07XG4gICAgSU9Sb3V0ZXJSZWdpc3RyeS5nZXRIYW5kbGVycyA9IGZ1bmN0aW9uICh1cmwsIGhhbmRsZXJUeXBlKSB7XG4gICAgICAgIHZhciB2YWxpZEhhbmRsZXJzID0gW107XG4gICAgICAgIHZhciByb3V0ZXJzID0gaGFuZGxlclR5cGUgPT09ICdsb2FkJyA/IHRoaXMuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVycyA6XG4gICAgICAgICAgICB0aGlzLmdldEluc3RhbmNlKCkuc2F2ZVJvdXRlcnM7XG4gICAgICAgIHJvdXRlcnMuZm9yRWFjaChmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHJvdXRlcih1cmwpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWxpZEhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsaWRIYW5kbGVycztcbiAgICB9O1xuICAgIHJldHVybiBJT1JvdXRlclJlZ2lzdHJ5O1xufSgpKTtcbmV4cG9ydHMuSU9Sb3V0ZXJSZWdpc3RyeSA9IElPUm91dGVyUmVnaXN0cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXJfcmVnaXN0cnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRUWVBFX1ZBTFVFX1NJWkVfTUFQID0ge1xuICAgICdmbG9hdDMyJzogNCxcbiAgICAnaW50MzInOiA0LFxuICAgICd1aW50MTYnOiAyLFxuICAgICd1aW50OCc6IDEsXG4gICAgJ2Jvb2wnOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuZnVuY3Rpb24gbG9hZFdlaWdodHNBc0FycmF5QnVmZmVyKGZldGNoVVJMcywgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXF1ZXN0cywgcmVzcG9uc2VzLCBidWZmZXJzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0cyA9IGZldGNoVVJMcy5tYXAoZnVuY3Rpb24gKGZldGNoVVJMKSB7IHJldHVybiBmZXRjaChmZXRjaFVSTCwgcmVxdWVzdE9wdGlvbnMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBQcm9taXNlLmFsbChyZXF1ZXN0cyldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIFByb21pc2UuYWxsKHJlc3BvbnNlcy5tYXAoZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpOyB9KSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVycyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBidWZmZXJzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRXZWlnaHRzQXNBcnJheUJ1ZmZlciA9IGxvYWRXZWlnaHRzQXNBcnJheUJ1ZmZlcjtcbmZ1bmN0aW9uIGxvYWRXZWlnaHRzKG1hbmlmZXN0LCBmaWxlUGF0aFByZWZpeCwgd2VpZ2h0TmFtZXMsIHJlcXVlc3RPcHRpb25zKSB7XG4gICAgaWYgKGZpbGVQYXRoUHJlZml4ID09PSB2b2lkIDApIHsgZmlsZVBhdGhQcmVmaXggPSAnJzsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyb3VwSW5kaWNlc1RvRmV0Y2hNYXAsIGdyb3VwV2VpZ2h0c1RvRmV0Y2gsIHdlaWdodHNGb3VuZCwgYWxsTWFuaWZlc3RXZWlnaHROYW1lcywgd2VpZ2h0c05vdEZvdW5kLCBncm91cEluZGljZXNUb0ZldGNoLCBmZXRjaFVybHMsIGJ1ZmZlcnMsIHdlaWdodHNUZW5zb3JNYXAsIGJ1ZmZlckluZGV4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBncm91cEluZGljZXNUb0ZldGNoTWFwID0gbWFuaWZlc3QubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBXZWlnaHRzVG9GZXRjaCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzRm91bmQgPSB3ZWlnaHROYW1lcyAhPSBudWxsID8gd2VpZ2h0TmFtZXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICBhbGxNYW5pZmVzdFdlaWdodE5hbWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0LmZvckVhY2goZnVuY3Rpb24gKG1hbmlmZXN0R3JvdXBDb25maWcsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdEdyb3VwQ29uZmlnLndlaWdodHMuZm9yRWFjaChmdW5jdGlvbiAod2VpZ2h0c0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0R0eXBlID0gKCdxdWFudGl6YXRpb24nIGluIHdlaWdodHNFbnRyeSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzRW50cnkucXVhbnRpemF0aW9uLmR0eXBlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c0VudHJ5LmR0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRzQnl0ZXMgPSB0eXBlc18xLkRUWVBFX1ZBTFVFX1NJWkVfTUFQW3Jhd0R0eXBlXSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh3ZWlnaHRzRW50cnkuc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnF1ZXVlV2VpZ2h0c0ZvckZldGNoaW5nRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kaWNlc1RvRmV0Y2hNYXBbZ3JvdXBJbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBXZWlnaHRzVG9GZXRjaFtncm91cEluZGV4XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cFdlaWdodHNUb0ZldGNoW2dyb3VwSW5kZXhdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBXZWlnaHRzVG9GZXRjaFtncm91cEluZGV4XS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0RW50cnk6IHdlaWdodHNFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiBncm91cE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVCeXRlczogd2VpZ2h0c0J5dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlaWdodE5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAod2VpZ2h0TmFtZSwgd2VpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWlnaHROYW1lID09PSB3ZWlnaHRzRW50cnkubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVucXVldWVXZWlnaHRzRm9yRmV0Y2hpbmdGbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNGb3VuZFt3ZWlnaHRJbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVucXVldWVXZWlnaHRzRm9yRmV0Y2hpbmdGbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxNYW5pZmVzdFdlaWdodE5hbWVzLnB1c2god2VpZ2h0c0VudHJ5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwT2Zmc2V0ICs9IHdlaWdodHNCeXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3ZWlnaHRzRm91bmQuZXZlcnkoZnVuY3Rpb24gKGZvdW5kKSB7IHJldHVybiBmb3VuZDsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNOb3RGb3VuZCA9IHdlaWdodE5hbWVzLmZpbHRlcihmdW5jdGlvbiAod2VpZ2h0LCBpKSB7IHJldHVybiAhd2VpZ2h0c0ZvdW5kW2ldOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHdlaWdodHMgaW4gbWFuaWZlc3Qgd2l0aCBuYW1lczogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3ZWlnaHRzTm90Rm91bmQuam9pbignLCAnKSArIFwiLiBcXG5cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWFuaWZlc3QgSlNPTiBoYXMgd2VpZ2h0cyB3aXRoIG5hbWVzOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbE1hbmlmZXN0V2VpZ2h0TmFtZXMuam9pbignLCAnKSArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRpY2VzVG9GZXRjaCA9IGdyb3VwSW5kaWNlc1RvRmV0Y2hNYXAucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgc2hvdWxkRmV0Y2gsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hVcmxzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kaWNlc1RvRmV0Y2guZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3RbaV0ucGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmV0Y2hVcmwgPSBmaWxlUGF0aFByZWZpeCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghZmlsZVBhdGhQcmVmaXguZW5kc1dpdGgoJy8nKSA/ICcvJyA6ICcnKSArIGZpbGVwYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoVXJscy5wdXNoKGZldGNoVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBsb2FkV2VpZ2h0c0FzQXJyYXlCdWZmZXIoZmV0Y2hVcmxzLCByZXF1ZXN0T3B0aW9ucyldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVycyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c1RlbnNvck1hcCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kaWNlc1RvRmV0Y2guZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bUJ1ZmZlcnMgPSBtYW5pZmVzdFtpXS5wYXRocy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBCeXRlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBudW1CdWZmZXJzOyBpXzErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQnl0ZXMgKz0gYnVmZmVyc1tidWZmZXJJbmRleE9mZnNldCArIGlfMV0uYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihncm91cEJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cEJ5dGVCdWZmZXIgPSBuZXcgVWludDhBcnJheShncm91cEJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV8yID0gMDsgaV8yIDwgbnVtQnVmZmVyczsgaV8yKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyc1tidWZmZXJJbmRleE9mZnNldCArIGlfMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQnl0ZUJ1ZmZlci5zZXQoYnVmZmVyLCBncm91cEJ1ZmZlck9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBCdWZmZXJPZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0c0VudHJpZXMgPSBncm91cFdlaWdodHNUb0ZldGNoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c0VudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAod2VpZ2h0c0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVCdWZmZXIgPSBncm91cEJ1ZmZlci5zbGljZSh3ZWlnaHRzRW50cnkuZ3JvdXBPZmZzZXQsIHdlaWdodHNFbnRyeS5ncm91cE9mZnNldCArIHdlaWdodHNFbnRyeS5zaXplQnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlZEFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdHlwZSA9IHdlaWdodHNFbnRyeS5tYW5pZmVzdEVudHJ5LmR0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgncXVhbnRpemF0aW9uJyBpbiB3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uXzEgPSB3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeS5xdWFudGl6YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWFudGl6YXRpb25fMS5kdHlwZSAhPT0gJ3VpbnQ4JyAmJiBxdWFudGl6YXRpb25fMS5kdHlwZSAhPT0gJ3VpbnQxNicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlaWdodCBcIiArIHdlaWdodHNFbnRyeS5tYW5pZmVzdEVudHJ5Lm5hbWUgKyBcIiBoYXMgdW5rbm93biBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwicXVhbnRpemF0aW9uIGR0eXBlIFwiICsgcXVhbnRpemF0aW9uXzEuZHR5cGUgKyBcIi5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWFudGl6ZWRBcnJheSA9IChxdWFudGl6YXRpb25fMS5kdHlwZSA9PT0gJ3VpbnQ4JykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnl0ZUJ1ZmZlcikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFVpbnQxNkFycmF5KGJ5dGVCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheSA9IEZsb2F0MzJBcnJheS5mcm9tKHF1YW50aXplZEFycmF5LCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAqIHF1YW50aXphdGlvbl8xLnNjYWxlICsgcXVhbnRpemF0aW9uXzEubWluOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheSA9IEludDMyQXJyYXkuZnJvbShxdWFudGl6ZWRBcnJheSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE1hdGgucm91bmQodiAqIHF1YW50aXphdGlvbl8xLnNjYWxlICsgcXVhbnRpemF0aW9uXzEubWluKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgXCIgKyB3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeS5uYW1lICsgXCIgaGFzIGEgZHR5cGUgbm90IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJzdXBwb3J0ZWQgYnkgcXVhbnRpemF0aW9uOiBcIiArIGR0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShieXRlQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBJbnQzMkFycmF5KGJ5dGVCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IFwiICsgd2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkubmFtZSArIFwiIGhhcyB1bmtub3duIGR0eXBlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHR5cGUgKyBcIi5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHROYW1lID0gd2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0c1RlbnNvck1hcFt3ZWlnaHROYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSB3ZWlnaHQgd2l0aCBuYW1lIFwiICsgd2VpZ2h0TmFtZSArIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBsZWFzZSBtYWtlIHN1cmUgd2VpZ2h0cyBuYW1lcyBhcmUgdW5pcXVlIGluIHRoZSBtYW5pZmVzdCBKU09OLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c1RlbnNvck1hcFt3ZWlnaHROYW1lXSA9IG9wc18xLnRlbnNvcih0eXBlZEFycmF5LCB3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeS5zaGFwZSwgd2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkuZHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleE9mZnNldCArPSBudW1CdWZmZXJzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB3ZWlnaHRzVGVuc29yTWFwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRXZWlnaHRzID0gbG9hZFdlaWdodHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWlnaHRzX2xvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKFwic2VlZHJhbmRvbVwiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGF4aXNfdXRpbCA9IHJlcXVpcmUoXCIuLi9vcHMvYXhpc191dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uL29wcy9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuLi9vcHMvY29uY2F0X3V0aWxcIik7XG52YXIgZXJmX3V0aWwgPSByZXF1aXJlKFwiLi4vb3BzL2VyZl91dGlsXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgc2VsdV91dGlsID0gcmVxdWlyZShcIi4uL29wcy9zZWx1X3V0aWxcIik7XG52YXIgc2xpY2VfdXRpbF8xID0gcmVxdWlyZShcIi4uL29wcy9zbGljZV91dGlsXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYmFja2VuZF91dGlsID0gcmVxdWlyZShcIi4vYmFja2VuZF91dGlsXCIpO1xudmFyIE1hdGhCYWNrZW5kQ1BVID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRoQmFja2VuZENQVSgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5maXJzdFVzZSA9IHRydWU7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZGF0YUlkLCBzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RVc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RVc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX05PREUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnSGkgdGhlcmUg8J+Riy4gTG9va3MgbGlrZSB5b3UgYXJlIHJ1bm5pbmcgVGVuc29yRmxvdy5qcyBpbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ05vZGUuanMuIFRvIHNwZWVkIHRoaW5ncyB1cCBkcmFtYXRpY2FsbHksIGluc3RhbGwgb3VyIG5vZGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZW5kLCB3aGljaCBiaW5kcyB0byBUZW5zb3JGbG93IEMrKywgYnkgcnVubmluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ25wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICdvciBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUtZ3B1IGlmIHlvdSBoYXZlIENVREEuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVGhlbiBjYWxsIHJlcXVpcmUoXFwndGVuc29yZmxvdy90ZmpzLW5vZGVcXCcpOyAoLWdwdSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3N1ZmZpeCBmb3IgQ1VEQSkgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgcHJvZ3JhbS4gJyArXG4gICAgICAgICAgICAgICAgICAgICdWaXNpdCBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLW5vZGUgZm9yIG1vcmUgZGV0YWlscy4nICtcbiAgICAgICAgICAgICAgICAgICAgJ1xcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIGJ1ZmZlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhLnNldChkYXRhSWQsIG51bGwpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGFJZCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRoQmFja2VuZENQVS53cml0ZSgpOiB2YWx1ZXMgY2FuIG5vdCBiZSBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgIHRoaXMuZGF0YS5zZXQoZGF0YUlkLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmZyb21QaXhlbHMgPSBmdW5jdGlvbiAocGl4ZWxzLCBudW1DaGFubmVscykge1xuICAgICAgICBpZiAocGl4ZWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0aEJhY2tlbmRDUFUud3JpdGVQaXhlbHMoKTogcGl4ZWxzIGNhbiBub3QgYmUgbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxzO1xuICAgICAgICBpZiAocGl4ZWxzIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICB2YWxzID0gcGl4ZWxzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGl4ZWxzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhbHMgPSBwaXhlbHMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgICAgICAgIC5nZXRJbWFnZURhdGEoMCwgMCwgcGl4ZWxzLndpZHRoLCBwaXhlbHMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBpeGVscyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHxcbiAgICAgICAgICAgIHBpeGVscyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHJlYWQgcGl4ZWxzIGZyb20gSFRNTEltYWdlRWxlbWVudCBvdXRzaWRlICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhlIGJyb3dzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHBpeGVscy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHBpeGVscy5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShwaXhlbHMsIDAsIDAsIHBpeGVscy53aWR0aCwgcGl4ZWxzLmhlaWdodCk7XG4gICAgICAgICAgICB2YWxzID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgICAgICAgIC5nZXRJbWFnZURhdGEoMCwgMCwgcGl4ZWxzLndpZHRoLCBwaXhlbHMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIGlzIG9mIHVua25vd24gdHlwZTogXCIgKyBwaXhlbHMuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlcztcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSA0KSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheSh2YWxzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBudW1QaXhlbHMgPSBwaXhlbHMud2lkdGggKiBwaXhlbHMuaGVpZ2h0O1xuICAgICAgICAgICAgdmFsdWVzID0gbmV3IEludDMyQXJyYXkobnVtUGl4ZWxzICogbnVtQ2hhbm5lbHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1QaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgbnVtQ2hhbm5lbHM7ICsrY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaSAqIG51bUNoYW5uZWxzICsgY2hhbm5lbF0gPSB2YWxzW2kgKiA0ICsgY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IFtwaXhlbHMuaGVpZ2h0LCBwaXhlbHMud2lkdGgsIG51bUNoYW5uZWxzXTtcbiAgICAgICAgcmV0dXJuIG9wc18xLnRlbnNvcjNkKHZhbHVlcywgb3V0U2hhcGUsICdpbnQzMicpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVhZFN5bmMoZGF0YUlkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVhZFN5bmMgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YShkYXRhSWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldChkYXRhSWQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRpc3Bvc2VEYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0LCBrZXJuZWxNcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIGYoKTtcbiAgICAgICAgICAgICAgICBrZXJuZWxNcyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGtlcm5lbE1zOiBrZXJuZWxNcyB9XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tZW1vcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnJlbGlhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudGhyb3dJZk5vRGF0YSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNQVSBiYWNrZW5kOiBObyBkYXRhIGZvdW5kIGZvciB0aGlzIHRlbnNvci4gXCIgK1xuICAgICAgICAgICAgICAgIFwiRGlkIHlvdSBjaGFuZ2UgeW91ciBiYWNrZW5kIGluIHRoZSBtaWRkbGUgb2YgdGhlIHByb2dyYW0/IFwiICtcbiAgICAgICAgICAgICAgICBcIk5ldyBiYWNrZW5kcyBjYW4ndCB1c2UgVGVuc29ycyBjcmVhdGVkIHdpdGggcHJldmlvdXMgYmFja2VuZHNcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gb3BzLmJ1ZmZlcihzaXplLCB4LmR0eXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gYnVmZmVyLmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgeExvYyA9IGxvYy5tYXAoZnVuY3Rpb24gKGlkeCwgaikgeyByZXR1cm4gaWR4ICsgYmVnaW5bal07IH0pO1xuICAgICAgICAgICAgYnVmZmVyLnNldC5hcHBseShidWZmZXIsIFt4LmdldC5hcHBseSh4LCB4TG9jKV0uY29uY2F0KGxvYykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXIudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zdHJpZGVkU2xpY2UgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIGVuZCwgc3RyaWRlcywgYmVnaW5NYXNrLCBlbmRNYXNrKSB7XG4gICAgICAgIHZhciBfYSA9IHNsaWNlX3V0aWxfMS5nZXRTdHJpZGVkU2xpY2VkSW5mbyh4LnNoYXBlLCBiZWdpbiwgZW5kLCBzdHJpZGVzLCBiZWdpbk1hc2ssIGVuZE1hc2spLCBiZWdpbkluZGV4ID0gX2FbMF0sIHNpemUgPSBfYVsxXTtcbiAgICAgICAgaWYgKHNpemUuc29tZShmdW5jdGlvbiAoYXhpcykgeyByZXR1cm4gYXhpcyA9PT0gMDsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHMudGVuc29yKFtdLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gb3BzLmJ1ZmZlcihzaXplLCB4LmR0eXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gYnVmZmVyLmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgbmV3TG9jID0gbmV3IEFycmF5KGxvYy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdMb2MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdMb2Nbal0gPSBsb2Nbal0gKiBzdHJpZGVzW2pdICsgYmVnaW5JbmRleFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQuYXBwbHkoYnVmZmVyLCBbeC5nZXQuYXBwbHkoeCwgbmV3TG9jKV0uY29uY2F0KGxvYykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXIudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG9wcy5idWZmZXIoeC5zaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciB4QnVmZmVyID0geC5idWZmZXIoKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIG91dExvYyA9IGJ1ZmZlci5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIGluTG9jID0gb3V0TG9jLnNsaWNlKCk7XG4gICAgICAgICAgICBheGlzLmZvckVhY2goZnVuY3Rpb24gKGF4KSB7IHJldHVybiBpbkxvY1theF0gPSB4LnNoYXBlW2F4XSAtIDEgLSBpbkxvY1theF07IH0pO1xuICAgICAgICAgICAgYnVmZmVyLnNldC5hcHBseShidWZmZXIsIFt4QnVmZmVyLmdldC5hcHBseSh4QnVmZmVyLCBpbkxvYyldLmNvbmNhdChvdXRMb2MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXIudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgMSk7XG4gICAgICAgIHZhciBidWZmZXIgPSBvcHMuYnVmZmVyKG91dFNoYXBlLCBhLmR0eXBlKTtcbiAgICAgICAgaWYgKGEuc2hhcGVbMF0gPT09IDEgJiYgYi5zaGFwZVswXSA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGFWYWxzID0gYS5kYXRhU3luYygpO1xuICAgICAgICAgICAgdmFyIGJWYWxzID0gYi5kYXRhU3luYygpO1xuICAgICAgICAgICAgdmFyIHZhbHMgPSBidWZmZXIudmFsdWVzO1xuICAgICAgICAgICAgdmFscy5zZXQoYVZhbHMsIDApO1xuICAgICAgICAgICAgdmFscy5zZXQoYlZhbHMsIGEuc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnRvVGVuc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRTaGFwZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGEuc2hhcGVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoYS5nZXQoaSwgaiksIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLnNoYXBlWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0KGIuZ2V0KGksIGopLCBpLCBqICsgYS5zaGFwZVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KG9wcy5zY2FsYXIoLTEpLCB4KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSksIGZ1bmN0aW9uIChhVmFsdWUsIGJWYWx1ZSkgeyByZXR1cm4gYVZhbHVlICsgYlZhbHVlOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBhVmFsdWUgLSBiVmFsdWU7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBNYXRoLnBvdyhhVmFsdWUsIGJWYWx1ZSk7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1hdE11bCA9IGZ1bmN0aW9uIChhLCBiLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKSB7XG4gICAgICAgIHZhciBzaGFyZWREaW0gPSB0cmFuc3Bvc2VBID8gYS5zaGFwZVswXSA6IGEuc2hhcGVbMV07XG4gICAgICAgIHZhciBsZWZ0RGltID0gdHJhbnNwb3NlQSA/IGEuc2hhcGVbMV0gOiBhLnNoYXBlWzBdO1xuICAgICAgICB2YXIgcmlnaHREaW0gPSB0cmFuc3Bvc2VCID8gYi5zaGFwZVswXSA6IGIuc2hhcGVbMV07XG4gICAgICAgIHZhciBhVmFsdWVzID0gYS5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIF9hID0gdHJhbnNwb3NlQSA/IFsxLCBhLnN0cmlkZXNbMF1dIDogW2Euc3RyaWRlc1swXSwgMV0sIGFPdXRlclN0ZXAgPSBfYVswXSwgYUlubmVyU3RlcCA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSB0cmFuc3Bvc2VCID8gW2Iuc3RyaWRlc1swXSwgMV0gOiBbMSwgYi5zdHJpZGVzWzBdXSwgYk91dGVyU3RlcCA9IF9iWzBdLCBiSW5uZXJTdGVwID0gX2JbMV07XG4gICAgICAgIHZhciBhT3V0ZXJFbmQgPSBsZWZ0RGltICogYU91dGVyU3RlcDtcbiAgICAgICAgdmFyIGJPdXRlckVuZCA9IHJpZ2h0RGltICogYk91dGVyU3RlcDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVmdERpbSAqIHJpZ2h0RGltKTtcbiAgICAgICAgdmFyIHJlc3VsdEluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgYU91dGVyID0gMDsgYU91dGVyIDwgYU91dGVyRW5kOyBhT3V0ZXIgKz0gYU91dGVyU3RlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgYk91dGVyID0gMDsgYk91dGVyIDwgYk91dGVyRW5kOyBiT3V0ZXIgKz0gYk91dGVyU3RlcCkge1xuICAgICAgICAgICAgICAgIHZhciBhSW5uZXIgPSBhT3V0ZXI7XG4gICAgICAgICAgICAgICAgdmFyIGJJbm5lciA9IGJPdXRlcjtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNoYXJlZERpbTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBhVmFsdWVzW2FJbm5lcl0gKiBiVmFsdWVzW2JJbm5lcl07XG4gICAgICAgICAgICAgICAgICAgIGFJbm5lciArPSBhSW5uZXJTdGVwO1xuICAgICAgICAgICAgICAgICAgICBiSW5uZXIgKz0gYklubmVyU3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdEluZGV4KytdID0gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHMudGVuc29yMmQocmVzdWx0LCBbbGVmdERpbSwgcmlnaHREaW1dKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBhVmFsdWUgKiBiVmFsdWU7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlYWxEaXZpZGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgb3AgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAvIGI7IH07XG4gICAgICAgIHZhciBvdXRwdXREdHlwZSA9ICdmbG9hdDMyJztcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCBvdXRwdXREdHlwZSwgb3ApO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmZsb29yRGl2ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIG9wID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGguZmxvb3IoYSAvIGIpOyB9O1xuICAgICAgICB2YXIgb3V0cHV0RHR5cGUgPSAnaW50MzInO1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIG91dHB1dER0eXBlLCBvcCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdER0eXBlID0gdHlwZXMudXBjYXN0VHlwZSh4LmR0eXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhvdXRTaGFwZSwgcmVzdWx0RHR5cGUpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFyZ01pbiA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHZhciBheGVzID0gW2F4aXNdO1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01pbicsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKG91dFNoYXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1pbiA9IGFWYWxzW29mZnNldF07XG4gICAgICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWluSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hcmdNYXggPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB2YXIgYXhlcyA9IFtheGlzXTtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNYXgnLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhvdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBtYXggPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICAgICAgdmFyIG1heEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IG1heEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY3Vtc3VtID0gZnVuY3Rpb24gKHgsIGF4aXMsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSkge1xuICAgICAgICBpZiAoYXhpcyAhPT0geC5yYW5rIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFja2VuZC5jdW1zdW0gaW4gQ1BVIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPVwiICsgKHgucmFuayAtIDEpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgYXhpcz1cIiArIGF4aXMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0RHR5cGUgPSB0eXBlcy51cGNhc3RUeXBlKHguZHR5cGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKHguc2hhcGUsIHJlc3VsdER0eXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgZmluYWxEaW0gPSB4LnNoYXBlW3gucmFuayAtIDFdO1xuICAgICAgICB2YXIgaW5kZXhBZGp1c3RlciA9IHJldmVyc2UgP1xuICAgICAgICAgICAgZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIGkgKyBmaW5hbERpbSAtIGogLSAxOyB9IDpcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpLCBqKSB7IHJldHVybiBpICsgajsgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFscy5sZW5ndGg7IGkgKz0gZmluYWxEaW0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmluYWxEaW07IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBpbmRleEFkanVzdGVyKGksIGopO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHNbaWR4XSA9IGV4Y2x1c2l2ZSA/IDAgOiBhVmFsc1tpZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZJZHggPSBpbmRleEFkanVzdGVyKGksIGogLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsc1tpZHhdID0gZXhjbHVzaXZlID8gYVZhbHNbcHJldklkeF0gKyB2YWxzW3ByZXZJZHhdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFWYWxzW2lkeF0gKyB2YWxzW3ByZXZJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFWYWwgPT09IGJWYWwpID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFWYWwgIT09IGJWYWwpID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoYVZhbCA8IGJWYWwpID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxlc3NFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChhVmFsIDw9IGJWYWwpID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoYVZhbCA+IGJWYWwpID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmdyZWF0ZXJFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChhVmFsID49IGJWYWwpID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvZ2ljYWxOb3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEludDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSB2YWx1ZXNbaV0gPyAwIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9LCAnYm9vbCcpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhVmFsICYmIGJWYWw7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvZ2ljYWxPciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFWYWwgfHwgYlZhbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBhLCBiLCBkdHlwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gY29uZGl0aW9uLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFsdWVzID0gYS5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhhLnNoYXBlLCBkdHlwZSk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGNvbmRpdGlvbi5yYW5rID09PSAwIHx8IGNvbmRpdGlvbi5yYW5rID4gMSB8fCBhLnJhbmsgPT09IDEgP1xuICAgICAgICAgICAgMSA6XG4gICAgICAgICAgICBhLnNoYXBlWzFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvZmZzZXQ7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzW2luZGV4KytdID0gYVZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1tpbmRleCsrXSA9IGJWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudG9wS1ZhbHVlcyA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcEsoeCwgaykudmFsdWVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRvcEtJbmRpY2VzID0gZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wSyh4LCBrKS5pbmRpY2VzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRvcEsgPSBmdW5jdGlvbiAoeCwgaykge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgdmFsdWVzQW5kSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzQW5kSW5kaWNlcy5wdXNoKHsgdmFsdWU6IHZhbHVlc1tpXSwgaW5kZXg6IGkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzQW5kSW5kaWNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdG9wa1ZhbHVlcyA9IHV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZSh4LmR0eXBlLCBrKTtcbiAgICAgICAgdmFyIHRvcGtJbmRpY2VzID0gbmV3IEludDMyQXJyYXkoayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgICAgICB0b3BrVmFsdWVzW2ldID0gdmFsdWVzQW5kSW5kaWNlc1tpXS52YWx1ZTtcbiAgICAgICAgICAgIHRvcGtJbmRpY2VzW2ldID0gdmFsdWVzQW5kSW5kaWNlc1tpXS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWVzOiBvcHMudGVuc29yMWQodG9wa1ZhbHVlcywgeC5kdHlwZSksXG4gICAgICAgICAgICBpbmRpY2VzOiBvcHMudGVuc29yMWQodG9wa0luZGljZXMsICdpbnQzMicpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtaW4nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhvdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBtaW4gPSBhVmFsc1swXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5taW5pbXVtID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCBhLmR0eXBlLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkgeyByZXR1cm4gTWF0aC5taW4oYVZhbCwgYlZhbCk7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIHZhciByZW0gPSBhVmFsICUgYlZhbDtcbiAgICAgICAgICAgIGlmICgoYVZhbCA8IDAgJiYgYlZhbCA8IDApIHx8IChhVmFsID49IDAgJiYgYlZhbCA+PSAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlbSArIGJWYWwpICUgYlZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtYXgnLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhvdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBtYXggPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1heGltdW0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIGEuZHR5cGUsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7IHJldHVybiBNYXRoLm1heChhVmFsLCBiVmFsKTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIGEuZHR5cGUsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGFWYWwgLSBiVmFsO1xuICAgICAgICAgICAgcmV0dXJuIGRpZmYgKiBkaWZmO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmNlaWwodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5mbG9vcih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXNbaV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gTWF0aC5mbG9vcih2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSAtIGJhc2UgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmZsb29yKHZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXNbaV0gLSBiYXNlID4gMC41KSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5jZWlsKHZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZSAlIDIuMCA9PT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IGJhc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBiYXNlICsgMS4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguZXhwKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZXhwbTEgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguZXhwbTEodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGgubG9nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5sb2cxcCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5sb2cxcCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yc3FydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gMSAvIE1hdGguc3FydCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSB2YWx1ZSAqIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlY2lwcm9jYWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IDEgLyB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXMgPSBvcHMuemVyb3MoeC5zaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciByZXNWYWxzID0gcmVzLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBpblZhbHMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5WYWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXNWYWxzW2ldID0gTWF0aC5tYXgoMCwgaW5WYWxzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gKE1hdGguZXhwKHYpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZWx1RGVyID0gZnVuY3Rpb24gKGR5LCB5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB5LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBkeVZhbHVlcyA9IGR5LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBkeVZhbHVlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IGR5VmFsdWVzW2ldICogKHYgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHNjYWxlQWxwaGEgPSBzZWx1X3V0aWwuU0VMVV9TQ0FMRUFMUEhBO1xuICAgICAgICB2YXIgc2NhbGUgPSBzZWx1X3V0aWwuU0VMVV9TQ0FMRTtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHNjYWxlICogdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHNjYWxlQWxwaGEgKiAoTWF0aC5leHAodikgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKHgsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYWJzKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuaW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSwgJ2ludDMyJyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSAxIC8gKDEgKyBNYXRoLmV4cCgtdmFsdWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc29mdHBsdXMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZXBzaWxvbiA9IDEuMTkyMDkyODk1NTA3ODEyNWUtNztcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IE1hdGgubG9nKGVwc2lsb24pICsgMi4wO1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHRvb0xhcmdlID0gdmFsdWVzW2ldID4gLXRocmVzaG9sZDtcbiAgICAgICAgICAgIHZhciB0b29TbWFsbCA9IHZhbHVlc1tpXSA8IHRocmVzaG9sZDtcbiAgICAgICAgICAgIHZhciBleHBYID0gTWF0aC5leHAodmFsdWVzW2ldKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHBYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9vTGFyZ2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBNYXRoLmxvZygxLjAgKyBleHBYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zaW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5zaW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5jb3ModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50YW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC50YW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hc2luID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYXNpbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFjb3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hY29zKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYXRhbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmF0YW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hdGFuMiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBNYXRoLmF0YW4yKGFWYWx1ZSwgYlZhbHVlKTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2luaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnNpbmgodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb3NoID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguY29zaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdXRpbC50YW5oKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYXNpbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hc2luaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFjb3NoID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYWNvc2godmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hdGFuaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmF0YW5oKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZXJmID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHAgPSBlcmZfdXRpbC5FUkZfUDtcbiAgICAgICAgdmFyIGExID0gZXJmX3V0aWwuRVJGX0ExO1xuICAgICAgICB2YXIgYTIgPSBlcmZfdXRpbC5FUkZfQTI7XG4gICAgICAgIHZhciBhMyA9IGVyZl91dGlsLkVSRl9BMztcbiAgICAgICAgdmFyIGE0ID0gZXJmX3V0aWwuRVJGX0E0O1xuICAgICAgICB2YXIgYTUgPSBlcmZfdXRpbC5FUkZfQTU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIHZhciB0ID0gMS4wIC8gKDEuMCArIHAgKiB2KTtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IDEuMCAtXG4gICAgICAgICAgICAgICAgKCgoKChhNSAqIHQgKyBhNCkgKiB0KSArIGEzKSAqIHQgKyBhMikgKiB0ICsgYTEpICogdCAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZXhwKC12ICogdik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDA7IH1cbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2YWx1ZSA+IDAgPyAxIDogYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY29udjJkID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciB5ID0gb3BzLmJ1ZmZlcihjb252SW5mby5vdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBjb252SW5mby5vdXRDaGFubmVsczsgKytkMikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCBjb252SW5mby5vdXRIZWlnaHQ7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBjb252SW5mby5zdHJpZGVIZWlnaHQgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgY29udkluZm8ub3V0V2lkdGg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyB3UisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhSID0geFJDb3JuZXIgKyB3UiAqIGRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gY29udkluZm8uaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEMgPSB4Q0Nvcm5lciArIHdDICogZGlsYXRpb25XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBjb252SW5mby5pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0geC5nZXQoYiwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZmlsdGVyLmdldCh3Uiwgd0MsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeS5zZXQoZG90UHJvZCwgYiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHkudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb252MmREZXJJbnB1dCA9IGZ1bmN0aW9uIChkeSwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgZHggPSBvcHMuYnVmZmVyKGNvbnZJbmZvLmluU2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHZhciBkeFZhbHVlcyA9IGR4LnZhbHVlcztcbiAgICAgICAgdmFyIF9hID0gZHguc3RyaWRlcywgZHhTMCA9IF9hWzBdLCBkeFMxID0gX2FbMV0sIGR4UzIgPSBfYVsyXTtcbiAgICAgICAgdmFyIGR5VmFsdWVzID0gZHkuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIF9iID0gZHkuc3RyaWRlcywgZHlTMCA9IF9iWzBdLCBkeVMxID0gX2JbMV0sIGR5UzIgPSBfYlsyXTtcbiAgICAgICAgdmFyIGZsdFZhbHVlcyA9IGZpbHRlci5kYXRhU3luYygpO1xuICAgICAgICB2YXIgX2MgPSBmaWx0ZXIuc3RyaWRlcywgZmx0UzAgPSBfY1swXSwgZmx0UzEgPSBfY1sxXSwgZmx0UzIgPSBfY1syXTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnZJbmZvLmJhdGNoU2l6ZSwgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoLCBpbkNoYW5uZWxzID0gY29udkluZm8uaW5DaGFubmVscywgaW5IZWlnaHQgPSBjb252SW5mby5pbkhlaWdodCwgaW5XaWR0aCA9IGNvbnZJbmZvLmluV2lkdGgsIG91dENoYW5uZWxzID0gY29udkluZm8ub3V0Q2hhbm5lbHMsIG91dEhlaWdodCA9IGNvbnZJbmZvLm91dEhlaWdodCwgb3V0V2lkdGggPSBjb252SW5mby5vdXRXaWR0aCwgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgdG9wUGFkID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgbGVmdFBhZCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IDA7IHhSIDwgaW5IZWlnaHQ7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geFIgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4UkNvcm5lciAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihvdXRIZWlnaHQsIChmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcikgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IDA7IHhDIDwgaW5XaWR0aDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geEMgLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhDQ29ybmVyIC8gc3RyaWRlV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKG91dFdpZHRoLCAoZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcikgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHhSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geVIgKiBzdHJpZGVIZWlnaHQgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHhDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHlDICogc3RyaWRlV2lkdGggLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5T2Zmc2V0ID0gZHlTMCAqIGIgKyBkeVMxICogeVIgKyBkeVMyICogeUM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbHRPZmZzZXQgPSBmbHRTMCAqIChmaWx0ZXJIZWlnaHQgLSAxIC0gd1IpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdFMxICogKGZpbHRlcldpZHRoIC0gMSAtIHdDKSArIGZsdFMyICogZDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBvdXRDaGFubmVsczsgKytkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gZHlWYWx1ZXNbZHlPZmZzZXQgKyBkMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZmx0VmFsdWVzW2ZsdE9mZnNldCArIGQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkeFZhbHVlc1tkeFMwICogYiArIGR4UzEgKiB4UiArIGR4UzIgKiB4QyArIGQxXSA9IGRvdFByb2Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR4LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyID0gZnVuY3Rpb24gKHgsIGR5LCBjb252SW5mbykge1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBkVyA9IG9wcy5idWZmZXIoY29udkluZm8uZmlsdGVyU2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHZhciBsZWZ0UGFkID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgdG9wUGFkID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7ICsrd1IpIHtcbiAgICAgICAgICAgIHZhciB5Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgodG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihjb252SW5mby5vdXRIZWlnaHQsIChjb252SW5mby5pbkhlaWdodCArIHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKHZhciB3QyA9IDA7IHdDIDwgZmlsdGVyV2lkdGg7ICsrd0MpIHtcbiAgICAgICAgICAgICAgICB2YXIgeUNNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCkpO1xuICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dFdpZHRoLCAoY29udkluZm8uaW5XaWR0aCArIGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IGNvbnZJbmZvLm91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB5Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFIgPSB3UiArIHlSICogc3RyaWRlSGVpZ2h0IC0gdG9wUGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHlDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEMgPSB3QyArIHlDICogc3RyaWRlV2lkdGggLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSB4LmdldChiLCB4UiwgeEMsIGQxKSAqIGR5LmdldChiLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRXLnNldChkb3RQcm9kLCB3Uiwgd0MsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRXLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBjaE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgdmFyIHkgPSBvcHMuYnVmZmVyKGNvbnZJbmZvLm91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogY29udkluZm8uc3RyaWRlSGVpZ2h0IC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIGNvbnZJbmZvLnN0cmlkZVdpZHRoIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcSA9IDA7IHEgPCBjaE11bDsgKytxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7ICsrd1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhSID0geFJDb3JuZXIgKyB3UiAqIGRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IGNvbnZJbmZvLmluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDA7IHdDIDwgZmlsdGVyV2lkdGg7ICsrd0MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4QyA9IHhDQ29ybmVyICsgd0MgKiBkaWxhdGlvbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBjb252SW5mby5pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldChiLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmaWx0ZXIuZ2V0KHdSLCB3QywgZDEsIHEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5LnNldChkb3RQcm9kLCBiLCB5UiwgeUMsIGQxICogY2hNdWwgKyBxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geS50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0ID0gZnVuY3Rpb24gKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBkeCA9IG9wcy5idWZmZXIoY29udkluZm8uaW5TaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgdmFyIGR4VmFsdWVzID0gZHgudmFsdWVzO1xuICAgICAgICB2YXIgX2EgPSBkeC5zdHJpZGVzLCBkeFMwID0gX2FbMF0sIGR4UzEgPSBfYVsxXSwgZHhTMiA9IF9hWzJdO1xuICAgICAgICB2YXIgZHlWYWx1ZXMgPSBkeS5kYXRhU3luYygpO1xuICAgICAgICB2YXIgX2IgPSBkeS5zdHJpZGVzLCBkeVMwID0gX2JbMF0sIGR5UzEgPSBfYlsxXSwgZHlTMiA9IF9iWzJdO1xuICAgICAgICB2YXIgZmx0VmFsdWVzID0gZmlsdGVyLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBfYyA9IGZpbHRlci5zdHJpZGVzLCBmbHRTMCA9IF9jWzBdLCBmbHRTMSA9IF9jWzFdLCBmbHRTMiA9IF9jWzJdO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29udkluZm8uYmF0Y2hTaXplLCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGgsIGluQ2hhbm5lbHMgPSBjb252SW5mby5pbkNoYW5uZWxzLCBpbkhlaWdodCA9IGNvbnZJbmZvLmluSGVpZ2h0LCBpbldpZHRoID0gY29udkluZm8uaW5XaWR0aCwgb3V0Q2hhbm5lbHMgPSBjb252SW5mby5vdXRDaGFubmVscywgb3V0SGVpZ2h0ID0gY29udkluZm8ub3V0SGVpZ2h0LCBvdXRXaWR0aCA9IGNvbnZJbmZvLm91dFdpZHRoLCBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciB0b3BQYWQgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBsZWZ0UGFkID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgY2hNdWwgPSBvdXRDaGFubmVscyAvIGluQ2hhbm5lbHM7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBpbkNoYW5uZWxzOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSAwOyB4UiA8IGluSGVpZ2h0OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHhSIC0gdG9wUGFkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeFJDb3JuZXIgLyBzdHJpZGVIZWlnaHQpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlSTWF4ID0gTWF0aC5taW4ob3V0SGVpZ2h0LCAoZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSAwOyB4QyA8IGluV2lkdGg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHhDIC0gbGVmdFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4Q0Nvcm5lciAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeUNNYXggPSBNYXRoLm1pbihvdXRXaWR0aCwgKGZpbHRlcldpZHRoICsgeENDb3JuZXIpIC8gc3RyaWRlV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB4Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHlSICogc3RyaWRlSGVpZ2h0IC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSB4Q01pbjsgeUMgPCB5Q01heDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB5QyAqIHN0cmlkZVdpZHRoIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeU9mZnNldCA9IGR5UzAgKiBiICsgZHlTMSAqIHlSICsgZHlTMiAqIHlDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmx0T2Zmc2V0ID0gZmx0UzAgKiAoZmlsdGVySGVpZ2h0IC0gMSAtIHdSKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHRTMSAqIChmaWx0ZXJXaWR0aCAtIDEgLSB3QykgKyBmbHRTMiAqIGQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkbSA9IDA7IGRtIDwgY2hNdWw7ICsrZG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkMiA9IGQxICogY2hNdWwgKyBkbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5VmFsdWVzW2R5T2Zmc2V0ICsgZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZsdFZhbHVlc1tmbHRPZmZzZXQgKyBkbV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZHhWYWx1ZXNbZHhTMCAqIGIgKyBkeFMxICogeFIgKyBkeFMyICogeEMgKyBkMV0gPSBkb3RQcm9kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlciA9IGZ1bmN0aW9uICh4LCBkeSwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgZFcgPSBvcHMuYnVmZmVyKGNvbnZJbmZvLmZpbHRlclNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgbGVmdFBhZCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHRvcFBhZCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgY2hNdWwgPSBjb252SW5mby5vdXRDaGFubmVscyAvIGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7ICsrd1IpIHtcbiAgICAgICAgICAgIHZhciB5Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgodG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihjb252SW5mby5vdXRIZWlnaHQsIChjb252SW5mby5pbkhlaWdodCArIHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKHZhciB3QyA9IDA7IHdDIDwgZmlsdGVyV2lkdGg7ICsrd0MpIHtcbiAgICAgICAgICAgICAgICB2YXIgeUNNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCkpO1xuICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dFdpZHRoLCAoY29udkluZm8uaW5XaWR0aCArIGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IGNvbnZJbmZvLm91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkMSA9IE1hdGgudHJ1bmMoZDIgLyBjaE11bCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkbSA9IGQyICUgY2hNdWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB5Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4UiA9IHdSICsgeVIgKiBzdHJpZGVIZWlnaHQgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSB5Q01pbjsgeUMgPCB5Q01heDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEMgPSB3QyArIHlDICogc3RyaWRlV2lkdGggLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHguZ2V0KGIsIHhSLCB4QywgZDEpICogZHkuZ2V0KGIsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkVy5zZXQoZG90UHJvZCwgd1IsIHdDLCBkMSwgZG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZFcudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50aWxlID0gZnVuY3Rpb24gKHgsIHJlcHMpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gbmV3IEFycmF5KHgucmFuayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1NoYXBlW2ldID0geC5zaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy5idWZmZXIobmV3U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgeEJ1ZiA9IHguYnVmZmVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5ld0xvYyA9IHJlc3VsdC5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTG9jID0gbmV3IEFycmF5KHgucmFuayk7XG4gICAgICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgPCBvcmlnaW5hbExvYy5sZW5ndGg7IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMb2NbaV8xXSA9IG5ld0xvY1tpXzFdICUgeC5zaGFwZVtpXzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsSW5kZXggPSB4QnVmLmxvY1RvSW5kZXgob3JpZ2luYWxMb2MpO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlc1tpXSA9IHhCdWYudmFsdWVzW29yaWdpbmFsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdICsgeC5zaGFwZVtpXSArIHBbMV07IH0pO1xuICAgICAgICB2YXIgc3RhcnQgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBbMF07IH0pO1xuICAgICAgICB2YXIgeEJ1ZmZlciA9IHguYnVmZmVyKCk7XG4gICAgICAgIHZhciBidWZmZXIgPSBvcHMuYnVmZmVyKG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgaWYgKGNvbnN0YW50VmFsdWUgIT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlci52YWx1ZXMuZmlsbChjb25zdGFudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHguc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0geEJ1ZmZlci5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIG91dENvb3JkcyA9IGNvb3Jkcy5tYXAoZnVuY3Rpb24gKGMsIGkpIHsgcmV0dXJuIGMgKyBzdGFydFtpXTsgfSk7XG4gICAgICAgICAgICBidWZmZXIuc2V0LmFwcGx5KGJ1ZmZlciwgW3guZ2V0LmFwcGx5KHgsIGNvb3JkcyldLmNvbmNhdChvdXRDb29yZHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gKHgsIHBlcm0pIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gbmV3IEFycmF5KHgucmFuayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1NoYXBlW2ldID0geC5zaGFwZVtwZXJtW2ldXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzXzEuYnVmZmVyKG5ld1NoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHhCdWYgPSB4LmJ1ZmZlcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHguc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0geEJ1Zi5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIG5ld0xvYyA9IG5ldyBBcnJheShsb2MubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMiA9IDA7IGlfMiA8IG5ld0xvYy5sZW5ndGg7IGlfMisrKSB7XG4gICAgICAgICAgICAgICAgbmV3TG9jW2lfMl0gPSBsb2NbcGVybVtpXzJdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IHJlc3VsdC5sb2NUb0luZGV4KG5ld0xvYyk7XG4gICAgICAgICAgICByZXN1bHQudmFsdWVzW25ld0luZGV4XSA9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZ2F0aGVyID0gZnVuY3Rpb24gKHgsIGluZGljZXMsIGF4aXMpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0geC5zaGFwZS5zbGljZSgpO1xuICAgICAgICB2YXIgaW5kaWNlc1ZhbHVlcyA9IGluZGljZXMuZGF0YVN5bmMoKTtcbiAgICAgICAgbmV3U2hhcGVbYXhpc10gPSBpbmRpY2VzVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wc18xLmJ1ZmZlcihuZXdTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciB4QnVmID0geC5idWZmZXIoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmV3TG9jID0gcmVzdWx0LmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxMb2MgPSBuZXdMb2Muc2xpY2UoKTtcbiAgICAgICAgICAgIG9yaWdpbmFsTG9jW2F4aXNdID0gaW5kaWNlc1ZhbHVlc1tuZXdMb2NbYXhpc11dO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsSW5kZXggPSB4QnVmLmxvY1RvSW5kZXgob3JpZ2luYWxMb2MpO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlc1tpXSA9IHhCdWYudmFsdWVzW29yaWdpbmFsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5wb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvLCBwb29sVHlwZSkge1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciB5ID0gb3BzLmJ1ZmZlcihjb252SW5mby5vdXRTaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogc3RyaWRlSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKGNvbnZJbmZvLmluSGVpZ2h0LCBmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCBjb252SW5mby5vdXRXaWR0aDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBzdHJpZGVXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbihjb252SW5mby5pbldpZHRoLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5NYXhWYWx1ZSA9IChwb29sVHlwZSA9PT0gJ21heCcgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXZnVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KGIsIHhSLCB4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocG9vbFR5cGUgPT09ICdtYXgnICYmIHBpeGVsID4gbWluTWF4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnVmFsdWUgKz0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeS5zZXQocG9vbFR5cGUgPT09ICdhdmcnID8gYXZnVmFsdWUgLyBjb3VudCA6IG1pbk1heFZhbHVlLCBiLCB5UiwgeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb29sKHgsIGNvbnZJbmZvLCAnbWF4Jyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbFBvc2l0aW9ucyA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb25zID0gb3BzLmJ1ZmZlcihjb252SW5mby5vdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogc3RyaWRlSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKGNvbnZJbmZvLmluSGVpZ2h0LCBmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCBjb252SW5mby5vdXRXaWR0aDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBzdHJpZGVXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbihjb252SW5mby5pbldpZHRoLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHhSIC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB4QyAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldChiLCB4UiwgeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9uID0gd1IgKiBmaWx0ZXJXaWR0aCArIHdDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb25zLnNldChtYXhQb3NpdGlvbiwgYiwgeVIsIHlDLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4UG9zaXRpb25zLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCB5LCBjb252SW5mbykge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb25zID0gdGhpcy5tYXhQb29sUG9zaXRpb25zKHgsIGNvbnZJbmZvKTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIGR4ID0gb3BzLmJ1ZmZlcih4LnNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR4UiA9IDA7IGR4UiA8IGNvbnZJbmZvLmluSGVpZ2h0OyArK2R4Uikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkeEMgPSAwOyBkeEMgPCBjb252SW5mby5pbldpZHRoOyArK2R4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UkNvcm5lciA9IGR4UiAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUNDb3JuZXIgPSBkeEMgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeVIgPSAoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBjb252SW5mby5vdXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlDID0gKGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gY29udkluZm8ub3V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlDKSAhPT0gZHlDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4UG9zID0gZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGggLSAxIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9ucy5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyUG9zID0gd1IgKiBmaWx0ZXJXaWR0aCArIHdDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IG1heFBvcyA9PT0gY3VyUG9zID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogbWFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkeC5zZXQoZG90UHJvZCwgYiwgZHhSLCBkeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIGR4ID0gb3BzLmJ1ZmZlcih4LnNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgYXZnTXVsdGlwbGllciA9IDEgLyAoZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGgpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR4UiA9IDA7IGR4UiA8IGNvbnZJbmZvLmluSGVpZ2h0OyArK2R4Uikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkeEMgPSAwOyBkeEMgPCBjb252SW5mby5pbldpZHRoOyArK2R4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UkNvcm5lciA9IGR4UiAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUNDb3JuZXIgPSBkeEMgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeVIgPSAoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBjb252SW5mby5vdXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlDID0gKGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gY29udkluZm8ub3V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlDKSAhPT0gZHlDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGR4LnNldChkb3RQcm9kICogYXZnTXVsdGlwbGllciwgYiwgZHhSLCBkeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiAoeCwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmRfdXRpbC5jYXN0VGVuc29yKHgsIGR0eXBlLCB0aGlzKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24gKHgsIHNoYXBlKSB7XG4gICAgICAgIHJldHVybiBiYWNrZW5kX3V0aWwucmVzaGFwZVRlbnNvcih4LCBzaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYXZnUG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb29sKHgsIGNvbnZJbmZvLCAnYXZnJykudG9GbG9hdCgpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyID0gZnVuY3Rpb24gKHgsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycykge1xuICAgICAgICB2YXIgX2EgPSB4LnNoYXBlLCBiYXRjaCA9IF9hWzBdLCBvbGRIZWlnaHQgPSBfYVsxXSwgb2xkV2lkdGggPSBfYVsyXSwgbnVtQ2hhbm5lbHMgPSBfYVszXTtcbiAgICAgICAgdmFyIG91dHB1dCA9IG9wcy5idWZmZXIoW2JhdGNoLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBudW1DaGFubmVsc10sIHguZHR5cGUpO1xuICAgICAgICB2YXIgZWZmZWN0aXZlSW5wdXRTaXplID0gW1xuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdIZWlnaHQgPiAxKSA/IG9sZEhlaWdodCAtIDEgOiBvbGRIZWlnaHQsXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld1dpZHRoID4gMSkgPyBvbGRXaWR0aCAtIDEgOiBvbGRXaWR0aFxuICAgICAgICBdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3V0cHV0U2l6ZSA9IFtcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3SGVpZ2h0ID4gMSkgPyBuZXdIZWlnaHQgLSAxIDogbmV3SGVpZ2h0LFxuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gbmV3V2lkdGggLSAxIDogbmV3V2lkdGhcbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaDsgYisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG5ld0hlaWdodDsgcisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuZXdXaWR0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgbnVtQ2hhbm5lbHM7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUZyYWNSb3cgPSAoZWZmZWN0aXZlSW5wdXRTaXplWzBdKSAqIHIgLyAoZWZmZWN0aXZlT3V0cHV0U2l6ZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY0NvbCA9IChlZmZlY3RpdmVJbnB1dFNpemVbMV0pICogYyAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VSb3dGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY1Jvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlUm93Q2VpbCA9IE1hdGgubWluKG9sZEhlaWdodCAtIDEsIE1hdGguY2VpbChzb3VyY2VGcmFjUm93KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sRmxvb3IgPSBNYXRoLmZsb29yKHNvdXJjZUZyYWNDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNvbENlaWwgPSBNYXRoLm1pbihvbGRXaWR0aCAtIDEsIE1hdGguY2VpbChzb3VyY2VGcmFjQ29sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wTGVmdCA9IHguZ2V0KGIsIHNvdXJjZVJvd0Zsb29yLCBzb3VyY2VDb2xGbG9vciwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tTGVmdCA9IHguZ2V0KGIsIHNvdXJjZVJvd0NlaWwsIHNvdXJjZUNvbEZsb29yLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BSaWdodCA9IHguZ2V0KGIsIHNvdXJjZVJvd0Zsb29yLCBzb3VyY2VDb2xDZWlsLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21SaWdodCA9IHguZ2V0KGIsIHNvdXJjZVJvd0NlaWwsIHNvdXJjZUNvbENlaWwsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0ZyYWMgPSBzb3VyY2VGcmFjUm93IC0gc291cmNlUm93Rmxvb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sRnJhYyA9IHNvdXJjZUZyYWNDb2wgLSBzb3VyY2VDb2xGbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BfMSA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGNvbEZyYWM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogY29sRnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRvcF8xICsgKGJvdHRvbSAtIHRvcF8xKSAqIHJvd0ZyYWM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0KG5ld1ZhbHVlLCBiLCByLCBjLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgeCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBfYSA9IHguc2hhcGUsIGJhdGNoID0gX2FbMF0sIHhIZWlnaHQgPSBfYVsxXSwgeFdpZHRoID0gX2FbMl0sIGRlcHRoID0gX2FbM107XG4gICAgICAgIHZhciBfYiA9IGR5LnNoYXBlLCB5SGVpZ2h0ID0gX2JbMV0sIHlXaWR0aCA9IF9iWzJdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gb3BzLmJ1ZmZlcihbYmF0Y2gsIHhIZWlnaHQsIHhXaWR0aCwgZGVwdGhdLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZVhTaXplID0gW1xuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5SGVpZ2h0ID4gMSkgPyB4SGVpZ2h0IC0gMSA6IHhIZWlnaHQsXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlXaWR0aCA+IDEpID8geFdpZHRoIC0gMSA6IHhXaWR0aFxuICAgICAgICBdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlWVNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlIZWlnaHQgPiAxKSA/IHlIZWlnaHQgLSAxIDogeUhlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeVdpZHRoID4gMSkgPyB5V2lkdGggLSAxIDogeVdpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBoZWlnaHRTY2FsZSA9IGVmZmVjdGl2ZVhTaXplWzBdIC8gZWZmZWN0aXZlWVNpemVbMF07XG4gICAgICAgIHZhciB3aWR0aFNjYWxlID0gZWZmZWN0aXZlWFNpemVbMV0gLyBlZmZlY3RpdmVZU2l6ZVsxXTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaDsgYisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHlIZWlnaHQ7IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciBkeFIgPSByICogaGVpZ2h0U2NhbGU7XG4gICAgICAgICAgICAgICAgdmFyIHRvcER4UkluZGV4ID0gTWF0aC5mbG9vcihkeFIpO1xuICAgICAgICAgICAgICAgIHZhciBib3R0b21EeFJJbmRleCA9IE1hdGgubWluKE1hdGguY2VpbChkeFIpLCB4SGVpZ2h0IC0gMSk7XG4gICAgICAgICAgICAgICAgdmFyIGR4UkxlcnAgPSBkeFIgLSB0b3BEeFJJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJzZUR4UkxlcnAgPSAxLjAgLSBkeFJMZXJwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgeVdpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4QyA9IGMgKiB3aWR0aFNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdER4Q0luZGV4ID0gTWF0aC5mbG9vcihkeEMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHREeENJbmRleCA9IE1hdGgubWluKE1hdGguY2VpbChkeEMpLCB4V2lkdGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4Q0xlcnAgPSBkeEMgLSBsZWZ0RHhDSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlRHhDTGVycCA9IDEuMCAtIGR4Q0xlcnA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVwdGg7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5VmFsID0gZHkuZ2V0KGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcExlZnQgPSBvdXRwdXQuZ2V0KGIsIHRvcER4UkluZGV4LCBsZWZ0RHhDSW5kZXgsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGVmdCArPSBkeVZhbCAqIGludmVyc2VEeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0KHRvcExlZnQsIGIsIHRvcER4UkluZGV4LCBsZWZ0RHhDSW5kZXgsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcFJpZ2h0ID0gb3V0cHV0LmdldChiLCB0b3BEeFJJbmRleCwgcmlnaHREeENJbmRleCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BSaWdodCArPSBkeVZhbCAqIGludmVyc2VEeFJMZXJwICogZHhDTGVycDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQodG9wUmlnaHQsIGIsIHRvcER4UkluZGV4LCByaWdodER4Q0luZGV4LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21MZWZ0ID0gb3V0cHV0LmdldChiLCBib3R0b21EeFJJbmRleCwgbGVmdER4Q0luZGV4LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbUxlZnQgKz0gZHlWYWwgKiBkeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0KGJvdHRvbUxlZnQsIGIsIGJvdHRvbUR4UkluZGV4LCBsZWZ0RHhDSW5kZXgsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gb3V0cHV0LmdldChiLCBib3R0b21EeFJJbmRleCwgcmlnaHREeENJbmRleCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b21SaWdodCArPSBkeVZhbCAqIGR4UkxlcnAgKiBkeENMZXJwO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldChib3R0b21SaWdodCwgYiwgYm90dG9tRHhSSW5kZXgsIHJpZ2h0RHhDSW5kZXgsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IgPSBmdW5jdGlvbiAoeCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBfYSA9IHguc2hhcGUsIGJhdGNoID0gX2FbMF0sIG9sZEhlaWdodCA9IF9hWzFdLCBvbGRXaWR0aCA9IF9hWzJdLCBudW1DaGFubmVscyA9IF9hWzNdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gb3BzLmJ1ZmZlcihbYmF0Y2gsIG5ld0hlaWdodCwgbmV3V2lkdGgsIG51bUNoYW5uZWxzXSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciBlZmZlY3RpdmVJbnB1dFNpemUgPSBhbGlnbkNvcm5lcnMgPyBbb2xkSGVpZ2h0IC0gMSwgb2xkV2lkdGggLSAxXSA6IFtvbGRIZWlnaHQsIG9sZFdpZHRoXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dHB1dFNpemUgPSBhbGlnbkNvcm5lcnMgPyBbbmV3SGVpZ2h0IC0gMSwgbmV3V2lkdGggLSAxXSA6IFtuZXdIZWlnaHQsIG5ld1dpZHRoXTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaDsgYisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG5ld0hlaWdodDsgcisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuZXdXaWR0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgbnVtQ2hhbm5lbHM7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUZyYWNSb3cgPSAoZWZmZWN0aXZlSW5wdXRTaXplWzBdKSAqIHIgLyAoZWZmZWN0aXZlT3V0cHV0U2l6ZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY0NvbCA9IChlZmZlY3RpdmVJbnB1dFNpemVbMV0pICogYyAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VOZWFyZXN0Um93ID0gTWF0aC5taW4ob2xkSGVpZ2h0IC0gMSwgYWxpZ25Db3JuZXJzID8gTWF0aC5yb3VuZChzb3VyY2VGcmFjUm93KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihzb3VyY2VGcmFjUm93KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTmVhcmVzdENvbCA9IE1hdGgubWluKG9sZFdpZHRoIC0gMSwgYWxpZ25Db3JuZXJzID8gTWF0aC5yb3VuZChzb3VyY2VGcmFjQ29sKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihzb3VyY2VGcmFjQ29sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB4LmdldChiLCBzb3VyY2VOZWFyZXN0Um93LCBzb3VyY2VOZWFyZXN0Q29sLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQobmV3VmFsdWUsIGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgeFZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG1lYW5WYWx1ZXMgPSBtZWFuLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciB2YXJpYW5jZVZhbHVlcyA9IHZhcmlhbmNlLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBzY2FsZVZhbHVlcyA9IHNjYWxlID8gc2NhbGUuZGF0YVN5bmMoKSA6IG5ldyBGbG9hdDMyQXJyYXkoWzFdKTtcbiAgICAgICAgdmFyIG9mZnNldFZhbHVlcyA9IG9mZnNldCA/IG9mZnNldC5kYXRhU3luYygpIDogbmV3IEZsb2F0MzJBcnJheShbMF0pO1xuICAgICAgICB2YXIgb3V0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4VmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0VmFsdWVzW2ldID0gb2Zmc2V0VmFsdWVzW2kgJSBvZmZzZXRWYWx1ZXMubGVuZ3RoXSArXG4gICAgICAgICAgICAgICAgKHhWYWx1ZXNbaV0gLSBtZWFuVmFsdWVzW2kgJSBtZWFuVmFsdWVzLmxlbmd0aF0pICpcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVWYWx1ZXNbaSAlIHNjYWxlVmFsdWVzLmxlbmd0aF0gL1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnNxcnQodmFyaWFuY2VWYWx1ZXNbaSAlIHZhcmlhbmNlVmFsdWVzLmxlbmd0aF0gKyB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHNfMS50ZW5zb3I0ZChvdXRWYWx1ZXMsIHguc2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQgPSBmdW5jdGlvbiAoeCwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gb3BzLmJ1ZmZlcih4LnNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgcmFkID0gcmFkaXVzO1xuICAgICAgICB2YXIgbWF4RCA9IG91dHB1dC5zaGFwZVszXSAtIDE7XG4gICAgICAgIGZ1bmN0aW9uIHN1bUFjcm9zc0NoYW5uZWxzKGIsIHIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgZCAtIHJhZCk7IGogPD0gTWF0aC5taW4oZCArIHJhZCwgbWF4RCk7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0geC5nZXQoYiwgciwgYywgaik7XG4gICAgICAgICAgICAgICAgc3VtICs9IHogKiB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IG91dHB1dC5zaGFwZVswXTsgYisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8PSBvdXRwdXQuc2hhcGVbMV07IHIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb3V0cHV0LnNoYXBlWzJdOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBvdXRwdXQuc2hhcGVbM107IGQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IHN1bUFjcm9zc0NoYW5uZWxzKGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHguZ2V0KGIsIHIsIGMsIGQpICogTWF0aC5wb3coYmlhcyArIGFscGhhICogc3VtLCAtYmV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0KHZhbCwgYiwgciwgYywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm11bHRpbm9taWFsID0gZnVuY3Rpb24gKGxvZ2l0cywgbm9ybWFsaXplZCwgbnVtU2FtcGxlcywgc2VlZCkge1xuICAgICAgICB2YXIgcHJvYmFiaWxpdGllcyA9IG5vcm1hbGl6ZWQgPyBsb2dpdHMgOiBvcHMuc29mdG1heChsb2dpdHMpO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gcHJvYmFiaWxpdGllcy5zaGFwZVswXTtcbiAgICAgICAgdmFyIG51bUV2ZW50cyA9IHByb2JhYmlsaXRpZXMuc2hhcGVbMV07XG4gICAgICAgIHZhciByZXMgPSBvcHMuemVyb3MoW2JhdGNoU2l6ZSwgbnVtU2FtcGxlc10sICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVzVmFscyA9IHJlcy5kYXRhU3luYygpO1xuICAgICAgICB2YXIgcHJvYlZhbHMgPSBwcm9iYWJpbGl0aWVzLmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBiICogbnVtRXZlbnRzO1xuICAgICAgICAgICAgdmFyIGNkZiA9IG5ldyBGbG9hdDMyQXJyYXkobnVtRXZlbnRzIC0gMSk7XG4gICAgICAgICAgICBjZGZbMF0gPSBwcm9iVmFsc1tvZmZzZXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRfMSA9IDE7IGV2ZW50XzEgPCBjZGYubGVuZ3RoOyArK2V2ZW50XzEpIHtcbiAgICAgICAgICAgICAgICBjZGZbZXZlbnRfMV0gPSBjZGZbZXZlbnRfMSAtIDFdICsgcHJvYlZhbHNbb2Zmc2V0ICsgZXZlbnRfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmFuZG9tID0gc2VlZHJhbmRvbS5hbGVhKHNlZWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB2YXIgb3V0T2Zmc2V0ID0gYiAqIG51bVNhbXBsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBzYW1wbGVJZCA9IDA7IHNhbXBsZUlkIDwgbnVtU2FtcGxlczsgKytzYW1wbGVJZCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gcmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgcmVzVmFsc1tvdXRPZmZzZXQgKyBzYW1wbGVJZF0gPSBjZGYubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGV2ZW50XzIgPSAwOyBldmVudF8yIDwgY2RmLmxlbmd0aDsgZXZlbnRfMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyIDwgY2RmW2V2ZW50XzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNWYWxzW291dE9mZnNldCArIHNhbXBsZUlkXSA9IGV2ZW50XzI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm9uZUhvdCA9IGZ1bmN0aW9uIChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBGbG9hdDMyQXJyYXkoaW5kaWNlcy5zaXplICogZGVwdGgpO1xuICAgICAgICByZXMuZmlsbChvZmZWYWx1ZSk7XG4gICAgICAgIGZvciAodmFyIGV2ZW50XzMgPSAwOyBldmVudF8zIDwgaW5kaWNlcy5zaXplOyArK2V2ZW50XzMpIHtcbiAgICAgICAgICAgIHJlc1tldmVudF8zICogZGVwdGggKyBpbmRpY2VzLmdldChldmVudF8zKV0gPSBvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHMudGVuc29yMmQocmVzLCBbaW5kaWNlcy5zaXplLCBkZXB0aF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmJyb2FkY2FzdGVkQmluYXJ5T3AgPSBmdW5jdGlvbiAoYSwgYiwgZHR5cGUsIG9wKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLmJ1ZmZlcihuZXdTaGFwZSwgZHR5cGUpO1xuICAgICAgICB2YXIgYVZhbHVlcyA9IGEuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGJWYWx1ZXMgPSBiLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhQnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoYS5zaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgICB2YXIgYkJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGIuc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIGFCdWYgPSBhLmJ1ZmZlcigpO1xuICAgICAgICB2YXIgYkJ1ZiA9IGIuYnVmZmVyKCk7XG4gICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSByZXN1bHQuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBhTG9jID0gbG9jLnNsaWNlKC1hLnJhbmspO1xuICAgICAgICAgICAgYUJyb2FkY2FzdERpbXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYUxvY1tkXSA9IDA7IH0pO1xuICAgICAgICAgICAgdmFyIGFJbmRleCA9IGFCdWYubG9jVG9JbmRleChhTG9jKTtcbiAgICAgICAgICAgIHZhciBiTG9jID0gbG9jLnNsaWNlKC1iLnJhbmspO1xuICAgICAgICAgICAgYkJyb2FkY2FzdERpbXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYkxvY1tkXSA9IDA7IH0pO1xuICAgICAgICAgICAgdmFyIGJJbmRleCA9IGJCdWYubG9jVG9JbmRleChiTG9jKTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZXNbaV0gPSBvcChhVmFsdWVzW2FJbmRleF0sIGJWYWx1ZXNbYkluZGV4XSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgX2xvb3BfMihpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gTWF0aEJhY2tlbmRDUFU7XG59KCkpO1xuZXhwb3J0cy5NYXRoQmFja2VuZENQVSA9IE1hdGhCYWNrZW5kQ1BVO1xuZW52aXJvbm1lbnRfMS5FTlYucmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWF0aEJhY2tlbmRDUFUoKTsgfSwgMSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrZW5kX2NwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG52YXIgYXJyYXlfb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL2FycmF5X29wc1wiKTtcbmZ1bmN0aW9uIGNhc3RUZW5zb3IoeCwgZHR5cGUsIGJhY2tlbmQpIHtcbiAgICBpZiAoIV9fMS51dGlsLmhhc0VuY29kaW5nTG9zcyh4LmR0eXBlLCBkdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIF9fMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IGRhdGFJZDogeC5kYXRhSWQgfSwgZHR5cGUpO1xuICAgIH1cbiAgICBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuaW50KHgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLm5vdEVxdWFsKHgsIGFycmF5X29wc18xLkFycmF5T3BzLnNjYWxhcigwLCB4LmR0eXBlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBDYXN0OiB1bmtub3duIGR0eXBlIGFyZ3VtZW50IChcIiArIGR0eXBlICsgXCIpXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FzdFRlbnNvciA9IGNhc3RUZW5zb3I7XG5mdW5jdGlvbiByZXNoYXBlVGVuc29yKHgsIHNoYXBlKSB7XG4gICAgcmV0dXJuIF9fMS5UZW5zb3IubWFrZShzaGFwZSwgeyBkYXRhSWQ6IHguZGF0YUlkIH0sIHguZHR5cGUpO1xufVxuZXhwb3J0cy5yZXNoYXBlVGVuc29yID0gcmVzaGFwZVRlbnNvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmRfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4uL29wcy9heGlzX3V0aWxcIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgcmVkdWNlX3V0aWwgPSByZXF1aXJlKFwiLi4vb3BzL3JlZHVjZV91dGlsXCIpO1xudmFyIHNsaWNlX3V0aWxfMSA9IHJlcXVpcmUoXCIuLi9vcHMvc2xpY2VfdXRpbFwiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JcIik7XG52YXIgdHlwZXMgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGJhY2tlbmRfdXRpbCA9IHJlcXVpcmUoXCIuL2JhY2tlbmRfdXRpbFwiKTtcbnZhciBhcmdtaW5tYXhfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9hcmdtaW5tYXhfZ3B1XCIpO1xudmFyIGF2Z19wb29sX2JhY2twcm9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYXZnX3Bvb2xfYmFja3Byb3BfZ3B1XCIpO1xudmFyIGJhdGNobm9ybV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2JhdGNobm9ybV9ncHVcIik7XG52YXIgYmluYXJ5b3BfZ3B1ID0gcmVxdWlyZShcIi4vd2ViZ2wvYmluYXJ5b3BfZ3B1XCIpO1xudmFyIGJpbmFyeW9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYmluYXJ5b3BfZ3B1XCIpO1xudmFyIGNsaXBfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jbGlwX2dwdVwiKTtcbnZhciBjb25jYXRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb25jYXRfZ3B1XCIpO1xudmFyIGNvbnZfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2JhY2twcm9wX2dwdVwiKTtcbnZhciBjb252X2JhY2twcm9wX2dwdV9kZXB0aHdpc2VfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbnZfYmFja3Byb3BfZ3B1X2RlcHRod2lzZVwiKTtcbnZhciBjb252X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29udl9ncHVcIik7XG52YXIgY29udl9ncHVfZGVwdGh3aXNlXzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2dwdV9kZXB0aHdpc2VcIik7XG52YXIgY3Vtc3VtX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY3Vtc3VtX2dwdVwiKTtcbnZhciBmcm9tX3BpeGVsc19ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2Zyb21fcGl4ZWxzX2dwdVwiKTtcbnZhciBnYXRoZXJfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9nYXRoZXJfZ3B1XCIpO1xudmFyIGdwZ3B1X2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X2NvbnRleHRcIik7XG52YXIgZ3BncHVfbWF0aCA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X21hdGhcIik7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X3V0aWxcIik7XG52YXIgbG9naWNhbF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2xvZ2ljYWxfZ3B1XCIpO1xudmFyIGxybl9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2xybl9ncHVcIik7XG52YXIgbWF4X3Bvb2xfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9tYXhfcG9vbF9iYWNrcHJvcF9ncHVcIik7XG52YXIgbXVsbWF0X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbXVsbWF0X2dwdVwiKTtcbnZhciBtdWx0aW5vbWlhbF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL211bHRpbm9taWFsX2dwdVwiKTtcbnZhciBvbmVob3RfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9vbmVob3RfZ3B1XCIpO1xudmFyIHBhZF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3BhZF9ncHVcIik7XG52YXIgcG9vbF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3Bvb2xfZ3B1XCIpO1xudmFyIHJlZHVjZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3JlZHVjZV9ncHVcIik7XG52YXIgcmVzaXplX2JpbGluZWFyX2JhY2twcm9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcmVzaXplX2JpbGluZWFyX2JhY2twcm9wX2dwdVwiKTtcbnZhciByZXNpemVfYmlsaW5lYXJfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZXNpemVfYmlsaW5lYXJfZ3B1XCIpO1xudmFyIHJlc2l6ZV9uZWFyZXN0X25laWdoYm9yX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcmVzaXplX25lYXJlc3RfbmVpZ2hib3JfZ3B1XCIpO1xudmFyIHJldmVyc2VfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZXZlcnNlX2dwdVwiKTtcbnZhciBzbGljZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3NsaWNlX2dwdVwiKTtcbnZhciBzdHJpZGVkX3NsaWNlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvc3RyaWRlZF9zbGljZV9ncHVcIik7XG52YXIgdGV4X3V0aWxfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RleF91dGlsXCIpO1xudmFyIHRleHR1cmVfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdGV4dHVyZV9tYW5hZ2VyXCIpO1xudmFyIHRpbGVfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC90aWxlX2dwdVwiKTtcbnZhciB0cmFuc3Bvc2VfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC90cmFuc3Bvc2VfZ3B1XCIpO1xudmFyIHVuYXJ5X29wID0gcmVxdWlyZShcIi4vd2ViZ2wvdW5hcnlvcF9ncHVcIik7XG52YXIgdW5hcnlvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3VuYXJ5b3BfZ3B1XCIpO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbC93ZWJnbF91dGlsXCIpO1xudmFyIEJFRk9SRV9QQUdJTkdfQ09OU1RBTlQgPSAzMDA7XG52YXIgTWF0aEJhY2tlbmRXZWJHTCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0aEJhY2tlbmRXZWJHTChncGdwdSwgZGVsYXllZFN0b3JhZ2UpIHtcbiAgICAgICAgaWYgKGRlbGF5ZWRTdG9yYWdlID09PSB2b2lkIDApIHsgZGVsYXllZFN0b3JhZ2UgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuZ3BncHUgPSBncGdwdTtcbiAgICAgICAgdGhpcy5kZWxheWVkU3RvcmFnZSA9IGRlbGF5ZWRTdG9yYWdlO1xuICAgICAgICB0aGlzLnRleERhdGEgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZWFkID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlzcG9zYWwgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICB0aGlzLmxydURhdGFHUFUgPSBbXTtcbiAgICAgICAgdGhpcy5udW1CeXRlc0luR1BVID0gMDtcbiAgICAgICAgdGhpcy51cGxvYWRXYWl0TXMgPSAwO1xuICAgICAgICB0aGlzLmRvd25sb2FkV2FpdE1zID0gMDtcbiAgICAgICAgdGhpcy5iaW5hcnlDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3BncHUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdSA9IG5ldyBncGdwdV9jb250ZXh0XzEuR1BHUFVDb250ZXh0KGdwZ3B1X3V0aWwuY3JlYXRlV2ViR0xDb250ZXh0KHRoaXMuY2FudmFzKSk7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5OVU1fQllURVNfQkVGT1JFX1BBR0lORyA9XG4gICAgICAgICAgICAod2luZG93LnNjcmVlbi5oZWlnaHQgKiB3aW5kb3cuc2NyZWVuLndpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pICpcbiAgICAgICAgICAgICAgICBCRUZPUkVfUEFHSU5HX0NPTlNUQU5UO1xuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyID0gbmV3IHRleHR1cmVfbWFuYWdlcl8xLlRleHR1cmVNYW5hZ2VyKHRoaXMuZ3BncHUpO1xuICAgIH1cbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkYXRhSWQsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAodGhpcy50ZXhEYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgYnVmZmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4RGF0YS5zZXQoZGF0YUlkLCB7XG4gICAgICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgICAgICBkdHlwZTogZHR5cGUsXG4gICAgICAgICAgICB2YWx1ZXM6IG51bGwsXG4gICAgICAgICAgICB0ZXh0dXJlOiBudWxsLFxuICAgICAgICAgICAgdGV4U2hhcGU6IG51bGwsXG4gICAgICAgICAgICB0ZXhUeXBlOiB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkZMT0FUXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZnJvbVBpeGVscyA9IGZ1bmN0aW9uIChwaXhlbHMsIG51bUNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChwaXhlbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRoQmFja2VuZFdlYkdMLndyaXRlUGl4ZWxzKCk6IHBpeGVscyBjYW4gbm90IGJlIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4U2hhcGUgPSBbcGl4ZWxzLmhlaWdodCwgcGl4ZWxzLndpZHRoXTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gW3BpeGVscy5oZWlnaHQsIHBpeGVscy53aWR0aCwgbnVtQ2hhbm5lbHNdO1xuICAgICAgICBpZiAocGl4ZWxzIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbVBpeGVsc0NhbnZhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcmVhZCBwaXhlbHMgZnJvbSBIVE1MSW1hZ2VFbGVtZW50IG91dHNpZGUgdGhlIGJyb3dzZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIERPTSBpcyBub3QgcmVhZHkgeWV0LiBQbGVhc2UgY2FsbCB0Zi5mcm9tUGl4ZWxzKCkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25jZSB0aGUgRE9NIGlzIHJlYWR5LiBPbmUgd2F5IHRvIGRvIHRoYXQgaXMgdG8gYWRkIGFuIGV2ZW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RlbmVyIGZvciBgRE9NQ29udGVudExvYWRlZGAgb24gdGhlIGRvY3VtZW50IG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZyb21QaXhlbHNDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnJvbVBpeGVsc0NhbnZhcy53aWR0aCA9IHBpeGVscy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuZnJvbVBpeGVsc0NhbnZhcy5oZWlnaHQgPSBwaXhlbHMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5mcm9tUGl4ZWxzQ2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHBpeGVscywgMCwgMCwgcGl4ZWxzLndpZHRoLCBwaXhlbHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHBpeGVscyA9IHRoaXMuZnJvbVBpeGVsc0NhbnZhcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVtcFBpeGVsQXJyYXkgPSB0ZW5zb3JfMS5UZW5zb3IubWFrZSh0ZXhTaGFwZSwge30sICdpbnQzMicpO1xuICAgICAgICB0aGlzLnRleERhdGEuZ2V0KHRlbXBQaXhlbEFycmF5LmRhdGFJZCkudGV4VHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuVU5TSUdORURfQllURTtcbiAgICAgICAgdGhpcy5ncGdwdS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUodGhpcy5nZXRUZXh0dXJlKHRlbXBQaXhlbEFycmF5LmRhdGFJZCksIHBpeGVscyk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGZyb21fcGl4ZWxzX2dwdV8xLkZyb21QaXhlbHNQcm9ncmFtKG91dFNoYXBlKTtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbdGVtcFBpeGVsQXJyYXldKTtcbiAgICAgICAgdGVtcFBpeGVsQXJyYXkuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGhCYWNrZW5kV2ViR0wud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YShkYXRhSWQpO1xuICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0ZXhEYXRhLnRleHR1cmUsIHRleFNoYXBlID0gdGV4RGF0YS50ZXhTaGFwZSwgdGV4VHlwZSA9IHRleERhdGEudGV4VHlwZTtcbiAgICAgICAgaWYgKHRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlVGV4dHVyZShkYXRhSWQsIHRleHR1cmUsIHRleFNoYXBlLCB0ZXhUeXBlKTtcbiAgICAgICAgICAgIHRleERhdGEudGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICB0ZXhEYXRhLnRleFNoYXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0ZXhEYXRhLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRTdG9yYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKGRhdGFJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlYWRTeW5jID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB0aGlzLnRocm93SWZOb0RhdGEoZGF0YUlkKTtcbiAgICAgICAgdmFyIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGV4RGF0YS50ZXh0dXJlLCB2YWx1ZXMgPSB0ZXhEYXRhLnZhbHVlcywgdGV4U2hhcGUgPSB0ZXhEYXRhLnRleFNoYXBlO1xuICAgICAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVPbkNQVShkYXRhSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkVGltZVByb2dyYW0gPSB0aGlzLmFjdGl2ZVRpbWVycyAhPSBudWxsO1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIGlmIChzaG91bGRUaW1lUHJvZ3JhbSkge1xuICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmxvYXQzMlZhbHVlcyA9IHRoaXMuZ3BncHUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZSh0ZXh0dXJlLCB0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV0pO1xuICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRXYWl0TXMgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlT25DUFUoZGF0YUlkLCBmbG9hdDMyVmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHRleERhdGEudmFsdWVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmliZXJzXzEsIHRleERhdGEsIHRleHR1cmUsIHZhbHVlcywgdGV4U2hhcGUsIGZsb2F0MzJWYWx1ZXMsIHN1YnNjcmliZXJzLCB2YWxzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1JlYWQuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc18xID0gdGhpcy5wZW5kaW5nUmVhZC5nZXQoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzdWJzY3JpYmVyc18xLnB1c2gocmVzb2x2ZSk7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSB0ZXhEYXRhLnRleHR1cmUsIHZhbHVlcyA9IHRleERhdGEudmFsdWVzLCB0ZXhTaGFwZSA9IHRleERhdGEudGV4U2hhcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlT25DUFUoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHZhbHVlc107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfR0VUX0JVRkZFUl9TVUJfREFUQV9BU1lOQ19FWFRFTlNJT05fRU5BQkxFRCcpKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmdwZ3B1LmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmVBc3luYyh0ZXh0dXJlLCB0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQzMlZhbHVlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVPbkNQVShkYXRhSWQsIGZsb2F0MzJWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0ZXhEYXRhLnZhbHVlc107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVhZFN5bmMoZGF0YUlkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZWFkLnNldChkYXRhSWQsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5ncGdwdS5ydW5RdWVyeShmdW5jdGlvbiAoKSB7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMgPSB0aGlzLnBlbmRpbmdSZWFkLmdldChkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHMgPSB0aGlzLnJlYWRTeW5jKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiByZXNvbHZlKHZhbHMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZURhdGEoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdmFsc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudGltZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbGRBY3RpdmVUaW1lcnMsIG5ld0FjdGl2ZVRpbWVycywgb3V0ZXJNb3N0VGltZSwgZmxhdHRlbmVkQWN0aXZlVGltZXJzLCBrZXJuZWxNcywgcmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQWN0aXZlVGltZXJzID0gdGhpcy5hY3RpdmVUaW1lcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBY3RpdmVUaW1lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyTW9zdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2dyYW1UaW1lcnNTdGFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9ncmFtVGltZXJzU3RhY2sgPSBuZXdBY3RpdmVUaW1lcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJNb3N0VGltZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKG5ld0FjdGl2ZVRpbWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRpbWVycyA9IG5ld0FjdGl2ZVRpbWVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5lZEFjdGl2ZVRpbWVycyA9IHV0aWwuZmxhdHRlbih0aGlzLmFjdGl2ZVRpbWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRpbWVycyA9IG9sZEFjdGl2ZVRpbWVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlck1vc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9ncmFtVGltZXJzU3RhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBQcm9taXNlLmFsbChmbGF0dGVuZWRBY3RpdmVUaW1lcnMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBzdW0gKz0gcmVzdWx0OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5lbE1zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZFdhaXRNczogdGhpcy51cGxvYWRXYWl0TXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRXYWl0TXM6IHRoaXMuZG93bmxvYWRXYWl0TXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2VybmVsTXM6IGtlcm5lbE1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxNczogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkV2FpdE1zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRXYWl0TXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1lbW9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgdW5yZWxpYWJsZTogZmFsc2UsIG51bUJ5dGVzSW5HUFU6IHRoaXMubnVtQnl0ZXNJbkdQVSB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc3RhcnRUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdwZ3B1LmJlZ2luUXVlcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydE1zOiBwZXJmb3JtYW5jZS5ub3coKSwgZW5kTXM6IG51bGwgfTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmVuZFRpbWVyID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LmVuZFF1ZXJ5KCk7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnkuZW5kTXMgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lclF1ZXJ5O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5ncGdwdS5wb2xsUXVlcnlUaW1lKHF1ZXJ5KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVyUXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRpbWVyUXVlcnkuZW5kTXMgLSB0aW1lclF1ZXJ5LnN0YXJ0TXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGlzcG9zZURhdGEgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdSZWFkLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEaXNwb3NhbC5hZGQoZGF0YUlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50ZXhEYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCksIHRleHR1cmUgPSBfYS50ZXh0dXJlLCB0ZXhTaGFwZSA9IF9hLnRleFNoYXBlLCB0ZXhUeXBlID0gX2EudGV4VHlwZTtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VUZXh0dXJlKGRhdGFJZCwgdGV4dHVyZSwgdGV4U2hhcGUsIHRleFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50ZXhEYXRhLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCkudGV4dHVyZTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldEdQR1BVQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3BncHU7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShzaXplKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSwgbnVsbCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBlbmQsIHN0cmlkZXMsIGJlZ2luTWFzaywgZW5kTWFzaykge1xuICAgICAgICB2YXIgX2EgPSBzbGljZV91dGlsXzEuZ2V0U3RyaWRlZFNsaWNlZEluZm8oeC5zaGFwZSwgYmVnaW4sIGVuZCwgc3RyaWRlcywgYmVnaW5NYXNrLCBlbmRNYXNrKSwgYmVnaW5JbmRleCA9IF9hWzBdLCBzaXplID0gX2FbMV07XG4gICAgICAgIGlmIChzaXplLnNvbWUoZnVuY3Rpb24gKGF4aXMpIHsgcmV0dXJuIGF4aXMgPT09IDA7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gb3BzLnRlbnNvcihbXSwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgc3RyaWRlZF9zbGljZV9ncHVfMS5TdHJpZGVkU2xpY2VQcm9ncmFtKGJlZ2luSW5kZXgsIHN0cmlkZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcmV2ZXJzZV9ncHVfMS5SZXZlcnNlUHJvZ3JhbSh4LnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29uY2F0X2dwdV8xLkNvbmNhdFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuTkVHKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF0TXVsID0gZnVuY3Rpb24gKGEsIGIsIHRyYW5zcG9zZUEsIHRyYW5zcG9zZUIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbXVsbWF0X2dwdV8xLk1hdE11bFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5NVUwsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGlucHV0cyA9IFt4LCBtZWFuLCB2YXJpYW5jZV07XG4gICAgICAgIHZhciBvZmZzZXRTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb2Zmc2V0U2hhcGUgPSBvZmZzZXQuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZVNoYXBlID0gbnVsbDtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNjYWxlU2hhcGUgPSBzY2FsZS5zaGFwZTtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiYXRjaG5vcm1fZ3B1XzEuQmF0Y2hOb3JtUHJvZ3JhbSh4LnNoYXBlLCBtZWFuLnNoYXBlLCB2YXJpYW5jZS5zaGFwZSwgb2Zmc2V0U2hhcGUsIHNjYWxlU2hhcGUsIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgaW5wdXRzKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQgPSBmdW5jdGlvbiAoeCwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBscm5fZ3B1XzEuTFJOUHJvZ3JhbSh4LnNoYXBlLCByYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudGlsZSA9IGZ1bmN0aW9uICh4LCByZXBzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHRpbGVfZ3B1XzEuVGlsZVByb2dyYW0oeC5zaGFwZSwgcmVwcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwYWRfZ3B1XzEuUGFkUHJvZ3JhbSh4LnNoYXBlLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uICh4LCBwZXJtKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHRyYW5zcG9zZV9ncHVfMS5UcmFuc3Bvc2VQcm9ncmFtKHguc2hhcGUsIHBlcm0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nYXRoZXIgPSBmdW5jdGlvbiAoeCwgaW5kaWNlcywgYXhpcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBnYXRoZXJfZ3B1XzEuR2F0aGVyUHJvZ3JhbSh4LnNoYXBlLCBpbmRpY2VzLnNpemUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBpbmRpY2VzXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoeCwgcmVkdWNlVHlwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHguc2hhcGVbMF07XG4gICAgICAgIHZhciBpblNpemUgPSB4LnNoYXBlWzFdO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZV91dGlsLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpblNpemUpO1xuICAgICAgICB2YXIgcmVkdWNlSW5mbyA9IHsgd2luZG93U2l6ZTogd2luZG93U2l6ZSwgaW5TaXplOiBpblNpemUsIGJhdGNoU2l6ZTogYmF0Y2hTaXplIH07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlZHVjZV9ncHVfMS5SZWR1Y2VQcm9ncmFtKHJlZHVjZUluZm8sIHJlZHVjZVR5cGUpO1xuICAgICAgICB2YXIgX2EgPSBwcm9ncmFtLm91dHB1dFNoYXBlLCByb3dzID0gX2FbMF0sIGNvbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KFtyb3dzLCBjb2xzXSwgZHR5cGUpO1xuICAgICAgICB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgICAgICBpZiAob3V0cHV0LnNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShvdXRwdXQsIHJlZHVjZVR5cGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFyZ1JlZHVjZSA9IGZ1bmN0aW9uICh4LCByZWR1Y2VUeXBlLCBiZXN0SW5kaWNlc0EpIHtcbiAgICAgICAgaWYgKGJlc3RJbmRpY2VzQSA9PT0gdm9pZCAwKSB7IGJlc3RJbmRpY2VzQSA9IG51bGw7IH1cbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHguc2hhcGVbMF07XG4gICAgICAgIHZhciBpblNpemUgPSB4LnNoYXBlWzFdO1xuICAgICAgICBpZiAoYmVzdEluZGljZXNBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJhdGNoU2l6ZSA9IGJlc3RJbmRpY2VzQS5zaGFwZVswXTtcbiAgICAgICAgICAgIGluU2l6ZSA9IGJlc3RJbmRpY2VzQS5zaGFwZVsxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZV91dGlsLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpblNpemUpO1xuICAgICAgICB2YXIgcmVkdWNlSW5mbyA9IHsgd2luZG93U2l6ZTogd2luZG93U2l6ZSwgaW5TaXplOiBpblNpemUsIGJhdGNoU2l6ZTogYmF0Y2hTaXplIH07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGFyZ21pbm1heF9ncHVfMS5BcmdNaW5NYXhQcm9ncmFtKHJlZHVjZUluZm8sIHJlZHVjZVR5cGUsIGJlc3RJbmRpY2VzQSA9PSBudWxsKTtcbiAgICAgICAgdmFyIF9hID0gcHJvZ3JhbS5vdXRwdXRTaGFwZSwgcm93cyA9IF9hWzBdLCBjb2xzID0gX2FbMV07XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShbcm93cywgY29sc10sICdpbnQzMicpO1xuICAgICAgICB2YXIgaW5wdXRzID0gW3hdO1xuICAgICAgICBpZiAoYmVzdEluZGljZXNBICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKGJlc3RJbmRpY2VzQSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cywgb3V0cHV0KTtcbiAgICAgICAgaWYgKG91dHB1dC5zaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcmdSZWR1Y2UoeCwgcmVkdWNlVHlwZSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnc3VtJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0geC5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICB2YXIgb3V0cHV0RFR5cGUgPSB0eXBlcy5zdW1PdXRUeXBlKHguZHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoYTJELCAnc3VtJywgb3V0cHV0RFR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXJnTWluID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdmFyIGF4ZXMgPSBbYXhpc107XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWluJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0geC5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdSZWR1Y2UoYTJELCAnbWluJykucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hcmdNYXggPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB2YXIgYXhlcyA9IFtheGlzXTtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNYXgnLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSB4LmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ1JlZHVjZShhMkQsICdtYXgnKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmN1bXN1bSA9IGZ1bmN0aW9uICh4LCBheGlzLCBleGNsdXNpdmUsIHJldmVyc2UpIHtcbiAgICAgICAgaWYgKGF4aXMgIT09IHgucmFuayAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYkdMIGN1bXN1bSBzaGFkZXIgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIgKyAoeC5yYW5rIC0gMSkgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IGdvdCBheGlzPVwiICsgYXhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGN1bXN1bV9ncHVfMS5DdW1TdW1Qcm9ncmFtKHguc2hhcGUsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5FUVVBTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5OT1RfRVFVQUwsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5MRVNTLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubGVzc0VxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5MRVNTX0VRVUFMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ3JlYXRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuR1JFQVRFUiwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdyZWF0ZXJFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuR1JFQVRFUl9FUVVBTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvZ2ljYWxOb3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkxPR0lDQUxfTk9UKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubG9naWNhbEFuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTE9HSUNBTF9BTkQsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sb2dpY2FsT3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkxPR0lDQUxfT1IsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGEsIGIsIGR0eXBlKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGxvZ2ljYWxfZ3B1XzEuV2hlcmVQcm9ncmFtKGNvbmRpdGlvbi5yYW5rLCBhLnNoYXBlLCBhLnJhbmspO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgZHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtjb25kaXRpb24sIGEsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudG9wS1ZhbHVlcyA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9wS1ZhbHVlcyBHUFUgbm90IHlldCBpbXBsZW1lbnRlZCEnKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRvcEtJbmRpY2VzID0gZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b3BLSW5kaWNlcyBHUFUgbm90IHlldCBpbXBsZW1lbnRlZCEnKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWluJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0geC5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoYTJELCAnbWluJywgYTJELmR0eXBlKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1pbmltdW0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1Lk1JTiwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTU9ELCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtYXgnLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSB4LmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShhMkQsICdtYXgnLCBhMkQuZHR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTUFYLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LlNRVUFSRURfRElGRkVSRU5DRSwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlYWxEaXZpZGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgb3AgPSBiaW5hcnlvcF9ncHUuRElWO1xuICAgICAgICB2YXIgb3V0cHV0RHR5cGUgPSAnZmxvYXQzMic7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShvcCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCBvdXRwdXREdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZmxvb3JEaXYgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgb3AgPSBiaW5hcnlvcF9ncHUuSU5UX0RJVjtcbiAgICAgICAgdmFyIG91dHB1dER0eXBlID0gJ2ludDMyJztcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKG9wLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIG91dHB1dER0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkFERCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuU1VCLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuUE9XLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNlaWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkNFSUwpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuRkxPT1IpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TSUdOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlJPVU5EKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5FWFApO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5leHBtMSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuRVhQTTEpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkxPRyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvZzFwID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5MT0cxUCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNRUlQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yc3FydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuUlNRUlQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNRVUFSRSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlY2lwcm9jYWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlJFQ0lQUk9DQUwpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5SRUxVKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5FTFUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5lbHVEZXIgPSBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5FTFVfREVSLCBkeS5zaGFwZSwgeS5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2R5LCB5XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TRUxVKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuaW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5UT19JTlQpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjbGlwX2dwdV8xLkNsaXBQcm9ncmFtKHguc2hhcGUsIG1pbiwgbWF4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5BQlMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zaWdtb2lkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TSUdNT0lEKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc29mdHBsdXMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNPRlRQTFVTKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2luID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TSU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkNPUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRhbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuVEFOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQVNJTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFjb3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFDT1MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5BVEFOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXRhbjIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkFUQU4yLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2luaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU0lOSCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkNPU0gpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50YW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5UQU5IKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXNpbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFTSU5IKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYWNvc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFDT1NIKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFUQU5IKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZXJmID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5FUkYpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU1RFUChhbHBoYSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb252MmQgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2dwdV8xLkNvbnYyRFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBmaWx0ZXJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvbnYyZERlcklucHV0ID0gZnVuY3Rpb24gKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfYmFja3Byb3BfZ3B1XzEuQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZHksIGZpbHRlcl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyID0gZnVuY3Rpb24gKHgsIGR5LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV8xLkNvbnYyRERlckZpbHRlclByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBkeV0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9ncHVfZGVwdGh3aXNlXzEuRGVwdGh3aXNlQ29udjJEUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3gsIGZpbHRlcl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQgPSBmdW5jdGlvbiAoZHksIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9iYWNrcHJvcF9ncHVfZGVwdGh3aXNlXzEuRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZHksIGZpbHRlcl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyID0gZnVuY3Rpb24gKHgsIGR5LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV9kZXB0aHdpc2VfMS5EZXB0aHdpc2VDb252MkREZXJGaWx0ZXJQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeCwgZHldKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1heFBvb2wgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcG9vbF9ncHVfMS5Qb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnbWF4JywgZmFsc2UpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXZnUG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdhdmcnLCBmYWxzZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgeCwgeSwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGdldFBvc2l0aW9ucyA9IHRydWU7XG4gICAgICAgIHZhciBtYXhQb29sUG9zaXRpb25zUHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdtYXgnLCBnZXRQb3NpdGlvbnMpO1xuICAgICAgICB2YXIgbWF4UG9vbFBvc2l0aW9ucyA9IHRoaXMuY29tcGlsZUFuZFJ1bihtYXhQb29sUG9zaXRpb25zUHJvZ3JhbSwgW3hdKTtcbiAgICAgICAgdmFyIG1heFBvb2xCYWNrUHJvcFByb2dyYW0gPSBuZXcgbWF4X3Bvb2xfYmFja3Byb3BfZ3B1XzEuTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KG1heFBvb2xCYWNrUHJvcFByb2dyYW0ub3V0cHV0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb21waWxlQW5kUnVuKG1heFBvb2xCYWNrUHJvcFByb2dyYW0sIFtkeSwgbWF4UG9vbFBvc2l0aW9uc10sIG91dHB1dCk7XG4gICAgICAgIG1heFBvb2xQb3NpdGlvbnMuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgYXZnUG9vbEJhY2twcm9wUHJvZ3JhbSA9IG5ldyBhdmdfcG9vbF9iYWNrcHJvcF9ncHVfMS5BdmdQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkoYXZnUG9vbEJhY2twcm9wUHJvZ3JhbS5vdXRwdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYXZnUG9vbEJhY2twcm9wUHJvZ3JhbSwgW2R5XSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiAoeCwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmRfdXRpbC5jYXN0VGVuc29yKHgsIGR0eXBlLCB0aGlzKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbiAoeCwgc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmRfdXRpbC5yZXNoYXBlVGVuc29yKHgsIHNoYXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyID0gZnVuY3Rpb24gKHgsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZXNpemVfYmlsaW5lYXJfZ3B1XzEuUmVzaXplQmlsaW5lYXJQcm9ncmFtKHguc2hhcGUsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIHgsIGFsaWduQ29ybmVycykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZXNpemVfYmlsaW5lYXJfYmFja3Byb3BfZ3B1XzEuUmVzaXplQmlsaW5lYXJCYWNrcHJvcFByb2dyYW0oZHksIHgsIGFsaWduQ29ybmVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2R5XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IgPSBmdW5jdGlvbiAoeCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlc2l6ZV9uZWFyZXN0X25laWdoYm9yX2dwdV8xLlJlc2l6ZU5lYXJlc3ROZWlnaGJvclByb2dyYW0oeC5zaGFwZSwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubXVsdGlub21pYWwgPSBmdW5jdGlvbiAobG9naXRzLCBub3JtYWxpemVkLCBudW1TYW1wbGVzLCBzZWVkKSB7XG4gICAgICAgIHZhciBwcm9icyA9IG5vcm1hbGl6ZWQgPyBsb2dpdHMgOiBvcHMuc29mdG1heChsb2dpdHMpO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gcHJvYnMuc2hhcGVbMF07XG4gICAgICAgIHZhciBudW1PdXRjb21lcyA9IHByb2JzLnNoYXBlWzFdO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBtdWx0aW5vbWlhbF9ncHVfMS5NdWx0aW5vbWlhbFByb2dyYW0oYmF0Y2hTaXplLCBudW1PdXRjb21lcywgbnVtU2FtcGxlcyk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoc2VlZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3Byb2JzXSwgb3V0cHV0LCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5vbmVIb3QgPSBmdW5jdGlvbiAoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IG9uZWhvdF9ncHVfMS5PbmVIb3RQcm9ncmFtKGluZGljZXMuc2l6ZSwgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbaW5kaWNlc10pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWFrZU91dHB1dEFycmF5ID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2Uoc2hhcGUsIHt9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb21waWxlQW5kUnVuID0gZnVuY3Rpb24gKHByb2dyYW0sIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIGlucHV0c1swXS5kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0c0RhdGEgPSBpbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgX3RoaXMudXBsb2FkVG9HUFUoaW5wdXQuZGF0YUlkKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRlbnNvcjogaW5wdXQsIHRleERhdGE6IF90aGlzLnRleERhdGEuZ2V0KGlucHV0LmRhdGFJZCkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBsb2FkVG9HUFUob3V0cHV0LmRhdGFJZCk7XG4gICAgICAgIHZhciBvdXRwdXREYXRhID0ge1xuICAgICAgICAgICAgdGVuc29yOiBvdXRwdXQsXG4gICAgICAgICAgICB0ZXhEYXRhOiB0aGlzLnRleERhdGEuZ2V0KG91dHB1dC5kYXRhSWQpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBrZXkgPSBncGdwdV9tYXRoLm1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzRGF0YSwgb3V0cHV0RGF0YSk7XG4gICAgICAgIHZhciBiaW5hcnkgPSB0aGlzLmdldEFuZFNhdmVCaW5hcnkoa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3BncHVfbWF0aC5jb21waWxlUHJvZ3JhbShfdGhpcy5ncGdwdSwgcHJvZ3JhbSwgaW5wdXRzRGF0YSwgb3V0cHV0RGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2hvdWxkVGltZVByb2dyYW0gPSB0aGlzLmFjdGl2ZVRpbWVycyAhPSBudWxsO1xuICAgICAgICB2YXIgcXVlcnk7XG4gICAgICAgIGlmIChzaG91bGRUaW1lUHJvZ3JhbSkge1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLnN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBncGdwdV9tYXRoLnJ1blByb2dyYW0oYmluYXJ5LCBpbnB1dHNEYXRhLCBvdXRwdXREYXRhLCBjdXN0b21TZXR1cCk7XG4gICAgICAgIGlmICh0aGlzLm51bUJ5dGVzSW5HUFUgPiB0aGlzLk5VTV9CWVRFU19CRUZPUkVfUEFHSU5HKSB7XG4gICAgICAgICAgICB2YXIgbnVtQnl0ZXNUb1BhZ2UgPSB0aGlzLm51bUJ5dGVzSW5HUFUgLSB0aGlzLk5VTV9CWVRFU19CRUZPUkVfUEFHSU5HO1xuICAgICAgICAgICAgd2hpbGUgKG51bUJ5dGVzVG9QYWdlID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSWQgPSB0aGlzLmxydURhdGFHUFUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCksIHNoYXBlID0gX2Euc2hhcGUsIGR0eXBlID0gX2EuZHR5cGU7XG4gICAgICAgICAgICAgICAgbnVtQnl0ZXNUb1BhZ2UgLT0gdGhpcy5jb21wdXRlQnl0ZXMoc2hhcGUsIGR0eXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWQoZGF0YUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5lbmRUaW1lcihxdWVyeSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKHRoaXMuZ2V0UXVlcnlUaW1lKHF1ZXJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldEFuZFNhdmVCaW5hcnkgPSBmdW5jdGlvbiAoa2V5LCBnZXRCaW5hcnkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuYmluYXJ5Q2FjaGUpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeUNhY2hlW2tleV0gPSBnZXRCaW5hcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlDYWNoZVtrZXldO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0VGV4dHVyZU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKHRoaXMuYmluYXJ5Q2FjaGVba2V5XS53ZWJHTFByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbVBpeGVsc0NhbnZhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21QaXhlbHNDYW52YXMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50aHJvd0lmTm9EYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAoIXRoaXMudGV4RGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgYmFja2VuZDogTm8gZGF0YSBmb3VuZCBmb3IgdGhpcyB0ZW5zb3IuIFwiICtcbiAgICAgICAgICAgICAgICBcIkRpZCB5b3UgY2hhbmdlIHlvdXIgYmFja2VuZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBwcm9ncmFtPyBcIiArXG4gICAgICAgICAgICAgICAgXCJOZXcgYmFja2VuZHMgY2FuJ3QgdXNlIFRlbnNvcnMgY3JlYXRlZCB3aXRoIHByZXZpb3VzIGJhY2tlbmRzXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS51cGxvYWRUb0dQVSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgIHZhciB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgICAgICB2YXIgc2hhcGUgPSB0ZXhEYXRhLnNoYXBlLCB2YWx1ZXMgPSB0ZXhEYXRhLnZhbHVlcywgdGV4dHVyZSA9IHRleERhdGEudGV4dHVyZSwgZHR5cGUgPSB0ZXhEYXRhLmR0eXBlLCB0ZXhUeXBlID0gdGV4RGF0YS50ZXhUeXBlO1xuICAgICAgICBpZiAodGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxydURhdGFHUFUuc3BsaWNlKHRoaXMubHJ1RGF0YUdQVS5pbmRleE9mKGRhdGFJZCksIDEpO1xuICAgICAgICAgICAgdGhpcy5scnVEYXRhR1BVLnB1c2goZGF0YUlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkVGltZVByb2dyYW0gPSB0aGlzLmFjdGl2ZVRpbWVycyAhPSBudWxsO1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIGlmIChzaG91bGRUaW1lUHJvZ3JhbSkge1xuICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4U2hhcGUgPSB3ZWJnbF91dGlsLmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUodGhpcy5ncGdwdS5nbCwgc2hhcGUpO1xuICAgICAgICB0ZXhEYXRhLnRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgICAgIHZhciBuZXdUZXh0dXJlID0gdGhpcy5hY3F1aXJlVGV4dHVyZShkYXRhSWQsIHRleFNoYXBlLCB0ZXhUeXBlKTtcbiAgICAgICAgdGV4RGF0YS50ZXh0dXJlID0gbmV3VGV4dHVyZTtcbiAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LnVwbG9hZE1hdHJpeFRvVGV4dHVyZShuZXdUZXh0dXJlLCB0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV0sIHR5cGVkQXJyYXlUb0Zsb2F0MzIodmFsdWVzLCBkdHlwZSkpO1xuICAgICAgICAgICAgdGV4RGF0YS52YWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRXYWl0TXMgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY2FjaGVPbkNQVSA9IGZ1bmN0aW9uIChkYXRhSWQsIGZsb2F0MzJWYWx1ZXMpIHtcbiAgICAgICAgdmFyIGRvbnRLZWVwQ29weU9uR1BVID0gdGhpcy5kZWxheWVkU3RvcmFnZTtcbiAgICAgICAgdmFyIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGV4RGF0YS50ZXh0dXJlLCB0ZXhTaGFwZSA9IHRleERhdGEudGV4U2hhcGUsIGR0eXBlID0gdGV4RGF0YS5kdHlwZSwgdGV4VHlwZSA9IHRleERhdGEudGV4VHlwZTtcbiAgICAgICAgaWYgKGRvbnRLZWVwQ29weU9uR1BVICYmIHRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlVGV4dHVyZShkYXRhSWQsIHRleHR1cmUsIHRleFNoYXBlLCB0ZXhUeXBlKTtcbiAgICAgICAgICAgIHRleERhdGEudGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICB0ZXhEYXRhLnRleFNoYXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxvYXQzMlZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZXhEYXRhLnZhbHVlcyA9IGZsb2F0MzJUb1R5cGVkQXJyYXkoZmxvYXQzMlZhbHVlcywgZHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZSA9IGZ1bmN0aW9uIChkYXRhSWQsIHRleHR1cmUsIHRleFNoYXBlLCB0ZXhUeXBlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKSwgc2hhcGUgPSBfYS5zaGFwZSwgZHR5cGUgPSBfYS5kdHlwZTtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMubHJ1RGF0YUdQVS5pbmRleE9mKGRhdGFJZCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5scnVEYXRhR1BVLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVtQnl0ZXNJbkdQVSAtPSB0aGlzLmNvbXB1dGVCeXRlcyhzaGFwZSwgZHR5cGUpO1xuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRleHR1cmUsIHRleFNoYXBlLCB0ZXhUeXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlID0gZnVuY3Rpb24gKGRhdGFJZCwgdGV4U2hhcGUsIHRleFR5cGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpLCBzaGFwZSA9IF9hLnNoYXBlLCBkdHlwZSA9IF9hLmR0eXBlO1xuICAgICAgICB0aGlzLmxydURhdGFHUFUucHVzaChkYXRhSWQpO1xuICAgICAgICB0aGlzLm51bUJ5dGVzSW5HUFUgKz0gdGhpcy5jb21wdXRlQnl0ZXMoc2hhcGUsIGR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodGV4U2hhcGUsIHRleFR5cGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29tcHV0ZUJ5dGVzID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKSAqIHV0aWwuYnl0ZXNQZXJFbGVtZW50KGR0eXBlKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXRoQmFja2VuZFdlYkdMO1xufSgpKTtcbmV4cG9ydHMuTWF0aEJhY2tlbmRXZWJHTCA9IE1hdGhCYWNrZW5kV2ViR0w7XG5pZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdJU19CUk9XU0VSJykpIHtcbiAgICBlbnZpcm9ubWVudF8xLkVOVi5yZWdpc3RlckJhY2tlbmQoJ3dlYmdsJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hdGhCYWNrZW5kV2ViR0woKTsgfSwgMik7XG59XG5mdW5jdGlvbiBmbG9hdDMyVG9UeXBlZEFycmF5KGEsIGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInIHx8IGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IChkdHlwZSA9PT0gJ2ludDMyJykgPyBuZXcgSW50MzJBcnJheShhLmxlbmd0aCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gTWF0aC5yb3VuZChhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0eXBlZEFycmF5VG9GbG9hdDMyKGEsIGR0eXBlKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSA/IGEgOiBuZXcgRmxvYXQzMkFycmF5KGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZF93ZWJnbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBcmdNaW5NYXhQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmdNaW5NYXhQcm9ncmFtKHJlZHVjZUluZm8sIG9wLCBmaXJzdFBhc3MpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlSW5mby53aW5kb3dTaXplO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gcmVkdWNlSW5mby5iYXRjaFNpemU7XG4gICAgICAgIHZhciBpblNpemUgPSByZWR1Y2VJbmZvLmluU2l6ZTtcbiAgICAgICAgdmFyIG91dFNpemUgPSBNYXRoLmNlaWwoaW5TaXplIC8gd2luZG93U2l6ZSk7XG4gICAgICAgIGlmICghZmlyc3RQYXNzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmVzdEluZGljZXNBJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dFNpemVdO1xuICAgICAgICB2YXIgY29tcE9wID0gKG9wID09PSAnbWF4JykgPyAnPicgOiAnPCc7XG4gICAgICAgIHZhciBpbmRleFNuaXBwZXQgPSBmaXJzdFBhc3MgP1xuICAgICAgICAgICAgJ2luT2Zmc2V0ICsgaTsnIDpcbiAgICAgICAgICAgICdyb3VuZChnZXRCZXN0SW5kaWNlc0EoYmF0Y2gsIGluT2Zmc2V0ICsgaSkpOyc7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiICsgd2luZG93U2l6ZSArIFwiO1xcblxcbiAgICAgICAgaW50IGJlc3RJbmRleCA9IDA7XFxuICAgICAgICBmbG9hdCBiZXN0VmFsdWUgPSBnZXRBKGJhdGNoLCBpbk9mZnNldCk7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgd2luZG93U2l6ZSArIFwiOyBpKyspIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gXCIgKyBpbmRleFNuaXBwZXQgKyBcIjtcXG4gICAgICAgICAgZmxvYXQgY2FuZGlkYXRlID0gZ2V0QShiYXRjaCwgaW5JZHgpO1xcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlIFwiICsgY29tcE9wICsgXCIgYmVzdFZhbHVlKSB7XFxuICAgICAgICAgICAgYmVzdFZhbHVlID0gY2FuZGlkYXRlO1xcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGluSWR4O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoYmVzdEluZGV4KSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEFyZ01pbk1heFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5BcmdNaW5NYXhQcm9ncmFtID0gQXJnTWluTWF4UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyZ21pbm1heF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQXZnUG9vbDJEQmFja3Byb3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdmdQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIGF2Z011bHRpcGxpZXIgPSAxIC8gKGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG4gICAgICBjb25zdCBmbG9hdCBhdmdNdWx0aXBsaWVyID0gZmxvYXQoXCIgKyBhdmdNdWx0aXBsaWVyICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIgKyBzdHJpZGVIZWlnaHQgKyBcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIiArIGNvbnZJbmZvLm91dEhlaWdodCArIFwiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIiArIHN0cmlkZVdpZHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgaWR5UiwgaWR5QywgZCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogYXZnTXVsdGlwbGllcjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBBdmdQb29sMkRCYWNrcHJvcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5BdmdQb29sMkRCYWNrcHJvcFByb2dyYW0gPSBBdmdQb29sMkRCYWNrcHJvcFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdmdfcG9vbF9iYWNrcHJvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIEJhdGNoTm9ybVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhdGNoTm9ybVByb2dyYW0oeFNoYXBlLCBtZWFuU2hhcGUsIHZhcmlhbmNlU2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ21lYW4nLCAndmFyaWFuY2UnXTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCBtZWFuU2hhcGUpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh4U2hhcGUsIHZhcmlhbmNlU2hhcGUpO1xuICAgICAgICB2YXIgb2Zmc2V0U25pcHBldCA9ICcwLjAnO1xuICAgICAgICBpZiAob2Zmc2V0U2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCBvZmZzZXRTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICBvZmZzZXRTbmlwcGV0ID0gJ2dldE9mZnNldEF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZVNuaXBwZXQgPSAnMS4wJztcbiAgICAgICAgaWYgKHNjYWxlU2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCBzY2FsZVNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdzY2FsZScpO1xuICAgICAgICAgICAgc2NhbGVTbmlwcGV0ID0gJ2dldFNjYWxlQXRPdXRDb29yZHMoKSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBvZmZzZXQgPSBcIiArIG9mZnNldFNuaXBwZXQgKyBcIjtcXG4gICAgICAgIGZsb2F0IHNjYWxlID0gXCIgKyBzY2FsZVNuaXBwZXQgKyBcIjtcXG4gICAgICAgIGZsb2F0IGludiA9IHNjYWxlICogaW52ZXJzZXNxcnQodmFyaWFuY2UgKyBmbG9hdChcIiArIHZhcmlhbmNlRXBzaWxvbiArIFwiKSk7XFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJhdGNoTm9ybVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5CYXRjaE5vcm1Qcm9ncmFtID0gQmF0Y2hOb3JtUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhdGNobm9ybV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIENIRUNLX05BTl9TTklQUEVUID0gXCJcXG4gIGlmIChpc05hTihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNOYU4oYikpIHJldHVybiBiO1xcblwiO1xuZXhwb3J0cy5BREQgPSAncmV0dXJuIGEgKyBiOyc7XG5leHBvcnRzLlNVQiA9ICdyZXR1cm4gYSAtIGI7JztcbmV4cG9ydHMuTVVMID0gJ3JldHVybiBhICogYjsnO1xuZXhwb3J0cy5ESVYgPSAncmV0dXJuIGEgLyBiOyc7XG5leHBvcnRzLklOVF9ESVYgPSBcIlxcbiAgZmxvYXQgcmVzdWx0U2lnbiA9IHNpZ24oYSkgKiBzaWduKGIpO1xcbiAgaW50IGlhID0gcm91bmQoYSk7XFxuICBpbnQgaWIgPSByb3VuZChiKTtcXG4gIGludCByZXN1bHQgPSBpYSAvIGliO1xcbiAgaW50IGFtb2RiID0gaWEgLSBpYiAqIHJlc3VsdDtcXG5cXG4gIGlmIChyZXN1bHRTaWduIDwgMC4wICYmIGFtb2RiICE9IDApIHtcXG4gICAgcmVzdWx0IC09IDE7XFxuICB9XFxuICByZXR1cm4gZmxvYXQocmVzdWx0KTtcXG5cIjtcbmV4cG9ydHMuUE9XID0gXCJcXG4gIHJldHVybiAocm91bmQobW9kKGIsIDIuMCkpID09IDAgfHwgcm91bmQobW9kKGIsIDIuMCkpID09IDIpID9cXG4gICAgICBwb3coYWJzKGEpLCBiKSA6IHNpZ24oYSkgKiBwb3coYWJzKGEpLCBiKTtcXG5cIjtcbmV4cG9ydHMuU1FVQVJFRF9ESUZGRVJFTkNFID0gJ3JldHVybiAoYSAtIGIpICogKGEgLSBiKTsnO1xuZXhwb3J0cy5FUVVBTCA9IFwicmV0dXJuIGZsb2F0KGEgPT0gYik7XCI7XG5leHBvcnRzLk5PVF9FUVVBTCA9IFwicmV0dXJuIGZsb2F0KGEgIT0gYik7XCI7XG5leHBvcnRzLkxFU1MgPSBcInJldHVybiBmbG9hdChhIDwgYik7XCI7XG5leHBvcnRzLkxFU1NfRVFVQUwgPSBcInJldHVybiBmbG9hdChhIDw9IGIpO1wiO1xuZXhwb3J0cy5HUkVBVEVSID0gXCJyZXR1cm4gZmxvYXQoYSA+IGIpO1wiO1xuZXhwb3J0cy5HUkVBVEVSX0VRVUFMID0gXCJyZXR1cm4gZmxvYXQoYSA+PSBiKTtcIjtcbmV4cG9ydHMuTE9HSUNBTF9BTkQgPSBcInJldHVybiBmbG9hdChhID49IDEuMCAmJiBiID49IDEuMCk7XCI7XG5leHBvcnRzLkxPR0lDQUxfT1IgPSBcInJldHVybiBmbG9hdChhID49IDEuMCB8fCBiID49IDEuMCk7XCI7XG5leHBvcnRzLk1BWCA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBtYXgoYSwgYik7XFxuXCI7XG5leHBvcnRzLk1JTiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBtaW4oYSwgYik7XFxuXCI7XG5leHBvcnRzLk1PRCA9IFwicmV0dXJuIG1vZChhLCBiKTtcIjtcbmV4cG9ydHMuQVRBTjIgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gYXRhbihhLCBiKTtcXG5cIjtcbmV4cG9ydHMuRUxVX0RFUiA9IFwicmV0dXJuIChiID49IDEuMCkgPyBhIDogYSAqIChiICsgMS4wKTtcIjtcbnZhciBCaW5hcnlPcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wUHJvZ3JhbShvcCwgYVNoYXBlLCBiU2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPVxuICAgICAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYVNoYXBlLCBiU2hhcGUpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBmbG9hdCBiaW5hcnlPcGVyYXRpb24oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICAgICAgXCIgKyBvcCArIFwiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBCaW5hcnlPcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5CaW5hcnlPcFByb2dyYW0gPSBCaW5hcnlPcFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5hcnlvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2xpcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaXBQcm9ncmFtKGFTaGFwZSwgbWluLCBtYXgpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgICAgIHZhciBtaW5GaXhlZCA9IG1pbi50b0ZpeGVkKDIwKTtcbiAgICAgICAgdmFyIG1heEZpeGVkID0gbWF4LnRvRml4ZWQoMjApO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIFwiICsgbWluRml4ZWQgKyBcIiwgXCIgKyBtYXhGaXhlZCArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENsaXBQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ2xpcFByb2dyYW0gPSBDbGlwUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaXBfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uLy4uL29wcy9jb25jYXRfdXRpbFwiKTtcbnZhciBDb25jYXRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jYXRQcm9ncmFtKGFTaGFwZSwgYlNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQScsICdCJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9XG4gICAgICAgICAgICBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYVNoYXBlLCBiU2hhcGUsIDEpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB5UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHlDID0gY29vcmRzLnk7XFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcXG4gICAgICAgIGlmICh5QyA8IFwiICsgYVNoYXBlWzFdICsgXCIpIHtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRBKHlSLCB5Qyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB5QyAtPSBcIiArIGFTaGFwZVsxXSArIFwiO1xcbiAgICAgICAgICB2YWx1ZSA9IGdldEIoeVIsIHlDKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbmNhdFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db25jYXRQcm9ncmFtID0gQ29uY2F0UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29udjJERGVyRmlsdGVyUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVyRmlsdGVyUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnZHknXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmZpbHRlclNoYXBlO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiICsgY29udkluZm8uYmF0Y2hTaXplICsgXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIiArIHN0cmlkZUhlaWdodCArIFwiIC0gXCIgKyBwYWRUb3AgKyBcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIiArIHN0cmlkZVdpZHRoICsgXCIgLSBcIiArIHBhZExlZnQgKyBcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlckZpbHRlclByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkREZXJGaWx0ZXJQcm9ncmFtID0gQ29udjJERGVyRmlsdGVyUHJvZ3JhbTtcbnZhciBDb252MkREZXJJbnB1dFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYyRERlcklucHV0UHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiICsgZmlsdGVySGVpZ2h0ICsgXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIiArIHN0cmlkZVdpZHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIgKyBmaWx0ZXJXaWR0aCArIFwiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIiArIGNvbnZJbmZvLm91dENoYW5uZWxzICsgXCI7IGQyKyspIHtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlcklucHV0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlcklucHV0UHJvZ3JhbSA9IENvbnYyRERlcklucHV0UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfYmFja3Byb3BfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ2R5J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5maWx0ZXJTaGFwZTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBjaGFubmVsTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkbSA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQyID0gZDEgKiBcIiArIGNoYW5uZWxNdWwgKyBcIiArIGRtO1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIC8vIFRPRE86IFZlYzQgb3ZlciB0aGUgYmF0Y2ggc2l6ZVxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIiArIGNvbnZJbmZvLmJhdGNoU2l6ZSArIFwiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCI7IHlSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiAtIFwiICsgcGFkVG9wICsgXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIgKyBjb252SW5mby5vdXRXaWR0aCArIFwiOyB5QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIgKyBzdHJpZGVXaWR0aCArIFwiIC0gXCIgKyBwYWRMZWZ0ICsgXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgY29udkluZm8uaW5XaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBEZXB0aHdpc2VDb252MkREZXJGaWx0ZXJQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuRGVwdGh3aXNlQ29udjJERGVyRmlsdGVyUHJvZ3JhbSA9IERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW07XG52YXIgRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXB0aHdpc2VDb252MkREZXJJbnB1dFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeScsICdXJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgY2hhbm5lbE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIgKyBzdHJpZGVIZWlnaHQgKyBcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIiArIGNvbnZJbmZvLm91dEhlaWdodCArIFwiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGludCB3UlBlcm0gPSBcIiArIGZpbHRlckhlaWdodCArIFwiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyBjb252SW5mby5vdXRXaWR0aCArIFwiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiICsgZmlsdGVyV2lkdGggKyBcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAvLyBUT0RPOiBWZWM0IG92ZXIgdGhlIGNoYW5uZWxNdWxcXG4gICAgICAgICAgICBmb3IgKGludCBkbSA9IDA7IGRtIDwgXCIgKyBjaGFubmVsTXVsICsgXCI7IGRtKyspIHtcXG4gICAgICAgICAgICAgIGludCBkMiA9IGQxICogXCIgKyBjaGFubmVsTXVsICsgXCIgKyBkbTtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZG0pO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIERlcHRod2lzZUNvbnYyRERlcklucHV0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkRlcHRod2lzZUNvbnYyRERlcklucHV0UHJvZ3JhbSA9IERlcHRod2lzZUNvbnYyRERlcklucHV0UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfYmFja3Byb3BfZ3B1X2RlcHRod2lzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb252MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihjb252SW5mby5pbkNoYW5uZWxzIC8gNCkgKiA0O1xuICAgICAgICB2YXIgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSBjb252SW5mby5pbkNoYW5uZWxzICUgNDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMylcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAyLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDMsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSAqXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSlcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb252MkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJEUHJvZ3JhbSA9IENvbnYyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZXB0aHdpc2VDb252MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXB0aHdpc2VDb252MkRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIHhOdW1Sb3dzID0gY29udkluZm8uaW5IZWlnaHQ7XG4gICAgICAgIHZhciB4TnVtQ29scyA9IGNvbnZJbmZvLmluV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICAgICAgdmFyIGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGNoYW5uZWxNdWwgPSBjb252SW5mby5vdXRDaGFubmVscyAvIGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDEgPSBkMiAvIFwiICsgY2hhbm5lbE11bCArIFwiO1xcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogXCIgKyBjaGFubmVsTXVsICsgXCI7XFxuXFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBxKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIC8vIFRPRE8oZHNtaWxrb3YpOiBGbGF0dGVuIHRoZSB0d28gZm9yIGxvb3BzIGFuZCB2ZWM0IHRoZSBvcGVyYXRpb25zLlxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiICsgZGlsYXRpb25IZWlnaHQgKyBcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiICsgZGlsYXRpb25XaWR0aCArIFwiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xcbiAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbCAqIHdWYWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRGVwdGh3aXNlQ29udjJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkRlcHRod2lzZUNvbnYyRFByb2dyYW0gPSBEZXB0aHdpc2VDb252MkRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl9ncHVfZGVwdGh3aXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIEN1bVN1bVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEN1bVN1bVByb2dyYW0oc2hhcGUsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHNoYXBlO1xuICAgICAgICB2YXIgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGZpbmFsRGltID0gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gcmV2ZXJzZSA/ICc8JyA6ICc+JztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgaW50IGdldEluZGV4KGludCBpKSB7XFxuICAgICAgICBcIiArIChyZXZlcnNlID8gXCJyZXR1cm4gXCIgKyBmaW5hbERpbSArIFwiIC1pIC0gMTtcIiA6ICdyZXR1cm4gaTsnKSArIFwiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUocmFuaykgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBlbmQgPSBcIiArIGdldEZpbmFsQ29vcmQocmFuaywgJ2Nvb3JkcycpICsgXCI7XFxuICAgICAgICBmbG9hdCB2YWwgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBpID0gXCIgKyBmaW5hbERpbSArIFwiIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcXG4gICAgICAgICAgaW50IGlkeCA9IGdldEluZGV4KGkpO1xcbiAgICAgICAgICBpZiAoaWR4IFwiICsgY29tcGFyYXRvciArIFwiIGVuZCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChpZHggPT0gZW5kICYmIFwiICsgZXhjbHVzaXZlICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBcIiArIGdldEZpbmFsQ29vcmQocmFuaywgJ2Nvb3JkcycpICsgXCIgPSBpZHg7XFxuICAgICAgICAgIHZhbCArPSBnZXRYKFwiICsgZ2V0Q29vcmRzKHJhbmssICdjb29yZHMnKSArIFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDdW1TdW1Qcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ3VtU3VtUHJvZ3JhbSA9IEN1bVN1bVByb2dyYW07XG5mdW5jdGlvbiBnZXRDb29yZHMocmFuaywgbmFtZSkge1xuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmFtZSArIFwiLngsIFwiICsgbmFtZSArIFwiLnlcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmFtZSArIFwiLngsIFwiICsgbmFtZSArIFwiLnksIFwiICsgbmFtZSArIFwiLnpcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgICAgICByZXR1cm4gbmFtZSArIFwiLngsIFwiICsgbmFtZSArIFwiLnksIFwiICsgbmFtZSArIFwiLnosIFwiICsgbmFtZSArIFwiLndcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RmluYWxDb29yZChyYW5rLCBuYW1lKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIueVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIuelwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIud1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdW1zdW1fZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEZyb21QaXhlbHNQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcm9tUGl4ZWxzUHJvZ3JhbShvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IG91dHB1dFNoYXBlWzBdLCB3aWR0aCA9IG91dHB1dFNoYXBlWzFdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiICsgd2lkdGggKyBcIi4wLCBcIiArIGhlaWdodCArIFwiLjApO1xcblxcbiAgICAgICAgdmVjNCB2YWx1ZXMgPSB0ZXh0dXJlMkQoQSwgdXYpO1xcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRnJvbVBpeGVsc1Byb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Gcm9tUGl4ZWxzUHJvZ3JhbSA9IEZyb21QaXhlbHNQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbV9waXhlbHNfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIEdhdGhlclByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhdGhlclByb2dyYW0oYVNoYXBlLCBpbmRpY2VzTGVuZ3RoLCBheGlzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQScsICdpbmRpY2VzJ107XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IGFTaGFwZS5zbGljZSgpO1xuICAgICAgICBvdXRwdXRTaGFwZVtheGlzXSA9IGluZGljZXNMZW5ndGg7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc291cmNlQ29vcmRzID0gZ2V0U291cmNlQ29vcmRzKGFTaGFwZSwgYXhpcyk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIgKyBzb3VyY2VDb29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBHYXRoZXJQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuR2F0aGVyUHJvZ3JhbSA9IEdhdGhlclByb2dyYW07XG5mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMoYVNoYXBlLCBheGlzKSB7XG4gICAgdmFyIHJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkdhdGhlciBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiaW50KGdldEluZGljZXMocmVzUkMpKVwiO1xuICAgIH1cbiAgICB2YXIgY3VycmVudENvb3JkcyA9IFsncmVzUkMueCcsICdyZXNSQy55JywgJ3Jlc1JDLnonLCAncmVzUkMudyddO1xuICAgIHZhciBzb3VyY2VDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gYXhpcykge1xuICAgICAgICAgICAgc291cmNlQ29vcmRzLnB1c2goXCJpbnQoZ2V0SW5kaWNlcyhcIiArIGN1cnJlbnRDb29yZHNbaV0gKyBcIikpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlQ29vcmRzLnB1c2goXCJcIiArIGN1cnJlbnRDb29yZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VDb29yZHMuam9pbigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2F0aGVyX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdwZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi9ncGdwdV91dGlsXCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsX3V0aWxcIik7XG52YXIgR1BHUFVDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHUEdQVUNvbnRleHQoZ2wpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLml0ZW1zVG9Qb2xsID0gW107XG4gICAgICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gZ3BncHVfdXRpbC5jcmVhdGVXZWJHTENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb3NlQ29udGV4dEV4dGVuc2lvbiA9XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBncGdwdV91dGlsLmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyID0gd2ViZ2xfdXRpbC5jcmVhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICB9XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uJyArXG4gICAgICAgICAgICAgICAgJyBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBwcm9ncmFtIHdpdGggJyArXG4gICAgICAgICAgICAgICAgJ0dQR1BVQ29udGV4dC5kZWxldGVQcm9ncmFtIGJlZm9yZSBkaXNwb3NpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggJyArXG4gICAgICAgICAgICAgICAgJ3RleHR1cmUuICBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBvdXRwdXQgJyArXG4gICAgICAgICAgICAgICAgJ21hdHJpeCB0ZXh0dXJlIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZU1hdHJpeFRleHR1cmUgYmVmb3JlICcgK1xuICAgICAgICAgICAgICAgICdkaXNwb3NpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZpbmlzaCgpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlRnJhbWVidWZmZXIoX3RoaXMuZnJhbWVidWZmZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kZWxldGVCdWZmZXIoX3RoaXMudmVydGV4QnVmZmVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kZWxldGVCdWZmZXIoX3RoaXMuaW5kZXhCdWZmZXIpOyB9KTtcbiAgICAgICAgdGhpcy5sb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZW5hYmxlQXV0b21hdGljRGVidWdWYWxpZGF0aW9uID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSA9IGVuYWJsZWQ7XG4gICAgICAgIHdlYmdsX3V0aWwuZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcoZW5hYmxlZCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZU1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5jcmVhdGVNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcGl4ZWxzKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGdwZ3B1X3V0aWwudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHBpeGVscyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKHRoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWxldGVNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRNYXRyaXhUb1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBudW1DaGFubmVscyA9IDE7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgsIG51bUNoYW5uZWxzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHRleHR1cmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZUFzeW5jID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZG93bmxvYWQgbWF0cml4IGZyb20gb3V0cHV0IHRleHR1cmUgYXN5bmNocm9ub3VzbHksIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYyBpcyBub3QgZW5hYmxlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlckFzeW5jKHRleHR1cmUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jKF90aGlzLmdsLCBfdGhpcy5nZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24sIHJvd3MsIGNvbHVtbnMpOyB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucywgY2hhbm5lbHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zLCBjaGFubmVscyk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gd2ViZ2xfdXRpbC5jcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgICAgICB2YXIgdmVydGV4U2hhZGVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wpO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHdlYmdsX3V0aWwuY3JlYXRlUHJvZ3JhbShnbCk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5saW5rUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnZlcnRleEF0dHJzQXJlQm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZCA9IGdwZ3B1X3V0aWwuYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGdsLCB0aGlzLnByb2dyYW0sIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVsZXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChwcm9ncmFtID09PSB0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0UHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIGlmICgodGhpcy5wcm9ncmFtICE9IG51bGwpICYmIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSwgc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgaWYgKHNob3VsZFRocm93ID09PSB2b2lkIDApIHsgc2hvdWxkVGhyb3cgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHdlYmdsX3V0aWwuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3codGhpcy5nbCwgcHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdlYmdsX3V0aWwuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbih0aGlzLmdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb24gPSBmdW5jdGlvbiAocHJvZ3JhbSwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGUpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRJbnB1dE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAoaW5wdXRNYXRyaXhUZXh0dXJlLCB1bmlmb3JtTG9jYXRpb24sIHRleHR1cmVVbml0KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgICAgICB3ZWJnbF91dGlsLmJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIodGhpcy5nbCwgdGhpcy5wcm9ncmFtLCBpbnB1dE1hdHJpeFRleHR1cmUsIHVuaWZvcm1Mb2NhdGlvbiwgdGV4dHVyZVVuaXQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKG91dHB1dE1hdHJpeFRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKG91dHB1dE1hdHJpeFRleHR1cmUsIGNvbHVtbnMsIHJvd3MpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKG91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIob3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBudW1Sb3dzLCBzdGFydENvbHVtbiwgbnVtQ29sdW1ucykge1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKHN0YXJ0Q29sdW1uLCBzdGFydFJvdywgbnVtQ29sdW1ucywgbnVtUm93cyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBudW1Sb3dzLCBzdGFydENvbHVtbiwgbnVtQ29sdW1ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVidWdWYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZXhlY3V0ZVByb2dyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z1ZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZmluaXNoKCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykgPT09IDIgP1xuICAgICAgICAgICAgICAgICAgICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMicgOlxuICAgICAgICAgICAgICAgICAgICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9uO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucnVuUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlGbikge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLmJlZ2luUXVlcnkoKTtcbiAgICAgICAgcXVlcnlGbigpO1xuICAgICAgICB0aGlzLmVuZFF1ZXJ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvbGxRdWVyeVRpbWUocXVlcnkpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5iZWdpblF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZ2wyID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHZhciBleHRfMSA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5XzEgPSBnbDIuY3JlYXRlUXVlcnkoKTtcbiAgICAgICAgICAgIGdsMi5iZWdpblF1ZXJ5KGV4dF8xLlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5XzEpO1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5XzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO1xuICAgICAgICB2YXIgcXVlcnkgPSBleHQuY3JlYXRlUXVlcnlFWFQoKTtcbiAgICAgICAgZXh0LmJlZ2luUXVlcnlFWFQoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5lbmRRdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICAgICAgdmFyIGdsMiA9IHRoaXMuZ2w7XG4gICAgICAgICAgICB2YXIgZXh0XzIgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTtcbiAgICAgICAgICAgIGdsMi5lbmRRdWVyeShleHRfMi5USU1FX0VMQVBTRURfRVhUKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0ID0gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7XG4gICAgICAgIGV4dC5lbmRRdWVyeUVYVChleHQuVElNRV9FTEFQU0VEX0VYVCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmlzUXVlcnlBdmFpbGFibGUgPSBmdW5jdGlvbiAocXVlcnksIHF1ZXJ5VGltZXJWZXJzaW9uKSB7XG4gICAgICAgIGlmIChxdWVyeVRpbWVyVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5VGltZXJWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZ2wyID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHZhciBleHQgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBnbDIuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIGdsMi5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2pvaW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2pvaW50ID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIoZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhdGhpcy5kaXNqb2ludDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleHQgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNqb2ludCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNqb2ludCA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGUgJiYgIXRoaXMuZGlzam9pbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucG9sbFF1ZXJ5VGltZSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeVRpbWVyVmVyc2lvbiA9IGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKTtcbiAgICAgICAgICAgIF90aGlzLmFkZEl0ZW1Ub1BvbGwoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaXNRdWVyeUF2YWlsYWJsZShxdWVyeSwgcXVlcnlUaW1lclZlcnNpb24pOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKF90aGlzLmdldFF1ZXJ5VGltZShxdWVyeSwgcXVlcnlUaW1lclZlcnNpb24pKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5wb2xsSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJpblNlYXJjaExhc3RUcnVlKHRoaXMuaXRlbXNUb1BvbGwubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlzRG9uZUZuOyB9KSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGluZGV4OyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlRm4gPSB0aGlzLml0ZW1zVG9Qb2xsW2ldLnJlc29sdmVGbjtcbiAgICAgICAgICAgIHJlc29sdmVGbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXNUb1BvbGwgPSB0aGlzLml0ZW1zVG9Qb2xsLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmFkZEl0ZW1Ub1BvbGwgPSBmdW5jdGlvbiAoaXNEb25lRm4sIHJlc29sdmVGbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLml0ZW1zVG9Qb2xsLnB1c2goeyBpc0RvbmVGbjogaXNEb25lRm4sIHJlc29sdmVGbjogcmVzb2x2ZUZuIH0pO1xuICAgICAgICBpZiAodGhpcy5pdGVtc1RvUG9sbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5yZXBlYXRlZFRyeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wb2xsSXRlbXMoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5pdGVtc1RvUG9sbC5sZW5ndGggPT09IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWUgPSBmdW5jdGlvbiAocXVlcnksIHF1ZXJ5VGltZXJWZXJzaW9uKSB7XG4gICAgICAgIGlmIChxdWVyeVRpbWVyVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5VGltZXJWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZ2wyID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE5hbm9zID0gZ2wyLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBnbDIuUVVFUllfUkVTVUxUKTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lRWxhcHNlZE5hbm9zIC8gMTAwMDAwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleHQgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtcbiAgICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE5hbm9zID0gZXh0LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBleHQuUVVFUllfUkVTVUxUX0VYVCk7XG4gICAgICAgICAgICByZXR1cm4gdGltZUVsYXBzZWROYW5vcyAvIDEwMDAwMDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCwgdGV4dHVyZSwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMub3V0cHV0VGV4dHVyZSwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyID0gZnVuY3Rpb24gKHRleHR1cmUsIGRvd25sb2FkQW5kRGVjb2RlKSB7XG4gICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCh0ZXh0dXJlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRvd25sb2FkQW5kRGVjb2RlKCk7XG4gICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93bigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlckFzeW5jID0gZnVuY3Rpb24gKHRleHR1cmUsIGRvd25sb2FkQW5kRGVjb2RlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyU2V0dXAodGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGRvd25sb2FkQW5kRGVjb2RlKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyVGVhcmRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIgPSBmdW5jdGlvbiAob3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoZ2wsIG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIoZ2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0VGV4dHVyZSA9IG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZDtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNjaXNzb3IoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnRocm93SWZOb1Byb2dyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR1BHUFVDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuR1BHUFVDb250ZXh0ID0gR1BHUFVDb250ZXh0O1xuZnVuY3Rpb24gYmluU2VhcmNoTGFzdFRydWUoYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGJlc3QgPSAtMTtcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgIHZhciBtaWQgPSAoc3RhcnQgKyBlbmQpID4+IDE7XG4gICAgICAgIHZhciBpc0RvbmUgPSBhcnJbbWlkXSgpO1xuICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgICBiZXN0ID0gbWlkO1xuICAgICAgICAgICAgc3RhcnQgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cbmV4cG9ydHMuYmluU2VhcmNoTGFzdFRydWUgPSBiaW5TZWFyY2hMYXN0VHJ1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X2NvbnRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgc2hhZGVyX2NvbXBpbGVyID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIE5BTl9VTklGT1JNX05BTUUgPSAnTmFOJztcbmZ1bmN0aW9uIHNob3VsZFVwbG9hZE5hTlVuaWZvcm0oKSB7XG4gICAgcmV0dXJuICFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xufVxuZnVuY3Rpb24gY29tcGlsZVByb2dyYW0oZ3BncHUsIHByb2dyYW0sIGlucHV0cywgb3V0cHV0KSB7XG4gICAgdmFyIHVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIgaW5wdXRJbmZvcyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIHZhciBzaGFwZUluZm8gPSB7XG4gICAgICAgICAgICBsb2dpY2FsU2hhcGU6IGlucHV0LnRlbnNvci5zaGFwZSxcbiAgICAgICAgICAgIHRleFNoYXBlOiBpbnB1dC50ZXhEYXRhLnRleFNoYXBlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHByb2dyYW0udmFyaWFibGVOYW1lc1tpXSwgc2hhcGVJbmZvOiBzaGFwZUluZm8gfTtcbiAgICB9KTtcbiAgICB2YXIgaW5TaGFwZUluZm9zID0gaW5wdXRJbmZvcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGVJbmZvOyB9KTtcbiAgICB2YXIgb3V0U2hhcGVJbmZvID0ge1xuICAgICAgICBsb2dpY2FsU2hhcGU6IG91dHB1dC50ZW5zb3Iuc2hhcGUsXG4gICAgICAgIHRleFNoYXBlOiBvdXRwdXQudGV4RGF0YS50ZXhTaGFwZVxuICAgIH07XG4gICAgdmFyIHNvdXJjZSA9IHNoYWRlcl9jb21waWxlci5tYWtlU2hhZGVyKGlucHV0SW5mb3MsIG91dFNoYXBlSW5mbywgdXNlckNvZGUsIHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpO1xuICAgIHZhciB3ZWJHTFByb2dyYW0gPSBncGdwdS5jcmVhdGVQcm9ncmFtKHNvdXJjZSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2dyYW0udmFyaWFibGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdW5pZm9ybU5hbWUgPSBwcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdID1cbiAgICAgICAgICAgIGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFVwbG9hZE5hTlVuaWZvcm0oKSkge1xuICAgICAgICB2YXIgdGhyb3dJZk5hTlVuaWZvcm1Jc05vdFVzZWQgPSBmYWxzZTtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1tOQU5fVU5JRk9STV9OQU1FXSA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIE5BTl9VTklGT1JNX05BTUUsIHRocm93SWZOYU5Vbmlmb3JtSXNOb3RVc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHdlYkdMUHJvZ3JhbTogd2ViR0xQcm9ncmFtLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zLFxuICAgICAgICBncGdwdTogZ3BncHUsXG4gICAgICAgIGluU2hhcGVJbmZvczogaW5TaGFwZUluZm9zLFxuICAgICAgICBvdXRTaGFwZUluZm86IG91dFNoYXBlSW5mb1xuICAgIH07XG59XG5leHBvcnRzLmNvbXBpbGVQcm9ncmFtID0gY29tcGlsZVByb2dyYW07XG5mdW5jdGlvbiB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oc2hhcGVJbmZvcywgaW5wdXRzKSB7XG4gICAgaWYgKHNoYXBlSW5mb3MubGVuZ3RoICE9PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIFwiICsgc2hhcGVJbmZvcy5sZW5ndGggKyBcIiBpbnB1dHMsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJ3YXMgZXhlY3V0ZWQgd2l0aCBcIiArIGlucHV0cy5sZW5ndGggKyBcIiBpbnB1dHNcIikpO1xuICAgIH1cbiAgICBzaGFwZUluZm9zLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgdmFyIHNoYXBlQSA9IHMubG9naWNhbFNoYXBlO1xuICAgICAgICB2YXIgdGV4U2hhcGVBID0gcy50ZXhTaGFwZTtcbiAgICAgICAgdmFyIHNoYXBlQiA9IGlucHV0c1tpXS50ZW5zb3Iuc2hhcGU7XG4gICAgICAgIHZhciB0ZXhTaGFwZUIgPSBpbnB1dHNbaV0udGV4RGF0YS50ZXhTaGFwZTtcbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ0aGUgY3VycmVudCBhcmdzLiBTaGFwZXMgXCIgKyBzaGFwZUEgKyBcIiBhbmQgXCIgKyBzaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwodGV4U2hhcGVBLCB0ZXhTaGFwZUIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGVcIiArXG4gICAgICAgICAgICAgICAgKFwiIGN1cnJlbnQgYXJncy4gU2hhcGUgXCIgKyB0ZXhTaGFwZUEgKyBcIiBhbmQgXCIgKyB0ZXhTaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuUHJvZ3JhbShiaW5hcnksIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCkge1xuICAgIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShiaW5hcnkuaW5TaGFwZUluZm9zLCBpbnB1dHMpO1xuICAgIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShbYmluYXJ5Lm91dFNoYXBlSW5mb10sIFtvdXRwdXRdKTtcbiAgICB2YXIgb3V0VGV4ID0gb3V0cHV0LnRleERhdGEudGV4dHVyZTtcbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRwdXQudGV4RGF0YS50ZXhTaGFwZTtcbiAgICB2YXIgZ3BncHUgPSBiaW5hcnkuZ3BncHU7XG4gICAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShvdXRUZXgsIG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSk7XG4gICAgZ3BncHUuc2V0UHJvZ3JhbShiaW5hcnkud2ViR0xQcm9ncmFtKTtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgdmFyIHRleCA9IGlucHV0LnRleERhdGEudGV4dHVyZTtcbiAgICAgICAgdmFyIHZhcmlhYmxlTmFtZSA9IGJpbmFyeS5wcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHZhciB2YXJpYWJsZVVuaWZvcm1Mb2NhdGlvbiA9IGJpbmFyeS51bmlmb3JtTG9jYXRpb25zW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh0ZXgsIHZhcmlhYmxlVW5pZm9ybUxvY2F0aW9uLCBpKTtcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpKSB7XG4gICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihiaW5hcnkudW5pZm9ybUxvY2F0aW9uc1tOQU5fVU5JRk9STV9OQU1FXSwgTmFOKTtcbiAgICB9XG4gICAgaWYgKGN1c3RvbVNldHVwICE9IG51bGwpIHtcbiAgICAgICAgY3VzdG9tU2V0dXAoZ3BncHUsIGJpbmFyeS53ZWJHTFByb2dyYW0pO1xuICAgIH1cbiAgICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuZXhwb3J0cy5ydW5Qcm9ncmFtID0gcnVuUHJvZ3JhbTtcbmZ1bmN0aW9uIG1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpIHtcbiAgICB2YXIga2V5SW5wdXRzID0gJyc7XG4gICAgaW5wdXRzLmNvbmNhdChvdXRwdXQpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAga2V5SW5wdXRzICs9IHgudGVuc29yLnNoYXBlICsgXCJfXCIgKyB4LnRleERhdGEudGV4U2hhcGU7XG4gICAgfSk7XG4gICAgdmFyIGtleVVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIga2V5QnJvYWRjYXN0ID0gKHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpLnRvU3RyaW5nKCk7XG4gICAgdmFyIGtleSA9IHByb2dyYW0uY29uc3RydWN0b3IubmFtZTtcbiAgICBrZXkgKz0gJ18nICsga2V5QnJvYWRjYXN0ICsgJ18nICsga2V5SW5wdXRzICsgJ18nICsga2V5VXNlckNvZGU7XG4gICAgcmV0dXJuIGtleTtcbn1cbmV4cG9ydHMubWFrZVNoYWRlcktleSA9IG1ha2VTaGFkZXJLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncGdwdV9tYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB0ZXhfdXRpbCA9IHJlcXVpcmUoXCIuL3RleF91dGlsXCIpO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbF91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbHBoYTogZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRydWVcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzID0gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcztcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMQ29udGV4dChjYW52YXMpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMoKTtcbiAgICB2YXIgZ2w7XG4gICAgaWYgKGNhbnZhcyAhPSBudWxsKSB7XG4gICAgICAgIGdsID0gd2ViZ2xfdXRpbC5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbCA9IHdlYmdsX3V0aWwuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0KGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuQkxFTkQpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5ESVRIRVIpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuU0FNUExFX0NPVkVSQUdFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jdWxsRmFjZShnbC5CQUNLKTsgfSk7XG4gICAgcmV0dXJuIGdsO1xufVxuZXhwb3J0cy5jcmVhdGVXZWJHTENvbnRleHQgPSBjcmVhdGVXZWJHTENvbnRleHQ7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wpIHtcbiAgICB2YXIgdmVydGV4U2hhZGVyU291cmNlID0gXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBhdHRyaWJ1dGUgdmVjMyBjbGlwU3BhY2VQb3M7XFxuICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlUG9zLCAxKTtcXG4gICAgICByZXN1bHRVViA9IHV2O1xcbiAgICB9XCI7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXI7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhCdWZmZXIoZ2wpIHtcbiAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgMCwgMCwgMSwgLTEsIC0xLCAwLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAxLCAtMSwgMCwgMSwgMF0pO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihnbCwgdmVydGV4QXJyYXkpO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhCdWZmZXIgPSBjcmVhdGVWZXJ0ZXhCdWZmZXI7XG5mdW5jdGlvbiBjcmVhdGVJbmRleEJ1ZmZlcihnbCkge1xuICAgIHZhciB0cmlhbmdsZVZlcnRleEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDIsIDEsIDNdKTtcbiAgICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcihnbCwgdHJpYW5nbGVWZXJ0ZXhJbmRpY2VzKTtcbn1cbmV4cG9ydHMuY3JlYXRlSW5kZXhCdWZmZXIgPSBjcmVhdGVJbmRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbC5SMzJGO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuUkdCQTtcbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgIH1cbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2wuUkVEO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuUkdCQTtcbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVUeXBlKGdsKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuRkxPQVQ7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscykge1xuICAgIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHRleHR1cmUgPSB3ZWJnbF91dGlsLmNyZWF0ZVRleHR1cmUoZ2wpO1xuICAgIHZhciB0ZXgyZCA9IGdsLlRFWFRVUkVfMkQ7XG4gICAgdmFyIGludGVybmFsRm9ybWF0ID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgdmFyIGZvcm1hdCA9IGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUodGV4MmQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhJbWFnZTJEKHRleDJkLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCBnZXRUZXh0dXJlVHlwZShnbCksIG51bGwpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuZnVuY3Rpb24gY3JlYXRlTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDE7XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMuY3JlYXRlTWF0cml4VGV4dHVyZSA9IGNyZWF0ZU1hdHJpeFRleHR1cmU7XG5mdW5jdGlvbiBjcmVhdGVDb2xvck1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLmNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZSA9IGNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlID0gY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyhnbCwgcHJvZ3JhbSwgdmVydGV4QnVmZmVyKSB7XG4gICAgdmFyIHBvc09mZnNldCA9IDA7XG4gICAgdmFyIHV2T2Zmc2V0ID0gMyAqIDQ7XG4gICAgdmFyIHN0cmlkZSA9ICgzICogNCkgKyAoMiAqIDQpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyKTsgfSk7XG4gICAgdmFyIHN1Y2Nlc3MgPSB3ZWJnbF91dGlsLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoZ2wsIHByb2dyYW0sICdjbGlwU3BhY2VQb3MnLCB2ZXJ0ZXhCdWZmZXIsIDMsIHN0cmlkZSwgcG9zT2Zmc2V0KTtcbiAgICByZXR1cm4gc3VjY2VzcyAmJlxuICAgICAgICB3ZWJnbF91dGlsLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoZ2wsIHByb2dyYW0sICd1dicsIHZlcnRleEJ1ZmZlciwgMiwgc3RyaWRlLCB1dk9mZnNldCk7XG59XG5leHBvcnRzLmJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyA9IGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcztcbmZ1bmN0aW9uIHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgcGl4ZWxzKSB7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZXhwb3J0cy51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUgPSB1cGxvYWRQaXhlbERhdGFUb1RleHR1cmU7XG5mdW5jdGlvbiB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBkYXRhLCBudW1DaGFubmVscykge1xuICAgIHZhciB0ZXh0dXJlRm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0ZXh0dXJlRm9ybWF0LCBnZXRUZXh0dXJlVHlwZShnbCksIGRhdGEpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZnVuY3Rpb24gdXBsb2FkTWF0cml4VG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgsIG51bUNoYW5uZWxzKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIHVucGFja2VkQXJyYXk7XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxzUGVyVGV4dHVyZSA9IG51bUNoYW5uZWxzID09PSAxID8gd2ViZ2xfdXRpbC5nZXRDaGFubmVsc1BlclRleHR1cmUoKSA6IG51bUNoYW5uZWxzO1xuICAgICAgICBpZiAoY2hhbm5lbHNQZXJUZXh0dXJlID09PSAxKSB7XG4gICAgICAgICAgICB1bnBhY2tlZEFycmF5ID0gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5wYWNrZWRBcnJheSA9XG4gICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeC5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICAgICAgICAgICAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KG1hdHJpeCwgdW5wYWNrZWRBcnJheSwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5wYWNrZWRBcnJheSA9IHRleF91dGlsLmVuY29kZUZsb2F0QXJyYXkobWF0cml4KTtcbiAgICB9XG4gICAgdXBsb2FkRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgdywgaCwgdW5wYWNrZWRBcnJheSwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy51cGxvYWRNYXRyaXhUb1RleHR1cmUgPSB1cGxvYWRNYXRyaXhUb1RleHR1cmU7XG5mdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUoZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gICAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKG1hdHJpeCwgcm93cywgY29sdW1ucywgcGFja2VkUkdCQSk7XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3LCBoLCBwYWNrZWRSR0JBLCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSA9IHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZTtcbnZhciBmbG9hdERvd25sb2FkQnVmZmVyID0gbnVsbDtcbnZhciBieXRlRG93bmxvYWRCdWZmZXIgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICB2YXIgaXNGbG9hdFRleHR1cmUgPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xuICAgIHZhciBuZWVkZWRTaXplID0gcm93cyAqIGNvbHVtbnMgKiBjaGFubmVsc1BlclRleHR1cmU7XG4gICAgaWYgKGlzRmxvYXRUZXh0dXJlKSB7XG4gICAgICAgIGlmIChmbG9hdERvd25sb2FkQnVmZmVyID09IG51bGwgfHxcbiAgICAgICAgICAgIGZsb2F0RG93bmxvYWRCdWZmZXIubGVuZ3RoIDwgbmVlZGVkU2l6ZSkge1xuICAgICAgICAgICAgZmxvYXREb3dubG9hZEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkobmVlZGVkU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChieXRlRG93bmxvYWRCdWZmZXIgPT0gbnVsbCB8fCBieXRlRG93bmxvYWRCdWZmZXIubGVuZ3RoIDwgbmVlZGVkU2l6ZSkge1xuICAgICAgICAgICAgYnl0ZURvd25sb2FkQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmVlZGVkU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChpc0Zsb2F0VGV4dHVyZSA/IGZsb2F0RG93bmxvYWRCdWZmZXIgOiBieXRlRG93bmxvYWRCdWZmZXIpXG4gICAgICAgIC5zdWJhcnJheSgwLCBuZWVkZWRTaXplKTtcbn1cbmZ1bmN0aW9uIGRlY29kZURvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIoZG93bmxvYWRUYXJnZXQsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpIHtcbiAgICB2YXIgaXNGbG9hdFRleHR1cmUgPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xuICAgIGlmIChpc0Zsb2F0VGV4dHVyZSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShyb3dzICogY29sdW1ucyk7XG4gICAgICAgIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5KGRvd25sb2FkVGFyZ2V0LCBtYXRyaXgsIGNoYW5uZWxzUGVyUGl4ZWwpO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleF91dGlsLmRlY29kZVRvRmxvYXRBcnJheShkb3dubG9hZFRhcmdldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jKGdsLCBnZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24sIHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbDIsIGNoYW5uZWxzUGVyUGl4ZWwsIGRvd25sb2FkVGFyZ2V0LCBidWZmZXJTaXplQnl0ZXMsIGJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgZ2wyID0gZ2w7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzUGVyUGl4ZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFRhcmdldCA9IGdldERvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIocm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclNpemVCeXRlcyA9IGRvd25sb2FkVGFyZ2V0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVGFyZ2V0Lmxlbmd0aCAqIDQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbDIuUElYRUxfUEFDS19CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYnVmZmVyRGF0YShnbDIuUElYRUxfUEFDS19CVUZGRVIsIGJ1ZmZlclNpemVCeXRlcywgZ2wuU1RBVElDX0RSQVcpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnbDIucmVhZFBpeGVscygwLCAwLCBjb2x1bW5zLCByb3dzLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBnZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24uZ2V0QnVmZmVyU3ViRGF0YUFzeW5jKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgMCwgZG93bmxvYWRUYXJnZXQpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBkZWNvZGVEb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKGRvd25sb2FkVGFyZ2V0LCByb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmMgPSBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmM7XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIGNoYW5uZWxzUGVyUGl4ZWwgPSA0O1xuICAgIHZhciBkb3dubG9hZFRhcmdldCA9IGdldERvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIocm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgZ2wuUkdCQSwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBkb3dubG9hZFRhcmdldCk7IH0pO1xuICAgIHJldHVybiBkZWNvZGVEb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKGRvd25sb2FkVGFyZ2V0LCByb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKTtcbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSA9IGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmU7XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zLCBjaGFubmVscykge1xuICAgIHZhciBzaXplID0gcm93cyAqIGNvbHVtbnMgKiA0O1xuICAgIHZhciBkb3dubG9hZFRhcmdldCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5yZWFkUGl4ZWxzKDAsIDAsIGNvbHVtbnMsIHJvd3MsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRvd25sb2FkVGFyZ2V0KTsgfSk7XG4gICAgdmFyIHBhY2tlZFJHQkEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG93bmxvYWRUYXJnZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFja2VkUkdCQVtpXSA9IGRvd25sb2FkVGFyZ2V0W2ldO1xuICAgIH1cbiAgICB2YXIgbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShyb3dzICogY29sdW1ucyAqIGNoYW5uZWxzKTtcbiAgICB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheShwYWNrZWRSR0JBLCBtYXRyaXgsIGNoYW5uZWxzKTtcbiAgICByZXR1cm4gbWF0cml4O1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlID0gZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZTtcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIHBhY2tlZFJHQkEgPSBuZXcgRmxvYXQzMkFycmF5KHRleF91dGlsLmdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucykpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdldFRleHR1cmVUeXBlKGdsKSwgcGFja2VkUkdCQSk7IH0pO1xuICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zKTtcbiAgICByZXR1cm4gdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEocGFja2VkUkdCQSwgcm93cywgY29sdW1ucywgbWF0cml4KTtcbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZSA9IGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncGdwdV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFdoZXJlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2hlcmVQcm9ncmFtKGNSYW5rLCBzaGFwZSwgcmFuaykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2MnLCAnYScsICdiJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdmFyIGNDb29yZHM7XG4gICAgICAgIHZhciBhYkNvb3JkcztcbiAgICAgICAgaWYgKHJhbmsgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIldoZXJlIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgICAgICBhYkNvb3JkcyA9IFwicmVzUkNcIjtcbiAgICAgICAgICAgIGNDb29yZHMgPSBcInJlc1JDXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudENvb3JkcyA9IFsncmVzUkMueCcsICdyZXNSQy55JywgJ3Jlc1JDLnonLCAncmVzUkMudyddO1xuICAgICAgICAgICAgdmFyIGNDb29yZFZhcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhYkNvb3JkVmFycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFiQ29vcmRWYXJzLnB1c2goXCJcIiArIGN1cnJlbnRDb29yZHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgY1JhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgY0Nvb3JkVmFycy5wdXNoKFwiXCIgKyBjdXJyZW50Q29vcmRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjQ29vcmRzID0gY0Nvb3JkVmFycy5qb2luKCk7XG4gICAgICAgICAgICBhYkNvb3JkcyA9IGFiQ29vcmRWYXJzLmpvaW4oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBjVmFsID0gZ2V0QyhcIiArIGNDb29yZHMgKyBcIik7XFxuICAgICAgICBpZiAoY1ZhbCA+PSAxLjApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIgKyBhYkNvb3JkcyArIFwiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QihcIiArIGFiQ29vcmRzICsgXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gV2hlcmVQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuV2hlcmVQcm9ncmFtID0gV2hlcmVQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9naWNhbF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTFJOUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTFJOUHJvZ3JhbSh4U2hhcGUsIHJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIHJhZCA9IHJhZGl1cztcbiAgICAgICAgdmFyIG1heEQgPSB4U2hhcGVbM10gLSAxO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgICB2YXIgcG93T3BlcmF0b3I7XG4gICAgICAgIHZhciBiYXNpcyA9IFwiZmxvYXQoXCIgKyBiaWFzICsgXCIpICsgZmxvYXQoXCIgKyBhbHBoYSArIFwiKSAqIHN1bVwiO1xuICAgICAgICBpZiAoYmV0YSA9PT0gMC41KSB7XG4gICAgICAgICAgICBwb3dPcGVyYXRvciA9IFwiaW52ZXJzZXNxcnQoXCIgKyBiYXNpcyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJldGEgPT09IDEuMCkge1xuICAgICAgICAgICAgcG93T3BlcmF0b3IgPSBcIjEuMC8oXCIgKyBiYXNpcyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG93T3BlcmF0b3IgPSBcImV4cChsb2coXCIgKyBiYXNpcyArIFwiKSAqIGZsb2F0KC1cIiArIGJldGEgKyBcIikpO1wiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0WChiLCByLCBjLCBkKTtcXG4gICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGogPSAtXCIgKyByYWQgKyBcIjsgaiA8PSBcIiArIHJhZCArIFwiOyBqKyspIHtcXG4gICAgICAgICAgaW50IGlkeCA9IGQgKyBqO1xcbiAgICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDw9ICBcIiArIG1heEQgKyBcIikge1xcbiAgICAgICAgICAgIGZsb2F0IHogPSBnZXRYKGIsIHIsIGMsIGlkeCk7XFxuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCB2YWwgPSB4ICogXCIgKyBwb3dPcGVyYXRvciArIFwiO1xcbiAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIExSTlByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5MUk5Qcm9ncmFtID0gTFJOUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxybl9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeScsICdtYXhQb3MnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCAtIDE7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG4gICAgICAgICAgICBpbnQgbWF4UG9zVmFsdWUgPSBcIiArIGxhc3RJbmRleCArIFwiIC0gaW50KGdldE1heFBvcyhiLCBpZHlSLCBpZHlDLCBkKSk7XFxuXFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlLCBjaGVjayBpdCBhZ2FpbnN0IHRoZSB2YWx1ZSBmcm9tIHRoZVxcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cXG4gICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPSB3UiAqIFwiICsgZmlsdGVyV2lkdGggKyBcIiArIHdDO1xcbiAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5NYXhQb29sMkRCYWNrcHJvcFByb2dyYW0gPSBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXhfcG9vbF9iYWNrcHJvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWF0TXVsUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0TXVsUHJvZ3JhbShhU2hhcGUsIGJTaGFwZSwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQikge1xuICAgICAgICBpZiAodHJhbnNwb3NlQSA9PT0gdm9pZCAwKSB7IHRyYW5zcG9zZUEgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodHJhbnNwb3NlQiA9PT0gdm9pZCAwKSB7IHRyYW5zcG9zZUIgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ21hdHJpeEEnLCAnbWF0cml4QiddO1xuICAgICAgICB2YXIgb3V0ZXJTaGFwZUEgPSB0cmFuc3Bvc2VBID8gYVNoYXBlWzFdIDogYVNoYXBlWzBdO1xuICAgICAgICB2YXIgb3V0ZXJTaGFwZUIgPSB0cmFuc3Bvc2VCID8gYlNoYXBlWzBdIDogYlNoYXBlWzFdO1xuICAgICAgICB2YXIgc2hhcmVkRGltID0gdHJhbnNwb3NlQSA/IGFTaGFwZVswXSA6IGFTaGFwZVsxXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtvdXRlclNoYXBlQSwgb3V0ZXJTaGFwZUJdO1xuICAgICAgICB2YXIgYVNuaXBwZXRGcm9tT2Zmc2V0ID0gZnVuY3Rpb24gKHZlYzRPZmZzZXQsIGluZGV4VmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNwb3NlQSA/IGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQgKyBcIiwgYVJvd1wiIDpcbiAgICAgICAgICAgICAgICBcImFSb3csIFwiICsgaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJTbmlwcGV0RnJvbU9mZnNldCA9IGZ1bmN0aW9uICh2ZWM0T2Zmc2V0LCBpbmRleFZhcikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zcG9zZUIgPyBcImJDb2wsIFwiICsgaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldCA6XG4gICAgICAgICAgICAgICAgaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldCArIFwiLCBiQ29sXCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzaGFyZWREaW1OZWFyZXN0VmVjNCA9IE1hdGguZmxvb3Ioc2hhcmVkRGltIC8gNCkgKiA0O1xuICAgICAgICB2YXIgc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9IHNoYXJlZERpbSAlIDQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIiBmbG9hdCBkb3RBUm93QkNvbChpbnQgYVJvdywgaW50IGJDb2wpIHtcXG4gICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHNoYXJlZERpbU5lYXJlc3RWZWM0ICsgXCI7IGkgKz0gNCkge1xcbiAgICAgICAgdmVjNCBhID0gdmVjNChcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDEsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMiwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgzLCAnaScpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgdmVjNCBiID0gdmVjNChcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDEsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMiwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgzLCAnaScpICsgXCIpXFxuICAgICAgICApO1xcblxcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFwiICsgKHNoYXJlZERpbVZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgIHJlc3VsdCArPSBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSAqXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgdmVjMiBhID0gdmVjMihcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgdmVjMiBiID0gdmVjMihcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9IGVsc2UgaWYgKFwiICsgKHNoYXJlZERpbVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgIHZlYzMgYSA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgyLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMzIGIgPSB2ZWMzKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMiwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgaXZlYzIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZG90QVJvd0JDb2wocmVzUkMueCwgcmVzUkMueSkpO1xcbiAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTWF0TXVsUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk1hdE11bFByb2dyYW0gPSBNYXRNdWxQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsbWF0X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNdWx0aW5vbWlhbFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpbm9taWFsUHJvZ3JhbShiYXRjaFNpemUsIG51bU91dGNvbWVzLCBudW1TYW1wbGVzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsncHJvYnMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG51bVNhbXBsZXNdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHNlZWQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuXFxuICAgICAgICBmbG9hdCByID0gcmFuZG9tKHNlZWQpO1xcbiAgICAgICAgZmxvYXQgY2RmID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIChudW1PdXRjb21lcyAtIDEpICsgXCI7IGkrKykge1xcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICBpZiAociA8IGNkZikge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBubyBvdGhlciBldmVudCBoYXBwZW5lZCwgbGFzdCBldmVudCBoYXBwZW5lZC5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChcIiArIChudW1PdXRjb21lcyAtIDEpICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBNdWx0aW5vbWlhbFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNlZWRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlZWRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnc2VlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKF90aGlzLnNlZWRMb2MsIHNlZWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpbm9taWFsUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk11bHRpbm9taWFsUHJvZ3JhbSA9IE11bHRpbm9taWFsUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpbm9taWFsX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPbmVIb3RQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPbmVIb3RQcm9ncmFtKG51bUluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2luZGljZXMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtudW1JbmRpY2VzLCBkZXB0aF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xcbiAgICAgICAgc2V0T3V0cHV0KG1peChmbG9hdChcIiArIG9mZlZhbHVlICsgXCIpLCBmbG9hdChcIiArIG9uVmFsdWUgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBPbmVIb3RQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuT25lSG90UHJvZ3JhbSA9IE9uZUhvdFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmVob3RfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFBhZFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZFByb2dyYW0oeFNoYXBlLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gcFswXSArIHhTaGFwZVtpXSArIHBbMV07IH0pO1xuICAgICAgICB2YXIgcmFuayA9IHhTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciB0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSkuam9pbignLCcpO1xuICAgICAgICB2YXIgZW5kID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdICsgeFNoYXBlW2ldOyB9KS5qb2luKCcsJyk7XG4gICAgICAgIHZhciB1bnBhY2tlZENvb3JkcyA9IFsnY29vcmRzWzBdJywgJ2Nvb3Jkc1sxXScsICdjb29yZHNbMl0nLCAnY29vcmRzWzNdJ10uc2xpY2UoMCwgcmFuayk7XG4gICAgICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIGludCBzdGFydCA9IFwiICsgc3RhcnQgKyBcIjtcXG4gICAgICAgIGludCBlbmQgPSBcIiArIGVuZCArIFwiO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpZiAob3V0QyA8IHN0YXJ0IHx8IG91dEMgPj0gZW5kKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiICsgY29uc3RhbnRWYWx1ZSArIFwiKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGdldFgob3V0QyAtIHN0YXJ0KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIHR5cGUgKyBcIiBzdGFydCA9IFwiICsgdHlwZSArIFwiKFwiICsgc3RhcnQgKyBcIik7XFxuICAgICAgXCIgKyB0eXBlICsgXCIgZW5kID0gXCIgKyB0eXBlICsgXCIoXCIgKyBlbmQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyB0eXBlICsgXCIgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGFueShsZXNzVGhhbihvdXRDLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKG91dEMsIGVuZCkpKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIiArIGNvbnN0YW50VmFsdWUgKyBcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIgKyB0eXBlICsgXCIgY29vcmRzID0gb3V0QyAtIHN0YXJ0O1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIHVucGFja2VkQ29vcmRzICsgXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUGFkUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlBhZFByb2dyYW0gPSBQYWRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQb29sMkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb29sMkRQcm9ncmFtKGNvbnZJbmZvLCBwb29sVHlwZSwgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJyAmJiBjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wdXRlIHBvc2l0aW9ucyBmb3IgYXZlcmFnZSBwb29sLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgaXNBdmdQb29sID0gcG9vbFR5cGUgPT09ICdhdmcnO1xuICAgICAgICB2YXIgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcwLjAnO1xuICAgICAgICBpZiAoIWlzQXZnUG9vbCkge1xuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICctMS4wIC8gMC4wJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVPcF8xID0gJz49JztcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuXFxuICAgICAgICAgICAgICAvLyBJZiBhIG1pbiAvIG1heCB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuIGZvdW5kLCB1c2UgaXQuIElmIG5vdCxcXG4gICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cXG4gICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcXG4gICAgICAgICAgICAgICAgICB2YWx1ZSwgbWluTWF4VmFsdWUsIG1pbk1heFZhbHVlRm91bmQpO1xcbiAgICAgICAgICAgICAgaWYgKHZhbHVlIFwiICsgY29tcGFyZU9wXzEgKyBcIiBjdXJyTWluTWF4VmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcXG4gICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSB3UiAqIFwiICsgZmlsdGVyV2lkdGggKyBcIiArIHdDO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQobWluTWF4UG9zaXRpb24pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGFyZU9wID0gJ21heCc7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHBvb2xUeXBlICsgXCIoXCIgKyBwb29sVHlwZSArIFwiKFwiICsgcG9vbFR5cGUgKyBcIihcIiArXG4gICAgICAgICAgICAnbWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSknO1xuICAgICAgICBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwiYXZnVmFsdWUgLyBjb3VudFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihmaWx0ZXJXaWR0aCAvIDQpICogNDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9IGZpbHRlcldpZHRoICUgNDtcbiAgICAgICAgdmFyIHVwZGF0ZVNuaXBwZXQgPSBcIlxcbiAgICAgIGlmIChcIiArIGlzQXZnUG9vbCArIFwiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIiArIGNvbXBhcmVPcCArIFwiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvdW50ICs9IDEuMDtcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuICAgICAgICBjb3VudCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCArIFwiOyB3QyArPSA0KSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAxLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAzLCBkKVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiICsgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCArIFwiO1xcbiAgICAgICAgICBpZiAoXCIgKyAoZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAxLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIiArIHJldHVyblZhbHVlICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBQb29sMkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUG9vbDJEUHJvZ3JhbSA9IFBvb2wyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb29sX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWR1Y2VQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWR1Y2VQcm9ncmFtKHJlZHVjZUluZm8sIHJlZHVjZVR5cGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlSW5mby53aW5kb3dTaXplO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gcmVkdWNlSW5mby5iYXRjaFNpemU7XG4gICAgICAgIHZhciBpblNpemUgPSByZWR1Y2VJbmZvLmluU2l6ZTtcbiAgICAgICAgdmFyIG91dFNpemUgPSBNYXRoLmNlaWwoaW5TaXplIC8gd2luZG93U2l6ZSk7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRTaXplXTtcbiAgICAgICAgdmFyIGlzUmVkdWNlU3VtID0gcmVkdWNlVHlwZSA9PT0gJ3N1bSc7XG4gICAgICAgIHZhciBpbml0aWFsaXphdGlvblZhbHVlID0gJzAuMCc7XG4gICAgICAgIGlmICghaXNSZWR1Y2VTdW0pIHtcbiAgICAgICAgICAgIGlmIChyZWR1Y2VUeXBlID09PSAnbWluJykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMS4wIC8gMC4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnLTEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBhcmVPcCA9IHJlZHVjZVR5cGUgPT09ICdtaW4nID8gJ21pbicgOiAnbWF4JztcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVkdWNlVHlwZSArIFwiKFwiICsgcmVkdWNlVHlwZSArIFwiKFwiICsgcmVkdWNlVHlwZSArIFwiKFwiICtcbiAgICAgICAgICAgICdtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKSc7XG4gICAgICAgIGlmIChyZWR1Y2VUeXBlID09PSAnc3VtJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcInN1bVZhbHVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbmRvd1NpemVOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3Iod2luZG93U2l6ZSAvIDQpICogNDtcbiAgICAgICAgdmFyIHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID0gd2luZG93U2l6ZSAlIDQ7XG4gICAgICAgIHZhciB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICBpZiAoXCIgKyBpc1JlZHVjZVN1bSArIFwiKSB7XFxuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIiArIGNvbXBhcmVPcCArIFwiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIHZhciBjaGVja091dE9mQm91bmRzID0gJyc7XG4gICAgICAgIGlmIChpblNpemUgJSB3aW5kb3dTaXplID4gMCkge1xuICAgICAgICAgICAgY2hlY2tPdXRPZkJvdW5kcyA9IFwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiICsgaW5TaXplICsgXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xcbiAgICAgICAgXCIgKyBjaGVja091dE9mQm91bmRzICsgXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiICsgd2luZG93U2l6ZSArIFwiO1xcblxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCIpO1xcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgd2luZG93U2l6ZU5lYXJlc3RWZWM0ICsgXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiICsgd2luZG93U2l6ZU5lYXJlc3RWZWM0ICsgXCI7XFxuICAgICAgICBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiICsgKHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIiArIHJldHVyblZhbHVlICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZWR1Y2VQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUmVkdWNlUHJvZ3JhbSA9IFJlZHVjZVByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2VfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlc2l6ZUJpbGluZWFyQmFja3Byb3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVCaWxpbmVhckJhY2twcm9wUHJvZ3JhbShkeSwgeCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geC5zaGFwZTtcbiAgICAgICAgdmFyIF9hID0geC5zaGFwZSwgeEhlaWdodCA9IF9hWzFdLCB4V2lkdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIF9iID0gZHkuc2hhcGUsIHlIZWlnaHQgPSBfYlsxXSwgeVdpZHRoID0gX2JbMl07XG4gICAgICAgIHZhciBlZmZlY3RpdmVYU2l6ZSA9IFtcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeUhlaWdodCA+IDEpID8geEhlaWdodCAtIDEgOiB4SGVpZ2h0LFxuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5V2lkdGggPiAxKSA/IHhXaWR0aCAtIDEgOiB4V2lkdGhcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZVlTaXplID0gW1xuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5SGVpZ2h0ID4gMSkgPyB5SGVpZ2h0IC0gMSA6IHlIZWlnaHQsXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlXaWR0aCA+IDEpID8geVdpZHRoIC0gMSA6IHlXaWR0aFxuICAgICAgICBdO1xuICAgICAgICB2YXIgaGVpZ2h0U2NhbGUgPSBlZmZlY3RpdmVYU2l6ZVswXSAvIGVmZmVjdGl2ZVlTaXplWzBdO1xuICAgICAgICB2YXIgd2lkdGhTY2FsZSA9IGVmZmVjdGl2ZVhTaXplWzFdIC8gZWZmZWN0aXZlWVNpemVbMV07XG4gICAgICAgIHZhciBpbnZIZWlnaHRTY2FsZSA9IDEgLyBoZWlnaHRTY2FsZTtcbiAgICAgICAgdmFyIGludldpZHRoU2NhbGUgPSAxIC8gd2lkdGhTY2FsZTtcbiAgICAgICAgdmFyIHdpbkhlaWdodCA9IChNYXRoLmNlaWwoaW52SGVpZ2h0U2NhbGUpICogMikgKyAyO1xuICAgICAgICB2YXIgd2luV2lkdGggPSAoTWF0aC5jZWlsKGludldpZHRoU2NhbGUpICogMikgKyAyO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KFwiICsgaGVpZ2h0U2NhbGUgKyBcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoXCIgKyB3aWR0aFNjYWxlICsgXCIpO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdChcIiArIGludkhlaWdodFNjYWxlICsgXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KFwiICsgaW52V2lkdGhTY2FsZSArIFwiKTtcXG5cXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoXCIgKyB3aW5IZWlnaHQgKyBcIik7XFxuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoXCIgKyB3aW5XaWR0aCArIFwiKTtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5UiA9IGludChzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpO1xcblxcbiAgICAgICAgZmxvYXQgc3RhcnRDTGVycCA9IGZsb29yKGZsb2F0KGMpICogaW52V2lkdGhTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpO1xcblxcbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XFxuICAgICAgICBmb3IgKGludCBkeVJPZmZzZXQgPSAwOyBkeVJPZmZzZXQgPCB3aW5IZWlnaHQ7IGR5Uk9mZnNldCsrKSB7XFxuICAgICAgICAgIGludCBkeVIgPSBkeVJPZmZzZXQgKyBzdGFydER5UjtcXG5cXG4gICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBcIiArIHlIZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IGR5Q09mZnNldCA9IDA7IGR5Q09mZnNldCA8IHdpbldpZHRoOyBkeUNPZmZzZXQrKykge1xcbiAgICAgICAgICAgIGludCBkeUMgPSBkeUNPZmZzZXQgKyBzdGFydER5QztcXG5cXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gXCIgKyB5V2lkdGggKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IGR4UiA9IGZsb2F0KGR5UikgKiBoZWlnaHRTY2FsZTtcXG4gICAgICAgICAgICBpbnQgdG9wRHhSSW5kZXggPSBpbnQoZmxvb3IoZHhSKSk7XFxuICAgICAgICAgICAgaW50IGJvdHRvbUR4UkluZGV4ID0gaW50KG1pbihjZWlsKGR4UiksIFwiICsgKHhIZWlnaHQgLSAxKSArIFwiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeFJMZXJwID0gZHhSIC0gZmxvYXQodG9wRHhSSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeFJMZXJwID0gMS4wIC0gZHhSTGVycDtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeEMgPSBmbG9hdChkeUMpICogd2lkdGhTY2FsZTtcXG4gICAgICAgICAgICBpbnQgbGVmdER4Q0luZGV4ID0gaW50KGZsb29yKGR4QykpO1xcbiAgICAgICAgICAgIGludCByaWdodER4Q0luZGV4ID0gaW50KG1pbihjZWlsKGR4QyksIFwiICsgKHhXaWR0aCAtIDEpICsgXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4Q0xlcnAgPSBkeEMgLSBmbG9hdChsZWZ0RHhDSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeENMZXJwID0gMS4wIC0gZHhDTGVycDtcXG5cXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gdG9wTGVmdFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz1cXG4gICAgICAgICAgICAgICAgZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyB0b3BSaWdodFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBkeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gYm90dG9tTGVmdFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIGJvdHRvbVJpZ2h0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogZHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIEVuZCBsb29wIG92ZXIgZHlcXG5cXG4gICAgICAgIHNldE91dHB1dChhY2N1bXVsYXRvcik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZUJpbGluZWFyQmFja3Byb3BQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUmVzaXplQmlsaW5lYXJCYWNrcHJvcFByb2dyYW0gPSBSZXNpemVCaWxpbmVhckJhY2twcm9wUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2l6ZV9iaWxpbmVhcl9iYWNrcHJvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVzaXplQmlsaW5lYXJQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVCaWxpbmVhclByb2dyYW0oaW5wdXRTaGFwZSwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHZhciBiYXRjaCA9IGlucHV0U2hhcGVbMF0sIG9sZEhlaWdodCA9IGlucHV0U2hhcGVbMV0sIG9sZFdpZHRoID0gaW5wdXRTaGFwZVsyXSwgZGVwdGggPSBpbnB1dFNoYXBlWzNdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBkZXB0aF07XG4gICAgICAgIHZhciBlZmZlY3RpdmVJblNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gb2xkSGVpZ2h0IC0gMSA6IG9sZEhlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3V2lkdGggPiAxKSA/IG9sZFdpZHRoIC0gMSA6IG9sZFdpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBlZmZlY3RpdmVPdXRTaXplID0gW1xuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdIZWlnaHQgPiAxKSA/IG5ld0hlaWdodCAtIDEgOiBuZXdIZWlnaHQsXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld1dpZHRoID4gMSkgPyBuZXdXaWR0aCAtIDEgOiBuZXdXaWR0aFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUluU2l6ZVswXSAvIGVmZmVjdGl2ZU91dFNpemVbMF0gKyBcIixcXG4gICAgICAgICAgXCIgKyBlZmZlY3RpdmVJblNpemVbMV0gLyBlZmZlY3RpdmVPdXRTaXplWzFdICsgXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIiArIG9sZEhlaWdodCArIFwiLjAsIFwiICsgb2xkV2lkdGggKyBcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICBpdmVjMiBzb3VyY2VGbG9vclJDID0gaXZlYzIoc291cmNlRnJhY0luZGV4UkMpO1xcbiAgICAgICAgaXZlYzIgc291cmNlQ2VpbFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XFxuXFxuICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcblxcbiAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNSQy54O1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVzaXplQmlsaW5lYXJQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUmVzaXplQmlsaW5lYXJQcm9ncmFtID0gUmVzaXplQmlsaW5lYXJQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaXplX2JpbGluZWFyX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXNpemVOZWFyZXN0TmVpZ2hib3JQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVOZWFyZXN0TmVpZ2hib3JQcm9ncmFtKGlucHV0U2hhcGUsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgYmF0Y2ggPSBpbnB1dFNoYXBlWzBdLCBvbGRIZWlnaHQgPSBpbnB1dFNoYXBlWzFdLCBvbGRXaWR0aCA9IGlucHV0U2hhcGVbMl0sIGRlcHRoID0gaW5wdXRTaGFwZVszXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgZGVwdGhdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlSW5TaXplID0gYWxpZ25Db3JuZXJzID8gW29sZEhlaWdodCAtIDEsIG9sZFdpZHRoIC0gMV0gOiBbb2xkSGVpZ2h0LCBvbGRXaWR0aF07XG4gICAgICAgIHZhciBlZmZlY3RpdmVPdXRTaXplID0gYWxpZ25Db3JuZXJzID8gW25ld0hlaWdodCAtIDEsIG5ld1dpZHRoIC0gMV0gOiBbbmV3SGVpZ2h0LCBuZXdXaWR0aF07XG4gICAgICAgIHZhciByb3VuZEJhc2UgPSBhbGlnbkNvcm5lcnMgPyAnMC41JyA6ICcwLjAnO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUluU2l6ZVswXSAvIGVmZmVjdGl2ZU91dFNpemVbMF0gKyBcIixcXG4gICAgICAgICAgXCIgKyBlZmZlY3RpdmVJblNpemVbMV0gLyBlZmZlY3RpdmVPdXRTaXplWzFdICsgXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIiArIG9sZEhlaWdodCArIFwiLjAsIFwiICsgb2xkV2lkdGggKyBcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0UkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgZmxvb3Ioc291cmNlRnJhY0luZGV4UkMgKyBcIiArIHJvdW5kQmFzZSArIFwiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRBKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueSwgZCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVOZWFyZXN0TmVpZ2hib3JQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUmVzaXplTmVhcmVzdE5laWdoYm9yUHJvZ3JhbSA9IFJlc2l6ZU5lYXJlc3ROZWlnaGJvclByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNpemVfbmVhcmVzdF9uZWlnaGJvcl9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgUmV2ZXJzZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldmVyc2VQcm9ncmFtKHhTaGFwZSwgYXhpcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdmFyIHJhbmsgPSB4U2hhcGUubGVuZ3RoO1xuICAgICAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay1cIiArIHJhbmsgKyBcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgY29vcmQgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIgKyB4U2hhcGVbMF0gKyBcIiAtIGNvb3JkIC0gMSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRJbkNvb3JkID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChheGlzLmluZGV4T2YoaSkgIT09IC0xICYmIHhTaGFwZVtpXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4U2hhcGVbaV0gKyBcIiAtIGNvb3Jkc1tcIiArIGkgKyBcIl0gLSAxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJjb29yZHNbXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbkNvb3JkcyA9IHhTaGFwZS5tYXAoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGdldEluQ29vcmQoaSk7IH0pLmpvaW4oJywnKTtcbiAgICAgICAgdmFyIHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyB0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIGluQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmV2ZXJzZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZXZlcnNlUHJvZ3JhbSA9IFJldmVyc2VQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV2ZXJzZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG5mdW5jdGlvbiBtYWtlU2hhZGVyKGlucHV0c0luZm8sIG91dHB1dFNoYXBlLCB1c2VyQ29kZSwgYnJvYWRjYXN0KSB7XG4gICAgdmFyIHNhbXBsZVNuaXBwZXQgPSBnZXRTYW1wbGVTbmlwcGV0KCk7XG4gICAgdmFyIHNldE91dHB1dFNuaXBwZXQgPSBnZXRTZXRPdXRwdXRTbmlwcGV0KCk7XG4gICAgdmFyIGlucHV0UHJlZml4U25pcHBldCA9IGlucHV0c0luZm8ubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBcInVuaWZvcm0gc2FtcGxlcjJEIFwiICsgeC5uYW1lICsgXCI7XCI7IH0pLmpvaW4oJ1xcbicpO1xuICAgIHZhciBpbnB1dFNhbXBsaW5nU25pcHBldCA9IGlucHV0c0luZm8ubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldCh4LCBvdXRwdXRTaGFwZSwgYnJvYWRjYXN0KTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dHB1dFNoYXBlLnRleFNoYXBlO1xuICAgIHZhciBvdXRwdXRTYW1wbGluZ1NuaXBwZXQgPSBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0U2hhcGUubG9naWNhbFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgdmFyIHNvdXJjZSA9IFtcbiAgICAgICAgU0hBREVSX1BSRUZJWCwgc2FtcGxlU25pcHBldCwgc2V0T3V0cHV0U25pcHBldCwgaW5wdXRQcmVmaXhTbmlwcGV0LFxuICAgICAgICBvdXRwdXRTYW1wbGluZ1NuaXBwZXQsIGlucHV0U2FtcGxpbmdTbmlwcGV0LCB1c2VyQ29kZVxuICAgIF0uam9pbignXFxuJyk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmV4cG9ydHMubWFrZVNoYWRlciA9IG1ha2VTaGFkZXI7XG5mdW5jdGlvbiBnZXRTYW1wbGVTbmlwcGV0KCkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpID9cbiAgICAgICAgRkxPQVRfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA6XG4gICAgICAgIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TQU1QTEVfU05JUFBFVDtcbn1cbmZ1bmN0aW9uIGdldFNldE91dHB1dFNuaXBwZXQoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykgP1xuICAgICAgICBGTE9BVF9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUIDpcbiAgICAgICAgVU5TSUdORURfQllURV9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckZyb21JbkluZm8oaW5JbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5JbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgc3dpdGNoIChzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXJTY2FsYXIoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXIxRChpbkluZm8pO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjJEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyM0QoaW5JbmZvKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXI0RChpbkluZm8pO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjVEKGluSW5mbyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2hhcGUubGVuZ3RoICsgXCItRCBpbnB1dCBzYW1wbGluZ1wiICtcbiAgICAgICAgICAgICAgICBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldChpbkluZm8sIG91dFNoYXBlSW5mbywgYnJvYWRjYXN0KSB7XG4gICAgdmFyIHJlcyA9IGdldFNhbXBsZXJGbGF0KGluSW5mbyk7XG4gICAgcmVzICs9IGdldFNhbXBsZXJGcm9tSW5JbmZvKGluSW5mbyk7XG4gICAgaWYgKGJyb2FkY2FzdCB8fFxuICAgICAgICB1dGlsLmFycmF5c0VxdWFsKGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKSkge1xuICAgICAgICByZXMgKz0gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKGluSW5mbywgb3V0U2hhcGVJbmZvLCBicm9hZGNhc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dFNoYXBlLCBvdXRUZXhTaGFwZSkge1xuICAgIHN3aXRjaCAob3V0U2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDFEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQyRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0M0RDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDREQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQ1RENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG91dFNoYXBlLmxlbmd0aCArIFwiLUQgb3V0cHV0IHNhbXBsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbnZhciBTQU1QTEVfMURfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgU0FNUExFXzJEX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tMkQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgbnVtQywgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gcm93ICogbnVtQyArIGNvbDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV8zRF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICsgZGVwdGg7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfNERfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb200RChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHN0cmlkZTIsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgaW50IGRlcHRoMikge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aCAqIHN0cmlkZTIgKyBkZXB0aDI7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfNURfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb201RChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHN0cmlkZTIsIGludCBzdHJpZGUzLCBpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICsgXFxuICAgICAgICAgICAgICBkZXB0aCAqIHN0cmlkZTIgKyBkZXB0aDIgKiBzdHJpZGUzICsgZGVwdGgzO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgVU5TSUdORURfQllURV9URVhUVVJFX1NBTVBMRV9TTklQUEVUID0gXCJcXG4gIHVuaWZvcm0gZmxvYXQgTmFOO1xcblxcbiAgY29uc3QgdmVjNCBmbG9hdERlbHRhcyA9IHZlYzQoXFxuICAgICAgMS4wLFxcbiAgICAgIDEuMCAvIDI1NS4wLFxcbiAgICAgIDEuMCAvICgyNTUuMCAqIDI1NS4wKSxcXG4gICAgICAxLjAgLyAoMjU1LjAgKiAyNTUuMCAqIDI1NS4wKVxcbiAgKTtcXG4gIGNvbnN0IGZsb2F0IG1pblZhbHVlID0gXCIgKyB0ZXhfdXRpbC5GTE9BVF9NSU4gKyBcIi4wO1xcbiAgY29uc3QgZmxvYXQgbWF4VmFsdWUgPSBcIiArIHRleF91dGlsLkZMT0FUX01BWCArIFwiLjA7XFxuICBjb25zdCBmbG9hdCByYW5nZSA9IChtYXhWYWx1ZSAtIG1pblZhbHVlKSAvIDI1NS4wO1xcbiAgY29uc3QgdmVjMiBkb3RSYW5nZSA9IHZlYzIoMS4wLCByYW5nZSk7XFxuXFxuICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICB2ZWM0IHNhbXBsZVZhbHVlID0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB1dik7XFxuICAgIGlmIChhbGwoZXF1YWwoc2FtcGxlVmFsdWUsIHZlYzQoXCIgKyB0ZXhfdXRpbC5CWVRFX05BTl9WQUxVRSArIFwiKSkpKSB7XFxuICAgICAgcmV0dXJuIE5hTjtcXG4gICAgfVxcblxcbiAgICB2ZWM0IGVuY1ZhbHVlID0gZmxvb3Ioc2FtcGxlVmFsdWUgKiAyNTUuMCArIDAuNSk7XFxuICAgIGZsb2F0IGRlY29kZWRWYWx1ZSA9IGRvdChlbmNWYWx1ZSwgZmxvYXREZWx0YXMpO1xcbiAgICByZXR1cm4gZG90KHZlYzIobWluVmFsdWUsIGRlY29kZWRWYWx1ZSksIGRvdFJhbmdlKTtcXG4gIH1cXG5cIjtcbnZhciBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQgPSBcIlxcbiAgY29uc3QgdmVjNCBmbG9hdFBvd2VycyA9IHZlYzQoXFxuICAgIDEuMCxcXG4gICAgMjU1LjAsXFxuICAgIDI1NS4wICogMjU1LjAsXFxuICAgIDI1NS4wICogMjU1LjAgKiAyNTUuMFxcbiAgKTtcXG4gIGNvbnN0IHZlYzIgcmVjaXBSYW5nZSA9IHZlYzIoMS4wL3JhbmdlKTtcXG4gIGNvbnN0IHZlYzIgcmVjaXBSYW5nZTI1NSA9IHZlYzIoMS4wLyhtYXhWYWx1ZSAtIG1pblZhbHVlKSk7XFxuXFxuICB2b2lkIHNldE91dHB1dChmbG9hdCBkZWNvZGVkVmFsdWUpIHtcXG4gICAgaWYgKGlzTmFOKGRlY29kZWRWYWx1ZSkpIHtcXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KFwiICsgdGV4X3V0aWwuQllURV9OQU5fVkFMVUUgKyBcIik7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGEgPSBkb3QodmVjMihkZWNvZGVkVmFsdWUsIC1taW5WYWx1ZSksIHJlY2lwUmFuZ2UpO1xcbiAgICBmbG9hdCBiID0gZnJhY3QoYSkgKiAyNTUuMDtcXG4gICAgZmxvYXQgYyA9IGZyYWN0KGIpICogMjU1LjA7XFxuICAgIGZsb2F0IGQgPSBmcmFjdChjKSAqIDI1NS4wO1xcbiAgICBnbF9GcmFnQ29sb3IgPSBmbG9vcih2ZWM0KGEsIGIsIGMsIGQpKSAvIDI1NS4wO1xcblxcbiAgICAvLyBUT0RPKGRzbWlsa292KTogVmVyc2lvbiBhYm92ZSBnZXRzIGJldHRlciBhY2N1cmFjeSBidXQgcHJvYmFibHkgc2xvd2VyXFxuICAgIC8vIHRoYW4gdGhlIHZlcnNpb24gYmVsb3cuIEJlbmNobWFyayB0byBkZXRlcm1pbmUgaWYgdGhlIGFjY3VyYWN5IGlzIHdvcnRoXFxuICAgIC8vIHRoZSBjb3N0LlxcblxcbiAgICAvLyBmbG9hdCBub3JtVmFsdWUgPSBkb3QodmVjMihkZWNvZGVkVmFsdWUsIC1taW5WYWx1ZSksIHJlY2lwUmFuZ2UyNTUpO1xcbiAgICAvLyB2ZWM0IGYgPSBub3JtVmFsdWUgKiBmbG9hdFBvd2VycztcXG4gICAgLy8gZ2xfRnJhZ0NvbG9yID0gZmxvb3IoZnJhY3QoZikgKiAyNTUuMCkgLyAyNTUuMDtcXG4gIH1cXG5cIjtcbnZhciBGTE9BVF9URVhUVVJFX1NBTVBMRV9TTklQUEVUID0gXCJcXG4gIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XFxuICAgIHJldHVybiB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xcbiAgfVxcblwiO1xudmFyIEZMT0FUX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQgPSBcIlxcbiAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gIH1cXG5cIjtcbnZhciBTSEFERVJfUFJFRklYID0gXCJcXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xcblxcbiAgc3RydWN0IGl2ZWM1XFxuICB7XFxuICAgIGludCB4O1xcbiAgICBpbnQgeTtcXG4gICAgaW50IHo7XFxuICAgIGludCB3O1xcbiAgICBpbnQgdTtcXG4gIH07XFxuXFxuICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xcbiAgICBmbG9hdCB2MSA9IHZhbCAqIHZhbDtcXG4gICAgZmxvYXQgdjIgPSB2YWwgKiB2YWw7XFxuICAgIHJldHVybiB2MSA9PSB2MiA/IGZhbHNlIDogdHJ1ZTtcXG4gIH1cXG5cXG4gIGJvb2wgaGFzTmFOKHZlYzQgdmFsdWVzKSB7XFxuICAgIHZlYzQgdjEgPSB2YWx1ZXMgKiB2YWx1ZXM7XFxuICAgIHZlYzQgdjIgPSB2YWx1ZXMgKiB2YWx1ZXM7XFxuICAgIHJldHVybiBhbnkobm90RXF1YWwodjEsIHYyKSk7XFxuICB9XFxuXFxuICBmbG9hdCBnZXROYU4odmVjNCB2YWx1ZXMpIHtcXG4gICAgcmV0dXJuIGRvdCh2ZWM0KDEpLCB2YWx1ZXMpO1xcbiAgfVxcblxcbiAgaW50IHJvdW5kKGZsb2F0IHZhbHVlKSB7XFxuICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gIH1cXG5cXG4gIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xcbiAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xcbiAgfVxcblxcbiAgLy9CYXNlZCBvbiB0aGUgd29yayBvZiBEYXZlIEhvc2tpbnNcXG4gIC8vaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzRkalNSV1xcbiAgI2RlZmluZSBIQVNIU0NBTEUxIDQ0My44OTc1XFxuICBmbG9hdCByYW5kb20oZmxvYXQgc2VlZCl7XFxuICAgIHZlYzIgcCA9IHJlc3VsdFVWICogc2VlZDtcXG4gICAgdmVjMyBwMyAgPSBmcmFjdCh2ZWMzKHAueHl4KSAqIEhBU0hTQ0FMRTEpO1xcbiAgICBwMyArPSBkb3QocDMsIHAzLnl6eCArIDE5LjE5KTtcXG4gICAgcmV0dXJuIGZyYWN0KChwMy54ICsgcDMueSkgKiBwMy56KTtcXG4gIH1cXG5cXG4gIFwiICsgU0FNUExFXzFEX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfMkRfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV8zRF9TTklQUEVUICsgXCJcXG4gIFwiICsgU0FNUExFXzREX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfNURfU05JUFBFVCArIFwiXFxuXCI7XG5mdW5jdGlvbiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0MURDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgaWYgKHRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnkgKiBcIiArIHRleFNoYXBlWzBdICsgXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgcmV0dXJuIHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDNEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGluZGV4IC09IHIgKiBcIiArIHN0cmlkZTAgKyBcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC8gXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgaW50IGQgPSBpbmRleCAtIGMgKiBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0NERDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIGludCByID0gaW5kZXggLyBcIiArIHN0cmlkZTAgKyBcIjtcXG4gICAgICBpbmRleCAtPSByICogXCIgKyBzdHJpZGUwICsgXCI7XFxuXFxuICAgICAgaW50IGMgPSBpbmRleCAvIFwiICsgc3RyaWRlMSArIFwiO1xcbiAgICAgIGluZGV4IC09IGMgKiBcIiArIHN0cmlkZTEgKyBcIjtcXG5cXG4gICAgICBpbnQgZCA9IGluZGV4IC8gXCIgKyBzdHJpZGUyICsgXCI7XFxuICAgICAgaW50IGQyID0gaW5kZXggLSBkICogXCIgKyBzdHJpZGUyICsgXCI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQ1RENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgc3RyaWRlMyA9IHNoYXBlWzRdO1xuICAgIHZhciBzdHJpZGUyID0gc2hhcGVbM10gKiBzdHJpZGUzO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGluZGV4IC09IHIgKiBcIiArIHN0cmlkZTAgKyBcIjtcXG5cXG4gICAgICBpbnQgYyA9IGluZGV4IC8gXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgaW5kZXggLT0gYyAqIFwiICsgc3RyaWRlMSArIFwiO1xcblxcbiAgICAgIGludCBkID0gaW5kZXggLyBcIiArIHN0cmlkZTIgKyBcIjtcXG4gICAgICBpbmRleCAtPSBkICogXCIgKyBzdHJpZGUyICsgXCI7XFxuXFxuICAgICAgaW50IGQyID0gaW5kZXggIC8gXCIgKyBzdHJpZGUzICsgXCI7XFxuICAgICAgaW50IGQzID0gaW5kZXggLSBkMiAqIFwiICsgc3RyaWRlMyArIFwiO1xcblxcbiAgICAgIGl2ZWM1IG91dFNoYXBlID0gaXZlYzUociwgYywgZCwgZDIsIGQzKTtcXG4gICAgICByZXR1cm4gb3V0U2hhcGU7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0MkRDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMihpbmRleCwgMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMigwLCBpbmRleCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzaGFwZVsxXSArIFwiO1xcbiAgICAgIGludCBjID0gaW5kZXggLSByICogXCIgKyBzaGFwZVsxXSArIFwiO1xcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyU2NhbGFyKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCBoYWxmQ1IpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXIxRChpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiRmxhdChpbmRleCk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjJEKGlucHV0SW5mbykge1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIHZhciBzcXVlZXplZFNoYXBlID0gbmV3U2hhcGU7XG4gICAgaWYgKHNxdWVlemVkU2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dEluZm8gPSBzcXVlZXplSW5wdXRJbmZvKGlucHV0SW5mbywgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnXTtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgXCIgKyBnZXRTYW1wbGVyRnJvbUluSW5mbyhuZXdJbnB1dEluZm8pICsgXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdGV4TnVtQyArIFwiLjAsIDAuNSk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgdmVjMiB1diA9IFVWZnJvbTJEKFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgXCIgKyBzaGFwZVsxXSArIFwiLCByb3csIGNvbCk7XFxuICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICB9XFxuXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyM0QoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgc2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdO1xuICAgIHZhciBfYSA9IHV0aWwuc3F1ZWV6ZVNoYXBlKHNoYXBlKSwgbmV3U2hhcGUgPSBfYS5uZXdTaGFwZSwga2VwdERpbXMgPSBfYS5rZXB0RGltcztcbiAgICB2YXIgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIHNxdWVlemVkU2hhcGUpO1xuICAgICAgICB2YXIgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgXCIgKyBnZXRTYW1wbGVyRnJvbUluSW5mbyhuZXdJbnB1dEluZm8pICsgXCJcXG4gICAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMCkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICAgIGludCB0ZXhDID0gY29sICogXCIgKyBzdHJpZGUxICsgXCIgKyBkZXB0aDtcXG4gICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICBpbnQgdGV4UiA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICBpbnQgdGV4QyA9IGRlcHRoO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gVVZmcm9tM0QoXFxuICAgICAgICAgICAgXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHN0cmlkZTAgKyBcIiwgXCIgKyBzdHJpZGUxICsgXCIsIHJvdywgY29sLCBkZXB0aCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjREKGlucHV0SW5mbykge1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuICAgIHZhciBfYSA9IHV0aWwuc3F1ZWV6ZVNoYXBlKHNoYXBlKSwgbmV3U2hhcGUgPSBfYS5uZXdTaGFwZSwga2VwdERpbXMgPSBfYS5rZXB0RGltcztcbiAgICBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dEluZm8gPSBzcXVlZXplSW5wdXRJbmZvKGlucHV0SW5mbywgbmV3U2hhcGUpO1xuICAgICAgICB2YXIgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJywgJ2RlcHRoMiddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMCkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGludCB0ZXhDID0gY29sICogXCIgKyBzdHJpZGUxICsgXCIgKyBkZXB0aCAqIFwiICsgc3RyaWRlMiArIFwiICsgZGVwdGgyO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUyKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93ICogXCIgKyBzaGFwZVsxXSAqIHNoYXBlWzJdICsgXCIgKyBjb2wgKiBcIiArIHNoYXBlWzJdICsgXCIgKyBkZXB0aDtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGgyO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tNEQoXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHN0cmlkZTAgKyBcIiwgXCIgKyBzdHJpZGUxICsgXCIsXFxuICAgICAgICAgIFwiICsgc3RyaWRlMiArIFwiLCByb3csIGNvbCwgZGVwdGgsIGRlcHRoMik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyNUQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIHZhciBzdHJpZGUzID0gc2hhcGVbNF07XG4gICAgdmFyIHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJywgJ2RlcHRoMyddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMCkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGludCB0ZXhDID0gY29sICogXCIgKyBzdHJpZGUxICsgXCIgKyBkZXB0aCAqIFwiICsgc3RyaWRlMiArIFwiICtcXG4gICAgICAgICAgICAgICAgICAgZGVwdGgyICogXCIgKyBzdHJpZGUzICsgXCIgKyBkZXB0aDM7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTMpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgaW50IHRleFIgPSByb3cgKiBcIiArIHNoYXBlWzFdICogc2hhcGVbMl0gKyBcIiArIGNvbCAqIFwiICsgc2hhcGVbMl0gKyBcIiArXFxuICAgICAgICAgICAgICAgICAgIGRlcHRoICogXCIgKyBzaGFwZVszXSArIFwiICsgZGVwdGgyO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDM7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb201RChcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc3RyaWRlMCArIFwiLCBcIiArIHN0cmlkZTEgKyBcIixcXG4gICAgICAgICAgXCIgKyBzdHJpZGUyICsgXCIsIFwiICsgc3RyaWRlMyArIFwiLCByb3csIGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJGbGF0KGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpICsgJ0ZsYXQnO1xuICAgIHZhciB0TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIGlmICh0TnVtQyA9PT0gMSAmJiB0TnVtUiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgaGFsZkNSKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodE51bUMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHROdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0TnVtQyArIFwiLjAsIDAuNSk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IFVWZnJvbTFEKFwiICsgdE51bVIgKyBcIiwgXCIgKyB0TnVtQyArIFwiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRCcm9hZGNhc3RPdXRwdXRDb29yZHNTYW1wbGVyKGlucHV0SW5mbywgb3V0U2hhcGVJbmZvLCB0ZXhGdW5jU25pcHBldCwgZnVuY05hbWUpIHtcbiAgICB2YXIgaW5SYW5rID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciBvdXRSYW5rID0gb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIHR5cGUgPSAnaW50JztcbiAgICBpZiAob3V0UmFuayA9PT0gMikge1xuICAgICAgICB0eXBlID0gJ2l2ZWMyJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0UmFuayA9PT0gMykge1xuICAgICAgICB0eXBlID0gJ2l2ZWMzJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0UmFuayA9PT0gNCkge1xuICAgICAgICB0eXBlID0gJ2l2ZWM0JztcbiAgICB9XG4gICAgdmFyIGJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKTtcbiAgICB2YXIgcmFua0RpZmYgPSBvdXRSYW5rIC0gaW5SYW5rO1xuICAgIHZhciBjb29yZHNTbmlwcGV0O1xuICAgIGlmIChpblJhbmsgPT09IDApIHtcbiAgICAgICAgY29vcmRzU25pcHBldCA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnY29vcmRzID0gMDsnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29vcmRzU25pcHBldCA9XG4gICAgICAgICAgICBicm9hZGNhc3REaW1zLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gXCJjb29yZHNbXCIgKyAoZCArIHJhbmtEaWZmKSArIFwiXSA9IDA7XCI7IH0pLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICB2YXIgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgaWYgKG91dFJhbmsgPCAyICYmIGluUmFuayA+IDApIHtcbiAgICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJ2Nvb3Jkcyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocywgaSkgeyByZXR1cm4gXCJjb29yZHNbXCIgKyAoaSArIHJhbmtEaWZmKSArIFwiXVwiOyB9KVxuICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgXCIgKyB0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgXCIgKyBjb29yZHNTbmlwcGV0ICsgXCJcXG4gICAgICByZXR1cm4gZ2V0XCIgKyB0ZXhGdW5jU25pcHBldCArIFwiKFwiICsgdW5wYWNrZWRDb29yZHNTbmlwcGV0ICsgXCIpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJBdE91dHB1dENvb3JkcyhpbnB1dEluZm8sIG91dFNoYXBlSW5mbywgc3VwcG9ydHNCcm9hZGNhc3RpbmcpIHtcbiAgICB2YXIgaW5UZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgdGV4RnVuY1NuaXBwZXQgPSB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleEZ1bmNTbmlwcGV0ICsgJ0F0T3V0Q29vcmRzJztcbiAgICB2YXIgYnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsIG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgIHZhciBpblJhbmsgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIG91dFJhbmsgPSBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgZG9Ccm9hZGNhc3QgPSBzdXBwb3J0c0Jyb2FkY2FzdGluZyAmJiAoKG91dFJhbmsgPiBpblJhbmspIHx8IGJyb2FkY2FzdERpbXMubGVuZ3RoID4gMCk7XG4gICAgdmFyIGJyb2FkY2FzdE92ZXJPdXRlciA9IGJyb2FkY2FzdF91dGlsLmJyb2FkY2FzdERpbXNBcmVPdXRlcihicm9hZGNhc3REaW1zKTtcbiAgICBpZiAoZG9Ccm9hZGNhc3QgJiYgIWJyb2FkY2FzdE92ZXJPdXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QnJvYWRjYXN0T3V0cHV0Q29vcmRzU2FtcGxlcihpbnB1dEluZm8sIG91dFNoYXBlSW5mbywgdGV4RnVuY1NuaXBwZXQsIGZ1bmNOYW1lKTtcbiAgICB9XG4gICAgdmFyIG91dFRleFNoYXBlID0gb3V0U2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIGlmICh1dGlsLmFycmF5c0VxdWFsKGluVGV4U2hhcGUsIG91dFRleFNoYXBlKSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgcmVzdWx0VVYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoaW5UZXhTaGFwZSk7XG4gICAgdmFyIGJyb2FkY2FzdFNuaXBwZXQgPSAnJztcbiAgICBpZiAoZG9Ccm9hZGNhc3QgJiYgYnJvYWRjYXN0T3Zlck91dGVyKSB7XG4gICAgICAgIGJyb2FkY2FzdFNuaXBwZXQgPSBcIlxcbiAgICAgICAgaW50IG1haW5QYXJ0ID0gaW5kZXggLyBcIiArIGluU2l6ZSArIFwiO1xcbiAgICAgICAgaW5kZXggLT0gbWFpblBhcnQgKiBcIiArIGluU2l6ZSArIFwiO1xcbiAgICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIG91dFRleFNoYXBlWzBdICsgXCIsIFwiICsgb3V0VGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIG91dFRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiICsgYnJvYWRjYXN0U25pcHBldCArIFwiXFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvIFwiICsgaW5UZXhTaGFwZVsxXSArIFwiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIgKyBpblRleFNoYXBlWzFdICsgXCI7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgaW5UZXhTaGFwZVsxXSArIFwiLjAsIFwiICsgaW5UZXhTaGFwZVswXSArIFwiLjApO1xcblxcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0Q29vcmRzRGF0YVR5cGUocmFuaykge1xuICAgIGlmIChyYW5rIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuICdpbnQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnaXZlYzInO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiAnaXZlYzMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnaXZlYzQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA1KSB7XG4gICAgICAgIHJldHVybiAnaXZlYzUnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJHUFUgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRDb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlO1xuZnVuY3Rpb24gc3F1ZWV6ZUlucHV0SW5mbyhpbkluZm8sIHNxdWVlemVkU2hhcGUpIHtcbiAgICB2YXIgbmV3SW5wdXRJbmZvID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbkluZm8pKTtcbiAgICBuZXdJbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSA9IHNxdWVlemVkU2hhcGU7XG4gICAgcmV0dXJuIG5ld0lucHV0SW5mbztcbn1cbmZ1bmN0aW9uIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpIHtcbiAgICByZXR1cm4ga2VwdERpbXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBwYXJhbXNbZF07IH0pLmpvaW4oJywgJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXJfY29tcGlsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgU2xpY2VQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGljZVByb2dyYW0oZGVzdFNpemUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydzb3VyY2UnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGRlc3RTaXplO1xuICAgICAgICB0aGlzLnJhbmsgPSBkZXN0U2l6ZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBnZXRDb29yZHModGhpcy5yYW5rKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBcIiArIGR0eXBlICsgXCIgc3RhcnQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHNvdXJjZUxvYyA9IHN0YXJ0ICsgZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKFwiICsgc291cmNlQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBTbGljZVByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc3RhcnQubGVuZ3RoICE9PSB0aGlzLnJhbmspIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiICsgdGhpcy5yYW5rICsgXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIFwiICtcbiAgICAgICAgICAgICAgICAoXCJsZW5ndGggb2Ygc3RhcnQgKFwiICsgc3RhcnQubGVuZ3RoICsgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHdlYkdMUHJvZ3JhbSwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0TG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFpKF90aGlzLnN0YXJ0TG9jLCBzdGFydFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yYW5rID09PSAyKSB7XG4gICAgICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJpKF90aGlzLnN0YXJ0TG9jLCBzdGFydFswXSwgc3RhcnRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMykge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0zaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdLCBzdGFydFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yYW5rID09PSA0KSB7XG4gICAgICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTRpKF90aGlzLnN0YXJ0TG9jLCBzdGFydFswXSwgc3RhcnRbMV0sIHN0YXJ0WzJdLCBzdGFydFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIgKyBfdGhpcy5yYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU2xpY2VQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuU2xpY2VQcm9ncmFtID0gU2xpY2VQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0Q29vcmRzKHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MueCwgc291cmNlTG9jLnknO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55LCBzb3VyY2VMb2Mueic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MueCwgc291cmNlTG9jLnksIHNvdXJjZUxvYy56LCBzb3VyY2VMb2Mudyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpY2VfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFN0cmlkZWRTbGljZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmlkZWRTbGljZVByb2dyYW0oYmVnaW4sIHN0cmlkZXMsIHNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gc2hhcGU7XG4gICAgICAgIHRoaXMucmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIG5ld0Nvb3JkcyA9ICcnO1xuICAgICAgICBpZiAodGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICBuZXdDb29yZHMgPSAnY29vcmRzICogc3RyaWRlcyArIGJlZ2luJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0Nvb3JkcyA9XG4gICAgICAgICAgICAgICAgc2hhcGUubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBcImNvb3Jkc1tcIiArIGkgKyBcIl0gKiBzdHJpZGVzW1wiICsgaSArIFwiXSArIGJlZ2luW1wiICsgaSArIFwiXVwiOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIFwiICsgZHR5cGUgKyBcIiBiZWdpbiA9IFwiICsgZHR5cGUgKyBcIihcIiArIGJlZ2luICsgXCIpO1xcbiAgICAgIFwiICsgZHR5cGUgKyBcIiBzdHJpZGVzID0gXCIgKyBkdHlwZSArIFwiKFwiICsgc3RyaWRlcyArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIG5ld0Nvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmlkZWRTbGljZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5TdHJpZGVkU2xpY2VQcm9ncmFtID0gU3RyaWRlZFNsaWNlUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmlkZWRfc2xpY2VfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRleHR1cmVUeXBlO1xuKGZ1bmN0aW9uIChUZXh0dXJlVHlwZSkge1xuICAgIFRleHR1cmVUeXBlW1RleHR1cmVUeXBlW1wiRkxPQVRcIl0gPSAwXSA9IFwiRkxPQVRcIjtcbiAgICBUZXh0dXJlVHlwZVtUZXh0dXJlVHlwZVtcIlVOU0lHTkVEX0JZVEVcIl0gPSAxXSA9IFwiVU5TSUdORURfQllURVwiO1xufSkoVGV4dHVyZVR5cGUgPSBleHBvcnRzLlRleHR1cmVUeXBlIHx8IChleHBvcnRzLlRleHR1cmVUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbY29sdW1ucywgcm93c107XG59XG5leHBvcnRzLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0O1xuZnVuY3Rpb24gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShtYXRyaXhTaXplLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICByZXR1cm4gbWF0cml4U2l6ZSAqIGNoYW5uZWxzUGVyVGV4dHVyZTtcbn1cbmV4cG9ydHMuZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZSA9IGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemU7XG5mdW5jdGlvbiBnZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gW2NvbHVtbnMgKiA0LCByb3dzXTtcbn1cbmV4cG9ydHMuZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCA9IGdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQ7XG5mdW5jdGlvbiBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKHVucGFja2VkU2l6ZSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgaWYgKHVucGFja2VkU2l6ZSAlIGNoYW5uZWxzUGVyVGV4dHVyZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnBhY2tlZFNpemUgKFwiICsgdW5wYWNrZWRTaXplICsgXCIpIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBcIiArXG4gICAgICAgICAgICAoXCJcIiArIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5wYWNrZWRTaXplIC8gY2hhbm5lbHNQZXJUZXh0dXJlO1xufVxuZXhwb3J0cy5nZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplID0gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZTtcbmZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheShtYXRyaXgsIHVucGFja2VkQXJyYXksIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeC5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gICAgaWYgKHVucGFja2VkQXJyYXkubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucGFja2VkQXJyYXkgbGVuZ3RoIChcIiArIHVucGFja2VkQXJyYXkubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgK1xuICAgICAgICAgICAgKFwiXCIgKyByZXF1aXJlZFNpemUpKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgbWF0cml4Lmxlbmd0aDsgKytzcmMpIHtcbiAgICAgICAgdW5wYWNrZWRBcnJheVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgIGRzdCArPSBjaGFubmVsc1BlclRleHR1cmU7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkgPSBlbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXk7XG5leHBvcnRzLkZMT0FUX01BWCA9IDIwMDAwO1xuZXhwb3J0cy5GTE9BVF9NSU4gPSAtZXhwb3J0cy5GTE9BVF9NQVg7XG52YXIgRkxPQVRfUkFOR0UgPSAoZXhwb3J0cy5GTE9BVF9NQVggLSBleHBvcnRzLkZMT0FUX01JTikgLyAyNTU7XG52YXIgRkxPQVRfREVMVEFTID0gWzEsIDEgLyAyNTUsIDEgLyAoMjU1ICogMjU1KSwgMSAvICgyNTUgKiAyNTUgKiAyNTUpXTtcbnZhciBGTE9BVF9QT1dFUlMgPSBbMSwgMjU1LCAyNTUgKiAyNTVdO1xuZXhwb3J0cy5CWVRFX05BTl9WQUxVRSA9IDA7XG5mdW5jdGlvbiBlbmNvZGVGbG9hdEFycmF5KGZsb2F0QXJyYXkpIHtcbiAgICB2YXIgdWludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmxvYXRBcnJheS5sZW5ndGggKiA0KTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZsb2F0QXJyYXlbaSAvIDRdO1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICB1aW50QXJyYXlbaV0gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgdWludEFycmF5W2kgKyAxXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDJdID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgM10gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gKHZhbHVlIC0gZXhwb3J0cy5GTE9BVF9NSU4pIC8gRkxPQVRfUkFOR0U7XG4gICAgICAgIHZhciBlbmMgPSBGTE9BVF9QT1dFUlMubWFwKGZ1bmN0aW9uIChwb3cpIHsgcmV0dXJuIHBvdyAqIG5vcm1hbGl6ZWRWYWx1ZTsgfSk7XG4gICAgICAgIHZhciBidWNrZXRzID0gZW5jLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE1hdGguZmxvb3IoKHZhbHVlICUgMSkgKiAyNTUpOyB9KTtcbiAgICAgICAgdWludEFycmF5W2ldID0gTWF0aC5mbG9vcihub3JtYWxpemVkVmFsdWUpO1xuICAgICAgICB1aW50QXJyYXlbaSArIDFdID0gYnVja2V0c1swXTtcbiAgICAgICAgdWludEFycmF5W2kgKyAyXSA9IGJ1Y2tldHNbMV07XG4gICAgICAgIHVpbnRBcnJheVtpICsgM10gPSBidWNrZXRzWzJdO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1aW50QXJyYXkubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnRBcnJheTtcbn1cbmV4cG9ydHMuZW5jb2RlRmxvYXRBcnJheSA9IGVuY29kZUZsb2F0QXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVUb0Zsb2F0QXJyYXkodWludEFycmF5KSB7XG4gICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHVpbnRBcnJheS5sZW5ndGggLyA0KTtcbiAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIGlmICh1aW50QXJyYXlbaV0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMV0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMl0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgM10gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUpIHtcbiAgICAgICAgICAgIGZsb2F0QXJyYXlbaSAvIDRdID0gTmFOO1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG90ID0gMDtcbiAgICAgICAgRkxPQVRfREVMVEFTLmZvckVhY2goZnVuY3Rpb24gKGRlbHRhLCBqKSB7XG4gICAgICAgICAgICBkb3QgKz0gZGVsdGEgKiB1aW50QXJyYXlbaSArIGpdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHZhbHVlID0gZG90ICogRkxPQVRfUkFOR0UgKyBleHBvcnRzLkZMT0FUX01JTjtcbiAgICAgICAgZmxvYXRBcnJheVtpIC8gNF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdWludEFycmF5Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIF9sb29wXzIoaSk7XG4gICAgfVxuICAgIHJldHVybiBmbG9hdEFycmF5O1xufVxuZXhwb3J0cy5kZWNvZGVUb0Zsb2F0QXJyYXkgPSBkZWNvZGVUb0Zsb2F0QXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheSh1bnBhY2tlZEFycmF5LCBtYXRyaXgsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKHVucGFja2VkQXJyYXkubGVuZ3RoLCBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgIGlmIChtYXRyaXgubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgdW5wYWNrZWRBcnJheS5sZW5ndGg7IHNyYyArPSBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICAgICAgbWF0cml4W2RzdCsrXSA9IHVucGFja2VkQXJyYXlbc3JjXTtcbiAgICB9XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5ID0gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheSh1bnBhY2tlZEFycmF5LCBtYXRyaXgsIGNoYW5uZWxzKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IHVucGFja2VkQXJyYXkubGVuZ3RoICogY2hhbm5lbHMgLyA0O1xuICAgIGlmIChtYXRyaXgubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgdW5wYWNrZWRBcnJheS5sZW5ndGg7IHNyYyArPSA0KSB7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHVucGFja2VkQXJyYXlbc3JjICsgY107XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5ID0gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXk7XG5mdW5jdGlvbiBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtNYXRoLmNlaWwoY29sdW1ucyAvIDIpLCBNYXRoLmNlaWwocm93cyAvIDIpXTtcbn1cbmV4cG9ydHMuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodDtcbmZ1bmN0aW9uIGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICByZXR1cm4gdyAqIGggKiA0O1xufVxuZXhwb3J0cy5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlID0gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZTtcbmZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvUGFja2VkUkdCQShtYXRyaXgsIHJvd3MsIGNvbHVtbnMsIHBhY2tlZFJHQkEpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKTtcbiAgICBpZiAocGFja2VkUkdCQS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFja2VkUkdCQSBsZW5ndGggKFwiICsgcGFja2VkUkdCQS5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB0ZXh0dXJlV2lkdGggPSBfYVswXSwgdGV4dHVyZUhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBvZGRXaWR0aCA9IChjb2x1bW5zICUgMikgPT09IDE7XG4gICAgdmFyIG9kZEhlaWdodCA9IChyb3dzICUgMikgPT09IDE7XG4gICAgdmFyIHdpZHRoSW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihjb2x1bW5zIC8gMik7XG4gICAgdmFyIGhlaWdodEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3Iocm93cyAvIDIpO1xuICAgIHtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IChvZGRXaWR0aCA/IDQgOiAwKTtcbiAgICAgICAgdmFyIG9uZVJvdyA9IGNvbHVtbnM7XG4gICAgICAgIHZhciBkc3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICB2YXIgbWF0cml4U3JjUm93ID0gKGJsb2NrWSAqIDIgKiBjb2x1bW5zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRyaXhTcmNDb2wgPSBibG9ja1ggKiAyO1xuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBtYXRyaXhTcmNSb3cgKyBtYXRyaXhTcmNDb2w7XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAxXSA9IG1hdHJpeFtzcmMgKyAxXTtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDJdID0gbWF0cml4W3NyYyArIG9uZVJvd107XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAzXSA9IG1hdHJpeFtzcmMgKyBvbmVSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICBkc3QgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoKSB7XG4gICAgICAgIHZhciBzcmMgPSBjb2x1bW5zIC0gMTtcbiAgICAgICAgdmFyIGRzdCA9ICh0ZXh0dXJlV2lkdGggLSAxKSAqIDQ7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSAyICogY29sdW1ucztcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAyXSA9IG1hdHJpeFtzcmMgKyBjb2x1bW5zXTtcbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRIZWlnaHQpIHtcbiAgICAgICAgdmFyIHNyYyA9IChyb3dzIC0gMSkgKiBjb2x1bW5zO1xuICAgICAgICB2YXIgZHN0ID0gKHRleHR1cmVIZWlnaHQgLSAxKSAqIHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgICAgICAgZHN0ICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgICAgICBwYWNrZWRSR0JBW3BhY2tlZFJHQkEubGVuZ3RoIC0gNF0gPSBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gcGFja2VkUkdCQTtcbn1cbmV4cG9ydHMuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBID0gZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBO1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEocGFja2VkUkdCQSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IHJvd3MgKiBjb2x1bW5zO1xuICAgIGlmIChyZXF1aXJlZFNpemUgPCBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIG9kZFdpZHRoID0gKGNvbHVtbnMgJSAyKSA9PT0gMTtcbiAgICB2YXIgb2RkSGVpZ2h0ID0gKHJvd3MgJSAyKSA9PT0gMTtcbiAgICB2YXIgd2lkdGhJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKGNvbHVtbnMgLyAyKTtcbiAgICB2YXIgaGVpZ2h0SW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihyb3dzIC8gMik7XG4gICAgdmFyIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHRleHR1cmVXaWR0aCA9IF9hWzBdLCB0ZXh0dXJlSGVpZ2h0ID0gX2FbMV07XG4gICAge1xuICAgICAgICB2YXIgc3JjU3RyaWRlID0gb2RkV2lkdGggPyA0IDogMDtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IGNvbHVtbnMgKyAob2RkV2lkdGggPyAxIDogMCk7XG4gICAgICAgIHZhciBzcmMgPSAwO1xuICAgICAgICB2YXIgZHN0Um93MSA9IDA7XG4gICAgICAgIHZhciBkc3RSb3cyID0gY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzErK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MSsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cyKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzIrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3RSb3cxICs9IGRzdFN0cmlkZTtcbiAgICAgICAgICAgIGRzdFJvdzIgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCkge1xuICAgICAgICB2YXIgc3JjID0gKHRleHR1cmVXaWR0aCAtIDEpICogNDtcbiAgICAgICAgdmFyIGRzdCA9IGNvbHVtbnMgLSAxO1xuICAgICAgICB2YXIgc3JjU3RyaWRlID0gdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IDIgKiBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICBtYXRyaXhbZHN0XSA9IHBhY2tlZFJHQkFbc3JjXTtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QgKyBjb2x1bW5zXSA9IHBhY2tlZFJHQkFbc3JjICsgMl07XG4gICAgICAgICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgICAgICAgZHN0ICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkSGVpZ2h0KSB7XG4gICAgICAgIHZhciBzcmMgPSAodGV4dHVyZUhlaWdodCAtIDEpICogdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgdmFyIGRzdCA9IChyb3dzIC0gMSkgKiBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIHNyYyArPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCAmJiBvZGRIZWlnaHQpIHtcbiAgICAgICAgbWF0cml4W21hdHJpeC5sZW5ndGggLSAxXSA9IHBhY2tlZFJHQkFbcGFja2VkUkdCQS5sZW5ndGggLSA0XTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbn1cbmV4cG9ydHMuZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEgPSBkZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRleF91dGlsXzEgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciBUZXh0dXJlTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dHVyZU1hbmFnZXIoZ3BncHUpIHtcbiAgICAgICAgdGhpcy5ncGdwdSA9IGdwZ3B1O1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcyA9IDA7XG4gICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVzID0ge307XG4gICAgfVxuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZSA9IGZ1bmN0aW9uIChzaGFwZVJDLCB0ZXhUeXBlKSB7XG4gICAgICAgIGlmICh0ZXhUeXBlID09PSB2b2lkIDApIHsgdGV4VHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuRkxPQVQ7IH1cbiAgICAgICAgdmFyIHNoYXBlS2V5ID0gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZVJDLCB0ZXhUeXBlKTtcbiAgICAgICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy5mcmVlVGV4dHVyZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLnVzZWRUZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMudXNlZFRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMtLTtcbiAgICAgICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzKys7XG4gICAgICAgICAgICB0aGlzLmxvZygpO1xuICAgICAgICAgICAgdmFyIG5ld1RleHR1cmVfMSA9IHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy51c2VkVGV4dHVyZXNbc2hhcGVLZXldLnB1c2gobmV3VGV4dHVyZV8xKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdUZXh0dXJlXzE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMrKztcbiAgICAgICAgdGhpcy5sb2coKTtcbiAgICAgICAgdmFyIG5ld1RleHR1cmUgPSB0aGlzLmdwZ3B1LmNyZWF0ZU1hdHJpeFRleHR1cmUoc2hhcGVSQ1swXSwgc2hhcGVSQ1sxXSk7XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVzW3NoYXBlS2V5XS5wdXNoKG5ld1RleHR1cmUpO1xuICAgICAgICByZXR1cm4gbmV3VGV4dHVyZTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzaGFwZSwgdGV4VHlwZSkge1xuICAgICAgICBpZiAodGV4VHlwZSA9PT0gdm9pZCAwKSB7IHRleFR5cGUgPSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkZMT0FUOyB9XG4gICAgICAgIHZhciBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGUsIHRleFR5cGUpO1xuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLmZyZWVUZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5wdXNoKHRleHR1cmUpO1xuICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcysrO1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcy0tO1xuICAgICAgICB2YXIgdGV4TGlzdCA9IHRoaXMudXNlZFRleHR1cmVzW3NoYXBlS2V5XTtcbiAgICAgICAgdmFyIHRleEluZGV4ID0gdGV4TGlzdC5pbmRleE9mKHRleHR1cmUpO1xuICAgICAgICBpZiAodGV4SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWxlYXNlIGEgdGV4dHVyZSB0aGF0IHdhcyBuZXZlciBwcm92aWRlZCBieSB0aGlzICcgK1xuICAgICAgICAgICAgICAgICd0ZXh0dXJlIG1hbmFnZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXhMaXN0LnNwbGljZSh0ZXhJbmRleCwgMSk7XG4gICAgICAgIHRoaXMubG9nKCk7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMubnVtRnJlZVRleHR1cmVzICsgdGhpcy5udW1Vc2VkVGV4dHVyZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmVlL1VzZWQnLCB0aGlzLm51bUZyZWVUZXh0dXJlcyArIFwiIC8gXCIgKyB0aGlzLm51bVVzZWRUZXh0dXJlcywgXCIoXCIgKyB0b3RhbCArIFwiKVwiKTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5nZXROdW1Vc2VkVGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5nZXROdW1GcmVlVGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUZyZWVUZXh0dXJlcztcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5mcmVlVGV4dHVyZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHRleFNoYXBlIGluIHRoaXMuZnJlZVRleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWVUZXh0dXJlc1t0ZXhTaGFwZV0uZm9yRWFjaChmdW5jdGlvbiAodGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZSh0ZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgdGV4U2hhcGUgaW4gdGhpcy51c2VkVGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMudXNlZFRleHR1cmVzW3RleFNoYXBlXS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVUZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcyA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dHVyZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5UZXh0dXJlTWFuYWdlciA9IFRleHR1cmVNYW5hZ2VyO1xuZnVuY3Rpb24gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZVJvd3NDb2wsIHRleFR5cGUpIHtcbiAgICByZXR1cm4gc2hhcGVSb3dzQ29sWzBdICsgXCJfXCIgKyBzaGFwZVJvd3NDb2xbMV0gKyBcIl9cIiArIHRleFR5cGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlX21hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgVGlsZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbGVQcm9ncmFtKGFTaGFwZSwgcmVwcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGFTaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBnZXRTb3VyY2VDb29yZHMoYVNoYXBlKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFRpbGVQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuVGlsZVByb2dyYW0gPSBUaWxlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyhhU2hhcGUpIHtcbiAgICB2YXIgcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPiA1KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVGlsZSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiaW1vZChyZXNSQywgXCIgKyBhU2hhcGVbMF0gKyBcIilcIjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDb29yZHMgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnLCAncmVzUkMudSddO1xuICAgIHZhciBzb3VyY2VDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VyY2VDb29yZHMucHVzaChcImltb2QoXCIgKyBjdXJyZW50Q29vcmRzW2ldICsgXCIsIFwiICsgYVNoYXBlW2ldICsgXCIpXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlQ29vcmRzLmpvaW4oKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGVfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFRyYW5zcG9zZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9zZVByb2dyYW0oYVNoYXBlLCBuZXdEaW0pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IG5ldyBBcnJheShhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBhU2hhcGVbbmV3RGltW2ldXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMucmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHN3aXRjaGVkID0gZ2V0U3dpdGNoZWRDb29yZHMobmV3RGltKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIHN3aXRjaGVkICsgXCIpKTtcXG4gICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zcG9zZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5UcmFuc3Bvc2VQcm9ncmFtID0gVHJhbnNwb3NlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldFN3aXRjaGVkQ29vcmRzKG5ld0RpbSkge1xuICAgIHZhciByYW5rID0gbmV3RGltLmxlbmd0aDtcbiAgICBpZiAocmFuayA+IDUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUcmFuc3Bvc2UgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIHZhciBvcmlnaW5hbE9yZGVyID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53JywgJ3Jlc1JDLnUnXTtcbiAgICB2YXIgc3dpdGNoZWRDb29yZHMgPSBuZXcgQXJyYXkocmFuayk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEaW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoZWRDb29yZHNbbmV3RGltW2ldXSA9IG9yaWdpbmFsT3JkZXJbaV07XG4gICAgfVxuICAgIHJldHVybiBzd2l0Y2hlZENvb3Jkcy5qb2luKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3Bvc2VfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVyZl91dGlsID0gcmVxdWlyZShcIi4uLy4uL29wcy9lcmZfdXRpbFwiKTtcbnZhciBzZWx1X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL3NlbHVfdXRpbFwiKTtcbnZhciBVbmFyeU9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5hcnlPcFByb2dyYW0oYVNoYXBlLCBvcFNuaXBwZXQpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGZsb2F0IHVuYXJ5T3BlcmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgIFwiICsgb3BTbmlwcGV0ICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBVbmFyeU9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlVuYXJ5T3BQcm9ncmFtID0gVW5hcnlPcFByb2dyYW07XG52YXIgQ0hFQ0tfTkFOX1NOSVBQRVQgPSBcImlmIChpc05hTih4KSkgcmV0dXJuIHg7XCI7XG5leHBvcnRzLkFCUyA9IFwicmV0dXJuIGFicyh4KTtcIjtcbmV4cG9ydHMuUkVMVSA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiB4O1xcblwiO1xuZXhwb3J0cy5FTFUgPSBcInJldHVybiAoeCA+PSAwLjApID8geCA6IChleHAoeCkgLSAxLjApO1wiO1xuZXhwb3J0cy5TRUxVID0gXCJcXG4gIC8vIFN0YWJsZSBhbmQgQXR0cmFjdGluZyBGaXhlZCBQb2ludCAoMCwgMSkgZm9yIE5vcm1hbGl6ZWQgV2VpZ2h0cy5cXG4gIC8vIHNlZTogaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDI1MTVcXG4gIGZsb2F0IHNjYWxlQWxwaGEgPSBcIiArIHNlbHVfdXRpbC5TRUxVX1NDQUxFQUxQSEEgKyBcIjtcXG4gIGZsb2F0IHNjYWxlID0gXCIgKyBzZWx1X3V0aWwuU0VMVV9TQ0FMRSArIFwiO1xcbiAgcmV0dXJuICh4ID49IDAuMCkgPyBzY2FsZSAqIHggOiBzY2FsZUFscGhhICogKGV4cCh4KSAtIDEuMCk7XFxuXCI7XG5mdW5jdGlvbiBTVEVQKGFscGhhKSB7XG4gICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjA7IH1cbiAgICByZXR1cm4gQ0hFQ0tfTkFOX1NOSVBQRVQgKyAoXCJcXG4gICAgcmV0dXJuIHggPiAwLjAgPyAxLjAgOiBmbG9hdChcIiArIGFscGhhICsgXCIpO1xcbiAgXCIpO1xufVxuZXhwb3J0cy5TVEVQID0gU1RFUDtcbmV4cG9ydHMuTkVHID0gXCJyZXR1cm4gLXg7XCI7XG5leHBvcnRzLkNFSUwgPSBcInJldHVybiBjZWlsKHgpO1wiO1xuZXhwb3J0cy5GTE9PUiA9IFwicmV0dXJuIGZsb29yKHgpO1wiO1xuZXhwb3J0cy5TSUdOID0gXCJcXG4gIGlmIChpc05hTih4KSkgeyByZXR1cm4gMC4wOyB9XFxuICByZXR1cm4gc2lnbih4KTtcXG5cIjtcbmV4cG9ydHMuUk9VTkQgPSBcIlxcbiAgLy8gT3BlbkdMIEVTIGRvZXMgbm90IHN1cHBvcnQgcm91bmQgZnVuY3Rpb24uXFxuICAvLyBUaGUgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIGJhbmtlcidzIHJvdW5kaW5nLlxcbiAgZmxvYXQgYmFzZSA9IGZsb29yKHgpO1xcbiAgaWYgKCh4IC0gYmFzZSkgPCAwLjUpIHtcXG4gICAgcmV0dXJuIGZsb29yKHgpO1xcbiAgfSBlbHNlIGlmICgoeCAtIGJhc2UpID4gMC41KSB7XFxuICAgIHJldHVybiBjZWlsKHgpO1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKG1vZChiYXNlLCAyLjApID09IDAuMCkge1xcbiAgICAgIHJldHVybiBiYXNlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlICsgMS4wO1xcbiAgICB9XFxuICB9XFxuXCI7XG5leHBvcnRzLkVYUCA9IFwicmV0dXJuIGV4cCh4KTtcIjtcbmV4cG9ydHMuRVhQTTEgPSBcInJldHVybiBleHAoeCkgLSAxLjA7XCI7XG5leHBvcnRzLkxPRyA9IFwicmV0dXJuIGxvZyh4KTtcIjtcbmV4cG9ydHMuTE9HMVAgPSBcInJldHVybiBsb2coMS4wICsgeCk7XCI7XG5leHBvcnRzLlNRUlQgPSBcInJldHVybiBzcXJ0KHgpO1wiO1xuZXhwb3J0cy5SU1FSVCA9IFwicmV0dXJuIGludmVyc2VzcXJ0KHgpO1wiO1xuZXhwb3J0cy5TSUdNT0lEID0gXCJyZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1wiO1xuZXhwb3J0cy5TT0ZUUExVUyA9IFwiXFxuICBmbG9hdCBlcHNpbG9uID0gMS4xOTIwOTI4OTU1MDc4MTI1ZS03O1xcbiAgZmxvYXQgdGhyZXNob2xkID0gbG9nKGVwc2lsb24pICsgMi4wO1xcblxcbiAgYm9vbCB0b29fbGFyZ2UgPSB4ID4gLXRocmVzaG9sZDtcXG4gIGJvb2wgdG9vX3NtYWxsID0geCA8IHRocmVzaG9sZDtcXG5cXG4gIGZsb2F0IHJlc3VsdDtcXG4gIGZsb2F0IGV4cF94ID0gZXhwKHgpO1xcblxcbiAgaWYgKHRvb19sYXJnZSl7XFxuICAgIHJlc3VsdCA9IHg7XFxuICB9XFxuICBlbHNlIGlmICh0b29fc21hbGwpe1xcbiAgICByZXN1bHQgPSBleHBfeDtcXG4gIH1cXG4gIGVsc2V7XFxuICAgIHJlc3VsdCA9IGxvZyhleHBfeCArIDEuMCk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcblwiO1xuZXhwb3J0cy5TSU4gPSBcInJldHVybiBzaW4oeCk7XCI7XG5leHBvcnRzLkNPUyA9IFwicmV0dXJuIGNvcyh4KTtcIjtcbmV4cG9ydHMuVEFOID0gXCJyZXR1cm4gdGFuKHgpO1wiO1xuZXhwb3J0cy5BU0lOID0gXCJyZXR1cm4gYXNpbih4KTtcIjtcbmV4cG9ydHMuQUNPUyA9IFwicmV0dXJuIGFjb3MoeCk7XCI7XG5leHBvcnRzLkFUQU4gPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gYXRhbih4KTtcXG5cIjtcbmV4cG9ydHMuU0lOSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoeCk7XFxuICByZXR1cm4gKGUyeCAtIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCI7XG5leHBvcnRzLkNPU0ggPSBcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC14KTtcXG4gIHJldHVybiAoZTJ4ICsgMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIjtcbmV4cG9ydHMuVEFOSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoLTIuMCAqIGFicyh4KSk7XFxuICByZXR1cm4gc2lnbih4KSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XFxuXCI7XG5leHBvcnRzLkFTSU5IID0gXCJyZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4ICsgMS4wKSk7XCI7XG5leHBvcnRzLkFDT1NIID0gXCJyZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMS4wKSk7XCI7XG5leHBvcnRzLkFUQU5IID0gXCJyZXR1cm4gKGxvZygxLjAgKyB4KSAtIGxvZygxLjAgLSB4KSkgLyAyLjA7XCI7XG5leHBvcnRzLkVSRiA9IFwiXFxuICAvLyBFcnJvciBmdW5jdGlvbiBpcyBjYWxjdWxhdGVkIGFwcHJveGltYXRlbHkgd2l0aCBlbGVtZW50YXJ5IGZ1bmN0aW9uLlxcbiAgLy8gU2VlIFxcXCJIYW5kYm9vayBvZiBNYXRoZW1hdGljYWwgRnVuY3Rpb25zIHdpdGggRm9ybXVsYXMsXFxuICAvLyBHcmFwaHMsIGFuZCBNYXRoZW1hdGljYWwgVGFibGVzXFxcIiwgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLlxcbiAgZmxvYXQgcCA9IFwiICsgZXJmX3V0aWwuRVJGX1AgKyBcIjtcXG4gIGZsb2F0IGExID0gXCIgKyBlcmZfdXRpbC5FUkZfQTEgKyBcIjtcXG4gIGZsb2F0IGEyID0gXCIgKyBlcmZfdXRpbC5FUkZfQTIgKyBcIjtcXG4gIGZsb2F0IGEzID0gXCIgKyBlcmZfdXRpbC5FUkZfQTMgKyBcIjtcXG4gIGZsb2F0IGE0ID0gXCIgKyBlcmZfdXRpbC5FUkZfQTQgKyBcIjtcXG4gIGZsb2F0IGE1ID0gXCIgKyBlcmZfdXRpbC5FUkZfQTUgKyBcIjtcXG5cXG4gIGZsb2F0IHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xcbiAgcmV0dXJuIDEuMCAtICgoKCgoYTUqdCArIGE0KSp0KSArIGEzKSp0ICsgYTIpKnQgKyBhMSkqdCpleHAoLXgqeCk7XFxuXCI7XG5leHBvcnRzLlNRVUFSRSA9IFwicmV0dXJuIHggKiB4O1wiO1xuZXhwb3J0cy5SRUNJUFJPQ0FMID0gXCJyZXR1cm4gMS4wIC8geDtcIjtcbmV4cG9ydHMuTE9HSUNBTF9OT1QgPSBcInJldHVybiBmbG9hdCghKHggPj0gMS4wKSk7XCI7XG5leHBvcnRzLlRPX0lOVCA9IFwicmV0dXJuIGZsb2F0KGludCh4KSk7XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmFyeW9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNQVhfVEVYVFVSRV9TSVpFID0gbnVsbDtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dChhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgcmV0dXJuIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKTtcbn1cbmV4cG9ydHMuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0ID0gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuZnVuY3Rpb24gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZ2w7XG4gICAgdmFyIHdlYmdsVmVyc2lvbiA9IGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpO1xuICAgIGlmICh3ZWJnbFZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdlYmdsVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICBnbCA9IChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKSB8fFxuICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgaWYgKHdlYmdsVmVyc2lvbiA9PT0gMCB8fCBnbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR0wuJyk7XG4gICAgfVxuICAgIHJldHVybiBnbDtcbn1cbmV4cG9ydHMuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyA9IGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXM7XG5mdW5jdGlvbiBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmMpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBmdW5jKCk7XG4gICAgY2hlY2tXZWJHTEVycm9yKGdsKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5leHBvcnRzLmNhbGxBbmRDaGVjayA9IGNhbGxBbmRDaGVjaztcbnZhciB3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nKGVuYWJsZWQpIHtcbiAgICB3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQgPSBlbmFibGVkO1xufVxuZXhwb3J0cy5lbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyA9IGVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nO1xuZnVuY3Rpb24gY2hlY2tXZWJHTEVycm9yKGdsKSB7XG4gICAgaWYgKHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBnbC5nZXRFcnJvcigpO1xuICAgICAgICBpZiAoZXJyb3IgIT09IGdsLk5PX0VSUk9SKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIEVycm9yOiAnICsgZ2V0V2ViR0xFcnJvck1lc3NhZ2UoZ2wsIGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNoZWNrV2ViR0xFcnJvciA9IGNoZWNrV2ViR0xFcnJvcjtcbmZ1bmN0aW9uIGdldFdlYkdMRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlIGdsLk5PX0VSUk9SOlxuICAgICAgICAgICAgcmV0dXJuICdOT19FUlJPUic7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9FTlVNOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX0VOVU0nO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfVkFMVUU6XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfVkFMVUUnO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfT1BFUkFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX09QRVJBVElPTic7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OJztcbiAgICAgICAgY2FzZSBnbC5PVVRfT0ZfTUVNT1JZOlxuICAgICAgICAgICAgcmV0dXJuICdPVVRfT0ZfTUVNT1JZJztcbiAgICAgICAgY2FzZSBnbC5DT05URVhUX0xPU1RfV0VCR0w6XG4gICAgICAgICAgICByZXR1cm4gJ0NPTlRFWFRfTE9TVF9XRUJHTCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVbmtub3duIGVycm9yIGNvZGUgXCIgKyBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRXZWJHTEVycm9yTWVzc2FnZSA9IGdldFdlYkdMRXJyb3JNZXNzYWdlO1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uT3JUaHJvdyhnbCwgZXh0ZW5zaW9uTmFtZSkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpOyB9LCAnRXh0ZW5zaW9uIFwiJyArIGV4dGVuc2lvbk5hbWUgKyAnXCIgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuJyk7XG59XG5leHBvcnRzLmdldEV4dGVuc2lvbk9yVGhyb3cgPSBnZXRFeHRlbnNpb25PclRocm93O1xuZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpIHtcbiAgICB2YXIgdmVydGV4U2hhZGVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgdmVydGV4IFdlYkdMU2hhZGVyLicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyU291cmNlKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7IH0pO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbXBpbGUgdmVydGV4IHNoYWRlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbn1cbmV4cG9ydHMuY3JlYXRlVmVydGV4U2hhZGVyID0gY3JlYXRlVmVydGV4U2hhZGVyO1xuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBmcmFnbWVudCBXZWJHTFNoYWRlci4nKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpOyB9KTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ1NoYWRlclNvdXJjZUFuZEluZm9Mb2coZnJhZ21lbnRTaGFkZXJTb3VyY2UsIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29tcGlsZSBmcmFnbWVudCBzaGFkZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbn1cbmV4cG9ydHMuY3JlYXRlRnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVGcmFnbWVudFNoYWRlcjtcbnZhciBsaW5lTnVtYmVyUmVnZXggPSAvRVJST1I6IFswLTldKzooWzAtOV0rKTovZztcbmZ1bmN0aW9uIGxvZ1NoYWRlclNvdXJjZUFuZEluZm9Mb2coc2hhZGVyU291cmNlLCBzaGFkZXJJbmZvTG9nKSB7XG4gICAgdmFyIGxpbmVOdW1iZXJSZWdleFJlc3VsdCA9IGxpbmVOdW1iZXJSZWdleC5leGVjKHNoYWRlckluZm9Mb2cpO1xuICAgIGlmIChsaW5lTnVtYmVyUmVnZXhSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNvdWxkbid0IHBhcnNlIGxpbmUgbnVtYmVyIGluIGVycm9yOiBcIiArIHNoYWRlckluZm9Mb2cpO1xuICAgICAgICBjb25zb2xlLmxvZyhzaGFkZXJTb3VyY2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsaW5lTnVtYmVyID0gK2xpbmVOdW1iZXJSZWdleFJlc3VsdFsxXTtcbiAgICB2YXIgc2hhZGVyTGluZXMgPSBzaGFkZXJTb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBwYWQgPSBzaGFkZXJMaW5lcy5sZW5ndGgudG9TdHJpbmcoKS5sZW5ndGggKyAyO1xuICAgIHZhciBsaW5lc1dpdGhMaW5lTnVtYmVycyA9IHNoYWRlckxpbmVzLm1hcChmdW5jdGlvbiAobGluZSwgbGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdXRpbC5yaWdodFBhZCgobGluZU51bWJlciArIDEpLnRvU3RyaW5nKCksIHBhZCkgKyBsaW5lO1xuICAgIH0pO1xuICAgIHZhciBtYXhMaW5lTGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzV2l0aExpbmVOdW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChsaW5lc1dpdGhMaW5lTnVtYmVyc1tpXS5sZW5ndGgsIG1heExpbmVMZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgYmVmb3JlRXJyb3JMaW5lcyA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKDAsIGxpbmVOdW1iZXIgLSAxKTtcbiAgICB2YXIgZXJyb3JMaW5lID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UobGluZU51bWJlciAtIDEsIGxpbmVOdW1iZXIpO1xuICAgIHZhciBhZnRlckVycm9yTGluZXMgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZShsaW5lTnVtYmVyKTtcbiAgICBjb25zb2xlLmxvZyhiZWZvcmVFcnJvckxpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICBjb25zb2xlLmxvZyhzaGFkZXJJbmZvTG9nLnNwbGl0KCdcXG4nKVswXSk7XG4gICAgY29uc29sZS5sb2coXCIlYyBcIiArIHV0aWwucmlnaHRQYWQoZXJyb3JMaW5lWzBdLCBtYXhMaW5lTGVuZ3RoKSwgJ2JvcmRlcjoxcHggc29saWQgcmVkOyBiYWNrZ3JvdW5kLWNvbG9yOiNlM2QyZDI7IGNvbG9yOiNhNjE3MTcnKTtcbiAgICBjb25zb2xlLmxvZyhhZnRlckVycm9yTGluZXMuam9pbignXFxuJykpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlUHJvZ3JhbSgpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFByb2dyYW0uJyk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2dyYW0gPSBjcmVhdGVQcm9ncmFtO1xuZnVuY3Rpb24gbGlua1Byb2dyYW0oZ2wsIHByb2dyYW0pIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbGluayB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuJyk7XG4gICAgfVxufVxuZXhwb3J0cy5saW5rUHJvZ3JhbSA9IGxpbmtQcm9ncmFtO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgcHJvZ3JhbSB2YWxpZGF0aW9uIGZhaWxlZC4nKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUHJvZ3JhbSA9IHZhbGlkYXRlUHJvZ3JhbTtcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihnbCwgZGF0YSkge1xuICAgIHZhciBidWZmZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlQnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpOyB9KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5jcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIgPSBjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXI7XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcihnbCwgZGF0YSkge1xuICAgIHZhciBidWZmZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlQnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTsgfSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIgPSBjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcjtcbmZ1bmN0aW9uIHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpIHtcbiAgICBpZiAoTUFYX1RFWFRVUkVfU0laRSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNQVhfVEVYVFVSRV9TSVpFO1xuICAgIH1cbiAgICBNQVhfVEVYVFVSRV9TSVpFID1cbiAgICAgICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7IH0pO1xuICAgIHJldHVybiBNQVhfVEVYVFVSRV9TSVpFO1xufVxuZXhwb3J0cy5xdWVyeU1heFRleHR1cmVTaXplID0gcXVlcnlNYXhUZXh0dXJlU2l6ZTtcbmZ1bmN0aW9uIGdldENoYW5uZWxzUGVyVGV4dHVyZSgpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDQ7XG59XG5leHBvcnRzLmdldENoYW5uZWxzUGVyVGV4dHVyZSA9IGdldENoYW5uZWxzUGVyVGV4dHVyZTtcbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVRleHR1cmUoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xUZXh0dXJlLicpO1xufVxuZXhwb3J0cy5jcmVhdGVUZXh0dXJlID0gY3JlYXRlVGV4dHVyZTtcbmZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVNpemUoZ2wsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgbWF4VGV4dHVyZVNpemUgPSBxdWVyeU1heFRleHR1cmVTaXplKGdsKTtcbiAgICBpZiAoKHdpZHRoIDw9IDApIHx8IChoZWlnaHQgPD0gMCkpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZCA9IFwiW1wiICsgd2lkdGggKyBcInhcIiArIGhlaWdodCArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCB0ZXh0dXJlIHNpemUgJyArIHJlcXVlc3RlZCArICcgaXMgaW52YWxpZC4nKTtcbiAgICB9XG4gICAgaWYgKCh3aWR0aCA+IG1heFRleHR1cmVTaXplKSB8fCAoaGVpZ2h0ID4gbWF4VGV4dHVyZVNpemUpKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ZWQgPSBcIltcIiArIHdpZHRoICsgXCJ4XCIgKyBoZWlnaHQgKyBcIl1cIjtcbiAgICAgICAgdmFyIG1heCA9IFwiW1wiICsgbWF4VGV4dHVyZVNpemUgKyBcInhcIiArIG1heFRleHR1cmVTaXplICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSAnICsgcmVxdWVzdGVkICtcbiAgICAgICAgICAgICcgZ3JlYXRlciB0aGFuIFdlYkdMIG1heGltdW0gb24gdGhpcyBicm93c2VyIC8gR1BVICcgKyBtYXggKyAnLicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUZXh0dXJlU2l6ZSA9IHZhbGlkYXRlVGV4dHVyZVNpemU7XG5mdW5jdGlvbiBjcmVhdGVGcmFtZWJ1ZmZlcihnbCkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xGcmFtZWJ1ZmZlci4nKTtcbn1cbmV4cG9ydHMuY3JlYXRlRnJhbWVidWZmZXIgPSBjcmVhdGVGcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIGJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGF0dHJpYnV0ZSwgYnVmZmVyLCBhcnJheUVudHJpZXNQZXJJdGVtLCBpdGVtU3RyaWRlSW5CeXRlcywgaXRlbU9mZnNldEluQnl0ZXMpIHtcbiAgICB2YXIgbG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlKTtcbiAgICBpZiAobG9jID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2MsIGFycmF5RW50cmllc1Blckl0ZW0sIGdsLkZMT0FULCBmYWxzZSwgaXRlbVN0cmlkZUluQnl0ZXMsIGl0ZW1PZmZzZXRJbkJ5dGVzKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2MpOyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZSA9IGJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGU7XG5mdW5jdGlvbiBiaW5kVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTsgfSk7XG59XG5leHBvcnRzLmJpbmRUZXh0dXJlVW5pdCA9IGJpbmRUZXh0dXJlVW5pdDtcbmZ1bmN0aW9uIHVuYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCkge1xuICAgIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZXhwb3J0cy51bmJpbmRUZXh0dXJlVW5pdCA9IHVuYmluZFRleHR1cmVVbml0O1xuZnVuY3Rpb24gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3coZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpOyB9LCAndW5pZm9ybSBcIicgKyB1bmlmb3JtTmFtZSArICdcIiBub3QgcHJlc2VudCBpbiBwcm9ncmFtLicpO1xufVxuZXhwb3J0cy5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyA9IGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93O1xuZnVuY3Rpb24gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbihnbCwgcHJvZ3JhbSwgdW5pZm9ybU5hbWUpIHtcbiAgICByZXR1cm4gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbn1cbmV4cG9ydHMuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbiA9IGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb247XG5mdW5jdGlvbiBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKGdsLCBwcm9ncmFtLCB0ZXh0dXJlLCB1bmlmb3JtU2FtcGxlckxvY2F0aW9uLCB0ZXh0dXJlVW5pdCkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudW5pZm9ybTFpKHVuaWZvcm1TYW1wbGVyTG9jYXRpb24sIHRleHR1cmVVbml0KTsgfSk7XG59XG5leHBvcnRzLmJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIgPSBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyO1xuZnVuY3Rpb24gYmluZENhbnZhc1RvRnJhbWVidWZmZXIoZ2wpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zY2lzc29yKDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7IH0pO1xufVxuZXhwb3J0cy5iaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlciA9IGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoZ2wsIHRleHR1cmUsIGZyYW1lYnVmZmVyKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApOyB9KTtcbn1cbmV4cG9ydHMuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIgPSBiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcihnbCwgZnJhbWVidWZmZXIpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgbnVsbCwgMCk7IH0pO1xufVxuZXhwb3J0cy51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIgPSB1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXI7XG5mdW5jdGlvbiB2YWxpZGF0ZUZyYW1lYnVmZmVyKGdsKSB7XG4gICAgdmFyIHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICAgIGlmIChzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYmluZGluZyBmcmFtZWJ1ZmZlcjogJyArIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlRnJhbWVidWZmZXIgPSB2YWxpZGF0ZUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yIFwiICsgc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UgPSBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTtcbmZ1bmN0aW9uIHRocm93SWZOdWxsKGdsLCByZXR1cm5UT3JOdWxsLCBmYWlsdXJlTWVzc2FnZSkge1xuICAgIHZhciB0T3JOdWxsID0gY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXR1cm5UT3JOdWxsKCk7IH0pO1xuICAgIGlmICh0T3JOdWxsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhaWx1cmVNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRPck51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCkge1xuICAgIHZhciBtYXhUZXh0dXJlVW5pdCA9IGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTIC0gMTtcbiAgICB2YXIgZ2xUZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0ICsgZ2wuVEVYVFVSRTA7XG4gICAgaWYgKGdsVGV4dHVyZVVuaXQgPCBnbC5URVhUVVJFMCB8fCBnbFRleHR1cmVVbml0ID4gbWF4VGV4dHVyZVVuaXQpIHtcbiAgICAgICAgdmFyIHRleHR1cmVVbml0UmFuZ2UgPSBcIltnbC5URVhUVVJFMCwgZ2wuVEVYVFVSRVwiICsgbWF4VGV4dHVyZVVuaXQgKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGV4dHVyZVVuaXQgbXVzdCBiZSBpbiBcIiArIHRleHR1cmVVbml0UmFuZ2UgKyBcIi5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZShnbCwgbG9nU2hhcGUpIHtcbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHZhciBzcXVlZXplUmVzdWx0ID0gdXRpbC5zcXVlZXplU2hhcGUobG9nU2hhcGUpO1xuICAgICAgICBsb2dTaGFwZSA9IHNxdWVlemVSZXN1bHQubmV3U2hhcGU7XG4gICAgfVxuICAgIHZhciBtYXhUZXhTaXplID0gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCk7XG4gICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUobG9nU2hhcGUpO1xuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggPD0gMSAmJiBzaXplIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFtzaXplLCAxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAyICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gbG9nU2hhcGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMyAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdLCBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSA0ICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSAqIGxvZ1NoYXBlWzNdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSAqIGxvZ1NoYXBlWzNdXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1dGlsLnNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlID0gZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmdsX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JcIik7XG52YXIgdGVuc29yX3V0aWwgPSByZXF1aXJlKFwiLi4vdGVuc29yX3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbF8xID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIGNvbmNhdF8xID0gcmVxdWlyZShcIi4vY29uY2F0XCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIHJhbmRfMSA9IHJlcXVpcmUoXCIuL3JhbmRcIik7XG52YXIgcmVkdWN0aW9uX29wc18xID0gcmVxdWlyZShcIi4vcmVkdWN0aW9uX29wc1wiKTtcbnZhciBBcnJheU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlPcHMoKSB7XG4gICAgfVxuICAgIEFycmF5T3BzLnRlbnNvciA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoc2hhcGUgIT0gbnVsbCAmJiBpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgaW5mZXJyZWRTaGFwZSwgXCJFcnJvciBjcmVhdGluZyBhIG5ldyBUZW5zb3IuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJJbmZlcnJlZCBzaGFwZSAoXCIgKyBpbmZlcnJlZFNoYXBlICsgXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBcIikgK1xuICAgICAgICAgICAgICAgIChcInByb3ZpZGVkIHNoYXBlIChcIiArIHNoYXBlICsgXCIpLiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5pc1R5cGVkQXJyYXkodmFsdWVzKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZSA9IHNoYXBlIHx8IGluZmVycmVkU2hhcGU7XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMsIGR0eXBlKSB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5zY2FsYXIgPSBmdW5jdGlvbiAodmFsdWUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmICh1dGlsLmlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgYSBuZXcgU2NhbGFyOiB2YWx1ZSBtdXN0IGJlIGEgcHJpbWl0aXZlICcgK1xuICAgICAgICAgICAgICAgICcobnVtYmVyfGJvb2xlYW4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcih2YWx1ZSwgW10sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRlbnNvcjFkID0gZnVuY3Rpb24gKHZhbHVlcywgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvcjFkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIGEgZmxhdC9UeXBlZEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcih2YWx1ZXMsIGluZmVycmVkU2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRlbnNvcjJkID0gZnVuY3Rpb24gKHZhbHVlcywgc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmIChzaGFwZSAhPSBudWxsICYmIHNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdHdvIG51bWJlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDIgJiYgaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yMmQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXSBvciBmbGF0L1R5cGVkQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPT09IDEgJiYgc2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgJyArXG4gICAgICAgICAgICAgICAgJ2FyZSBhIGZsYXQvVHlwZWRBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlID0gc2hhcGUgfHwgaW5mZXJyZWRTaGFwZTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcih2YWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy50ZW5zb3IzZCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICBpZiAoc2hhcGUgIT0gbnVsbCAmJiBzaGFwZS5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHRocmVlIG51bWJlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDMgJiYgaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yM2QoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA9PT0gMSAmJiBzaGFwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvcjNkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCAnICtcbiAgICAgICAgICAgICAgICAnYXJlIGEgZmxhdCBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlID0gc2hhcGUgfHwgaW5mZXJyZWRTaGFwZTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcih2YWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy50ZW5zb3I0ZCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICBpZiAoc2hhcGUgIT0gbnVsbCAmJiBzaGFwZS5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIGZvdXIgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gNCAmJiBpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3I0ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPT09IDEgJiYgc2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgJyArXG4gICAgICAgICAgICAgICAgJ2FyZSBhIGZsYXQgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZSA9IHNoYXBlIHx8IGluZmVycmVkU2hhcGU7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy50ZW5zb3IodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMudGVuc29yNWQgPSBmdW5jdGlvbiAodmFsdWVzLCBzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgaWYgKHNoYXBlICE9IG51bGwgJiYgc2hhcGUubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmaXZlIG51bWJlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDUgJiYgaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yNWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgXFxcbiAgICAgICAgICAgbnVtYmVyW11bXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPT09IDEgJiYgc2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3I1ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgJyArXG4gICAgICAgICAgICAgICAgJ2FyZSBhIGZsYXQgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZSA9IHNoYXBlIHx8IGluZmVycmVkU2hhcGU7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy50ZW5zb3IodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMub25lcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIHZhbHVlcyA9IG1ha2VPbmVzVHlwZWRBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpLCBkdHlwZSk7XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIHZhbHVlcyA9IG1ha2VaZXJvc1R5cGVkQXJyYXkodXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKSwgZHR5cGUpO1xuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2Uoc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuZmlsbCA9IGZ1bmN0aW9uIChzaGFwZSwgdmFsdWUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIHZhciB2YWx1ZXMgPSB1dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoZHR5cGUsIHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSkpO1xuICAgICAgICB2YWx1ZXMuZmlsbCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5vbmVzTGlrZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ29uZXNMaWtlJyk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5vbmVzKHguc2hhcGUsIHguZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuemVyb3NMaWtlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnemVyb3NMaWtlJyk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy56ZXJvcyh4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLmNsb25lID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnY2xvbmUnKTtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkudG9GbG9hdCgpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyBkYXRhSWQ6IHguZGF0YUlkIH0sIHguZHR5cGUpO1xuICAgICAgICB9LCB7IHg6IHggfSwgZGVyKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLmV5ZSA9IGZ1bmN0aW9uIChudW1Sb3dzLCBudW1Db2x1bW5zLCBiYXRjaFNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICBpZiAobnVtQ29sdW1ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBudW1Db2x1bW5zID0gbnVtUm93cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gQXJyYXlPcHMuYnVmZmVyKFtudW1Sb3dzLCBudW1Db2x1bW5zXSwgZHR5cGUpO1xuICAgICAgICB2YXIgbiA9IG51bVJvd3MgPD0gbnVtQ29sdW1ucyA/IG51bVJvd3MgOiBudW1Db2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgYnVmZmVyLnNldCgxLCBpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gYnVmZmVyLnRvVGVuc29yKCkuYXMyRChudW1Sb3dzLCBudW1Db2x1bW5zKTtcbiAgICAgICAgaWYgKGJhdGNoU2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiYXRjaFNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheU9wcy50aWxlKEFycmF5T3BzLmV4cGFuZERpbXMob3V0LCAwKSwgW2JhdGNoU2hhcGVbMF0sIDEsIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJhdGNoU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRpbGUoQXJyYXlPcHMuZXhwYW5kRGltcyhBcnJheU9wcy5leHBhbmREaW1zKG91dCwgMCksIDApLCBbYmF0Y2hTaGFwZVswXSwgYmF0Y2hTaGFwZVsxXSwgMSwgMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXllKCkgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgMUQgYW5kIDJEIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiYmF0Y2hTaGFwZXMsIGJ1dCByZWNlaXZlZCBcIiArIGJhdGNoU2hhcGUubGVuZ3RoICsgXCJELlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5T3BzLnJhbmRvbU5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2LCBkdHlwZSwgc2VlZCkge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIGlmIChkdHlwZSAhPSBudWxsICYmIGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIiArIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZEdhdXNzID0gbmV3IHJhbmRfMS5NUFJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIGR0eXBlLCBmYWxzZSwgc2VlZCk7XG4gICAgICAgIHZhciByZXMgPSBBcnJheU9wcy5idWZmZXIoc2hhcGUsIGR0eXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMudmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXMudmFsdWVzW2ldID0gcmFuZEdhdXNzLm5leHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2LCBkdHlwZSwgc2VlZCkge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIGlmIChkdHlwZSAhPSBudWxsICYmIGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIiArIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZEdhdXNzID0gbmV3IHJhbmRfMS5NUFJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIGR0eXBlLCB0cnVlLCBzZWVkKTtcbiAgICAgICAgdmFyIHJlcyA9IEFycmF5T3BzLmJ1ZmZlcihzaGFwZSwgZHR5cGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy52YWx1ZXNbaV0gPSByYW5kR2F1c3MubmV4dFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy50b1RlbnNvcigpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucmFuZG9tVW5pZm9ybSA9IGZ1bmN0aW9uIChzaGFwZSwgbWludmFsLCBtYXh2YWwsIGR0eXBlKSB7XG4gICAgICAgIGlmIChtaW52YWwgPT09IHZvaWQgMCkgeyBtaW52YWwgPSAwOyB9XG4gICAgICAgIGlmIChtYXh2YWwgPT09IHZvaWQgMCkgeyBtYXh2YWwgPSAxOyB9XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIHZhciByZXMgPSBBcnJheU9wcy5idWZmZXIoc2hhcGUsIGR0eXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMudmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXMudmFsdWVzW2ldID0gdXRpbC5yYW5kVW5pZm9ybShtaW52YWwsIG1heHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy50b1RlbnNvcigpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucmFuZCA9IGZ1bmN0aW9uIChzaGFwZSwgcmFuZEZ1bmN0aW9uLCBkdHlwZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBudWxsO1xuICAgICAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSByYW5kRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2Uoc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMubXVsdGlub21pYWwgPSBmdW5jdGlvbiAobG9naXRzLCBudW1TYW1wbGVzLCBzZWVkLCBub3JtYWxpemVkKSB7XG4gICAgICAgIGlmIChub3JtYWxpemVkID09PSB2b2lkIDApIHsgbm9ybWFsaXplZCA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxvZ2l0czogbG9naXRzIH0sICdtdWx0aW5vbWlhbCcpO1xuICAgICAgICB2YXIgbnVtT3V0Y29tZXMgPSBsb2dpdHMuc2l6ZTtcbiAgICAgICAgdmFyIG9yaWdSYW5rID0gbG9naXRzLnJhbms7XG4gICAgICAgIGlmIChudW1PdXRjb21lcyA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG11bHRpbm9taWFsOiB5b3UgbmVlZCBhdCBsZWFzdCAyIG91dGNvbWVzLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgICAgICAobnVtT3V0Y29tZXMgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnUmFuayA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmsgb2YgcHJvYmFiaWxpdGllcyBtdXN0IGJlIDEgb3IgMiwgYnV0IGlzIFwiICsgb3JpZ1JhbmspO1xuICAgICAgICB9XG4gICAgICAgIHNlZWQgPSBzZWVkIHx8IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHZhciBsb2dpdHMyRCA9IG9yaWdSYW5rID09PSAxID8gbG9naXRzLmFzMkQoMSwgLTEpIDogbG9naXRzO1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tdWx0aW5vbWlhbChsb2dpdHMyRCwgbm9ybWFsaXplZCwgbnVtU2FtcGxlcywgc2VlZCk7IH0sIHsgbG9naXRzMkQ6IGxvZ2l0czJEIH0pO1xuICAgICAgICByZXR1cm4gb3JpZ1JhbmsgPT09IDEgPyByZXMuYXMxRCgpIDogcmVzO1xuICAgIH07XG4gICAgQXJyYXlPcHMub25lSG90ID0gZnVuY3Rpb24gKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICBpZiAob25WYWx1ZSA9PT0gdm9pZCAwKSB7IG9uVmFsdWUgPSAxOyB9XG4gICAgICAgIGlmIChvZmZWYWx1ZSA9PT0gdm9pZCAwKSB7IG9mZlZhbHVlID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydChpbmRpY2VzLmR0eXBlID09PSAnaW50MzInLCAnSW5kaWNlcyBtdXN0IGJlIG9mIGR0eXBlIGBpbnQzMmAnKTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gb25lSG90OiBkZXB0aCBtdXN0IGJlID49MiwgYnV0IGl0IGlzIFwiICsgZGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm9uZUhvdChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpOyB9LCB7IGluZGljZXM6IGluZGljZXMgfSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5mcm9tUGl4ZWxzID0gZnVuY3Rpb24gKHBpeGVscywgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSB2b2lkIDApIHsgbnVtQ2hhbm5lbHMgPSAzOyB9XG4gICAgICAgIGlmIChudW1DaGFubmVscyA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBUZW5zb3Igd2l0aCBtb3JlIHRoYW4gNCBjaGFubmVscyBmcm9tIHBpeGVscy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmZyb21QaXhlbHMocGl4ZWxzLCBudW1DaGFubmVscyk7XG4gICAgfTtcbiAgICBBcnJheU9wcy50b1BpeGVscyA9IGZ1bmN0aW9uIChpbWcsIGNhbnZhcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGhlaWdodCwgd2lkdGgsIGRlcHRoLCBtaW5UZW5zb3IsIG1heFRlbnNvciwgbWluLCBtYXgsIGRhdGEsIG11bHRpcGxpZXIsIGJ5dGVzLCBpLCByLCBnLCBiLCBhLCBqLCBjdHgsIGltYWdlRGF0YTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGltZzogaW1nIH0sICd0b1BpeGVscycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltZy5yYW5rICE9PSAyICYmIGltZy5yYW5rICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9QaXhlbHMgb25seSBzdXBwb3J0cyByYW5rIDIgb3IgMyB0ZW5zb3JzLCBnb3QgcmFuayBcIiArIGltZy5yYW5rICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBpbWcuc2hhcGUuc2xpY2UoMCwgMiksIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBpbWcucmFuayA9PT0gMiA/IDEgOiBpbWcuc2hhcGVbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPiA0IHx8IGRlcHRoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9QaXhlbHMgb25seSBzdXBwb3J0cyBkZXB0aCBvZiBzaXplIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiMSwgMyBvciA0IGJ1dCBnb3QgXCIgKyBkZXB0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluVGVuc29yID0gaW1nLm1pbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VGVuc29yID0gaW1nLm1heCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtaW5UZW5zb3IuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gKF9iLnNlbnQoKSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1heFRlbnNvci5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSAoX2Iuc2VudCgpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblRlbnNvci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhUZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltZy5kdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA8IDAgfHwgbWF4ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgdmFsdWVzIGZvciBhIGZsb2F0MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInJhbmdlIFswIC0gMV0gYnV0IGdvdCByYW5nZSBbXCIgKyBtaW4gKyBcIiAtIFwiICsgbWF4ICsgXCJdLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW1nLmR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA8IDAgfHwgbWF4ID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgaW50MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInJhbmdlIFswIC0gMjU1XSBidXQgZ290IHJhbmdlIFtcIiArIG1pbiArIFwiIC0gXCIgKyBtYXggKyBcIl0uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIGZvciB0b1BpeGVsczogXCIgKyBpbWcuZHR5cGUgKyBcIi5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFBsZWFzZSB1c2UgZmxvYXQzMiBvciBpbnQzMiB0ZW5zb3JzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgaW1nLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gaW1nLmR0eXBlID09PSAnZmxvYXQzMicgPyAyNTUgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoZWlnaHQgKiB3aWR0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHZvaWQgMCwgZyA9IHZvaWQgMCwgYiA9IHZvaWQgMCwgYSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IGRhdGFbaV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gZGF0YVtpXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBkYXRhW2ldICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IGRhdGFbaSAqIDNdICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGRhdGFbaSAqIDMgKyAxXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBkYXRhW2kgKiAzICsgMl0gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gZGF0YVtpICogNF0gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gZGF0YVtpICogNCArIDFdICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGRhdGFbaSAqIDQgKyAyXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBkYXRhW2kgKiA0ICsgM10gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gaSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaiArIDBdID0gTWF0aC5yb3VuZChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tqICsgMV0gPSBNYXRoLnJvdW5kKGcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2ogKyAyXSA9IE1hdGgucm91bmQoYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaiArIDNdID0gTWF0aC5yb3VuZChhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW52YXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShieXRlcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBieXRlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJyYXlPcHMucmVzaGFwZSA9IGZ1bmN0aW9uICh4LCBzaGFwZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdyZXNoYXBlJyk7XG4gICAgICAgIHNoYXBlID0gdXRpbC5pbmZlckZyb21JbXBsaWNpdFNoYXBlKHNoYXBlLCB4LnNpemUpO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnNpemUgPT09IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSksICduZXcgc2hhcGUgYW5kIG9sZCBzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLicpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkucmVzaGFwZSh4LnNoYXBlKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5yZXNoYXBlKHgsIHNoYXBlKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuc3F1ZWV6ZSA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3NxdWVlemUnKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnJlc2hhcGUoeCwgdXRpbC5zcXVlZXplU2hhcGUoeC5zaGFwZSwgYXhpcykubmV3U2hhcGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuY2FzdCA9IGZ1bmN0aW9uICh4LCBkdHlwZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdjYXN0Jyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5jbG9uZSgpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNhc3QoeCwgZHR5cGUpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBBcnJheU9wcy50aWxlID0gZnVuY3Rpb24gKHgsIHJlcHMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAndGlsZScpO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IHJlcHMubGVuZ3RoLCBcIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIiArIHgucmFuayArIFwiIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggbGVuZ3RoIG9mIHJlcHMgXCIgKyByZXBzICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJYID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB4R3JhZCA9IEFycmF5T3BzLnplcm9zTGlrZSh4KTtcbiAgICAgICAgICAgICAgICBpZiAoeC5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwc1swXTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4R3JhZCA9IHhHcmFkLmFkZChkeS5zbGljZShbaSAqIHguc2hhcGVbMF1dLCBbeC5zaGFwZVswXV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBzWzBdOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwc1sxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEdyYWQgPSB4R3JhZC5hZGQoZHkuc2xpY2UoW2kgKiB4LnNoYXBlWzBdLCBqICogeC5zaGFwZVsxXV0sIFt4LnNoYXBlWzBdLCB4LnNoYXBlWzFdXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcHNbMF07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBzWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJlcHNbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4R3JhZCA9IHhHcmFkLmFkZChkeS5zbGljZShbaSAqIHguc2hhcGVbMF0sIGogKiB4LnNoYXBlWzFdLCBrICogeC5zaGFwZVsyXV0sIFt4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBzWzBdOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwc1sxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByZXBzWzJdOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCByZXBzWzNdOyArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhHcmFkID0geEdyYWQuYWRkKGR5LnNsaWNlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICogeC5zaGFwZVswXSwgaiAqIHguc2hhcGVbMV0sIGsgKiB4LnNoYXBlWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgKiB4LnNoYXBlWzNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCBbeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSwgeC5zaGFwZVszXV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhZGllbnQgZm9yIHRpbGUgb3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgcmFuay1cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeC5yYW5rICsgXCIgdGVuc29ycyB5ZXQuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhHcmFkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGRlclggfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQudGlsZSh4LCByZXBzKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuZ2F0aGVyID0gZnVuY3Rpb24gKHgsIGluZGljZXMsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4LCBpbmRpY2VzOiBpbmRpY2VzIH0sICdnYXRoZXInKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5kaWNlcy5kdHlwZSA9PT0gJ2ludDMyJywgJ0luZGljZXMgbXVzdCBiZSBvZiBkdHlwZSBgaW50MzJgJyk7XG4gICAgICAgIGF4aXMgPSBheGlzX3V0aWxfMS5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKVswXTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJYID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLnVuc29ydGVkU2VnbWVudFN1bShkeSwgaW5kaWNlcywgeC5zaGFwZVtheGlzXSwgYXhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZGVyWCB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5nYXRoZXIoeCwgaW5kaWNlcywgYXhpcyk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnBhZDFkID0gZnVuY3Rpb24gKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIGlmIChjb25zdGFudFZhbHVlID09PSB2b2lkIDApIHsgY29uc3RhbnRWYWx1ZSA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQocGFkZGluZ3MubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIuJyk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5wYWQoeCwgW3BhZGRpbmdzXSwgY29uc3RhbnRWYWx1ZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5wYWQyZCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICBpZiAoY29uc3RhbnRWYWx1ZSA9PT0gdm9pZCAwKSB7IGNvbnN0YW50VmFsdWUgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHBhZGRpbmdzLmxlbmd0aCA9PT0gMiAmJiBwYWRkaW5nc1swXS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhZGRpbmdzWzFdLmxlbmd0aCA9PT0gMiwgJ0ludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guJyk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5wYWQoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucGFkM2QgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnN0YW50VmFsdWUgPT09IHZvaWQgMCkgeyBjb25zdGFudFZhbHVlID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydChwYWRkaW5ncy5sZW5ndGggPT09IDMgJiYgcGFkZGluZ3NbMF0ubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICBwYWRkaW5nc1sxXS5sZW5ndGggPT09IDIgJiYgcGFkZGluZ3NbMl0ubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC4nKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnBhZCh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5wYWQ0ZCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICBpZiAoY29uc3RhbnRWYWx1ZSA9PT0gdm9pZCAwKSB7IGNvbnN0YW50VmFsdWUgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHBhZGRpbmdzLmxlbmd0aCA9PT0gNCAmJiBwYWRkaW5nc1swXS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhZGRpbmdzWzFdLmxlbmd0aCA9PT0gMiAmJiBwYWRkaW5nc1syXS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhZGRpbmdzWzNdLmxlbmd0aCA9PT0gMiwgJ0ludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guJyk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5wYWQoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucGFkID0gZnVuY3Rpb24gKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIGlmIChjb25zdGFudFZhbHVlID09PSB2b2lkIDApIHsgY29uc3RhbnRWYWx1ZSA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAncGFkJyk7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkKHNjYWxhcikgaXMgbm90IGRlZmluZWQuIFBhc3Mgbm9uLXNjYWxhciB0byBwYWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVnaW4gPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBbMF07IH0pO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuc2xpY2UoYmVnaW4sIHguc2hhcGUpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnBhZCh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnN0YWNrID0gZnVuY3Rpb24gKHRlbnNvcnMsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB0ZW5zb3JzOiB0ZW5zb3JzIH0sICdzdGFjaycpO1xuICAgICAgICB1dGlsLmFzc2VydCh0ZW5zb3JzLmxlbmd0aCA+PSAxLCAnUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIHRmLnN0YWNrJyk7XG4gICAgICAgIGlmICh0ZW5zb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbnNvcnNbMF0uZXhwYW5kRGltcyhheGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuayA9IHRlbnNvcnNbMF0ucmFuaztcbiAgICAgICAgdmFyIHNoYXBlID0gdGVuc29yc1swXS5zaGFwZTtcbiAgICAgICAgdmFyIGR0eXBlID0gdGVuc29yc1swXS5kdHlwZTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYXhpcyA8PSByYW5rLCAnQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvcicpO1xuICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goc2hhcGUsIHQuc2hhcGUsICdBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIHNoYXBlcycpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGVuc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChkdHlwZSA9PT0gdC5kdHlwZSwgJ0FsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgZHR5cGVzJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZXhwYW5kZWRUZW5zb3JzID0gdGVuc29ycy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZXhwYW5kRGltcyhheGlzKTsgfSk7XG4gICAgICAgIHJldHVybiBjb25jYXRfMS5Db25jYXRPcHMuY29uY2F0KGV4cGFuZGVkVGVuc29ycywgYXhpcyk7XG4gICAgfTtcbiAgICBBcnJheU9wcy51bnN0YWNrID0gZnVuY3Rpb24gKHZhbHVlLCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgdmFyIG51bSA9IHZhbHVlLnNoYXBlW2F4aXNdO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBBcnJheSh2YWx1ZS5yYW5rIC0gMSkuZmlsbCgwKTtcbiAgICAgICAgdmFyIG91dEluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5yYW5rOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBheGlzKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVbb3V0SW5kZXhdID0gdmFsdWUuc2hhcGVbaV07XG4gICAgICAgICAgICAgICAgb3V0SW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3BsaXRTaXplcztcbiAgICAgICAgc3BsaXRTaXplcyA9IEFycmF5KG51bSkuZmlsbCgxKTtcbiAgICAgICAgdmFyIGJlZ2luID0gQXJyYXkodmFsdWUucmFuaykuZmlsbCgwKTtcbiAgICAgICAgdmFyIHNpemUgPSB2YWx1ZS5zaGFwZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gc3BsaXRTaXplcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHNpemVbYXhpc10gPSBzO1xuICAgICAgICAgICAgdmFyIHNsaWNlID0gdmFsdWUuc2xpY2UoYmVnaW4sIHNpemUpO1xuICAgICAgICAgICAgYmVnaW5bYXhpc10gKz0gcztcbiAgICAgICAgICAgIHJldHVybiBzbGljZS5yZXNoYXBlKG91dHB1dFNoYXBlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5zcGxpdCA9IGZ1bmN0aW9uICh4LCBudW1PclNpemVTcGxpdHMsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdzcGxpdCcpO1xuICAgICAgICBheGlzID0gYXhpc191dGlsXzEucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSlbMF07XG4gICAgICAgIHZhciBzcGxpdFNpemVzO1xuICAgICAgICBpZiAodHlwZW9mIChudW1PclNpemVTcGxpdHMpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoeC5zaGFwZVtheGlzXSAlIG51bU9yU2l6ZVNwbGl0cyA9PT0gMCwgJ051bWJlciBvZiBzcGxpdHMgbXVzdCBldmVubHkgZGl2aWRlIHRoZSBheGlzLicpO1xuICAgICAgICAgICAgc3BsaXRTaXplcyA9IEFycmF5KG51bU9yU2l6ZVNwbGl0cykuZmlsbCh4LnNoYXBlW2F4aXNdIC8gbnVtT3JTaXplU3BsaXRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHguc2hhcGVbYXhpc10gPT09IG51bU9yU2l6ZVNwbGl0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9KSwgJ1RoZSBzdW0gb2Ygc2l6ZXMgbXVzdCBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgYXhpcyBkaW1lbnNpb24uJyk7XG4gICAgICAgICAgICBzcGxpdFNpemVzID0gbnVtT3JTaXplU3BsaXRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWdpbiA9IEFycmF5KHgucmFuaykuZmlsbCgwKTtcbiAgICAgICAgdmFyIHNpemUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBzcGxpdFNpemVzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgc2l6ZVtheGlzXSA9IHM7XG4gICAgICAgICAgICB2YXIgc2xpY2UgPSB4LnNsaWNlKGJlZ2luLCBzaXplKTtcbiAgICAgICAgICAgIGJlZ2luW2F4aXNdICs9IHM7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJyYXlPcHMuY3Vtc3VtID0gZnVuY3Rpb24gKHgsIGF4aXMsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSkge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIGlmIChleGNsdXNpdmUgPT09IHZvaWQgMCkgeyBleGNsdXNpdmUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAocmV2ZXJzZSA9PT0gdm9pZCAwKSB7IHJldmVyc2UgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdjdW1zdW0nKTtcbiAgICAgICAgYXhpcyA9IGF4aXMgfCAwO1xuICAgICAgICB2YXIgcGVybXV0YXRpb24gPSBheGlzX3V0aWxfMS5nZXRBeGVzUGVybXV0YXRpb24oW2F4aXNdLCB4LnJhbmspO1xuICAgICAgICB2YXIgcGVybXV0ZWRYID0geDtcbiAgICAgICAgaWYgKHBlcm11dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBlcm11dGVkWCA9IHgudHJhbnNwb3NlKHBlcm11dGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGVybXV0ZWRBeGlzID0gYXhpc191dGlsXzEuZ2V0SW5uZXJNb3N0QXhlcygxLCB4LnJhbmspWzBdO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGVybXV0ZWRYOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5jdW1zdW0oYXhpcywgZXhjbHVzaXZlLCAhcmV2ZXJzZSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5jdW1zdW0ocGVybXV0ZWRYLCBwZXJtdXRlZEF4aXMsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSk7IH0sIHsgcGVybXV0ZWRYOiBwZXJtdXRlZFggfSwgZ3JhZCk7XG4gICAgICAgIGlmIChwZXJtdXRhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyYW5zcG9zZShwZXJtdXRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXlPcHMuZXhwYW5kRGltcyA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnZXhwYW5kRGltcycpO1xuICAgICAgICB1dGlsLmFzc2VydChheGlzIDw9IHgucmFuaywgJ0F4aXMgbXVzdCBiZSA8PSByYW5rIG9mIHRoZSB0ZW5zb3InKTtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0geC5zaGFwZS5zbGljZSgpO1xuICAgICAgICBuZXdTaGFwZS5zcGxpY2UoYXhpcywgMCwgMSk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5yZXNoYXBlKHgsIG5ld1NoYXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLmxpbnNwYWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBzdG9wLCBudW0pIHtcbiAgICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVxdWVzdCB6ZXJvIHNhbXBsZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gKG51bSAtIDEpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbWFrZVplcm9zVHlwZWRBcnJheShudW0sICdmbG9hdDMyJyk7XG4gICAgICAgIHZhbHVlc1swXSA9IHN0YXJ0O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWVzW2kgLSAxXSArIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcjFkKHZhbHVlcywgJ2Zsb2F0MzInKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBzdG9wLCBzdGVwLCBkdHlwZSkge1xuICAgICAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7IHN0ZXAgPSAxOyB9XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGEgc3RlcCBvZiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhbWVTdGFydFN0b3AgPSBzdGFydCA9PT0gc3RvcDtcbiAgICAgICAgdmFyIGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCA9IHN0YXJ0IDwgc3RvcCAmJiBzdGVwIDwgMDtcbiAgICAgICAgdmFyIGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCA9IHN0b3AgPCBzdGFydCAmJiBzdGVwID4gMTtcbiAgICAgICAgaWYgKHNhbWVTdGFydFN0b3AgfHwgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwIHx8XG4gICAgICAgICAgICBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheU9wcy56ZXJvcyhbMF0sIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtRWxlbWVudHMgPSBNYXRoLmFicyhNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBtYWtlWmVyb3NUeXBlZEFycmF5KG51bUVsZW1lbnRzLCBkdHlwZSk7XG4gICAgICAgIGlmIChzdG9wIDwgc3RhcnQgJiYgc3RlcCA9PT0gMSkge1xuICAgICAgICAgICAgc3RlcCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1swXSA9IHN0YXJ0O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWVzW2kgLSAxXSArIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcjFkKHZhbHVlcywgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuYnVmZmVyID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIHJldHVybiBuZXcgdGVuc29yXzEuVGVuc29yQnVmZmVyKHNoYXBlLCBkdHlwZSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnByaW50ID0gZnVuY3Rpb24gKHgsIHZlcmJvc2UpIHtcbiAgICAgICAgaWYgKHZlcmJvc2UgPT09IHZvaWQgMCkgeyB2ZXJib3NlID0gZmFsc2U7IH1cbiAgICAgICAgY29uc29sZS5sb2codGVuc29yX3V0aWwudGVuc29yVG9TdHJpbmcoeCwgdmVyYm9zZSkpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInRlbnNvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwic2NhbGFyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJ0ZW5zb3IxZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwidGVuc29yMmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInRlbnNvcjNkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJ0ZW5zb3I0ZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwidGVuc29yNWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwib25lc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJ6ZXJvc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJmaWxsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcIm9uZXNMaWtlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInplcm9zTGlrZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJjbG9uZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJleWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwicmFuZG9tTm9ybWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInRydW5jYXRlZE5vcm1hbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJyYW5kb21Vbmlmb3JtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJyYW5kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJtdWx0aW5vbWlhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJvbmVIb3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwiZnJvbVBpeGVsc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1Zpc3VhbGl6YXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwidG9QaXhlbHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1RyYW5zZm9ybWF0aW9ucycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInJlc2hhcGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1RyYW5zZm9ybWF0aW9ucycgfSlcbiAgICBdLCBBcnJheU9wcywgXCJzcXVlZXplXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdUcmFuc2Zvcm1hdGlvbnMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJjYXN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwidGlsZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnU2xpY2luZyBhbmQgSm9pbmluZycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImdhdGhlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnVHJhbnNmb3JtYXRpb25zJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwicGFkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwic3RhY2tcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJ1bnN0YWNrXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwic3BsaXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1NjYW4nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwiY3Vtc3VtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdUcmFuc2Zvcm1hdGlvbnMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJleHBhbmREaW1zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb24sXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcImxpbnNwYWNlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb24sXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInJhbmdlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJidWZmZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInByaW50XCIsIG51bGwpO1xuICAgIHJldHVybiBBcnJheU9wcztcbn0oKSk7XG5leHBvcnRzLkFycmF5T3BzID0gQXJyYXlPcHM7XG5mdW5jdGlvbiBtYWtlWmVyb3NUeXBlZEFycmF5KHNpemUsIGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09IG51bGwgfHwgZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlICQge2R0eXBlfVwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlT25lc1R5cGVkQXJyYXkoc2l6ZSwgZHR5cGUpIHtcbiAgICB2YXIgYXJyYXkgPSBtYWtlWmVyb3NUeXBlZEFycmF5KHNpemUsIGR0eXBlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2ldID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gdG9UeXBlZEFycmF5KGEsIGR0eXBlKSB7XG4gICAgaWYgKG5vQ29udmVyc2lvbk5lZWRlZChhLCBkdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGEgPSB1dGlsLmZsYXR0ZW4oYSk7XG4gICAgfVxuICAgIHJldHVybiB1dGlsLmNvcHlUeXBlZEFycmF5KGEsIGR0eXBlKTtcbn1cbmZ1bmN0aW9uIG5vQ29udmVyc2lvbk5lZWRlZChhLCBkdHlwZSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSAmJiBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB8fFxuICAgICAgICAoYSBpbnN0YW5jZW9mIEludDMyQXJyYXkgJiYgZHR5cGUgPT09ICdpbnQzMicpIHx8XG4gICAgICAgIChhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBkdHlwZSA9PT0gJ2Jvb2wnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5X29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBheGVzQXJlSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChheGVzW2F4ZXMubGVuZ3RoIC0gaSAtIDFdICE9PSByYW5rIC0gMSAtIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYXhlc0FyZUlubmVyTW9zdERpbXMgPSBheGVzQXJlSW5uZXJNb3N0RGltcztcbmZ1bmN0aW9uIGNvbWJpbmVMb2NhdGlvbnMob3V0cHV0TG9jLCByZWR1Y2VMb2MsIGF4ZXMpIHtcbiAgICB2YXIgcmFuayA9IG91dHB1dExvYy5sZW5ndGggKyByZWR1Y2VMb2MubGVuZ3RoO1xuICAgIHZhciBsb2MgPSBbXTtcbiAgICB2YXIgb3V0SWR4ID0gMDtcbiAgICB2YXIgcmVkdWNlSWR4ID0gMDtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBsb2MucHVzaChvdXRwdXRMb2Nbb3V0SWR4KytdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5wdXNoKHJlZHVjZUxvY1tyZWR1Y2VJZHgrK10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2M7XG59XG5leHBvcnRzLmNvbWJpbmVMb2NhdGlvbnMgPSBjb21iaW5lTG9jYXRpb25zO1xuZnVuY3Rpb24gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhhU2hhcGUsIGF4ZXMpIHtcbiAgICB2YXIgb3V0U2hhcGUgPSBbXTtcbiAgICB2YXIgcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgICAgICAgb3V0U2hhcGUucHVzaChhU2hhcGVbZGltXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlZHVjZVNoYXBlID0gYXhlcy5tYXAoZnVuY3Rpb24gKGRpbSkgeyByZXR1cm4gYVNoYXBlW2RpbV07IH0pO1xuICAgIHJldHVybiBbb3V0U2hhcGUsIHJlZHVjZVNoYXBlXTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyA9IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXM7XG5mdW5jdGlvbiBleHBhbmRTaGFwZVRvS2VlcERpbShzaGFwZSwgYXhlcykge1xuICAgIHZhciByZWR1Y2VTdWJTaGFwZSA9IGF4ZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiAxOyB9KTtcbiAgICByZXR1cm4gY29tYmluZUxvY2F0aW9ucyhzaGFwZSwgcmVkdWNlU3ViU2hhcGUsIGF4ZXMpO1xufVxuZXhwb3J0cy5leHBhbmRTaGFwZVRvS2VlcERpbSA9IGV4cGFuZFNoYXBlVG9LZWVwRGltO1xuZnVuY3Rpb24gcGFyc2VBeGlzUGFyYW0oYXhpcywgc2hhcGUpIHtcbiAgICB2YXIgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBheGlzID0gYXhpcyA9PSBudWxsID8gc2hhcGUubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBpOyB9KSA6IFtdLmNvbmNhdChheGlzKTtcbiAgICB1dGlsLmFzc2VydChheGlzLmV2ZXJ5KGZ1bmN0aW9uIChheCkgeyByZXR1cm4gYXggPj0gLXJhbmsgJiYgYXggPCByYW5rOyB9KSwgXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLVwiICsgcmFuayArIFwiLCBcIiArIHJhbmsgKyBcIikgYnV0IFwiICtcbiAgICAgICAgKFwiZ290IGF4aXMgXCIgKyBheGlzKSk7XG4gICAgdXRpbC5hc3NlcnQoYXhpcy5ldmVyeShmdW5jdGlvbiAoYXgpIHsgcmV0dXJuIHV0aWwuaXNJbnQoYXgpOyB9KSwgXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgXCIgK1xuICAgICAgICAoXCJnb3QgYXhpcyBcIiArIGF4aXMpKTtcbiAgICByZXR1cm4gYXhpcy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgPCAwID8gcmFuayArIGEgOiBhOyB9KTtcbn1cbmV4cG9ydHMucGFyc2VBeGlzUGFyYW0gPSBwYXJzZUF4aXNQYXJhbTtcbmZ1bmN0aW9uIGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKG1zZywgYXhlcywgcmFuaykge1xuICAgIHV0aWwuYXNzZXJ0KGF4ZXNBcmVJbm5lck1vc3REaW1zKGF4ZXMsIHJhbmspLCBtc2cgKyBcIiBzdXBwb3J0cyBvbmx5IGlubmVyLW1vc3QgYXhlcyBmb3Igbm93LiBcIiArXG4gICAgICAgIChcIkdvdCBheGVzIFwiICsgYXhlcyArIFwiIGFuZCByYW5rLVwiICsgcmFuayArIFwiIGlucHV0LlwiKSk7XG59XG5leHBvcnRzLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zID0gYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXM7XG5mdW5jdGlvbiBnZXRBeGVzUGVybXV0YXRpb24oYXhlcywgcmFuaykge1xuICAgIGlmIChheGVzQXJlSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBheGVzLmZvckVhY2goZnVuY3Rpb24gKGF4aXMpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGF4aXMpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRBeGVzUGVybXV0YXRpb24gPSBnZXRBeGVzUGVybXV0YXRpb247XG5mdW5jdGlvbiBnZXRVbmRvQXhlc1Blcm11dGF0aW9uKGF4ZXMpIHtcbiAgICByZXR1cm4gYXhlcy5tYXAoZnVuY3Rpb24gKGF4aXMsIGkpIHsgcmV0dXJuIFtpLCBheGlzXTsgfSlcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMV0gLSBiWzFdOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4WzBdOyB9KTtcbn1cbmV4cG9ydHMuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbiA9IGdldFVuZG9BeGVzUGVybXV0YXRpb247XG5mdW5jdGlvbiBnZXRJbm5lck1vc3RBeGVzKG51bUF4ZXMsIHJhbmspIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHJhbmsgLSBudW1BeGVzOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5nZXRJbm5lck1vc3RBeGVzID0gZ2V0SW5uZXJNb3N0QXhlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF4aXNfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXJyYXlfb3BzXzEgPSByZXF1aXJlKFwiLi9hcnJheV9vcHNcIik7XG52YXIgYnJvYWRjYXN0X3V0aWxfMSA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIEJhdGNoTm9ybU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmF0Y2hOb3JtT3BzKCkge1xuICAgIH1cbiAgICBCYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uMmQgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtZWFuLnJhbmsgPT09IDIgfHwgbWVhbi5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBtZWFuIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBtZWFuLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJpYW5jZS5yYW5rID09PSAyIHx8IHZhcmlhbmNlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyB2YXJpYW5jZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHNjYWxlLnJhbmsgPT09IDIgfHwgc2NhbGUucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogc2NhbGUgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBzY2FsZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KG9mZnNldC5yYW5rID09PSAyIHx8IG9mZnNldC5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBvZmZzZXQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24oeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCk7XG4gICAgfTtcbiAgICBCYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uM2QgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtZWFuLnJhbmsgPT09IDMgfHwgbWVhbi5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBtZWFuIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBtZWFuLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJpYW5jZS5yYW5rID09PSAzIHx8IHZhcmlhbmNlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyB2YXJpYW5jZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHNjYWxlLnJhbmsgPT09IDMgfHwgc2NhbGUucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogc2NhbGUgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBzY2FsZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KG9mZnNldC5yYW5rID09PSAzIHx8IG9mZnNldC5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBvZmZzZXQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24oeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCk7XG4gICAgfTtcbiAgICBCYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uNGQgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtZWFuLnJhbmsgPT09IDQgfHwgbWVhbi5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiBtZWFuIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBtZWFuLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJpYW5jZS5yYW5rID09PSA0IHx8IHZhcmlhbmNlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyB2YXJpYW5jZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHNjYWxlLnJhbmsgPT09IDQgfHwgc2NhbGUucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogc2NhbGUgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBzY2FsZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KG9mZnNldC5yYW5rID09PSA0IHx8IG9mZnNldC5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiBvZmZzZXQgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBvZmZzZXQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24oeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCk7XG4gICAgfTtcbiAgICBCYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uID0gZnVuY3Rpb24gKHgsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHZhcmlhbmNlRXBzaWxvbiA9PT0gdm9pZCAwKSB7IHZhcmlhbmNlRXBzaWxvbiA9IC4wMDE7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCwgbWVhbjogbWVhbiwgdmFyaWFuY2U6IHZhcmlhbmNlIH0sICdiYXRjaE5vcm1hbGl6YXRpb24nKTtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHNjYWxlOiBzY2FsZSB9LCAnYmF0Y2hOb3JtYWxpemF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBvZmZzZXQ6IG9mZnNldCB9LCAnYmF0Y2hOb3JtYWxpemF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQobWVhbi5yYW5rID09PSB2YXJpYW5jZS5yYW5rLCAnQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCB2YXJpYW5jZSB0byBoYXZlICcgK1xuICAgICAgICAgICAgJ2VxdWFsIHJhbmtzLicpO1xuICAgICAgICB1dGlsLmFzc2VydChvZmZzZXQgPT0gbnVsbCB8fCBtZWFuLnJhbmsgPT09IG9mZnNldC5yYW5rLCAnQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBvZmZzZXQgdG8gaGF2ZSAnICtcbiAgICAgICAgICAgICdlcXVhbCByYW5rcy4nKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUgPT0gbnVsbCB8fCBtZWFuLnJhbmsgPT09IHNjYWxlLnJhbmssICdCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHNjYWxlIHRvIGhhdmUgJyArXG4gICAgICAgICAgICAnZXF1YWwgcmFua3MuJyk7XG4gICAgICAgIHZhciB4NEQ7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDAgfHwgeC5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgMSwgMSwgeC5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCAxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHg0RCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHNjYWxlVmFsdWUgPSBzY2FsZSA9PSBudWxsID8gYXJyYXlfb3BzXzEuQXJyYXlPcHMuc2NhbGFyKDEpIDogc2NhbGU7XG4gICAgICAgICAgICB2YXIgcmVkdWN0aW9uQXhlcyA9IGJyb2FkY2FzdF91dGlsXzEuZ2V0UmVkdWN0aW9uQXhlcyhtZWFuLnNoYXBlLCB4NEQuc2hhcGUpO1xuICAgICAgICAgICAgdmFyIHRpbGVTaGFwZSA9IFtdO1xuICAgICAgICAgICAgaWYgKG1lYW4ucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeDRELnNoYXBlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlU2hhcGUucHVzaCh4NEQuc2hhcGVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aWxlU2hhcGUucHVzaCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4TWludXNNZWFuID0geC5zdWIobWVhbik7XG4gICAgICAgICAgICB2YXIgZHlUaW1lc1NjYWxlVmFsdWUgPSBkeS5tdWwoc2NhbGVWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgb25lT3ZlclNxcnRWYXJpYW5jZSA9IG9wc18xLnJzcXJ0KHZhcmlhbmNlLmFkZChhcnJheV9vcHNfMS5BcnJheU9wcy5zY2FsYXIodmFyaWFuY2VFcHNpbG9uKSkpO1xuICAgICAgICAgICAgdmFyIG1pbnVzSGFsZlJDdWJlID0gb25lT3ZlclNxcnRWYXJpYW5jZS5tdWwob25lT3ZlclNxcnRWYXJpYW5jZSlcbiAgICAgICAgICAgICAgICAubXVsKG9uZU92ZXJTcXJ0VmFyaWFuY2UpXG4gICAgICAgICAgICAgICAgLm11bChhcnJheV9vcHNfMS5BcnJheU9wcy5zY2FsYXIoLTAuNSkpO1xuICAgICAgICAgICAgdmFyIGRlclggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lYW4ucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tdWwoYXJyYXlfb3BzXzEuQXJyYXlPcHMudGlsZShvbmVPdmVyU3FydFZhcmlhbmNlLmFzNEQoMSwgMSwgMSwgbWVhbi5zaGFwZVswXSksIHRpbGVTaGFwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubXVsKHNjYWxlVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVzaGFwZSh4LnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeS5tdWwob25lT3ZlclNxcnRWYXJpYW5jZSkubXVsKHNjYWxlVmFsdWUpLnJlc2hhcGUoeC5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJNZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBtZWFuRGVyID0gb25lT3ZlclNxcnRWYXJpYW5jZS5tdWwoYXJyYXlfb3BzXzEuQXJyYXlPcHMuc2NhbGFyKC0xKSkubXVsKGR5VGltZXNTY2FsZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWVhbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lYW5EZXIgPSBtZWFuRGVyLnN1bShyZWR1Y3Rpb25BeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lYW5EZXIucmVzaGFwZShtZWFuLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyVmFyaWFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhbmNlRGVyID0gbWludXNIYWxmUkN1YmUubXVsKHhNaW51c01lYW4pLm11bChkeVRpbWVzU2NhbGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lYW4ucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYW5jZURlciA9IHZhcmlhbmNlRGVyLnN1bShyZWR1Y3Rpb25BeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhbmNlRGVyLnJlc2hhcGUobWVhbi5zaGFwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRlclNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB4TWludXNNZWFuMlRpbWVzUnNxcnQgPSB4TWludXNNZWFuLm11bChvbmVPdmVyU3FydFZhcmlhbmNlKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVEZXIgPSBkeS5tdWwoeE1pbnVzTWVhbjJUaW1lc1JzcXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAobWVhbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlRGVyID0gc2NhbGVEZXIuc3VtKHJlZHVjdGlvbkF4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGVEZXIucmVzaGFwZShtZWFuLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXREZXIgPSBkeTtcbiAgICAgICAgICAgICAgICBpZiAobWVhbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldERlciA9IG9mZnNldERlci5zdW0ocmVkdWN0aW9uQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXREZXIucmVzaGFwZShtZWFuLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGRlclgsXG4gICAgICAgICAgICAgICAgbWVhbjogZGVyTWVhbixcbiAgICAgICAgICAgICAgICB2YXJpYW5jZTogZGVyVmFyaWFuY2UsXG4gICAgICAgICAgICAgICAgc2NhbGU6IGRlclNjYWxlLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZGVyT2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5iYXRjaE5vcm1hbGl6YXRpb24oeDRELCBiYXRjaG5vcm1SZXNoYXBlNEQobWVhbiksIGJhdGNobm9ybVJlc2hhcGU0RCh2YXJpYW5jZSksIHZhcmlhbmNlRXBzaWxvbiwgYmF0Y2hub3JtUmVzaGFwZTREKHNjYWxlKSwgYmF0Y2hub3JtUmVzaGFwZTREKG9mZnNldCkpOyB9LCB7IHg6IHgsIG1lYW46IG1lYW4sIHZhcmlhbmNlOiB2YXJpYW5jZSwgc2NhbGU6IHNjYWxlLCBvZmZzZXQ6IG9mZnNldCB9LCBkZXIpO1xuICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUoeC5zaGFwZSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmF0Y2hOb3JtT3BzLCBcImJhdGNoTm9ybWFsaXphdGlvbjJkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCYXRjaE5vcm1PcHMsIFwiYmF0Y2hOb3JtYWxpemF0aW9uM2RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJhdGNoTm9ybU9wcywgXCJiYXRjaE5vcm1hbGl6YXRpb240ZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTm9ybWFsaXphdGlvbicgfSlcbiAgICBdLCBCYXRjaE5vcm1PcHMsIFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIsIG51bGwpO1xuICAgIHJldHVybiBCYXRjaE5vcm1PcHM7XG59KCkpO1xuZXhwb3J0cy5CYXRjaE5vcm1PcHMgPSBCYXRjaE5vcm1PcHM7XG5mdW5jdGlvbiBiYXRjaG5vcm1SZXNoYXBlNEQoeCkge1xuICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHguYXMxRCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh4LnJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4geC5hczREKDEsIDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaG5vcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBCaW5hcnlPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wcygpIHtcbiAgICB9XG4gICAgQmluYXJ5T3BzLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2FkZCcpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGEuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGIuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShiLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmFkZChhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0sIGRlcik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMuYWRkU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gYWRkU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuYWRkKGIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLnN1YiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ3N1YicpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGEuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGIuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMubmVnKCkucmVzaGFwZShiLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnN1YnRyYWN0KGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5zdWJTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBzdWJTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5zdWIoYik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMucG93ID0gZnVuY3Rpb24gKGJhc2UsIGV4cCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBiYXNlOiBiYXNlLCBleHA6IGV4cCB9LCAncG93Jyk7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGJhc2Uuc2hhcGUsIGV4cC5zaGFwZSk7XG4gICAgICAgIGJhc2UgPSBiYXNlLmNhc3QodHlwZXNfMS51cGNhc3RUeXBlKGJhc2UuZHR5cGUsIGV4cC5kdHlwZSkpO1xuICAgICAgICBleHAgPSBleHAuY2FzdCh0eXBlc18xLnVwY2FzdFR5cGUoYmFzZS5kdHlwZSwgZXhwLmR0eXBlKSk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5LCBzYXZlZCkge1xuICAgICAgICAgICAgdmFyIHkgPSBzYXZlZFswXTtcbiAgICAgICAgICAgIHZhciBkZXJCYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5tdWwoZXhwLnRvRmxvYXQoKS5tdWwoeS5kaXYoYmFzZSkpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYmFzZS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKGJhc2Uuc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJFeHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5Lm11bCh5Lm11bChiYXNlLmxvZygpKS50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhleHAuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShleHAuc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGJhc2U6IGRlckJhc2UsIGV4cDogZGVyRXhwIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kLCBzYXZlKSB7IHJldHVybiBzYXZlKGJhY2tlbmQucG93KGJhc2UsIGV4cCkpOyB9LCB7IGJhc2U6IGJhc2UsIGV4cDogZXhwIH0sIGdyYWQpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLnBvd1N0cmljdCA9IGZ1bmN0aW9uIChiYXNlLCBleHApIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChiYXNlLnNoYXBlLCBleHAuc2hhcGUsICdFcnJvciBpbiBwb3dTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYmFzZS5wb3coZXhwKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5tdWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBhOiBhLCBiOiBiIH0sICdtdWwnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIGRlckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5Lm11bChiLnRvRmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGEuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuc3VtKHJlZHVjZUF4ZXMpLnJlc2hhcGUoYS5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRlckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5Lm11bChhLnRvRmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGIuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuc3VtKHJlZHVjZUF4ZXMpLnJlc2hhcGUoYi5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogZGVyQSwgYjogZGVyQiB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tdWx0aXBseShhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0sIGRlcik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMubXVsU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbXVsdGlwbHlTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5tdWwoYik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMuZGl2ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnZGl2Jyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgdmFyIGZvcndhcmRGdW5jO1xuICAgICAgICBpZiAoYS5kdHlwZSA9PT0gJ2ludDMyJyAmJiBiLmR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgICByZXR1cm4gQmluYXJ5T3BzLmZsb29yRGl2KGEsIGIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yd2FyZEZ1bmMgPSBmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5yZWFsRGl2aWRlKGEsIGIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkuZGl2KGIudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdW0ocmVkdWNlQXhlcykucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkubXVsKGEudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYi5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gYi5zcXVhcmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRpdih0bXAudG9GbG9hdCgpKS5uZWcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZvcndhcmRGdW5jLCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5mbG9vckRpdiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2Zsb29yRGl2Jyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgdmFyIGZvcndhcmRGdW5jID0gZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZmxvb3JEaXYoYSwgYik7IH07XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkuZGl2KGIudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdW0ocmVkdWNlQXhlcykucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkubXVsKGEudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYi5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gYi5zcXVhcmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRpdih0bXAudG9GbG9hdCgpKS5uZWcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZvcndhcmRGdW5jLCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5kaXZTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBkaXZpZGVTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5kaXYoYik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMubW9kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnbW9kJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhhLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHkuc3VtKHJlZHVjZUF4ZXMpLnJlc2hhcGUoYS5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkubXVsKGEuZGl2KGIpLmZsb29yKCkubmVnKCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhiLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubW9kKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5tb2RTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBtb2RTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5tb2QoYik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMubWluaW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ21pbmltdW0nKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBpZiAoYS5kdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICBhID0gYS50b0ludCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiLmR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIGIgPSBiLnRvSW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKGEubGVzc0VxdWFsKGIpLnRvRmxvYXQoKSk7IH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bChhLmdyZWF0ZXIoYikudG9GbG9hdCgpKTsgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubWluaW11bShhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0sIGRlcik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMubWluaW11bVN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIG1pbmltdW1TdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5taW5pbXVtKGIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLm1heGltdW0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBhOiBhLCBiOiBiIH0sICdtYXhpbXVtJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgaWYgKGEuZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgYSA9IGEudG9JbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5kdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICBiID0gYi50b0ludCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bChhLmdyZWF0ZXJFcXVhbChiKS50b0Zsb2F0KCkpOyB9O1xuICAgICAgICAgICAgdmFyIGRlckIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWwoYS5sZXNzKGIpLnRvRmxvYXQoKSk7IH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm1heGltdW0oYSwgYik7IH0sIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLm1heGltdW1TdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBtaW5pbXVtU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEubWF4aW11bShiKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5zcXVhcmVkRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ3NxdWFyZWREaWZmZXJlbmNlJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciB0d28gPSBvcHNfMS5zY2FsYXIoMik7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bChhLnN1YihiKS5tdWwodHdvKSk7IH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bChiLnN1YihhKS5tdWwodHdvKSk7IH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnNxdWFyZWREaWZmZXJlbmNlKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuc3F1YXJlZERpZmZlcmVuY2UoYik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMuYXRhbjIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBhOiBhLCBiOiBiIH0sICdhdGFuMicpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IEJpbmFyeU9wcy5hZGQob3BzXzEuc3F1YXJlKGEpLCBvcHNfMS5zcXVhcmUoYikpO1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5tdWwoYi5kaXYoZCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhhLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc3VtKHJlZHVjZUF4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUoYS5zaGFwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRlckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBCaW5hcnlPcHMuYWRkKG9wc18xLnNxdWFyZShhKSwgb3BzXzEuc3F1YXJlKGIpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gb3BzXzEubmVnKGR5Lm11bChhLmRpdihkKSkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhiLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc3VtKHJlZHVjZUF4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUoYi5zaGFwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogZGVyQSwgYjogZGVyQiB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hdGFuMihhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0sIGRlcik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJhZGRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJhZGRTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0FyaXRobWV0aWMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwic3ViXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwic3ViU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcInBvd1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcInBvd1N0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtdWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtdWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0FyaXRobWV0aWMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwiZGl2XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcImZsb29yRGl2XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwiZGl2U3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcIm1vZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcIm1vZFN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtaW5pbXVtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwibWluaW11bVN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtYXhpbXVtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwibWF4aW11bVN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJzcXVhcmVkRGlmZmVyZW5jZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcInNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwiYXRhbjJcIiwgbnVsbCk7XG4gICAgcmV0dXJuIEJpbmFyeU9wcztcbn0oKSk7XG5leHBvcnRzLkJpbmFyeU9wcyA9IEJpbmFyeU9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeV9vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKSB7XG4gICAgdmFyIGluUmFuayA9IGluU2hhcGUubGVuZ3RoO1xuICAgIHZhciBkaW1zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpblJhbms7IGkrKykge1xuICAgICAgICB2YXIgZGltID0gaW5SYW5rIC0gMSAtIGk7XG4gICAgICAgIHZhciBhID0gaW5TaGFwZVtkaW1dIHx8IDE7XG4gICAgICAgIHZhciBiID0gb3V0U2hhcGVbb3V0U2hhcGUubGVuZ3RoIC0gMSAtIGldIHx8IDE7XG4gICAgICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICAgICAgICBkaW1zLnVuc2hpZnQoZGltKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGltcztcbn1cbmV4cG9ydHMuZ2V0QnJvYWRjYXN0RGltcyA9IGdldEJyb2FkY2FzdERpbXM7XG5mdW5jdGlvbiBnZXRSZWR1Y3Rpb25BeGVzKGluU2hhcGUsIG91dFNoYXBlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGluRGltID0gaW5TaGFwZVtpblNoYXBlLmxlbmd0aCAtIGkgLSAxXTtcbiAgICAgICAgdmFyIG91dEF4aXMgPSBvdXRTaGFwZS5sZW5ndGggLSBpIC0gMTtcbiAgICAgICAgdmFyIG91dERpbSA9IG91dFNoYXBlW291dEF4aXNdO1xuICAgICAgICBpZiAoaW5EaW0gPT0gbnVsbCB8fCAoaW5EaW0gPT09IDEgJiYgb3V0RGltID4gMSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KG91dEF4aXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmdldFJlZHVjdGlvbkF4ZXMgPSBnZXRSZWR1Y3Rpb25BeGVzO1xuZnVuY3Rpb24gYnJvYWRjYXN0RGltc0FyZU91dGVyKGRpbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRpbXNbaV0gIT09IGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYnJvYWRjYXN0RGltc0FyZU91dGVyID0gYnJvYWRjYXN0RGltc0FyZU91dGVyO1xuZnVuY3Rpb24gYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoc2hhcGVBLCBzaGFwZUIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGVyck1zZyA9IFwiT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBcIiArXG4gICAgICAgIChzaGFwZUEgKyBcIiBhbmQgXCIgKyBzaGFwZUIgKyBcIi5cIik7XG4gICAgdmFyIGwgPSBNYXRoLm1heChzaGFwZUEubGVuZ3RoLCBzaGFwZUIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgYSA9IHNoYXBlQVtzaGFwZUEubGVuZ3RoIC0gaSAtIDFdIHx8IDE7XG4gICAgICAgIHZhciBiID0gc2hhcGVCW3NoYXBlQi5sZW5ndGggLSBpIC0gMV0gfHwgMTtcbiAgICAgICAgaWYgKGEgPiAxICYmIGIgPiAxICYmIGEgIT09IGIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoTWF0aC5tYXgoYSwgYikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSA9IGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvYWRjYXN0X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgQ29tcGFyZU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGFyZU9wcygpIHtcbiAgICB9XG4gICAgQ29tcGFyZU9wcy5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ25vdEVxdWFsJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm5vdEVxdWFsKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLm5vdEVxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbm90RXF1YWxTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5ub3RFcXVhbChiKTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMubGVzcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2xlc3MnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubGVzcyhhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0pO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5sZXNzU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbGVzc1N0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmxlc3MoYik7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnZXF1YWwnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZXF1YWwoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMuZXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBlcXVhbFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmVxdWFsKGIpO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5sZXNzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBhOiBhLCBiOiBiIH0sICdsZXNzRXF1YWwnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubGVzc0VxdWFsKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLmxlc3NFcXVhbFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGxlc3NFcXVhbFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmxlc3NFcXVhbChiKTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMuZ3JlYXRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2dyZWF0ZXInKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZ3JlYXRlcihhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0pO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5ncmVhdGVyU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gZ3JlYXRlclN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmdyZWF0ZXIoYik7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLmdyZWF0ZXJFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2dyZWF0ZXJFcXVhbCcpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5ncmVhdGVyRXF1YWwoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMuZ3JlYXRlckVxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gZ3JlYXRlckVxdWFsU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuZ3JlYXRlckVxdWFsKGIpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcIm5vdEVxdWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcIm5vdEVxdWFsU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29tcGFyZU9wcywgXCJsZXNzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImxlc3NTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImVxdWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImVxdWFsU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29tcGFyZU9wcywgXCJsZXNzRXF1YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwibGVzc0VxdWFsU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29tcGFyZU9wcywgXCJncmVhdGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImdyZWF0ZXJTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImdyZWF0ZXJFcXVhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29tcGFyZU9wcywgXCJncmVhdGVyRXF1YWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgcmV0dXJuIENvbXBhcmVPcHM7XG59KCkpO1xuZXhwb3J0cy5Db21wYXJlT3BzID0gQ29tcGFyZU9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbF8xID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4vY29uY2F0X3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgQ29uY2F0T3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jYXRPcHMoKSB7XG4gICAgfVxuICAgIENvbmNhdE9wcy5jb25jYXQxZCA9IGZ1bmN0aW9uICh0ZW5zb3JzKSB7XG4gICAgICAgIHJldHVybiBDb25jYXRPcHMuY29uY2F0KHRlbnNvcnMsIDApO1xuICAgIH07XG4gICAgQ29uY2F0T3BzLmNvbmNhdDJkID0gZnVuY3Rpb24gKHRlbnNvcnMsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIENvbmNhdE9wcy5jb25jYXQodGVuc29ycywgYXhpcyk7XG4gICAgfTtcbiAgICBDb25jYXRPcHMuY29uY2F0M2QgPSBmdW5jdGlvbiAodGVuc29ycywgYXhpcykge1xuICAgICAgICByZXR1cm4gQ29uY2F0T3BzLmNvbmNhdCh0ZW5zb3JzLCBheGlzKTtcbiAgICB9O1xuICAgIENvbmNhdE9wcy5jb25jYXQ0ZCA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBheGlzKSB7XG4gICAgICAgIHJldHVybiBDb25jYXRPcHMuY29uY2F0KHRlbnNvcnMsIGF4aXMpO1xuICAgIH07XG4gICAgQ29uY2F0T3BzLmNvbmNhdCA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQodGVuc29ycy5sZW5ndGggPj0gMSwgJ1Bhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byBjb25jYXQnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgdGVuc29yczogdGVuc29ycyB9LCAnY29uY2F0Jyk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0ZW5zb3JzWzBdO1xuICAgICAgICBpZiAodGVuc29ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWxfMS5wYXJzZUF4aXNQYXJhbShheGlzLCByZXN1bHQuc2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbmNhdDJUZW5zb3JzKHJlc3VsdCwgdGVuc29yc1tpXSwgYXhlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29uY2F0T3BzLCBcImNvbmNhdFwiLCBudWxsKTtcbiAgICByZXR1cm4gQ29uY2F0T3BzO1xufSgpKTtcbmV4cG9ydHMuQ29uY2F0T3BzID0gQ29uY2F0T3BzO1xuZnVuY3Rpb24gY29uY2F0MlRlbnNvcnMoYSwgYiwgYXhpcykge1xuICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyhhLnNoYXBlLCBiLnNoYXBlLCBheGlzKTtcbiAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgdmFyIGEyRCA9IGEuYXMyRCgtMSwgdXRpbC5zaXplRnJvbVNoYXBlKGEuc2hhcGUuc2xpY2UoYXhpcykpKTtcbiAgICB2YXIgYjJEID0gYi5hczJEKC0xLCB1dGlsLnNpemVGcm9tU2hhcGUoYi5zaGFwZS5zbGljZShheGlzKSkpO1xuICAgIHZhciBfYSA9IGNvbmNhdF91dGlsLmNvbXB1dGVHcmFkaWVudFNsaWNlU2hhcGVzKGEyRC5zaGFwZSwgYjJELnNoYXBlKSwgYUJlZ2luID0gX2EuYUJlZ2luLCBhU2l6ZSA9IF9hLmFTaXplLCBiQmVnaW4gPSBfYS5iQmVnaW4sIGJTaXplID0gX2EuYlNpemU7XG4gICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICByZXR1cm4geyBhOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5zbGljZShhQmVnaW4sIGFTaXplKTsgfSwgYjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuc2xpY2UoYkJlZ2luLCBiU2l6ZSk7IH0gfTtcbiAgICB9O1xuICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNvbmNhdChhMkQsIGIyRCk7IH0sIHsgYTogYTJELCBiOiBiMkQgfSwgZGVyKTtcbiAgICByZXR1cm4gcmVzLnJlc2hhcGUob3V0U2hhcGUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2VydFBhcmFtcyhhU2hhcGUsIGJTaGFwZSwgYXhpcykge1xuICAgIHZhciBhUmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgdmFyIGJSYW5rID0gYlNoYXBlLmxlbmd0aDtcbiAgICB1dGlsLmFzc2VydChhU2hhcGUubGVuZ3RoID09PSBiU2hhcGUubGVuZ3RoLCBcIkVycm9yIGluIGNvbmNhdFwiICsgYVJhbmsgKyBcIkQ6IHJhbmsgb2YgeDEgKFwiICsgYVJhbmsgKyBcIikgYW5kIHgyIChcIiArIGJSYW5rICsgXCIpIFwiICtcbiAgICAgICAgXCJtdXN0IGJlIHRoZSBzYW1lLlwiKTtcbiAgICB1dGlsLmFzc2VydChheGlzID49IDAgJiYgYXhpcyA8IGFSYW5rLCBcIkVycm9yIGluIGNvbmNhdFwiICsgYVJhbmsgKyBcIkQ6IGF4aXMgbXVzdCBiZSBcIiArXG4gICAgICAgIChcImJldHdlZW4gMCBhbmQgXCIgKyAoYVJhbmsgLSAxKSArIFwiLlwiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhUmFuazsgaSsrKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KChpID09PSBheGlzKSB8fCAoYVNoYXBlW2ldID09PSBiU2hhcGVbaV0pLCBcIkVycm9yIGluIGNvbmNhdFwiICsgYVJhbmsgKyBcIkQ6IFNoYXBlIChcIiArIGFTaGFwZSArIFwiKSBkb2VzIG5vdCBtYXRjaCBcIiArXG4gICAgICAgICAgICAoXCIoXCIgKyBiU2hhcGUgKyBcIikgYWxvbmcgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhpcyBcIiArIGkgKyBcIi5cIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0UGFyYW1zID0gYXNzZXJ0UGFyYW1zO1xuZnVuY3Rpb24gY29tcHV0ZU91dFNoYXBlMUQoeDFTaGFwZSwgeDJTaGFwZSkge1xuICAgIHV0aWwuYXNzZXJ0KHgxU2hhcGUubGVuZ3RoID09PSAxICYmIHgyU2hhcGUubGVuZ3RoID09PSAxLCAneDEgYW5kIHgyIHNob3VsZCBiZSAxZCBhcnJheS4nKTtcbiAgICB2YXIgb3V0cHV0U2hhcGUgPSB4MVNoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0U2hhcGVbMF0gKz0geDJTaGFwZVswXTtcbiAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG59XG5leHBvcnRzLmNvbXB1dGVPdXRTaGFwZTFEID0gY29tcHV0ZU91dFNoYXBlMUQ7XG5mdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUoeDFTaGFwZSwgeDJTaGFwZSwgYXhpcykge1xuICAgIHV0aWwuYXNzZXJ0KHgxU2hhcGUubGVuZ3RoID09PSB4MlNoYXBlLmxlbmd0aCwgJ3gxIGFuZCB4MiBzaG91bGQgaGF2ZSB0aGUgc2FtZSByYW5rLicpO1xuICAgIHZhciBvdXRwdXRTaGFwZSA9IHgxU2hhcGUuc2xpY2UoKTtcbiAgICBvdXRwdXRTaGFwZVtheGlzXSArPSB4MlNoYXBlW2F4aXNdO1xuICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dFNoYXBlID0gY29tcHV0ZU91dFNoYXBlO1xuZnVuY3Rpb24gY29tcHV0ZUdyYWRpZW50U2xpY2VTaGFwZXMoYVNoYXBlLCBiU2hhcGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhQmVnaW46IFswLCAwXSxcbiAgICAgICAgYVNpemU6IGFTaGFwZSxcbiAgICAgICAgYkJlZ2luOiBbMCwgYVNoYXBlWzFdXSxcbiAgICAgICAgYlNpemU6IGJTaGFwZVxuICAgIH07XG59XG5leHBvcnRzLmNvbXB1dGVHcmFkaWVudFNsaWNlU2hhcGVzID0gY29tcHV0ZUdyYWRpZW50U2xpY2VTaGFwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4vY29udl91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIENvbnZPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnZPcHMoKSB7XG4gICAgfVxuICAgIENvbnZPcHMuY29udjFkID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgc3RyaWRlLCBwYWQsIGRhdGFGb3JtYXQsIGRpbGF0aW9uLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRhRm9ybWF0ID0gJ05XQyc7IH1cbiAgICAgICAgaWYgKGRpbGF0aW9uID09PSB2b2lkIDApIHsgZGlsYXRpb24gPSAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHgsIGZpbHRlcjogZmlsdGVyIH0sICdjb252MWQnKTtcbiAgICAgICAgdmFyIHgzRCA9IHg7XG4gICAgICAgIHZhciByZXNoYXBlZFRvM0QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMikge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzNEID0gdHJ1ZTtcbiAgICAgICAgICAgIHgzRCA9IHguYXMzRCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4M0QucmFuayA9PT0gMywgXCJFcnJvciBpbiBjb252MWQ6IGlucHV0IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIgKyB4M0QucmFuayArIFwiLlwiKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZmlsdGVyLnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjFkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoZmlsdGVyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBjb252MWQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgXCIgK1xuICAgICAgICAgICAgICAgIChcImRpbVJvdW5kaW5nTW9kZSBcIiArIGRpbVJvdW5kaW5nTW9kZSArIFwiIGJ1dCBnb3QgcGFkIFwiICsgcGFkICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4M0Quc2hhcGVbMl0gPT09IGZpbHRlci5zaGFwZVsxXSwgXCJFcnJvciBpbiBjb252MWQ6IGRlcHRoIG9mIGlucHV0IChcIiArIHgzRC5zaGFwZVsyXSArIFwiKSBtdXN0IG1hdGNoIFwiICtcbiAgICAgICAgICAgIChcImlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMV0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoc3RyaWRlLCBkaWxhdGlvbiksICdFcnJvciBpbiBjb252MUQ6IEVpdGhlciBzdHJpZGUgb3IgZGlsYXRpb24gbXVzdCBiZSAxLiAnICtcbiAgICAgICAgICAgIChcIkdvdCBzdHJpZGUgXCIgKyBzdHJpZGUgKyBcIiBhbmQgZGlsYXRpb24gJ1wiICsgZGlsYXRpb24gKyBcIidcIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkYXRhRm9ybWF0ID09PSAnTldDJywgXCJFcnJvciBpbiBjb252MWQ6IGdvdCBkYXRhRm9ybWF0IG9mIFwiICsgZGF0YUZvcm1hdCArIFwiIGJ1dCBvbmx5IE5XQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgdmFyIGZpbHRlcjREID0gZmlsdGVyLmFzNEQoMSwgZmlsdGVyLnNoYXBlWzBdLCBmaWx0ZXIuc2hhcGVbMV0sIGZpbHRlci5zaGFwZVsyXSk7XG4gICAgICAgIHZhciBpbnB1dDREID0geDNELmFzNEQoeDNELnNoYXBlWzBdLCAxLCB4M0Quc2hhcGVbMV0sIHgzRC5zaGFwZVsyXSk7XG4gICAgICAgIHZhciBzdHJpZGVzID0gWzEsIHN0cmlkZV07XG4gICAgICAgIHZhciBkaWxhdGlvbnMgPSBbMSwgZGlsYXRpb25dO1xuICAgICAgICB2YXIgY29udjJkRGF0YUZvcm1hdCA9ICdOSFdDJztcbiAgICAgICAgdmFyIHJlcyA9IENvbnZPcHMuY29udjJkKGlucHV0NEQsIGZpbHRlcjRELCBzdHJpZGVzLCBwYWQsIGNvbnYyZERhdGFGb3JtYXQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG8zRCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczJEKHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzBdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgfTtcbiAgICBDb252T3BzLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRhRm9ybWF0ID0gJ05IV0MnOyB9XG4gICAgICAgIGlmIChkaWxhdGlvbnMgPT09IHZvaWQgMCkgeyBkaWxhdGlvbnMgPSBbMSwgMV07IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCwgZmlsdGVyOiBmaWx0ZXIgfSwgJ2NvbnYyZCcpO1xuICAgICAgICB2YXIgeDREID0geDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIiArIHg0RC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChmaWx0ZXIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5zaGFwZVszXSA9PT0gZmlsdGVyLnNoYXBlWzJdLCBcIkVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKFwiICsgeDRELnNoYXBlWzNdICsgXCIpIG11c3QgbWF0Y2ggXCIgK1xuICAgICAgICAgICAgKFwiaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGVzLCBkaWxhdGlvbnMpLCAnRXJyb3IgaW4gY29udjJEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiAnICtcbiAgICAgICAgICAgIChcIkdvdCBzdHJpZGVzIFwiICsgc3RyaWRlcyArIFwiIGFuZCBkaWxhdGlvbnMgJ1wiICsgZGlsYXRpb25zICsgXCInXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZGF0YUZvcm1hdCA9PT0gJ05IV0MnLCBcIkVycm9yIGluIGNvbnYyZDogZ290IGRhdGFGb3JtYXQgb2YgXCIgKyBkYXRhRm9ybWF0ICsgXCIgYnV0IG9ubHkgTkhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHg0RC5zaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHR1cGxlVmFsdWVzQXJlT25lKGRpbGF0aW9ucyksICdFcnJvciBpbiBncmFkaWVudCBvZiBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QnICtcbiAgICAgICAgICAgICAgICAoXCJ5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIgKyBkaWxhdGlvbnMgKyBcIidcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb252T3BzLmNvbnYyZERlcklucHV0KHg0RC5zaGFwZSwgZHksIGZpbHRlciwgc3RyaWRlcywgcGFkKTsgfSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnZPcHMuY29udjJkRGVyRmlsdGVyKHg0RCwgZHksIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgcGFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5jb252MmQoeDRELCBmaWx0ZXIsIGNvbnZJbmZvKTsgfSwgeyB4OiB4NEQsIGZpbHRlcjogZmlsdGVyIH0sIGdyYWQpO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIENvbnZPcHMuY29udjJkRGVySW5wdXQgPSBmdW5jdGlvbiAoeFNoYXBlLCBkeSwgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBkeTogZHksIGZpbHRlcjogZmlsdGVyIH0sICdjb252MmREZXJJbnB1dCcpO1xuICAgICAgICB1dGlsLmFzc2VydCh4U2hhcGUubGVuZ3RoID09PSBkeS5yYW5rLCBcIkxlbmd0aCBvZiBpblNoYXBlIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIHhTaGFwZS5sZW5ndGggKyBcIikgYW5kIHJhbmsgb2YgZHkgKFwiICsgZHkucmFuayArIFwiKSBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgdmFyIHhTaGFwZTREID0geFNoYXBlO1xuICAgICAgICB2YXIgZHk0RCA9IGR5O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChkeS5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgZHk0RCA9IGR5LmFzNEQoMSwgZHkuc2hhcGVbMF0sIGR5LnNoYXBlWzFdLCBkeS5zaGFwZVsyXSk7XG4gICAgICAgICAgICB4U2hhcGU0RCA9IFsxLCB4U2hhcGVbMF0sIHhTaGFwZVsxXSwgeFNoYXBlWzJdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5EZXB0aCA9IHhTaGFwZTREWzNdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBkeTRELnNoYXBlWzNdO1xuICAgICAgICB1dGlsLmFzc2VydCh4U2hhcGU0RC5sZW5ndGggPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBsZW5ndGggXCIgK1xuICAgICAgICAgICAgKHhTaGFwZTRELmxlbmd0aCArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGR5NEQucmFuaykpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBmaWx0ZXIucmFuaykpO1xuICAgICAgICB1dGlsLmFzc2VydChpbkRlcHRoID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0IChcIiArIGluRGVwdGggKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQob3V0RGVwdGggPT09IGZpbHRlci5zaGFwZVszXSwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0IChcIiArIG91dERlcHRoICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbM10gKyBcIi5cIikpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWxhdGlvbnMgPSAxO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeFNoYXBlNEQsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNvbnYyZERlcklucHV0KGR5NEQsIGZpbHRlciwgY29udkluZm8pOyB9LCB7IGR5NEQ6IGR5NEQgfSk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgQ29udk9wcy5jb252MmREZXJGaWx0ZXIgPSBmdW5jdGlvbiAoeCwgZHksIGZpbHRlclNoYXBlLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4LCBkeTogZHkgfSwgJ2NvbnYyZERlckZpbHRlcicpO1xuICAgICAgICB2YXIgeDREID0geDtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkeTREID0gZHk7XG4gICAgICAgIGlmIChkeTRELnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIGR5NEQgPSBkeS5hczREKDEsIGR5LnNoYXBlWzBdLCBkeS5zaGFwZVsxXSwgZHkuc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKHg0RC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGR5IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgIChkeTRELnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZmlsdGVyU2hhcGUubGVuZ3RoID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoZmlsdGVyU2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh4NEQuc2hhcGVbM10gPT09IGZpbHRlclNoYXBlWzJdLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgaW5wdXQgXCIgKyB4NEQuc2hhcGVbM10gKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKFwiICsgZmlsdGVyU2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkeTRELnNoYXBlWzNdID09PSBmaWx0ZXJTaGFwZVszXSwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIiArIGR5NEQuc2hhcGVbM10gKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAoXCIgKyBmaWx0ZXJTaGFwZVszXSArIFwiKS5cIikpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgXCIgK1xuICAgICAgICAgICAgICAgIChcImRpbVJvdW5kaW5nTW9kZSBcIiArIGRpbVJvdW5kaW5nTW9kZSArIFwiIGJ1dCBnb3QgcGFkIFwiICsgcGFkICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlsYXRpb25zID0gMTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHg0RC5zaGFwZSwgZmlsdGVyU2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5jb252MmREZXJGaWx0ZXIoeDRELCBkeTRELCBjb252SW5mbyk7IH0sIHsgeDREOiB4NEQsIGR5NEQ6IGR5NEQgfSk7XG4gICAgfTtcbiAgICBDb252T3BzLmNvbnYyZFRyYW5zcG9zZSA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIG91dHB1dFNoYXBlLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4LCBmaWx0ZXI6IGZpbHRlciB9LCAnY29udjJkVHJhbnNwb3NlJyk7XG4gICAgICAgIHJldHVybiBDb252T3BzLmNvbnYyZERlcklucHV0KG91dHB1dFNoYXBlLCB4LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIENvbnZPcHMuZGVwdGh3aXNlQ29udjJkID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgc3RyaWRlcywgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnTkhXQyc7IH1cbiAgICAgICAgaWYgKGRpbGF0aW9ucyA9PT0gdm9pZCAwKSB7IGRpbGF0aW9ucyA9IFsxLCAxXTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4LCBmaWx0ZXI6IGZpbHRlciB9LCAnZGVwdGh3aXNlQ29udjJkJyk7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgeDRELnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChmaWx0ZXIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5zaGFwZVszXSA9PT0gZmlsdGVyLnNoYXBlWzJdLCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIHg0RC5zaGFwZVszXSArIFwiKSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBcIikgK1xuICAgICAgICAgICAgKFwiZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGRpbGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkaWxhdGlvbnMgPSBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKHN0cmlkZXMsIGRpbGF0aW9ucyksICdFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuICcgK1xuICAgICAgICAgICAgKFwiR290IHN0cmlkZXMgXCIgKyBzdHJpZGVzICsgXCIgYW5kIGRpbGF0aW9ucyAnXCIgKyBkaWxhdGlvbnMgKyBcIidcIikpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgXCIgK1xuICAgICAgICAgICAgICAgIChcImRpbVJvdW5kaW5nTW9kZSBcIiArIGRpbVJvdW5kaW5nTW9kZSArIFwiIGJ1dCBnb3QgcGFkIFwiICsgcGFkICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeDRELnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUsIHRydWUpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodHVwbGVWYWx1ZXNBcmVPbmUoZGlsYXRpb25zKSwgJ0Vycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuICcgK1xuICAgICAgICAgICAgICAgIChcIjEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICdcIiArIGRpbGF0aW9ucyArIFwiJ1wiKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlcHRod2lzZUNvbnYyZERlcklucHV0KHg0RC5zaGFwZSwgZHksIGZpbHRlciwgY29udkluZm8pOyB9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVwdGh3aXNlQ29udjJkRGVyRmlsdGVyKHg0RCwgZHksIGZpbHRlci5zaGFwZSwgY29udkluZm8pOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZGVwdGh3aXNlQ29udjJEKHg0RCwgZmlsdGVyLCBjb252SW5mbyk7IH0sIHsgeDogeDRELCBmaWx0ZXI6IGZpbHRlciB9LCBncmFkKTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBDb252T3BzLnNlcGFyYWJsZUNvbnYyZCA9IGZ1bmN0aW9uICh4LCBkZXB0aHdpc2VGaWx0ZXIsIHBvaW50d2lzZUZpbHRlciwgc3RyaWRlcywgcGFkLCBkaWxhdGlvbiwgZGF0YUZvcm1hdCkge1xuICAgICAgICBpZiAoZGlsYXRpb24gPT09IHZvaWQgMCkgeyBkaWxhdGlvbiA9IFsxLCAxXTsgfVxuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnTkhXQyc7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCwgZGVwdGh3aXNlRmlsdGVyOiBkZXB0aHdpc2VGaWx0ZXIsIHBvaW50d2lzZUZpbHRlcjogcG9pbnR3aXNlRmlsdGVyIH0sICdzZXBhcmFibGVDb252MmQnKTtcbiAgICAgICAgdmFyIHg0RCA9IHg7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ05DSFcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcGFyYWJsZUNvbnYyZCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0IE5DSFc7IG9ubHkgJyArXG4gICAgICAgICAgICAgICAgJ05IV0MgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgeDRELnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkZXB0aHdpc2VGaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGRlcHRod2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGRlcHRod2lzZUZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQocG9pbnR3aXNlRmlsdGVyLnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBkZXB0aHdpc2VGaWx0ZXIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHBvaW50d2lzZUZpbHRlci5zaGFwZVswXSA9PT0gMSwgXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSBmaXJzdCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBcIiArXG4gICAgICAgICAgICAoXCIgbXVzdCBiZSAxLCBidXQgZ290IFwiICsgcG9pbnR3aXNlRmlsdGVyLnNoYXBlWzBdICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQocG9pbnR3aXNlRmlsdGVyLnNoYXBlWzFdID09PSAxLCBcIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHNlY29uZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBcIiArXG4gICAgICAgICAgICAoXCIgbXVzdCBiZSAxLCBidXQgZ290IFwiICsgcG9pbnR3aXNlRmlsdGVyLnNoYXBlWzFdICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGluQ2hhbm5lbHMgPSBkZXB0aHdpc2VGaWx0ZXIuc2hhcGVbMl07XG4gICAgICAgIHZhciBjaGFubmVsTXVsdGlwbGllciA9IGRlcHRod2lzZUZpbHRlci5zaGFwZVszXTtcbiAgICAgICAgdXRpbC5hc3NlcnQocG9pbnR3aXNlRmlsdGVyLnNoYXBlWzJdID09PSBpbkNoYW5uZWxzICogY2hhbm5lbE11bHRpcGxpZXIsIFwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgdGhpcmQgZGltZW5zaW9uIG9mIHBvaW50d2lzZSBmaWx0ZXIgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBiZSBcIiArIGluQ2hhbm5lbHMgKiBjaGFubmVsTXVsdGlwbGllciArIFwiLCBcIikgK1xuICAgICAgICAgICAgKFwiYnV0IGdvdCBcIiArIHBvaW50d2lzZUZpbHRlci5zaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHZhciBkZXB0aHdpc2UgPSBDb252T3BzLmRlcHRod2lzZUNvbnYyZCh4NEQsIGRlcHRod2lzZUZpbHRlciwgc3RyaWRlcywgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbik7XG4gICAgICAgIHZhciBwb2ludHdpc2VTdHJpZGUgPSAxO1xuICAgICAgICB2YXIgcmVzID0gQ29udk9wcy5jb252MmQoZGVwdGh3aXNlLCBwb2ludHdpc2VGaWx0ZXIsIHBvaW50d2lzZVN0cmlkZSwgJ3ZhbGlkJywgZGF0YUZvcm1hdCk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJjb252MWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJjb252MmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwiY29udjJkRGVySW5wdXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwiY29udjJkRGVyRmlsdGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwiY29udjJkVHJhbnNwb3NlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwiZGVwdGh3aXNlQ29udjJkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwic2VwYXJhYmxlQ29udjJkXCIsIG51bGwpO1xuICAgIHJldHVybiBDb252T3BzO1xufSgpKTtcbmV4cG9ydHMuQ29udk9wcyA9IENvbnZPcHM7XG5mdW5jdGlvbiBwYXJzZVR1cGxlUGFyYW0ocGFyYW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW1dIDogcGFyYW07XG59XG5mdW5jdGlvbiB0dXBsZVZhbHVlc0FyZU9uZShwYXJhbSkge1xuICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShwYXJhbSksIGRpbUEgPSBfYVswXSwgZGltQiA9IF9hWzFdO1xuICAgIHJldHVybiBkaW1BID09PSAxICYmIGRpbUIgPT09IDE7XG59XG5mdW5jdGlvbiBlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoc3RyaWRlcywgZGlsYXRpb25zKSB7XG4gICAgcmV0dXJuIHR1cGxlVmFsdWVzQXJlT25lKHN0cmlkZXMpIHx8IHR1cGxlVmFsdWVzQXJlT25lKGRpbGF0aW9ucyk7XG59XG5mdW5jdGlvbiBkZXB0aHdpc2VDb252MmREZXJJbnB1dCh4U2hhcGUsIGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgdmFyIGR5NEQgPSBkeTtcbiAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgaWYgKGR5LnJhbmsgPT09IDMpIHtcbiAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgZHk0RCA9IGR5LmFzNEQoMSwgZHkuc2hhcGVbMF0sIGR5LnNoYXBlWzFdLCBkeS5zaGFwZVsyXSk7XG4gICAgfVxuICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmRlcHRod2lzZUNvbnYyRERlcklucHV0KGR5NEQsIGZpbHRlciwgY29udkluZm8pOyB9LCB7IGR5NEQ6IGR5NEQgfSk7XG4gICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBkZXB0aHdpc2VDb252MmREZXJGaWx0ZXIoeCwgZHksIGZpbHRlclNoYXBlLCBjb252SW5mbykge1xuICAgIHZhciB4NEQgPSB4O1xuICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgeDREID0geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgIH1cbiAgICB2YXIgZHk0RCA9IGR5O1xuICAgIGlmIChkeTRELnJhbmsgPT09IDMpIHtcbiAgICAgICAgZHk0RCA9IGR5LmFzNEQoMSwgZHkuc2hhcGVbMF0sIGR5LnNoYXBlWzFdLCBkeS5zaGFwZVsyXSk7XG4gICAgfVxuICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcih4NEQsIGR5NEQsIGNvbnZJbmZvKTsgfSwgeyB4NEQ6IHg0RCwgZHk0RDogZHk0RCB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gY29tcHV0ZVBvb2wyREluZm8oaW5TaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCByb3VuZGluZ01vZGUsIGRhdGFGb3JtYXQpIHtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnY2hhbm5lbHNMYXN0JzsgfVxuICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShmaWx0ZXJTaXplKSwgZmlsdGVySGVpZ2h0ID0gX2FbMF0sIGZpbHRlcldpZHRoID0gX2FbMV07XG4gICAgdmFyIGZpbHRlclNoYXBlO1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICBmaWx0ZXJTaGFwZSA9IFtmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBpblNoYXBlWzNdLCBpblNoYXBlWzNdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgIGZpbHRlclNoYXBlID0gW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIGluU2hhcGVbMV0sIGluU2hhcGVbMV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiICsgZGF0YUZvcm1hdCk7XG4gICAgfVxuICAgIHZhciBkaWxhdGlvbnMgPSAxO1xuICAgIHJldHVybiBjb21wdXRlQ29udjJESW5mbyhpblNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIHJvdW5kaW5nTW9kZSwgZmFsc2UsIGRhdGFGb3JtYXQpO1xufVxuZXhwb3J0cy5jb21wdXRlUG9vbDJESW5mbyA9IGNvbXB1dGVQb29sMkRJbmZvO1xuZnVuY3Rpb24gY29tcHV0ZUNvbnYyREluZm8oaW5TaGFwZSwgZmlsdGVyU2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCByb3VuZGluZ01vZGUsIGRlcHRod2lzZSwgZGF0YUZvcm1hdCkge1xuICAgIGlmIChkZXB0aHdpc2UgPT09IHZvaWQgMCkgeyBkZXB0aHdpc2UgPSBmYWxzZTsgfVxuICAgIGlmIChkYXRhRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0YUZvcm1hdCA9ICdjaGFubmVsc0xhc3QnOyB9XG4gICAgdmFyIF9hID0gWy0xLCAtMSwgLTEsIC0xXSwgYmF0Y2hTaXplID0gX2FbMF0sIGluSGVpZ2h0ID0gX2FbMV0sIGluV2lkdGggPSBfYVsyXSwgaW5DaGFubmVscyA9IF9hWzNdO1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICBiYXRjaFNpemUgPSBpblNoYXBlWzBdLCBpbkhlaWdodCA9IGluU2hhcGVbMV0sIGluV2lkdGggPSBpblNoYXBlWzJdLCBpbkNoYW5uZWxzID0gaW5TaGFwZVszXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgIGJhdGNoU2l6ZSA9IGluU2hhcGVbMF0sIGluQ2hhbm5lbHMgPSBpblNoYXBlWzFdLCBpbkhlaWdodCA9IGluU2hhcGVbMl0sIGluV2lkdGggPSBpblNoYXBlWzNdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiICsgZGF0YUZvcm1hdCk7XG4gICAgfVxuICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBmaWx0ZXJTaGFwZVswXSwgZmlsdGVyV2lkdGggPSBmaWx0ZXJTaGFwZVsxXSwgZmlsdGVyQ2hhbm5lbHMgPSBmaWx0ZXJTaGFwZVszXTtcbiAgICB2YXIgX2IgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9iWzBdLCBzdHJpZGVXaWR0aCA9IF9iWzFdO1xuICAgIHZhciBfYyA9IHBhcnNlVHVwbGVQYXJhbShkaWxhdGlvbnMpLCBkaWxhdGlvbkhlaWdodCA9IF9jWzBdLCBkaWxhdGlvbldpZHRoID0gX2NbMV07XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVySGVpZ2h0LCBkaWxhdGlvbkhlaWdodCk7XG4gICAgdmFyIGVmZmVjdGl2ZUZpbHRlcldpZHRoID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJXaWR0aCwgZGlsYXRpb25XaWR0aCk7XG4gICAgdmFyIF9kID0gZ2V0UGFkQW5kT3V0SW5mbyhwYWQsIGluSGVpZ2h0LCBpbldpZHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQsIGVmZmVjdGl2ZUZpbHRlcldpZHRoLCByb3VuZGluZ01vZGUpLCBwYWRJbmZvID0gX2QucGFkSW5mbywgb3V0SGVpZ2h0ID0gX2Qub3V0SGVpZ2h0LCBvdXRXaWR0aCA9IF9kLm91dFdpZHRoO1xuICAgIHZhciBvdXRDaGFubmVscyA9IGRlcHRod2lzZSA/IGZpbHRlckNoYW5uZWxzICogaW5DaGFubmVscyA6IGZpbHRlckNoYW5uZWxzO1xuICAgIHZhciBvdXRTaGFwZTtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0Q2hhbm5lbHMsIG91dEhlaWdodCwgb3V0V2lkdGhdO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICBvdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dEhlaWdodCwgb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmF0Y2hTaXplOiBiYXRjaFNpemUsXG4gICAgICAgIGRhdGFGb3JtYXQ6IGRhdGFGb3JtYXQsXG4gICAgICAgIGluSGVpZ2h0OiBpbkhlaWdodCxcbiAgICAgICAgaW5XaWR0aDogaW5XaWR0aCxcbiAgICAgICAgaW5DaGFubmVsczogaW5DaGFubmVscyxcbiAgICAgICAgb3V0SGVpZ2h0OiBvdXRIZWlnaHQsXG4gICAgICAgIG91dFdpZHRoOiBvdXRXaWR0aCxcbiAgICAgICAgb3V0Q2hhbm5lbHM6IG91dENoYW5uZWxzLFxuICAgICAgICBwYWRJbmZvOiBwYWRJbmZvLFxuICAgICAgICBzdHJpZGVIZWlnaHQ6IHN0cmlkZUhlaWdodCxcbiAgICAgICAgc3RyaWRlV2lkdGg6IHN0cmlkZVdpZHRoLFxuICAgICAgICBmaWx0ZXJIZWlnaHQ6IGZpbHRlckhlaWdodCxcbiAgICAgICAgZmlsdGVyV2lkdGg6IGZpbHRlcldpZHRoLFxuICAgICAgICBkaWxhdGlvbkhlaWdodDogZGlsYXRpb25IZWlnaHQsXG4gICAgICAgIGRpbGF0aW9uV2lkdGg6IGRpbGF0aW9uV2lkdGgsXG4gICAgICAgIGluU2hhcGU6IGluU2hhcGUsXG4gICAgICAgIG91dFNoYXBlOiBvdXRTaGFwZSxcbiAgICAgICAgZmlsdGVyU2hhcGU6IGZpbHRlclNoYXBlXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcHV0ZUNvbnYyREluZm8gPSBjb21wdXRlQ29udjJESW5mbztcbmZ1bmN0aW9uIGNvbXB1dGVPdXRwdXRTaGFwZTNEKGluU2hhcGUsIGZpZWxkU2l6ZSwgb3V0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCwgcm91bmRpbmdNb2RlKSB7XG4gICAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgICAgICB6ZXJvUGFkID0gY29tcHV0ZURlZmF1bHRQYWQoaW5TaGFwZSwgZmllbGRTaXplLCBzdHJpZGUpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRSb3dzID0gaW5TaGFwZVswXTtcbiAgICB2YXIgaW5wdXRDb2xzID0gaW5TaGFwZVsxXTtcbiAgICB2YXIgb3V0cHV0Um93cyA9IGNvbmRpdGlvbmFsUm91bmQoKGlucHV0Um93cyAtIGZpZWxkU2l6ZSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZSArIDEsIHJvdW5kaW5nTW9kZSk7XG4gICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChvdXRwdXRSb3dzKSwgXCJUaGUgb3V0cHV0ICMgb2Ygcm93cyAoXCIgKyBvdXRwdXRSb3dzICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBcIiArXG4gICAgICAgIFwic3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgIHZhciBvdXRwdXRDb2xzID0gY29uZGl0aW9uYWxSb3VuZCgoaW5wdXRDb2xzIC0gZmllbGRTaXplICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlICsgMSwgcm91bmRpbmdNb2RlKTtcbiAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KG91dHB1dENvbHMpLCBcIlRoZSBvdXRwdXQgIyBvZiBjb2x1bW5zIChcIiArIG91dHB1dENvbHMgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgXCIgK1xuICAgICAgICBcInRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7XG4gICAgcmV0dXJuIFtvdXRwdXRSb3dzLCBvdXRwdXRDb2xzLCBvdXREZXB0aF07XG59XG5mdW5jdGlvbiBjb21wdXRlRGVmYXVsdFBhZChpbnB1dFNoYXBlLCBmaWVsZFNpemUsIHN0cmlkZSwgZGlsYXRpb24pIHtcbiAgICBpZiAoZGlsYXRpb24gPT09IHZvaWQgMCkgeyBkaWxhdGlvbiA9IDE7IH1cbiAgICB2YXIgZWZmZWN0aXZlRmllbGRTaXplID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWVsZFNpemUsIGRpbGF0aW9uKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5wdXRTaGFwZVswXSAqIChzdHJpZGUgLSAxKSAtIHN0cmlkZSArIGVmZmVjdGl2ZUZpZWxkU2l6ZSkgLyAyKTtcbn1cbmV4cG9ydHMuY29tcHV0ZURlZmF1bHRQYWQgPSBjb21wdXRlRGVmYXVsdFBhZDtcbmZ1bmN0aW9uIHBhcnNlVHVwbGVQYXJhbShwYXJhbSkge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInID8gW3BhcmFtLCBwYXJhbV0gOiBwYXJhbTtcbn1cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVyU2l6ZSwgZGlsYXRpb24pIHtcbiAgICBpZiAoZGlsYXRpb24gPD0gMSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlclNpemUgKyAoZmlsdGVyU2l6ZSAtIDEpICogKGRpbGF0aW9uIC0gMSk7XG59XG5mdW5jdGlvbiBnZXRQYWRBbmRPdXRJbmZvKHBhZCwgaW5IZWlnaHQsIGluV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIHJvdW5kaW5nTW9kZSkge1xuICAgIHZhciBwYWRJbmZvO1xuICAgIHZhciBvdXRIZWlnaHQ7XG4gICAgdmFyIG91dFdpZHRoO1xuICAgIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcGFkVHlwZSA9IChwYWQgPT09IDApID8gJ1ZBTElEJyA6ICdOVU1CRVInO1xuICAgICAgICBwYWRJbmZvID0geyB0b3A6IHBhZCwgYm90dG9tOiBwYWQsIGxlZnQ6IHBhZCwgcmlnaHQ6IHBhZCwgdHlwZTogcGFkVHlwZSB9O1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb21wdXRlT3V0cHV0U2hhcGUzRChbaW5IZWlnaHQsIGluV2lkdGgsIDFdLCBmaWx0ZXJIZWlnaHQsIDEsIHN0cmlkZUhlaWdodCwgcGFkLCByb3VuZGluZ01vZGUpO1xuICAgICAgICBvdXRIZWlnaHQgPSBvdXRTaGFwZVswXTtcbiAgICAgICAgb3V0V2lkdGggPSBvdXRTaGFwZVsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFkID09PSAnc2FtZScpIHtcbiAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5jZWlsKGluSGVpZ2h0IC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgb3V0V2lkdGggPSBNYXRoLmNlaWwoaW5XaWR0aCAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgdmFyIHBhZEFsb25nSGVpZ2h0ID0gKG91dEhlaWdodCAtIDEpICogc3RyaWRlSGVpZ2h0ICsgZmlsdGVySGVpZ2h0IC0gaW5IZWlnaHQ7XG4gICAgICAgIHZhciBwYWRBbG9uZ1dpZHRoID0gKG91dFdpZHRoIC0gMSkgKiBzdHJpZGVXaWR0aCArIGZpbHRlcldpZHRoIC0gaW5XaWR0aDtcbiAgICAgICAgdmFyIHRvcF8xID0gTWF0aC5mbG9vcihwYWRBbG9uZ0hlaWdodCAvIDIpO1xuICAgICAgICB2YXIgYm90dG9tID0gcGFkQWxvbmdIZWlnaHQgLSB0b3BfMTtcbiAgICAgICAgdmFyIGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFkQWxvbmdXaWR0aCAtIGxlZnQ7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogdG9wXzEsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQsIHR5cGU6ICdTQU1FJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChwYWQgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgcGFkSW5mbyA9IHsgdG9wOiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwLCB0eXBlOiAnVkFMSUQnIH07XG4gICAgICAgIG91dEhlaWdodCA9IE1hdGguY2VpbCgoaW5IZWlnaHQgLSBmaWx0ZXJIZWlnaHQgKyAxKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgIG91dFdpZHRoID0gTWF0aC5jZWlsKChpbldpZHRoIC0gZmlsdGVyV2lkdGggKyAxKSAvIHN0cmlkZVdpZHRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogXCIgKyBwYWQpO1xuICAgIH1cbiAgICByZXR1cm4geyBwYWRJbmZvOiBwYWRJbmZvLCBvdXRIZWlnaHQ6IG91dEhlaWdodCwgb3V0V2lkdGg6IG91dFdpZHRoIH07XG59XG5mdW5jdGlvbiBjb25kaXRpb25hbFJvdW5kKHZhbHVlLCByb3VuZGluZ01vZGUpIHtcbiAgICBpZiAoIXJvdW5kaW5nTW9kZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHN3aXRjaCAocm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGNhc2UgJ3JvdW5kJzpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByb3VuZGluZ01vZGUgXCIgKyByb3VuZGluZ01vZGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRVJGX1AgPSAwLjMyNzU5MTE7XG5leHBvcnRzLkVSRl9BMSA9IDAuMjU0ODI5NTkyO1xuZXhwb3J0cy5FUkZfQTIgPSAtMC4yODQ0OTY3MzY7XG5leHBvcnRzLkVSRl9BMyA9IDEuNDIxNDEzNzQxO1xuZXhwb3J0cy5FUkZfQTQgPSAtMS40NTMxNTIwMjc7XG5leHBvcnRzLkVSRl9BNSA9IDEuMDYxNDA1NDI5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJmX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIEltYWdlT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbWFnZU9wcygpIHtcbiAgICB9XG4gICAgSW1hZ2VPcHMucmVzaXplQmlsaW5lYXIgPSBmdW5jdGlvbiAoaW1hZ2VzLCBzaXplLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgaWYgKGFsaWduQ29ybmVycyA9PT0gdm9pZCAwKSB7IGFsaWduQ29ybmVycyA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGltYWdlczogaW1hZ2VzIH0sICdyZXNpemVCaWxpbmVhcicpO1xuICAgICAgICB1dGlsLmFzc2VydChpbWFnZXMucmFuayA9PT0gMyB8fCBpbWFnZXMucmFuayA9PT0gNCwgXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogeCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBpbWFnZXMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHNpemUubGVuZ3RoID09PSAyLCBcIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiBuZXcgc2hhcGUgbXVzdCAyRCwgYnV0IGdvdCBzaGFwZSBcIiArXG4gICAgICAgICAgICAoc2l6ZSArIFwiLlwiKSk7XG4gICAgICAgIHZhciBiYXRjaEltYWdlcyA9IGltYWdlcztcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW1hZ2VzLnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICBiYXRjaEltYWdlcyA9XG4gICAgICAgICAgICAgICAgaW1hZ2VzLmFzNEQoMSwgaW1hZ2VzLnNoYXBlWzBdLCBpbWFnZXMuc2hhcGVbMV0sIGltYWdlcy5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IHNpemVbMF0sIG5ld1dpZHRoID0gc2l6ZVsxXTtcbiAgICAgICAgdmFyIGZvcndhcmQgPSBmdW5jdGlvbiAoYmFja2VuZCwgc2F2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmQucmVzaXplQmlsaW5lYXIoYmF0Y2hJbWFnZXMsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYWNrd2FyZCA9IGZ1bmN0aW9uIChkeSwgc2F2ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmF0Y2hJbWFnZXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmQucmVzaXplQmlsaW5lYXJCYWNrcHJvcChkeSwgYmF0Y2hJbWFnZXMsIGFsaWduQ29ybmVycyk7XG4gICAgICAgICAgICAgICAgfSwge30pOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmb3J3YXJkLCB7IGJhdGNoSW1hZ2VzOiBiYXRjaEltYWdlcyB9LCBiYWNrd2FyZCk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgSW1hZ2VPcHMucmVzaXplTmVhcmVzdE5laWdoYm9yID0gZnVuY3Rpb24gKGltYWdlcywgc2l6ZSwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIGlmIChhbGlnbkNvcm5lcnMgPT09IHZvaWQgMCkgeyBhbGlnbkNvcm5lcnMgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBpbWFnZXM6IGltYWdlcyB9LCAncmVzaXplTmVhcmVzdE5laWdoYm9yJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGltYWdlcy5yYW5rID09PSAzIHx8IGltYWdlcy5yYW5rID09PSA0LCBcIkVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogeCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBpbWFnZXMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHNpemUubGVuZ3RoID09PSAyLCBcIkVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKHNpemUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChpbWFnZXMuZHR5cGUgPT09ICdmbG9hdDMyJyB8fCBpbWFnZXMuZHR5cGUgPT09ICdpbnQzMicsICdgaW1hZ2VzYCBtdXN0IGhhdmUgYGludDMyYCBvciBgZmxvYXQzMmAgYXMgZHR5cGUnKTtcbiAgICAgICAgdmFyIGJhdGNoSW1hZ2VzID0gaW1hZ2VzO1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbWFnZXMucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhdGNoSW1hZ2VzID1cbiAgICAgICAgICAgICAgICBpbWFnZXMuYXM0RCgxLCBpbWFnZXMuc2hhcGVbMF0sIGltYWdlcy5zaGFwZVsxXSwgaW1hZ2VzLnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gc2l6ZVswXSwgbmV3V2lkdGggPSBzaXplWzFdO1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5yZXNpemVOZWFyZXN0TmVpZ2hib3IoYmF0Y2hJbWFnZXMsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycyk7IH0sIHsgYmF0Y2hJbWFnZXM6IGJhdGNoSW1hZ2VzIH0pO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdJbWFnZXMnLCBuYW1lc3BhY2U6ICdpbWFnZScgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEltYWdlT3BzLCBcInJlc2l6ZUJpbGluZWFyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdJbWFnZXMnLCBuYW1lc3BhY2U6ICdpbWFnZScgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEltYWdlT3BzLCBcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiLCBudWxsKTtcbiAgICByZXR1cm4gSW1hZ2VPcHM7XG59KCkpO1xuZXhwb3J0cy5JbWFnZU9wcyA9IEltYWdlT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2Vfb3BzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciB0cmFja2luZ18xID0gcmVxdWlyZShcIi4uL3RyYWNraW5nXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIExpbmFsZ09wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluYWxnT3BzKCkge1xuICAgIH1cbiAgICBMaW5hbGdPcHMuZ3JhbVNjaG1pZHQgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyIGlucHV0SXNUZW5zb3IyRDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgICAgICBpbnB1dElzVGVuc29yMkQgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoeHMgIT0gbnVsbCAmJiB4cy5sZW5ndGggPiAwLCAnR3JhbS1TY2htaWR0IHByb2Nlc3M6IGlucHV0IG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHknKTtcbiAgICAgICAgICAgIHZhciBkaW0gPSB4c1swXS5zaGFwZVswXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgeHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHhzW2ldLnNoYXBlWzBdID09PSBkaW0sICdHcmFtLVNjaG1pZHQ6IE5vbi11bmlxdWUgbGVuZ3RocyBmb3VuZCBpbiB0aGUgaW5wdXQgdmVjdG9yczogJyArXG4gICAgICAgICAgICAgICAgICAgIChcIihcIiArIHhzW2ldLnNoYXBlWzBdICsgXCIgdnMuIFwiICsgZGltICsgXCIpXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0SXNUZW5zb3IyRCA9IHRydWU7XG4gICAgICAgICAgICB4cyA9IG9wc18xLnNwbGl0KHhzLCB4cy5zaGFwZVswXSwgMCkubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBvcHNfMS5zcXVlZXplKHgsIFswXSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxfMS5hc3NlcnQoeHMubGVuZ3RoIDw9IHhzWzBdLnNoYXBlWzBdLCBcIkdyYW0tU2NobWlkdDogTnVtYmVyIG9mIHZlY3RvcnMgKFwiICsgeHMubGVuZ3RoICsgXCIpIGV4Y2VlZHMgXCIgK1xuICAgICAgICAgICAgKFwibnVtYmVyIG9mIGRpbWVuc2lvbnMgKFwiICsgeHNbMF0uc2hhcGVbMF0gKyBcIikuXCIpKTtcbiAgICAgICAgdmFyIHlzID0gW107XG4gICAgICAgIHZhciB4czFkID0geHM7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHlzLnB1c2godHJhY2tpbmdfMS5UcmFja2luZy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHhzMWRbaV07XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvaiA9IG9wc18xLnN1bSh5c1tqXS5tdWxTdHJpY3QoeCkpLm11bCh5c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0geC5zdWIocHJvaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguZGl2KG9wc18xLm5vcm0oeCwgJ2V1Y2xpZGVhbicpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRJc1RlbnNvcjJEKSB7XG4gICAgICAgICAgICByZXR1cm4gb3BzXzEuc3RhY2soeXMsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHlzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTGluZWFyIEFsZ2VicmEnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMaW5hbGdPcHMsIFwiZ3JhbVNjaG1pZHRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIExpbmFsZ09wcztcbn0oKSk7XG5leHBvcnRzLkxpbmFsZ09wcyA9IExpbmFsZ09wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmFsZ19vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdHlwZXMgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgTG9naWNhbE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9naWNhbE9wcygpIHtcbiAgICB9XG4gICAgTG9naWNhbE9wcy5sb2dpY2FsTm90ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbG9naWNhbE5vdCcpO1xuICAgICAgICB1dGlsLmFzc2VydCh4LmR0eXBlID09PSAnYm9vbCcsICdFcnJvciBBcnJheSBtdXN0IGJlIG9mIHR5cGUgYm9vbC4nKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubG9naWNhbE5vdCh4KTsgfSwgeyB4OiB4IH0pO1xuICAgIH07XG4gICAgTG9naWNhbE9wcy5sb2dpY2FsQW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnbG9naWNhbEFuZCcpO1xuICAgICAgICB1dGlsLmFzc2VydChhLmR0eXBlID09PSAnYm9vbCcgJiYgYi5kdHlwZSA9PT0gJ2Jvb2wnLCAnRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuJyk7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sb2dpY2FsQW5kKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBMb2dpY2FsT3BzLmxvZ2ljYWxPciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2xvZ2ljYWxPcicpO1xuICAgICAgICB1dGlsLmFzc2VydChhLmR0eXBlID09PSAnYm9vbCcgJiYgYi5kdHlwZSA9PT0gJ2Jvb2wnLCAnRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuJyk7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sb2dpY2FsT3IoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIExvZ2ljYWxPcHMubG9naWNhbFhvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2xvZ2ljYWxYb3InKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5kdHlwZSA9PT0gJ2Jvb2wnICYmIGIuZHR5cGUgPT09ICdib29sJywgJ0Vycm9yIEFycmF5IG11c3QgYmUgb2YgdHlwZSBib29sLicpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIExvZ2ljYWxPcHMubG9naWNhbE9yKGEsIGIpLmxvZ2ljYWxBbmQoTG9naWNhbE9wcy5sb2dpY2FsQW5kKGEsIGIpLmxvZ2ljYWxOb3QoKSk7XG4gICAgfTtcbiAgICBMb2dpY2FsT3BzLndoZXJlID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBjb25kaXRpb246IGNvbmRpdGlvbiwgYTogYSwgYjogYiB9LCAnd2hlcmUnKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoY29uZGl0aW9uLmR0eXBlID09PSAnYm9vbCcsICdFcnJvciBDb25kaXRpb24gbXVzdCBiZSBvZiB0eXBlIGJvb2wuJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHdoZXJlOiAnKTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChjb25kaXRpb24uc2hhcGVbMF0gPT09IGEuc2hhcGVbMF0sICdUaGUgZmlyc3QgZGltZW5zaW9uIG9mIGBhYCBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIGBjb25kaXRpb25gLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChjb25kaXRpb24uc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiB3aGVyZTogJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR0eXBlID0gdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQud2hlcmUoY29uZGl0aW9uLCBhLCBiLCBkdHlwZSk7IH0sIHsgY29uZGl0aW9uOiBjb25kaXRpb24sIGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvZ2ljYWxPcHMsIFwibG9naWNhbE5vdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvZ2ljYWxPcHMsIFwibG9naWNhbEFuZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvZ2ljYWxPcHMsIFwibG9naWNhbE9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9naWNhbE9wcywgXCJsb2dpY2FsWG9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9naWNhbE9wcywgXCJ3aGVyZVwiLCBudWxsKTtcbiAgICByZXR1cm4gTG9naWNhbE9wcztcbn0oKSk7XG5leHBvcnRzLkxvZ2ljYWxPcHMgPSBMb2dpY2FsT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9naWNhbF9vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi9vcHNcIik7XG52YXIgUmVkdWN0aW9uO1xuKGZ1bmN0aW9uIChSZWR1Y3Rpb24pIHtcbiAgICBSZWR1Y3Rpb25bUmVkdWN0aW9uW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgUmVkdWN0aW9uW1JlZHVjdGlvbltcIk1FQU5cIl0gPSAxXSA9IFwiTUVBTlwiO1xuICAgIFJlZHVjdGlvbltSZWR1Y3Rpb25bXCJTVU1cIl0gPSAyXSA9IFwiU1VNXCI7XG4gICAgUmVkdWN0aW9uW1JlZHVjdGlvbltcIlNVTV9CWV9OT05aRVJPX1dFSUdIVFNcIl0gPSAzXSA9IFwiU1VNX0JZX05PTlpFUk9fV0VJR0hUU1wiO1xufSkoUmVkdWN0aW9uID0gZXhwb3J0cy5SZWR1Y3Rpb24gfHwgKGV4cG9ydHMuUmVkdWN0aW9uID0ge30pKTtcbnZhciBMb3NzT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb3NzT3BzKCkge1xuICAgIH1cbiAgICBMb3NzT3BzLmNvbXB1dGVXZWlnaHRlZExvc3MgPSBmdW5jdGlvbiAobG9zc2VzLCB3ZWlnaHRzLCByZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKHJlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IHJlZHVjdGlvbiA9IFJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxvc3NlczogbG9zc2VzIH0sICdjb21wdXRlV2VpZ2h0ZWRMb3NzJyk7XG4gICAgICAgIGlmICh3ZWlnaHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHdlaWdodHM6IHdlaWdodHMgfSwgJ2NvbXB1dGVXZWlnaHRlZExvc3MnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2VpZ2h0ZWRMb3NzID0gKHdlaWdodHMgPT0gbnVsbCkgPyBsb3NzZXMgOiBsb3NzZXMubXVsKHdlaWdodHMpO1xuICAgICAgICBpZiAocmVkdWN0aW9uID09PSBSZWR1Y3Rpb24uTk9ORSkge1xuICAgICAgICAgICAgcmV0dXJuIHdlaWdodGVkTG9zcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVkdWN0aW9uID09PSBSZWR1Y3Rpb24uU1VNKSB7XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRMb3NzLnN1bSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWR1Y3Rpb24gPT09IFJlZHVjdGlvbi5NRUFOKSB7XG4gICAgICAgICAgICByZXR1cm4gKHdlaWdodHMgPT0gbnVsbCkgPyB3ZWlnaHRlZExvc3MubWVhbigpIDpcbiAgICAgICAgICAgICAgICB3ZWlnaHRlZExvc3Muc3VtKCkuZGl2KHdlaWdodHMuc3VtKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWR1Y3Rpb24gPT09IFJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKSB7XG4gICAgICAgICAgICBpZiAod2VpZ2h0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlaWdodGVkTG9zcy5zdW0oKS5kaXYob3BzLnNjYWxhcihsb3NzZXMuc2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bU5vblplcm9zID0gd2VpZ2h0cy5ub3RFcXVhbChvcHMuc2NhbGFyKDApKS5zdW0oKS50b0Zsb2F0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlaWdodGVkTG9zcy5zdW0oKS5kaXYobnVtTm9uWmVyb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biByZWR1Y3Rpb246IFwiICsgcmVkdWN0aW9uKTtcbiAgICB9O1xuICAgIExvc3NPcHMuYWJzb2x1dGVEaWZmZXJlbmNlID0gZnVuY3Rpb24gKGxhYmVscywgcHJlZGljdGlvbnMsIHdlaWdodHMsIHJlZHVjdGlvbikge1xuICAgICAgICBpZiAocmVkdWN0aW9uID09PSB2b2lkIDApIHsgcmVkdWN0aW9uID0gUmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFM7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgbGFiZWxzOiBsYWJlbHMsIHByZWRpY3Rpb25zOiBwcmVkaWN0aW9ucyB9LCAnYWJzb2x1dGVEaWZmZXJlbmNlJyk7XG4gICAgICAgIGlmICh3ZWlnaHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHdlaWdodHM6IHdlaWdodHMgfSwgJ2Fic29sdXRlRGlmZmVyZW5jZScpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gobGFiZWxzLnNoYXBlLCBwcmVkaWN0aW9ucy5zaGFwZSwgJ0Vycm9yIGluIGFic29sdXRlRGlmZmVyZW5jZTogJyk7XG4gICAgICAgIHZhciBsb3NzZXMgPSBsYWJlbHMuc3ViKHByZWRpY3Rpb25zKS5hYnMoKTtcbiAgICAgICAgcmV0dXJuIExvc3NPcHMuY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzZXMsIHdlaWdodHMsIHJlZHVjdGlvbik7XG4gICAgfTtcbiAgICBMb3NzT3BzLm1lYW5TcXVhcmVkRXJyb3IgPSBmdW5jdGlvbiAobGFiZWxzLCBwcmVkaWN0aW9ucywgd2VpZ2h0cywgcmVkdWN0aW9uKSB7XG4gICAgICAgIGlmIChyZWR1Y3Rpb24gPT09IHZvaWQgMCkgeyByZWR1Y3Rpb24gPSBSZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUzsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBsYWJlbHM6IGxhYmVscywgcHJlZGljdGlvbnM6IHByZWRpY3Rpb25zIH0sICdtZWFuU3F1YXJlZEVycm9yJyk7XG4gICAgICAgIGlmICh3ZWlnaHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHdlaWdodHM6IHdlaWdodHMgfSwgJ21lYW5TcXVhcmVkRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGxhYmVscy5zaGFwZSwgcHJlZGljdGlvbnMuc2hhcGUsICdFcnJvciBpbiBtZWFuU3F1YXJlZEVycm9yOiAnKTtcbiAgICAgICAgdmFyIGxvc3NlcyA9IGxhYmVscy5zcXVhcmVkRGlmZmVyZW5jZShwcmVkaWN0aW9ucyk7XG4gICAgICAgIHJldHVybiBMb3NzT3BzLmNvbXB1dGVXZWlnaHRlZExvc3MobG9zc2VzLCB3ZWlnaHRzLCByZWR1Y3Rpb24pO1xuICAgIH07XG4gICAgTG9zc09wcy5jb3NpbmVEaXN0YW5jZSA9IGZ1bmN0aW9uIChsYWJlbHMsIHByZWRpY3Rpb25zLCBheGlzLCB3ZWlnaHRzLCByZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKHJlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IHJlZHVjdGlvbiA9IFJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxhYmVsczogbGFiZWxzLCBwcmVkaWN0aW9uczogcHJlZGljdGlvbnMgfSwgJ2Nvc2luZURpc3RhbmNlJyk7XG4gICAgICAgIGlmICh3ZWlnaHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHdlaWdodHM6IHdlaWdodHMgfSwgJ2Nvc2luZURpc3RhbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChsYWJlbHMuc2hhcGUsIHByZWRpY3Rpb25zLnNoYXBlLCAnRXJyb3IgaW4gY29zaW5lRGlzdGFuY2U6ICcpO1xuICAgICAgICB2YXIgb25lID0gb3BzLnNjYWxhcigxKTtcbiAgICAgICAgdmFyIGxvc3NlcyA9IG9uZS5zdWIobGFiZWxzLm11bChwcmVkaWN0aW9ucykuc3VtKGF4aXMsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuIExvc3NPcHMuY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzZXMsIHdlaWdodHMsIHJlZHVjdGlvbik7XG4gICAgfTtcbiAgICBMb3NzT3BzLmhpbmdlTG9zcyA9IGZ1bmN0aW9uIChsYWJlbHMsIHByZWRpY3Rpb25zLCB3ZWlnaHRzLCByZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKHJlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IHJlZHVjdGlvbiA9IFJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxhYmVsczogbGFiZWxzLCBwcmVkaWN0aW9uczogcHJlZGljdGlvbnMgfSwgJ2hpbmdlTG9zcycpO1xuICAgICAgICBpZiAod2VpZ2h0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB3ZWlnaHRzOiB3ZWlnaHRzIH0sICdoaW5nZUxvc3MnKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGxhYmVscy5zaGFwZSwgcHJlZGljdGlvbnMuc2hhcGUsICdFcnJvciBpbiBoaW5nZUxvc3M6ICcpO1xuICAgICAgICB2YXIgb25lID0gb3BzLnNjYWxhcigxKTtcbiAgICAgICAgbGFiZWxzID0gb3BzLnNjYWxhcigyKS5tdWwobGFiZWxzKS5zdWIob25lKTtcbiAgICAgICAgdmFyIGxvc3NlcyA9IG9uZS5zdWIobGFiZWxzLm11bChwcmVkaWN0aW9ucykpLnJlbHUoKTtcbiAgICAgICAgcmV0dXJuIExvc3NPcHMuY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzZXMsIHdlaWdodHMsIHJlZHVjdGlvbik7XG4gICAgfTtcbiAgICBMb3NzT3BzLmxvZ0xvc3MgPSBmdW5jdGlvbiAobGFiZWxzLCBwcmVkaWN0aW9ucywgd2VpZ2h0cywgZXBzaWxvbiwgcmVkdWN0aW9uKSB7XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTc7IH1cbiAgICAgICAgaWYgKHJlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IHJlZHVjdGlvbiA9IFJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxhYmVsczogbGFiZWxzLCBwcmVkaWN0aW9uczogcHJlZGljdGlvbnMgfSwgJ2xvZ0xvc3MnKTtcbiAgICAgICAgaWYgKHdlaWdodHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgd2VpZ2h0czogd2VpZ2h0cyB9LCAnbG9nTG9zcycpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gobGFiZWxzLnNoYXBlLCBwcmVkaWN0aW9ucy5zaGFwZSwgJ0Vycm9yIGluIGxvZ0xvc3M6ICcpO1xuICAgICAgICB2YXIgb25lID0gb3BzLnNjYWxhcigxKTtcbiAgICAgICAgdmFyIGVwc2lsb25TY2FsYXIgPSBvcHMuc2NhbGFyKGVwc2lsb24pO1xuICAgICAgICB2YXIgbG9zc2VzID0gbGFiZWxzLm11bChwcmVkaWN0aW9ucy5hZGQoZXBzaWxvblNjYWxhcikubG9nKCkpXG4gICAgICAgICAgICAubmVnKClcbiAgICAgICAgICAgIC5zdWIob25lLnN1YihsYWJlbHMpLm11bChvbmUuc3ViKHByZWRpY3Rpb25zKS5hZGQoZXBzaWxvblNjYWxhcikubG9nKCkpKTtcbiAgICAgICAgcmV0dXJuIExvc3NPcHMuY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzZXMsIHdlaWdodHMsIHJlZHVjdGlvbik7XG4gICAgfTtcbiAgICBMb3NzT3BzLmh1YmVyTG9zcyA9IGZ1bmN0aW9uIChsYWJlbHMsIHByZWRpY3Rpb25zLCB3ZWlnaHRzLCBkZWx0YSwgcmVkdWN0aW9uKSB7XG4gICAgICAgIGlmIChkZWx0YSA9PT0gdm9pZCAwKSB7IGRlbHRhID0gMS4wOyB9XG4gICAgICAgIGlmIChyZWR1Y3Rpb24gPT09IHZvaWQgMCkgeyByZWR1Y3Rpb24gPSBSZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUzsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBsYWJlbHM6IGxhYmVscywgcHJlZGljdGlvbnM6IHByZWRpY3Rpb25zIH0sICdodWJlckxvc3MnKTtcbiAgICAgICAgaWYgKHdlaWdodHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgd2VpZ2h0czogd2VpZ2h0cyB9LCAnaHViZXJMb3NzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChsYWJlbHMuc2hhcGUsIHByZWRpY3Rpb25zLnNoYXBlLCAnRXJyb3IgaW4gaHViZXJMb3NzOiAnKTtcbiAgICAgICAgdmFyIGRlbHRhU2NhbGFyID0gb3BzLnNjYWxhcihkZWx0YSk7XG4gICAgICAgIHZhciBlcnJvciA9IHByZWRpY3Rpb25zLnN1YihsYWJlbHMpLmFicygpO1xuICAgICAgICB2YXIgcXVhZHJhdGljID0gb3BzLm1pbmltdW0oZXJyb3IsIGRlbHRhU2NhbGFyKTtcbiAgICAgICAgdmFyIGxpbmVhciA9IGVycm9yLnN1YihxdWFkcmF0aWMpO1xuICAgICAgICB2YXIgbG9zc2VzID0gb3BzLnNjYWxhcigwLjUpLm11bChxdWFkcmF0aWMuc3F1YXJlKCkpLmFkZChkZWx0YVNjYWxhci5tdWwobGluZWFyKSk7XG4gICAgICAgIHJldHVybiBMb3NzT3BzLmNvbXB1dGVXZWlnaHRlZExvc3MobG9zc2VzLCB3ZWlnaHRzLCByZWR1Y3Rpb24pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdMb3NzZXMnLCBuYW1lc3BhY2U6ICdsb3NzZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMb3NzT3BzLCBcImNvbXB1dGVXZWlnaHRlZExvc3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdMb3NzZXMnLCBuYW1lc3BhY2U6ICdsb3NzZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMb3NzT3BzLCBcImFic29sdXRlRGlmZmVyZW5jZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0xvc3NlcycsIG5hbWVzcGFjZTogJ2xvc3NlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvc3NPcHMsIFwibWVhblNxdWFyZWRFcnJvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0xvc3NlcycsIG5hbWVzcGFjZTogJ2xvc3NlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvc3NPcHMsIFwiY29zaW5lRGlzdGFuY2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdMb3NzZXMnLCBuYW1lc3BhY2U6ICdsb3NzZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMb3NzT3BzLCBcImhpbmdlTG9zc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0xvc3NlcycsIG5hbWVzcGFjZTogJ2xvc3NlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvc3NPcHMsIFwibG9nTG9zc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0xvc3NlcycsIG5hbWVzcGFjZTogJ2xvc3NlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvc3NPcHMsIFwiaHViZXJMb3NzXCIsIG51bGwpO1xuICAgIHJldHVybiBMb3NzT3BzO1xufSgpKTtcbmV4cG9ydHMuTG9zc09wcyA9IExvc3NPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb3NzX29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgTFJOT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMUk5PcHMoKSB7XG4gICAgfVxuICAgIExSTk9wcy5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uICh4LCBkZXB0aFJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEpIHtcbiAgICAgICAgaWYgKGRlcHRoUmFkaXVzID09PSB2b2lkIDApIHsgZGVwdGhSYWRpdXMgPSA1OyB9XG4gICAgICAgIGlmIChiaWFzID09PSB2b2lkIDApIHsgYmlhcyA9IDE7IH1cbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAxOyB9XG4gICAgICAgIGlmIChiZXRhID09PSB2b2lkIDApIHsgYmV0YSA9IDAuNTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbicpO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDQgfHwgeC5yYW5rID09PSAzLCBcIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiB4IG11c3QgYmUgcmFuayAzIG9yIDQgYnV0IGdvdFxcbiAgICAgICAgICAgICAgIHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQoZGVwdGhSYWRpdXMpLCBcIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiBkZXB0aFJhZGl1cyBtdXN0IGJlIGFuIGludGVnZXJcXG4gICAgICAgICAgICAgICAgICAgICBidXQgZ290IGRlcHRoUmFkaXVzIFwiICsgZGVwdGhSYWRpdXMgKyBcIi5cIik7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RCh4NEQsIGRlcHRoUmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSk7IH0sIHsgeDREOiB4NEQgfSk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdOb3JtYWxpemF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTFJOT3BzLCBcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIsIG51bGwpO1xuICAgIHJldHVybiBMUk5PcHM7XG59KCkpO1xuZXhwb3J0cy5MUk5PcHMgPSBMUk5PcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1scm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBMU1RNT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMU1RNT3BzKCkge1xuICAgIH1cbiAgICBMU1RNT3BzLm11bHRpUk5OQ2VsbCA9IGZ1bmN0aW9uIChsc3RtQ2VsbHMsIGRhdGEsIGMsIGgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgZGF0YTogZGF0YSwgYzogYywgaDogaCB9LCAnbXVsdGlSTk5DZWxsJyk7XG4gICAgICAgIHZhciBpbnB1dCA9IGRhdGE7XG4gICAgICAgIHZhciBuZXdTdGF0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3RtQ2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBsc3RtQ2VsbHNbaV0oaW5wdXQsIGNbaV0sIGhbaV0pO1xuICAgICAgICAgICAgbmV3U3RhdGVzLnB1c2gob3V0cHV0WzBdKTtcbiAgICAgICAgICAgIG5ld1N0YXRlcy5wdXNoKG91dHB1dFsxXSk7XG4gICAgICAgICAgICBpbnB1dCA9IG91dHB1dFsxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3QyA9IFtdO1xuICAgICAgICB2YXIgbmV3SCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1N0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbmV3Qy5wdXNoKG5ld1N0YXRlc1tpXSk7XG4gICAgICAgICAgICBuZXdILnB1c2gobmV3U3RhdGVzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtuZXdDLCBuZXdIXTtcbiAgICB9O1xuICAgIExTVE1PcHMuYmFzaWNMU1RNQ2VsbCA9IGZ1bmN0aW9uIChmb3JnZXRCaWFzLCBsc3RtS2VybmVsLCBsc3RtQmlhcywgZGF0YSwgYywgaCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBmb3JnZXRCaWFzOiBmb3JnZXRCaWFzLCBsc3RtS2VybmVsOiBsc3RtS2VybmVsLCBsc3RtQmlhczogbHN0bUJpYXMsIGRhdGE6IGRhdGEsIGM6IGMsIGg6IGggfSwgJ2Jhc2ljTFNUTUNlbGwnKTtcbiAgICAgICAgdmFyIGNvbWJpbmVkID0gZGF0YS5jb25jYXQoaCwgMSk7XG4gICAgICAgIHZhciB3ZWlnaHRlZCA9IGNvbWJpbmVkLm1hdE11bChsc3RtS2VybmVsKTtcbiAgICAgICAgdmFyIHJlcyA9IHdlaWdodGVkLmFkZChsc3RtQmlhcyk7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSByZXMuc2hhcGVbMF07XG4gICAgICAgIHZhciBzbGljZUNvbHMgPSByZXMuc2hhcGVbMV0gLyA0O1xuICAgICAgICB2YXIgc2xpY2VTaXplID0gW2JhdGNoU2l6ZSwgc2xpY2VDb2xzXTtcbiAgICAgICAgdmFyIGkgPSByZXMuc2xpY2UoWzAsIDBdLCBzbGljZVNpemUpO1xuICAgICAgICB2YXIgaiA9IHJlcy5zbGljZShbMCwgc2xpY2VDb2xzXSwgc2xpY2VTaXplKTtcbiAgICAgICAgdmFyIGYgPSByZXMuc2xpY2UoWzAsIHNsaWNlQ29scyAqIDJdLCBzbGljZVNpemUpO1xuICAgICAgICB2YXIgbyA9IHJlcy5zbGljZShbMCwgc2xpY2VDb2xzICogM10sIHNsaWNlU2l6ZSk7XG4gICAgICAgIHZhciBuZXdDID0gaS5zaWdtb2lkKCkubXVsU3RyaWN0KGoudGFuaCgpKS5hZGRTdHJpY3QoYy5tdWxTdHJpY3QoZm9yZ2V0Qmlhcy5hZGQoZikuc2lnbW9pZCgpKSk7XG4gICAgICAgIHZhciBuZXdIID0gbmV3Qy50YW5oKCkubXVsU3RyaWN0KG8uc2lnbW9pZCgpKTtcbiAgICAgICAgcmV0dXJuIFtuZXdDLCBuZXdIXTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSTk4nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMU1RNT3BzLCBcIm11bHRpUk5OQ2VsbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUk5OJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTFNUTU9wcywgXCJiYXNpY0xTVE1DZWxsXCIsIG51bGwpO1xuICAgIHJldHVybiBMU1RNT3BzO1xufSgpKTtcbmV4cG9ydHMuTFNUTU9wcyA9IExTVE1PcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sc3RtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBNYXRtdWxPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdG11bE9wcygpIHtcbiAgICB9XG4gICAgTWF0bXVsT3BzLm1hdE11bCA9IGZ1bmN0aW9uIChhLCBiLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKSB7XG4gICAgICAgIGlmICh0cmFuc3Bvc2VBID09PSB2b2lkIDApIHsgdHJhbnNwb3NlQSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0cmFuc3Bvc2VCID09PSB2b2lkIDApIHsgdHJhbnNwb3NlQiA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ21hdE11bCcpO1xuICAgICAgICB2YXIgaW5uZXJTaGFwZUEgPSB0cmFuc3Bvc2VBID8gYS5zaGFwZVswXSA6IGEuc2hhcGVbMV07XG4gICAgICAgIHZhciBpbm5lclNoYXBlQiA9IHRyYW5zcG9zZUIgPyBiLnNoYXBlWzFdIDogYi5zaGFwZVswXTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5yYW5rID09PSAyICYmIGIucmFuayA9PT0gMiwgXCJFcnJvciBpbiBtYXRNdWw6IGlucHV0cyBtdXN0IGJlIHJhbmsgMiwgZ290IHJhbmtzIFwiICsgYS5yYW5rICtcbiAgICAgICAgICAgIChcIiBhbmQgXCIgKyBiLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChpbm5lclNoYXBlQSA9PT0gaW5uZXJTaGFwZUIsIFwiRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKFwiICsgaW5uZXJTaGFwZUEgKyBcIikgYW5kIChcIiArXG4gICAgICAgICAgICAoaW5uZXJTaGFwZUIgKyBcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIiArIGEuc2hhcGUgKyBcIiBhbmQgXCIpICtcbiAgICAgICAgICAgIChiLnNoYXBlICsgXCIgYW5kIHRyYW5zcG9zZUE9XCIgKyB0cmFuc3Bvc2VBKSArXG4gICAgICAgICAgICAoXCIgYW5kIHRyYW5zcG9zZUI9XCIgKyB0cmFuc3Bvc2VCICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgaWYgKCF0cmFuc3Bvc2VBICYmICF0cmFuc3Bvc2VCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubWF0TXVsKGIudG9GbG9hdCgpLCBmYWxzZSwgdHJ1ZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIGI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGEudG9GbG9hdCgpLm1hdE11bChkeSwgdHJ1ZSwgZmFsc2UpOyB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0cmFuc3Bvc2VBICYmIHRyYW5zcG9zZUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tYXRNdWwoYi50b0Zsb2F0KCksIGZhbHNlLCBmYWxzZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIGI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm1hdE11bChhLnRvRmxvYXQoKSwgdHJ1ZSwgZmFsc2UpOyB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zcG9zZUEgJiYgIXRyYW5zcG9zZUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhOiBmdW5jdGlvbiAoKSB7IHJldHVybiBiLnRvRmxvYXQoKS5tYXRNdWwoZHksIGZhbHNlLCB0cnVlKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgYjogZnVuY3Rpb24gKCkgeyByZXR1cm4gYS50b0Zsb2F0KCkubWF0TXVsKGR5LCBmYWxzZSwgZmFsc2UpOyB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGIudG9GbG9hdCgpLm1hdE11bChkeSwgdHJ1ZSwgdHJ1ZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIGI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm1hdE11bChhLnRvRmxvYXQoKSwgdHJ1ZSwgdHJ1ZSk7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tYXRNdWwoYSwgYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQik7IH0sIHsgYTogYSwgYjogYiB9LCBncmFkKTtcbiAgICB9O1xuICAgIE1hdG11bE9wcy52ZWN0b3JUaW1lc01hdHJpeCA9IGZ1bmN0aW9uICh2LCBtYXRyaXgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5yYW5rID09PSAxLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBmaXJzdCBpbnB1dCBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgdi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobWF0cml4LnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IHNlY29uZCBpbnB1dCBtdXN0IGJlIHJhbmsgMiwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgbWF0cml4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2LnNpemUgPT09IG1hdHJpeC5zaGFwZVswXSwgXCJFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2l6ZSBvZiB2ZWN0b3IgKFwiICsgdi5zaXplICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggZmlyc3QgZGltZW5zaW9uIG9mIG1hdHJpeCAoXCIgKyBtYXRyaXguc2hhcGVbMF0gKyBcIilcIikpO1xuICAgICAgICByZXR1cm4gdi5hczJEKDEsIC0xKS5tYXRNdWwobWF0cml4KS5hczFEKCk7XG4gICAgfTtcbiAgICBNYXRtdWxPcHMubWF0cml4VGltZXNWZWN0b3IgPSBmdW5jdGlvbiAobWF0cml4LCB2KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYucmFuayA9PT0gMSwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3Rvcjogc2Vjb25kIGlucHV0IG11c3QgcmFuayAxLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB2LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtYXRyaXgucmFuayA9PT0gMiwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3RvcjogZmlyc3QgaW5wdXQgbXVzdCBiZSBhIHJhbmsgMiwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgbWF0cml4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2LnNpemUgPT09IG1hdHJpeC5zaGFwZVsxXSwgXCJFcnJvciBpbiBtYXRyaXhUaW1lc1ZlY3Rvcjogc2l6ZSBvZiBmaXJzdCByYW5rIDEgaW5wdXQgXCIgKyB2LnNpemUgKyBcIiBcIiArXG4gICAgICAgICAgICBcIm11c3QgbWF0Y2ggaW5uZXIgZGltZW5zaW9uIG9mIHNlY29uZCByYW5rIDIgaW5wdXQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwic2hhcGUgXCIgKyBtYXRyaXguc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gbWF0cml4Lm1hdE11bCh2LmFzMkQoLTEsIDEpKS5hczFEKCk7XG4gICAgfTtcbiAgICBNYXRtdWxPcHMuZG90UHJvZHVjdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodjEucmFuayA9PT0gMSAmJiB2Mi5yYW5rID09PSAxLCBcIkVycm9yIGluIGRvdFByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIiArXG4gICAgICAgICAgICAodjEucmFuayArIFwiIGFuZCBcIiArIHYyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5zaXplID09PSB2Mi5zaXplLCBcIkVycm9yIGluIGRvdFByb2R1Y3Q6IHNpemUgb2YgaW5wdXRzIChcIiArIHYxLnNpemUgKyBcIikgYW5kIChcIiArXG4gICAgICAgICAgICAodjIuc2l6ZSArIFwiKSBtdXN0IG1hdGNoLlwiKSk7XG4gICAgICAgIHJldHVybiB2MS5hczJEKDEsIC0xKS5tYXRNdWwodjIuYXMyRCgtMSwgMSkpLmFzU2NhbGFyKCk7XG4gICAgfTtcbiAgICBNYXRtdWxPcHMub3V0ZXJQcm9kdWN0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5yYW5rID09PSAxICYmIHYyLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gb3V0ZXJQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgXCIgK1xuICAgICAgICAgICAgKHYxLnJhbmsgKyBcIiBhbmQgXCIgKyB2Mi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHYxLmFzMkQoLTEsIDEpLm1hdE11bCh2Mi5hczJEKDEsIC0xKSk7XG4gICAgfTtcbiAgICBNYXRtdWxPcHMuZG90ID0gZnVuY3Rpb24gKHQxLCB0Mikge1xuICAgICAgICB1dGlsLmFzc2VydCgodDEucmFuayA9PT0gMSB8fCB0MS5yYW5rID09PSAyKSAmJiAodDIucmFuayA9PT0gMSB8fCB0Mi5yYW5rID09PSAyKSwgXCJFcnJvciBpbiBkb3Q6IGlucHV0cyBtdXN0IGFsbCBiZSByYW5rIDEgb3IgMiwgYnV0IGdvdCByYW5rcyBcIiArXG4gICAgICAgICAgICAodDEucmFuayArIFwiIGFuZCBcIiArIHQyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB2YXIgdDFJbm5lciA9ICh0MS5yYW5rID09PSAxID8gdDEuc2l6ZSA6IHQxLnNoYXBlWzFdKTtcbiAgICAgICAgdmFyIHQySW5uZXIgPSAodDIucmFuayA9PT0gMSA/IHQyLnNpemUgOiB0Mi5zaGFwZVswXSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHQxSW5uZXIgPT09IHQySW5uZXIsIFwiRXJyb3IgaW4gZG90OiBpbm5lciBkaW1lbnNpb25zIG9mIGlucHV0cyBtdXN0IG1hdGNoLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgICh0MUlubmVyICsgXCIgYW5kIFwiICsgdDJJbm5lciArIFwiLlwiKSk7XG4gICAgICAgIGlmICh0MS5yYW5rID09PSAxICYmIHQyLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0MS5hczJEKDEsIC0xKS5tYXRNdWwodDIuYXMyRCgtMSwgMSkpLmFzU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodDEucmFuayA9PT0gMSAmJiB0Mi5yYW5rID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdDEuYXMyRCgxLCAtMSkubWF0TXVsKHQyLmFzMkQodDIuc2hhcGVbMF0sIHQyLnNoYXBlWzFdKSkuYXMxRCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQxLnJhbmsgPT09IDIgJiYgdDIucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHQxLm1hdE11bCh0Mi5hczJEKC0xLCAxKSkuYXMxRCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHQxLm1hdE11bCh0Mi5hczJEKHQyLnNoYXBlWzBdLCB0Mi5zaGFwZVsxXSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTWF0cmljZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBNYXRtdWxPcHMsIFwibWF0TXVsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBNYXRtdWxPcHMsIFwidmVjdG9yVGltZXNNYXRyaXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE1hdG11bE9wcywgXCJtYXRyaXhUaW1lc1ZlY3RvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTWF0bXVsT3BzLCBcImRvdFByb2R1Y3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ01hdHJpY2VzJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTWF0bXVsT3BzLCBcIm91dGVyUHJvZHVjdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTWF0cmljZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBNYXRtdWxPcHMsIFwiZG90XCIsIG51bGwpO1xuICAgIHJldHVybiBNYXRtdWxPcHM7XG59KCkpO1xuZXhwb3J0cy5NYXRtdWxPcHMgPSBNYXRtdWxPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRtdWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBhcnJheV9vcHNfMSA9IHJlcXVpcmUoXCIuL2FycmF5X29wc1wiKTtcbnZhciBiaW5hcnlfb3BzXzEgPSByZXF1aXJlKFwiLi9iaW5hcnlfb3BzXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIE1vdmluZ0F2ZXJhZ2VPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vdmluZ0F2ZXJhZ2VPcHMoKSB7XG4gICAgfVxuICAgIE1vdmluZ0F2ZXJhZ2VPcHMubW92aW5nQXZlcmFnZSA9IGZ1bmN0aW9uICh2LCB4LCBkZWNheSwgc3RlcCwgemVyb0RlYmlhcykge1xuICAgICAgICBpZiAoemVyb0RlYmlhcyA9PT0gdm9pZCAwKSB7IHplcm9EZWJpYXMgPSB0cnVlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHY6IHYsIHg6IHggfSwgJ21vdmluZ0F2ZXJhZ2UnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKHYsIHgpO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKHYuc2hhcGUsIHguc2hhcGUpLCAnU2hhcGUgbWlzbWF0Y2ggaW4gdiBhbmQgeCcpO1xuICAgICAgICB2YXIgb25lID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuc2NhbGFyKDEpO1xuICAgICAgICBkZWNheSA9IHR5cGVvZiBkZWNheSA9PT0gJ251bWJlcicgPyBhcnJheV9vcHNfMS5BcnJheU9wcy5zY2FsYXIoZGVjYXkpIDogZGVjYXk7XG4gICAgICAgIHZhciBvbmVNaW51c0RlY2F5ID0gb25lLnN1YihkZWNheSk7XG4gICAgICAgIHZhciB1cGRhdGUgPSB4LnN1Yih2KS5tdWwob25lTWludXNEZWNheSk7XG4gICAgICAgIGlmICh6ZXJvRGViaWFzKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChzdGVwICE9IG51bGwsICdXaGVuIHVzaW5nIHplcm9EZWJpYXM6IHRydWUsIHN0ZXAgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICBzdGVwID0gdHlwZW9mIHN0ZXAgPT09ICdudW1iZXInID8gYXJyYXlfb3BzXzEuQXJyYXlPcHMuc2NhbGFyKHN0ZXApIDogc3RlcDtcbiAgICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5kaXYob25lLnN1YihiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLnBvdyhkZWNheSwgc3RlcCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdi5hZGQodXBkYXRlKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdNb3ZpbmcgQXZlcmFnZScgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE1vdmluZ0F2ZXJhZ2VPcHMsIFwibW92aW5nQXZlcmFnZVwiLCBudWxsKTtcbiAgICByZXR1cm4gTW92aW5nQXZlcmFnZU9wcztcbn0oKSk7XG5leHBvcnRzLk1vdmluZ0F2ZXJhZ2VPcHMgPSBNb3ZpbmdBdmVyYWdlT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92aW5nX2F2ZXJhZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIE5vcm1PcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vcm1PcHMoKSB7XG4gICAgfVxuICAgIE5vcm1PcHMubm9ybSA9IGZ1bmN0aW9uICh4LCBvcmQsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChvcmQgPT09IHZvaWQgMCkgeyBvcmQgPSAnZXVjbGlkZWFuJzsgfVxuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbm9ybScpO1xuICAgICAgICB2YXIgbm9ybSA9IG5vcm1JbXBsKHgsIG9yZCwgYXhpcyk7XG4gICAgICAgIHZhciBrZWVwRGltc1NoYXBlID0gbm9ybS5zaGFwZTtcbiAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgICAgIGtlZXBEaW1zU2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0obm9ybS5zaGFwZSwgYXhlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm0ucmVzaGFwZShrZWVwRGltc1NoYXBlKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdNYXRyaWNlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE5vcm1PcHMsIFwibm9ybVwiLCBudWxsKTtcbiAgICByZXR1cm4gTm9ybU9wcztcbn0oKSk7XG5leHBvcnRzLk5vcm1PcHMgPSBOb3JtT3BzO1xuZnVuY3Rpb24gbm9ybUltcGwoeCwgcCwgYXhpcykge1xuICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICBpZiAoeC5yYW5rID09PSAwKSB7XG4gICAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH1cbiAgICBpZiAoeC5yYW5rICE9PSAxICYmIGF4aXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1JbXBsKHgucmVzaGFwZShbLTFdKSwgcCwgYXhpcyk7XG4gICAgfVxuICAgIGlmICh4LnJhbmsgPT09IDEgfHwgdHlwZW9mIGF4aXMgPT09ICdudW1iZXInIHx8XG4gICAgICAgIGF4aXMgaW5zdGFuY2VvZiBBcnJheSAmJiBheGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAocCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkuc3VtKGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkubWF4KGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmFicygpLm1pbihheGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gJ2V1Y2xpZGVhbicgfHwgcCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkucG93KG9wcy5zY2FsYXIoMiwgJ2ludDMyJykpLnN1bShheGlzKS5zcXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiICsgcCk7XG4gICAgfVxuICAgIGlmIChheGlzIGluc3RhbmNlb2YgQXJyYXkgJiYgYXhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmFicygpLnN1bShheGlzWzBdKS5tYXgoYXhpc1sxXSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkuc3VtKGF4aXNbMV0pLm1heChheGlzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5zdW0oYXhpc1sxXSkubWluKGF4aXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAnZnJvJyB8fCBwID09PSAnZXVjbGlkZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHguc3F1YXJlKCkuc3VtKGF4aXMpLnNxcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogXCIgKyBwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBheGlzOiBcIiArIGF4aXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbmZ1bmN0aW9uIG9wZXJhdGlvbih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbHNfMS50aWR5KG5hbWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KHZvaWQgMCwgYXJncyk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5leHBvcnRzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcnJheV9vcHNfMSA9IHJlcXVpcmUoXCIuL2FycmF5X29wc1wiKTtcbnZhciBiYXRjaG5vcm1fMSA9IHJlcXVpcmUoXCIuL2JhdGNobm9ybVwiKTtcbnZhciBiaW5hcnlfb3BzXzEgPSByZXF1aXJlKFwiLi9iaW5hcnlfb3BzXCIpO1xudmFyIGNvbXBhcmVfMSA9IHJlcXVpcmUoXCIuL2NvbXBhcmVcIik7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKFwiLi9jb25jYXRcIik7XG52YXIgY29udl8xID0gcmVxdWlyZShcIi4vY29udlwiKTtcbnZhciBpbWFnZV9vcHNfMSA9IHJlcXVpcmUoXCIuL2ltYWdlX29wc1wiKTtcbnZhciBsaW5hbGdfb3BzXzEgPSByZXF1aXJlKFwiLi9saW5hbGdfb3BzXCIpO1xudmFyIGxvZ2ljYWxfb3BzXzEgPSByZXF1aXJlKFwiLi9sb2dpY2FsX29wc1wiKTtcbnZhciBsb3NzX29wc18xID0gcmVxdWlyZShcIi4vbG9zc19vcHNcIik7XG52YXIgbHJuXzEgPSByZXF1aXJlKFwiLi9scm5cIik7XG52YXIgbHN0bV8xID0gcmVxdWlyZShcIi4vbHN0bVwiKTtcbnZhciBtYXRtdWxfMSA9IHJlcXVpcmUoXCIuL21hdG11bFwiKTtcbnZhciBtb3ZpbmdfYXZlcmFnZV8xID0gcmVxdWlyZShcIi4vbW92aW5nX2F2ZXJhZ2VcIik7XG52YXIgbm9ybV8xID0gcmVxdWlyZShcIi4vbm9ybVwiKTtcbnZhciBwb29sXzEgPSByZXF1aXJlKFwiLi9wb29sXCIpO1xudmFyIHJlZHVjdGlvbl9vcHNfMSA9IHJlcXVpcmUoXCIuL3JlZHVjdGlvbl9vcHNcIik7XG52YXIgcmV2ZXJzZV8xID0gcmVxdWlyZShcIi4vcmV2ZXJzZVwiKTtcbnZhciBzbGljZV8xID0gcmVxdWlyZShcIi4vc2xpY2VcIik7XG52YXIgc29mdG1heF8xID0gcmVxdWlyZShcIi4vc29mdG1heFwiKTtcbnZhciBzdHJpZGVkX3NsaWNlXzEgPSByZXF1aXJlKFwiLi9zdHJpZGVkX3NsaWNlXCIpO1xudmFyIHRyYW5zcG9zZV8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3NlXCIpO1xudmFyIHVuYXJ5X29wc18xID0gcmVxdWlyZShcIi4vdW5hcnlfb3BzXCIpO1xuZXhwb3J0cy5iYXRjaE5vcm1hbGl6YXRpb24gPSBiYXRjaG5vcm1fMS5CYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uO1xuZXhwb3J0cy5iYXRjaE5vcm1hbGl6YXRpb24yZCA9IGJhdGNobm9ybV8xLkJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24yZDtcbmV4cG9ydHMuYmF0Y2hOb3JtYWxpemF0aW9uM2QgPSBiYXRjaG5vcm1fMS5CYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uM2Q7XG5leHBvcnRzLmJhdGNoTm9ybWFsaXphdGlvbjRkID0gYmF0Y2hub3JtXzEuQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbjRkO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXRfMS5Db25jYXRPcHMuY29uY2F0O1xuZXhwb3J0cy5jb25jYXQxZCA9IGNvbmNhdF8xLkNvbmNhdE9wcy5jb25jYXQxZDtcbmV4cG9ydHMuY29uY2F0MmQgPSBjb25jYXRfMS5Db25jYXRPcHMuY29uY2F0MmQ7XG5leHBvcnRzLmNvbmNhdDNkID0gY29uY2F0XzEuQ29uY2F0T3BzLmNvbmNhdDNkO1xuZXhwb3J0cy5jb25jYXQ0ZCA9IGNvbmNhdF8xLkNvbmNhdE9wcy5jb25jYXQ0ZDtcbmV4cG9ydHMuY29udjFkID0gY29udl8xLkNvbnZPcHMuY29udjFkO1xuZXhwb3J0cy5jb252MmQgPSBjb252XzEuQ29udk9wcy5jb252MmQ7XG5leHBvcnRzLmNvbnYyZFRyYW5zcG9zZSA9IGNvbnZfMS5Db252T3BzLmNvbnYyZFRyYW5zcG9zZTtcbmV4cG9ydHMuZGVwdGh3aXNlQ29udjJkID0gY29udl8xLkNvbnZPcHMuZGVwdGh3aXNlQ29udjJkO1xuZXhwb3J0cy5zZXBhcmFibGVDb252MmQgPSBjb252XzEuQ29udk9wcy5zZXBhcmFibGVDb252MmQ7XG5leHBvcnRzLm1hdE11bCA9IG1hdG11bF8xLk1hdG11bE9wcy5tYXRNdWw7XG5leHBvcnRzLm1hdHJpeFRpbWVzVmVjdG9yID0gbWF0bXVsXzEuTWF0bXVsT3BzLm1hdHJpeFRpbWVzVmVjdG9yO1xuZXhwb3J0cy5vdXRlclByb2R1Y3QgPSBtYXRtdWxfMS5NYXRtdWxPcHMub3V0ZXJQcm9kdWN0O1xuZXhwb3J0cy52ZWN0b3JUaW1lc01hdHJpeCA9IG1hdG11bF8xLk1hdG11bE9wcy52ZWN0b3JUaW1lc01hdHJpeDtcbmV4cG9ydHMuZG90ID0gbWF0bXVsXzEuTWF0bXVsT3BzLmRvdDtcbmV4cG9ydHMuYXZnUG9vbCA9IHBvb2xfMS5Qb29sT3BzLmF2Z1Bvb2w7XG5leHBvcnRzLm1heFBvb2wgPSBwb29sXzEuUG9vbE9wcy5tYXhQb29sO1xuZXhwb3J0cy50cmFuc3Bvc2UgPSB0cmFuc3Bvc2VfMS5UcmFuc3Bvc2VPcHMudHJhbnNwb3NlO1xuZXhwb3J0cy5yZXZlcnNlID0gcmV2ZXJzZV8xLlJldmVyc2VPcHMucmV2ZXJzZTtcbmV4cG9ydHMucmV2ZXJzZTFkID0gcmV2ZXJzZV8xLlJldmVyc2VPcHMucmV2ZXJzZTFkO1xuZXhwb3J0cy5yZXZlcnNlMmQgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlMmQ7XG5leHBvcnRzLnJldmVyc2UzZCA9IHJldmVyc2VfMS5SZXZlcnNlT3BzLnJldmVyc2UzZDtcbmV4cG9ydHMucmV2ZXJzZTRkID0gcmV2ZXJzZV8xLlJldmVyc2VPcHMucmV2ZXJzZTRkO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2U7XG5leHBvcnRzLnNsaWNlMWQgPSBzbGljZV8xLlNsaWNlT3BzLnNsaWNlMWQ7XG5leHBvcnRzLnNsaWNlMmQgPSBzbGljZV8xLlNsaWNlT3BzLnNsaWNlMmQ7XG5leHBvcnRzLnNsaWNlM2QgPSBzbGljZV8xLlNsaWNlT3BzLnNsaWNlM2Q7XG5leHBvcnRzLnNsaWNlNGQgPSBzbGljZV8xLlNsaWNlT3BzLnNsaWNlNGQ7XG5leHBvcnRzLnN0cmlkZWRTbGljZSA9IHN0cmlkZWRfc2xpY2VfMS5TdHJpZGVkU2xpY2VPcHMuc3RyaWRlZFNsaWNlO1xuZXhwb3J0cy5hcmdNYXggPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLmFyZ01heDtcbmV4cG9ydHMuYXJnTWluID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5hcmdNaW47XG5leHBvcnRzLmxvZ1N1bUV4cCA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMubG9nU3VtRXhwO1xuZXhwb3J0cy5tYXggPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLm1heDtcbmV4cG9ydHMubWVhbiA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMubWVhbjtcbmV4cG9ydHMubWluID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5taW47XG5leHBvcnRzLm1vbWVudHMgPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLm1vbWVudHM7XG5leHBvcnRzLnN1bSA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMuc3VtO1xuZXhwb3J0cy51bnNvcnRlZFNlZ21lbnRTdW0gPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLnVuc29ydGVkU2VnbWVudFN1bTtcbmV4cG9ydHMuZXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5lcXVhbDtcbmV4cG9ydHMuZXF1YWxTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5lcXVhbFN0cmljdDtcbmV4cG9ydHMuZ3JlYXRlciA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmdyZWF0ZXI7XG5leHBvcnRzLmdyZWF0ZXJTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ncmVhdGVyU3RyaWN0O1xuZXhwb3J0cy5ncmVhdGVyRXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ncmVhdGVyRXF1YWw7XG5leHBvcnRzLmdyZWF0ZXJFcXVhbFN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmdyZWF0ZXJFcXVhbFN0cmljdDtcbmV4cG9ydHMubGVzcyA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3M7XG5leHBvcnRzLmxlc3NTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5sZXNzU3RyaWN0O1xuZXhwb3J0cy5sZXNzRXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5sZXNzRXF1YWw7XG5leHBvcnRzLmxlc3NFcXVhbFN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3NFcXVhbFN0cmljdDtcbmV4cG9ydHMubm90RXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ub3RFcXVhbDtcbmV4cG9ydHMubm90RXF1YWxTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ub3RFcXVhbFN0cmljdDtcbmV4cG9ydHMubG9naWNhbE5vdCA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy5sb2dpY2FsTm90O1xuZXhwb3J0cy5sb2dpY2FsQW5kID0gbG9naWNhbF9vcHNfMS5Mb2dpY2FsT3BzLmxvZ2ljYWxBbmQ7XG5leHBvcnRzLmxvZ2ljYWxPciA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy5sb2dpY2FsT3I7XG5leHBvcnRzLmxvZ2ljYWxYb3IgPSBsb2dpY2FsX29wc18xLkxvZ2ljYWxPcHMubG9naWNhbFhvcjtcbmV4cG9ydHMud2hlcmUgPSBsb2dpY2FsX29wc18xLkxvZ2ljYWxPcHMud2hlcmU7XG5leHBvcnRzLmFicyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmFicztcbmV4cG9ydHMuYWNvcyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmFjb3M7XG5leHBvcnRzLmFjb3NoID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuYWNvc2g7XG5leHBvcnRzLmFzaW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5hc2luO1xuZXhwb3J0cy5hc2luaCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmFzaW5oO1xuZXhwb3J0cy5hdGFuID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuYXRhbjtcbmV4cG9ydHMuYXRhbmggPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5hdGFuaDtcbmV4cG9ydHMuY2VpbCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmNlaWw7XG5leHBvcnRzLmNsaXBCeVZhbHVlID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuY2xpcEJ5VmFsdWU7XG5leHBvcnRzLmNvcyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmNvcztcbmV4cG9ydHMuY29zaCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmNvc2g7XG5leHBvcnRzLmVsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmVsdTtcbmV4cG9ydHMuZXhwID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuZXhwO1xuZXhwb3J0cy5leHBtMSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmV4cG0xO1xuZXhwb3J0cy5mbG9vciA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmZsb29yO1xuZXhwb3J0cy5zaWduID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc2lnbjtcbmV4cG9ydHMubGVha3lSZWx1ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMubGVha3lSZWx1O1xuZXhwb3J0cy5sb2cgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5sb2c7XG5leHBvcnRzLmxvZzFwID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMubG9nMXA7XG5leHBvcnRzLmxvZ1NpZ21vaWQgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5sb2dTaWdtb2lkO1xuZXhwb3J0cy5uZWcgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5uZWc7XG5leHBvcnRzLnByZWx1ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMucHJlbHU7XG5leHBvcnRzLnJlbHUgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5yZWx1O1xuZXhwb3J0cy5yZWNpcHJvY2FsID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMucmVjaXByb2NhbDtcbmV4cG9ydHMucm91bmQgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5yb3VuZDtcbmV4cG9ydHMuc2VsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNlbHU7XG5leHBvcnRzLnNpZ21vaWQgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zaWdtb2lkO1xuZXhwb3J0cy5zaW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zaW47XG5leHBvcnRzLnNpbmggPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zaW5oO1xuZXhwb3J0cy5zb2Z0cGx1cyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNvZnRwbHVzO1xuZXhwb3J0cy5zcXJ0ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc3FydDtcbmV4cG9ydHMucnNxcnQgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5yc3FydDtcbmV4cG9ydHMuc3F1YXJlID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc3F1YXJlO1xuZXhwb3J0cy5zdGVwID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc3RlcDtcbmV4cG9ydHMudGFuID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMudGFuO1xuZXhwb3J0cy50YW5oID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMudGFuaDtcbmV4cG9ydHMuZXJmID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuZXJmO1xuZXhwb3J0cy5hZGQgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLmFkZDtcbmV4cG9ydHMuYWRkU3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5hZGRTdHJpY3Q7XG5leHBvcnRzLmF0YW4yID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5hdGFuMjtcbmV4cG9ydHMuZGl2ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5kaXY7XG5leHBvcnRzLmZsb29yRGl2ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5mbG9vckRpdjtcbmV4cG9ydHMuZGl2U3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5kaXZTdHJpY3Q7XG5leHBvcnRzLm1heGltdW0gPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1heGltdW07XG5leHBvcnRzLm1heGltdW1TdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1heGltdW1TdHJpY3Q7XG5leHBvcnRzLm1pbmltdW0gPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1pbmltdW07XG5leHBvcnRzLm1pbmltdW1TdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1pbmltdW1TdHJpY3Q7XG5leHBvcnRzLm1vZCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubW9kO1xuZXhwb3J0cy5tb2RTdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1vZFN0cmljdDtcbmV4cG9ydHMubXVsID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5tdWw7XG5leHBvcnRzLm11bFN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubXVsU3RyaWN0O1xuZXhwb3J0cy5wb3cgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLnBvdztcbmV4cG9ydHMucG93U3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5wb3dTdHJpY3Q7XG5leHBvcnRzLnN1YiA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMuc3ViO1xuZXhwb3J0cy5zdWJTdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLnN1YlN0cmljdDtcbmV4cG9ydHMuc3F1YXJlZERpZmZlcmVuY2UgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLnNxdWFyZWREaWZmZXJlbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMuc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q7XG5leHBvcnRzLm5vcm0gPSBub3JtXzEuTm9ybU9wcy5ub3JtO1xuZXhwb3J0cy5jYXN0ID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuY2FzdDtcbmV4cG9ydHMuY2xvbmUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5jbG9uZTtcbmV4cG9ydHMuZnJvbVBpeGVscyA9IGFycmF5X29wc18xLkFycmF5T3BzLmZyb21QaXhlbHM7XG5leHBvcnRzLnRvUGl4ZWxzID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudG9QaXhlbHM7XG5leHBvcnRzLm9uZXMgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5vbmVzO1xuZXhwb3J0cy5vbmVzTGlrZSA9IGFycmF5X29wc18xLkFycmF5T3BzLm9uZXNMaWtlO1xuZXhwb3J0cy56ZXJvcyA9IGFycmF5X29wc18xLkFycmF5T3BzLnplcm9zO1xuZXhwb3J0cy56ZXJvc0xpa2UgPSBhcnJheV9vcHNfMS5BcnJheU9wcy56ZXJvc0xpa2U7XG5leHBvcnRzLmV5ZSA9IGFycmF5X29wc18xLkFycmF5T3BzLmV5ZTtcbmV4cG9ydHMucmFuZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnJhbmQ7XG5leHBvcnRzLnJhbmRvbU5vcm1hbCA9IGFycmF5X29wc18xLkFycmF5T3BzLnJhbmRvbU5vcm1hbDtcbmV4cG9ydHMudHJ1bmNhdGVkTm9ybWFsID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudHJ1bmNhdGVkTm9ybWFsO1xuZXhwb3J0cy5yYW5kb21Vbmlmb3JtID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucmFuZG9tVW5pZm9ybTtcbmV4cG9ydHMubXVsdGlub21pYWwgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5tdWx0aW5vbWlhbDtcbmV4cG9ydHMucmVzaGFwZSA9IGFycmF5X29wc18xLkFycmF5T3BzLnJlc2hhcGU7XG5leHBvcnRzLnNxdWVlemUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5zcXVlZXplO1xuZXhwb3J0cy50aWxlID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudGlsZTtcbmV4cG9ydHMuZ2F0aGVyID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuZ2F0aGVyO1xuZXhwb3J0cy5vbmVIb3QgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5vbmVIb3Q7XG5leHBvcnRzLmxpbnNwYWNlID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMubGluc3BhY2U7XG5leHBvcnRzLnJhbmdlID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucmFuZ2U7XG5leHBvcnRzLmJ1ZmZlciA9IGFycmF5X29wc18xLkFycmF5T3BzLmJ1ZmZlcjtcbmV4cG9ydHMuZmlsbCA9IGFycmF5X29wc18xLkFycmF5T3BzLmZpbGw7XG5leHBvcnRzLnRlbnNvciA9IGFycmF5X29wc18xLkFycmF5T3BzLnRlbnNvcjtcbmV4cG9ydHMuc2NhbGFyID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuc2NhbGFyO1xuZXhwb3J0cy50ZW5zb3IxZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnRlbnNvcjFkO1xuZXhwb3J0cy50ZW5zb3IyZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnRlbnNvcjJkO1xuZXhwb3J0cy50ZW5zb3IzZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnRlbnNvcjNkO1xuZXhwb3J0cy50ZW5zb3I0ZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnRlbnNvcjRkO1xuZXhwb3J0cy50ZW5zb3I1ZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnRlbnNvcjVkO1xuZXhwb3J0cy5wcmludCA9IGFycmF5X29wc18xLkFycmF5T3BzLnByaW50O1xuZXhwb3J0cy5leHBhbmREaW1zID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuZXhwYW5kRGltcztcbmV4cG9ydHMuc3RhY2sgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5zdGFjaztcbmV4cG9ydHMudW5zdGFjayA9IGFycmF5X29wc18xLkFycmF5T3BzLnVuc3RhY2s7XG5leHBvcnRzLnNwbGl0ID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuc3BsaXQ7XG5leHBvcnRzLmN1bXN1bSA9IGFycmF5X29wc18xLkFycmF5T3BzLmN1bXN1bTtcbmV4cG9ydHMucGFkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucGFkO1xuZXhwb3J0cy5wYWQxZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnBhZDFkO1xuZXhwb3J0cy5wYWQyZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnBhZDJkO1xuZXhwb3J0cy5wYWQzZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnBhZDNkO1xuZXhwb3J0cy5wYWQ0ZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnBhZDRkO1xuZXhwb3J0cy5tb3ZpbmdBdmVyYWdlID0gbW92aW5nX2F2ZXJhZ2VfMS5Nb3ZpbmdBdmVyYWdlT3BzLm1vdmluZ0F2ZXJhZ2U7XG5leHBvcnRzLmJhc2ljTFNUTUNlbGwgPSBsc3RtXzEuTFNUTU9wcy5iYXNpY0xTVE1DZWxsO1xuZXhwb3J0cy5tdWx0aVJOTkNlbGwgPSBsc3RtXzEuTFNUTU9wcy5tdWx0aVJOTkNlbGw7XG5leHBvcnRzLnNvZnRtYXggPSBzb2Z0bWF4XzEuU29mdG1heE9wcy5zb2Z0bWF4O1xuZXhwb3J0cy5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbiA9IGxybl8xLkxSTk9wcy5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjtcbmV4cG9ydHMubGluYWxnID0gbGluYWxnX29wc18xLkxpbmFsZ09wcztcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbmV4cG9ydHMub3BlcmF0aW9uID0gb3BlcmF0aW9uXzEub3BlcmF0aW9uO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuW3RlbnNvcl8xLlRlbnNvciwgdHlwZXNfMS5SYW5rXTtcbltsb3NzX29wc18xLlJlZHVjdGlvbl07XG5leHBvcnRzLmxvc3NlcyA9IHtcbiAgICBhYnNvbHV0ZURpZmZlcmVuY2U6IGxvc3Nfb3BzXzEuTG9zc09wcy5hYnNvbHV0ZURpZmZlcmVuY2UsXG4gICAgY29tcHV0ZVdlaWdodGVkTG9zczogbG9zc19vcHNfMS5Mb3NzT3BzLmNvbXB1dGVXZWlnaHRlZExvc3MsXG4gICAgY29zaW5lRGlzdGFuY2U6IGxvc3Nfb3BzXzEuTG9zc09wcy5jb3NpbmVEaXN0YW5jZSxcbiAgICBoaW5nZUxvc3M6IGxvc3Nfb3BzXzEuTG9zc09wcy5oaW5nZUxvc3MsXG4gICAgaHViZXJMb3NzOiBsb3NzX29wc18xLkxvc3NPcHMuaHViZXJMb3NzLFxuICAgIGxvZ0xvc3M6IGxvc3Nfb3BzXzEuTG9zc09wcy5sb2dMb3NzLFxuICAgIG1lYW5TcXVhcmVkRXJyb3I6IGxvc3Nfb3BzXzEuTG9zc09wcy5tZWFuU3F1YXJlZEVycm9yLFxuICAgIHNvZnRtYXhDcm9zc0VudHJvcHk6IHNvZnRtYXhfMS5Tb2Z0bWF4T3BzLnNvZnRtYXhDcm9zc0VudHJvcHlcbn07XG5leHBvcnRzLmltYWdlID0ge1xuICAgIHJlc2l6ZUJpbGluZWFyOiBpbWFnZV9vcHNfMS5JbWFnZU9wcy5yZXNpemVCaWxpbmVhcixcbiAgICByZXNpemVOZWFyZXN0TmVpZ2hib3I6IGltYWdlX29wc18xLkltYWdlT3BzLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbnZfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBQb29sT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb29sT3BzKCkge1xuICAgIH1cbiAgICBQb29sT3BzLm1heFBvb2wgPSBmdW5jdGlvbiAoeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbWF4UG9vbCcpO1xuICAgICAgICB2YXIgeDREID0geDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArIHg0RC5yYW5rICsgXCIuXCIpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBtYXhQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKHg0RC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSwgc2F2ZWQpIHtcbiAgICAgICAgICAgIHZhciB5NEQgPSBzYXZlZFswXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUG9vbE9wcy5tYXhQb29sQmFja3Byb3AoZHksIHg0RCwgeTRELCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCwgc2F2ZSkgeyByZXR1cm4gc2F2ZShiYWNrZW5kLm1heFBvb2woeDRELCBjb252SW5mbykpOyB9LCB7IHg6IHg0RCB9LCBncmFkKTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBQb29sT3BzLm1heFBvb2xCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgaW5wdXQsIG91dHB1dCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgZHk6IGR5LCBpbnB1dDogaW5wdXQsIG91dHB1dDogb3V0cHV0IH0sICdtYXhQb29sQmFja3Byb3AnKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gZHkucmFuaywgXCJSYW5rIG9mIGlucHV0IChcIiArIGlucHV0LnJhbmsgKyBcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIgKyBkeS5yYW5rICsgXCIpXCIpO1xuICAgICAgICB1dGlsLmFzc2VydChkeS5yYW5rID09PSA0LCBcIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChkeS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoaW5wdXQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlUG9vbDJESW5mbyhpbnB1dC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tYXhQb29sQmFja3Byb3AoZHksIGlucHV0LCBvdXRwdXQsIGNvbnZJbmZvKTsgfSwgeyBkeTogZHksIGlucHV0OiBpbnB1dCB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFBvb2xPcHMuYXZnUG9vbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdhdmdQb29sJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHguZHR5cGUgPT09ICdmbG9hdDMyJywgJ1RoZSBpbnB1dCBkdHlwZSB0byBhdmdQb29sIG11c3QgYmUgZmxvYXQzMicpO1xuICAgICAgICB2YXIgeDREID0geDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGF2Z1Bvb2w6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICsgeDRELnJhbmsgKyBcIi5cIik7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGF2Z1Bvb2w6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgXCIgK1xuICAgICAgICAgICAgICAgIChcImRpbVJvdW5kaW5nTW9kZSBcIiArIGRpbVJvdW5kaW5nTW9kZSArIFwiIGJ1dCBnb3QgcGFkIFwiICsgcGFkICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZVBvb2wyREluZm8oeDRELnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQb29sT3BzLmF2Z1Bvb2xCYWNrcHJvcChkeSwgeDRELCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hdmdQb29sKHg0RCwgY29udkluZm8pOyB9LCB7IHg6IHg0RCB9LCBncmFkKTtcbiAgICAgICAgcmVzID0gcmVzLmNhc3QoeC5kdHlwZSk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUG9vbE9wcy5hdmdQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIGlucHV0LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgZHk6IGR5LCBpbnB1dDogaW5wdXQgfSwgJ2F2Z1Bvb2xCYWNrcHJvcCcpO1xuICAgICAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSBkeS5yYW5rLCBcIlJhbmsgb2YgaW5wdXQgKFwiICsgaW5wdXQucmFuayArIFwiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIiArIGR5LnJhbmsgKyBcIilcIik7XG4gICAgICAgIHZhciBpbnB1dDREID0gaW5wdXQ7XG4gICAgICAgIHZhciBkeTREID0gZHk7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlucHV0LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICBpbnB1dDREID0gaW5wdXQuYXM0RCgxLCBpbnB1dC5zaGFwZVswXSwgaW5wdXQuc2hhcGVbMV0sIGlucHV0LnNoYXBlWzJdKTtcbiAgICAgICAgICAgIGR5NEQgPSBkeS5hczREKDEsIGR5LnNoYXBlWzBdLCBkeS5zaGFwZVsxXSwgZHkuc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoZHk0RC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQ0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGF2Z1Bvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChpbnB1dDRELnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZVBvb2wyREluZm8oaW5wdXQ0RC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXZnUG9vbEJhY2twcm9wKGR5NEQsIGlucHV0NEQsIGNvbnZJbmZvKTsgfSwgeyBkeTREOiBkeTRELCBpbnB1dDREOiBpbnB1dDREIH0pO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFBvb2xPcHMsIFwibWF4UG9vbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUG9vbE9wcywgXCJtYXhQb29sQmFja3Byb3BcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUG9vbE9wcywgXCJhdmdQb29sXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBQb29sT3BzLCBcImF2Z1Bvb2xCYWNrcHJvcFwiLCBudWxsKTtcbiAgICByZXR1cm4gUG9vbE9wcztcbn0oKSk7XG5leHBvcnRzLlBvb2xPcHMgPSBQb29sT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9vbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWVkcmFuZG9tID0gcmVxdWlyZShcInNlZWRyYW5kb21cIik7XG52YXIgTVBSYW5kR2F1c3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1QUmFuZEdhdXNzKG1lYW4sIHN0ZERldmlhdGlvbiwgZHR5cGUsIHRydW5jYXRlZCwgc2VlZCkge1xuICAgICAgICB0aGlzLm1lYW4gPSBtZWFuO1xuICAgICAgICB0aGlzLnN0ZERldiA9IHN0ZERldmlhdGlvbjtcbiAgICAgICAgdGhpcy5kdHlwZSA9IGR0eXBlO1xuICAgICAgICB0aGlzLm5leHRWYWwgPSBOYU47XG4gICAgICAgIHRoaXMudHJ1bmNhdGVkID0gdHJ1bmNhdGVkO1xuICAgICAgICBpZiAodGhpcy50cnVuY2F0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXIgPSB0aGlzLm1lYW4gKyB0aGlzLnN0ZERldiAqIDI7XG4gICAgICAgICAgICB0aGlzLmxvd2VyID0gdGhpcy5tZWFuIC0gdGhpcy5zdGREZXYgKiAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVkVmFsdWUgPSBzZWVkID8gc2VlZCA6IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHRoaXMucmFuZG9tID0gc2VlZHJhbmRvbS5hbGVhKHNlZWRWYWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgTVBSYW5kR2F1c3MucHJvdG90eXBlLm5leHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc05hTih0aGlzLm5leHRWYWwpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm5leHRWYWw7XG4gICAgICAgICAgICB0aGlzLm5leHRWYWwgPSBOYU47XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdFgsIHJlc3VsdFk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghaXNWYWxpZCkge1xuICAgICAgICAgICAgdmFyIHYxID0gdm9pZCAwLCB2MiA9IHZvaWQgMCwgcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2MSA9IDIgKiB0aGlzLnJhbmRvbSgpIC0gMTtcbiAgICAgICAgICAgICAgICB2MiA9IDIgKiB0aGlzLnJhbmRvbSgpIC0gMTtcbiAgICAgICAgICAgICAgICBzID0gdjEgKiB2MSArIHYyICogdjI7XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgfHwgcyA9PT0gMCk7XG4gICAgICAgICAgICB2YXIgbXVsID0gTWF0aC5zcXJ0KC0yLjAgKiBNYXRoLmxvZyhzKSAvIHMpO1xuICAgICAgICAgICAgcmVzdWx0WCA9IHRoaXMubWVhbiArIHRoaXMuc3RkRGV2ICogdjEgKiBtdWw7XG4gICAgICAgICAgICByZXN1bHRZID0gdGhpcy5tZWFuICsgdGhpcy5zdGREZXYgKiB2MiAqIG11bDtcbiAgICAgICAgICAgIGlmICghdGhpcy50cnVuY2F0ZWQgfHwgdGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKHJlc3VsdFgpKSB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRydW5jYXRlZCB8fCB0aGlzLmlzVmFsaWRUcnVuY2F0ZWQocmVzdWx0WSkpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFZhbCA9IHRoaXMuY29udmVydFZhbHVlKHJlc3VsdFkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRWYWx1ZShyZXN1bHRYKTtcbiAgICB9O1xuICAgIE1QUmFuZEdhdXNzLnByb3RvdHlwZS5jb252ZXJ0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZHR5cGUgPT0gbnVsbCB8fCB0aGlzLmR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfTtcbiAgICBNUFJhbmRHYXVzcy5wcm90b3R5cGUuaXNWYWxpZFRydW5jYXRlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPD0gdGhpcy51cHBlciAmJiB2YWx1ZSA+PSB0aGlzLmxvd2VyO1xuICAgIH07XG4gICAgcmV0dXJuIE1QUmFuZEdhdXNzO1xufSgpKTtcbmV4cG9ydHMuTVBSYW5kR2F1c3MgPSBNUFJhbmRHYXVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBBUkFMTEVMSVpFX1RIUkVTSE9MRCA9IDMwO1xuZnVuY3Rpb24gY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGluU2l6ZSkge1xuICAgIGlmIChpblNpemUgPD0gZXhwb3J0cy5QQVJBTExFTElaRV9USFJFU0hPTEQpIHtcbiAgICAgICAgcmV0dXJuIGluU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5lYXJlc3REaXZpc29yKGluU2l6ZSwgTWF0aC5mbG9vcihNYXRoLnNxcnQoaW5TaXplKSkpO1xufVxuZXhwb3J0cy5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUgPSBjb21wdXRlT3B0aW1hbFdpbmRvd1NpemU7XG5mdW5jdGlvbiBuZWFyZXN0RGl2aXNvcihzaXplLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICBpZiAoc2l6ZSAlIGkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbCA9IHJlcXVpcmUoXCIuL2F4aXNfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi9vcHNcIik7XG52YXIgUmVkdWN0aW9uT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWR1Y3Rpb25PcHMoKSB7XG4gICAgfVxuICAgIFJlZHVjdGlvbk9wcy5sb2dTdW1FeHAgPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2xvZ1N1bUV4cCcpO1xuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIHhNYXggPSB4Lm1heChheGVzLCB0cnVlKTtcbiAgICAgICAgdmFyIGEgPSB4LnN1Yih4TWF4KTtcbiAgICAgICAgdmFyIGIgPSBhLmV4cCgpO1xuICAgICAgICB2YXIgYyA9IGIuc3VtKGF4ZXMpO1xuICAgICAgICB2YXIgZCA9IGMubG9nKCk7XG4gICAgICAgIHZhciByZXMgPSB4TWF4LnJlc2hhcGUoZC5zaGFwZSkuYWRkKGQpO1xuICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXMuc2hhcGUsIGF4ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUmVkdWN0aW9uT3BzLnN1bSA9IGZ1bmN0aW9uICh4LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc3VtJyk7XG4gICAgICAgIGlmICh4LmR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHggPSB4LnRvSW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBjdXN0b21PcCA9IGdsb2JhbHNfMS5jdXN0b21HcmFkKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB2YXIgcGVybXV0YXRpb24gPSBheGlzX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHgucmFuayk7XG4gICAgICAgICAgICB2YXIgcmVkdWN0aW9uQXhlcyA9IGF4ZXM7XG4gICAgICAgICAgICB2YXIgcGVybXV0ZWRYID0geDtcbiAgICAgICAgICAgIGlmIChwZXJtdXRhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGVybXV0ZWRYID0geC50cmFuc3Bvc2UocGVybXV0YXRpb24pO1xuICAgICAgICAgICAgICAgIHJlZHVjdGlvbkF4ZXMgPVxuICAgICAgICAgICAgICAgICAgICBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhyZWR1Y3Rpb25BeGVzLmxlbmd0aCwgeC5yYW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc3VtKHBlcm11dGVkWCwgcmVkdWN0aW9uQXhlcyk7IH0sIHsgcGVybXV0ZWRYOiBwZXJtdXRlZFggfSk7XG4gICAgICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0odmFsdWUuc2hhcGUsIGF4ZXMpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ3JhZEZ1bmMgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5kZWREeVNoYXBlID0geC5zaGFwZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZER5U2hhcGVbYXhpc10gPSAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZER5ID0gZHkucmVzaGFwZShleHBhbmRlZER5U2hhcGUpO1xuICAgICAgICAgICAgICAgIHZhciBkZXJYID0gZXhwYW5kZWREeS5tdWwob3BzLm9uZXMoeC5zaGFwZSwgJ2Zsb2F0MzInKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlclg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBncmFkRnVuYzogZ3JhZEZ1bmMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdXN0b21PcCh4KTtcbiAgICB9O1xuICAgIFJlZHVjdGlvbk9wcy5tZWFuID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdtZWFuJyk7XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgc2hhcGVzID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyk7XG4gICAgICAgIHZhciByZWR1Y2VTaGFwZSA9IHNoYXBlc1sxXTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgY3VzdG9tT3AgPSBnbG9iYWxzXzEuY3VzdG9tR3JhZChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIHJlZHVjZVNpemVTY2FsYXIgPSBvcHMuc2NhbGFyKHJlZHVjZVNpemUpO1xuICAgICAgICAgICAgdmFyIHhSZWR1Y2UgPSByZWR1Y2VTaXplU2NhbGFyLmR0eXBlID09PSB4LmR0eXBlID9cbiAgICAgICAgICAgICAgICB4IDpcbiAgICAgICAgICAgICAgICB4LmNhc3QocmVkdWNlU2l6ZVNjYWxhci5kdHlwZSk7XG4gICAgICAgICAgICB2YXIgcmVzID0geFJlZHVjZS5kaXYocmVkdWNlU2l6ZVNjYWxhcik7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByZXMuc3VtKGF4aXMsIGtlZXBEaW1zKTtcbiAgICAgICAgICAgIHZhciBncmFkRnVuYyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZER5U2hhcGUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkRHlTaGFwZVtheGlzXSA9IDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkRHkgPSBkeS5yZXNoYXBlKGV4cGFuZGVkRHlTaGFwZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlclggPSBleHBhbmRlZER5Lm11bChvcHMub25lcyh4LnNoYXBlLCAnZmxvYXQzMicpKS5kaXYocmVkdWNlU2l6ZVNjYWxhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlclg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBncmFkRnVuYzogZ3JhZEZ1bmMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdXN0b21PcCh4KTtcbiAgICB9O1xuICAgIFJlZHVjdGlvbk9wcy5taW4gPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ21pbicpO1xuICAgICAgICB2YXIgb3JpZ0F4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHgucmFuayk7XG4gICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHgudHJhbnNwb3NlKHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHgucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubWluKHgsIGF4ZXMpOyB9LCB7IHg6IHggfSk7XG4gICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlcy5zaGFwZSwgb3JpZ0F4ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUmVkdWN0aW9uT3BzLm1heCA9IGZ1bmN0aW9uICh4LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbWF4Jyk7XG4gICAgICAgIHZhciBvcmlnQXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIGF4ZXMgPSBvcmlnQXhlcztcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB4ID0geC50cmFuc3Bvc2UocGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tYXgoeCwgYXhlcyk7IH0sIHsgeDogeCB9KTtcbiAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSZWR1Y3Rpb25PcHMuYXJnTWluID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdhcmdNaW4nKTtcbiAgICAgICAgaWYgKGF4aXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXhpcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHgucmFuayk7XG4gICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHgudHJhbnNwb3NlKHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHgucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXJnTWluKHgsIGF4ZXNbMF0pOyB9LCB7IHg6IHggfSk7XG4gICAgfTtcbiAgICBSZWR1Y3Rpb25PcHMuYXJnTWF4ID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdhcmdNYXgnKTtcbiAgICAgICAgaWYgKGF4aXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXhpcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHgucmFuayk7XG4gICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHgudHJhbnNwb3NlKHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIHgucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXJnTWF4KHgsIGF4ZXNbMF0pOyB9LCB7IHg6IHggfSk7XG4gICAgfTtcbiAgICBSZWR1Y3Rpb25PcHMubW9tZW50cyA9IGZ1bmN0aW9uICh4LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbW9tZW50cycpO1xuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIG1lYW4gPSB4Lm1lYW4oYXhlcywga2VlcERpbXMpO1xuICAgICAgICB2YXIga2VlcERpbXNTaGFwZSA9IG1lYW4uc2hhcGU7XG4gICAgICAgIGlmICgha2VlcERpbXMpIHtcbiAgICAgICAgICAgIGtlZXBEaW1zU2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0obWVhbi5zaGFwZSwgYXhlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRldlNxdWFyZWQgPSB4LnRvRmxvYXQoKS5zdWIobWVhbi5yZXNoYXBlKGtlZXBEaW1zU2hhcGUpKS5zcXVhcmUoKTtcbiAgICAgICAgdmFyIHZhcmlhbmNlID0gZGV2U3F1YXJlZC5tZWFuKGF4ZXMsIGtlZXBEaW1zKTtcbiAgICAgICAgcmV0dXJuIHsgbWVhbjogbWVhbiwgdmFyaWFuY2U6IHZhcmlhbmNlIH07XG4gICAgfTtcbiAgICBSZWR1Y3Rpb25PcHMudW5zb3J0ZWRTZWdtZW50U3VtID0gZnVuY3Rpb24gKHgsIHNlZ21lbnRJZHMsIG51bVNlZ21lbnRzLCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCwgc2VnbWVudElkczogc2VnbWVudElkcyB9LCAndW5zb3J0ZWRTZWdtZW50U3VtJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHNlZ21lbnRJZHMuZHR5cGUgPT09ICdpbnQzMicsICdTZWdtZW50IElkcyBtdXN0IGJlIG9mIGR0eXBlIGBpbnQzMmAnKTtcbiAgICAgICAgYXhpcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKVswXTtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB2YXIgZGltID0gc2VnbWVudElkcy5zaGFwZVswXTtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5zaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGF4aXMpIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZS5wdXNoKGRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZS5wdXNoKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXNoYXBlZFNlZ21lbnRJZHMgPSBvcHMucmVzaGFwZShzZWdtZW50SWRzLCBuZXdTaGFwZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRJZCA9IG9wcy5zY2FsYXIoaSwgJ2ludDMyJyk7XG4gICAgICAgICAgICB2YXIgbWFzayA9IG9wcy5lcXVhbChzZWdtZW50SWQsIHJlc2hhcGVkU2VnbWVudElkcykuYXNUeXBlKCdmbG9hdDMyJyk7XG4gICAgICAgICAgICB2YXIgc3VtID0gbWFzay5tdWwoeCkuc3VtKGF4aXMpO1xuICAgICAgICAgICAgcmVzLnB1c2goc3VtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BzLnN0YWNrKHJlcywgYXhpcyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcImxvZ1N1bUV4cFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcInN1bVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcIm1lYW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1JlZHVjdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFJlZHVjdGlvbk9wcywgXCJtaW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1JlZHVjdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFJlZHVjdGlvbk9wcywgXCJtYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1JlZHVjdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFJlZHVjdGlvbk9wcywgXCJhcmdNaW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1JlZHVjdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFJlZHVjdGlvbk9wcywgXCJhcmdNYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ05vcm1hbGl6YXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZWR1Y3Rpb25PcHMsIFwibW9tZW50c1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcInVuc29ydGVkU2VnbWVudFN1bVwiLCBudWxsKTtcbiAgICByZXR1cm4gUmVkdWN0aW9uT3BzO1xufSgpKTtcbmV4cG9ydHMuUmVkdWN0aW9uT3BzID0gUmVkdWN0aW9uT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWN0aW9uX29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsXzEgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgUmV2ZXJzZU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV2ZXJzZU9wcygpIHtcbiAgICB9XG4gICAgUmV2ZXJzZU9wcy5yZXZlcnNlMWQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gcmV2ZXJzZTFEOiB4IG11c3QgYmUgcmFuayAxIGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIFJldmVyc2VPcHMucmV2ZXJzZSh4LCAwKTtcbiAgICB9O1xuICAgIFJldmVyc2VPcHMucmV2ZXJzZTJkID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAyLCBcIkVycm9yIGluIHJldmVyc2UyRDogeCBtdXN0IGJlIHJhbmsgMiBidXQgZ290XFxuICAgICAgICAgICAgIHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHJldHVybiBSZXZlcnNlT3BzLnJldmVyc2UoeCwgYXhpcyk7XG4gICAgfTtcbiAgICBSZXZlcnNlT3BzLnJldmVyc2UzZCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiByZXZlcnNlM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gUmV2ZXJzZU9wcy5yZXZlcnNlKHgsIGF4aXMpO1xuICAgIH07XG4gICAgUmV2ZXJzZU9wcy5yZXZlcnNlNGQgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gcmV2ZXJzZTREOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIFJldmVyc2VPcHMucmV2ZXJzZSh4LCBheGlzKTtcbiAgICB9O1xuICAgIFJldmVyc2VPcHMucmV2ZXJzZSA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3JldmVyc2UnKTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHguY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbF8xLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkucmV2ZXJzZShheGVzKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5yZXZlcnNlKHgsIGF4ZXMpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgICAgIHJldHVybiByZXMucmVzaGFwZUFzKHgpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZXZlcnNlT3BzLCBcInJldmVyc2VcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFJldmVyc2VPcHM7XG59KCkpO1xuZXhwb3J0cy5SZXZlcnNlT3BzID0gUmV2ZXJzZU9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldmVyc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNFTFVfU0NBTEVBTFBIQSA9IDEuNzU4MDk5MzQwODQ3Mzc2ODU5OTQwMjE3NTIwODEyMztcbmV4cG9ydHMuU0VMVV9TQ0FMRSA9IDEuMDUwNzAwOTg3MzU1NDgwNDkzNDE5MzM0OTg1Mjk0Njtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbHVfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgc2xpY2VfdXRpbCA9IHJlcXVpcmUoXCIuL3NsaWNlX3V0aWxcIik7XG52YXIgU2xpY2VPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWNlT3BzKCkge1xuICAgIH1cbiAgICBTbGljZU9wcy5zbGljZTFkID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMSwgXCJzbGljZTFkIGV4cGVjdHMgYSByYW5rLTEgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIiArIHgucmFuayArIFwiIHRlbnNvclwiKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlT3BzLnNsaWNlKHgsIFtiZWdpbl0sIFtzaXplXSk7XG4gICAgfTtcbiAgICBTbGljZU9wcy5zbGljZTJkID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMiwgXCJzbGljZTFkIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIiArIHgucmFuayArIFwiIHRlbnNvclwiKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlT3BzLnNsaWNlKHgsIGJlZ2luLCBzaXplKTtcbiAgICB9O1xuICAgIFNsaWNlT3BzLnNsaWNlM2QgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcInNsaWNlMWQgZXhwZWN0cyBhIHJhbmstMyB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiICsgeC5yYW5rICsgXCIgdGVuc29yXCIpO1xuICAgICAgICByZXR1cm4gU2xpY2VPcHMuc2xpY2UoeCwgYmVnaW4sIHNpemUpO1xuICAgIH07XG4gICAgU2xpY2VPcHMuc2xpY2U0ZCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDQsIFwic2xpY2UxZCBleHBlY3RzIGEgcmFuay00IHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIgKyB4LnJhbmsgKyBcIiB0ZW5zb3JcIik7XG4gICAgICAgIHJldHVybiBTbGljZU9wcy5zbGljZSh4LCBiZWdpbiwgc2l6ZSk7XG4gICAgfTtcbiAgICBTbGljZU9wcy5zbGljZSA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdzbGljZScpO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NsaWNpbmcgc2NhbGFyIGlzIG5vdCBwb3NzaWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWdpbl87XG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBiZWdpbl8gPSBbYmVnaW5dLmNvbmNhdChuZXcgQXJyYXkoeC5yYW5rIC0gMSkuZmlsbCgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVnaW4ubGVuZ3RoIDwgeC5yYW5rKSB7XG4gICAgICAgICAgICBiZWdpbl8gPSBiZWdpbi5jb25jYXQobmV3IEFycmF5KHgucmFuayAtIGJlZ2luLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZWdpbl8gPSBiZWdpbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZV87XG4gICAgICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIHNpemVfID0gbmV3IEFycmF5KHgucmFuaykuZmlsbCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzaXplXyA9IFtzaXplXS5jb25jYXQobmV3IEFycmF5KHgucmFuayAtIDEpLmZpbGwoLTEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplLmxlbmd0aCA8IHgucmFuaykge1xuICAgICAgICAgICAgc2l6ZV8gPSBzaXplLmNvbmNhdChuZXcgQXJyYXkoeC5yYW5rIC0gc2l6ZS5sZW5ndGgpLmZpbGwoLTEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpemVfID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBzaXplXyA9IHNpemVfLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgaWYgKGQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnQoZCA9PT0gLTEsICdCYWQgdmFsdWUgaW4gc2l6ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnNoYXBlW2ldIC0gYmVnaW5fW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZCh4LCBiZWdpbl8sIHNpemVfKTtcbiAgICAgICAgdmFyIGlucHV0U2hhcGUgPSB4LnNoYXBlO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR5LnJhbms7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdzLnB1c2goW2JlZ2luX1tpXSwgaW5wdXRTaGFwZVtpXSAtIGJlZ2luX1tpXSAtIHNpemVfW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5wYWQocGFkZGluZ3MpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnNsaWNlKHgsIGJlZ2luXywgc2l6ZV8pOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnU2xpY2luZyBhbmQgSm9pbmluZycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFNsaWNlT3BzLCBcInNsaWNlXCIsIG51bGwpO1xuICAgIHJldHVybiBTbGljZU9wcztcbn0oKSk7XG5leHBvcnRzLlNsaWNlT3BzID0gU2xpY2VPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSBiZWdpbi5sZW5ndGgsIFwiRXJyb3IgaW4gc2xpY2VcIiArIGlucHV0LnJhbmsgKyBcIkQ6IExlbmd0aCBvZiBiZWdpbiBcIiArIGJlZ2luICsgXCIgbXVzdCBcIiArXG4gICAgICAgIChcIm1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIgKyBpbnB1dC5yYW5rICsgXCIpLlwiKSk7XG4gICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gc2l6ZS5sZW5ndGgsIFwiRXJyb3IgaW4gc2xpY2VcIiArIGlucHV0LnJhbmsgKyBcIkQ6IExlbmd0aCBvZiBzaXplIFwiICsgc2l6ZSArIFwiIG11c3QgXCIgK1xuICAgICAgICAoXCJtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiICsgaW5wdXQucmFuayArIFwiKS5cIikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQucmFuazsgKytpKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGJlZ2luW2ldICsgc2l6ZVtpXSA8PSBpbnB1dC5zaGFwZVtpXSwgXCJFcnJvciBpbiBzbGljZVwiICsgaW5wdXQucmFuayArIFwiRDogYmVnaW5bXCIgKyBpICsgXCJdICsgc2l6ZVtcIiArIGkgKyBcIl0gXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgKGJlZ2luW2ldICsgc2l6ZVtpXSkgKyBcIikgd291bGQgb3ZlcmZsb3cgaW5wdXQuc2hhcGVbXCIgKyBpICsgXCJdIChcIiArIGlucHV0LnNoYXBlW2ldICsgXCIpXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFBhcmFtc1ZhbGlkID0gYXNzZXJ0UGFyYW1zVmFsaWQ7XG5mdW5jdGlvbiBnZXRTdHJpZGVkU2xpY2VkSW5mbyhzaGFwZSwgYmVnaW4sIGVuZCwgc3RyaWRlcywgYmVnaW5NYXNrLCBlbmRNYXNrKSB7XG4gICAgaWYgKGJlZ2luTWFzayA9PT0gdm9pZCAwKSB7IGJlZ2luTWFzayA9IDA7IH1cbiAgICBpZiAoZW5kTWFzayA9PT0gdm9pZCAwKSB7IGVuZE1hc2sgPSAwOyB9XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBbXTtcbiAgICB2YXIgZW5kSW5kZXggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXJ0SW5kZXhbaV0gPSBzdGFydEZvckF4aXMoYmVnaW5NYXNrLCBiZWdpbiwgc3RyaWRlcywgc2hhcGUsIGkpO1xuICAgICAgICBlbmRJbmRleFtpXSA9IHN0b3BGb3JBeGlzKGVuZE1hc2ssIGVuZCwgc3RyaWRlcywgc2hhcGUsIGkpO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IG5ldyBBcnJheShzaGFwZS5sZW5ndGgpLmZpbGwoMCk7XG4gICAgc2l6ZSA9IHNpemUubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIHN0YXJ0ID0gc3RhcnRJbmRleFtpXTsgIShzdHJpZGVzW2ldID4gMCA/IHN0YXJ0ID49IGVuZEluZGV4W2ldIDogc3RhcnQgPD0gZW5kSW5kZXhbaV0pOyBzdGFydCArPSBzdHJpZGVzW2ldKSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9KTtcbiAgICByZXR1cm4gW3N0YXJ0SW5kZXgsIHNpemVdO1xufVxuZXhwb3J0cy5nZXRTdHJpZGVkU2xpY2VkSW5mbyA9IGdldFN0cmlkZWRTbGljZWRJbmZvO1xuZnVuY3Rpb24gc3RhcnRGb3JBeGlzKGJlZ2luTWFzaywgc3RhcnRJbmRpY2VzLCBzdHJpZGVzLCBpbnB1dFNoYXBlLCBheGlzKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRJbmRpY2VzW2F4aXNdO1xuICAgIGlmIChiZWdpbk1hc2sgJiAxIDw8IGF4aXMpIHtcbiAgICAgICAgaWYgKHN0cmlkZXNbYXhpc10gPiAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXhpc1NpemUgPSBpbnB1dFNoYXBlW2F4aXNdO1xuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgKz0gYXhpc1NpemU7XG4gICAgfVxuICAgIHN0YXJ0ID0gdXRpbC5jbGFtcCgwLCBzdGFydCwgYXhpc1NpemUgLSAxKTtcbiAgICByZXR1cm4gc3RhcnQ7XG59XG5leHBvcnRzLnN0YXJ0Rm9yQXhpcyA9IHN0YXJ0Rm9yQXhpcztcbmZ1bmN0aW9uIHN0b3BGb3JBeGlzKGVuZE1hc2ssIHN0b3BJbmRpY2VzLCBzdHJpZGVzLCBpbnB1dFNoYXBlLCBheGlzKSB7XG4gICAgdmFyIHN0b3AgPSBzdG9wSW5kaWNlc1theGlzXTtcbiAgICBpZiAoZW5kTWFzayAmICgxIDw8IGF4aXMpKSB7XG4gICAgICAgIGlmIChzdHJpZGVzW2F4aXNdID4gMCkge1xuICAgICAgICAgICAgc3RvcCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBheGlzU2l6ZSA9IGlucHV0U2hhcGVbYXhpc107XG4gICAgaWYgKHN0b3AgPCAwKSB7XG4gICAgICAgIHN0b3AgKz0gYXhpc1NpemU7XG4gICAgfVxuICAgIGlmIChzdHJpZGVzW2F4aXNdID4gMCkge1xuICAgICAgICBzdG9wID0gdXRpbC5jbGFtcCgwLCBzdG9wLCBheGlzU2l6ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9wID0gdXRpbC5jbGFtcCgtMSwgc3RvcCwgYXhpc1NpemUgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3A7XG59XG5leHBvcnRzLnN0b3BGb3JBeGlzID0gc3RvcEZvckF4aXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGljZV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBTb2Z0bWF4T3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4T3BzKCkge1xuICAgIH1cbiAgICBTb2Z0bWF4T3BzLnNvZnRtYXggPSBmdW5jdGlvbiAobG9naXRzLCBkaW0pIHtcbiAgICAgICAgaWYgKGRpbSA9PT0gdm9pZCAwKSB7IGRpbSA9IC0xOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxvZ2l0czogbG9naXRzIH0sICdzb2Z0bWF4Jyk7XG4gICAgICAgIGlmIChkaW0gPT09IC0xKSB7XG4gICAgICAgICAgICBkaW0gPSBsb2dpdHMucmFuayAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbSAhPT0gbG9naXRzLnJhbmsgLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gJyArXG4gICAgICAgICAgICAgICAgKFwiTG9naXRzIHdhcyByYW5rIFwiICsgbG9naXRzLnJhbmsgKyBcIiBhbmQgZGltIHdhcyBcIiArIGRpbSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXN0b21PcCA9IGdsb2JhbHNfMS5jdXN0b21HcmFkKGZ1bmN0aW9uIChsb2dpdHMpIHtcbiAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbHNlID0gbG9naXRzLmxvZ1N1bUV4cChbZGltXSwga2VlcERpbXMpO1xuICAgICAgICAgICAgdmFyIGxvZ1Jlc3VsdCA9IGxvZ2l0cy50b0Zsb2F0KCkuc3ViKGxzZSk7XG4gICAgICAgICAgICB2YXIgeSA9IGxvZ1Jlc3VsdC5leHAoKTtcbiAgICAgICAgICAgIHZhciBncmFkRnVuYyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgICAgIHZhciBkeVRpbWVzWSA9IGR5Lm11bCh5KTtcbiAgICAgICAgICAgICAgICB2YXIga2VlcERpbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBkeVRpbWVzWS5zdWIoZHlUaW1lc1kuc3VtKFtkaW1dLCBrZWVwRGltcykubXVsKHkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogeSwgZ3JhZEZ1bmM6IGdyYWRGdW5jIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VzdG9tT3AobG9naXRzKTtcbiAgICB9O1xuICAgIFNvZnRtYXhPcHMuc29mdG1heENyb3NzRW50cm9weSA9IGZ1bmN0aW9uIChsYWJlbHMsIGxvZ2l0cywgZGltKSB7XG4gICAgICAgIGlmIChkaW0gPT09IHZvaWQgMCkgeyBkaW0gPSAtMTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBsYWJlbHM6IGxhYmVscywgbG9naXRzOiBsb2dpdHMgfSwgJ3NvZnRtYXhDcm9zc0VudHJvcHknKTtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChsYWJlbHMuc2hhcGUsIGxvZ2l0cy5zaGFwZSwgJ0Vycm9yIGluIHNvZnRtYXhDcm9zc0VudHJvcHk6ICcpO1xuICAgICAgICBpZiAoZGltID09PSAtMSkge1xuICAgICAgICAgICAgZGltID0gbG9naXRzLnJhbmsgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaW0gIT09IGxvZ2l0cy5yYW5rIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGNyb3NzIGVudHJvcHkgYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBcIiArXG4gICAgICAgICAgICAgICAgKFwic3VwcG9ydGVkLiBMYWJlbHMgLyBsb2dpdHMgd2FzIHJhbmsgXCIgKyBsb2dpdHMucmFuayArIFwiIFwiKSArXG4gICAgICAgICAgICAgICAgKFwiYW5kIGRpbSB3YXMgXCIgKyBkaW0pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VzdG9tT3AgPSBnbG9iYWxzXzEuY3VzdG9tR3JhZChmdW5jdGlvbiAobGFiZWxzLCBsb2dpdHMpIHtcbiAgICAgICAgICAgIHZhciBwcmVkaWN0ZWRQcm9icyA9IGxvZ2l0cy5zb2Z0bWF4KGRpbSk7XG4gICAgICAgICAgICB2YXIgY29zdFZlY3RvciA9IG9wcy5zY2FsYXIoMWUtNSkuYWRkKHByZWRpY3RlZFByb2JzKS5sb2coKS5tdWwobGFiZWxzKS5uZWcoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvc3RWZWN0b3Iuc3VtKFtkaW1dKTtcbiAgICAgICAgICAgIHZhciBncmFkRnVuYyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgICAgIHZhciBkeVNoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKGR5LnNoYXBlLCBbZGltXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgZHkucmVzaGFwZShkeVNoYXBlKS5tdWwobGFiZWxzLnRvRmxvYXQoKS5zdWIocHJlZGljdGVkUHJvYnMpKSxcbiAgICAgICAgICAgICAgICAgICAgZHkucmVzaGFwZShkeVNoYXBlKS5tdWwocHJlZGljdGVkUHJvYnMuc3ViKGxhYmVscy50b0Zsb2F0KCkpKSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZ3JhZEZ1bmM6IGdyYWRGdW5jIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VzdG9tT3AobGFiZWxzLCBsb2dpdHMpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ05vcm1hbGl6YXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBTb2Z0bWF4T3BzLCBcInNvZnRtYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdMb3NzZXMnLCBuYW1lc3BhY2U6ICdsb3NzZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBTb2Z0bWF4T3BzLCBcInNvZnRtYXhDcm9zc0VudHJvcHlcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFNvZnRtYXhPcHM7XG59KCkpO1xuZXhwb3J0cy5Tb2Z0bWF4T3BzID0gU29mdG1heE9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvZnRtYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIFN0cmlkZWRTbGljZU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaWRlZFNsaWNlT3BzKCkge1xuICAgIH1cbiAgICBTdHJpZGVkU2xpY2VPcHMuc3RyaWRlZFNsaWNlID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBlbmQsIHN0cmlkZXMsIGJlZ2luTWFzaywgZW5kTWFzaykge1xuICAgICAgICBpZiAoYmVnaW5NYXNrID09PSB2b2lkIDApIHsgYmVnaW5NYXNrID0gMDsgfVxuICAgICAgICBpZiAoZW5kTWFzayA9PT0gdm9pZCAwKSB7IGVuZE1hc2sgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3N0cmlkZWRTbGljZScpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zdHJpZGVkU2xpY2UoeCwgYmVnaW4sIGVuZCwgc3RyaWRlcywgYmVnaW5NYXNrLCBlbmRNYXNrKTsgfSwgeyB4OiB4IH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBTdHJpZGVkU2xpY2VPcHMsIFwic3RyaWRlZFNsaWNlXCIsIG51bGwpO1xuICAgIHJldHVybiBTdHJpZGVkU2xpY2VPcHM7XG59KCkpO1xuZXhwb3J0cy5TdHJpZGVkU2xpY2VPcHMgPSBTdHJpZGVkU2xpY2VPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpZGVkX3NsaWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgVHJhbnNwb3NlT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc3Bvc2VPcHMoKSB7XG4gICAgfVxuICAgIFRyYW5zcG9zZU9wcy50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoeCwgcGVybSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICd0cmFuc3Bvc2UnKTtcbiAgICAgICAgaWYgKHBlcm0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcGVybSA9IHguc2hhcGUubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBpOyB9KS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSBwZXJtLmxlbmd0aCwgXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIgKyB4LnJhbmsgKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIGxlbmd0aCBvZiBwZXJtIFwiICsgcGVybSArIFwiLlwiKSk7XG4gICAgICAgIHBlcm0uZm9yRWFjaChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoYXhpcyA+PSAwICYmIGF4aXMgPCB4LnJhbmssIFwiQWxsIGVudHJpZXMgaW4gJ3Blcm0nIG11c3QgYmUgYmV0d2VlbiAwIGFuZCBcIiArICh4LnJhbmsgLSAxKSArXG4gICAgICAgICAgICAgICAgKFwiIGJ1dCBnb3QgXCIgKyBwZXJtKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoeC5yYW5rIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHVuZG9QZXJtID0gYXhpc191dGlsLmdldFVuZG9BeGVzUGVybXV0YXRpb24ocGVybSk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS50cmFuc3Bvc2UodW5kb1Blcm0pOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnRyYW5zcG9zZSh4LCBwZXJtKTsgfSwgeyB4OiB4IH0sIGRlcik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTWF0cmljZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBUcmFuc3Bvc2VPcHMsIFwidHJhbnNwb3NlXCIsIG51bGwpO1xuICAgIHJldHVybiBUcmFuc3Bvc2VPcHM7XG59KCkpO1xuZXhwb3J0cy5UcmFuc3Bvc2VPcHMgPSBUcmFuc3Bvc2VPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3Bvc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBzZWx1X3V0aWwgPSByZXF1aXJlKFwiLi9zZWx1X3V0aWxcIik7XG52YXIgVW5hcnlPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuYXJ5T3BzKCkge1xuICAgIH1cbiAgICBVbmFyeU9wcy5uZWcgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICduZWcnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm5lZygpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm5lZyh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuY2VpbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2NlaWwnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wcy56ZXJvc0xpa2UoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNlaWwoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmZsb29yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnZmxvb3InKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wcy56ZXJvc0xpa2UoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmZsb29yKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5zaWduID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc2lnbicpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb3BzLnplcm9zTGlrZShkeSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc2lnbih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMucm91bmQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdyb3VuZCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb3BzLnplcm9zTGlrZShkeSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQucm91bmQoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmV4cCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2V4cCcpO1xuICAgICAgICB2YXIgYmNrID0gZnVuY3Rpb24gKGR5LCBzYXZlZCkge1xuICAgICAgICAgICAgdmFyIHkgPSBzYXZlZFswXTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdCh5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCwgc2F2ZSkgeyByZXR1cm4gc2F2ZShiYWNrZW5kLmV4cCh4KSk7IH0sIHsgeDogeCB9LCBiY2spO1xuICAgIH07XG4gICAgVW5hcnlPcHMuZXhwbTEgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdleHBtMScpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHguZXhwKCkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmV4cG0xKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5sb2cgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdsb2cnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmRpdlN0cmljdCh4LnRvRmxvYXQoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubG9nKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5sb2cxcCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2xvZzFwJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5kaXZTdHJpY3QoeC5hZGQob3BzLnNjYWxhcigxKSkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmxvZzFwKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5zcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc3FydCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KHgudG9GbG9hdCgpLnNxcnQoKS5tdWwob3BzLnNjYWxhcigyKSkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnNxcnQoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnJzcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAncnNxcnQnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KHgucG93KG9wcy5zY2FsYXIoMS41KSkubXVsKG9wcy5zY2FsYXIoMikpKS5uZWcoKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQucnNxcnQoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3NxdWFyZScpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHgudG9GbG9hdCgpLm11bChvcHMuc2NhbGFyKDIpKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc3F1YXJlKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5yZWNpcHJvY2FsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAncmVjaXByb2NhbCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KHguc3F1YXJlKCkubmVnKCkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnJlY2lwcm9jYWwoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmFicyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2FicycpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHgudG9GbG9hdCgpLnN0ZXAoLTEpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hYnMoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmNsaXBCeVZhbHVlID0gZnVuY3Rpb24gKHgsIGNsaXBWYWx1ZU1pbiwgY2xpcFZhbHVlTWF4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2NsaXBCeVZhbHVlJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KChjbGlwVmFsdWVNaW4gPD0gY2xpcFZhbHVlTWF4KSwgXCJFcnJvciBpbiBjbGlwOiBtaW4gKFwiICsgY2xpcFZhbHVlTWluICsgXCIpIG11c3QgYmUgXCIgK1xuICAgICAgICAgICAgKFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvIG1heCAoXCIgKyBjbGlwVmFsdWVNYXggKyBcIikuXCIpKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkud2hlcmUoeC5ncmVhdGVyRXF1YWwob3BzLnNjYWxhcihjbGlwVmFsdWVNaW4pKVxuICAgICAgICAgICAgICAgICAgICAubG9naWNhbEFuZCh4Lmxlc3NFcXVhbChvcHMuc2NhbGFyKGNsaXBWYWx1ZU1heCkpKSwgb3BzXzEuemVyb3NMaWtlKGR5KSk7IH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5jbGlwKHgsIGNsaXBWYWx1ZU1pbiwgY2xpcFZhbHVlTWF4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMucmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3JlbHUnKTtcbiAgICAgICAgaWYgKHguZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgcmV0dXJuIHgudG9JbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHN0ZXBSZXMgPSB4LnN0ZXAoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdChzdGVwUmVzLnRvRmxvYXQoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQucmVsdSh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnZWx1Jyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5LCBzYXZlZCkge1xuICAgICAgICAgICAgdmFyIHkgPSBzYXZlZFswXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5lbHVEZXIoZHksIHkpOyB9LCB7IGR5OiBkeSwgeTogeSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCwgc2F2ZSkgeyByZXR1cm4gc2F2ZShiYWNrZW5kLmVsdSh4KSk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnNlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdzZWx1Jyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSB4LmdyZWF0ZXIob3BzLnNjYWxhcigwKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZUFscGhhID0gb3BzLnNjYWxhcihzZWx1X3V0aWwuU0VMVV9TQ0FMRUFMUEhBKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gb3BzLnNjYWxhcihzZWx1X3V0aWwuU0VMVV9TQ0FMRSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmVhdGVyVGhhblplcm9EZXIgPSBkeS5tdWwoc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVzc0VxdWFsWmVyb0RlciA9IGR5Lm11bChzY2FsZUFscGhhKS5tdWwoeC50b0Zsb2F0KCkuZXhwKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BzLndoZXJlKG1hc2ssIGdyZWF0ZXJUaGFuWmVyb0RlciwgbGVzc0VxdWFsWmVyb0Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc2VsdSh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMubGVha3lSZWx1ID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4yOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2xlYWt5UmVsdScpO1xuICAgICAgICByZXR1cm4gb3BzLm1heGltdW0ob3BzLnNjYWxhcihhbHBoYSkubXVsKHgpLCB4KTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnByZWx1ID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHgsIGFscGhhOiBhbHBoYSB9LCAncHJlbHUnKTtcbiAgICAgICAgdmFyIHplcm8gPSBvcHMuc2NhbGFyKDApO1xuICAgICAgICByZXR1cm4gb3BzLm1heGltdW0oemVybywgeCkuYWRkKGFscGhhLm11bChvcHMubWluaW11bSh6ZXJvLCB4KSkpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3NpZ21vaWQnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHksIHNhdmVkKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHNhdmVkWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHkubXVsKG9wcy5zY2FsYXIoMSkuc3ViKHkpKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQsIHNhdmUpIHsgcmV0dXJuIHNhdmUoYmFja2VuZC5zaWdtb2lkKHgpKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMubG9nU2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2xvZ1NpZ21vaWQnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdCh4Lm5lZygpLnNpZ21vaWQoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc29mdHBsdXMoeC5uZWcoKSkubmVnKCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnNvZnRwbHVzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc29mdHBsdXMnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdCh4LnNpZ21vaWQoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc29mdHBsdXMoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3NpbicpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4geC50b0Zsb2F0KCkuY29zKCkubXVsU3RyaWN0KGR5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zaW4oeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2NvcycpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4geC50b0Zsb2F0KCkuc2luKCkubmVnKCkubXVsU3RyaWN0KGR5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5jb3MoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnRhbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3RhbicpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KHguY29zKCkuc3F1YXJlKCkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnRhbih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuYXNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2FzaW4nKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHkuZGl2U3RyaWN0KFVuYXJ5T3BzLnNxcnQob3BzLnNjYWxhcigxKS5zdWIoeC50b0Zsb2F0KCkuc3F1YXJlKCkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXNpbih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuYWNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2Fjb3MnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHkuZGl2U3RyaWN0KFVuYXJ5T3BzLnNxcnQob3BzLnNjYWxhcigxKS5zdWIoeC50b0Zsb2F0KCkuc3F1YXJlKCkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZWcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hY29zKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5hdGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnYXRhbicpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KG9wcy5zY2FsYXIoMSkuYWRkKHgudG9GbG9hdCgpLnNxdWFyZSgpKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXRhbih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc2luaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3NpbmgnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHgudG9GbG9hdCgpLmNvc2goKS5tdWxTdHJpY3QoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnNpbmgoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmNvc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdjb3NoJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4LnRvRmxvYXQoKS5zaW5oKCkubXVsU3RyaWN0KGR5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5jb3NoKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy50YW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAndGFuaCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSwgc2F2ZWQpIHtcbiAgICAgICAgICAgIHZhciB5ID0gc2F2ZWRbMF07XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcHMuc2NhbGFyKDEpLnN1Yih5LnNxdWFyZSgpKS5tdWxTdHJpY3QoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kLCBzYXZlKSB7IHJldHVybiBzYXZlKGJhY2tlbmQudGFuaCh4KSk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmFzaW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnYXNpbmgnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHkuZGl2U3RyaWN0KFVuYXJ5T3BzLnNxcnQob3BzLnNjYWxhcigxKS5hZGQoeC50b0Zsb2F0KCkuc3F1YXJlKCkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXNpbmgoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmFjb3NoID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnYWNvc2gnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHkuZGl2U3RyaWN0KFVuYXJ5T3BzLnNxcnQoeC50b0Zsb2F0KCkuc3F1YXJlKCkuc3ViKG9wcy5zY2FsYXIoMSkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYWNvc2goeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmF0YW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnYXRhbmgnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmRpdlN0cmljdChvcHMuc2NhbGFyKDEpLnN1Yih4LnRvRmxvYXQoKS5zcXVhcmUoKSkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmF0YW5oKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5lcmYgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LmR0eXBlID09PSAnaW50MzInIHx8IHguZHR5cGUgPT09ICdmbG9hdDMyJywgJ0lucHV0IGR0eXBlIG11c3QgYmUgYGludDMyYCBvciBgZmxvYXQzMmAuJyk7XG4gICAgICAgIGlmICh4LmR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgICB4ID0geC50b0Zsb2F0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHkubXVsU3RyaWN0KG9wcy5zY2FsYXIoMiAvIE1hdGguc3FydChNYXRoLlBJKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tdWwoeC5zcXVhcmUoKS5uZWcoKS5leHAoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmVyZih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc3RlcCA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdzdGVwJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcHMuemVyb3NMaWtlKGR5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zdGVwKHgsIGFscGhhKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJuZWdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJjZWlsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiZmxvb3JcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzaWduXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwicm91bmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJleHBcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJleHBtMVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImxvZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImxvZzFwXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwic3FydFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInJzcXJ0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwic3F1YXJlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwicmVjaXByb2NhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImFic1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImNsaXBCeVZhbHVlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwicmVsdVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImVsdVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInNlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJsZWFreVJlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJwcmVsdVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInNpZ21vaWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJsb2dTaWdtb2lkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwic29mdHBsdXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzaW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJjb3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJ0YW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJhc2luXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiYWNvc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImF0YW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzaW5oXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiY29zaFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInRhbmhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJhc2luaFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImFjb3NoXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiYXRhbmhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJlcmZcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzdGVwXCIsIG51bGwpO1xuICAgIHJldHVybiBVbmFyeU9wcztcbn0oKSk7XG5leHBvcnRzLlVuYXJ5T3BzID0gVW5hcnlPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmFyeV9vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlcmlhbGl6YXRpb25cIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhZGVsdGFPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGFkZWx0YU9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFkZWx0YU9wdGltaXplcihsZWFybmluZ1JhdGUsIHJobywgZXBzaWxvbikge1xuICAgICAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS04OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMucmhvID0gcmhvO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gZXBzaWxvbjtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRHcmFkcyA9IHt9O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMgPSB7fTtcbiAgICAgICAgX3RoaXMuYyA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigtbGVhcm5pbmdSYXRlKSk7XG4gICAgICAgIF90aGlzLmVwc2lsb25TY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoZXBzaWxvbikpO1xuICAgICAgICBfdGhpcy5yaG9TY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIocmhvKSk7XG4gICAgICAgIF90aGlzLm9uZU1pbnVzUmhvID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKDEgLSByaG8pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAodmFyaWFibGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgaWYgKHRoaXNfMS5hY2N1bXVsYXRlZEdyYWRzW3ZhcmlhYmxlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGVfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNfMS5hY2N1bXVsYXRlZFVwZGF0ZXNbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZV8yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXNbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZV8yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHZhcmlhYmxlR3JhZGllbnRzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0ZWRHcmFkID0gdGhpc18xLmFjY3VtdWxhdGVkR3JhZHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZFVwZGF0ZSA9IHRoaXNfMS5hY2N1bXVsYXRlZFVwZGF0ZXNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0ZWRHcmFkID0gX3RoaXMucmhvU2NhbGFyLm11bChhY2N1bXVsYXRlZEdyYWQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoX3RoaXMub25lTWludXNSaG8ubXVsKGdyYWRpZW50LnNxdWFyZSgpKSk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZXMgPSBhY2N1bXVsYXRlZFVwZGF0ZS5hZGQoX3RoaXMuZXBzaWxvblNjYWxhcilcbiAgICAgICAgICAgICAgICAgICAgLnNxcnQoKVxuICAgICAgICAgICAgICAgICAgICAuZGl2KGFjY3VtdWxhdGVkR3JhZC5hZGQoX3RoaXMuZXBzaWxvblNjYWxhcikuc3FydCgpKVxuICAgICAgICAgICAgICAgICAgICAubXVsKGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0ZWRVcGRhdGUgPSBfdGhpcy5yaG9TY2FsYXIubXVsKGFjY3VtdWxhdGVkVXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKF90aGlzLm9uZU1pbnVzUmhvLm11bCh1cGRhdGVzLnNxdWFyZSgpKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRlZEdyYWQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlc1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRlZFVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuYy5tdWwodXBkYXRlcykuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5hc3NpZ24obmV3VmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciB2YXJpYWJsZU5hbWUgaW4gdmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgICAgIF9sb29wXzEodmFyaWFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZXBzaWxvblNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMucmhvU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVNaW51c1Joby5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzW25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkR3JhZHMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkR3JhZHNbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlYXJuaW5nUmF0ZTogdGhpcy5sZWFybmluZ1JhdGUsXG4gICAgICAgICAgICByaG86IHRoaXMucmhvLFxuICAgICAgICAgICAgZXBzaWxvbjogdGhpcy5lcHNpbG9uXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBZGFkZWx0YU9wdGltaXplci5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xzKGNvbmZpZy5sZWFybmluZ1JhdGUsIGNvbmZpZy5yaG8sIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9O1xuICAgIEFkYWRlbHRhT3B0aW1pemVyLmNsYXNzTmFtZSA9ICdBZGFkZWx0YU9wdGltaXplcic7XG4gICAgcmV0dXJuIEFkYWRlbHRhT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhZGVsdGFPcHRpbWl6ZXIgPSBBZGFkZWx0YU9wdGltaXplcjtcbnNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEFkYWRlbHRhT3B0aW1pemVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYWRlbHRhX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2VyaWFsaXphdGlvblwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFncmFkT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhZ3JhZE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFncmFkT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpIHtcbiAgICAgICAgaWYgKGluaXRpYWxBY2N1bXVsYXRvclZhbHVlID09PSB2b2lkIDApIHsgaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUgPSAwLjE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSA9IGluaXRpYWxBY2N1bXVsYXRvclZhbHVlO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzID0ge307XG4gICAgICAgIF90aGlzLmMgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoLWxlYXJuaW5nUmF0ZSkpO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKDFlLTgpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICBpZiAodGhpc18xLmFjY3VtdWxhdGVkR3JhZHNbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZV8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzW3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuZmlsbCh2YWx1ZS5zaGFwZSwgX3RoaXMuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhcmlhYmxlKHRyYWluYWJsZV8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHZhcmlhYmxlR3JhZGllbnRzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0ZWRHcmFkID0gdGhpc18xLmFjY3VtdWxhdGVkR3JhZHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0ZWRHcmFkID0gYWNjdW11bGF0ZWRHcmFkLmFkZChncmFkaWVudC5zcXVhcmUoKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRlZEdyYWQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IF90aGlzLmNcbiAgICAgICAgICAgICAgICAgICAgLm11bChncmFkaWVudC5kaXYobmV3QWNjdW11bGF0ZWRHcmFkLmFkZChfdGhpcy5lcHNpbG9uKS5zcXJ0KCkpKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5hc3NpZ24obmV3VmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciB2YXJpYWJsZU5hbWUgaW4gdmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgICAgIF9sb29wXzEodmFyaWFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhZ3JhZE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lcHNpbG9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRHcmFkcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkR3JhZHMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkR3JhZHNbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhZ3JhZE9wdGltaXplci5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVhcm5pbmdSYXRlOiB0aGlzLmxlYXJuaW5nUmF0ZSxcbiAgICAgICAgICAgIGluaXRpYWxBY2N1bXVsYXRvclZhbHVlOiB0aGlzLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQWRhZ3JhZE9wdGltaXplci5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xzKGNvbmZpZy5sZWFybmluZ1JhdGUsIGNvbmZpZy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSk7XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLmNsYXNzTmFtZSA9ICdBZGFncmFkT3B0aW1pemVyJztcbiAgICByZXR1cm4gQWRhZ3JhZE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYWdyYWRPcHRpbWl6ZXIgPSBBZGFncmFkT3B0aW1pemVyO1xuc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoQWRhZ3JhZE9wdGltaXplcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFncmFkX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2VyaWFsaXphdGlvblwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFtT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhbU9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFtT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgYmV0YTEsIGJldGEyLCBlcHNpbG9uKSB7XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5iZXRhMSA9IGJldGExO1xuICAgICAgICBfdGhpcy5iZXRhMiA9IGJldGEyO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gZXBzaWxvbjtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCA9IHt9O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCA9IHt9O1xuICAgICAgICBfdGhpcy5jID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKC1sZWFybmluZ1JhdGUpKTtcbiAgICAgICAgX3RoaXMuZXBzU2NhbGFyID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKGVwc2lsb24pKTtcbiAgICAgICAgX3RoaXMuYmV0YTFTY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoYmV0YTEpKTtcbiAgICAgICAgX3RoaXMuYmV0YTJTY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoYmV0YTIpKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYWNjQmV0YTEgPSBvcHNfMS5zY2FsYXIoYmV0YTEpLnZhcmlhYmxlKCk7XG4gICAgICAgICAgICBfdGhpcy5hY2NCZXRhMiA9IG9wc18xLnNjYWxhcihiZXRhMikudmFyaWFibGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uZU1pbnVzQmV0YTEgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSAtIGJldGExKSk7XG4gICAgICAgIF90aGlzLm9uZU1pbnVzQmV0YTIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSAtIGJldGEyKSk7XG4gICAgICAgIF90aGlzLm9uZSA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigxKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhbU9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9uZU1pbnVzQWNjQmV0YTEgPSBfdGhpcy5vbmUuc3ViKF90aGlzLmFjY0JldGExKTtcbiAgICAgICAgICAgIHZhciBvbmVNaW51c0FjY0JldGEyID0gX3RoaXMub25lLnN1YihfdGhpcy5hY2NCZXRhMik7XG4gICAgICAgICAgICBmb3IgKHZhciB2YXJpYWJsZU5hbWUgaW4gdmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFt2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFt2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdmFyaWFibGVHcmFkaWVudHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RNb21lbnQgPSBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZE1vbWVudCA9IF90aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpcnN0TW9tZW50ID0gX3RoaXMuYmV0YTFTY2FsYXIubXVsKGZpcnN0TW9tZW50KVxuICAgICAgICAgICAgICAgICAgICAuYWRkKF90aGlzLm9uZU1pbnVzQmV0YTEubXVsKGdyYWRpZW50KSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NlY29uZE1vbWVudCA9IF90aGlzLmJldGEyU2NhbGFyLm11bChzZWNvbmRNb21lbnQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoX3RoaXMub25lTWludXNCZXRhMi5tdWwoZ3JhZGllbnQuc3F1YXJlKCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgYmlhc0NvcnJlY3RlZEZpcnN0TW9tZW50ID0gbmV3Rmlyc3RNb21lbnQuZGl2KG9uZU1pbnVzQWNjQmV0YTEpO1xuICAgICAgICAgICAgICAgIHZhciBiaWFzQ29ycmVjdGVkU2Vjb25kTW9tZW50ID0gbmV3U2Vjb25kTW9tZW50LmRpdihvbmVNaW51c0FjY0JldGEyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0ZpcnN0TW9tZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFt2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdTZWNvbmRNb21lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IF90aGlzLmNcbiAgICAgICAgICAgICAgICAgICAgLm11bChiaWFzQ29ycmVjdGVkRmlyc3RNb21lbnQuZGl2KF90aGlzLmVwc1NjYWxhci5hZGQoYmlhc0NvcnJlY3RlZFNlY29uZE1vbWVudC5zcXJ0KCkpKSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmFjY0JldGExLmFzc2lnbihfdGhpcy5hY2NCZXRhMS5tdWwoX3RoaXMuYmV0YTFTY2FsYXIpKTtcbiAgICAgICAgICAgIF90aGlzLmFjY0JldGEyLmFzc2lnbihfdGhpcy5hY2NCZXRhMi5tdWwoX3RoaXMuYmV0YTJTY2FsYXIpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmVwc1NjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYmV0YTFTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJldGEyU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2NCZXRhMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjQmV0YTIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uZU1pbnVzQmV0YTEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uZU1pbnVzQmV0YTIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uZS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhbU9wdGltaXplci5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVhcm5pbmdSYXRlOiB0aGlzLmxlYXJuaW5nUmF0ZSxcbiAgICAgICAgICAgIGJldGExOiB0aGlzLmJldGExLFxuICAgICAgICAgICAgYmV0YTI6IHRoaXMuYmV0YTIsXG4gICAgICAgICAgICBlcHNpbG9uOiB0aGlzLmVwc2lsb24sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnLmxlYXJuaW5nUmF0ZSwgY29uZmlnLmJldGExLCBjb25maWcuYmV0YTIsIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9O1xuICAgIEFkYW1PcHRpbWl6ZXIuY2xhc3NOYW1lID0gJ0FkYW1PcHRpbWl6ZXInO1xuICAgIHJldHVybiBBZGFtT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhbU9wdGltaXplciA9IEFkYW1PcHRpbWl6ZXI7XG5zZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihBZGFtT3B0aW1pemVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYW1fb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zZXJpYWxpemF0aW9uXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIEFkYW1heE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYW1heE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFtYXhPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIGVwc2lsb24sIGRlY2F5KSB7XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgaWYgKGRlY2F5ID09PSB2b2lkIDApIHsgZGVjYXkgPSAwLjA7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5iZXRhMSA9IGJldGExO1xuICAgICAgICBfdGhpcy5iZXRhMiA9IGJldGEyO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gZXBzaWxvbjtcbiAgICAgICAgX3RoaXMuZGVjYXkgPSBkZWNheTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCA9IHt9O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybSA9IHt9O1xuICAgICAgICBfdGhpcy5jID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKC1sZWFybmluZ1JhdGUpKTtcbiAgICAgICAgX3RoaXMuZXBzU2NhbGFyID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKGVwc2lsb24pKTtcbiAgICAgICAgX3RoaXMuYmV0YTFTY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoYmV0YTEpKTtcbiAgICAgICAgX3RoaXMuYmV0YTJTY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoYmV0YTIpKTtcbiAgICAgICAgX3RoaXMuZGVjYXlTY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoZGVjYXkpKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaXRlcmF0aW9uID0gb3BzXzEuc2NhbGFyKDApLnZhcmlhYmxlKCk7XG4gICAgICAgICAgICBfdGhpcy5hY2NCZXRhMSA9IG9wc18xLnNjYWxhcihiZXRhMSkudmFyaWFibGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uZU1pbnVzQmV0YTEgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSAtIGJldGExKSk7XG4gICAgICAgIF90aGlzLm9uZSA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigxKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhbWF4T3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb25lTWludXNBY2NCZXRhMSA9IF90aGlzLm9uZS5zdWIoX3RoaXMuYWNjQmV0YTEpO1xuICAgICAgICAgICAgdmFyIGxyID0gX3RoaXMuYy5kaXYoX3RoaXMub25lLmFkZChfdGhpcy5kZWNheVNjYWxhci5tdWwoX3RoaXMuaXRlcmF0aW9uKSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgdmFyaWFibGVOYW1lIGluIHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFt2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHZhcmlhYmxlR3JhZGllbnRzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0TW9tZW50ID0gX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFt2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRlZEluZk5vcm0gPSBfdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVt2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdGaXJzdE1vbWVudCA9IF90aGlzLmJldGExU2NhbGFyLm11bChmaXJzdE1vbWVudClcbiAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5vbmVNaW51c0JldGExLm11bChncmFkaWVudCkpO1xuICAgICAgICAgICAgICAgIHZhciB1dDAgPSBfdGhpcy5iZXRhMlNjYWxhci5tdWwod2VpZ2h0ZWRJbmZOb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgdXQxID0gZ3JhZGllbnQuYWJzKCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1dlaWdodGVkSW5mTm9ybSA9IHV0MC5tYXhpbXVtKHV0MSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFt2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdGaXJzdE1vbWVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bdmFyaWFibGVOYW1lXS5hc3NpZ24obmV3V2VpZ2h0ZWRJbmZOb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBsci5kaXYob25lTWludXNBY2NCZXRhMSlcbiAgICAgICAgICAgICAgICAgICAgLm11bChuZXdGaXJzdE1vbWVudC5kaXYoX3RoaXMuZXBzU2NhbGFyLmFkZChuZXdXZWlnaHRlZEluZk5vcm0pKSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLml0ZXJhdGlvbi5hc3NpZ24oX3RoaXMuaXRlcmF0aW9uLmFkZChfdGhpcy5vbmUpKTtcbiAgICAgICAgICAgIF90aGlzLmFjY0JldGExLmFzc2lnbihfdGhpcy5hY2NCZXRhMS5tdWwoX3RoaXMuYmV0YTFTY2FsYXIpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGFtYXhPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZXBzU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2NCZXRhMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYmV0YTFTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJldGEyU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVNaW51c0JldGExLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5kZWNheVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmUuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtuYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVhcm5pbmdSYXRlOiB0aGlzLmxlYXJuaW5nUmF0ZSxcbiAgICAgICAgICAgIGJldGExOiB0aGlzLmJldGExLFxuICAgICAgICAgICAgYmV0YTI6IHRoaXMuYmV0YTIsXG4gICAgICAgICAgICBlcHNpbG9uOiB0aGlzLmVwc2lsb24sXG4gICAgICAgICAgICBkZWNheTogdGhpcy5kZWNheVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQWRhbWF4T3B0aW1pemVyLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnLmxlYXJuaW5nUmF0ZSwgY29uZmlnLmJldGExLCBjb25maWcuYmV0YTIsIGNvbmZpZy5lcHNpbG9uLCBjb25maWcuZGVjYXkpO1xuICAgIH07XG4gICAgQWRhbWF4T3B0aW1pemVyLmNsYXNzTmFtZSA9ICdBZGFtYXhPcHRpbWl6ZXInO1xuICAgIHJldHVybiBBZGFtYXhPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5BZGFtYXhPcHRpbWl6ZXIgPSBBZGFtYXhPcHRpbWl6ZXI7XG5zZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihBZGFtYXhPcHRpbWl6ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhbWF4X29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2VyaWFsaXphdGlvblwiKTtcbnZhciBzZ2Rfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9zZ2Rfb3B0aW1pemVyXCIpO1xudmFyIE1vbWVudHVtT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9tZW50dW1PcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9tZW50dW1PcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBtb21lbnR1bSwgdXNlTmVzdGVyb3YpIHtcbiAgICAgICAgaWYgKHVzZU5lc3Rlcm92ID09PSB2b2lkIDApIHsgdXNlTmVzdGVyb3YgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMubW9tZW50dW0gPSBtb21lbnR1bTtcbiAgICAgICAgX3RoaXMudXNlTmVzdGVyb3YgPSB1c2VOZXN0ZXJvdjtcbiAgICAgICAgX3RoaXMubSA9IG9wc18xLnNjYWxhcihfdGhpcy5tb21lbnR1bSk7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGlvbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAodmFyaWFibGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgaWYgKHRoaXNfMS5hY2N1bXVsYXRpb25zW3ZhcmlhYmxlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGVfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0aW9uc1t2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGlvbiA9IHRoaXNfMS5hY2N1bXVsYXRpb25zW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSB2YXJpYWJsZUdyYWRpZW50c1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0aW9uID0gX3RoaXMubS5tdWwoYWNjdW11bGF0aW9uKS5hZGQoZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51c2VOZXN0ZXJvdikge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jLm11bChncmFkaWVudC5hZGQobmV3QWNjdW11bGF0aW9uLm11bChfdGhpcy5tKSkpLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IF90aGlzLmMubXVsKG5ld0FjY3VtdWxhdGlvbikuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0aW9uc1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRpb24pO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFzc2lnbihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHZhcmlhYmxlTmFtZSBpbiB2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICAgICAgX2xvb3BfMSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdmFyaWFibGVOYW1lIGluIHRoaXMuYWNjdW11bGF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0aW9uc1t2YXJpYWJsZU5hbWVdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLnNldE1vbWVudHVtID0gZnVuY3Rpb24gKG1vbWVudHVtKSB7XG4gICAgICAgIHRoaXMubW9tZW50dW0gPSBtb21lbnR1bTtcbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWFybmluZ1JhdGU6IHRoaXMubGVhcm5pbmdSYXRlLFxuICAgICAgICAgICAgbW9tZW50dW06IHRoaXMubW9tZW50dW0sXG4gICAgICAgICAgICB1c2VOZXN0ZXJvdjogdGhpcy51c2VOZXN0ZXJvdlxuICAgICAgICB9O1xuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNscyhjb25maWcubGVhcm5pbmdSYXRlLCBjb25maWcubW9tZW50dW0sIGNvbmZpZy51c2VOZXN0ZXJvdik7XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5jbGFzc05hbWUgPSAnTW9tZW50dW1PcHRpbWl6ZXInO1xuICAgIHJldHVybiBNb21lbnR1bU9wdGltaXplcjtcbn0oc2dkX29wdGltaXplcl8xLlNHRE9wdGltaXplcikpO1xuZXhwb3J0cy5Nb21lbnR1bU9wdGltaXplciA9IE1vbWVudHVtT3B0aW1pemVyO1xuc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTW9tZW50dW1PcHRpbWl6ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9tZW50dW1fb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zZXJpYWxpemF0aW9uXCIpO1xudmFyIE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPcHRpbWl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT3B0aW1pemVyLnByb3RvdHlwZS5taW5pbWl6ZSA9IGZ1bmN0aW9uIChmLCByZXR1cm5Db3N0LCB2YXJMaXN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5Db3N0ID09PSB2b2lkIDApIHsgcmV0dXJuQ29zdCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29tcHV0ZUdyYWRpZW50cyhmLCB2YXJMaXN0KSwgdmFsdWUgPSBfYS52YWx1ZSwgZ3JhZHMgPSBfYS5ncmFkcztcbiAgICAgICAgdGhpcy5hcHBseUdyYWRpZW50cyhncmFkcyk7XG4gICAgICAgIHZhciB2YXJOYW1lcyA9IE9iamVjdC5rZXlzKGdyYWRzKTtcbiAgICAgICAgdmFyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodmFyTmFtZSkgeyByZXR1cm4gZ3JhZHNbdmFyTmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgaWYgKHJldHVybkNvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPcHRpbWl6ZXIucHJvdG90eXBlLmNvbXB1dGVHcmFkaWVudHMgPSBmdW5jdGlvbiAoZiwgdmFyTGlzdCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsc18xLnZhcmlhYmxlR3JhZHMoZiwgdmFyTGlzdCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnIH0pXG4gICAgXSwgT3B0aW1pemVyLnByb3RvdHlwZSwgXCJtaW5pbWl6ZVwiLCBudWxsKTtcbiAgICBPcHRpbWl6ZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXIpO1xuICAgIHJldHVybiBPcHRpbWl6ZXI7XG59KHNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemFibGUpKTtcbmV4cG9ydHMuT3B0aW1pemVyID0gT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBhZGFkZWx0YV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2FkYWRlbHRhX29wdGltaXplclwiKTtcbnZhciBhZGFncmFkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vYWRhZ3JhZF9vcHRpbWl6ZXJcIik7XG52YXIgYWRhbV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2FkYW1fb3B0aW1pemVyXCIpO1xudmFyIGFkYW1heF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2FkYW1heF9vcHRpbWl6ZXJcIik7XG52YXIgbW9tZW50dW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9tb21lbnR1bV9vcHRpbWl6ZXJcIik7XG52YXIgcm1zcHJvcF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL3Jtc3Byb3Bfb3B0aW1pemVyXCIpO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NnZF9vcHRpbWl6ZXJcIik7XG52YXIgT3B0aW1pemVyQ29uc3RydWN0b3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMoKSB7XG4gICAgfVxuICAgIE9wdGltaXplckNvbnN0cnVjdG9ycy5zZ2QgPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgc2dkX29wdGltaXplcl8xLlNHRE9wdGltaXplcihsZWFybmluZ1JhdGUpO1xuICAgIH07XG4gICAgT3B0aW1pemVyQ29uc3RydWN0b3JzLm1vbWVudHVtID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgbW9tZW50dW0sIHVzZU5lc3Rlcm92KSB7XG4gICAgICAgIGlmICh1c2VOZXN0ZXJvdiA9PT0gdm9pZCAwKSB7IHVzZU5lc3Rlcm92ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBtb21lbnR1bV9vcHRpbWl6ZXJfMS5Nb21lbnR1bU9wdGltaXplcihsZWFybmluZ1JhdGUsIG1vbWVudHVtLCB1c2VOZXN0ZXJvdik7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMucm1zcHJvcCA9IGZ1bmN0aW9uIChsZWFybmluZ1JhdGUsIGRlY2F5LCBtb21lbnR1bSwgZXBzaWxvbiwgY2VudGVyZWQpIHtcbiAgICAgICAgaWYgKGRlY2F5ID09PSB2b2lkIDApIHsgZGVjYXkgPSAuOTsgfVxuICAgICAgICBpZiAobW9tZW50dW0gPT09IHZvaWQgMCkgeyBtb21lbnR1bSA9IDAuMDsgfVxuICAgICAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS04OyB9XG4gICAgICAgIGlmIChjZW50ZXJlZCA9PT0gdm9pZCAwKSB7IGNlbnRlcmVkID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBybXNwcm9wX29wdGltaXplcl8xLlJNU1Byb3BPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBkZWNheSwgbW9tZW50dW0sIGVwc2lsb24sIGNlbnRlcmVkKTtcbiAgICB9O1xuICAgIE9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFtID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgYmV0YTEsIGJldGEyLCBlcHNpbG9uKSB7XG4gICAgICAgIGlmIChsZWFybmluZ1JhdGUgPT09IHZvaWQgMCkgeyBsZWFybmluZ1JhdGUgPSAwLjAwMTsgfVxuICAgICAgICBpZiAoYmV0YTEgPT09IHZvaWQgMCkgeyBiZXRhMSA9IDAuOTsgfVxuICAgICAgICBpZiAoYmV0YTIgPT09IHZvaWQgMCkgeyBiZXRhMiA9IDAuOTk5OyB9XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBhZGFtX29wdGltaXplcl8xLkFkYW1PcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIGVwc2lsb24pO1xuICAgIH07XG4gICAgT3B0aW1pemVyQ29uc3RydWN0b3JzLmFkYWRlbHRhID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgcmhvLCBlcHNpbG9uKSB7XG4gICAgICAgIGlmIChsZWFybmluZ1JhdGUgPT09IHZvaWQgMCkgeyBsZWFybmluZ1JhdGUgPSAuMDAxOyB9XG4gICAgICAgIGlmIChyaG8gPT09IHZvaWQgMCkgeyByaG8gPSAuOTU7IH1cbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICByZXR1cm4gbmV3IGFkYWRlbHRhX29wdGltaXplcl8xLkFkYWRlbHRhT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgcmhvLCBlcHNpbG9uKTtcbiAgICB9O1xuICAgIE9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFtYXggPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIGVwc2lsb24sIGRlY2F5KSB7XG4gICAgICAgIGlmIChsZWFybmluZ1JhdGUgPT09IHZvaWQgMCkgeyBsZWFybmluZ1JhdGUgPSAwLjAwMjsgfVxuICAgICAgICBpZiAoYmV0YTEgPT09IHZvaWQgMCkgeyBiZXRhMSA9IDAuOTsgfVxuICAgICAgICBpZiAoYmV0YTIgPT09IHZvaWQgMCkgeyBiZXRhMiA9IDAuOTk5OyB9XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgaWYgKGRlY2F5ID09PSB2b2lkIDApIHsgZGVjYXkgPSAwLjA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBhZGFtYXhfb3B0aW1pemVyXzEuQWRhbWF4T3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgYmV0YTEsIGJldGEyLCBlcHNpbG9uLCBkZWNheSk7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhZ3JhZCA9IGZ1bmN0aW9uIChsZWFybmluZ1JhdGUsIGluaXRpYWxBY2N1bXVsYXRvclZhbHVlKSB7XG4gICAgICAgIGlmIChpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSA9PT0gdm9pZCAwKSB7IGluaXRpYWxBY2N1bXVsYXRvclZhbHVlID0gMC4xOyB9XG4gICAgICAgIHJldHVybiBuZXcgYWRhZ3JhZF9vcHRpbWl6ZXJfMS5BZGFncmFkT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdPcHRpbWl6ZXJzJywgbmFtZXNwYWNlOiAndHJhaW4nIH0pXG4gICAgXSwgT3B0aW1pemVyQ29uc3RydWN0b3JzLCBcInNnZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwibW9tZW50dW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdPcHRpbWl6ZXJzJywgbmFtZXNwYWNlOiAndHJhaW4nIH0pXG4gICAgXSwgT3B0aW1pemVyQ29uc3RydWN0b3JzLCBcInJtc3Byb3BcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdPcHRpbWl6ZXJzJywgbmFtZXNwYWNlOiAndHJhaW4nIH0pXG4gICAgXSwgT3B0aW1pemVyQ29uc3RydWN0b3JzLCBcImFkYW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdPcHRpbWl6ZXJzJywgbmFtZXNwYWNlOiAndHJhaW4nIH0pXG4gICAgXSwgT3B0aW1pemVyQ29uc3RydWN0b3JzLCBcImFkYWRlbHRhXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnT3B0aW1pemVycycsIG5hbWVzcGFjZTogJ3RyYWluJyB9KVxuICAgIF0sIE9wdGltaXplckNvbnN0cnVjdG9ycywgXCJhZGFtYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdPcHRpbWl6ZXJzJywgbmFtZXNwYWNlOiAndHJhaW4nIH0pXG4gICAgXSwgT3B0aW1pemVyQ29uc3RydWN0b3JzLCBcImFkYWdyYWRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE9wdGltaXplckNvbnN0cnVjdG9ycztcbn0oKSk7XG5leHBvcnRzLk9wdGltaXplckNvbnN0cnVjdG9ycyA9IE9wdGltaXplckNvbnN0cnVjdG9ycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGltaXplcl9jb25zdHJ1Y3RvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlcmlhbGl6YXRpb25cIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgUk1TUHJvcE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJNU1Byb3BPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUk1TUHJvcE9wdGltaXplcihsZWFybmluZ1JhdGUsIGRlY2F5LCBtb21lbnR1bSwgZXBzaWxvbiwgY2VudGVyZWQpIHtcbiAgICAgICAgaWYgKGRlY2F5ID09PSB2b2lkIDApIHsgZGVjYXkgPSAwLjk7IH1cbiAgICAgICAgaWYgKG1vbWVudHVtID09PSB2b2lkIDApIHsgbW9tZW50dW0gPSAwLjA7IH1cbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICBpZiAoY2VudGVyZWQgPT09IHZvaWQgMCkgeyBjZW50ZXJlZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuZGVjYXkgPSBkZWNheTtcbiAgICAgICAgX3RoaXMubW9tZW50dW0gPSBtb21lbnR1bTtcbiAgICAgICAgX3RoaXMuZXBzaWxvbiA9IGVwc2lsb247XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMgPSB7fTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMgPSB7fTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNb21lbnRzID0ge307XG4gICAgICAgIF90aGlzLmMgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIobGVhcm5pbmdSYXRlKSk7XG4gICAgICAgIF90aGlzLmVwc2lsb25TY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoZXBzaWxvbikpO1xuICAgICAgICBfdGhpcy5kZWNheVNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihkZWNheSkpO1xuICAgICAgICBfdGhpcy5tb21lbnR1bVNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihtb21lbnR1bSkpO1xuICAgICAgICBfdGhpcy5vbmVNaW51c0RlY2F5ID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKDEgLSBkZWNheSkpO1xuICAgICAgICBfdGhpcy5jZW50ZXJlZCA9IGNlbnRlcmVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzID0gZnVuY3Rpb24gKHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIGlmICh0aGlzXzEuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1t2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlXzEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZV8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzXzEuYWNjdW11bGF0ZWRNZWFuR3JhZHNbdmFyaWFibGVOYW1lXSA9PSBudWxsICYmIHRoaXNfMS5jZW50ZXJlZCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGVfMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHNbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZV8yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzXzEuYWNjdW11bGF0ZWRNb21lbnRzW3ZhcmlhYmxlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGVfMyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNb21lbnRzW3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGVfMyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0ZWRNZWFuU3F1YXJlID0gdGhpc18xLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZE1lYW5HcmFkID0gdGhpc18xLmFjY3VtdWxhdGVkTWVhbkdyYWRzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0ZWRNb21lbnRzID0gdGhpc18xLmFjY3VtdWxhdGVkTW9tZW50c1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdmFyaWFibGVHcmFkaWVudHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0ZWRNZWFuU3F1YXJlID0gX3RoaXMuZGVjYXlTY2FsYXIubXVsKGFjY3VtdWxhdGVkTWVhblNxdWFyZSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5vbmVNaW51c0RlY2F5Lm11bChncmFkaWVudC5zcXVhcmUoKSkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jZW50ZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0ZWRNZWFuR3JhZCA9IF90aGlzLmRlY2F5U2NhbGFyLm11bChhY2N1bXVsYXRlZE1lYW5HcmFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5vbmVNaW51c0RlY2F5Lm11bChncmFkaWVudCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0ZWRNb21lbnRzID0gX3RoaXMubW9tZW50dW1TY2FsYXIubXVsKGFjY3VtdWxhdGVkTW9tZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQoX3RoaXMuYy5tdWwoZ3JhZGllbnQpLmRpdihuZXdBY2N1bXVsYXRlZE1lYW5TcXVhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdWIobmV3QWNjdW11bGF0ZWRNZWFuR3JhZC5zcXVhcmUoKS5hZGQoX3RoaXMuZXBzaWxvblNjYWxhcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3FydCgpKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbdmFyaWFibGVOYW1lXS5hc3NpZ24obmV3QWNjdW11bGF0ZWRNZWFuU3F1YXJlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHNbdmFyaWFibGVOYW1lXS5hc3NpZ24obmV3QWNjdW11bGF0ZWRNZWFuR3JhZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkTW9tZW50c1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRlZE1vbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZS5zdWIobmV3QWNjdW11bGF0ZWRNb21lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZE1lYW5TcXVhcmVfMSA9IF90aGlzLmRlY2F5U2NhbGFyLm11bChhY2N1bXVsYXRlZE1lYW5TcXVhcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkKF90aGlzLm9uZU1pbnVzRGVjYXkubXVsKGdyYWRpZW50LnNxdWFyZSgpKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZE1vbWVudHMgPSBfdGhpcy5tb21lbnR1bVNjYWxhci5tdWwoYWNjdW11bGF0ZWRNb21lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5jLm11bChncmFkaWVudCkuZGl2KG5ld0FjY3VtdWxhdGVkTWVhblNxdWFyZV8xLmFkZChfdGhpcy5lcHNpbG9uU2NhbGFyKS5zcXJ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRlZE1lYW5TcXVhcmVfMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkTW9tZW50c1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRlZE1vbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZS5zdWIobmV3QWNjdW11bGF0ZWRNb21lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHZhcmlhYmxlTmFtZSBpbiB2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICAgICAgX2xvb3BfMSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSTVNQcm9wT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmVwc2lsb25TY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmRlY2F5U2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5tb21lbnR1bVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub25lTWludXNEZWNheS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMgIT0gbnVsbCAmJiB0aGlzLmNlbnRlcmVkKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkc1tuYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkTW9tZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkTW9tZW50cylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuYWNjdW11bGF0ZWRNb21lbnRzW25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlYXJuaW5nUmF0ZTogdGhpcy5sZWFybmluZ1JhdGUsXG4gICAgICAgICAgICBkZWNheTogdGhpcy5kZWNheSxcbiAgICAgICAgICAgIG1vbWVudHVtOiB0aGlzLm1vbWVudHVtLFxuICAgICAgICAgICAgZXBzaWxvbjogdGhpcy5lcHNpbG9uLFxuICAgICAgICAgICAgY2VudGVyZWQ6IHRoaXMuY2VudGVyZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNscyhjb25maWcubGVhcm5pbmdSYXRlLCBjb25maWcuZGVjYXksIGNvbmZpZy5tb21lbnR1bSwgY29uZmlnLmVwc2lsb24sIGNvbmZpZy5jZW50ZXJlZCk7XG4gICAgfTtcbiAgICBSTVNQcm9wT3B0aW1pemVyLmNsYXNzTmFtZSA9ICdSTVNQcm9wT3B0aW1pemVyJztcbiAgICByZXR1cm4gUk1TUHJvcE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLlJNU1Byb3BPcHRpbWl6ZXIgPSBSTVNQcm9wT3B0aW1pemVyO1xuc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoUk1TUHJvcE9wdGltaXplcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybXNwcm9wX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2VyaWFsaXphdGlvblwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBTR0RPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTR0RPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU0dET3B0aW1pemVyKGxlYXJuaW5nUmF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLnNldExlYXJuaW5nUmF0ZShsZWFybmluZ1JhdGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNHRE9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZhck5hbWVzID0gT2JqZWN0LmtleXModmFyaWFibGVHcmFkaWVudHMpO1xuICAgICAgICB2YXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSB2YXJpYWJsZUdyYWRpZW50c1t2YXJOYW1lXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3Zhck5hbWVdO1xuICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IF90aGlzLmMubXVsKGdyYWRpZW50KS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFzc2lnbihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLnNldExlYXJuaW5nUmF0ZSA9IGZ1bmN0aW9uIChsZWFybmluZ1JhdGUpIHtcbiAgICAgICAgdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIGlmICh0aGlzLmMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmMgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoLWxlYXJuaW5nUmF0ZSkpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGxlYXJuaW5nUmF0ZTogdGhpcy5sZWFybmluZ1JhdGUgfTtcbiAgICB9O1xuICAgIFNHRE9wdGltaXplci5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xzKGNvbmZpZy5sZWFybmluZ1JhdGUpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLmNsYXNzTmFtZSA9ICdTR0RPcHRpbWl6ZXInO1xuICAgIHJldHVybiBTR0RPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBTR0RPcHRpbWl6ZXI7XG5zZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihTR0RPcHRpbWl6ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2dkX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBQcm9maWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvZmlsZXIoYmFja2VuZFRpbWVyLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kVGltZXIgPSBiYWNrZW5kVGltZXI7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICBpZiAobG9nZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByb2ZpbGVyLnByb3RvdHlwZS5wcm9maWxlS2VybmVsID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGhvbGRSZXN1bHRXcmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aW1lciA9IHRoaXMuYmFja2VuZFRpbWVyLnRpbWUoaG9sZFJlc3VsdFdyYXBwZXJGbik7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHV0aWwuY2hlY2tGb3JOYU4odmFscywgcmVzdWx0LmR0eXBlLCBuYW1lKTtcbiAgICAgICAgdGltZXIudGhlbihmdW5jdGlvbiAodGltaW5nKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nS2VybmVsUHJvZmlsZShuYW1lLCByZXN1bHQsIHZhbHMsIHRpbWluZy5rZXJuZWxNcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFByb2ZpbGVyO1xufSgpKTtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbnZhciBMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcbiAgICB9XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5sb2dLZXJuZWxQcm9maWxlID0gZnVuY3Rpb24gKG5hbWUsIHJlc3VsdCwgdmFscywgdGltZU1zKSB7XG4gICAgICAgIHZhciB0aW1lID0gdXRpbC5yaWdodFBhZCh0aW1lTXMgKyBcIm1zXCIsIDkpO1xuICAgICAgICB2YXIgcGFkZGVkTmFtZSA9IHV0aWwucmlnaHRQYWQobmFtZSwgMjUpO1xuICAgICAgICB2YXIgcmFuayA9IHJlc3VsdC5yYW5rO1xuICAgICAgICB2YXIgc2l6ZSA9IHJlc3VsdC5zaXplO1xuICAgICAgICB2YXIgc2hhcGUgPSB1dGlsLnJpZ2h0UGFkKHJlc3VsdC5zaGFwZS50b1N0cmluZygpLCAxNCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiJWNcIiArIHBhZGRlZE5hbWUgKyBcIlxcdCVjXCIgKyB0aW1lICsgXCJcXHQlY1wiICsgcmFuayArIFwiRCBcIiArIHNoYXBlICsgXCJcXHQlY1wiICsgc2l6ZSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAnY29sb3I6cmVkJywgJ2NvbG9yOmJsdWUnLCAnY29sb3I6IG9yYW5nZScpO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2ZpbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNlcmlhbGl6YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VyaWFsaXphYmxlKCkge1xuICAgIH1cbiAgICBTZXJpYWxpemFibGUucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3JcbiAgICAgICAgICAgIC5jbGFzc05hbWU7XG4gICAgfTtcbiAgICBTZXJpYWxpemFibGUuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNscyhjb25maWcpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcmlhbGl6YWJsZTtcbn0oKSk7XG5leHBvcnRzLlNlcmlhbGl6YWJsZSA9IFNlcmlhbGl6YWJsZTtcbnZhciBTZXJpYWxpemF0aW9uTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJpYWxpemF0aW9uTWFwKCkge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZU1hcCA9IHt9O1xuICAgIH1cbiAgICBTZXJpYWxpemF0aW9uTWFwLmdldE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFNlcmlhbGl6YXRpb25NYXAuaW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgU2VyaWFsaXphdGlvbk1hcC5pbnN0YW5jZSA9IG5ldyBTZXJpYWxpemF0aW9uTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNlcmlhbGl6YXRpb25NYXAuaW5zdGFuY2U7XG4gICAgfTtcbiAgICBTZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGNscykge1xuICAgICAgICB0aGlzLmdldE1hcCgpLmNsYXNzTmFtZU1hcFtjbHMuY2xhc3NOYW1lXSA9IFtjbHMsIGNscy5mcm9tQ29uZmlnXTtcbiAgICB9O1xuICAgIHJldHVybiBTZXJpYWxpemF0aW9uTWFwO1xufSgpKTtcbmV4cG9ydHMuU2VyaWFsaXphdGlvbk1hcCA9IFNlcmlhbGl6YXRpb25NYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0RmlsdGVyZWROb2Rlc1hUb1kodGFwZSwgeHMsIHkpIHtcbiAgICB2YXIgdGVuc29yc0Zyb21YID0ge307XG4gICAgdmFyIG5vZGVzRnJvbVggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRlbnNvcnNGcm9tWFt4c1tpXS5pZF0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0YXBlW2ldO1xuICAgICAgICB2YXIgbm9kZUlucHV0cyA9IG5vZGUuaW5wdXRzO1xuICAgICAgICBmb3IgKHZhciBpbnB1dE5hbWUgaW4gbm9kZUlucHV0cykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZUlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgdmFyIGFueUlucHV0RnJvbVggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgeHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGVuc29yc0Zyb21YW2lucHV0LmlkXSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzRnJvbVhbbm9kZS5vdXRwdXQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYW55SW5wdXRGcm9tWCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzRnJvbVhbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW55SW5wdXRGcm9tWCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB0ZW5zb3JzTGVhZFRvWSA9IHt9O1xuICAgIHRlbnNvcnNMZWFkVG9ZW3kuaWRdID0gdHJ1ZTtcbiAgICB2YXIgbm9kZXNUb1kgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gdGFwZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbm9kZSA9IHRhcGVbaV07XG4gICAgICAgIHZhciBub2RlSW5wdXRzID0gbm9kZS5pbnB1dHM7XG4gICAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICAgIG91dHB1dHMucHVzaChub2RlLm91dHB1dCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0cHV0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRlbnNvcnNMZWFkVG9ZW291dHB1dHNbal0uaWRdKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5wdXROYW1lIGluIG5vZGVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yc0xlYWRUb1lbbm9kZUlucHV0c1tpbnB1dE5hbWVdLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9ZW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZpbHRlcmVkVGFwZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRhcGVbaV07XG4gICAgICAgIGlmIChub2Rlc0Zyb21YW25vZGUuaWRdICYmIG5vZGVzVG9ZW25vZGUuaWRdKSB7XG4gICAgICAgICAgICB2YXIgcHJ1bmVkSW5wdXRzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dE5hbWUgaW4gbm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUlucHV0ID0gbm9kZS5pbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodGVuc29yc0Zyb21YW25vZGVJbnB1dC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVkSW5wdXRzW2lucHV0TmFtZV0gPSBub2RlSW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBydW5lZE5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlKTtcbiAgICAgICAgICAgIHBydW5lZE5vZGUuaW5wdXRzID0gcHJ1bmVkSW5wdXRzO1xuICAgICAgICAgICAgcHJ1bmVkTm9kZS5vdXRwdXQgPSBub2RlLm91dHB1dDtcbiAgICAgICAgICAgIGZpbHRlcmVkVGFwZS5wdXNoKHBydW5lZE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZFRhcGU7XG59XG5leHBvcnRzLmdldEZpbHRlcmVkTm9kZXNYVG9ZID0gZ2V0RmlsdGVyZWROb2Rlc1hUb1k7XG5mdW5jdGlvbiBiYWNrcHJvcGFnYXRlR3JhZGllbnRzKHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXAsIGZpbHRlcmVkVGFwZSkge1xuICAgIGZvciAodmFyIGkgPSBmaWx0ZXJlZFRhcGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBmaWx0ZXJlZFRhcGVbaV07XG4gICAgICAgIHZhciBkeSA9IHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXBbbm9kZS5vdXRwdXQuaWRdO1xuICAgICAgICBpZiAobm9kZS5ncmFkaWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudDogZ3JhZGllbnQgZnVuY3Rpb24gbm90IGZvdW5kIFwiICtcbiAgICAgICAgICAgICAgICAoXCJmb3IgXCIgKyBub2RlLm5hbWUgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dEdyYWRpZW50cyA9IG5vZGUuZ3JhZGllbnQoZHkpO1xuICAgICAgICBmb3IgKHZhciBpbnB1dE5hbWUgaW4gbm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGlmICghKGlucHV0TmFtZSBpbiBpbnB1dEdyYWRpZW50cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYmFja3Byb3AgdGhyb3VnaCBpbnB1dCBcIiArIGlucHV0TmFtZSArIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkF2YWlsYWJsZSBncmFkaWVudHMgZm91bmQ6IFwiICsgT2JqZWN0LmtleXMoaW5wdXRHcmFkaWVudHMpICsgXCIuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkeCA9IGlucHV0R3JhZGllbnRzW2lucHV0TmFtZV0oKTtcbiAgICAgICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChkeC5zaGFwZSwgeC5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgXCIgKyBub2RlLm5hbWUgKyBcIi4gVGhlIGdyYWRpZW50IG9mIGlucHV0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiJ1wiICsgaW5wdXROYW1lICsgXCInIGhhcyBzaGFwZSAnXCIgKyBkeC5zaGFwZSArIFwiJywgd2hpY2ggZG9lcyBub3QgbWF0Y2ggXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwidGhlIHNoYXBlIG9mIHRoZSBpbnB1dCAnXCIgKyB4LnNoYXBlICsgXCInXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW5zb3JBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3guaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW5zb3JBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3guaWRdID0gZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyR3JhZGllbnQgPSB0ZW5zb3JBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3guaWRdO1xuICAgICAgICAgICAgICAgIHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF0gPSBjdXJHcmFkaWVudC5hZGQoZHgpO1xuICAgICAgICAgICAgICAgIGN1ckdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYmFja3Byb3BhZ2F0ZUdyYWRpZW50cyA9IGJhY2twcm9wYWdhdGVHcmFkaWVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4vb3BzL29wc1wiKTtcbnZhciB0ZW5zb3JfdXRpbCA9IHJlcXVpcmUoXCIuL3RlbnNvcl91dGlsXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIFRlbnNvckJ1ZmZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVuc29yQnVmZmVyKHNoYXBlLCBkdHlwZSwgdmFsdWVzKSB7XG4gICAgICAgIHRoaXMuZHR5cGUgPSBkdHlwZTtcbiAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChuID09PSBzaXplLCBcIkxlbmd0aCBvZiB2YWx1ZXMgJ1wiICsgbiArIFwiJyBkb2VzIG5vdCBtYXRjaCB0aGUgc2l6ZSBcIiArXG4gICAgICAgICAgICAgICAgKFwiaW5mZXJyZWQgYnkgdGhlIHNoYXBlICdcIiArIHNpemUgKyBcIidcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZS5zbGljZSgpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9XG4gICAgICAgICAgICB2YWx1ZXMgfHwgdXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKGR0eXBlLCB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpKTtcbiAgICAgICAgdGhpcy5zdHJpZGVzID0gY29tcHV0ZVN0cmlkZXMoc2hhcGUpO1xuICAgICAgICB0aGlzLnNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgIH1cbiAgICBUZW5zb3JCdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvY3MgPSBbMF07XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQobG9jcy5sZW5ndGggPT09IHRoaXMucmFuaywgXCJUaGUgbnVtYmVyIG9mIHByb3ZpZGVkIGNvb3JkaW5hdGVzIChcIiArIGxvY3MubGVuZ3RoICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgKFwiICsgdGhpcy5yYW5rICsgXCIpXCIpKTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sb2NUb0luZGV4KGxvY3MpO1xuICAgICAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9jcyA9IFswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcbiAgICB9O1xuICAgIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2NzKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5yYW5rID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9jcyA9IG5ldyBBcnJheSh0aGlzLnNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGxvY3NbaV0gPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGVzW2ldKTtcbiAgICAgICAgICAgIGluZGV4IC09IGxvY3NbaV0gKiB0aGlzLnN0cmlkZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbG9jc1tsb2NzLmxlbmd0aCAtIDFdID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBsb2NzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbnNvckJ1ZmZlci5wcm90b3R5cGUsIFwicmFua1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZW5zb3JCdWZmZXIucHJvdG90eXBlLnRvVGVuc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gVGVuc29yLm1ha2UodGhpcy5zaGFwZSwgeyB2YWx1ZXM6IHRoaXMudmFsdWVzIH0sIHRoaXMuZHR5cGUpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUsIFwic2V0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBUZW5zb3JCdWZmZXIucHJvdG90eXBlLCBcImdldFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgVGVuc29yQnVmZmVyLnByb3RvdHlwZSwgXCJ0b1RlbnNvclwiLCBudWxsKTtcbiAgICBUZW5zb3JCdWZmZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3JCdWZmZXIpO1xuICAgIHJldHVybiBUZW5zb3JCdWZmZXI7XG59KCkpO1xuZXhwb3J0cy5UZW5zb3JCdWZmZXIgPSBUZW5zb3JCdWZmZXI7XG52YXIgVGVuc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW5zb3Ioc2hhcGUsIGR0eXBlLCB2YWx1ZXMsIGRhdGFJZCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuc2l6ZSA9PT0gdmFsdWVzLmxlbmd0aCwgXCJDb25zdHJ1Y3RpbmcgdGVuc29yIG9mIHNoYXBlIChcIiArIHRoaXMuc2l6ZSArIFwiKSBzaG91bGQgbWF0Y2ggdGhlIFwiICtcbiAgICAgICAgICAgICAgICAoXCJsZW5ndGggb2YgdmFsdWVzIChcIiArIHZhbHVlcy5sZW5ndGggKyBcIilcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZS5zbGljZSgpO1xuICAgICAgICB0aGlzLmR0eXBlID0gZHR5cGUgfHwgJ2Zsb2F0MzInO1xuICAgICAgICB0aGlzLnN0cmlkZXMgPSBjb21wdXRlU3RyaWRlcyhzaGFwZSk7XG4gICAgICAgIHRoaXMuZGF0YUlkID0gZGF0YUlkICE9IG51bGwgPyBkYXRhSWQgOiB7fTtcbiAgICAgICAgdGhpcy5pZCA9IFRlbnNvcl8xLm5leHRJZCsrO1xuICAgICAgICB0aGlzLnJhbmtUeXBlID0gKHRoaXMucmFuayA8IDUgPyB0aGlzLnJhbmsudG9TdHJpbmcoKSA6ICdoaWdoZXInKTtcbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyVGVuc29yKHRoaXMpO1xuICAgICAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS53cml0ZSh0aGlzLmRhdGFJZCwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUZW5zb3JfMSA9IFRlbnNvcjtcbiAgICBUZW5zb3IubWFrZSA9IGZ1bmN0aW9uIChzaGFwZSwgZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JfMShzaGFwZSwgZHR5cGUsIGRhdGEudmFsdWVzLCBkYXRhLmRhdGFJZCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFzMUQoKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXNTY2FsYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuc2l6ZSA9PT0gMSwgJ1RoZSBhcnJheSBtdXN0IGhhdmUgb25seSAxIGVsZW1lbnQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW10pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hczFEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFt0aGlzLnNpemVdKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXMyRCA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3Jvd3MsIGNvbHVtbnNdKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXMzRCA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zLCBkZXB0aCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtyb3dzLCBjb2x1bW5zLCBkZXB0aF0pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hczREID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoLCBkZXB0aDIpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbcm93cywgY29sdW1ucywgZGVwdGgsIGRlcHRoMl0pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hc1R5cGUgPSBmdW5jdGlvbiAoZHR5cGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jYXN0KHRoaXMsIGR0eXBlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW5zb3IucHJvdG90eXBlLCBcInJhbmtcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYXBlLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGVuc29yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQobG9jcy5sZW5ndGggPT09IHRoaXMucmFuaywgJ051bWJlciBvZiBjb29yZGluYXRlcyBpbiBnZXQoKSBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3InKTtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKGxvY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2NzID0gWzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGxvY3NbbG9jcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU3luYygpW2luZGV4XTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3BzLmJ1ZmZlcih0aGlzLnNoYXBlLCB0aGlzLmR0eXBlLCB0aGlzLmRhdGFTeW5jKCkpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWFkKHRoaXMuZGF0YUlkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmRhdGFTeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlYWRTeW5jKHRoaXMuZGF0YUlkKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5kaXNwb3NlVGVuc29yKHRoaXMpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbCA9IHRydWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVuc29yLnByb3RvdHlwZSwgXCJpc0Rpc3Bvc2VkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRlbnNvci5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaXMgZGlzcG9zZWQuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzVHlwZSgnZmxvYXQzMicpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNUeXBlKCdpbnQzMicpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50b0Jvb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzVHlwZSgnYm9vbCcpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uICh2ZXJib3NlKSB7XG4gICAgICAgIGlmICh2ZXJib3NlID09PSB2b2lkIDApIHsgdmVyYm9zZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBvcHMucHJpbnQodGhpcywgdmVyYm9zZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbiAobmV3U2hhcGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5yZXNoYXBlKHRoaXMsIG5ld1NoYXBlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucmVzaGFwZUFzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZSh4LnNoYXBlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZXhwYW5kRGltcyA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG9wcy5leHBhbmREaW1zKHRoaXMsIGF4aXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jdW1zdW0gPSBmdW5jdGlvbiAoYXhpcywgZXhjbHVzaXZlLCByZXZlcnNlKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgaWYgKGV4Y2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGV4Y2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChyZXZlcnNlID09PSB2b2lkIDApIHsgcmV2ZXJzZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBvcHMuY3Vtc3VtKHRoaXMsIGF4aXMsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNxdWVlemUgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNxdWVlemUodGhpcywgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNsb25lKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICh2ZXJib3NlKSB7XG4gICAgICAgIGlmICh2ZXJib3NlID09PSB2b2lkIDApIHsgdmVyYm9zZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfdXRpbC50ZW5zb3JUb1N0cmluZyh0aGlzLCB2ZXJib3NlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudGlsZSA9IGZ1bmN0aW9uIChyZXBzKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMudGlsZSh0aGlzLCByZXBzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZ2F0aGVyID0gZnVuY3Rpb24gKGluZGljZXMsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmdhdGhlcih0aGlzLCBpbmRpY2VzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubWF0TXVsID0gZnVuY3Rpb24gKGIsIHRyYW5zcG9zZUEsIHRyYW5zcG9zZUIpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9zZUEgPT09IHZvaWQgMCkgeyB0cmFuc3Bvc2VBID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRyYW5zcG9zZUIgPT09IHZvaWQgMCkgeyB0cmFuc3Bvc2VCID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tYXRNdWwodGhpcywgYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQik7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZG90KHRoaXMsIGIpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5ub3JtID0gZnVuY3Rpb24gKG9yZCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKG9yZCA9PT0gdm9pZCAwKSB7IG9yZCA9ICdldWNsaWRlYW4nOyB9XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm5vcm0odGhpcywgb3JkLCBheGlzLCBrZWVwRGltcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc2xpY2UodGhpcywgYmVnaW4sIHNpemUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5yZXZlcnNlKHRoaXMsIGF4aXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY29uY2F0KFt0aGlzLCB4XSwgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnN0YWNrID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICByZXR1cm4gb3BzLnN0YWNrKFt0aGlzLCB4XSwgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnVuc3RhY2sgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHJldHVybiBvcHMudW5zdGFjayh0aGlzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucGFkID0gZnVuY3Rpb24gKHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIGlmIChjb25zdGFudFZhbHVlID09PSB2b2lkIDApIHsgY29uc3RhbnRWYWx1ZSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG9wcy5wYWQodGhpcywgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAobWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmJhdGNoTm9ybWFsaXphdGlvbih0aGlzLCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9nU3VtRXhwID0gZnVuY3Rpb24gKGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxvZ1N1bUV4cCh0aGlzLCBheGlzLCBrZWVwRGltcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uIChheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zdW0odGhpcywgYXhpcywga2VlcERpbXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tZWFuID0gZnVuY3Rpb24gKGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1lYW4odGhpcywgYXhpcywga2VlcERpbXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWluKHRoaXMsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1heCh0aGlzLCBheGlzLCBrZWVwRGltcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFyZ01pbiA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hcmdNaW4odGhpcywgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFyZ01heCA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hcmdNYXgodGhpcywgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiAoZHR5cGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jYXN0KHRoaXMsIGR0eXBlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hZGQodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFkZFN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYWRkU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnN1Yih0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3ViU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zdWJTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChleHApIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5wb3codGhpcywgZXhwKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucG93U3RyaWN0ID0gZnVuY3Rpb24gKGV4cCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnBvd1N0cmljdCh0aGlzLCBleHApO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm11bCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubXVsU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tdWxTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZGl2KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5mbG9vckRpdiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZmxvb3JEaXYodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmRpdlN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZGl2U3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5taW5pbXVtID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5taW5pbXVtKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5taW5pbXVtU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5taW5pbXVtU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tYXhpbXVtID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tYXhpbXVtKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tYXhpbXVtU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tYXhpbXVtU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1vZCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubW9kU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tb2RTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zcXVhcmVkRGlmZmVyZW5jZSh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2VTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAocGVybSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnRyYW5zcG9zZSh0aGlzLCBwZXJtKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubm90RXF1YWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm5vdEVxdWFsKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5ub3RFcXVhbFN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubm90RXF1YWxTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxlc3ModGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxlc3NTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxlc3NTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5lcXVhbCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmVxdWFsU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sZXNzRXF1YWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxlc3NFcXVhbCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubGVzc0VxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sZXNzRXF1YWxTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmdyZWF0ZXIodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmdyZWF0ZXJTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmdyZWF0ZXJTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmdyZWF0ZXJFcXVhbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZ3JlYXRlckVxdWFsKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5ncmVhdGVyRXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmdyZWF0ZXJFcXVhbFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9naWNhbEFuZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9naWNhbEFuZCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9naWNhbE9yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sb2dpY2FsT3IodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxvZ2ljYWxOb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9naWNhbE5vdCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9naWNhbFhvciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9naWNhbFhvcih0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCB4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMud2hlcmUoY29uZGl0aW9uLCB0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm5lZyh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jZWlsKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5mbG9vcih0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zaWduKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZXhwKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5leHBtMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5leHBtMSh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxvZyh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9nMXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9nMXAodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc3FydCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucnNxcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMucnNxcnQodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zcXVhcmUodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnJlY2lwcm9jYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMucmVjaXByb2NhbCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFicyh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY2xpcEJ5VmFsdWUgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jbGlwQnlWYWx1ZSh0aGlzLCBtaW4sIG1heCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnJlbHUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMucmVsdSh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZWx1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmVsdSh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc2VsdSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zZWx1KHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sZWFreVJlbHUgPSBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjI7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sZWFreVJlbHUodGhpcywgYWxwaGEpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5wcmVsdSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnByZWx1KHRoaXMsIGFscGhhKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc2lnbW9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zaWdtb2lkKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2dTaWdtb2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxvZ1NpZ21vaWQodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNvZnRwbHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNvZnRwbHVzKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc2luKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY29zKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50YW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMudGFuKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hc2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFzaW4odGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFjb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYWNvcyh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXRhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hdGFuKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zaW5oID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNpbmgodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNvc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY29zaCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudGFuaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy50YW5oKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hc2luaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hc2luaCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYWNvc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYWNvc2godGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmF0YW5oID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmF0YW5oKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5lcmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZXJmKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5yb3VuZCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnN0ZXAodGhpcywgYWxwaGEpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zb2Z0bWF4ID0gZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICBpZiAoZGltID09PSB2b2lkIDApIHsgZGltID0gLTE7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zb2Z0bWF4KHRoaXMsIGRpbSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyID0gZnVuY3Rpb24gKG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykge1xuICAgICAgICBpZiAoYWxpZ25Db3JuZXJzID09PSB2b2lkIDApIHsgYWxpZ25Db3JuZXJzID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5pbWFnZS5yZXNpemVCaWxpbmVhcih0aGlzLCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IgPSBmdW5jdGlvbiAobmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIGlmIChhbGlnbkNvcm5lcnMgPT09IHZvaWQgMCkgeyBhbGlnbkNvcm5lcnMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmltYWdlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcih0aGlzLCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jb252MWQgPSBmdW5jdGlvbiAoZmlsdGVyLCBzdHJpZGUsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb24sIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnTldDJzsgfVxuICAgICAgICBpZiAoZGlsYXRpb24gPT09IHZvaWQgMCkgeyBkaWxhdGlvbiA9IDE7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb252MWQodGhpcywgZmlsdGVyLCBzdHJpZGUsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb24sIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uIChmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRhRm9ybWF0ID0gJ05IV0MnOyB9XG4gICAgICAgIGlmIChkaWxhdGlvbnMgPT09IHZvaWQgMCkgeyBkaWxhdGlvbnMgPSBbMSwgMV07IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb252MmQodGhpcywgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRhdGFGb3JtYXQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY29udjJkVHJhbnNwb3NlID0gZnVuY3Rpb24gKGZpbHRlciwgb3V0cHV0U2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY29udjJkVHJhbnNwb3NlKHRoaXMsIGZpbHRlciwgb3V0cHV0U2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEID0gZnVuY3Rpb24gKGZpbHRlciwgc3RyaWRlcywgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnTkhXQyc7IH1cbiAgICAgICAgaWYgKGRpbGF0aW9ucyA9PT0gdm9pZCAwKSB7IGRpbGF0aW9ucyA9IFsxLCAxXTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmRlcHRod2lzZUNvbnYyZCh0aGlzLCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hdmdQb29sID0gZnVuY3Rpb24gKGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYXZnUG9vbCh0aGlzLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1heFBvb2wgPSBmdW5jdGlvbiAoZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tYXhQb29sKHRoaXMsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAocmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSkge1xuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHsgcmFkaXVzID0gNTsgfVxuICAgICAgICBpZiAoYmlhcyA9PT0gdm9pZCAwKSB7IGJpYXMgPSAxOyB9XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMTsgfVxuICAgICAgICBpZiAoYmV0YSA9PT0gdm9pZCAwKSB7IGJldGEgPSAwLjU7IH1cbiAgICAgICAgcmV0dXJuIG9wcy5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbih0aGlzLCByYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbiAodHJhaW5hYmxlLCBuYW1lLCBkdHlwZSkge1xuICAgICAgICBpZiAodHJhaW5hYmxlID09PSB2b2lkIDApIHsgdHJhaW5hYmxlID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gVmFyaWFibGUudmFyaWFibGUodGhpcywgdHJhaW5hYmxlLCBuYW1lLCBkdHlwZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bSA9IGZ1bmN0aW9uIChzZWdtZW50SWRzLCBudW1TZWdtZW50cywgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMudW5zb3J0ZWRTZWdtZW50U3VtKHRoaXMsIHNlZ21lbnRJZHMsIG51bVNlZ21lbnRzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5uZXh0SWQgPSAwO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiZmxhdHRlblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImFzU2NhbGFyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiYXMxRFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImFzMkRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJhczNEXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiYXM0RFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImFzVHlwZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImJ1ZmZlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImRhdGFcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJkYXRhU3luY1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImRpc3Bvc2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJ0b0Zsb2F0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwidG9JbnRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJ0b0Jvb2xcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJwcmludFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcInJlc2hhcGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJyZXNoYXBlQXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJleHBhbmREaW1zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiY3Vtc3VtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwic3F1ZWV6ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImNsb25lXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gICAgVGVuc29yID0gVGVuc29yXzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IpO1xuICAgIHJldHVybiBUZW5zb3I7XG4gICAgdmFyIFRlbnNvcl8xO1xufSgpKTtcbmV4cG9ydHMuVGVuc29yID0gVGVuc29yO1xudmFyIFZhcmlhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFyaWFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFyaWFibGUoaW5pdGlhbFZhbHVlLCB0cmFpbmFibGUsIG5hbWUpIHtcbiAgICAgICAgaWYgKHRyYWluYWJsZSA9PT0gdm9pZCAwKSB7IHRyYWluYWJsZSA9IHRydWU7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbFZhbHVlLnNoYXBlLCBpbml0aWFsVmFsdWUuZHR5cGUsIG51bGwsIGluaXRpYWxWYWx1ZS5kYXRhSWQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRyYWluYWJsZSA9IHRyYWluYWJsZTtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmIChfdGhpcy5uYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBWYXJpYWJsZV8xLm5leHRWYXJJZC50b1N0cmluZygpO1xuICAgICAgICAgICAgVmFyaWFibGVfMS5uZXh0VmFySWQrKztcbiAgICAgICAgfVxuICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJWYXJpYWJsZShfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmFyaWFibGVfMSA9IFZhcmlhYmxlO1xuICAgIFZhcmlhYmxlLnZhcmlhYmxlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSwgdHJhaW5hYmxlLCBuYW1lLCBkdHlwZSkge1xuICAgICAgICBpZiAodHJhaW5hYmxlID09PSB2b2lkIDApIHsgdHJhaW5hYmxlID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoZHR5cGUgIT0gbnVsbCAmJiBkdHlwZSAhPT0gaW5pdGlhbFZhbHVlLmR0eXBlKSB7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWUuYXNUeXBlKGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlXzEoaW5pdGlhbFZhbHVlLCB0cmFpbmFibGUsIG5hbWUpO1xuICAgIH07XG4gICAgVmFyaWFibGUucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUuZHR5cGUgIT09IHRoaXMuZHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR0eXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiICsgbmV3VmFsdWUuZHR5cGUgKyBcIikgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAoXCJwcmV2aW91cyB2YWx1ZSAoXCIgKyB0aGlzLmR0eXBlICsgXCIpIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChuZXdWYWx1ZS5zaGFwZSwgdGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiICsgbmV3VmFsdWUuc2hhcGUgKyBcIikgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAoXCJwcmV2aW91cyB2YWx1ZSAoXCIgKyB0aGlzLnNoYXBlICsgXCIpIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5kaXNwb3NlVGVuc29yKHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGFJZCA9IG5ld1ZhbHVlLmRhdGFJZDtcbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyVGVuc29yKHRoaXMpO1xuICAgIH07XG4gICAgVmFyaWFibGUubmV4dFZhcklkID0gMDtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBWYXJpYWJsZS5wcm90b3R5cGUsIFwiYXNzaWduXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBWYXJpYWJsZSwgXCJ2YXJpYWJsZVwiLCBudWxsKTtcbiAgICBWYXJpYWJsZSA9IFZhcmlhYmxlXzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBWYXJpYWJsZSk7XG4gICAgcmV0dXJuIFZhcmlhYmxlO1xuICAgIHZhciBWYXJpYWJsZV8xO1xufShUZW5zb3IpKTtcbmV4cG9ydHMuVmFyaWFibGUgPSBWYXJpYWJsZTtcbnZhciB2YXJpYWJsZSA9IFZhcmlhYmxlLnZhcmlhYmxlO1xuZXhwb3J0cy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuZnVuY3Rpb24gY29tcHV0ZVN0cmlkZXMoc2hhcGUpIHtcbiAgICB2YXIgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yICh2YXIgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzdHJpZGVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIEZPUk1BVF9MSU1JVF9OVU1fVkFMUyA9IDIwO1xudmFyIEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTID0gMztcbnZhciBGT1JNQVRfTlVNX1NJR19ESUdJVFMgPSA3O1xuZnVuY3Rpb24gdGVuc29yVG9TdHJpbmcodCwgdmVyYm9zZSkge1xuICAgIHZhciB2YWxzID0gdC5kYXRhU3luYygpO1xuICAgIHZhciBwYWRQZXJDb2wgPSBjb21wdXRlTWF4U2l6ZVBlckNvbHVtbih0KTtcbiAgICB2YXIgdmFsc0xpbmVzID0gc3ViVGVuc29yVG9TdHJpbmcodmFscywgdC5zaGFwZSwgdC5zdHJpZGVzLCBwYWRQZXJDb2wpO1xuICAgIHZhciBsaW5lcyA9IFsnVGVuc29yJ107XG4gICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgbGluZXMucHVzaChcIiAgZHR5cGU6IFwiICsgdC5kdHlwZSk7XG4gICAgICAgIGxpbmVzLnB1c2goXCIgIHJhbms6IFwiICsgdC5yYW5rKTtcbiAgICAgICAgbGluZXMucHVzaChcIiAgc2hhcGU6IFtcIiArIHQuc2hhcGUgKyBcIl1cIik7XG4gICAgICAgIGxpbmVzLnB1c2goXCIgIHZhbHVlczpcIik7XG4gICAgfVxuICAgIGxpbmVzLnB1c2godmFsc0xpbmVzLm1hcChmdW5jdGlvbiAobCkgeyByZXR1cm4gJyAgICAnICsgbDsgfSkuam9pbignXFxuJykpO1xuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn1cbmV4cG9ydHMudGVuc29yVG9TdHJpbmcgPSB0ZW5zb3JUb1N0cmluZztcbmZ1bmN0aW9uIGNvbXB1dGVNYXhTaXplUGVyQ29sdW1uKHQpIHtcbiAgICB2YXIgdmFscyA9IHQuZGF0YVN5bmMoKTtcbiAgICB2YXIgbiA9IHQuc2l6ZTtcbiAgICB2YXIgbnVtQ29scyA9IHQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHBhZFBlckNvbCA9IG5ldyBBcnJheShudW1Db2xzKS5maWxsKDApO1xuICAgIGlmICh0LnJhbmsgPiAxKSB7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG4gLyBudW1Db2xzOyByb3crKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJvdyAqIG51bUNvbHM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNvbHM7IGorKykge1xuICAgICAgICAgICAgICAgIHBhZFBlckNvbFtqXSA9XG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHBhZFBlckNvbFtqXSwgdmFsVG9TdHJpbmcodmFsc1tvZmZzZXQgKyBqXSwgMCkubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFkUGVyQ29sO1xufVxuZnVuY3Rpb24gdmFsVG9TdHJpbmcodmFsLCBwYWQpIHtcbiAgICByZXR1cm4gdXRpbC5yaWdodFBhZChwYXJzZUZsb2F0KHZhbC50b0ZpeGVkKEZPUk1BVF9OVU1fU0lHX0RJR0lUUykpLnRvU3RyaW5nKCksIHBhZCk7XG59XG5mdW5jdGlvbiBzdWJUZW5zb3JUb1N0cmluZyh2YWxzLCBzaGFwZSwgc3RyaWRlcywgcGFkUGVyQ29sLCBpc0xhc3QpIHtcbiAgICBpZiAoaXNMYXN0ID09PSB2b2lkIDApIHsgaXNMYXN0ID0gdHJ1ZTsgfVxuICAgIHZhciBzaXplID0gc2hhcGVbMF07XG4gICAgdmFyIHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFt2YWxzWzBdLnRvU3RyaW5nKCldO1xuICAgIH1cbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICBpZiAoc2l6ZSA+IEZPUk1BVF9MSU1JVF9OVU1fVkFMUykge1xuICAgICAgICAgICAgdmFyIGZpcnN0VmFscyA9IEFycmF5LmZyb20odmFscy5zdWJhcnJheSgwLCBGT1JNQVRfTlVNX0ZJUlNUX0xBU1RfVkFMUykpO1xuICAgICAgICAgICAgdmFyIGxhc3RWYWxzID0gQXJyYXkuZnJvbSh2YWxzLnN1YmFycmF5KHNpemUgLSBGT1JNQVRfTlVNX0ZJUlNUX0xBU1RfVkFMUywgc2l6ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnWycgKyBmaXJzdFZhbHMubWFwKGZ1bmN0aW9uICh4LCBpKSB7IHJldHVybiB2YWxUb1N0cmluZyh4LCBwYWRQZXJDb2xbaV0pOyB9KS5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICAgICAgJywgLi4uLCAnICtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFZhbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuIHZhbFRvU3RyaW5nKHgsIHBhZFBlckNvbFtzaXplIC0gRk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFMgKyBpXSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKSArXG4gICAgICAgICAgICAgICAgICAgICddJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ1snICtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHZhbHMpLm1hcChmdW5jdGlvbiAoeCwgaSkgeyByZXR1cm4gdmFsVG9TdHJpbmcoeCwgcGFkUGVyQ29sW2ldKTsgfSkuam9pbignLCAnKSArXG4gICAgICAgICAgICAgICAgJ10nXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciBzdWJzaGFwZSA9IHNoYXBlLnNsaWNlKDEpO1xuICAgIHZhciBzdWJzdHJpZGVzID0gc3RyaWRlcy5zbGljZSgxKTtcbiAgICB2YXIgc3RyaWRlID0gc3RyaWRlc1swXTtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICBpZiAoc2l6ZSA+IEZPUk1BVF9MSU1JVF9OVU1fVkFMUykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGkgKiBzdHJpZGU7XG4gICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBzdHJpZGU7XG4gICAgICAgICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCBzdWJUZW5zb3JUb1N0cmluZyh2YWxzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLCBzdWJzaGFwZSwgc3Vic3RyaWRlcywgcGFkUGVyQ29sLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVzLnB1c2goJy4uLicpO1xuICAgICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBpICogc3RyaWRlO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgc3RyaWRlO1xuICAgICAgICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgc3ViVGVuc29yVG9TdHJpbmcodmFscy5zdWJhcnJheShzdGFydCwgZW5kKSwgc3Vic2hhcGUsIHN1YnN0cmlkZXMsIHBhZFBlckNvbCwgaSA9PT0gc2l6ZSAtIDEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGkgKiBzdHJpZGU7XG4gICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBzdHJpZGU7XG4gICAgICAgICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCBzdWJUZW5zb3JUb1N0cmluZyh2YWxzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLCBzdWJzaGFwZSwgc3Vic3RyaWRlcywgcGFkUGVyQ29sLCBpID09PSBzaXplIC0gMSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzZXAgPSByYW5rID09PSAyID8gJywnIDogJyc7XG4gICAgbGluZXNbMF0gPSAnWycgKyBsaW5lc1swXSArIHNlcDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9ICcgJyArIGxpbmVzW2ldICsgc2VwO1xuICAgIH1cbiAgICB2YXIgbmV3TGluZVNlcCA9ICcsXFxuJztcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHJhbms7IGkrKykge1xuICAgICAgICBuZXdMaW5lU2VwICs9ICdcXG4nO1xuICAgIH1cbiAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9XG4gICAgICAgICcgJyArIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICsgJ10nICsgKGlzTGFzdCA/ICcnIDogbmV3TGluZVNlcCk7XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi90ZW5zb3JcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5leHBvcnRzLldFQkdMX0VOVlMgPSB7XG4gICAgJ0JBQ0tFTkQnOiAndGVzdC13ZWJnbCdcbn07XG5leHBvcnRzLkNQVV9FTlZTID0ge1xuICAgICdCQUNLRU5EJzogJ3Rlc3QtY3B1J1xufTtcbmV4cG9ydHMuQUxMX0VOVlMgPSB7fTtcbmV4cG9ydHMuVEVTVF9FUFNJTE9OID0gMWUtMztcbmZ1bmN0aW9uIGV4cGVjdEFycmF5c0Nsb3NlKGFjdHVhbCwgZXhwZWN0ZWQsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSBleHBvcnRzLlRFU1RfRVBTSUxPTjsgfVxuICAgIGlmICghKGFjdHVhbCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikgJiYgIShleHBlY3RlZCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikpIHtcbiAgICAgICAgdmFyIGFUeXBlID0gYWN0dWFsLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHZhciBiVHlwZSA9IGV4cGVjdGVkLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUgYWN0dWFsOiBcIiArIGFUeXBlICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgIChcInZzIGV4cGVjdGVkOiBcIiArIGJUeXBlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgIGlmIChhY3R1YWwuZHR5cGUgIT09IGV4cGVjdGVkLmR0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlIGFjdHVhbDogXCIgKyBhY3R1YWwuZHR5cGUgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgKFwidnMgZXhwZWN0ZWQ6IFwiICsgZXhwZWN0ZWQuZHR5cGUgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWwuc2hhcGUsIGV4cGVjdGVkLnNoYXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgc2hhcGUgYWN0dWFsOiBcIiArIGFjdHVhbC5zaGFwZSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ2cyBleHBlY3RlZDogXCIgKyBleHBlY3RlZC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFjdHVhbFZhbHVlcztcbiAgICB2YXIgZXhwZWN0ZWRWYWx1ZXM7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikge1xuICAgICAgICBhY3R1YWxWYWx1ZXMgPSBhY3R1YWwuZGF0YVN5bmMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjdHVhbFZhbHVlcyA9IGFjdHVhbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgIGV4cGVjdGVkVmFsdWVzID0gZXhwZWN0ZWQuZGF0YVN5bmMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cGVjdGVkVmFsdWVzID0gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIGlmIChhY3R1YWxWYWx1ZXMubGVuZ3RoICE9PSBleHBlY3RlZFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgYWN0dWFsOiBcIiArIGFjdHVhbFZhbHVlcy5sZW5ndGggKyBcIiB2cyBcIiArXG4gICAgICAgICAgICAoXCJleHBlY3RlZDogXCIgKyBleHBlY3RlZFZhbHVlcy5sZW5ndGggKyBcIi5cXG5cIikgK1xuICAgICAgICAgICAgKFwiQWN0dWFsOiAgIFwiICsgYWN0dWFsVmFsdWVzICsgXCIuXFxuXCIpICtcbiAgICAgICAgICAgIChcIkV4cGVjdGVkOiBcIiArIGV4cGVjdGVkVmFsdWVzICsgXCIuXCIpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYSA9IGFjdHVhbFZhbHVlc1tpXTtcbiAgICAgICAgdmFyIGUgPSBleHBlY3RlZFZhbHVlc1tpXTtcbiAgICAgICAgaWYgKCFhcmVDbG9zZShhLCBOdW1iZXIoZSksIGVwc2lsb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgZGlmZmVyOiBhY3R1YWxbXCIgKyBpICsgXCJdID0gXCIgKyBhICsgXCIsIGV4cGVjdGVkW1wiICsgaSArIFwiXSA9IFwiICsgZSArIFwiLlxcblwiICtcbiAgICAgICAgICAgICAgICAoXCJBY3R1YWw6ICAgXCIgKyBhY3R1YWxWYWx1ZXMgKyBcIi5cXG5cIikgK1xuICAgICAgICAgICAgICAgIChcIkV4cGVjdGVkOiBcIiArIGV4cGVjdGVkVmFsdWVzICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0QXJyYXlzQ2xvc2UgPSBleHBlY3RBcnJheXNDbG9zZTtcbmZ1bmN0aW9uIGV4cGVjdFByb21pc2VUb0ZhaWwoZm4sIGRvbmUpIHtcbiAgICBmbigpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9uZS5mYWlsKCk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbmUoKTsgfSk7XG59XG5leHBvcnRzLmV4cGVjdFByb21pc2VUb0ZhaWwgPSBleHBlY3RQcm9taXNlVG9GYWlsO1xuZnVuY3Rpb24gZXhwZWN0QXJyYXlzRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAgIHJldHVybiBleHBlY3RBcnJheXNDbG9zZShhY3R1YWwsIGV4cGVjdGVkLCAwKTtcbn1cbmV4cG9ydHMuZXhwZWN0QXJyYXlzRXF1YWwgPSBleHBlY3RBcnJheXNFcXVhbDtcbmZ1bmN0aW9uIGV4cGVjdE51bWJlcnNDbG9zZShhLCBlLCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gZXhwb3J0cy5URVNUX0VQU0lMT047IH1cbiAgICBpZiAoIWFyZUNsb3NlKGEsIGUsIGVwc2lsb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlcnMgZGlmZmVyOiBhY3R1YWwgPT09IFwiICsgYSArIFwiLCBleHBlY3RlZCA9PT0gXCIgKyBlKTtcbiAgICB9XG59XG5leHBvcnRzLmV4cGVjdE51bWJlcnNDbG9zZSA9IGV4cGVjdE51bWJlcnNDbG9zZTtcbmZ1bmN0aW9uIGFyZUNsb3NlKGEsIGUsIGVwc2lsb24pIHtcbiAgICBpZiAoaXNOYU4oYSkgJiYgaXNOYU4oZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc05hTihhKSB8fCBpc05hTihlKSB8fCBNYXRoLmFicyhhIC0gZSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBleHBlY3RWYWx1ZXNJblJhbmdlKGFjdHVhbCwgbG93LCBoaWdoKSB7XG4gICAgdmFyIGFjdHVhbFZhbHM7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikge1xuICAgICAgICBhY3R1YWxWYWxzID0gYWN0dWFsLmRhdGFTeW5jKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY3R1YWxWYWxzID0gYWN0dWFsO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbFZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFjdHVhbFZhbHNbaV0gPCBsb3cgfHwgYWN0dWFsVmFsc1tpXSA+IGhpZ2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIG91dCBvZiByYW5nZTpcIiArIGFjdHVhbFZhbHNbaV0gKyBcIiBsb3c6IFwiICsgbG93ICsgXCIsIGhpZ2g6IFwiICsgaGlnaCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmV4cGVjdFZhbHVlc0luUmFuZ2UgPSBleHBlY3RWYWx1ZXNJblJhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVzdF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIFRyYWNraW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFja2luZygpIHtcbiAgICB9XG4gICAgVHJhY2tpbmcudGlkeSA9IGZ1bmN0aW9uIChuYW1lT3JGbiwgZm4sIGdyYWRNb2RlKSB7XG4gICAgICAgIGlmIChncmFkTW9kZSA9PT0gdm9pZCAwKSB7IGdyYWRNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lT3JGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byB0aWR5KCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuID0gbmFtZU9yRm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVPckZuICE9PSAnc3RyaW5nJyAmJiAhKG5hbWVPckZuIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIGZpcnN0IGFyZ3VtZW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAndG8gdGlkeSgpIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSAybmQgYXJndW1lbnQgJyArXG4gICAgICAgICAgICAgICAgICAgICd0byB0aWR5KCkgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbmFtZU9yRm47XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnN0YXJ0U2NvcGUobmFtZSwgZ3JhZE1vZGUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZm4oKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCByZXR1cm4gYSBQcm9taXNlIGluc2lkZSBvZiB0aWR5LicpO1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5lbmRTY29wZShyZXN1bHQsIGdyYWRNb2RlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFRyYWNraW5nLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciB0ZW5zb3JzID0gdXRpbF8xLmdldFRlbnNvcnNJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmRpc3Bvc2UoKTsgfSk7XG4gICAgfTtcbiAgICBUcmFja2luZy5rZWVwID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmtlZXAocmVzdWx0KTtcbiAgICB9O1xuICAgIFRyYWNraW5nLnRpbWUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnRpbWUoZik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1BlcmZvcm1hbmNlJywgc3ViaGVhZGluZzogJ01lbW9yeScgfSlcbiAgICBdLCBUcmFja2luZywgXCJ0aWR5XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnUGVyZm9ybWFuY2UnLCBzdWJoZWFkaW5nOiAnTWVtb3J5JyB9KVxuICAgIF0sIFRyYWNraW5nLCBcImRpc3Bvc2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdQZXJmb3JtYW5jZScsIHN1YmhlYWRpbmc6ICdNZW1vcnknIH0pXG4gICAgXSwgVHJhY2tpbmcsIFwia2VlcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1BlcmZvcm1hbmNlJywgc3ViaGVhZGluZzogJ1RpbWluZycgfSlcbiAgICBdLCBUcmFja2luZywgXCJ0aW1lXCIsIG51bGwpO1xuICAgIHJldHVybiBUcmFja2luZztcbn0oKSk7XG5leHBvcnRzLlRyYWNraW5nID0gVHJhY2tpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhZGFkZWx0YV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvYWRhZGVsdGFfb3B0aW1pemVyXCIpO1xudmFyIGFkYWdyYWRfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYWdyYWRfb3B0aW1pemVyXCIpO1xudmFyIGFkYW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYW1fb3B0aW1pemVyXCIpO1xudmFyIGFkYW1heF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvYWRhbWF4X29wdGltaXplclwiKTtcbnZhciBtb21lbnR1bV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvbW9tZW50dW1fb3B0aW1pemVyXCIpO1xudmFyIG9wdGltaXplcl9jb25zdHJ1Y3RvcnNfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvb3B0aW1pemVyX2NvbnN0cnVjdG9yc1wiKTtcbnZhciBybXNwcm9wX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9ybXNwcm9wX29wdGltaXplclwiKTtcbnZhciBzZ2Rfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL3NnZF9vcHRpbWl6ZXJcIik7XG5bbW9tZW50dW1fb3B0aW1pemVyXzEuTW9tZW50dW1PcHRpbWl6ZXIsIHNnZF9vcHRpbWl6ZXJfMS5TR0RPcHRpbWl6ZXIsIGFkYWRlbHRhX29wdGltaXplcl8xLkFkYWRlbHRhT3B0aW1pemVyLCBhZGFncmFkX29wdGltaXplcl8xLkFkYWdyYWRPcHRpbWl6ZXIsXG4gICAgcm1zcHJvcF9vcHRpbWl6ZXJfMS5STVNQcm9wT3B0aW1pemVyLCBhZGFtYXhfb3B0aW1pemVyXzEuQWRhbWF4T3B0aW1pemVyLCBhZGFtX29wdGltaXplcl8xLkFkYW1PcHRpbWl6ZXJdO1xuZXhwb3J0cy50cmFpbiA9IHtcbiAgICBzZ2Q6IG9wdGltaXplcl9jb25zdHJ1Y3RvcnNfMS5PcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuc2dkLFxuICAgIG1vbWVudHVtOiBvcHRpbWl6ZXJfY29uc3RydWN0b3JzXzEuT3B0aW1pemVyQ29uc3RydWN0b3JzLm1vbWVudHVtLFxuICAgIGFkYWRlbHRhOiBvcHRpbWl6ZXJfY29uc3RydWN0b3JzXzEuT3B0aW1pemVyQ29uc3RydWN0b3JzLmFkYWRlbHRhLFxuICAgIGFkYWdyYWQ6IG9wdGltaXplcl9jb25zdHJ1Y3RvcnNfMS5PcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhZ3JhZCxcbiAgICBybXNwcm9wOiBvcHRpbWl6ZXJfY29uc3RydWN0b3JzXzEuT3B0aW1pemVyQ29uc3RydWN0b3JzLnJtc3Byb3AsXG4gICAgYWRhbWF4OiBvcHRpbWl6ZXJfY29uc3RydWN0b3JzXzEuT3B0aW1pemVyQ29uc3RydWN0b3JzLmFkYW1heCxcbiAgICBhZGFtOiBvcHRpbWl6ZXJfY29uc3RydWN0b3JzXzEuT3B0aW1pemVyQ29uc3RydWN0b3JzLmFkYW1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFpbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEVHlwZTtcbihmdW5jdGlvbiAoRFR5cGUpIHtcbiAgICBEVHlwZVtcImZsb2F0MzJcIl0gPSBcImZsb2F0MzJcIjtcbiAgICBEVHlwZVtcImludDMyXCJdID0gXCJpbnQzMlwiO1xuICAgIERUeXBlW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xufSkoRFR5cGUgPSBleHBvcnRzLkRUeXBlIHx8IChleHBvcnRzLkRUeXBlID0ge30pKTtcbnZhciBSYW5rO1xuKGZ1bmN0aW9uIChSYW5rKSB7XG4gICAgUmFua1tcIlIwXCJdID0gXCJSMFwiO1xuICAgIFJhbmtbXCJSMVwiXSA9IFwiUjFcIjtcbiAgICBSYW5rW1wiUjJcIl0gPSBcIlIyXCI7XG4gICAgUmFua1tcIlIzXCJdID0gXCJSM1wiO1xuICAgIFJhbmtbXCJSNFwiXSA9IFwiUjRcIjtcbiAgICBSYW5rW1wiUjVcIl0gPSBcIlI1XCI7XG59KShSYW5rID0gZXhwb3J0cy5SYW5rIHx8IChleHBvcnRzLlJhbmsgPSB7fSkpO1xudmFyIFVwY2FzdEludDMyQW5kTWFwO1xuKGZ1bmN0aW9uIChVcGNhc3RJbnQzMkFuZE1hcCkge1xuICAgIFVwY2FzdEludDMyQW5kTWFwW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFVwY2FzdEludDMyQW5kTWFwW1wiaW50MzJcIl0gPSBcImludDMyXCI7XG4gICAgVXBjYXN0SW50MzJBbmRNYXBbXCJib29sXCJdID0gXCJpbnQzMlwiO1xufSkoVXBjYXN0SW50MzJBbmRNYXAgfHwgKFVwY2FzdEludDMyQW5kTWFwID0ge30pKTtcbnZhciBVcGNhc3RCb29sQW5kTWFwO1xuKGZ1bmN0aW9uIChVcGNhc3RCb29sQW5kTWFwKSB7XG4gICAgVXBjYXN0Qm9vbEFuZE1hcFtcImZsb2F0MzJcIl0gPSBcImZsb2F0MzJcIjtcbiAgICBVcGNhc3RCb29sQW5kTWFwW1wiaW50MzJcIl0gPSBcImludDMyXCI7XG4gICAgVXBjYXN0Qm9vbEFuZE1hcFtcImJvb2xcIl0gPSBcImJvb2xcIjtcbn0pKFVwY2FzdEJvb2xBbmRNYXAgfHwgKFVwY2FzdEJvb2xBbmRNYXAgPSB7fSkpO1xudmFyIFVwY2FzdEZsb2F0MzJBbmRNYXA7XG4oZnVuY3Rpb24gKFVwY2FzdEZsb2F0MzJBbmRNYXApIHtcbiAgICBVcGNhc3RGbG9hdDMyQW5kTWFwW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFVwY2FzdEZsb2F0MzJBbmRNYXBbXCJpbnQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFVwY2FzdEZsb2F0MzJBbmRNYXBbXCJib29sXCJdID0gXCJmbG9hdDMyXCI7XG59KShVcGNhc3RGbG9hdDMyQW5kTWFwIHx8IChVcGNhc3RGbG9hdDMyQW5kTWFwID0ge30pKTtcbnZhciB1cGNhc3RUeXBlTWFwID0ge1xuICAgIGZsb2F0MzI6IFVwY2FzdEZsb2F0MzJBbmRNYXAsXG4gICAgaW50MzI6IFVwY2FzdEludDMyQW5kTWFwLFxuICAgIGJvb2w6IFVwY2FzdEJvb2xBbmRNYXBcbn07XG5mdW5jdGlvbiB1cGNhc3RUeXBlKHR5cGVBLCB0eXBlQikge1xuICAgIHJldHVybiB1cGNhc3RUeXBlTWFwW3R5cGVBXVt0eXBlQl07XG59XG5leHBvcnRzLnVwY2FzdFR5cGUgPSB1cGNhc3RUeXBlO1xuZnVuY3Rpb24gc3VtT3V0VHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHVwY2FzdFR5cGUodHlwZSwgJ2ludDMyJyk7XG59XG5leHBvcnRzLnN1bU91dFR5cGUgPSBzdW1PdXRUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi90ZW5zb3JcIik7XG5mdW5jdGlvbiBhc3NlcnRBcmd1bWVudElzVGVuc29yKHgsIGFyZ05hbWUsIGZ1bmN0aW9uTmFtZSkge1xuICAgIGFzc2VydCh4IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yLCBcIkFyZ3VtZW50ICdcIiArIGFyZ05hbWUgKyBcIicgcGFzc2VkIHRvICdcIiArIGZ1bmN0aW9uTmFtZSArIFwiJyBtdXN0IGJlIGEgVGVuc29yLCBcIiArXG4gICAgICAgIChcImJ1dCBnb3QgXCIgKyB0eXBlb2YgeCArIFwiLlwiKSk7XG59XG5mdW5jdGlvbiBhc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKGFyZ3MsIGZ1bmN0aW9uTmFtZSkge1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGFyZ05hbWUpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbYXJnTmFtZV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnRJc1RlbnNvcih0LCBhcmdOYW1lICsgXCJbXCIgKyBpICsgXCJdXCIsIGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50SXNUZW5zb3IoYXJnLCBhcmdOYW1lLCBmdW5jdGlvbk5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBhcmdOYW1lIGluIGFyZ3MpIHtcbiAgICAgICAgX2xvb3BfMShhcmdOYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMgPSBhc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzO1xuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIHZhciBjb3VudGVyID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciB0ZW1wID0gMDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChjb3VudGVyID4gMCkge1xuICAgICAgICBpbmRleCA9IChNYXRoLnJhbmRvbSgpICogY291bnRlcikgfCAwO1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIHRlbXAgPSBhcnJheVtjb3VudGVyXTtcbiAgICAgICAgYXJyYXlbY291bnRlcl0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHRlbXA7XG4gICAgfVxufVxuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbmZ1bmN0aW9uIGNsYW1wKG1pbiwgeCwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4oeCwgbWF4KSk7XG59XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG5mdW5jdGlvbiByYW5kVW5pZm9ybShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpICsgYTtcbn1cbmV4cG9ydHMucmFuZFVuaWZvcm0gPSByYW5kVW5pZm9ybTtcbmZ1bmN0aW9uIGRpc3RTcXVhcmVkKGEsIGIpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpZmYgPSBOdW1iZXIoYVtpXSkgLSBOdW1iZXIoYltpXSk7XG4gICAgICAgIHJlc3VsdCArPSBkaWZmICogZGlmZjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGlzdFNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbmZ1bmN0aW9uIGFzc2VydChleHByLCBtc2cpIHtcbiAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5mdW5jdGlvbiBhc3NlcnRTaGFwZXNNYXRjaChzaGFwZUEsIHNoYXBlQiwgZXJyb3JNZXNzYWdlUHJlZml4KSB7XG4gICAgaWYgKGVycm9yTWVzc2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IGVycm9yTWVzc2FnZVByZWZpeCA9ICcnOyB9XG4gICAgYXNzZXJ0KGFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSwgZXJyb3JNZXNzYWdlUHJlZml4ICsgKFwiIFNoYXBlcyBcIiArIHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiIG11c3QgbWF0Y2hcIikpO1xufVxuZXhwb3J0cy5hc3NlcnRTaGFwZXNNYXRjaCA9IGFzc2VydFNoYXBlc01hdGNoO1xuZnVuY3Rpb24gYXNzZXJ0VHlwZXNNYXRjaChhLCBiKSB7XG4gICAgYXNzZXJ0KGEuZHR5cGUgPT09IGIuZHR5cGUsIFwiIFRoZSBkdHlwZXMgb2YgdGhlIGZpcnN0KFwiICsgYS5kdHlwZSArIFwiKSBhbmRcIiArXG4gICAgICAgIChcIiBzZWNvbmQoXCIgKyBiLmR0eXBlICsgXCIpIGlucHV0IG11c3QgbWF0Y2hcIikpO1xufVxuZXhwb3J0cy5hc3NlcnRUeXBlc01hdGNoID0gYXNzZXJ0VHlwZXNNYXRjaDtcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCByZXQpIHtcbiAgICBpZiAocmV0ID09PSB2b2lkIDApIHsgcmV0ID0gW107IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBmbGF0dGVuKGFycltpXSwgcmV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2goYXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG5mdW5jdGlvbiBpbmZlclNoYXBlKHZhbCkge1xuICAgIGlmIChpc1R5cGVkQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gW3ZhbC5sZW5ndGhdO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBzaGFwZSA9IFtdO1xuICAgIHdoaWxlICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBzaGFwZS5wdXNoKHZhbC5sZW5ndGgpO1xuICAgICAgICB2YWwgPSB2YWxbMF07XG4gICAgfVxuICAgIHJldHVybiBzaGFwZTtcbn1cbmV4cG9ydHMuaW5mZXJTaGFwZSA9IGluZmVyU2hhcGU7XG5mdW5jdGlvbiBzaXplRnJvbVNoYXBlKHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdmFyIHNpemUgPSBzaGFwZVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpemUgKj0gc2hhcGVbaV07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZXhwb3J0cy5zaXplRnJvbVNoYXBlID0gc2l6ZUZyb21TaGFwZTtcbmZ1bmN0aW9uIGlzU2NhbGFyU2hhcGUoc2hhcGUpIHtcbiAgICByZXR1cm4gc2hhcGUubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5pc1NjYWxhclNoYXBlID0gaXNTY2FsYXJTaGFwZTtcbmZ1bmN0aW9uIGFycmF5c0VxdWFsKG4xLCBuMikge1xuICAgIGlmIChuMS5sZW5ndGggIT09IG4yLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG4xW2ldICE9PSBuMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5hcnJheXNFcXVhbCA9IGFycmF5c0VxdWFsO1xuZnVuY3Rpb24gaXNJbnQoYSkge1xuICAgIHJldHVybiBhICUgMSA9PT0gMDtcbn1cbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcbmZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIGlmIChNYXRoLnRhbmggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC50YW5oKHgpO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZTJ4ID0gTWF0aC5leHAoMiAqIHgpO1xuICAgICAgICByZXR1cm4gKGUyeCAtIDEpIC8gKGUyeCArIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFuaCA9IHRhbmg7XG5mdW5jdGlvbiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpIHtcbiAgICBmb3IgKHZhciBhID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoc2l6ZSkpOyBhID4gMTsgLS1hKSB7XG4gICAgICAgIGlmIChzaXplICUgYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFthLCBzaXplIC8gYV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsxLCBzaXplXTtcbn1cbmV4cG9ydHMuc2l6ZVRvU3F1YXJpc2hTaGFwZSA9IHNpemVUb1NxdWFyaXNoU2hhcGU7XG5mdW5jdGlvbiBjcmVhdGVTaHVmZmxlZEluZGljZXMobikge1xuICAgIHZhciBzaHVmZmxlZEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgc2h1ZmZsZWRJbmRpY2VzW2ldID0gaTtcbiAgICB9XG4gICAgc2h1ZmZsZShzaHVmZmxlZEluZGljZXMpO1xuICAgIHJldHVybiBzaHVmZmxlZEluZGljZXM7XG59XG5leHBvcnRzLmNyZWF0ZVNodWZmbGVkSW5kaWNlcyA9IGNyZWF0ZVNodWZmbGVkSW5kaWNlcztcbmZ1bmN0aW9uIHJpZ2h0UGFkKGEsIHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSBhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgcmV0dXJuIGEgKyAnICcucmVwZWF0KHNpemUgLSBhLmxlbmd0aCk7XG59XG5leHBvcnRzLnJpZ2h0UGFkID0gcmlnaHRQYWQ7XG5mdW5jdGlvbiByZXBlYXRlZFRyeShjaGVja0ZuLCBkZWxheUZuLCBtYXhDb3VudGVyKSB7XG4gICAgaWYgKGRlbGF5Rm4gPT09IHZvaWQgMCkgeyBkZWxheUZuID0gZnVuY3Rpb24gKGNvdW50ZXIpIHsgcmV0dXJuIDA7IH07IH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgdHJ5Q291bnQgPSAwO1xuICAgICAgICB2YXIgdHJ5Rm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tGbigpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeUNvdW50Kys7XG4gICAgICAgICAgICB2YXIgbmV4dEJhY2tvZmYgPSBkZWxheUZuKHRyeUNvdW50KTtcbiAgICAgICAgICAgIGlmIChtYXhDb3VudGVyICE9IG51bGwgJiYgdHJ5Q291bnQgPj0gbWF4Q291bnRlcikge1xuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQodHJ5Rm4sIG5leHRCYWNrb2ZmKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5Rm4oKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVwZWF0ZWRUcnkgPSByZXBlYXRlZFRyeTtcbmZ1bmN0aW9uIGdldFF1ZXJ5UGFyYW1zKHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgIHF1ZXJ5U3RyaW5nLnJlcGxhY2UoL1s/Jl0oW149PyZdKykoPzo9KFteJl0qKSk/L2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciB0ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVBhcmFtKHBhcmFtcywgdFswXSwgdFsxXSk7XG4gICAgICAgIHJldHVybiB0LmpvaW4oJz0nKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZXhwb3J0cy5nZXRRdWVyeVBhcmFtcyA9IGdldFF1ZXJ5UGFyYW1zO1xuZnVuY3Rpb24gZGVjb2RlUGFyYW0ocGFyYW1zLCBuYW1lLCB2YWx1ZSkge1xuICAgIHBhcmFtc1tkZWNvZGVVUklDb21wb25lbnQobmFtZSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlIHx8ICcnKTtcbn1cbmZ1bmN0aW9uIGluZmVyRnJvbUltcGxpY2l0U2hhcGUoc2hhcGUsIHNpemUpIHtcbiAgICB2YXIgc2hhcGVQcm9kID0gMTtcbiAgICB2YXIgaW1wbGljaXRJZHggPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzaGFwZVtpXSA+IDApIHtcbiAgICAgICAgICAgIHNoYXBlUHJvZCAqPSBzaGFwZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGFwZVtpXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gb25seSBoYXZlIDEgaW1wbGljaXQgc2l6ZS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJGb3VuZCAtIDEgYXQgZGltIFwiICsgaW1wbGljaXRJZHggKyBcIiBhbmQgZGltIFwiICsgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1wbGljaXRJZHggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlW2ldIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBub3QgYmUgPD0gMC4gRm91bmQgXCIgKyBzaGFwZVtpXSArIFwiIGF0IGRpbSBcIiArIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbXBsaWNpdElkeCA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHNpemUgPiAwICYmIHNpemUgIT09IHNoYXBlUHJvZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaXplKFwiICsgc2l6ZSArIFwiKSBtdXN0IG1hdGNoIHRoZSBwcm9kdWN0IG9mIHNoYXBlIFwiICsgc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG4gICAgaWYgKHNpemUgJSBzaGFwZVByb2QgIT09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgaW1wbGljaXQgc2hhcGUgY2FuJ3QgYmUgYSBmcmFjdGlvbmFsIG51bWJlci4gXCIgK1xuICAgICAgICAgICAgKFwiR290IFwiICsgc2l6ZSArIFwiIC8gXCIgKyBzaGFwZVByb2QpKTtcbiAgICB9XG4gICAgdmFyIG5ld1NoYXBlID0gc2hhcGUuc2xpY2UoKTtcbiAgICBuZXdTaGFwZVtpbXBsaWNpdElkeF0gPSBzaXplIC8gc2hhcGVQcm9kO1xuICAgIHJldHVybiBuZXdTaGFwZTtcbn1cbmV4cG9ydHMuaW5mZXJGcm9tSW1wbGljaXRTaGFwZSA9IGluZmVyRnJvbUltcGxpY2l0U2hhcGU7XG5mdW5jdGlvbiBzcXVlZXplU2hhcGUoc2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgbmV3U2hhcGUgPSBbXTtcbiAgICB2YXIga2VwdERpbXMgPSBbXTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXhpcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYXhpc1tqXSA9PT0gaSAmJiBzaGFwZVtpXSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzcXVlZXplIGF4aXMgXCIgKyBpICsgXCIgc2luY2UgaXRzIGRpbSAnXCIgKyBzaGFwZVtpXSArIFwiJyBpcyBub3QgMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYXhpc1tqXSA9PSBudWxsIHx8IGF4aXNbal0gPiBpKSAmJiBzaGFwZVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgICAgICAgICAgICAgIGtlcHREaW1zLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXhpc1tqXSA8PSBpKSB7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZVtpXSA+IDEpIHtcbiAgICAgICAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgICAgICAgICAga2VwdERpbXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBuZXdTaGFwZTogbmV3U2hhcGUsIGtlcHREaW1zOiBrZXB0RGltcyB9O1xufVxuZXhwb3J0cy5zcXVlZXplU2hhcGUgPSBzcXVlZXplU2hhcGU7XG5mdW5jdGlvbiBnZXRUeXBlZEFycmF5RnJvbURUeXBlKGR0eXBlLCBzaXplKSB7XG4gICAgdmFyIHZhbHVlcyA9IG51bGw7XG4gICAgaWYgKGR0eXBlID09IG51bGwgfHwgZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICB2YWx1ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0cy5nZXRUeXBlZEFycmF5RnJvbURUeXBlID0gZ2V0VHlwZWRBcnJheUZyb21EVHlwZTtcbmZ1bmN0aW9uIGlzVGVuc29ySW5MaXN0KHRlbnNvciwgdGVuc29yTGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVuc29yTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGVuc29yTGlzdFtpXS5pZCA9PT0gdGVuc29yLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVGVuc29ySW5MaXN0ID0gaXNUZW5zb3JJbkxpc3Q7XG5mdW5jdGlvbiBjaGVja0Zvck5hTih2YWxzLCBkdHlwZSwgbmFtZSkge1xuICAgIGlmIChkdHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc05hTih2YWxzW2ldKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgcmVzdWx0IG9mIHRoZSAnXCIgKyBuYW1lICsgXCInIGhhcyBOYU5zLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tGb3JOYU4gPSBjaGVja0Zvck5hTjtcbmZ1bmN0aW9uIGZsYXR0ZW5OYW1lQXJyYXlNYXAobmFtZUFycmF5TWFwLCBrZXlzKSB7XG4gICAgdmFyIHhzID0gW107XG4gICAgaWYgKG5hbWVBcnJheU1hcCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikge1xuICAgICAgICB4cy5wdXNoKG5hbWVBcnJheU1hcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgeE1hcCA9IG5hbWVBcnJheU1hcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4cy5wdXNoKHhNYXBba2V5c1tpXV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4cztcbn1cbmV4cG9ydHMuZmxhdHRlbk5hbWVBcnJheU1hcCA9IGZsYXR0ZW5OYW1lQXJyYXlNYXA7XG5mdW5jdGlvbiB1bmZsYXR0ZW5Ub05hbWVBcnJheU1hcChrZXlzLCBmbGF0QXJyYXlzKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSBmbGF0QXJyYXlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdW5mbGF0dGVuIFRlbnNvcltdLCBrZXlzIGFuZCBhcnJheXMgYXJlIG5vdCBvZiBzYW1lIGxlbmd0aC5cIik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2tleXNbaV1dID0gZmxhdEFycmF5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudW5mbGF0dGVuVG9OYW1lQXJyYXlNYXAgPSB1bmZsYXR0ZW5Ub05hbWVBcnJheU1hcDtcbmZ1bmN0aW9uIGhhc0VuY29kaW5nTG9zcyhvbGRUeXBlLCBuZXdUeXBlKSB7XG4gICAgaWYgKG5ld1R5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChuZXdUeXBlID09PSAnaW50MzInICYmIG9sZFR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChuZXdUeXBlID09PSAnYm9vbCcgJiYgb2xkVHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmhhc0VuY29kaW5nTG9zcyA9IGhhc0VuY29kaW5nTG9zcztcbmZ1bmN0aW9uIGNvcHlUeXBlZEFycmF5KGFycmF5LCBkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PSBudWxsIHx8IGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHZhciBib29sID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5yb3VuZChhcnJheVtpXSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBib29sW2ldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9vbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuY29weVR5cGVkQXJyYXkgPSBjb3B5VHlwZWRBcnJheTtcbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgYSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcbiAgICAgICAgYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbmZ1bmN0aW9uIGJ5dGVzUGVyRWxlbWVudChkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInIHx8IGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmJ5dGVzUGVyRWxlbWVudCA9IGJ5dGVzUGVyRWxlbWVudDtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZikge1xuICAgIHJldHVybiAhIShmICYmIGYuY29uc3RydWN0b3IgJiYgZi5jYWxsICYmIGYuYXBwbHkpO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmZ1bmN0aW9uIGdldFRlbnNvcnNJbkNvbnRhaW5lcihyZXN1bHQpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIHZhciBzZWVuID0gbmV3IFNldCgpO1xuICAgIHdhbGtUZW5zb3JDb250YWluZXIocmVzdWx0LCBsaXN0LCBzZWVuKTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbmV4cG9ydHMuZ2V0VGVuc29yc0luQ29udGFpbmVyID0gZ2V0VGVuc29yc0luQ29udGFpbmVyO1xuZnVuY3Rpb24gd2Fsa1RlbnNvckNvbnRhaW5lcihjb250YWluZXIsIGxpc3QsIHNlZW4pIHtcbiAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgIGxpc3QucHVzaChjb250YWluZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNJdGVyYWJsZShjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0ZXJhYmxlID0gY29udGFpbmVyO1xuICAgIGZvciAodmFyIGsgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIHZhbCA9IGl0ZXJhYmxlW2tdO1xuICAgICAgICBpZiAoIXNlZW4uaGFzKHZhbCkpIHtcbiAgICAgICAgICAgIHNlZW4uYWRkKHZhbCk7XG4gICAgICAgICAgICB3YWxrVGVuc29yQ29udGFpbmVyKHZhbCwgbGlzdCwgc2Vlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc0l0ZXJhYmxlKG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHwgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlcnNpb24gPSAnMC4xMS42JztcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdwZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi9rZXJuZWxzL3dlYmdsL2dwZ3B1X3V0aWxcIik7XG5leHBvcnRzLmdwZ3B1X3V0aWwgPSBncGdwdV91dGlsO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi9rZXJuZWxzL3dlYmdsL3dlYmdsX3V0aWxcIik7XG5leHBvcnRzLndlYmdsX3V0aWwgPSB3ZWJnbF91dGlsO1xudmFyIGJhY2tlbmRfd2ViZ2xfMSA9IHJlcXVpcmUoXCIuL2tlcm5lbHMvYmFja2VuZF93ZWJnbFwiKTtcbmV4cG9ydHMuTWF0aEJhY2tlbmRXZWJHTCA9IGJhY2tlbmRfd2ViZ2xfMS5NYXRoQmFja2VuZFdlYkdMO1xudmFyIGdwZ3B1X2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2tlcm5lbHMvd2ViZ2wvZ3BncHVfY29udGV4dFwiKTtcbmV4cG9ydHMuR1BHUFVDb250ZXh0ID0gZ3BncHVfY29udGV4dF8xLkdQR1BVQ29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmdsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgQWN0aXZhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGl2YXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aXZhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBY3RpdmF0aW9uLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9O1xuICAgIHJldHVybiBBY3RpdmF0aW9uO1xufSh0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSkpO1xuZXhwb3J0cy5BY3RpdmF0aW9uID0gQWN0aXZhdGlvbjtcbnZhciBFbHUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbHUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWx1KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEVsdS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAxOyB9XG4gICAgICAgIHJldHVybiBLLmVsdSh4LCBhbHBoYSk7XG4gICAgfTtcbiAgICBFbHUuY2xhc3NOYW1lID0gJ2VsdSc7XG4gICAgcmV0dXJuIEVsdTtcbn0oQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5FbHUgPSBFbHU7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoRWx1KTtcbnZhciBTZWx1ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VsdSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWx1KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNlbHUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRmYy5zZWx1KHgpO1xuICAgIH07XG4gICAgU2VsdS5jbGFzc05hbWUgPSAnc2VsdSc7XG4gICAgcmV0dXJuIFNlbHU7XG59KEFjdGl2YXRpb24pKTtcbmV4cG9ydHMuU2VsdSA9IFNlbHU7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoU2VsdSk7XG52YXIgUmVsdSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbHUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVsdSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZWx1LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0ZmMucmVsdSh4KTtcbiAgICB9O1xuICAgIFJlbHUuY2xhc3NOYW1lID0gJ3JlbHUnO1xuICAgIHJldHVybiBSZWx1O1xufShBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlJlbHUgPSBSZWx1O1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFJlbHUpO1xudmFyIFJlbHU2ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVsdTYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVsdTYoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUmVsdTYucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZjLm1pbmltdW0oSy5nZXRTY2FsYXIoNi4wKSwgdGZjLnJlbHUoeCkpOyB9KTtcbiAgICB9O1xuICAgIFJlbHU2LmNsYXNzTmFtZSA9ICdyZWx1Nic7XG4gICAgcmV0dXJuIFJlbHU2O1xufShBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlJlbHU2ID0gUmVsdTY7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoUmVsdTYpO1xudmFyIExpbmVhciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmVhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5lYXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTGluZWFyLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgTGluZWFyLmNsYXNzTmFtZSA9ICdsaW5lYXInO1xuICAgIHJldHVybiBMaW5lYXI7XG59KEFjdGl2YXRpb24pKTtcbmV4cG9ydHMuTGluZWFyID0gTGluZWFyO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKExpbmVhcik7XG52YXIgU2lnbW9pZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ21vaWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbW9pZCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTaWdtb2lkLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0ZmMuc2lnbW9pZCh4KTtcbiAgICB9O1xuICAgIFNpZ21vaWQuY2xhc3NOYW1lID0gJ3NpZ21vaWQnO1xuICAgIHJldHVybiBTaWdtb2lkO1xufShBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlNpZ21vaWQgPSBTaWdtb2lkO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFNpZ21vaWQpO1xudmFyIEhhcmRTaWdtb2lkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGFyZFNpZ21vaWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGFyZFNpZ21vaWQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSGFyZFNpZ21vaWQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIEsuaGFyZFNpZ21vaWQoeCk7XG4gICAgfTtcbiAgICBIYXJkU2lnbW9pZC5jbGFzc05hbWUgPSAnaGFyZFNpZ21vaWQnO1xuICAgIHJldHVybiBIYXJkU2lnbW9pZDtcbn0oQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5IYXJkU2lnbW9pZCA9IEhhcmRTaWdtb2lkO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEhhcmRTaWdtb2lkKTtcbnZhciBTb2Z0cGx1cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRwbHVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRwbHVzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNvZnRwbHVzLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0ZmMuc29mdHBsdXMoeCk7XG4gICAgfTtcbiAgICBTb2Z0cGx1cy5jbGFzc05hbWUgPSAnc29mdHBsdXMnO1xuICAgIHJldHVybiBTb2Z0cGx1cztcbn0oQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5Tb2Z0cGx1cyA9IFNvZnRwbHVzO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFNvZnRwbHVzKTtcbnZhciBTb2Z0c2lnbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRzaWduLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRzaWduKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNvZnRzaWduLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBLLnNvZnRzaWduKHgpO1xuICAgIH07XG4gICAgU29mdHNpZ24uY2xhc3NOYW1lID0gJ3NvZnRzaWduJztcbiAgICByZXR1cm4gU29mdHNpZ247XG59KEFjdGl2YXRpb24pKTtcbmV4cG9ydHMuU29mdHNpZ24gPSBTb2Z0c2lnbjtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihTb2Z0c2lnbik7XG52YXIgVGFuaCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhbmgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFuaCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYW5oLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0ZmMudGFuaCh4KTtcbiAgICB9O1xuICAgIFRhbmguY2xhc3NOYW1lID0gJ3RhbmgnO1xuICAgIHJldHVybiBUYW5oO1xufShBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlRhbmggPSBUYW5oO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFRhbmgpO1xudmFyIFNvZnRtYXggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU29mdG1heC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAoLTEpOyB9XG4gICAgICAgIHJldHVybiB0ZmMuc29mdG1heCh4LCBheGlzKTtcbiAgICB9O1xuICAgIFNvZnRtYXguY2xhc3NOYW1lID0gJ3NvZnRtYXgnO1xuICAgIHJldHVybiBTb2Z0bWF4O1xufShBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlNvZnRtYXggPSBTb2Z0bWF4O1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFNvZnRtYXgpO1xuZnVuY3Rpb24gc2VyaWFsaXplQWN0aXZhdGlvbihhY3RpdmF0aW9uKSB7XG4gICAgcmV0dXJuIGFjdGl2YXRpb24uZ2V0Q2xhc3NOYW1lKCk7XG59XG5leHBvcnRzLnNlcmlhbGl6ZUFjdGl2YXRpb24gPSBzZXJpYWxpemVBY3RpdmF0aW9uO1xuZnVuY3Rpb24gZGVzZXJpYWxpemVBY3RpdmF0aW9uKGNvbmZpZywgY3VzdG9tT2JqZWN0cykge1xuICAgIGlmIChjdXN0b21PYmplY3RzID09PSB2b2lkIDApIHsgY3VzdG9tT2JqZWN0cyA9IHt9OyB9XG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHNfMS5kZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGNvbmZpZywgdGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCwgY3VzdG9tT2JqZWN0cywgJ2FjdGl2YXRpb24nKTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVBY3RpdmF0aW9uID0gZGVzZXJpYWxpemVBY3RpdmF0aW9uO1xuZnVuY3Rpb24gZ2V0QWN0aXZhdGlvbihpZGVudGlmaWVyKSB7XG4gICAgaWYgKGlkZW50aWZpZXIgPT0gbnVsbCkge1xuICAgICAgICB2YXIgY29uZmlnID0geyBjbGFzc05hbWU6ICdsaW5lYXInLCBjb25maWc6IHt9IH07XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZUFjdGl2YXRpb24oY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgY29uZmlnID0geyBjbGFzc05hbWU6IGlkZW50aWZpZXIsIGNvbmZpZzoge30gfTtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplQWN0aXZhdGlvbihjb25maWcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpZGVudGlmaWVyIGluc3RhbmNlb2YgQWN0aXZhdGlvbikge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZUFjdGl2YXRpb24oaWRlbnRpZmllcik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2YXRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9lcHNpbG9uID0gMWUtNztcbmZ1bmN0aW9uIGVwc2lsb24oKSB7XG4gICAgcmV0dXJuIF9lcHNpbG9uO1xufVxuZXhwb3J0cy5lcHNpbG9uID0gZXBzaWxvbjtcbmZ1bmN0aW9uIHNldEVwc2lsb24oZSkge1xuICAgIF9lcHNpbG9uID0gZTtcbn1cbmV4cG9ydHMuc2V0RXBzaWxvbiA9IHNldEVwc2lsb247XG5mdW5jdGlvbiBpbWFnZURhdGFGb3JtYXQoKSB7XG4gICAgcmV0dXJuICdjaGFubmVsc0xhc3QnO1xufVxuZXhwb3J0cy5pbWFnZURhdGFGb3JtYXQgPSBpbWFnZURhdGFGb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBtYXRoX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL21hdGhfdXRpbHNcIik7XG52YXIgdmFyaWFibGVzXzEgPSByZXF1aXJlKFwiLi4vdmFyaWFibGVzXCIpO1xudmFyIGNvbW1vbl8yID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xudmFyIGNvbW1vbl8zID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xudmFyIGJhY2tlbmQgPSAnd2ViZ2wnO1xudmFyIERFRkFVTFRfRFRZUEUgPSAnZmxvYXQzMic7XG5mdW5jdGlvbiBkaXNwb3NlU2NhbGFyQ2FjaGUoKSB7XG4gICAgZm9yICh2YXIgdHlwZUtleSBpbiBzY2FsYXJDYWNoZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2NhbGFyQ2FjaGVbdHlwZUtleV0pIHtcbiAgICAgICAgICAgIHNjYWxhckNhY2hlW3R5cGVLZXldW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgZGVsZXRlIHNjYWxhckNhY2hlW3R5cGVLZXldW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRpc3Bvc2VTY2FsYXJDYWNoZSA9IGRpc3Bvc2VTY2FsYXJDYWNoZTtcbmZ1bmN0aW9uIHNldEJhY2tlbmQocmVxdWVzdGVkQmFja2VuZCkge1xuICAgIHRmYy5zZXRCYWNrZW5kKHJlcXVlc3RlZEJhY2tlbmQpO1xuICAgIGJhY2tlbmQgPSByZXF1ZXN0ZWRCYWNrZW5kO1xuICAgIGRpc3Bvc2VTY2FsYXJDYWNoZSgpO1xufVxuZXhwb3J0cy5zZXRCYWNrZW5kID0gc2V0QmFja2VuZDtcbmZ1bmN0aW9uIGdldEJhY2tlbmQoKSB7XG4gICAgcmV0dXJuIGJhY2tlbmQ7XG59XG5leHBvcnRzLmdldEJhY2tlbmQgPSBnZXRCYWNrZW5kO1xudmFyIHNjYWxhckNhY2hlID0ge1xuICAgIGZsb2F0MzI6IHt9LFxuICAgIGludDMyOiB7fVxufTtcbmZ1bmN0aW9uIGdldFNjYWxhcih2YWx1ZSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkdHlwZSA9IERFRkFVTFRfRFRZUEU7XG4gICAgfVxuICAgIGlmIChzY2FsYXJDYWNoZVtkdHlwZV1bdmFsdWVdID09IG51bGwpIHtcbiAgICAgICAgc2NhbGFyQ2FjaGVbZHR5cGVdW3ZhbHVlXSA9IHRmanNfY29yZV8xLnNjYWxhcih2YWx1ZSwgZHR5cGUpO1xuICAgICAgICB0ZmMua2VlcChzY2FsYXJDYWNoZVtkdHlwZV1bdmFsdWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxhckNhY2hlW2R0eXBlXVt2YWx1ZV07XG59XG5leHBvcnRzLmdldFNjYWxhciA9IGdldFNjYWxhcjtcbmV4cG9ydHMuZXBzaWxvbiA9IGNvbW1vbl8yLmVwc2lsb247XG5mdW5jdGlvbiBpc0JhY2tlbmRTeW1ib2xpYygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzQmFja2VuZFN5bWJvbGljID0gaXNCYWNrZW5kU3ltYm9saWM7XG5mdW5jdGlvbiBzaGFwZSh4KSB7XG4gICAgcmV0dXJuIHguc2hhcGU7XG59XG5leHBvcnRzLnNoYXBlID0gc2hhcGU7XG5mdW5jdGlvbiBpbnRTaGFwZSh4KSB7XG4gICAgcmV0dXJuIHguc2hhcGU7XG59XG5leHBvcnRzLmludFNoYXBlID0gaW50U2hhcGU7XG5mdW5jdGlvbiBkdHlwZSh4KSB7XG4gICAgcmV0dXJuICh4IGluc3RhbmNlb2YgdGZqc19jb3JlXzEuVGVuc29yKSA/IERFRkFVTFRfRFRZUEUgOiB4LmR0eXBlO1xufVxuZXhwb3J0cy5kdHlwZSA9IGR0eXBlO1xuZnVuY3Rpb24gY291bnRQYXJhbXMoeCkge1xuICAgIHZhciBzaGFwZSA9IHguc2hhcGU7XG4gICAgaWYgKHNoYXBlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNoYXBlLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAqIGI7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufVxuZXhwb3J0cy5jb3VudFBhcmFtcyA9IGNvdW50UGFyYW1zO1xuZnVuY3Rpb24gY2FzdCh4LCBkdHlwZSkge1xuICAgIHJldHVybiB4LmFzVHlwZShkdHlwZSk7XG59XG5leHBvcnRzLmNhc3QgPSBjYXN0O1xuZnVuY3Rpb24gZXhwYW5kRGltcyh4LCBheGlzKSB7XG4gICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gLTE7IH1cbiAgICB2YXIgb3V0U2hhcGUgPSBzaGFwZSh4KS5zbGljZSgpO1xuICAgIGlmIChheGlzIDwgMCkge1xuICAgICAgICBheGlzID0gb3V0U2hhcGUubGVuZ3RoICsgYXhpcyArIDE7XG4gICAgfVxuICAgIG91dFNoYXBlLnNwbGljZShheGlzLCAwLCAxKTtcbiAgICByZXR1cm4geC5yZXNoYXBlKG91dFNoYXBlKTtcbn1cbmV4cG9ydHMuZXhwYW5kRGltcyA9IGV4cGFuZERpbXM7XG5mdW5jdGlvbiByZXBlYXQoeCwgbikge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHguc2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcInJlcGVhdCgpIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgcmVjZWl2ZWQgYSBcIiArXG4gICAgICAgICAgICAgICAgKFwicmFuay1cIiArIHguc2hhcGUubGVuZ3RoICsgXCIgdGVuc29yLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSBleHBhbmREaW1zKHgsIDEpO1xuICAgICAgICByZXR1cm4gdGlsZSh5LCBbMSwgbiwgMV0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZXBlYXQgPSByZXBlYXQ7XG5mdW5jdGlvbiBmbGF0dGVuKHgpIHtcbiAgICB2YXIgbmV3U2hhcGUgPSBbbWF0aF91dGlscy5hcnJheVByb2QoeC5zaGFwZSldO1xuICAgIHJldHVybiB4LnJlc2hhcGUobmV3U2hhcGUpO1xufVxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbmZ1bmN0aW9uIGJhdGNoRmxhdHRlbih4KSB7XG4gICAgaWYgKHgucmFuayA8PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiYmF0Y2hGbGF0dGVuIHJlcXVpcmVzIGEgbWluaW11bSByYW5rIG9mIDIuIEdvdCByYW5rOiBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICB9XG4gICAgdmFyIG5ld1NoYXBlID0gW3guc2hhcGVbMF0sIG1hdGhfdXRpbHMuYXJyYXlQcm9kKHguc2hhcGUsIDEpXTtcbiAgICByZXR1cm4geC5yZXNoYXBlKG5ld1NoYXBlKTtcbn1cbmV4cG9ydHMuYmF0Y2hGbGF0dGVuID0gYmF0Y2hGbGF0dGVuO1xuZnVuY3Rpb24gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheSwgc3RhcnQsIHNpemUpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJyYXkucmFuaykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2UxZChhcnJheSwgc3RhcnQsIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2UyZChhcnJheSwgW3N0YXJ0LCAwXSwgW3NpemUsIGFycmF5LnNoYXBlWzFdXSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTNkKGFycmF5LCBbc3RhcnQsIDAsIDBdLCBbc2l6ZSwgYXJyYXkuc2hhcGVbMV0sIGFycmF5LnNoYXBlWzJdXSk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTRkKGFycmF5LCBbc3RhcnQsIDAsIDAsIDBdLCBbc2l6ZSwgYXJyYXkuc2hhcGVbMV0sIGFycmF5LnNoYXBlWzJdLCBhcnJheS5zaGFwZVszXV0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcInNsaWNlQWxvbmdGaXJzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIGFycmF5LnJhbmspKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zbGljZUFsb25nRmlyc3RBeGlzID0gc2xpY2VBbG9uZ0ZpcnN0QXhpcztcbmZ1bmN0aW9uIHNsaWNlQWxvbmdMYXN0QXhpcyhhcnJheSwgc3RhcnQsIHNpemUpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJyYXkucmFuaykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2UxZChhcnJheSwgc3RhcnQsIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2UyZChhcnJheSwgWzAsIHN0YXJ0XSwgW2FycmF5LnNoYXBlWzBdLCBzaXplXSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTNkKGFycmF5LCBbMCwgMCwgc3RhcnRdLCBbYXJyYXkuc2hhcGVbMF0sIGFycmF5LnNoYXBlWzFdLCBzaXplXSk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTRkKGFycmF5LCBbMCwgMCwgMCwgc3RhcnRdLCBbYXJyYXkuc2hhcGVbMF0sIGFycmF5LnNoYXBlWzFdLCBhcnJheS5zaGFwZVsyXSwgc2l6ZV0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcInNsaWNlQWxvbmdMYXN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgYXJyYXkucmFuaykpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNsaWNlQWxvbmdMYXN0QXhpcyA9IHNsaWNlQWxvbmdMYXN0QXhpcztcbmZ1bmN0aW9uIHNsaWNlQWxvbmdBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSwgYXhpcykge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChhcnJheS5yYW5rKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTFkKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZUFsb25nTGFzdEF4aXMoYXJyYXksIHN0YXJ0LCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcIiArIGF4aXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2UzZChhcnJheSwgWzAsIHN0YXJ0LCAwXSwgW2FycmF5LnNoYXBlWzBdLCBzaXplLCBhcnJheS5zaGFwZVsyXV0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2VBbG9uZ0xhc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyBheGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXhpcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheSwgc3RhcnQsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGZjLnNsaWNlNGQoYXJyYXksIFswLCBzdGFydCwgMCwgMF0sIFthcnJheS5zaGFwZVswXSwgc2l6ZSwgYXJyYXkuc2hhcGVbMl0sIGFycmF5LnNoYXBlWzNdXSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2U0ZChhcnJheSwgWzAsIDAsIHN0YXJ0LCAwXSwgW2FycmF5LnNoYXBlWzBdLCBhcnJheS5zaGFwZVsxXSwgc2l6ZSwgYXJyYXkuc2hhcGVbM11dKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlQWxvbmdMYXN0QXhpcyhhcnJheSwgc3RhcnQsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlwiICsgYXhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJzbGljZUFsb25nTGFzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIGFycmF5LnJhbmspKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zbGljZUFsb25nQXhpcyA9IHNsaWNlQWxvbmdBeGlzO1xuZnVuY3Rpb24gY29uY2F0ZW5hdGUodGVuc29ycywgYXhpcykge1xuICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IC0xOyB9XG4gICAgdmFyIHJhbms7XG4gICAgaWYgKGF4aXMgPCAwKSB7XG4gICAgICAgIHJhbmsgPSB0ZW5zb3JzWzBdLnJhbms7XG4gICAgICAgIGlmIChyYW5rICE9PSAwKSB7XG4gICAgICAgICAgICBheGlzID0gcmFuaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF4aXMgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChheGlzID09PSB0ZW5zb3JzWzBdLnJhbmspIHtcbiAgICAgICAgYXhpcyA9IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdGZjLmNvbmNhdCh0ZW5zb3JzLCBheGlzKTtcbn1cbmV4cG9ydHMuY29uY2F0ZW5hdGUgPSBjb25jYXRlbmF0ZTtcbmZ1bmN0aW9uIGNvbmNhdEFsb25nRmlyc3RBeGlzKGEsIGIpIHtcbiAgICBzd2l0Y2ggKGEucmFuaykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gdGZjLmNvbmNhdDFkKFthLCBiXSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiB0ZmMuY29uY2F0MmQoW2EsIGJdLCAwKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHRmYy5jb25jYXQzZChbYSwgYl0sIDApO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gdGZjLmNvbmNhdDRkKFthLCBiXSwgMCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignY29uY2F0QWxvbmdGaXJzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogJyArXG4gICAgICAgICAgICAgICAgYS5yYW5rKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbmNhdEFsb25nRmlyc3RBeGlzID0gY29uY2F0QWxvbmdGaXJzdEF4aXM7XG5mdW5jdGlvbiB0aWxlKHgsIG4pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobikpIHtcbiAgICAgICAgbiA9IFtuXTtcbiAgICB9XG4gICAgaWYgKHgucmFuayAhPT0gbi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgbGVuZ3RoIG9mIGlucHV0IG4gKFwiICsgbi5sZW5ndGggKyBcIikgZG9lcyBub3QgbWF0Y2ggXCIgK1xuICAgICAgICAgICAgKFwidGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIGlucHV0IHggKFwiICsgeC5yYW5rICsgXCIpXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRmYy50aWxlKHgsIG4pO1xufVxuZXhwb3J0cy50aWxlID0gdGlsZTtcbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geC5jbG9uZSgpO1xufVxuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZnVuY3Rpb24gZXllVmFyaWFibGUoc2l6ZSwgZHR5cGUsIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IHZhcmlhYmxlc18xLkxheWVyVmFyaWFibGUodGZjLmV5ZShzaXplLCBzaXplLCBudWxsLCBkdHlwZSksIGR0eXBlLCBuYW1lKTtcbn1cbmV4cG9ydHMuZXllVmFyaWFibGUgPSBleWVWYXJpYWJsZTtcbmZ1bmN0aW9uIHNjYWxhclRpbWVzQXJyYXkoYywgeCkge1xuICAgIHJldHVybiB0ZmMubXVsKGMsIHgpO1xufVxuZXhwb3J0cy5zY2FsYXJUaW1lc0FycmF5ID0gc2NhbGFyVGltZXNBcnJheTtcbmZ1bmN0aW9uIHNjYWxhclBsdXNBcnJheShjLCB4KSB7XG4gICAgcmV0dXJuIHRmYy5hZGQoYywgeCk7XG59XG5leHBvcnRzLnNjYWxhclBsdXNBcnJheSA9IHNjYWxhclBsdXNBcnJheTtcbmZ1bmN0aW9uIHJhbmRvbU5vcm1hbChzaGFwZSwgbWVhbiwgc3RkZGV2LCBkdHlwZSwgc2VlZCkge1xuICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDAuMDsgfVxuICAgIGlmIChzdGRkZXYgPT09IHZvaWQgMCkgeyBzdGRkZXYgPSAxLjA7IH1cbiAgICByZXR1cm4gdGZjLnJhbmRvbU5vcm1hbChzaGFwZSwgbWVhbiwgc3RkZGV2LCBkdHlwZSwgc2VlZCk7XG59XG5leHBvcnRzLnJhbmRvbU5vcm1hbCA9IHJhbmRvbU5vcm1hbDtcbmZ1bmN0aW9uIGRvdCh4LCB5KSB7XG4gICAgaWYgKHkucmFuayAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcihcImRvdCBzdXBwb3J0IGZvciB5IG90aGVyIHRoYW4gcmFuayAyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQ6IFwiICtcbiAgICAgICAgICAgIChcInkgc2hhcGUgPSBcIiArIHNoYXBlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoeC5yYW5rID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGZjLm1hdE11bCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHZhciB4U2hhcGUwID0geC5zaGFwZVswXTtcbiAgICAgICAgICAgIHZhciB4U2hhcGUxID0geC5zaGFwZVsxXTtcbiAgICAgICAgICAgIHZhciB4U2hhcGUyID0geC5zaGFwZVsyXTtcbiAgICAgICAgICAgIHggPSB4LnJlc2hhcGUoW3hTaGFwZTAgKiB4U2hhcGUxLCB4U2hhcGUyXSk7XG4gICAgICAgICAgICByZXR1cm4gdGZjLm1hdE11bCh4LCB5KS5yZXNoYXBlKFtcbiAgICAgICAgICAgICAgICB4U2hhcGUwLCB4U2hhcGUxLCB5LnNoYXBlWzFdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiZG90IHN1cHBvcnQgZm9yIHggb2YgcmFuayBcIiArIHgucmFuayArIFwiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQ6IFwiICtcbiAgICAgICAgICAgICAgICAoXCJ4IHNoYXBlID0gXCIgKyBzaGFwZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kb3QgPSBkb3Q7XG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB6ZXJvc0xpa2VYID0gdGZqc19jb3JlXzEuemVyb3NMaWtlKHgpO1xuICAgICAgICB2YXIgb25lc0xpa2VYID0gdGZqc19jb3JlXzEub25lc0xpa2UoeCk7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS53aGVyZSh0ZmMuZXF1YWwoeCwgemVyb3NMaWtlWCksIHplcm9zTGlrZVgsIHRmanNfY29yZV8xLndoZXJlKHRmYy5ncmVhdGVyKHgsIHRmanNfY29yZV8xLnplcm9zTGlrZSh4KSksIG9uZXNMaWtlWCwgc2NhbGFyVGltZXNBcnJheShnZXRTY2FsYXIoLTEpLCBvbmVzTGlrZVgpKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnNpZ24gPSBzaWduO1xuZnVuY3Rpb24gcXIoeCkge1xuICAgIHZhciBfYSA9IHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeC5zaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwicXIoKSByZXF1aXJlcyBhIDJEIFRlbnNvciwgYnV0IGdvdCBhIFwiICsgeC5zaGFwZS5sZW5ndGggKyBcIkQgVGVuc29yLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5zaGFwZVswXSA8IHguc2hhcGVbMV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwicXIoKSByZXF1aXJlcyB4LnNoYXBlWzBdID49IHguc2hhcGVbMV0sIGJ1dCBnb3Qgc2hhcGU6IFtcIiArIHguc2hhcGUgKyBcIl1cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSB4LnNoYXBlWzBdO1xuICAgICAgICB2YXIgbiA9IHguc2hhcGVbMV07XG4gICAgICAgIHZhciBxID0gdGZjLmV5ZShtKTtcbiAgICAgICAgdmFyIHIgPSB4LmNsb25lKCk7XG4gICAgICAgIHZhciBvbmUyRCA9IHRmanNfY29yZV8xLnRlbnNvcjJkKFtbMV1dLCBbMSwgMV0pO1xuICAgICAgICB2YXIgdyA9IG9uZTJELmNsb25lKCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGopIHtcbiAgICAgICAgICAgIHZhciByVGVtcCA9IHI7XG4gICAgICAgICAgICB2YXIgd1RlbXAgPSB3O1xuICAgICAgICAgICAgdmFyIHFUZW1wID0gcTtcbiAgICAgICAgICAgIF9hID0gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJqRW5kMSA9IHIuc2xpY2UoW2osIGpdLCBbbSAtIGosIDFdKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybVggPSB0ZmMubm9ybShyakVuZDEpO1xuICAgICAgICAgICAgICAgIHZhciByamogPSByLnNsaWNlKFtqLCBqXSwgWzEsIDFdKTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRmYy5uZWcoc2lnbihyamopKTtcbiAgICAgICAgICAgICAgICB2YXIgdTEgPSByamouc3ViKHRmYy5tdWwocywgbm9ybVgpKTtcbiAgICAgICAgICAgICAgICB2YXIgd1ByZSA9IHRmYy5kaXYocmpFbmQxLCB1MSk7XG4gICAgICAgICAgICAgICAgaWYgKHdQcmUuc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdyA9IG9uZTJELmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3ID0gb25lMkQuY29uY2F0KHdQcmUuc2xpY2UoWzEsIDBdLCBbd1ByZS5zaGFwZVswXSAtIDEsIHdQcmUuc2hhcGVbMV1dKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YXUgPSB0ZmMubmVnKHRmYy5kaXYodGZjLm1hdE11bChzLCB1MSksIG5vcm1YKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJqRW5kQWxsID0gci5zbGljZShbaiwgMF0sIFttIC0gaiwgbl0pO1xuICAgICAgICAgICAgICAgIHZhciB0YXVUaW1lc1cgPSB0YXUubXVsKHcpO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByakVuZEFsbC5zdWIodGF1VGltZXNXLm1hdE11bCh3LnRyYW5zcG9zZSgpLm1hdE11bChyakVuZEFsbCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByLnNsaWNlKFswLCAwXSwgW2osIG5dKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyakVuZEFsbC5zdWIodGF1VGltZXNXLm1hdE11bCh3LnRyYW5zcG9zZSgpLm1hdE11bChyakVuZEFsbCkpKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBxQWxsSkVuZCA9IHEuc2xpY2UoWzAsIGpdLCBbbSwgcS5zaGFwZVsxXSAtIGpdKTtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxID0gcUFsbEpFbmQuc3ViKHFBbGxKRW5kLm1hdE11bCh3KS5tYXRNdWwodGF1VGltZXNXLnRyYW5zcG9zZSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5zbGljZShbMCwgMF0sIFttLCBqXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocUFsbEpFbmQuc3ViKHFBbGxKRW5kLm1hdE11bCh3KS5tYXRNdWwodGF1VGltZXNXLnRyYW5zcG9zZSgpKSksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3csIHIsIHFdO1xuICAgICAgICAgICAgfSksIHcgPSBfYVswXSwgciA9IF9hWzFdLCBxID0gX2FbMl07XG4gICAgICAgICAgICB0ZmpzX2NvcmVfMS5kaXNwb3NlKFtyVGVtcCwgd1RlbXAsIHFUZW1wXSk7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcSwgcl07XG4gICAgfSksIHFPdXRlciA9IF9hWzBdLCByT3V0ZXIgPSBfYVsxXTtcbiAgICByZXR1cm4gW3FPdXRlciwgck91dGVyXTtcbn1cbmV4cG9ydHMucXIgPSBxcjtcbmZ1bmN0aW9uIG9uZUhvdChpbmRpY2VzLCBudW1DbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5kaWNlcy5yYW5rICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgMUQgb25lLWhvdCB0ZW5zb3JzIGFyZSBzdXBwb3J0ZWQgaW4gdGhlICcgK1xuICAgICAgICAgICAgICAgICdkZWVwbGVhcm4gYmFja2VuZCwgYXQgcHJlc2VudC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRpY2VzID0gaW5kaWNlcy50b0ludCgpO1xuICAgICAgICByZXR1cm4gdGZjLm9uZUhvdChpbmRpY2VzLCBudW1DbGFzc2VzKS50b0Zsb2F0KCk7XG4gICAgfSk7XG59XG5leHBvcnRzLm9uZUhvdCA9IG9uZUhvdDtcbmZ1bmN0aW9uIGdhdGhlcihyZWZlcmVuY2UsIGluZGljZXMsIGF4aXMpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluZGljZXMpKSB7XG4gICAgICAgICAgICBpbmRpY2VzID0gdGZqc19jb3JlXzEudGVuc29yMWQoaW5kaWNlcywgJ2ludDMyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRpY2VzID0gaW5kaWNlcy50b0ludCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZmMuZ2F0aGVyKHJlZmVyZW5jZSwgaW5kaWNlcywgYXhpcyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdhdGhlciA9IGdhdGhlcjtcbmZ1bmN0aW9uIHNxdWFyZSh4KSB7XG4gICAgcmV0dXJuIHRmYy5tdWxTdHJpY3QoeCwgeCk7XG59XG5leHBvcnRzLnNxdWFyZSA9IHNxdWFyZTtcbmZ1bmN0aW9uIHBvdyh4LCBhKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIChhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGEgPSB0ZmpzX2NvcmVfMS5zY2FsYXIoTWF0aC5yb3VuZChhKSwgJ2ludDMyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuZHR5cGUgIT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWludDMyIGR0eXBlIChcIiArIGEuZHR5cGUgKyBcIikgaXMgbm90IHN1cHBvcnRlZCBieSBwb3coKSB5ZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRmYy5wb3coeCwgYSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnBvdyA9IHBvdztcbmZ1bmN0aW9uIGJpYXNBZGQoeCwgYmlhcywgZGF0YUZvcm1hdCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YUZvcm1hdCA9IGNvbW1vbl8zLmltYWdlRGF0YUZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1vbl8xLmNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAgICAgaWYgKGJpYXMucmFuayAhPT0gMSAmJiBiaWFzLnJhbmsgIT09IHgucmFuaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1VuZXhwZWN0ZWQgYmlhcyBkaW1lbnNpb25zOiAnICsgYmlhcy5yYW5rICtcbiAgICAgICAgICAgICAgICAnOyBleHBlY3RlZCBpdCB0byBiZSAxIG9yICcgKyB4LnJhbmspO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaWFzU2hhcGUgPSBiaWFzLnNoYXBlO1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gNSkge1xuICAgICAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChiaWFzU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIGJpYXNTaGFwZVswXSwgMSwgMSwgMV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIGJpYXNTaGFwZVszXSwgYmlhc1NoYXBlWzBdLCBiaWFzU2hhcGVbMV0sIGJpYXNTaGFwZVsyXV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChiaWFzU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIDEsIDEsIDEsIGJpYXNTaGFwZVswXV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzFdLmNvbmNhdChiaWFzU2hhcGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChiaWFzU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIGJpYXNTaGFwZVswXSwgMSwgMV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIGJpYXNTaGFwZVsyXSwgYmlhc1NoYXBlWzBdLCBiaWFzU2hhcGVbMV1dKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmlhc1NoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0geC5hZGQoYmlhcy5yZXNoYXBlKFsxLCAxLCAxLCBiaWFzU2hhcGVbMF1dKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ID0geC5hZGQoYmlhcy5yZXNoYXBlKFsxXS5jb25jYXQoYmlhc1NoYXBlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmlhc1NoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0geC5hZGQoYmlhcy5yZXNoYXBlKFsxLCBiaWFzU2hhcGVbMF0sIDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ID0geC5hZGQoYmlhcy5yZXNoYXBlKFsxLCBiaWFzU2hhcGVbMV0sIGJpYXNTaGFwZVswXV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChiaWFzU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIDEsIGJpYXNTaGFwZVswXV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzFdLmNvbmNhdChiaWFzU2hhcGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA8IDMpIHtcbiAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVW5zdXBwb3J0ZWQgaW5wdXQgcmFuayBieSBiaWFzQWRkOiBcIiArIHgucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfSk7XG59XG5leHBvcnRzLmJpYXNBZGQgPSBiaWFzQWRkO1xuZnVuY3Rpb24gZWx1KHgsIGFscGhhKSB7XG4gICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAxOyB9XG4gICAgaWYgKGFscGhhICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiU3VwcG9ydCBmb3IgYWxwaGEgdmFsdWVzIG90aGVyIHRoYW4gMSAoXCIgKyBhbHBoYSArIFwiKSBpcyBub3QgaW1wbGVtZW50ZWQgXCIgK1xuICAgICAgICAgICAgXCJ5ZXQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGZjLmVsdSh4KTtcbn1cbmV4cG9ydHMuZWx1ID0gZWx1O1xuZnVuY3Rpb24gc29mdHNpZ24oeCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmYy5kaXYoeCwgdGZjLmFkZChnZXRTY2FsYXIoMSksIHRmYy5hYnMoeCkpKTsgfSk7XG59XG5leHBvcnRzLnNvZnRzaWduID0gc29mdHNpZ247XG5mdW5jdGlvbiBkcm9wb3V0KHgsIGxldmVsLCBub2lzZVNoYXBlLCBzZWVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobm9pc2VTaGFwZSAhPSBudWxsICYmICF0ZmpzX2NvcmVfMS51dGlsLmFycmF5c0VxdWFsKHguc2hhcGUsIG5vaXNlU2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignTm9uLWRlZmF1bHQgbm9pc2Ugc2hhcGUgaXMgbm90IGltcGxlbWVudGVkIHlldDogJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9pc2VTaGFwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdzZWVkIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgZHJvcG91dCB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSB0ZmMuc3RlcCh0ZmMuYWRkKHRmYy5uZWcobGV2ZWwpLCB0ZmMucmFuZG9tVW5pZm9ybSh4LnNoYXBlLCAwLCAxLCAnZmxvYXQzMicpKSk7XG4gICAgICAgIG11bHRpcGxpZXIgPSB0ZmMubXVsKHRmYy5kaXYoZ2V0U2NhbGFyKDEpLCB0ZmMuc3ViKGdldFNjYWxhcigxKSwgbGV2ZWwpKSwgbXVsdGlwbGllcik7XG4gICAgICAgIHJldHVybiB0ZmMubXVsKHgsIG11bHRpcGxpZXIpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kcm9wb3V0ID0gZHJvcG91dDtcbmZ1bmN0aW9uIG5hbWVTY29wZShuYW1lLCBmbikge1xuICAgIHJldHVybiBjb21tb25fMS5uYW1lU2NvcGUobmFtZSwgZm4pO1xufVxuZXhwb3J0cy5uYW1lU2NvcGUgPSBuYW1lU2NvcGU7XG5mdW5jdGlvbiBmbG9hdHgoKSB7XG4gICAgcmV0dXJuICdmbG9hdDMyJztcbn1cbmV4cG9ydHMuZmxvYXR4ID0gZmxvYXR4O1xudmFyIF91aWRQcmVmaXhlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0VWlkKHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IHZvaWQgMCkgeyBwcmVmaXggPSAnJzsgfVxuICAgIGlmICghKHByZWZpeCBpbiBfdWlkUHJlZml4ZXMpKSB7XG4gICAgICAgIF91aWRQcmVmaXhlc1twcmVmaXhdID0gMDtcbiAgICB9XG4gICAgX3VpZFByZWZpeGVzW3ByZWZpeF0gKz0gMTtcbiAgICByZXR1cm4gcHJlZml4ICsgX3VpZFByZWZpeGVzW3ByZWZpeF0udG9TdHJpbmcoKTtcbn1cbmV4cG9ydHMuZ2V0VWlkID0gZ2V0VWlkO1xuZnVuY3Rpb24gaGFyZFNpZ21vaWQoeCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSBzY2FsYXJQbHVzQXJyYXkoZ2V0U2NhbGFyKDAuNSksIHNjYWxhclRpbWVzQXJyYXkoZ2V0U2NhbGFyKDAuMiksIHgpKTtcbiAgICAgICAgcmV0dXJuIHRmYy5jbGlwQnlWYWx1ZSh5LCAwLCAxKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFyZFNpZ21vaWQgPSBoYXJkU2lnbW9pZDtcbmZ1bmN0aW9uIGluVHJhaW5QaGFzZSh4LCBhbHQsIHRyYWluaW5nKSB7XG4gICAgaWYgKHRyYWluaW5nID09PSB2b2lkIDApIHsgdHJhaW5pbmcgPSBmYWxzZTsgfVxuICAgIHJldHVybiB0cmFpbmluZyA/IHgoKSA6IGFsdCgpO1xufVxuZXhwb3J0cy5pblRyYWluUGhhc2UgPSBpblRyYWluUGhhc2U7XG5mdW5jdGlvbiBncmFkaWVudHMobG9zc0ZuLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgdmFyaWFibGVMaXN0ID0gdmFyaWFibGVzLm1hcChmdW5jdGlvbiAodmFyaWFibGUpIHsgcmV0dXJuIHZhcmlhYmxlLnJlYWQoKTsgfSk7XG4gICAgdmFyIHZhbHVkQW5kR3JhZHMgPSB0ZmpzX2NvcmVfMS52YXJpYWJsZUdyYWRzKGxvc3NGbiwgdmFyaWFibGVMaXN0KTtcbiAgICByZXR1cm4gdmFyaWFibGVzLm1hcChmdW5jdGlvbiAodmFyaWFibGUpIHsgcmV0dXJuIHZhbHVkQW5kR3JhZHMuZ3JhZHNbdmFyaWFibGUubmFtZV07IH0pO1xufVxuZXhwb3J0cy5ncmFkaWVudHMgPSBncmFkaWVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZmpzX2JhY2tlbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgQ2FsbGJhY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRpb25EYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgfVxuICAgIENhbGxiYWNrLnByb3RvdHlwZS5zZXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH07XG4gICAgQ2FsbGJhY2sucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9O1xuICAgIENhbGxiYWNrLnByb3RvdHlwZS5vbkVwb2NoQmVnaW4gPSBmdW5jdGlvbiAoZXBvY2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBDYWxsYmFjay5wcm90b3R5cGUub25FcG9jaEVuZCA9IGZ1bmN0aW9uIChlcG9jaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIENhbGxiYWNrLnByb3RvdHlwZS5vbkJhdGNoQmVnaW4gPSBmdW5jdGlvbiAoYmF0Y2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBDYWxsYmFjay5wcm90b3R5cGUub25CYXRjaEVuZCA9IGZ1bmN0aW9uIChiYXRjaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIENhbGxiYWNrLnByb3RvdHlwZS5vblRyYWluQmVnaW4gPSBmdW5jdGlvbiAobG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIENhbGxiYWNrLnByb3RvdHlwZS5vblRyYWluRW5kID0gZnVuY3Rpb24gKGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbGJhY2s7XG59KCkpO1xuZXhwb3J0cy5DYWxsYmFjayA9IENhbGxiYWNrO1xudmFyIENhbGxiYWNrTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsbGJhY2tMaXN0KGNhbGxiYWNrcywgcXVldWVMZW5ndGgpIHtcbiAgICAgICAgaWYgKHF1ZXVlTGVuZ3RoID09PSB2b2lkIDApIHsgcXVldWVMZW5ndGggPSAxMDsgfVxuICAgICAgICBpZiAoY2FsbGJhY2tzID09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnF1ZXVlTGVuZ3RoID0gcXVldWVMZW5ndGg7XG4gICAgfVxuICAgIENhbGxiYWNrTGlzdC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2FsbGJhY2tMaXN0LnByb3RvdHlwZS5zZXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNhbGxiYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgIGNhbGxiYWNrLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxsYmFja0xpc3QucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNhbGxiYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgIGNhbGxiYWNrLnNldE1vZGVsKG1vZGVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsbGJhY2tMaXN0LnByb3RvdHlwZS5vbkVwb2NoQmVnaW4gPSBmdW5jdGlvbiAoZXBvY2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfYSwgY2FsbGJhY2s7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBfYSA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IF9hLmxlbmd0aCkpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbGJhY2sub25FcG9jaEJlZ2luKGVwb2NoLCBsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxsYmFja0xpc3QucHJvdG90eXBlLm9uRXBvY2hFbmQgPSBmdW5jdGlvbiAoZXBvY2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfYSwgY2FsbGJhY2s7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBfYSA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IF9hLmxlbmd0aCkpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbGJhY2sub25FcG9jaEVuZChlcG9jaCwgbG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsbGJhY2tMaXN0LnByb3RvdHlwZS5vbkJhdGNoQmVnaW4gPSBmdW5jdGlvbiAoYmF0Y2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfYSwgY2FsbGJhY2s7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBfYSA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IF9hLmxlbmd0aCkpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbGJhY2sub25CYXRjaEJlZ2luKGJhdGNoLCBsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxsYmFja0xpc3QucHJvdG90eXBlLm9uQmF0Y2hFbmQgPSBmdW5jdGlvbiAoYmF0Y2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfYSwgY2FsbGJhY2s7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBfYSA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IF9hLmxlbmd0aCkpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbGJhY2sub25CYXRjaEVuZChiYXRjaCwgbG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsbGJhY2tMaXN0LnByb3RvdHlwZS5vblRyYWluQmVnaW4gPSBmdW5jdGlvbiAobG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2ksIF9hLCBjYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIF9hID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjYWxsYmFjay5vblRyYWluQmVnaW4obG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsbGJhY2tMaXN0LnByb3RvdHlwZS5vblRyYWluRW5kID0gZnVuY3Rpb24gKGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfYSwgY2FsbGJhY2s7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBfYSA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IF9hLmxlbmd0aCkpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbGJhY2sub25UcmFpbkVuZChsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbGJhY2tMaXN0O1xufSgpKTtcbmV4cG9ydHMuQ2FsbGJhY2tMaXN0ID0gQ2FsbGJhY2tMaXN0O1xudmFyIEJhc2VMb2dnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlTG9nZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VMb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5vbkVwb2NoQmVnaW4gPSBmdW5jdGlvbiAoZXBvY2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbHMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUub25CYXRjaEVuZCA9IGZ1bmN0aW9uIChiYXRjaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSwgX2xvb3BfMSwgdGhpc18xLCBrZXk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhdGNoU2l6ZSA9IGxvZ3NbJ3NpemUnXSA9PSBudWxsID8gMCA6IGxvZ3NbJ3NpemUnXTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZW4gKz0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgICAgIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxvZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpc18xLnRvdGFscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLnRvdGFsc1trZXldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS50b3RhbHNba2V5XSA9IHRoaXNfMS50b3RhbHNba2V5XSArIHZhbHVlICogYmF0Y2hTaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFRvdGFsc1RvRGlzcG9zZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpc18xLnRvdGFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFRvdGFsc1RvRGlzcG9zZSA9IHRoaXNfMS50b3RhbHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS50b3RhbHNba2V5XSA9IEsuZ2V0U2NhbGFyKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLnRvdGFsc1trZXldID0gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBLLnNjYWxhclBsdXNBcnJheShfdGhpcy50b3RhbHNba2V5XSwgdGZqc19jb3JlXzEubXVsKHZhbHVlLCBLLmdldFNjYWxhcihiYXRjaFNpemUpKSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFRvdGFsc1RvRGlzcG9zZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVG90YWxzVG9EaXNwb3NlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBsb2dzKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLm9uRXBvY2hFbmQgPSBmdW5jdGlvbiAoZXBvY2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfbG9vcF8yLCB0aGlzXzIsIF9pLCBfYSwga2V5O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIGlmIChsb2dzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzXzIudG90YWxzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNfMi50b3RhbHNba2V5XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzW2tleV0gPSB0aGlzXzIudG90YWxzW2tleV0gLyB0aGlzXzIuc2VlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSy5zY2FsYXJUaW1lc0FycmF5KHRmanNfY29yZV8xLmRpdihLLmdldFNjYWxhcigxKSwgSy5nZXRTY2FsYXIoX3RoaXMuc2VlbikpLCBfdGhpcy50b3RhbHNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvdGFsc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGZqc19jb3JlXzEua2VlcChsb2dzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2EgPSB0aGlzLnBhcmFtc1snbWV0cmljcyddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMihrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUxvZ2dlcjtcbn0oQ2FsbGJhY2spKTtcbmV4cG9ydHMuQmFzZUxvZ2dlciA9IEJhc2VMb2dnZXI7XG5mdW5jdGlvbiByZXNvbHZlU2NhbGFyc0luTG9ncyhsb2dzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMsIGtleXMsIGtleSwgdmFsdWUsIHZhbHVlU2NhbGFyLCB2YWx1ZXMsIGk7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBsb2dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxvZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTY2FsYXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHZhbHVlU2NhbGFyLmRhdGEoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBQcm9taXNlLmFsbChwcm9taXNlcyldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dzW2tleXNbaV1dID0gdmFsdWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZXNvbHZlU2NhbGFyc0luTG9ncyA9IHJlc29sdmVTY2FsYXJzSW5Mb2dzO1xuZnVuY3Rpb24gZGlzcG9zZVRlbnNvcnNJbkxvZ3MobG9ncykge1xuICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbG9ncykge1xuICAgICAgICB2YXIgdmFsdWUgPSBsb2dzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRpc3Bvc2VUZW5zb3JzSW5Mb2dzID0gZGlzcG9zZVRlbnNvcnNJbkxvZ3M7XG52YXIgSGlzdG9yeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhpc3RvcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGlzdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBIaXN0b3J5LnByb3RvdHlwZS5vblRyYWluQmVnaW4gPSBmdW5jdGlvbiAobG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcG9jaCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeSA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIaXN0b3J5LnByb3RvdHlwZS5vbkVwb2NoRW5kID0gZnVuY3Rpb24gKGVwb2NoLCBsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZXBvY2gucHVzaChlcG9jaCk7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gbG9ncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oaXN0b3J5W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5W2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3Rvcnlba2V5XS5wdXNoKGxvZ3Nba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIaXN0b3J5LnByb3RvdHlwZS5zeW5jRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzLCBrZXlzLCBpbmRpY2VzLCBrZXksIHZhbHVlQXJyYXksIGksIHZhbHVlU2NhbGFyLCB2YWx1ZXMsIG47XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdGhpcy5oaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVBcnJheSA9IHRoaXMuaGlzdG9yeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZUFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVBcnJheVtpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU2NhbGFyID0gdmFsdWVBcnJheVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godmFsdWVTY2FsYXIuZGF0YSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBQcm9taXNlLmFsbChwcm9taXNlcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgdmFsdWVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5W2tleXNbbl1dW2luZGljZXNbbl1dLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3Rvcnlba2V5c1tuXV1baW5kaWNlc1tuXV0gPSB2YWx1ZXNbbl1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIaXN0b3J5O1xufShDYWxsYmFjaykpO1xuZXhwb3J0cy5IaXN0b3J5ID0gSGlzdG9yeTtcbnZhciBDdXN0b21DYWxsYmFjayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1c3RvbUNhbGxiYWNrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUNhbGxiYWNrKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50cmFpbkJlZ2luID0gY29uZmlnLm9uVHJhaW5CZWdpbjtcbiAgICAgICAgX3RoaXMudHJhaW5FbmQgPSBjb25maWcub25UcmFpbkVuZDtcbiAgICAgICAgX3RoaXMuZXBvY2hCZWdpbiA9IGNvbmZpZy5vbkVwb2NoQmVnaW47XG4gICAgICAgIF90aGlzLmVwb2NoRW5kID0gY29uZmlnLm9uRXBvY2hFbmQ7XG4gICAgICAgIF90aGlzLmJhdGNoQmVnaW4gPSBjb25maWcub25CYXRjaEJlZ2luO1xuICAgICAgICBfdGhpcy5iYXRjaEVuZCA9IGNvbmZpZy5vbkJhdGNoRW5kO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEN1c3RvbUNhbGxiYWNrLnByb3RvdHlwZS5vbkVwb2NoQmVnaW4gPSBmdW5jdGlvbiAoZXBvY2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5lcG9jaEJlZ2luICE9IG51bGwpKSByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCByZXNvbHZlU2NhbGFyc0luTG9ncyhsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5lcG9jaEJlZ2luKGVwb2NoLCBsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEN1c3RvbUNhbGxiYWNrLnByb3RvdHlwZS5vbkVwb2NoRW5kID0gZnVuY3Rpb24gKGVwb2NoLCBsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuZXBvY2hFbmQgIT0gbnVsbCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmVwb2NoRW5kKGVwb2NoLCBsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEN1c3RvbUNhbGxiYWNrLnByb3RvdHlwZS5vbkJhdGNoQmVnaW4gPSBmdW5jdGlvbiAoYmF0Y2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5iYXRjaEJlZ2luICE9IG51bGwpKSByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCByZXNvbHZlU2NhbGFyc0luTG9ncyhsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5iYXRjaEJlZ2luKGJhdGNoLCBsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEN1c3RvbUNhbGxiYWNrLnByb3RvdHlwZS5vbkJhdGNoRW5kID0gZnVuY3Rpb24gKGJhdGNoLCBsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuYmF0Y2hFbmQgIT0gbnVsbCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmJhdGNoRW5kKGJhdGNoLCBsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEN1c3RvbUNhbGxiYWNrLnByb3RvdHlwZS5vblRyYWluQmVnaW4gPSBmdW5jdGlvbiAobG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnRyYWluQmVnaW4gIT0gbnVsbCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLnRyYWluQmVnaW4obG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDdXN0b21DYWxsYmFjay5wcm90b3R5cGUub25UcmFpbkVuZCA9IGZ1bmN0aW9uIChsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMudHJhaW5FbmQgIT0gbnVsbCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLnRyYWluRW5kKGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbUNhbGxiYWNrO1xufShDYWxsYmFjaykpO1xuZXhwb3J0cy5DdXN0b21DYWxsYmFjayA9IEN1c3RvbUNhbGxiYWNrO1xuZnVuY3Rpb24gc3RhbmRhcmRpemVDYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gICAgaWYgKGNhbGxiYWNrcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2tzIGluc3RhbmNlb2YgQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIFtjYWxsYmFja3NdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFja3MpICYmIGNhbGxiYWNrc1swXSBpbnN0YW5jZW9mIENhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFja3M7XG4gICAgfVxuICAgIHZhciBjYWxsYmFja0NvbmZpZ3MgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChjYWxsYmFja3MpO1xuICAgIHJldHVybiBjYWxsYmFja0NvbmZpZ3MubWFwKGZ1bmN0aW9uIChjYWxsYmFja0NvbmZpZykgeyByZXR1cm4gbmV3IEN1c3RvbUNhbGxiYWNrKGNhbGxiYWNrQ29uZmlnKTsgfSk7XG59XG5leHBvcnRzLnN0YW5kYXJkaXplQ2FsbGJhY2tzID0gc3RhbmRhcmRpemVDYWxsYmFja3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsYmFja3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBuYW1lTWFwID0gbmV3IE1hcCgpO1xuZXhwb3J0cy5WQUxJRF9EQVRBX0ZPUk1BVF9WQUxVRVMgPSBbJ2NoYW5uZWxzRmlyc3QnLCAnY2hhbm5lbHNMYXN0J107XG5mdW5jdGlvbiBjaGVja0RhdGFGb3JtYXQodmFsdWUpIHtcbiAgICBnZW5lcmljX3V0aWxzXzEuY2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShleHBvcnRzLlZBTElEX0RBVEFfRk9STUFUX1ZBTFVFUywgJ0RhdGFGb3JtYXQnLCB2YWx1ZSk7XG59XG5leHBvcnRzLmNoZWNrRGF0YUZvcm1hdCA9IGNoZWNrRGF0YUZvcm1hdDtcbmV4cG9ydHMuVkFMSURfUEFERElOR19NT0RFX1ZBTFVFUyA9IFsndmFsaWQnLCAnc2FtZScsICdjYXVzYWwnXTtcbmZ1bmN0aW9uIGNoZWNrUGFkZGluZ01vZGUodmFsdWUpIHtcbiAgICBnZW5lcmljX3V0aWxzXzEuY2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShleHBvcnRzLlZBTElEX1BBRERJTkdfTU9ERV9WQUxVRVMsICdQYWRkaW5nTW9kZScsIHZhbHVlKTtcbn1cbmV4cG9ydHMuY2hlY2tQYWRkaW5nTW9kZSA9IGNoZWNrUGFkZGluZ01vZGU7XG5leHBvcnRzLlZBTElEX1BPT0xfTU9ERV9WQUxVRVMgPSBbJ21heCcsICdhdmcnXTtcbmZ1bmN0aW9uIGNoZWNrUG9vbE1vZGUodmFsdWUpIHtcbiAgICBnZW5lcmljX3V0aWxzXzEuY2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShleHBvcnRzLlZBTElEX1BPT0xfTU9ERV9WQUxVRVMsICdQb29sTW9kZScsIHZhbHVlKTtcbn1cbmV4cG9ydHMuY2hlY2tQb29sTW9kZSA9IGNoZWNrUG9vbE1vZGU7XG52YXIgX25hbWVTY29wZVN0YWNrID0gW107XG52YXIgX25hbWVTY29wZURpdmlkZXIgPSAnLyc7XG5mdW5jdGlvbiBuYW1lU2NvcGUobmFtZSwgZm4pIHtcbiAgICBfbmFtZVNjb3BlU3RhY2sucHVzaChuYW1lKTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdmFsID0gZm4oKTtcbiAgICAgICAgX25hbWVTY29wZVN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBfbmFtZVNjb3BlU3RhY2sucG9wKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuZXhwb3J0cy5uYW1lU2NvcGUgPSBuYW1lU2NvcGU7XG5mdW5jdGlvbiBjdXJyZW50TmFtZVNjb3BlUHJlZml4KCkge1xuICAgIGlmIChfbmFtZVNjb3BlU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfbmFtZVNjb3BlU3RhY2suam9pbihfbmFtZVNjb3BlRGl2aWRlcikgKyBfbmFtZVNjb3BlRGl2aWRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY29wZWRUZW5zb3JOYW1lKHRlbnNvck5hbWUpIHtcbiAgICBpZiAoIWlzVmFsaWRUZW5zb3JOYW1lKHRlbnNvck5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6IFxcJycgKyB0ZW5zb3JOYW1lICsgJ1xcJycpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudE5hbWVTY29wZVByZWZpeCgpICsgdGVuc29yTmFtZTtcbn1cbmV4cG9ydHMuZ2V0U2NvcGVkVGVuc29yTmFtZSA9IGdldFNjb3BlZFRlbnNvck5hbWU7XG5mdW5jdGlvbiBnZXRVbmlxdWVUZW5zb3JOYW1lKHNjb3BlZE5hbWUpIHtcbiAgICBpZiAoIWlzVmFsaWRUZW5zb3JOYW1lKHNjb3BlZE5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6IFxcJycgKyBzY29wZWROYW1lICsgJ1xcJycpO1xuICAgIH1cbiAgICBpZiAoIW5hbWVNYXAuaGFzKHNjb3BlZE5hbWUpKSB7XG4gICAgICAgIG5hbWVNYXAuc2V0KHNjb3BlZE5hbWUsIDApO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBuYW1lTWFwLmdldChzY29wZWROYW1lKTtcbiAgICBuYW1lTWFwLnNldChzY29wZWROYW1lLCBuYW1lTWFwLmdldChzY29wZWROYW1lKSArIDEpO1xuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNjb3BlZE5hbWUgKyAnXycgKyBpbmRleDtcbiAgICAgICAgbmFtZU1hcC5zZXQocmVzdWx0LCAxKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzY29wZWROYW1lO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0VW5pcXVlVGVuc29yTmFtZSA9IGdldFVuaXF1ZVRlbnNvck5hbWU7XG52YXIgdGVuc29yTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgvXltBLVphLXpdW0EtWmEtejAtOVxcLl9cXC9dKiQvKTtcbmZ1bmN0aW9uIGlzVmFsaWRUZW5zb3JOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5tYXRjaCh0ZW5zb3JOYW1lUmVnZXgpID8gdHJ1ZSA6IGZhbHNlO1xufVxuZXhwb3J0cy5pc1ZhbGlkVGVuc29yTmFtZSA9IGlzVmFsaWRUZW5zb3JOYW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG5mdW5jdGlvbiBjYWxjTDJOb3Jtcyh3LCBheGlzKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZjLnNxcnQodGZjLnN1bShLLnNxdWFyZSh3KSwgYXhpcywgdHJ1ZSkpOyB9KTtcbn1cbnZhciBDb25zdHJhaW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uc3RyYWludCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdHJhaW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENvbnN0cmFpbnQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG4gICAgQ29uc3RyYWludCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnQ29uc3RyYWludHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIG5hbWVzcGFjZTogJ2NvbnN0cmFpbnRzJyB9KVxuICAgIF0sIENvbnN0cmFpbnQpO1xuICAgIHJldHVybiBDb25zdHJhaW50O1xufSh0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSkpO1xuZXhwb3J0cy5Db25zdHJhaW50ID0gQ29uc3RyYWludDtcbnZhciBNYXhOb3JtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4Tm9ybSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXhOb3JtKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWZhdWx0TWF4VmFsdWUgPSAyO1xuICAgICAgICBfdGhpcy5kZWZhdWx0QXhpcyA9IDA7XG4gICAgICAgIF90aGlzLm1heFZhbHVlID1cbiAgICAgICAgICAgIGNvbmZpZy5tYXhWYWx1ZSAhPSBudWxsID8gY29uZmlnLm1heFZhbHVlIDogX3RoaXMuZGVmYXVsdE1heFZhbHVlO1xuICAgICAgICBfdGhpcy5heGlzID0gY29uZmlnLmF4aXMgIT0gbnVsbCA/IGNvbmZpZy5heGlzIDogX3RoaXMuZGVmYXVsdEF4aXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF4Tm9ybS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAodykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9ybXMgPSBjYWxjTDJOb3Jtcyh3LCBfdGhpcy5heGlzKTtcbiAgICAgICAgICAgIHZhciBkZXNpcmVkID0gdGZjLmNsaXBCeVZhbHVlKG5vcm1zLCAwLCBfdGhpcy5tYXhWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGZjLm11bCh3LCB0ZmMuZGl2KGRlc2lyZWQsIEsuc2NhbGFyUGx1c0FycmF5KEsuZ2V0U2NhbGFyKEsuZXBzaWxvbigpKSwgbm9ybXMpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF4Tm9ybS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBtYXhWYWx1ZTogdGhpcy5tYXhWYWx1ZSwgYXhpczogdGhpcy5heGlzIH07XG4gICAgfTtcbiAgICBNYXhOb3JtLmNsYXNzTmFtZSA9ICdNYXhOb3JtJztcbiAgICByZXR1cm4gTWF4Tm9ybTtcbn0oQ29uc3RyYWludCkpO1xuZXhwb3J0cy5NYXhOb3JtID0gTWF4Tm9ybTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihNYXhOb3JtKTtcbnZhciBVbml0Tm9ybSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuaXROb3JtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuaXROb3JtKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWZhdWx0QXhpcyA9IDA7XG4gICAgICAgIF90aGlzLmF4aXMgPSBjb25maWcuYXhpcyAhPSBudWxsID8gY29uZmlnLmF4aXMgOiBfdGhpcy5kZWZhdWx0QXhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBVbml0Tm9ybS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAodykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0ZmMuZGl2KHcsIEsuc2NhbGFyUGx1c0FycmF5KEsuZ2V0U2NhbGFyKEsuZXBzaWxvbigpKSwgY2FsY0wyTm9ybXModywgX3RoaXMuYXhpcykpKTsgfSk7XG4gICAgfTtcbiAgICBVbml0Tm9ybS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBheGlzOiB0aGlzLmF4aXMgfTtcbiAgICB9O1xuICAgIFVuaXROb3JtLmNsYXNzTmFtZSA9ICdVbml0Tm9ybSc7XG4gICAgcmV0dXJuIFVuaXROb3JtO1xufShDb25zdHJhaW50KSk7XG5leHBvcnRzLlVuaXROb3JtID0gVW5pdE5vcm07XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoVW5pdE5vcm0pO1xudmFyIE5vbk5lZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vbk5lZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb25OZWcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTm9uTmVnLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHJldHVybiB0ZmMucmVsdSh3KTtcbiAgICB9O1xuICAgIE5vbk5lZy5jbGFzc05hbWUgPSAnTm9uTmVnJztcbiAgICByZXR1cm4gTm9uTmVnO1xufShDb25zdHJhaW50KSk7XG5leHBvcnRzLk5vbk5lZyA9IE5vbk5lZztcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihOb25OZWcpO1xudmFyIE1pbk1heE5vcm0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNaW5NYXhOb3JtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1pbk1heE5vcm0oY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlZmF1bHRNaW5WYWx1ZSA9IDAuMDtcbiAgICAgICAgX3RoaXMuZGVmYXVsdE1heFZhbHVlID0gMS4wO1xuICAgICAgICBfdGhpcy5kZWZhdWx0UmF0ZSA9IDEuMDtcbiAgICAgICAgX3RoaXMuZGVmYXVsdEF4aXMgPSAwO1xuICAgICAgICBfdGhpcy5taW5WYWx1ZSA9XG4gICAgICAgICAgICBjb25maWcubWluVmFsdWUgIT0gbnVsbCA/IGNvbmZpZy5taW5WYWx1ZSA6IF90aGlzLmRlZmF1bHRNaW5WYWx1ZTtcbiAgICAgICAgX3RoaXMubWF4VmFsdWUgPVxuICAgICAgICAgICAgY29uZmlnLm1heFZhbHVlICE9IG51bGwgPyBjb25maWcubWF4VmFsdWUgOiBfdGhpcy5kZWZhdWx0TWF4VmFsdWU7XG4gICAgICAgIF90aGlzLnJhdGUgPSBjb25maWcucmF0ZSAhPSBudWxsID8gY29uZmlnLnJhdGUgOiBfdGhpcy5kZWZhdWx0UmF0ZTtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGNvbmZpZy5heGlzICE9IG51bGwgPyBjb25maWcuYXhpcyA6IF90aGlzLmRlZmF1bHRBeGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1pbk1heE5vcm0ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vcm1zID0gY2FsY0wyTm9ybXModywgX3RoaXMuYXhpcyk7XG4gICAgICAgICAgICB2YXIgZGVzaXJlZCA9IHRmYy5hZGQoSy5zY2FsYXJUaW1lc0FycmF5KEsuZ2V0U2NhbGFyKF90aGlzLnJhdGUpLCB0ZmMuY2xpcEJ5VmFsdWUobm9ybXMsIF90aGlzLm1pblZhbHVlLCBfdGhpcy5tYXhWYWx1ZSkpLCBLLnNjYWxhclRpbWVzQXJyYXkoSy5nZXRTY2FsYXIoMS4wIC0gX3RoaXMucmF0ZSksIG5vcm1zKSk7XG4gICAgICAgICAgICByZXR1cm4gdGZjLm11bCh3LCB0ZmMuZGl2KGRlc2lyZWQsIEsuc2NhbGFyUGx1c0FycmF5KEsuZ2V0U2NhbGFyKEsuZXBzaWxvbigpKSwgbm9ybXMpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWluTWF4Tm9ybS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluVmFsdWU6IHRoaXMubWluVmFsdWUsXG4gICAgICAgICAgICBtYXhWYWx1ZTogdGhpcy5tYXhWYWx1ZSxcbiAgICAgICAgICAgIHJhdGU6IHRoaXMucmF0ZSxcbiAgICAgICAgICAgIGF4aXM6IHRoaXMuYXhpc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTWluTWF4Tm9ybS5jbGFzc05hbWUgPSAnTWluTWF4Tm9ybSc7XG4gICAgcmV0dXJuIE1pbk1heE5vcm07XG59KENvbnN0cmFpbnQpKTtcbmV4cG9ydHMuTWluTWF4Tm9ybSA9IE1pbk1heE5vcm07XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTWluTWF4Tm9ybSk7XG5leHBvcnRzLkNPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQID0ge1xuICAgICdtYXhOb3JtJzogJ01heE5vcm0nLFxuICAgICdtaW5NYXhOb3JtJzogJ01pbk1heE5vcm0nLFxuICAgICdub25OZWcnOiAnTm9uTmVnJyxcbiAgICAndW5pdE5vcm0nOiAnVW5pdE5vcm0nXG59O1xuZnVuY3Rpb24gc2VyaWFsaXplQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHNfMS5zZXJpYWxpemVLZXJhc09iamVjdChjb25zdHJhaW50KTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplQ29uc3RyYWludCA9IHNlcmlhbGl6ZUNvbnN0cmFpbnQ7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUNvbnN0cmFpbnQoY29uZmlnLCBjdXN0b21PYmplY3RzKSB7XG4gICAgaWYgKGN1c3RvbU9iamVjdHMgPT09IHZvaWQgMCkgeyBjdXN0b21PYmplY3RzID0ge307IH1cbiAgICByZXR1cm4gZ2VuZXJpY191dGlsc18xLmRlc2VyaWFsaXplS2VyYXNPYmplY3QoY29uZmlnLCB0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLCBjdXN0b21PYmplY3RzLCAnY29uc3RyYWludCcpO1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZUNvbnN0cmFpbnQgPSBkZXNlcmlhbGl6ZUNvbnN0cmFpbnQ7XG5mdW5jdGlvbiBnZXRDb25zdHJhaW50KGlkZW50aWZpZXIpIHtcbiAgICBpZiAoaWRlbnRpZmllciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBpZGVudGlmaWVyIGluIGV4cG9ydHMuQ09OU1RSQUlOVF9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVAgP1xuICAgICAgICAgICAgZXhwb3J0cy5DT05TVFJBSU5UX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUFtpZGVudGlmaWVyXSA6XG4gICAgICAgICAgICBpZGVudGlmaWVyO1xuICAgICAgICB2YXIgY29uZmlnID0geyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgY29uZmlnOiB7fSB9O1xuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVDb25zdHJhaW50KGNvbmZpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlkZW50aWZpZXIgaW5zdGFuY2VvZiBDb25zdHJhaW50KSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplQ29uc3RyYWludChpZGVudGlmaWVyKTtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbnN0cmFpbnQgPSBnZXRDb25zdHJhaW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RyYWludHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi90b3BvbG9neVwiKTtcbmZ1bmN0aW9uIGFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGtleSwgdmFsKSB7XG4gICAgaWYgKGtleS5kdHlwZSAhPSBudWxsICYmIGtleS5kdHlwZSAhPT0gdmFsLmR0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIGR0eXBlIG9mIHRoZSBmZWVkIChcIiArIHZhbC5kdHlwZSArIFwiKSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGF0IG9mIFwiICtcbiAgICAgICAgICAgIChcInRoZSBrZXkgJ1wiICsga2V5Lm5hbWUgKyBcIicgKFwiICsga2V5LmR0eXBlICsgXCIpLlwiKSk7XG4gICAgfVxuICAgIGlmIChrZXkuc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoa2V5LnNoYXBlLmxlbmd0aCAhPT0gdmFsLnNoYXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgcmFuayBvZiBmZWVkIChcIiArIHZhbC5zaGFwZS5sZW5ndGggKyBcIikgZG9lcyBub3QgbWF0Y2ggdGhlIHJhbmsgb2YgXCIgK1xuICAgICAgICAgICAgICAgIChcInRoZSBrZXkgKFwiICsga2V5LnNoYXBlLmxlbmd0aCArIFwiKS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5LnNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoa2V5LnNoYXBlW2ldICE9IG51bGwgJiYga2V5LnNoYXBlW2ldICE9PSB2YWwuc2hhcGVbaV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSBcIiArIGkgKyBcIi10aCBkaW1lbnNpb24gb2YgdGhlIGZlZWQgKFwiICsgdmFsLnNoYXBlW2ldICsgXCIpIGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiaW5jb21wYXRpYmxlIHdpdGggdGhhdCBvZiB0aGUga2V5IChcIiArIGtleS5zaGFwZVtpXSArIFwiKS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxudmFyIEZlZWREaWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGZWVkRGljdChmZWVkcykge1xuICAgICAgICB0aGlzLmlkMlZhbHVlID0ge307XG4gICAgICAgIGlmIChmZWVkcyBpbnN0YW5jZW9mIEZlZWREaWN0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBmZWVkcy5pZDJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWQyVmFsdWVbaWRdID0gZmVlZHMuaWQyVmFsdWVbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZlZWRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGZlZWRzXzEgPSBmZWVkczsgX2kgPCBmZWVkc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBmZWVkID0gZmVlZHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoZmVlZC5rZXksIGZlZWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEZlZWREaWN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBhc3NlcnRGZWVkQ29tcGF0aWJpbGl0eShrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuaWQyVmFsdWVba2V5LmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkMlZhbHVlW2tleS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRHVwbGljYXRlIGtleTogbmFtZT1cIiArIGtleS5uYW1lICsgXCIsIGlkPVwiICsga2V5LmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEZlZWREaWN0LnByb3RvdHlwZS5hZGRGZWVkID0gZnVuY3Rpb24gKGZlZWQpIHtcbiAgICAgICAgdGhpcy5hZGQoZmVlZC5rZXksIGZlZWQudmFsdWUpO1xuICAgIH07XG4gICAgRmVlZERpY3QucHJvdG90eXBlLmhhc0tleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQyVmFsdWVba2V5LmlkXSAhPSBudWxsO1xuICAgIH07XG4gICAgRmVlZERpY3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5pZDJWYWx1ZVtrZXkuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiTm9uZXhpc3RlbnQga2V5OiBcIiArIEpTT04uc3RyaW5naWZ5KGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQyVmFsdWVba2V5LmlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZlZWREaWN0O1xufSgpKTtcbmV4cG9ydHMuRmVlZERpY3QgPSBGZWVkRGljdDtcbmZ1bmN0aW9uIGV4ZWN1dGUoZmV0Y2hlcywgZmVlZERpY3QsIGt3YXJncykge1xuICAgIHZhciBhcnJheUZldGNoZXMgPSBBcnJheS5pc0FycmF5KGZldGNoZXMpO1xuICAgIHZhciBmZXRjaEFycmF5ID0gYXJyYXlGZXRjaGVzID8gZmV0Y2hlcyA6IFtmZXRjaGVzXTtcbiAgICB2YXIgb3V0cHV0cyA9IFtdO1xuICAgIHZhciBpbnRlcm5hbEZlZWREaWN0ID0gbmV3IEZlZWREaWN0KGZlZWREaWN0KTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGZldGNoQXJyYXlfMSA9IGZldGNoQXJyYXk7IF9pIDwgZmV0Y2hBcnJheV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZmV0Y2hfMSA9IGZldGNoQXJyYXlfMVtfaV07XG4gICAgICAgIG91dHB1dHMucHVzaChleGVjdXRlSW50ZXJuYWwoZmV0Y2hfMSwgaW50ZXJuYWxGZWVkRGljdCwga3dhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheUZldGNoZXMgPyBvdXRwdXRzIDogb3V0cHV0c1swXTtcbn1cbmV4cG9ydHMuZXhlY3V0ZSA9IGV4ZWN1dGU7XG5mdW5jdGlvbiBleGVjdXRlSW50ZXJuYWwoZmV0Y2gsIGludGVybmFsRmVlZERpY3QsIGt3YXJncykge1xuICAgIGlmIChpbnRlcm5hbEZlZWREaWN0Lmhhc0tleShmZXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFsRmVlZERpY3QuZ2V0VmFsdWUoZmV0Y2gpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2guc291cmNlTGF5ZXIgaW5zdGFuY2VvZiB0b3BvbG9neV8xLklucHV0TGF5ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJNaXNzaW5nIGEgZmVlZCB2YWx1ZSBmb3IgU3ltYm9saWNUZW5zb3IgZnJvbSBJbnB1dExheWVyIFwiICtcbiAgICAgICAgICAgIChcIidcIiArIHRvcG9sb2d5XzEuSW5wdXRMYXllci5uYW1lICsgXCInXCIpKTtcbiAgICB9XG4gICAgdmFyIGlucHV0cyA9IGZldGNoLmlucHV0cztcbiAgICB2YXIgaW5wdXRWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c18xID0gaW5wdXRzOyBfaSA8IGlucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfMVtfaV07XG4gICAgICAgIHZhciBpbnB1dFZhbCA9IGV4ZWN1dGVJbnRlcm5hbChpbnB1dCwgaW50ZXJuYWxGZWVkRGljdCwga3dhcmdzKTtcbiAgICAgICAgaW5wdXRWYWx1ZXMucHVzaChpbnB1dFZhbCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBmZXRjaC5zb3VyY2VMYXllci5hcHBseShpbnB1dFZhbHVlcywga3dhcmdzKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3V0cHV0KSkge1xuICAgICAgICBvdXRwdXQgPSBbb3V0cHV0XTtcbiAgICB9XG4gICAgdmFyIGxheWVyT3V0cHV0cyA9IGdldE5vZGVPdXRwdXRzKGZldGNoKTtcbiAgICB2YXIgb3V0cHV0U3ltYm9saWNUZW5zb3JzID0gQXJyYXkuaXNBcnJheShsYXllck91dHB1dHMpID8gbGF5ZXJPdXRwdXRzIDogW2xheWVyT3V0cHV0c107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRTeW1ib2xpY1RlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW50ZXJuYWxGZWVkRGljdC5hZGQob3V0cHV0U3ltYm9saWNUZW5zb3JzW2ldLCBvdXRwdXRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA9PT0gMSA/IG91dHB1dFswXSA6IG91dHB1dFtmZXRjaC5vdXRwdXRUZW5zb3JJbmRleF07XG59XG5mdW5jdGlvbiBnZXROb2RlT3V0cHV0cyhmZXRjaCkge1xuICAgIHZhciBsYXllck91dHB1dHM7XG4gICAgaWYgKGZldGNoLnNvdXJjZUxheWVyLmluYm91bmROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbGF5ZXJPdXRwdXRzID0gZmV0Y2guc291cmNlTGF5ZXIub3V0cHV0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmV0Y2guc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZmV0Y2guc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzW2ldXG4gICAgICAgICAgICAgICAgLm91dHB1dFRlbnNvcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dFRlbnNvciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0VGVuc29yLmlkID09PSBmZXRjaC5pZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXJPdXRwdXRzID0gZmV0Y2guc291cmNlTGF5ZXIuZ2V0T3V0cHV0QXQobm9kZUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGxheWVyT3V0cHV0cztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuLi9sYXllcnMvc2VyaWFsaXphdGlvblwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc2VyaWFsaXphdGlvbl91dGlsc1wiKTtcbnZhciB2YXJpYWJsZXNfMSA9IHJlcXVpcmUoXCIuLi92YXJpYWJsZXNcIik7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4uL3ZlcnNpb25cIik7XG52YXIgSW5wdXRTcGVjID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnB1dFNwZWMoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZHR5cGUgPSBjb25maWcuZHR5cGU7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBjb25maWcuc2hhcGU7XG4gICAgICAgIGlmIChjb25maWcuc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5uZGltID0gY29uZmlnLnNoYXBlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmRpbSA9IGNvbmZpZy5uZGltO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4TkRpbSA9IGNvbmZpZy5tYXhORGltO1xuICAgICAgICB0aGlzLm1pbk5EaW0gPSBjb25maWcubWluTkRpbTtcbiAgICAgICAgdGhpcy5heGVzID0gY29uZmlnLmF4ZXMgfHwge307XG4gICAgfVxuICAgIHJldHVybiBJbnB1dFNwZWM7XG59KCkpO1xuZXhwb3J0cy5JbnB1dFNwZWMgPSBJbnB1dFNwZWM7XG52YXIgX25leHROb2RlSUQgPSAwO1xudmFyIE5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUoY29uZmlnLCBjYWxsQXJncykge1xuICAgICAgICB0aGlzLmNhbGxBcmdzID0gY2FsbEFyZ3M7XG4gICAgICAgIHRoaXMuaWQgPSBfbmV4dE5vZGVJRCsrO1xuICAgICAgICB0aGlzLm91dGJvdW5kTGF5ZXIgPSBjb25maWcub3V0Ym91bmRMYXllcjtcbiAgICAgICAgdGhpcy5pbmJvdW5kTGF5ZXJzID0gY29uZmlnLmluYm91bmRMYXllcnM7XG4gICAgICAgIHRoaXMubm9kZUluZGljZXMgPSBjb25maWcubm9kZUluZGljZXM7XG4gICAgICAgIHRoaXMudGVuc29ySW5kaWNlcyA9IGNvbmZpZy50ZW5zb3JJbmRpY2VzO1xuICAgICAgICB0aGlzLmlucHV0VGVuc29ycyA9IGNvbmZpZy5pbnB1dFRlbnNvcnM7XG4gICAgICAgIHRoaXMub3V0cHV0VGVuc29ycyA9IGNvbmZpZy5vdXRwdXRUZW5zb3JzO1xuICAgICAgICB0aGlzLmlucHV0TWFza3MgPSBjb25maWcuaW5wdXRNYXNrcztcbiAgICAgICAgdGhpcy5vdXRwdXRNYXNrcyA9IGNvbmZpZy5vdXRwdXRNYXNrcztcbiAgICAgICAgdGhpcy5pbnB1dFNoYXBlcyA9IGNvbmZpZy5pbnB1dFNoYXBlcztcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZXMgPSBjb25maWcub3V0cHV0U2hhcGVzO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29uZmlnLmluYm91bmRMYXllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAobGF5ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxheWVyLm91dGJvdW5kTm9kZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25maWcub3V0Ym91bmRMYXllci5pbmJvdW5kTm9kZXMucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5ib3VuZE5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmluYm91bmRMYXllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAobGF5ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluYm91bmROYW1lcy5wdXNoKGxheWVyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5ib3VuZE5hbWVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG91dGJvdW5kTGF5ZXI6IHRoaXMub3V0Ym91bmRMYXllciA/IHRoaXMub3V0Ym91bmRMYXllci5uYW1lIDogbnVsbCxcbiAgICAgICAgICAgIGluYm91bmRMYXllcnM6IGluYm91bmROYW1lcyxcbiAgICAgICAgICAgIG5vZGVJbmRpY2VzOiB0aGlzLm5vZGVJbmRpY2VzLFxuICAgICAgICAgICAgdGVuc29ySW5kaWNlczogdGhpcy50ZW5zb3JJbmRpY2VzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xudmFyIF9uZXh0TGF5ZXJJRCA9IDA7XG52YXIgTGF5ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXllcihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NhbGxIb29rID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2FkZGVkV2VpZ2h0TmFtZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuX3N0YXRlZnVsID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlkID0gX25leHRMYXllcklEKys7XG4gICAgICAgIF90aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBudWxsO1xuICAgICAgICBfdGhpcy5zdXBwb3J0c01hc2tpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3RyYWluYWJsZVdlaWdodHMgPSBbXTtcbiAgICAgICAgX3RoaXMuX25vblRyYWluYWJsZVdlaWdodHMgPSBbXTtcbiAgICAgICAgX3RoaXMuX2xvc3NlcyA9IFtdO1xuICAgICAgICBfdGhpcy5fdXBkYXRlcyA9IFtdO1xuICAgICAgICBfdGhpcy5fYnVpbHQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaW5ib3VuZE5vZGVzID0gW107XG4gICAgICAgIF90aGlzLm91dGJvdW5kTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIG5hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gX3RoaXMuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgICAgICAgICBuYW1lID0gZ2VuZXJpY191dGlscy50b1NuYWtlQ2FzZShwcmVmaXgpICsgJ18nICsgSy5nZXRVaWQocHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudHJhaW5hYmxlID0gY29uZmlnLnRyYWluYWJsZSA9PSBudWxsID8gdHJ1ZSA6IGNvbmZpZy50cmFpbmFibGU7XG4gICAgICAgIF90aGlzLnVwZGF0YWJsZSA9IGNvbmZpZy51cGRhdGFibGUgPT0gbnVsbCA/IHRydWUgOiBjb25maWcudXBkYXRhYmxlO1xuICAgICAgICBpZiAoY29uZmlnLmlucHV0U2hhcGUgIT0gbnVsbCB8fCBjb25maWcuYmF0Y2hJbnB1dFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBiYXRjaElucHV0U2hhcGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmJhdGNoSW5wdXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hJbnB1dFNoYXBlID0gY29uZmlnLmJhdGNoSW5wdXRTaGFwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5pbnB1dFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmJhdGNoU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZSA9IGNvbmZpZy5iYXRjaFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhdGNoSW5wdXRTaGFwZSA9IFtiYXRjaFNpemVdLmNvbmNhdChjb25maWcuaW5wdXRTaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5iYXRjaElucHV0U2hhcGUgPSBiYXRjaElucHV0U2hhcGU7XG4gICAgICAgICAgICB2YXIgZHR5cGUgPSBjb25maWcuZHR5cGU7XG4gICAgICAgICAgICBpZiAoZHR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGR0eXBlID0gY29uZmlnLmlucHV0RFR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGR0eXBlID0gSy5mbG9hdHgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmR0eXBlID0gZHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy53ZWlnaHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLmluaXRpYWxXZWlnaHRzID0gY29uZmlnLndlaWdodHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5pbml0aWFsV2VpZ2h0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMYXllci5ub2RlS2V5ID0gZnVuY3Rpb24gKGxheWVyLCBub2RlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyLm5hbWUgKyAnX2liLScgKyBub2RlSW5kZXgudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5nZXROb2RlQXRJbmRleCA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIGF0dHJOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SdW50aW1lRXJyb3IoJ1RoZSBsYXllciBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQgJyArXG4gICAgICAgICAgICAgICAgKFwiYW5kIHRodXMgaGFzIG5vIGRlZmluZWQgXCIgKyBhdHRyTmFtZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCA8PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiQXNrZWQgdG8gZ2V0IFwiICsgYXR0ck5hbWUgKyBcIiBhdCBub2RlIFwiICsgbm9kZUluZGV4ICsgXCIsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgdGhlIGxheWVyIGhhcyBvbmx5IFwiICsgdGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoICsgXCIgaW5ib3VuZCBub2Rlcy5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluYm91bmROb2Rlc1tub2RlSW5kZXhdO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmdldElucHV0QXQgPSBmdW5jdGlvbiAobm9kZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleChub2RlSW5kZXgsICdpbnB1dCcpLmlucHV0VGVuc29ycyk7XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuZ2V0T3V0cHV0QXQgPSBmdW5jdGlvbiAobm9kZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleChub2RlSW5kZXgsICdvdXRwdXQnKS5vdXRwdXRUZW5zb3JzKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXllci5wcm90b3R5cGUsIFwiaW5wdXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnIGhhcyBtdWx0aXBsZSBpbmJvdW5kIG5vZGVzLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2hlbmNlIHRoZSBub3Rpb24gb2YgXCJsYXllciBpbnB1dFwiICcgK1xuICAgICAgICAgICAgICAgICAgICAnaXMgaWxsLWRlZmluZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGBnZXRJbnB1dEF0KG5vZGVJbmRleClgIGluc3RlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIiArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcgaXMgbm90IGNvbm5lY3RlZCwgbm8gaW5wdXQgdG8gcmV0dXJuLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KDAsICdpbnB1dCcpLmlucHV0VGVuc29ycyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXllci5wcm90b3R5cGUsIFwib3V0cHV0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnIGhhcyBubyBpbmJvdW5kIG5vZGVzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIiArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMsICcgK1xuICAgICAgICAgICAgICAgICAgICAnaGVuY2UgdGhlIG5vdGlvbiBvZiBcImxheWVyIG91dHB1dFwiICcgK1xuICAgICAgICAgICAgICAgICAgICAnaXMgaWxsLWRlZmluZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGBnZXRPdXRwdXRBdChub2RlSW5kZXgpYCBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KDAsICdvdXRwdXQnKS5vdXRwdXRUZW5zb3JzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheWVyLnByb3RvdHlwZSwgXCJsb3NzZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb3NzZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExheWVyLnByb3RvdHlwZS5jYWxjdWxhdGVMb3NzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvc3Nlcy5tYXAoZnVuY3Rpb24gKGxvc3NGbikgeyByZXR1cm4gbG9zc0ZuKCk7IH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheWVyLnByb3RvdHlwZSwgXCJ1cGRhdGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheWVyLnByb3RvdHlwZSwgXCJidWlsdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWx0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChidWlsdCkge1xuICAgICAgICAgICAgdGhpcy5fYnVpbHQgPSBidWlsdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheWVyLnByb3RvdHlwZSwgXCJ0cmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFpbmFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhaW5hYmxlV2VpZ2h0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAod2VpZ2h0cykge1xuICAgICAgICAgICAgdGhpcy5fdHJhaW5hYmxlV2VpZ2h0cyA9IHdlaWdodHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXllci5wcm90b3R5cGUsIFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XG4gICAgICAgICAgICB0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzID0gd2VpZ2h0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheWVyLnByb3RvdHlwZSwgXCJ3ZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5ZXIucHJvdG90eXBlLCBcInN0YXRlZnVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVmdWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExheWVyLnByb3RvdHlwZS5hc3NlcnRJbnB1dENvbXBhdGliaWxpdHkgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIGlucHV0cyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0cyk7XG4gICAgICAgIGlmICh0aGlzLmlucHV0U3BlYyA9PSBudWxsIHx8IHRoaXMuaW5wdXRTcGVjLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dFNwZWMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdCh0aGlzLmlucHV0U3BlYyk7XG4gICAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSBpbnB1dFNwZWMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkxheWVyIFwiICsgdGhpcy5uYW1lICsgXCIgZXhwZWN0cyBcIiArIGlucHV0U3BlYy5sZW5ndGggKyBcIiBpbnB1dHMsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgaXQgcmVjZWl2ZWQgXCIgKyBpbnB1dHMubGVuZ3RoICsgXCIgaW5wdXQgdGVuc29ycy4gXCIpICtcbiAgICAgICAgICAgICAgICAoXCJJbnB1dCByZWNlaXZlZDogXCIgKyBpbnB1dHMpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbnB1dEluZGV4ID0gMDsgaW5wdXRJbmRleCA8IGlucHV0cy5sZW5ndGg7IGlucHV0SW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHggPSBpbnB1dHNbaW5wdXRJbmRleF07XG4gICAgICAgICAgICB2YXIgc3BlYyA9IGlucHV0U3BlY1tpbnB1dEluZGV4XTtcbiAgICAgICAgICAgIGlmIChzcGVjID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZGltID0geC5yYW5rO1xuICAgICAgICAgICAgaWYgKHNwZWMubmRpbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5kaW0gIT09IHNwZWMubmRpbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklucHV0IFwiICsgaW5wdXRJbmRleCArIFwiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiICsgdGhpcy5uYW1lICsgXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImV4cGVjdGVkIG5kaW09XCIgKyBzcGVjLm5kaW0gKyBcIiwgZm91bmQgbmRpbT1cIiArIG5kaW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlYy5tYXhORGltICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobmRpbSA+IHNwZWMubWF4TkRpbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklucHV0IFwiICsgaW5wdXRJbmRleCArIFwiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIjogZXhwZWN0ZWQgbWF4X25kaW09XCIgKyBzcGVjLm1heE5EaW0gKyBcIiwgZm91bmQgbmRpbT1cIiArIG5kaW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlYy5taW5ORGltICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobmRpbSA8IHNwZWMubWluTkRpbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklucHV0IFwiICsgaW5wdXRJbmRleCArIFwiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIjogZXhwZWN0ZWQgbWluX25kaW09XCIgKyBzcGVjLm1pbk5EaW0gKyBcIiwgZm91bmQgbmRpbT1cIiArIG5kaW0gKyBcIi5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGVjLmR0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoSy5kdHlwZSh4KSAhPT0gc3BlYy5kdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeERUeXBlID0gSy5kdHlwZSh4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbnB1dCBcIiArIGlucHV0SW5kZXggKyBcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIiArIHRoaXMubmFtZSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIjogZXhwZWN0ZWQgZHR5cGU9XCIgKyBzcGVjLmR0eXBlICsgXCIsIGZvdW5kIGR0eXBlPVwiICsgeERUeXBlICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlYy5heGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhTaGFwZSA9IEsuaW50U2hhcGUoeCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNwZWMuYXhlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IE51bWJlcihrZXkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzcGVjLmF4ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhTaGFwZUF0QXhpcyA9IGF4aXMgPj0gMCA/IHhTaGFwZVtheGlzXSA6IHhTaGFwZVt4U2hhcGUubGVuZ3RoICsgYXhpc107XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIFt2YWx1ZSwgbnVsbF0uaW5kZXhPZih4U2hhcGVBdEF4aXMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbnB1dCBcIiArIGlucHV0SW5kZXggKyBcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubmFtZSArIFwiOiBleHBlY3RlZCBheGlzIFwiICsgYXhpcyArIFwiIG9mIGlucHV0IHNoYXBlIHRvIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiaGF2ZSB2YWx1ZSBcIiArIHZhbHVlICsgXCIgYnV0IGdvdCBzaGFwZSBcIiArIHhTaGFwZSArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlYy5zaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhTaGFwZSA9IEsuaW50U2hhcGUoeCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjLnNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGVjRGltID0gc3BlYy5zaGFwZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IHhTaGFwZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNEaW0gIT0gbnVsbCAmJiBkaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNEaW0gIT09IGRpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW5wdXQgXCIgKyBpbnB1dEluZGV4ICsgXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5uYW1lICsgXCI6IGV4cGVjdGVkIHNoYXBlPVwiICsgc3BlYy5zaGFwZSArIFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm91bmQgc2hhcGU9JHt4U2hhcGV9LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmludm9rZUNhbGxIb29rID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsSG9vayAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5zZXRDYWxsSG9vayA9IGZ1bmN0aW9uIChjYWxsSG9vaykge1xuICAgICAgICB0aGlzLl9jYWxsSG9vayA9IGNhbGxIb29rO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmNsZWFyQ2FsbEhvb2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxIb29rID0gbnVsbDtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBrd2FyZ3MgPSBrd2FyZ3MgfHwge307XG4gICAgICAgIHZhciBpbnB1dHNMaXN0ID0gZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRzKTtcbiAgICAgICAgdmFyIGFsbEFyZVN5bWJvbGljID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dHNMaXN0XzEgPSBpbnB1dHNMaXN0OyBfaSA8IGlucHV0c0xpc3RfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c0xpc3RfMVtfaV07XG4gICAgICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIHR5cGVzXzEuU3ltYm9saWNUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgYWxsQXJlU3ltYm9saWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9uZUFyZVN5bWJvbGljID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBpbnB1dHNMaXN0XzIgPSBpbnB1dHNMaXN0OyBfYSA8IGlucHV0c0xpc3RfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c0xpc3RfMltfYV07XG4gICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiB0eXBlc18xLlN5bWJvbGljVGVuc29yKSB7XG4gICAgICAgICAgICAgICAgbm9uZUFyZVN5bWJvbGljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbEFyZVN5bWJvbGljID09PSBub25lQXJlU3ltYm9saWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdBcmd1bWVudHMgdG8gYXBwbHkoKSBtdXN0IGJlIGFsbCAnICtcbiAgICAgICAgICAgICAgICAnU3ltYm9saWNUZW5zb3JzIG9yIGFsbCBUZW5zb3JzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEsubmFtZVNjb3BlKHRoaXMubmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5idWlsdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eShpbnB1dHMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFNoYXBlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeEVsZW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlucHV0U2hhcGVzLnB1c2goSy5pbnRTaGFwZSh4RWxlbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5idWlsZChnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkoaW5wdXRTaGFwZXMpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5idWlsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmluaXRpYWxXZWlnaHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFdlaWdodHMoX3RoaXMuaW5pdGlhbFdlaWdodHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eShpbnB1dHMpO1xuICAgICAgICAgICAgaWYgKG5vbmVBcmVTeW1ib2xpYykge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBfdGhpcy5jYWxsKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0TGlzdCA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dExpc3RDb3B5ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBvdXRwdXRMaXN0XzEgPSBvdXRwdXRMaXN0OyBfYiA8IG91dHB1dExpc3RfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBvdXRwdXRMaXN0XzFbX2JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzTGlzdC5pbmRleE9mKHgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IEsuaWRlbnRpdHkoeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0TGlzdENvcHkucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KG91dHB1dExpc3RDb3B5KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWN0aXZpdHlSZWd1bGFyaXplciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFNoYXBlID0gY29sbGVjdElucHV0U2hhcGUoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBfdGhpcy5jb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0RFR5cGVfMSA9IGd1ZXNzT3V0cHV0RFR5cGUoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0U2hhcGUgIT0gbnVsbCAmJiBvdXRwdXRTaGFwZS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob3V0cHV0U2hhcGVbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dFNoYXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzaGFwZSwgaW5kZXgpIHsgcmV0dXJuIG5ldyB0eXBlc18xLlN5bWJvbGljVGVuc29yKG91dHB1dERUeXBlXzEsIHNoYXBlLCBfdGhpcywgZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRzKSwga3dhcmdzLCBfdGhpcy5uYW1lLCBpbmRleCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbmV3IHR5cGVzXzEuU3ltYm9saWNUZW5zb3Iob3V0cHV0RFR5cGVfMSwgb3V0cHV0U2hhcGUsIF90aGlzLCBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpLCBrd2FyZ3MsIF90aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRJbmJvdW5kTm9kZShpbnB1dHMsIG91dHB1dCwgbnVsbCwgbnVsbCwgaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignTGF5ZXIgaW52b2NhdGlvbiBpbiB0aGUgcHJlc2VuY2Ugb2YgYWN0aXZpdHkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuZ2V0V2VpZ2h0cyA9IGZ1bmN0aW9uICh0cmFpbmFibGVPbmx5KSB7XG4gICAgICAgIGlmICh0cmFpbmFibGVPbmx5ID09PSB2b2lkIDApIHsgdHJhaW5hYmxlT25seSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZXNfMS5iYXRjaEdldFZhbHVlKHRyYWluYWJsZU9ubHkgPyB0aGlzLnRyYWluYWJsZVdlaWdodHMgOiB0aGlzLndlaWdodHMpO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLnNldFdlaWdodHMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBfdGhpcy53ZWlnaHRzO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IHdlaWdodHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJZb3UgY2FsbGVkIHNldFdlaWdodHMod2VpZ2h0cykgb24gbGF5ZXIgXFxcIlwiICsgX3RoaXMubmFtZSArIFwiXFxcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIndpdGggYSB3ZWlnaHQgbGlzdCBvZiBsZW5ndGggXCIgKyB3ZWlnaHRzLmxlbmd0aCArIFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoXCJidXQgdGhlIGxheWVyIHdhcyBleHBlY3RpbmcgXCIgKyBwYXJhbXMubGVuZ3RoICsgXCIgd2VpZ2h0cy4gXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwiUHJvdmlkZWQgd2VpZ2h0czogXCIgKyB3ZWlnaHRzICsgXCIuLi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd2VpZ2h0VmFsdWVUdXBsZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBwYXJhbVZhbHVlcyA9IHZhcmlhYmxlc18xLmJhdGNoR2V0VmFsdWUocGFyYW1zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1WYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHYgPSBwYXJhbVZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhcmFtc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IHdlaWdodHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0ZmpzX2NvcmVfMS51dGlsLmFycmF5c0VxdWFsKHB2LnNoYXBlLCB3LnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkxheWVyIHdlaWdodCBzaGFwZSBcIiArIHB2LnNoYXBlICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwibm90IGNvbXBhdGlibGUgd2l0aCBwcm92aWRlZCB3ZWlnaHQgc2hhcGUgXCIgKyB3LnNoYXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdlaWdodFZhbHVlVHVwbGVzLnB1c2goW3AsIHddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcmlhYmxlc18xLmJhdGNoU2V0VmFsdWUod2VpZ2h0VmFsdWVUdXBsZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5hZGRXZWlnaHQgPSBmdW5jdGlvbiAobmFtZSwgc2hhcGUsIGR0eXBlLCBpbml0aWFsaXplciwgcmVndWxhcml6ZXIsIHRyYWluYWJsZSwgY29uc3RyYWludCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkZWRXZWlnaHROYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJEdXBsaWNhdGUgd2VpZ2h0IG5hbWUgXCIgKyBuYW1lICsgXCIgZm9yIGxheWVyIFwiICsgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRlZFdlaWdodE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIGlmIChkdHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkdHlwZSA9IEsuZmxvYXR4KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlaWdodCA9IG5ldyB2YXJpYWJsZXNfMS5MYXllclZhcmlhYmxlKGluaXRpYWxpemVyLmFwcGx5KHNoYXBlLCBkdHlwZSksIGR0eXBlLCBuYW1lLCB0cmFpbmFibGUsIGNvbnN0cmFpbnQpO1xuICAgICAgICBpZiAocmVndWxhcml6ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hZGRMb3NzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ3VsYXJpemVyLmFwcGx5KHdlaWdodC5yZWFkKCkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhaW5hYmxlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWluYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWluYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5wdXNoKHdlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzLnB1c2god2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2VpZ2h0O1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmFkZExvc3MgPSBmdW5jdGlvbiAobG9zc2VzKSB7XG4gICAgICAgIGlmIChsb3NzZXMgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGxvc3NlcykgJiYgbG9zc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvc3NlcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGxvc3Nlcyk7XG4gICAgICAgIGlmICh0aGlzLl9sb3NzZXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sb3NzZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMubG9zc2VzKS5wdXNoLmFwcGx5KF9hLCBsb3NzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXRTaGFwZTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5jb21wdXRlTWFzayA9IGZ1bmN0aW9uIChpbnB1dHMsIG1hc2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzTWFza2luZykge1xuICAgICAgICAgICAgaWYgKG1hc2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hc2spKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2suZm9yRWFjaChmdW5jdGlvbiAobWFza0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxheWVyIFwiICsgX3RoaXMubmFtZSArIFwiIGRvZXMgbm90IHN1cHBvcnQgbWFza2luZyxcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdidXQgd2FzIHBhc3NlZCBhbiBpbnB1dE1hc2suJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxheWVyIFwiICsgdGhpcy5uYW1lICsgXCIgZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nLFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXQgd2FzIHBhc3NlZCBhbiBpbnB1dE1hc2suJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hc2s7XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuYWRkSW5ib3VuZE5vZGUgPSBmdW5jdGlvbiAoaW5wdXRUZW5zb3JzLCBvdXRwdXRUZW5zb3JzLCBpbnB1dE1hc2tzLCBvdXRwdXRNYXNrcywgaW5wdXRTaGFwZXMsIG91dHB1dFNoYXBlcywga3dhcmdzKSB7XG4gICAgICAgIGlmIChrd2FyZ3MgPT09IHZvaWQgMCkgeyBrd2FyZ3MgPSBudWxsOyB9XG4gICAgICAgIHZhciBpbnB1dFRlbnNvckxpc3QgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dFRlbnNvcnMpO1xuICAgICAgICBvdXRwdXRUZW5zb3JzID0gZ2VuZXJpY191dGlscy50b0xpc3Qob3V0cHV0VGVuc29ycyk7XG4gICAgICAgIGlucHV0TWFza3MgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dE1hc2tzKTtcbiAgICAgICAgb3V0cHV0TWFza3MgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChvdXRwdXRNYXNrcyk7XG4gICAgICAgIGlucHV0U2hhcGVzID0gZ2VuZXJpY191dGlscy5ub3JtYWxpemVTaGFwZUxpc3QoaW5wdXRTaGFwZXMpO1xuICAgICAgICBvdXRwdXRTaGFwZXMgPSBnZW5lcmljX3V0aWxzLm5vcm1hbGl6ZVNoYXBlTGlzdChvdXRwdXRTaGFwZXMpO1xuICAgICAgICB2YXIgaW5ib3VuZExheWVycyA9IFtdO1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHRlbnNvckluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dFRlbnNvckxpc3RfMSA9IGlucHV0VGVuc29yTGlzdDsgX2kgPCBpbnB1dFRlbnNvckxpc3RfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gaW5wdXRUZW5zb3JMaXN0XzFbX2ldO1xuICAgICAgICAgICAgaW5ib3VuZExheWVycy5wdXNoKHguc291cmNlTGF5ZXIpO1xuICAgICAgICAgICAgbm9kZUluZGljZXMucHVzaCh4Lm5vZGVJbmRleCk7XG4gICAgICAgICAgICB0ZW5zb3JJbmRpY2VzLnB1c2goeC50ZW5zb3JJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IE5vZGUoe1xuICAgICAgICAgICAgb3V0Ym91bmRMYXllcjogdGhpcyxcbiAgICAgICAgICAgIGluYm91bmRMYXllcnM6IGluYm91bmRMYXllcnMsXG4gICAgICAgICAgICBub2RlSW5kaWNlczogbm9kZUluZGljZXMsXG4gICAgICAgICAgICB0ZW5zb3JJbmRpY2VzOiB0ZW5zb3JJbmRpY2VzLFxuICAgICAgICAgICAgaW5wdXRUZW5zb3JzOiBpbnB1dFRlbnNvckxpc3QsXG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzOiBvdXRwdXRUZW5zb3JzLFxuICAgICAgICAgICAgaW5wdXRNYXNrczogaW5wdXRNYXNrcyxcbiAgICAgICAgICAgIG91dHB1dE1hc2tzOiBvdXRwdXRNYXNrcyxcbiAgICAgICAgICAgIGlucHV0U2hhcGVzOiBpbnB1dFNoYXBlcyxcbiAgICAgICAgICAgIG91dHB1dFNoYXBlczogb3V0cHV0U2hhcGVzXG4gICAgICAgIH0sIGt3YXJncyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0VGVuc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0VGVuc29yc1tpXS5zb3VyY2VMYXllciA9IHRoaXM7XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLm5vZGVJbmRleCA9IHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLnRlbnNvckluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgbmFtZTogdGhpcy5uYW1lLCB0cmFpbmFibGU6IHRoaXMudHJhaW5hYmxlIH07XG4gICAgICAgIGlmICh0aGlzLmJhdGNoSW5wdXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWdbJ2JhdGNoSW5wdXRTaGFwZSddID0gdGhpcy5iYXRjaElucHV0U2hhcGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnWydkdHlwZSddID0gdGhpcy5kdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCAnc3ViaGVhZGluZyc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIExheWVyLnByb3RvdHlwZSwgXCJhcHBseVwiLCBudWxsKTtcbiAgICBMYXllciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTGF5ZXJzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnLCBuYW1lc3BhY2U6ICdsYXllcnMnIH0pXG4gICAgXSwgTGF5ZXIpO1xuICAgIHJldHVybiBMYXllcjtcbn0odGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpKTtcbmV4cG9ydHMuTGF5ZXIgPSBMYXllcjtcbmZ1bmN0aW9uIGNvbGxlY3RJbnB1dFNoYXBlKGlucHV0VGVuc29ycykge1xuICAgIGlucHV0VGVuc29ycyA9XG4gICAgICAgIGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0VGVuc29ycyk7XG4gICAgdmFyIHNoYXBlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRUZW5zb3JzXzEgPSBpbnB1dFRlbnNvcnM7IF9pIDwgaW5wdXRUZW5zb3JzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB4ID0gaW5wdXRUZW5zb3JzXzFbX2ldO1xuICAgICAgICBzaGFwZXMucHVzaChLLmludFNoYXBlKHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShzaGFwZXMpO1xufVxuZnVuY3Rpb24gZ3Vlc3NPdXRwdXREVHlwZShpbnB1dFRlbnNvcnMpIHtcbiAgICByZXR1cm4gJ2Zsb2F0MzInO1xufVxudmFyIElucHV0TGF5ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnB1dExheWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElucHV0TGF5ZXIoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGR0eXBlOiBjb25maWcuZHR5cGUsXG4gICAgICAgICAgICBuYW1lOiBjb25maWcubmFtZSAhPSBudWxsID8gY29uZmlnLm5hbWUgOiBLLmdldFVpZCgnaW5wdXQnKS50b1N0cmluZygpXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIGlmIChjb25maWcuYmF0Y2hTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5iYXRjaFNpemUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuc3BhcnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zcGFyc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy50cmFpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuYnVpbHQgPSB0cnVlO1xuICAgICAgICBfdGhpcy5zcGFyc2UgPSBjb25maWcuc3BhcnNlO1xuICAgICAgICBpZiAoY29uZmlnLmlucHV0U2hhcGUgIT0gbnVsbCAmJiBjb25maWcuYmF0Y2hJbnB1dFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdPbmx5IHByb3ZpZGUgdGhlIGlucHV0U2hhcGUgT1IgJyArXG4gICAgICAgICAgICAgICAgJ2JhdGNoSW5wdXRTaGFwZSBhcmd1bWVudCB0byBpbnB1dExheWVyLCBub3QgYm90aCBhdCB0aGUgc2FtZSB0aW1lLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXRjaElucHV0U2hhcGUgPSBjb25maWcuYmF0Y2hJbnB1dFNoYXBlO1xuICAgICAgICBpZiAoYmF0Y2hJbnB1dFNoYXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuaW5wdXRTaGFwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0FuIElucHV0TGF5ZXIgc2hvdWxkIGJlIHBhc3NlZCBlaXRoZXIgYSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BiYXRjaElucHV0U2hhcGVgIG9yIGFuIGBpbnB1dFNoYXBlYC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhdGNoSW5wdXRTaGFwZSA9IFtjb25maWcuYmF0Y2hTaXplXS5jb25jYXQoY29uZmlnLmlucHV0U2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5iYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdDYW5ub3Qgc3BlY2lmeSBiYXRjaFNpemUgaWYgYmF0Y2hJbnB1dFNoYXBlIGlzJyArXG4gICAgICAgICAgICAgICAgICAgICdzcGVjaWZpZWQgd2hlbiBjcmVhdGluZyBhbiBJbnB1dExheWVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZSA9IGNvbmZpZy5kdHlwZSB8fCBLLmZsb2F0eCgpO1xuICAgICAgICBfdGhpcy5iYXRjaElucHV0U2hhcGUgPSBiYXRjaElucHV0U2hhcGU7XG4gICAgICAgIF90aGlzLmR0eXBlID0gZHR5cGU7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFt7IHNoYXBlOiBiYXRjaElucHV0U2hhcGUgfV07XG4gICAgICAgIHZhciBpbnB1dFRlbnNvciA9IG5ldyB0eXBlc18xLlN5bWJvbGljVGVuc29yKF90aGlzLmR0eXBlLCBfdGhpcy5iYXRjaElucHV0U2hhcGUsIF90aGlzLCBbXSwge30sIF90aGlzLm5hbWUpO1xuICAgICAgICBpbnB1dFRlbnNvci5ub2RlSW5kZXggPSAwO1xuICAgICAgICBpbnB1dFRlbnNvci50ZW5zb3JJbmRleCA9IDA7XG4gICAgICAgIG5ldyBOb2RlKHtcbiAgICAgICAgICAgIG91dGJvdW5kTGF5ZXI6IF90aGlzLFxuICAgICAgICAgICAgaW5ib3VuZExheWVyczogW10sXG4gICAgICAgICAgICBub2RlSW5kaWNlczogW10sXG4gICAgICAgICAgICB0ZW5zb3JJbmRpY2VzOiBbXSxcbiAgICAgICAgICAgIGlucHV0VGVuc29yczogW2lucHV0VGVuc29yXSxcbiAgICAgICAgICAgIG91dHB1dFRlbnNvcnM6IFtpbnB1dFRlbnNvcl0sXG4gICAgICAgICAgICBpbnB1dE1hc2tzOiBbbnVsbF0sXG4gICAgICAgICAgICBvdXRwdXRNYXNrczogW251bGxdLFxuICAgICAgICAgICAgaW5wdXRTaGFwZXM6IFtiYXRjaElucHV0U2hhcGVdLFxuICAgICAgICAgICAgb3V0cHV0U2hhcGVzOiBbYmF0Y2hJbnB1dFNoYXBlXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnB1dExheWVyLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQ2Fubm90IHBhc3MgYW55IGlucHV0IHRvIGFuICcgK1xuICAgICAgICAgICAgKFwiSW5wdXRMYXllcidzIGFwcGx5KCkgbWV0aG9kLiBJbnB1dExheWVyIG5hbWU6IFwiICsgdGhpcy5uYW1lKSk7XG4gICAgfTtcbiAgICBJbnB1dExheWVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXRjaElucHV0U2hhcGU6IHRoaXMuYmF0Y2hJbnB1dFNoYXBlLFxuICAgICAgICAgICAgZHR5cGU6IHRoaXMuZHR5cGUsXG4gICAgICAgICAgICBzcGFyc2U6IHRoaXMuc3BhcnNlLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBJbnB1dExheWVyLmNsYXNzTmFtZSA9ICdJbnB1dExheWVyJztcbiAgICByZXR1cm4gSW5wdXRMYXllcjtcbn0oTGF5ZXIpKTtcbmV4cG9ydHMuSW5wdXRMYXllciA9IElucHV0TGF5ZXI7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoSW5wdXRMYXllcik7XG5mdW5jdGlvbiBJbnB1dChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLmJhdGNoU2hhcGUgPT0gbnVsbCAmJiBjb25maWcuc2hhcGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIHRvIElucHV0IGVpdGhlciBhIGBzaGFwZWAnICtcbiAgICAgICAgICAgICcgb3IgYSBgYmF0Y2hTaGFwZWAgYXJndW1lbnQuIE5vdGUgdGhhdCAnICtcbiAgICAgICAgICAgICdgc2hhcGVgIGRvZXMgbm90IGluY2x1ZGUgdGhlIGJhdGNoICcgK1xuICAgICAgICAgICAgJ2RpbWVuc2lvbi4nKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5iYXRjaFNoYXBlICE9IG51bGwgJiYgY29uZmlnLnNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBzaGFwZWAgb3IgYGJhdGNoU2hhcGVgICcgK1xuICAgICAgICAgICAgJ2FyZ3VtZW50IHRvIElucHV0LCBidXQgbm90IGJvdGguJyk7XG4gICAgfVxuICAgIHZhciBiYXRjaFNoYXBlID0gY29uZmlnLmJhdGNoU2hhcGU7XG4gICAgaWYgKGNvbmZpZy5zaGFwZSAhPSBudWxsICYmIGJhdGNoU2hhcGUgPT0gbnVsbCkge1xuICAgICAgICBiYXRjaFNoYXBlID0gW251bGxdLmNvbmNhdChjb25maWcuc2hhcGUpO1xuICAgIH1cbiAgICB2YXIgZHR5cGUgPSBjb25maWcuZHR5cGU7XG4gICAgaWYgKGR0eXBlID09IG51bGwpIHtcbiAgICAgICAgZHR5cGUgPSBLLmZsb2F0eCgpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRMYXllciA9IG5ldyBJbnB1dExheWVyKHtcbiAgICAgICAgYmF0Y2hJbnB1dFNoYXBlOiBiYXRjaFNoYXBlLFxuICAgICAgICBuYW1lOiBjb25maWcubmFtZSxcbiAgICAgICAgZHR5cGU6IGR0eXBlLFxuICAgICAgICBzcGFyc2U6IGNvbmZpZy5zcGFyc2VcbiAgICB9KTtcbiAgICB2YXIgb3V0cHV0cyA9IGlucHV0TGF5ZXIuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnM7XG4gICAgcmV0dXJuIG91dHB1dHNbMF07XG59XG5leHBvcnRzLklucHV0ID0gSW5wdXQ7XG52YXIgQ29udGFpbmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udGFpbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lcihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge30pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lck5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgICBfdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgICAgIGlmIChfdGhpcy5uYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBfdGhpcy5nZXRDbGFzc05hbWUoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IEsuZ2V0VWlkKHByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3VwcG9ydHNNYXNraW5nID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnRyYWluYWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzLnVwZGF0YWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5pbnB1dHMpKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnB1dHMgPSBjb25maWcuaW5wdXRzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5pbnB1dHMgPSBbY29uZmlnLmlucHV0c107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLm91dHB1dHMpKSB7XG4gICAgICAgICAgICBfdGhpcy5vdXRwdXRzID0gY29uZmlnLm91dHB1dHMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm91dHB1dHMgPSBbY29uZmlnLm91dHB1dHNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmljX3V0aWxzLnVuaXF1ZShfdGhpcy5pbnB1dHMpLmxlbmd0aCAhPT0gX3RoaXMuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1RoZSBsaXN0IG9mIGlucHV0cyBwYXNzZWQgdG8gdGhlIG1vZGVsIGlzICcgK1xuICAgICAgICAgICAgICAgICdyZWR1bmRhbnQuIEFsbCBpbnB1dHMgc2hvdWxkIG9ubHkgYXBwZWFyIG9uY2UuIEZvdW5kOiAnICtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWU7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VuZXJpY191dGlscy51bmlxdWUoX3RoaXMub3V0cHV0cykubGVuZ3RoICE9PSBfdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgbGlzdCBvZiBvdXRwdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgcmVkdW5kYW50LiAnICtcbiAgICAgICAgICAgICAgICAnQWxsIG91dHB1dHMgc2hvdWxkIG9ubHkgYXBwZWFyIG9uY2UuIEZvdW5kOiAnICtcbiAgICAgICAgICAgICAgICBfdGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuaW5wdXRMYXllcnMgPSBbXTtcbiAgICAgICAgX3RoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcyA9IFtdO1xuICAgICAgICBfdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXMgPSBbXTtcbiAgICAgICAgX3RoaXMub3V0cHV0TGF5ZXJzID0gW107XG4gICAgICAgIF90aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzID0gW107XG4gICAgICAgIF90aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXMgPSBbXTtcbiAgICAgICAgX3RoaXMubGF5ZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5vdXRwdXRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHggPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB4LnNvdXJjZUxheWVyO1xuICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHgubm9kZUluZGV4O1xuICAgICAgICAgICAgdmFyIHRlbnNvckluZGV4ID0geC50ZW5zb3JJbmRleDtcbiAgICAgICAgICAgIF90aGlzLm91dHB1dExheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgIF90aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzLnB1c2gobm9kZUluZGV4KTtcbiAgICAgICAgICAgIF90aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh0ZW5zb3JJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IF90aGlzLmlucHV0czsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gX2NbX2JdO1xuICAgICAgICAgICAgdmFyIGxheWVyID0geC5zb3VyY2VMYXllcjtcbiAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSB4Lm5vZGVJbmRleDtcbiAgICAgICAgICAgIHZhciB0ZW5zb3JJbmRleCA9IHgudGVuc29ySW5kZXg7XG4gICAgICAgICAgICBnZW5lcmljX3V0aWxzLmFzc2VydChub2RlSW5kZXggPT09IDAsICdpbnB1dCBsYXllciBoYXMgPjEgbm9kZXMnKTtcbiAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KHRlbnNvckluZGV4ID09PSAwLCAnaW5wdXQgbGF5ZXIgaGFzID4xIHRlbnNvcnMnKTtcbiAgICAgICAgICAgIF90aGlzLmlucHV0TGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgX3RoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcy5wdXNoKG5vZGVJbmRleCk7XG4gICAgICAgICAgICBfdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh0ZW5zb3JJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuaW5wdXROYW1lcyA9IFtdO1xuICAgICAgICBfdGhpcy5vdXRwdXROYW1lcyA9IFtdO1xuICAgICAgICBfdGhpcy5mZWVkSW5wdXRTaGFwZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuZmVlZElucHV0TmFtZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuZmVlZE91dHB1dE5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuaW5wdXRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF90aGlzLmlucHV0TGF5ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBJbnB1dExheWVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGxheWVycyB0byBhIE1vZGVsIG11c3QgYmUgSW5wdXRMYXllciBvYmplY3RzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgKFwiUmVjZWl2ZWQgaW5wdXRzOiBcIiArIGNvbmZpZy5pbnB1dHMgKyBcIi4gXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwiSW5wdXQgXCIgKyBpICsgXCIgKDAtYmFzZWQpIG9yaWdpbmF0ZXMgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwiZnJvbSBsYXllciB0eXBlIFwiICsgbGF5ZXIuZ2V0Q2xhc3NOYW1lKCkgKyBcIi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaW5wdXROYW1lcy5wdXNoKGxheWVyLm5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuZmVlZElucHV0U2hhcGVzLnB1c2gobGF5ZXIuYmF0Y2hJbnB1dFNoYXBlKTtcbiAgICAgICAgICAgIF90aGlzLmZlZWRJbnB1dE5hbWVzLnB1c2gobGF5ZXIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IF90aGlzLm91dHB1dExheWVyczsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9lW19kXTtcbiAgICAgICAgICAgIF90aGlzLm91dHB1dE5hbWVzLnB1c2gobGF5ZXIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuaW50ZXJuYWxJbnB1dFNoYXBlcyA9IF90aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGU7IH0pO1xuICAgICAgICBfdGhpcy5pbnRlcm5hbE91dHB1dFNoYXBlcyA9IF90aGlzLm91dHB1dHMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNoYXBlOyB9KTtcbiAgICAgICAgdmFyIG5vZGVzRGVwdGhzID0ge307XG4gICAgICAgIHZhciBub2RlSURUb05vZGUgPSB7fTtcbiAgICAgICAgdmFyIGxheWVyc0RlcHRocyA9IHt9O1xuICAgICAgICB2YXIgbGF5ZXJJRFRvTGF5ZXIgPSB7fTtcbiAgICAgICAgdmFyIGxheWVySW5kaWNlcyA9IHt9O1xuICAgICAgICB2YXIgbm9kZXNJbkRlY3JlYXNpbmdEZXB0aCA9IFtdO1xuICAgICAgICB2YXIgYnVpbGRNYXBPZkdyYXBoID0gZnVuY3Rpb24gKHRlbnNvciwgZmluaXNoZWROb2Rlcywgbm9kZXNJblByb2dyZXNzLCBsYXllciwgbm9kZUluZGV4LCB0ZW5zb3JJbmRleCkge1xuICAgICAgICAgICAgaWYgKGxheWVyID09IG51bGwgfHwgbm9kZUluZGV4ID09IG51bGwgfHwgdGVuc29ySW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGVuc29yLnNvdXJjZUxheWVyO1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IHRlbnNvci5ub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgdGVuc29ySW5kZXggPSB0ZW5zb3IudGVuc29ySW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGxheWVyLmluYm91bmROb2Rlc1tub2RlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5vZGVzSW5Qcm9ncmVzcy5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SdW50aW1lRXJyb3IoXCJUaGUgdGVuc29yIFwiICsgdGVuc29yLm5hbWUgKyBcIiBhdCBsYXllciBcXFwiXCIgKyBsYXllci5uYW1lICsgXCJcXFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgJ2lzIHBhcnQgb2YgYSBjeWNsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZE5vZGVzLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyTm9kZXMuYWRkKENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBub2RlSW5kZXgpKTtcbiAgICAgICAgICAgIGlmICghKGxheWVyLmlkIGluIGxheWVySW5kaWNlcykpIHtcbiAgICAgICAgICAgICAgICBsYXllckluZGljZXNbbGF5ZXIuaWRdID0gT2JqZWN0LmtleXMobGF5ZXJJbmRpY2VzKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZXNJblByb2dyZXNzLmluZGV4T2Yobm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNJblByb2dyZXNzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtSW5ib3VuZExheWVycyA9IG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUluYm91bmRMYXllcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dFRlbnNvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyXzEgPSBub2RlLmluYm91bmRMYXllcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleF8xID0gbm9kZS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdGVuc29ySW5kZXhfMSA9IG5vZGUudGVuc29ySW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICBidWlsZE1hcE9mR3JhcGgoeCwgZmluaXNoZWROb2Rlcywgbm9kZXNJblByb2dyZXNzLCBsYXllcl8xLCBub2RlSW5kZXhfMSwgdGVuc29ySW5kZXhfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5pc2hlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZXNJblByb2dyZXNzLmluZGV4T2Yobm9kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGVzSW5Qcm9ncmVzcy5zcGxpY2Uobm9kZXNJblByb2dyZXNzLmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXNJbkRlY3JlYXNpbmdEZXB0aC5wdXNoKG5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZmluaXNoZWROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgbm9kZXNJblByb2dyZXNzID0gW107XG4gICAgICAgIGZvciAodmFyIF9mID0gMCwgX2cgPSBfdGhpcy5vdXRwdXRzOyBfZiA8IF9nLmxlbmd0aDsgX2YrKykge1xuICAgICAgICAgICAgdmFyIHggPSBfZ1tfZl07XG4gICAgICAgICAgICBidWlsZE1hcE9mR3JhcGgoeCwgZmluaXNoZWROb2Rlcywgbm9kZXNJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV2ZXJzZWROb2Rlc0luRGVjcmVhc2luZ0RlcHRoID0gbm9kZXNJbkRlY3JlYXNpbmdEZXB0aC5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgZm9yICh2YXIgX2ggPSAwLCByZXZlcnNlZE5vZGVzSW5EZWNyZWFzaW5nRGVwdGhfMSA9IHJldmVyc2VkTm9kZXNJbkRlY3JlYXNpbmdEZXB0aDsgX2ggPCByZXZlcnNlZE5vZGVzSW5EZWNyZWFzaW5nRGVwdGhfMS5sZW5ndGg7IF9oKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gcmV2ZXJzZWROb2Rlc0luRGVjcmVhc2luZ0RlcHRoXzFbX2hdO1xuICAgICAgICAgICAgbm9kZUlEVG9Ob2RlW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgICAgIGlmICghKG5vZGUuaWQgaW4gbm9kZXNEZXB0aHMpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNEZXB0aHNbbm9kZS5pZF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlcHRoID0gbm9kZXNEZXB0aHNbbm9kZS5pZF07XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEZXB0aCA9IChsYXllcnNEZXB0aHNbbm9kZS5vdXRib3VuZExheWVyLmlkXSA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgICBsYXllcnNEZXB0aHNbbm9kZS5vdXRib3VuZExheWVyLmlkXSk7XG4gICAgICAgICAgICBkZXB0aCA9IE1hdGgubWF4KGRlcHRoLCBwcmV2aW91c0RlcHRoKTtcbiAgICAgICAgICAgIGxheWVyc0RlcHRoc1tub2RlLm91dGJvdW5kTGF5ZXIuaWRdID0gZGVwdGg7XG4gICAgICAgICAgICBsYXllcklEVG9MYXllcltub2RlLm91dGJvdW5kTGF5ZXIuaWRdID0gbm9kZS5vdXRib3VuZExheWVyO1xuICAgICAgICAgICAgbm9kZXNEZXB0aHNbbm9kZS5pZF0gPSBkZXB0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluYm91bmRMYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gbm9kZS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5ib3VuZE5vZGUgPSBpbmJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzRGVwdGhfMSA9IChub2Rlc0RlcHRoc1tpbmJvdW5kTm9kZS5pZF0gPT0gbnVsbCA/IDAgOlxuICAgICAgICAgICAgICAgICAgICBub2Rlc0RlcHRoc1tpbmJvdW5kTm9kZS5pZF0pO1xuICAgICAgICAgICAgICAgIG5vZGVzRGVwdGhzW2luYm91bmROb2RlLmlkXSA9IE1hdGgubWF4KGRlcHRoICsgMSwgcHJldmlvdXNEZXB0aF8xKTtcbiAgICAgICAgICAgICAgICBub2RlSURUb05vZGVbaW5ib3VuZE5vZGUuaWRdID0gaW5ib3VuZE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGVzQnlEZXB0aCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBub2RlSUQgaW4gbm9kZXNEZXB0aHMpIHtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IG5vZGVzRGVwdGhzW25vZGVJRF07XG4gICAgICAgICAgICBpZiAoIShkZXB0aCBpbiBub2Rlc0J5RGVwdGgpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNCeURlcHRoW2RlcHRoXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXNCeURlcHRoW2RlcHRoXS5wdXNoKG5vZGVJRFRvTm9kZVtub2RlSURdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5ZXJzQnlEZXB0aCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBsYXllcklEIGluIGxheWVyc0RlcHRocykge1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gbGF5ZXJzRGVwdGhzW2xheWVySURdO1xuICAgICAgICAgICAgaWYgKCEoZGVwdGggaW4gbGF5ZXJzQnlEZXB0aCkpIHtcbiAgICAgICAgICAgICAgICBsYXllcnNCeURlcHRoW2RlcHRoXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXJzQnlEZXB0aFtkZXB0aF0ucHVzaChsYXllcklEVG9MYXllcltsYXllcklEXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcHRoS2V5cyA9IE9iamVjdC5rZXlzKGxheWVyc0J5RGVwdGgpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwYXJzZUludCh4LCAxMCk7IH0pXG4gICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcbiAgICAgICAgX3RoaXMubGF5ZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIF9qID0gMCwgZGVwdGhLZXlzXzEgPSBkZXB0aEtleXM7IF9qIDwgZGVwdGhLZXlzXzEubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBkZXB0aEtleXNfMVtfal07XG4gICAgICAgICAgICB2YXIgbGF5ZXJzRm9yRGVwdGggPSBsYXllcnNCeURlcHRoW2RlcHRoXTtcbiAgICAgICAgICAgIGxheWVyc0ZvckRlcHRoLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYUluZGV4ID0gbGF5ZXJJbmRpY2VzW2EuaWRdO1xuICAgICAgICAgICAgICAgIHZhciBiSW5kZXggPSBsYXllckluZGljZXNbYi5pZF07XG4gICAgICAgICAgICAgICAgaWYgKGFJbmRleCA8IGJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhSW5kZXggPiBiSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfayA9IDAsIGxheWVyc0ZvckRlcHRoXzEgPSBsYXllcnNGb3JEZXB0aDsgX2sgPCBsYXllcnNGb3JEZXB0aF8xLmxlbmd0aDsgX2srKykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc0ZvckRlcHRoXzFbX2tdO1xuICAgICAgICAgICAgICAgIF90aGlzLmxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5sYXllcnNCeURlcHRoID0gbGF5ZXJzQnlEZXB0aDtcbiAgICAgICAgZGVwdGhLZXlzID0gT2JqZWN0LmtleXMobm9kZXNCeURlcHRoKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcGFyc2VJbnQoeCwgMTApOyB9KVxuICAgICAgICAgICAgLnNvcnQoZ2VuZXJpY191dGlscy5yZXZlcnNlTnVtYmVyQ29tcGFyZSk7XG4gICAgICAgIHZhciBjb21wdXRhYmxlVGVuc29ycyA9IF90aGlzLmlucHV0cy5zbGljZSgpO1xuICAgICAgICB2YXIgbGF5ZXJzV2l0aENvbXBsZXRlSW5wdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2wgPSAwLCBkZXB0aEtleXNfMiA9IGRlcHRoS2V5czsgX2wgPCBkZXB0aEtleXNfMi5sZW5ndGg7IF9sKyspIHtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGRlcHRoS2V5c18yW19sXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9tID0gMCwgX28gPSBub2Rlc0J5RGVwdGhbZGVwdGhdOyBfbSA8IF9vLmxlbmd0aDsgX20rKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gX29bX21dO1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IG5vZGUub3V0Ym91bmRMYXllcjtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcCA9IDAsIF9xID0gbm9kZS5pbnB1dFRlbnNvcnM7IF9wIDwgX3EubGVuZ3RoOyBfcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IF9xW19wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wdXRhYmxlVGVuc29ycy5pbmRleE9mKHgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SdW50aW1lRXJyb3IoXCJHcmFwaCBkaXNjb25uZWN0ZWQ6IGNhbm5vdCBvYnRhaW4gdmFsdWUgZm9yIHRlbnNvciBcIiArIHggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCIgYXQgbGF5ZXIgXFxcIlwiICsgbGF5ZXIubmFtZSArIFwiXFxcIi4gXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBmb2xsb3dpbmcgcHJldmlvdXMgbGF5ZXJzIHdlcmUgYWNjZXNzZWQgd2l0aG91dCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiaXNzdWU6IFwiICsgbGF5ZXJzV2l0aENvbXBsZXRlSW5wdXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfciA9IDAsIF9zID0gbm9kZS5vdXRwdXRUZW5zb3JzOyBfciA8IF9zLmxlbmd0aDsgX3IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBfc1tfcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRhYmxlVGVuc29ycy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxheWVyc1dpdGhDb21wbGV0ZUlucHV0LnB1c2gobGF5ZXIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLm5vZGVzQnlEZXB0aCA9IG5vZGVzQnlEZXB0aDtcbiAgICAgICAgdmFyIGFsbE5hbWVzID0gX3RoaXMubGF5ZXJzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lOyB9KTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobmFtZV8xKSB7XG4gICAgICAgICAgICB2YXIgbnVtT2NjdXJyZW5jZXMgPSBhbGxOYW1lcy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IG5hbWVfMTsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG51bU9jY3VycmVuY2VzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJ1bnRpbWVFcnJvcihcIlRoZSBuYW1lIFxcXCJcIiArIG5hbWVfMSArIFwiXFxcIiBpcyB1c2VkIFwiICsgbnVtT2NjdXJyZW5jZXMgKyBcIiB0aW1lcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICdpbiB0aGUgbW9kZWwuIEFsbCBsYXllciBuYW1lcyBzaG91bGQgYmUgdW5pcXVlLiBMYXllciBuYW1lczogJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGFsbE5hbWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF90ID0gMCwgYWxsTmFtZXNfMSA9IGFsbE5hbWVzOyBfdCA8IGFsbE5hbWVzXzEubGVuZ3RoOyBfdCsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gYWxsTmFtZXNfMVtfdF07XG4gICAgICAgICAgICBfbG9vcF8xKG5hbWVfMSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMub3V0Ym91bmROb2RlcyA9IFtdO1xuICAgICAgICBfdGhpcy5pbmJvdW5kTm9kZXMgPSBbXTtcbiAgICAgICAgbmV3IE5vZGUoe1xuICAgICAgICAgICAgb3V0Ym91bmRMYXllcjogX3RoaXMsXG4gICAgICAgICAgICBpbmJvdW5kTGF5ZXJzOiBbXSxcbiAgICAgICAgICAgIG5vZGVJbmRpY2VzOiBbXSxcbiAgICAgICAgICAgIHRlbnNvckluZGljZXM6IFtdLFxuICAgICAgICAgICAgaW5wdXRUZW5zb3JzOiBfdGhpcy5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzOiBfdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgaW5wdXRNYXNrczogX3RoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gbnVsbDsgfSksXG4gICAgICAgICAgICBvdXRwdXRNYXNrczogX3RoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIG51bGw7IH0pLFxuICAgICAgICAgICAgaW5wdXRTaGFwZXM6IF90aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGU7IH0pLFxuICAgICAgICAgICAgb3V0cHV0U2hhcGVzOiBfdGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZTsgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJ0cmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0NvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgY29udGFpbnMgX3RyYWluYWJsZVdlaWdodHMuJyArXG4gICAgICAgICAgICAgICAgICAgICdUaGUgdHJhaW5hYmxlIHdlaWdodHMgb2YgYSBDb250YWluZXIgYXJlIGEgdW5pb24gb2YgdGhlICcgK1xuICAgICAgICAgICAgICAgICAgICAndHJhaW5hYmxlIHdlaWdodHMgb2YgaXRzIGNvbnNpdHVlbnQgTGF5ZXJzLiBJdHMgb3duICcgK1xuICAgICAgICAgICAgICAgICAgICAnX3RyYWluYWJsZVdlaWdodHMgbXVzdCByZW1haW4gYW4gZW1wdHkgQXJyYXkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhaW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdlaWdodHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmxheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cyA9IHdlaWdodHMuY29uY2F0KGxheWVyLnRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdlaWdodHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcIm5vblRyYWluYWJsZVdlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5sYXllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaC5hcHBseSh3ZWlnaHRzLCBsYXllci5ub25UcmFpbmFibGVXZWlnaHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy50cmFpbmFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlV2VpZ2h0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLmxheWVyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICB0cmFpbmFibGVXZWlnaHRzLnB1c2guYXBwbHkodHJhaW5hYmxlV2VpZ2h0cywgbGF5ZXIudHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh3ZWlnaHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3ZWlnaHRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJ3ZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmxvYWRXZWlnaHRzID0gZnVuY3Rpb24gKHdlaWdodHNKU09OLCBza2lwTWlzbWF0Y2gsIGlzTmFtZWRUZW5zb3JNYXApIHtcbiAgICAgICAgaWYgKHNraXBNaXNtYXRjaCA9PT0gdm9pZCAwKSB7IHNraXBNaXNtYXRjaCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpc05hbWVkVGVuc29yTWFwID09PSB2b2lkIDApIHsgaXNOYW1lZFRlbnNvck1hcCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpc05hbWVkVGVuc29yTWFwKSB7XG4gICAgICAgICAgICBsb2FkV2VpZ2h0c0Zyb21OYW1lZFRlbnNvck1hcCh3ZWlnaHRzSlNPTiwgdGhpcy5sYXllcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9hZFdlaWdodHNGcm9tSnNvbih3ZWlnaHRzSlNPTiwgdGhpcy5sYXllcnMsIHNraXBNaXNtYXRjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlZENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoZUNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIHZhciBtb2RlbENvbmZpZyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5nZXRDbGFzc05hbWUoKSxcbiAgICAgICAgICAgIGNvbmZpZzogdGhlQ29uZmlnLFxuICAgICAgICAgICAga2VyYXNWZXJzaW9uOiBcInRmanMtbGF5ZXJzIFwiICsgdmVyc2lvbl8xLnZlcnNpb24sXG4gICAgICAgICAgICBiYWNrZW5kOiAnVGVuc29yRmxvdy5qcydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vZGVsQ29uZmlnO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAodW51c2VkLCByZXR1cm5TdHJpbmcpIHtcbiAgICAgICAgaWYgKHJldHVyblN0cmluZyA9PT0gdm9pZCAwKSB7IHJldHVyblN0cmluZyA9IHRydWU7IH1cbiAgICAgICAgdmFyIG1vZGVsQ29uZmlnID0gc2VyaWFsaXphdGlvbl91dGlsc18xLmNvbnZlcnRUc1RvUHl0aG9uaWModGhpcy51cGRhdGVkQ29uZmlnKCkpO1xuICAgICAgICByZXR1cm4gcmV0dXJuU3RyaW5nID8gSlNPTi5zdHJpbmdpZnkobW9kZWxDb25maWcpIDogbW9kZWxDb25maWc7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5wdXRzID0gZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRzKTtcbiAgICAgICAgICAgIHZhciBtYXNrcztcbiAgICAgICAgICAgIGlmICgnbWFzaycgaW4ga3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgbWFza3MgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChrd2FyZ3NbJ21hc2snXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXNrcyA9IGdlbmVyaWNfdXRpbHMucHlMaXN0UmVwZWF0KG51bGwsIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJ1bkludGVybmFsR3JhcGgoaW5wdXRzLCBtYXNrcylbMF07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5jb21wdXRlTWFzayA9IGZ1bmN0aW9uIChpbnB1dHMsIG1hc2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5wdXRzID0gZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRzKTtcbiAgICAgICAgICAgIHZhciBtYXNrcztcbiAgICAgICAgICAgIGlmIChtYXNrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtYXNrcyA9IGdlbmVyaWNfdXRpbHMucHlMaXN0UmVwZWF0KG51bGwsIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFza3MgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChtYXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ydW5JbnRlcm5hbEdyYXBoKGlucHV0cywgbWFza3MpWzFdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgdmFyIGlucHV0U2hhcGVzID0gZ2VuZXJpY191dGlscy5ub3JtYWxpemVTaGFwZUxpc3QoaW5wdXRTaGFwZSk7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlcy5sZW5ndGggIT09IHRoaXMuaW5wdXRMYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkludmFsaWQgaW5wdXRTaGFwZSBhcmd1bWVudCBcIiArIGlucHV0U2hhcGUgKyBcIjogXCIgK1xuICAgICAgICAgICAgICAgIChcIm1vZGVsIGhhcyBcIiArIHRoaXMuaW5wdXRMYXllcnMubGVuZ3RoICsgXCIgdGVuc29yIGlucHV0cy5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXllcnNUb091dHB1dFNoYXBlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0U2hhcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmlucHV0TGF5ZXJzW2ldO1xuICAgICAgICAgICAgdmFyIGlucHV0U2hhcGVfMSA9IGlucHV0U2hhcGVzW2ldO1xuICAgICAgICAgICAgdmFyIHNoYXBlS2V5ID0gbGF5ZXIubmFtZSArICdfMF8wJztcbiAgICAgICAgICAgIGxheWVyc1RvT3V0cHV0U2hhcGVzW3NoYXBlS2V5XSA9IGlucHV0U2hhcGVfMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVwdGhLZXlzID0gT2JqZWN0LmtleXModGhpcy5ub2Rlc0J5RGVwdGgpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwYXJzZUludCh4LCAxMCk7IH0pXG4gICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcbiAgICAgICAgaWYgKGRlcHRoS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGRlcHRoS2V5c18zID0gZGVwdGhLZXlzOyBfaSA8IGRlcHRoS2V5c18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IGRlcHRoS2V5c18zW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzQnlEZXB0aFtkZXB0aF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9hIDwgbm9kZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18xW19hXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyID0gbm9kZS5vdXRib3VuZExheWVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnB1dExheWVycy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLmluZGV4T2YobGF5ZXIuaWQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0U2hhcGVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmluYm91bmRMYXllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmJvdW5kTGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4XzIgPSBub2RlLm5vZGVJbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbnNvckluZGV4ID0gbm9kZS50ZW5zb3JJbmRpY2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlS2V5ID0gaW5ib3VuZExheWVyLm5hbWUgKyBcIl9cIiArIG5vZGVJbmRleF8yICsgXCJfXCIgKyB0ZW5zb3JJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dFNoYXBlXzIgPSBsYXllcnNUb091dHB1dFNoYXBlc1tzaGFwZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNoYXBlc18xLnB1c2goaW5wdXRTaGFwZV8yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBsYXllci5jb21wdXRlT3V0cHV0U2hhcGUoZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KGlucHV0U2hhcGVzXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dFNoYXBlc18xID0gZ2VuZXJpY191dGlscy5ub3JtYWxpemVTaGFwZUxpc3Qob3V0cHV0U2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gbGF5ZXIuaW5ib3VuZE5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0cHV0U2hhcGVzXzEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZUtleSA9IGxheWVyLm5hbWUgKyBcIl9cIiArIG5vZGVJbmRleCArIFwiX1wiICsgajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyc1RvT3V0cHV0U2hhcGVzW3NoYXBlS2V5XSA9IG91dHB1dFNoYXBlc18xW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZXMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLm91dHB1dExheWVyc1tpXTtcbiAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIHRlbnNvckluZGV4ID0gdGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIHNoYXBlS2V5ID0gbGF5ZXIubmFtZSArIFwiX1wiICsgbm9kZUluZGV4ICsgXCJfXCIgKyB0ZW5zb3JJbmRleDtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlS2V5cy5wdXNoKHNoYXBlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IG91dHB1dFNoYXBlS2V5c1tpXTtcbiAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KGtleSBpbiBsYXllcnNUb091dHB1dFNoYXBlcyk7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZXMucHVzaChsYXllcnNUb091dHB1dFNoYXBlc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KG91dHB1dFNoYXBlcyk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLnJ1bkludGVybmFsR3JhcGggPSBmdW5jdGlvbiAoaW5wdXRzLCBtYXNrcykge1xuICAgICAgICBpZiAobWFza3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza3MgPSBnZW5lcmljX3V0aWxzLnB5TGlzdFJlcGVhdChudWxsLCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVuc29yTWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgICAgICAgICB2YXIgeSA9IGlucHV0c1tpXTtcbiAgICAgICAgICAgIHZhciBtYXNrID0gbWFza3NbaV07XG4gICAgICAgICAgICB0ZW5zb3JNYXBbeC5pZF0gPSBbeSwgbWFza107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcHRoS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcGFyc2VJbnQoeCwgMTApOyB9KVxuICAgICAgICAgICAgLnNvcnQoZ2VuZXJpY191dGlscy5yZXZlcnNlTnVtYmVyQ29tcGFyZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGVwdGhLZXlzXzQgPSBkZXB0aEtleXM7IF9pIDwgZGVwdGhLZXlzXzQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBkZXB0aEtleXNfNFtfaV07XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzQnlEZXB0aFtkZXB0aF07XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIG5vZGVzXzIgPSBub2RlczsgX2EgPCBub2Rlc18yLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNfMltfYV07XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gbm9kZS5vdXRib3VuZExheWVyO1xuICAgICAgICAgICAgICAgIHZhciByZWZlcmVuY2VJbnB1dFRlbnNvcnMgPSBub2RlLmlucHV0VGVuc29ycztcbiAgICAgICAgICAgICAgICB2YXIgcmVmZXJlbmNlT3V0cHV0VGVuc29ycyA9IG5vZGUub3V0cHV0VGVuc29ycztcbiAgICAgICAgICAgICAgICB2YXIgY29tcHV0ZWREYXRhID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCByZWZlcmVuY2VJbnB1dFRlbnNvcnNfMSA9IHJlZmVyZW5jZUlucHV0VGVuc29yczsgX2IgPCByZWZlcmVuY2VJbnB1dFRlbnNvcnNfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSByZWZlcmVuY2VJbnB1dFRlbnNvcnNfMVtfYl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4LmlkIGluIHRlbnNvck1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWREYXRhLnB1c2godGVuc29yTWFwW3guaWRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWREYXRhLmxlbmd0aCA9PT0gcmVmZXJlbmNlSW5wdXRUZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga3dhcmdzID0ge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZFRlbnNvcnMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZE1hc2tzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0VGVuc29yc18xID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0TWFza3NfMSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2FsbEFyZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAga3dhcmdzID0gbm9kZS5jYWxsQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWREYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gY29tcHV0ZWREYXRhWzBdLCBjb21wdXRlZFRlbnNvciA9IF9jWzBdLCBjb21wdXRlZE1hc2sgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrd2FyZ3MubWFzayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga3dhcmdzWydtYXNrJ10gPSBjb21wdXRlZE1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRUZW5zb3JzXzEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMudG9MaXN0KGxheWVyLmNhbGwoY29tcHV0ZWRUZW5zb3IsIGt3YXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0TWFza3NfMSA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGxheWVyLmNvbXB1dGVNYXNrKGNvbXB1dGVkVGVuc29yLCBjb21wdXRlZE1hc2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkVGVuc29ycyA9IFtjb21wdXRlZFRlbnNvcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZE1hc2tzID0gW2NvbXB1dGVkTWFza107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFRlbnNvcnMgPSBjb21wdXRlZERhdGEubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4WzBdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkTWFza3MgPSBjb21wdXRlZERhdGEubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4WzFdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrd2FyZ3MubWFzayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga3dhcmdzWydtYXNrJ10gPSBjb21wdXRlZE1hc2tzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VGVuc29yc18xID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmljX3V0aWxzLnRvTGlzdChsYXllci5jYWxsKGNvbXB1dGVkVGVuc29ycywga3dhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRNYXNrc18xID0gZ2VuZXJpY191dGlscy50b0xpc3QobGF5ZXIuY29tcHV0ZU1hc2soY29tcHV0ZWRUZW5zb3JzLCBjb21wdXRlZE1hc2tzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLmFjdGl2aXR5UmVndWxhcml6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdNb2RlbCBpbnZvY2F0aW9uIHdpdGggY29uY3JldGUgVGVuc29yIHZhbHVlKHMpIGluIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZlcmVuY2VPdXRwdXRUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHJlZmVyZW5jZU91dHB1dFRlbnNvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG91dHB1dFRlbnNvcnNfMVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXNrID0gb3V0cHV0TWFza3NfMVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvck1hcFt4LmlkXSA9IFt5LCBtYXNrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0VGVuc29ycyA9IFtdO1xuICAgICAgICB2YXIgb3V0cHV0TWFza3MgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gdGhpcy5vdXRwdXRzOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgdmFyIHggPSBfZVtfZF07XG4gICAgICAgICAgICBnZW5lcmljX3V0aWxzLmFzc2VydCh4LmlkIGluIHRlbnNvck1hcCwgXCJDb3VsZCBub3QgY29tcHV0ZSBvdXRwdXQgXCIgKyB4Lm5hbWUgKyBcIiA6IFwiICsgeC5pZCk7XG4gICAgICAgICAgICB2YXIgX2YgPSB0ZW5zb3JNYXBbeC5pZF0sIHRlbnNvciA9IF9mWzBdLCBtYXNrID0gX2ZbMV07XG4gICAgICAgICAgICBvdXRwdXRTaGFwZXMucHVzaCh0ZW5zb3Iuc2hhcGUpO1xuICAgICAgICAgICAgb3V0cHV0VGVuc29ycy5wdXNoKHRlbnNvcik7XG4gICAgICAgICAgICBvdXRwdXRNYXNrcy5wdXNoKG1hc2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbb3V0cHV0VGVuc29ycywgb3V0cHV0TWFza3MsIG91dHB1dFNoYXBlc107XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmJ1aWxkTm9kZUNvbnZlcnNpb25NYXAgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XG4gICAgICAgIHZhciBub2RlQ29udmVyc2lvbk1hcCA9IHt9O1xuICAgICAgICB2YXIga2VwdE5vZGVzO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5sYXllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBrZXB0Tm9kZXMgPSBsYXllciBpbnN0YW5jZW9mIENvbnRhaW5lciA/IDEgOiAwO1xuICAgICAgICAgICAgZm9yICh2YXIgb3JpZ2luYWxOb2RlSW5kZXggPSAwOyBvcmlnaW5hbE5vZGVJbmRleCA8IGxheWVyLmluYm91bmROb2Rlcy5sZW5ndGg7IG9yaWdpbmFsTm9kZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUtleSA9IENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBvcmlnaW5hbE5vZGVJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVLZXkgaW4gdGhpcy5jb250YWluZXJOb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlQ29udmVyc2lvbk1hcFtub2RlS2V5XSA9IGtlcHROb2RlcztcbiAgICAgICAgICAgICAgICAgICAga2VwdE5vZGVzICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlQ29udmVyc2lvbk1hcDtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZ2V0TGF5ZXIgPSBmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIldhcyBhc2tlZCB0byByZXRyaWV2ZSBsYXllciBhdCBpbmRleCBcIiArIGluZGV4ICsgXCIsIGJ1dCBtb2RlbCBvbmx5IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiaGFzIFwiICsgdGhpcy5sYXllcnMubGVuZ3RoICsgXCIgbGF5ZXIocykuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVyc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1Byb3ZpZGUgZWl0aGVyIGEgbGF5ZXIgbmFtZSBvciBsYXllciBpbmRleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmxheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChsYXllci5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiTm8gc3VjaCBsYXllcjogXCIgKyBuYW1lKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuY2FsY3VsYXRlTG9zc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9zc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMubGF5ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBub2RlSW5kZXggPSAwOyBub2RlSW5kZXggPCBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOyArK25vZGVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUtleSA9IENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBub2RlSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29udGFpbmVyTm9kZXMuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3NzZXMucHVzaC5hcHBseShsb3NzZXMsIGxheWVyLmNhbGN1bGF0ZUxvc3NlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb3NzZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IG5hbWU6IHRoaXMubmFtZSB9O1xuICAgICAgICB2YXIgbm9kZUNvbnZlcnNpb25NYXAgPSB0aGlzLmJ1aWxkTm9kZUNvbnZlcnNpb25NYXAodGhpcy5sYXllcnMpO1xuICAgICAgICB2YXIgbGF5ZXJDb25maWdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmxheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBsYXllckNsYXNzTmFtZSA9IGxheWVyLmdldENsYXNzTmFtZSgpO1xuICAgICAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gbGF5ZXIuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRJbmJvdW5kTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIG9yaWdpbmFsTm9kZUluZGV4ID0gMDsgb3JpZ2luYWxOb2RlSW5kZXggPCBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOyBvcmlnaW5hbE5vZGVJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBsYXllci5pbmJvdW5kTm9kZXNbb3JpZ2luYWxOb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG9yaWdpbmFsTm9kZUluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIga3dhcmdzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNhbGxBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG5vZGUuY2FsbEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3RTdHJpbmcuaW5kZXhPZigndW5kZWZpbmVkJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga3dhcmdzID0gbm9kZS5jYWxsQXJncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkxheWVyIFwiICsgbGF5ZXIubmFtZSArIFwiIHdhcyBwYXNzZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vbi1zZXJpYWxpemFibGUga2V5d29yZCBhcmd1bWVudHM6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUuY2FsbEFyZ3MgKyBcIi4gVGhleSB3aWxsIG5vdCBiZSBpbmNsdWRlZCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImluIHRoZSBzZXJpYWxpemVkIG1vZGVsIChhbmQgdGh1cyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaXNzaW5nIGF0IGRlc2VyaWFsaXphdGlvbiB0aW1lKS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga3dhcmdzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZURhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluYm91bmRMYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gbm9kZS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVuc29ySW5kZXggPSBub2RlLnRlbnNvckluZGljZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVLZXlfMSA9IENvbnRhaW5lci5ub2RlS2V5KGluYm91bmRMYXllciwgbm9kZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZUluZGV4ID0gbm9kZUNvbnZlcnNpb25NYXBbbm9kZUtleV8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3Tm9kZUluZGV4ID09PSBudWxsIHx8IG5ld05vZGVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVEYXRhLnB1c2goW2luYm91bmRMYXllci5uYW1lLCBuZXdOb2RlSW5kZXgsIHRlbnNvckluZGV4LCBrd2FyZ3NdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSW5ib3VuZE5vZGVzLnB1c2gobm9kZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXJDb25maWdzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBsYXllckNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGxheWVyQ29uZmlnLFxuICAgICAgICAgICAgICAgIGluYm91bmROb2RlczogZmlsdGVyZWRJbmJvdW5kTm9kZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZ1snbGF5ZXJzJ10gPSBsYXllckNvbmZpZ3M7XG4gICAgICAgIHZhciBtb2RlbElucHV0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIG5vZGVLZXkgPSBDb250YWluZXIubm9kZUtleShsYXllciwgbm9kZUluZGV4KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdOb2RlSW5kZXggPSBub2RlQ29udmVyc2lvbk1hcFtub2RlS2V5XTtcbiAgICAgICAgICAgIGlmIChuZXdOb2RlSW5kZXggPT09IG51bGwgfHwgbmV3Tm9kZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlSW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRlbnNvckluZGV4ID0gdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXNbaV07XG4gICAgICAgICAgICBtb2RlbElucHV0cy5wdXNoKFtsYXllci5uYW1lLCBuZXdOb2RlSW5kZXgsIHRlbnNvckluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnWydpbnB1dExheWVycyddID0gbW9kZWxJbnB1dHM7XG4gICAgICAgIHZhciBtb2RlbE91dHB1dHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5vdXRwdXRMYXllcnNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICAgIHZhciBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG5vZGVJbmRleCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyTm9kZXMuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZUluZGV4ID0gbm9kZUNvbnZlcnNpb25NYXBbbm9kZUtleV07XG4gICAgICAgICAgICBpZiAobmV3Tm9kZUluZGV4ID09PSBudWxsIHx8IG5ld05vZGVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZUluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZW5zb3JJbmRleCA9IHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tpXTtcbiAgICAgICAgICAgIG1vZGVsT3V0cHV0cy5wdXNoKFtsYXllci5uYW1lLCBuZXdOb2RlSW5kZXgsIHRlbnNvckluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnWydvdXRwdXRMYXllcnMnXSA9IG1vZGVsT3V0cHV0cztcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIENvbnRhaW5lci5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIHZhciBjcmVhdGVkTGF5ZXJzID0ge307XG4gICAgICAgIHZhciB1bnByb2Nlc3NlZE5vZGVzID0ge307XG4gICAgICAgIGZ1bmN0aW9uIGFkZFVucHJvY2Vzc2VkTm9kZShsYXllciwgbm9kZURhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGxheWVyLm5hbWUgaW4gdW5wcm9jZXNzZWROb2RlcykpIHtcbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZE5vZGVzW2xheWVyLm5hbWVdID0gW25vZGVEYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkTm9kZXNbbGF5ZXIubmFtZV0ucHVzaChub2RlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc05vZGUobGF5ZXIsIG5vZGVEYXRhKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRUZW5zb3JzID0gW107XG4gICAgICAgICAgICB2YXIga3dhcmdzO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBub2RlRGF0YV8xID0gbm9kZURhdGE7IF9pIDwgbm9kZURhdGFfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXREYXRhID0gbm9kZURhdGFfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGluYm91bmRMYXllck5hbWUgPSBpbnB1dERhdGFbMF07XG4gICAgICAgICAgICAgICAgdmFyIGluYm91bmROb2RlSW5kZXggPSBpbnB1dERhdGFbMV07XG4gICAgICAgICAgICAgICAgdmFyIGluYm91bmRUZW5zb3JJbmRleCA9IGlucHV0RGF0YVsyXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXREYXRhLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBrd2FyZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXREYXRhLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBrd2FyZ3MgPSBpbnB1dERhdGFbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkltcHJvcGVybHkgZm9ybWF0dGVkIG1vZGVsIGNvbmZpZyBmb3IgbGF5ZXIgXCIgKyBKU09OLnN0cmluZ2lmeShsYXllcikgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShpbnB1dERhdGEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5ib3VuZExheWVyTmFtZSBpbiBjcmVhdGVkTGF5ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRVbnByb2Nlc3NlZE5vZGUobGF5ZXIsIG5vZGVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5ib3VuZExheWVyID0gY3JlYXRlZExheWVyc1tpbmJvdW5kTGF5ZXJOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5ib3VuZExheWVyLmluYm91bmROb2Rlcy5sZW5ndGggPD0gaW5ib3VuZE5vZGVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRVbnByb2Nlc3NlZE5vZGUobGF5ZXIsIG5vZGVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5ib3VuZE5vZGUgPSBpbmJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzW2luYm91bmROb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlucHV0VGVuc29ycy5wdXNoKGluYm91bmROb2RlLm91dHB1dFRlbnNvcnNbaW5ib3VuZFRlbnNvckluZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRUZW5zb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXllci5hcHBseShnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkoaW5wdXRUZW5zb3JzKSwga3dhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzTGF5ZXIobGF5ZXJEYXRhKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJOYW1lID0gbGF5ZXJEYXRhLm5hbWU7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBzZXJpYWxpemF0aW9uXzEuZGVzZXJpYWxpemUobGF5ZXJEYXRhLCBjb25maWcuY3VzdG9tT2JqZWN0cyAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBjb25maWcuY3VzdG9tT2JqZWN0cyA6XG4gICAgICAgICAgICAgICAge30pO1xuICAgICAgICAgICAgY3JlYXRlZExheWVyc1tsYXllck5hbWVdID0gbGF5ZXI7XG4gICAgICAgICAgICB2YXIgaW5ib3VuZE5vZGVzRGF0YSA9IGxheWVyRGF0YS5pbmJvdW5kTm9kZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGluYm91bmROb2Rlc0RhdGFfMSA9IGluYm91bmROb2Rlc0RhdGE7IF9pIDwgaW5ib3VuZE5vZGVzRGF0YV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlRGF0YSA9IGluYm91bmROb2Rlc0RhdGFfMVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKCEobm9kZURhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJDb3JydXB0ZWQgY29uZmlndXJhdGlvbiwgZXhwZWN0ZWQgYXJyYXkgZm9yIG5vZGVEYXRhOiBcIiArIG5vZGVEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVW5wcm9jZXNzZWROb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgdmFyIGxheWVyc0Zyb21Db25maWcgPSBjb25maWcubGF5ZXJzO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxheWVyc0Zyb21Db25maWdfMSA9IGxheWVyc0Zyb21Db25maWc7IF9pIDwgbGF5ZXJzRnJvbUNvbmZpZ18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGxheWVyRGF0YSA9IGxheWVyc0Zyb21Db25maWdfMVtfaV07XG4gICAgICAgICAgICBwcm9jZXNzTGF5ZXIobGF5ZXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoIWdlbmVyaWNfdXRpbHMuaXNPYmplY3RFbXB0eSh1bnByb2Nlc3NlZE5vZGVzKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBsYXllcnNGcm9tQ29uZmlnXzIgPSBsYXllcnNGcm9tQ29uZmlnOyBfYSA8IGxheWVyc0Zyb21Db25maWdfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJEYXRhID0gbGF5ZXJzRnJvbUNvbmZpZ18yW19hXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyRGF0YS5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIubmFtZSBpbiB1bnByb2Nlc3NlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB1bnByb2Nlc3NlZE5vZGVzW2xheWVyLm5hbWVdOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVEYXRhID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05vZGUobGF5ZXIsIG5vZGVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdW5wcm9jZXNzZWROb2Rlc1tsYXllci5uYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0VGVuc29ycyA9IFtdO1xuICAgICAgICB2YXIgb3V0cHV0VGVuc29ycyA9IFtdO1xuICAgICAgICB2YXIgaW5wdXRMYXllcnNGcm9tQ29uZmlnID0gY29uZmlnLmlucHV0TGF5ZXJzO1xuICAgICAgICBmb3IgKHZhciBfZCA9IDAsIGlucHV0TGF5ZXJzRnJvbUNvbmZpZ18xID0gaW5wdXRMYXllcnNGcm9tQ29uZmlnOyBfZCA8IGlucHV0TGF5ZXJzRnJvbUNvbmZpZ18xLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgdmFyIGxheWVyRGF0YSA9IGlucHV0TGF5ZXJzRnJvbUNvbmZpZ18xW19kXTtcbiAgICAgICAgICAgIHZhciBsYXllck5hbWUgPSBsYXllckRhdGFbMF07XG4gICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gbGF5ZXJEYXRhWzFdO1xuICAgICAgICAgICAgdmFyIHRlbnNvckluZGV4ID0gbGF5ZXJEYXRhWzJdO1xuICAgICAgICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQobGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpO1xuICAgICAgICAgICAgdmFyIGxheWVyID0gY3JlYXRlZExheWVyc1tsYXllck5hbWVdO1xuICAgICAgICAgICAgdmFyIGxheWVyT3V0cHV0VGVuc29ycyA9IGxheWVyLmluYm91bmROb2Rlc1tub2RlSW5kZXhdLm91dHB1dFRlbnNvcnM7XG4gICAgICAgICAgICBpbnB1dFRlbnNvcnMucHVzaChsYXllck91dHB1dFRlbnNvcnNbdGVuc29ySW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0TGF5ZXJzRnJvbUNvbmZpZyA9IGNvbmZpZy5vdXRwdXRMYXllcnM7XG4gICAgICAgIGZvciAodmFyIF9lID0gMCwgb3V0cHV0TGF5ZXJzRnJvbUNvbmZpZ18xID0gb3V0cHV0TGF5ZXJzRnJvbUNvbmZpZzsgX2UgPCBvdXRwdXRMYXllcnNGcm9tQ29uZmlnXzEubGVuZ3RoOyBfZSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJEYXRhID0gb3V0cHV0TGF5ZXJzRnJvbUNvbmZpZ18xW19lXTtcbiAgICAgICAgICAgIHZhciBsYXllck5hbWUgPSBsYXllckRhdGFbMF07XG4gICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gbGF5ZXJEYXRhWzFdO1xuICAgICAgICAgICAgdmFyIHRlbnNvckluZGV4ID0gbGF5ZXJEYXRhWzJdO1xuICAgICAgICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQobGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpO1xuICAgICAgICAgICAgdmFyIGxheWVyID0gY3JlYXRlZExheWVyc1tsYXllck5hbWVdO1xuICAgICAgICAgICAgdmFyIGxheWVyT3V0cHV0VGVuc29ycyA9IGxheWVyLmluYm91bmROb2Rlc1tub2RlSW5kZXhdLm91dHB1dFRlbnNvcnM7XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzLnB1c2gobGF5ZXJPdXRwdXRUZW5zb3JzW3RlbnNvckluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjbHMoeyBpbnB1dHM6IGlucHV0VGVuc29ycywgb3V0cHV0czogb3V0cHV0VGVuc29ycywgbmFtZTogbmFtZSB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcInN0YXRlZnVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVmdWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQ29udGFpbmVyIGluc3RhbmNlIHVuZXhwZWN0ZWRseSBoYXMgX3N0YXRlZnVsID0gdHJ1ZS4gVGhlICcgK1xuICAgICAgICAgICAgICAgICAgICAnc3RhdGVmdWxuZXNzIG9mIGEgQ29udGFpbmVyIGlzIGRldGVybWluZWQgYnkgdGhlIExheWVycyBpdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRhaW5zLiBJdHMgX3N0YXRlZnVsIHByb3BlcnR5IG11c3QgcmVtYWluIHRoZSBkZWZhdWx0IGZhbHNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGF5ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuc3RhdGVmdWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0NsYXNzZXMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmNsYXNzZXM6IFsnTW9kZWwnXVxuICAgICAgICB9KVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiZ2V0TGF5ZXJcIiwgbnVsbCk7XG4gICAgcmV0dXJuIENvbnRhaW5lcjtcbn0oTGF5ZXIpKTtcbmV4cG9ydHMuQ29udGFpbmVyID0gQ29udGFpbmVyO1xuZnVuY3Rpb24gZ2V0U291cmNlSW5wdXRzKHRlbnNvciwgbGF5ZXIsIG5vZGVJbmRleCkge1xuICAgIGlmIChsYXllciA9PSBudWxsIHx8IChub2RlSW5kZXggIT0gbnVsbCAmJiBub2RlSW5kZXggPiAwKSkge1xuICAgICAgICBsYXllciA9IHRlbnNvci5zb3VyY2VMYXllcjtcbiAgICAgICAgbm9kZUluZGV4ID0gdGVuc29yLm5vZGVJbmRleDtcbiAgICB9XG4gICAgaWYgKGxheWVyLmluYm91bmROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFt0ZW5zb3JdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGUgPSBsYXllci5pbmJvdW5kTm9kZXNbbm9kZUluZGV4XTtcbiAgICAgICAgaWYgKG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmlucHV0VGVuc29ycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VUZW5zb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dFRlbnNvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyXzIgPSBub2RlLmluYm91bmRMYXllcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleF8zID0gbm9kZS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTb3VyY2VzID0gZ2V0U291cmNlSW5wdXRzKHgsIGxheWVyXzIsIG5vZGVJbmRleF8zKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHByZXZpb3VzU291cmNlc18xID0gcHJldmlvdXNTb3VyY2VzOyBfaSA8IHByZXZpb3VzU291cmNlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeF8xID0gcHJldmlvdXNTb3VyY2VzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlVGVuc29ycy5pbmRleE9mKHhfMSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VUZW5zb3JzLnB1c2goeF8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VUZW5zb3JzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTb3VyY2VJbnB1dHMgPSBnZXRTb3VyY2VJbnB1dHM7XG5mdW5jdGlvbiBsb2FkVGVuc29yKGR0eXBlLCBzaGFwZSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YVR5cGUgPSBnZW5lcmljX3V0aWxzLnN0cmluZ1RvRFR5cGUoZHR5cGUpO1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHNoYXBlLmxlbmd0aCA9PT0gMCA/IHZhbHVlIDogdGZqc19jb3JlXzEudXRpbC5mbGF0dGVuKHZhbHVlKSB9LCBkYXRhVHlwZSk7XG59XG5mdW5jdGlvbiBwcmVwcm9jZXNzV2VpZ2h0c0ZvckxvYWRpbmcobGF5ZXIsIHdlaWdodHMsIG9yaWdpbmFsS2VyYXNWZXJzaW9uLCBvcmlnaW5hbEJhY2tlbmQpIHtcbiAgICBpZiAoIW9yaWdpbmFsS2VyYXNWZXJzaW9uLnN0YXJ0c1dpdGgoJzIuJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1Vuc3VwcG9ydGVkIEtlcmFzIHZlcnNpb24gaW4gd2VpZ2h0cyBiZWluZyBsb2FkZWQ6ICcgK1xuICAgICAgICAgICAgb3JpZ2luYWxLZXJhc1ZlcnNpb24pO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbn1cbmZ1bmN0aW9uIGxvYWRXZWlnaHRzRnJvbU5hbWVkVGVuc29yTWFwKHdlaWdodHMsIGxheWVycykge1xuICAgIHZhciBuYW1lVG9XZWlnaHQgPSB7fTtcbiAgICB2YXIgdG90YWxXZWlnaHRzQ291bnQgPSAwO1xuICAgIGZvciAodmFyIF9pID0gMCwgbGF5ZXJzXzEgPSBsYXllcnM7IF9pIDwgbGF5ZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc18xW19pXTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IGxheWVyLndlaWdodHM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gX2JbX2FdO1xuICAgICAgICAgICAgaWYgKG5hbWVUb1dlaWdodFt3ZWlnaHQub3JpZ2luYWxOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJEdXBsaWNhdGUgd2VpZ2h0IG5hbWU6IFwiICsgd2VpZ2h0Lm9yaWdpbmFsTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lVG9XZWlnaHRbd2VpZ2h0Lm9yaWdpbmFsTmFtZV0gPSB3ZWlnaHQ7XG4gICAgICAgICAgICB0b3RhbFdlaWdodHNDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB3ZWlnaHRWYWx1ZVR1cGxlcyA9IFtdO1xuICAgIGZvciAodmFyIG5hbWVfMiBpbiB3ZWlnaHRzKSB7XG4gICAgICAgIHdlaWdodFZhbHVlVHVwbGVzLnB1c2goW25hbWVUb1dlaWdodFtuYW1lXzJdLCB3ZWlnaHRzW25hbWVfMl1dKTtcbiAgICAgICAgZGVsZXRlIG5hbWVUb1dlaWdodFtuYW1lXzJdO1xuICAgIH1cbiAgICB2YXIgdW5zZXROYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIG5hbWVfMyBpbiBuYW1lVG9XZWlnaHQpIHtcbiAgICAgICAgdW5zZXROYW1lcy5wdXNoKG5hbWVfMyk7XG4gICAgfVxuICAgIGlmICh1bnNldE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IodW5zZXROYW1lcy5sZW5ndGggKyBcIiBvZiBcIiArIHRvdGFsV2VpZ2h0c0NvdW50ICsgXCIgd2VpZ2h0cyBhcmUgbm90IHNldDogXCIgK1xuICAgICAgICAgICAgKFwiXCIgKyB1bnNldE5hbWVzKSk7XG4gICAgfVxuICAgIHZhcmlhYmxlc18xLmJhdGNoU2V0VmFsdWUod2VpZ2h0VmFsdWVUdXBsZXMpO1xufVxuZXhwb3J0cy5sb2FkV2VpZ2h0c0Zyb21OYW1lZFRlbnNvck1hcCA9IGxvYWRXZWlnaHRzRnJvbU5hbWVkVGVuc29yTWFwO1xuZnVuY3Rpb24gbG9hZFdlaWdodHNGcm9tSnNvbih3ZWlnaHRzSlNPTiwgbGF5ZXJzLCBza2lwTWlzbWF0Y2gpIHtcbiAgICBpZiAoc2tpcE1pc21hdGNoID09PSB2b2lkIDApIHsgc2tpcE1pc21hdGNoID0gZmFsc2U7IH1cbiAgICB2YXIgb3JpZ2luYWxLZXJhc1ZlcnNpb24gPSB3ZWlnaHRzSlNPTlsna2VyYXNfdmVyc2lvbiddO1xuICAgIHZhciBvcmlnaW5hbEJhY2tlbmQgPSB3ZWlnaHRzSlNPTlsnYmFja2VuZCddO1xuICAgIHZhciBsYXllck5hbWVzID0gbGF5ZXJzLm1hcChmdW5jdGlvbiAobGF5ZXIpIHsgcmV0dXJuIGxheWVyLm5hbWU7IH0pO1xuICAgIHZhciBpbmRleCA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMCwgbGF5ZXJzXzIgPSBsYXllcnM7IF9pIDwgbGF5ZXJzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc18yW19pXTtcbiAgICAgICAgaWYgKGxheWVyLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4W2xheWVyLm5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleFtsYXllci5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXhbbGF5ZXIubmFtZV0ucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5hbWVUb1dlaWdodHMgPSB3ZWlnaHRzSlNPTlsnd2VpZ2h0cyddO1xuICAgIHZhciB3ZWlnaHRWYWx1ZVR1cGxlcyA9IFtdO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGF5ZXJOYW1lcy5sZW5ndGg7ICsraykge1xuICAgICAgICB2YXIgbmFtZV80ID0gbGF5ZXJOYW1lc1trXTtcbiAgICAgICAgdmFyIGxheWVyV2VpZ2h0cyA9IG5hbWVUb1dlaWdodHNbbmFtZV80XTtcbiAgICAgICAgaWYgKGxheWVyV2VpZ2h0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsYXllcldlaWdodHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2VpZ2h0VmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbGF5ZXJXZWlnaHRzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0RW50cnkgPSBsYXllcldlaWdodHNbbl07XG4gICAgICAgICAgICB3ZWlnaHRWYWx1ZXMucHVzaChuZXcgdmFyaWFibGVzXzEuTGF5ZXJWYXJpYWJsZShsb2FkVGVuc29yKHdlaWdodEVudHJ5WydkdHlwZSddLCB3ZWlnaHRFbnRyeVsnc2hhcGUnXSwgd2VpZ2h0RW50cnlbJ3ZhbHVlJ10pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IGluZGV4W25hbWVfNF07IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBfYltfYV07XG4gICAgICAgICAgICB2YXIgc3ltYm9saWNXZWlnaHRzID0gbGF5ZXIud2VpZ2h0cztcbiAgICAgICAgICAgIHdlaWdodFZhbHVlcyA9IHByZXByb2Nlc3NXZWlnaHRzRm9yTG9hZGluZyhsYXllciwgd2VpZ2h0VmFsdWVzLCBvcmlnaW5hbEtlcmFzVmVyc2lvbiwgb3JpZ2luYWxCYWNrZW5kKTtcbiAgICAgICAgICAgIGlmICh3ZWlnaHRWYWx1ZXMubGVuZ3RoICE9PSBzeW1ib2xpY1dlaWdodHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBNaXNtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTa2lwcGluZyBsb2FkaW5nIG9mIHdlaWdodHMgb2YgbGF5ZXIgXCIgKyBsYXllci5uYW1lICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiZHVlIHRvIG1pc21hdGNoIGluIG51bWJlciBvZiB3ZWlnaHRzOiAoXCIgKyB3ZWlnaHRWYWx1ZXMubGVuZ3RoICsgXCIgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcInZzIFwiICsgc3ltYm9saWNXZWlnaHRzLmxlbmd0aCArIFwiKS5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJMYXllciAjXCIgKyBrICsgXCIgKG5hbWVkIFxcXCJcIiArIGxheWVyLm5hbWUgKyBcIlxcXCIpIGV4cGVjdHMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN5bWJvbGljV2VpZ2h0cy5sZW5ndGggKyBcIiB3ZWlnaHQocyksIGJ1dCB0aGUgc2F2ZWQgd2VpZ2h0cyBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiaGF2ZSBcIiArIHdlaWdodFZhbHVlcy5sZW5ndGggKyBcIiBlbGVtZW50KHMpLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3ZWlnaHRWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcE1pc21hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGZqc19jb3JlXzEudXRpbC5hcnJheXNFcXVhbChzeW1ib2xpY1dlaWdodHNbaV0uc2hhcGUsIHdlaWdodFZhbHVlc1tpXS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNraXBwaW5nIGxvYWRpbmcgb2Ygd2VpZ2h0cyBmb3IgbGF5ZXIgXCIgKyBsYXllci5uYW1lICsgXCIgZHVlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ0byBtaXNtYXRjaCBpbiBzaGFwZSAoXCIgKyBzeW1ib2xpY1dlaWdodHNbaV0uc2hhcGUgKyBcIiB2cyBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3ZWlnaHRWYWx1ZXNbaV0uc2hhcGUgKyBcIilcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2VpZ2h0VmFsdWVUdXBsZXMucHVzaChbc3ltYm9saWNXZWlnaHRzW2ldLCB3ZWlnaHRWYWx1ZXNbaV0ucmVhZCgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyaWFibGVzXzEuYmF0Y2hTZXRWYWx1ZSh3ZWlnaHRWYWx1ZVR1cGxlcyk7XG59XG5leHBvcnRzLmxvYWRXZWlnaHRzRnJvbUpzb24gPSBsb2FkV2VpZ2h0c0Zyb21Kc29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9wb2xvZ3kuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgY2FsbGJhY2tzXzEgPSByZXF1aXJlKFwiLi4vY2FsbGJhY2tzXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBsb3NzZXMgPSByZXF1aXJlKFwiLi4vbG9zc2VzXCIpO1xudmFyIE1ldHJpY3MgPSByZXF1aXJlKFwiLi4vbWV0cmljc1wiKTtcbnZhciBvcHRpbWl6ZXJzID0gcmVxdWlyZShcIi4uL29wdGltaXplcnNcIik7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgbWF0aF91dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL21hdGhfdXRpbHNcIik7XG52YXIgZXhlY3V0b3JfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dG9yXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi90b3BvbG9neVwiKTtcbmZ1bmN0aW9uIGlzRGF0YVRlbnNvcih4KSB7XG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiB0ZmpzX2NvcmVfMS5UZW5zb3I7XG59XG5leHBvcnRzLmlzRGF0YVRlbnNvciA9IGlzRGF0YVRlbnNvcjtcbmZ1bmN0aW9uIGlzRGF0YUFycmF5KHgpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KTtcbn1cbmV4cG9ydHMuaXNEYXRhQXJyYXkgPSBpc0RhdGFBcnJheTtcbmZ1bmN0aW9uIGlzRGF0YURpY3QoeCkge1xuICAgIHJldHVybiAhaXNEYXRhVGVuc29yKHgpICYmICFpc0RhdGFBcnJheSh4KTtcbn1cbmV4cG9ydHMuaXNEYXRhRGljdCA9IGlzRGF0YURpY3Q7XG5mdW5jdGlvbiBzdGFuZGFyZGl6ZUlucHV0RGF0YShkYXRhLCBuYW1lcywgc2hhcGVzLCBjaGVja0JhdGNoQXhpcywgZXhjZXB0aW9uUHJlZml4KSB7XG4gICAgaWYgKGNoZWNrQmF0Y2hBeGlzID09PSB2b2lkIDApIHsgY2hlY2tCYXRjaEF4aXMgPSB0cnVlOyB9XG4gICAgaWYgKGV4Y2VwdGlvblByZWZpeCA9PT0gdm9pZCAwKSB7IGV4Y2VwdGlvblByZWZpeCA9ICcnOyB9XG4gICAgaWYgKG5hbWVzID09IG51bGwgfHwgbmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBnb3RVbmV4cGVjdGVkRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzRGF0YUFycmF5KGRhdGEpICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdvdFVuZXhwZWN0ZWREYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0YURpY3QoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RVbmV4cGVjdGVkRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvdFVuZXhwZWN0ZWREYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnb3RVbmV4cGVjdGVkRGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCBcIiArIGV4Y2VwdGlvblByZWZpeCArIFwiIGV4cGVjdGVkIG5vIGRhdGEsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiYnV0IGdvdCBcIiArIGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbnVsbDsgfSk7XG4gICAgfVxuICAgIHZhciBhcnJheXM7XG4gICAgaWYgKGlzRGF0YURpY3QoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IGRhdGE7XG4gICAgICAgIGFycmF5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5hbWVzXzEgPSBuYW1lczsgX2kgPCBuYW1lc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGRhdGFbbmFtZV8xXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJObyBkYXRhIHByb3ZpZGVkIGZvciBcXFwiXCIgKyBuYW1lXzEgKyBcIlxcXCIuIE5lZWQgZGF0YSBmb3IgZWFjaCBrZXkgaW46IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyBuYW1lcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlzLnB1c2goZGF0YVtuYW1lXzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0RhdGFBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gZGF0YTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCBcIiArIGV4Y2VwdGlvblByZWZpeCArIFwiOiB0aGUgQXJyYXkgb2YgXCIgK1xuICAgICAgICAgICAgICAgIFwiVGVuc29ycyB0aGF0IHlvdSBhcmUgcGFzc2luZyB0byB5b3VyIG1vZGVsIGlzIG5vdCB0aGUgc2l6ZSB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIChcIm1vZGVsIGV4cGVjdGVkLiBFeHBlY3RlZCB0byBzZWUgXCIgKyBuYW1lcy5sZW5ndGggKyBcIiBUZW5zb3IocyksIGJ1dCBcIikgK1xuICAgICAgICAgICAgICAgIChcImluc3RlYWQgZ290IHRoZSBmb2xsb3dpbmcgbGlzdCBvZiBUZW5zb3Iocyk6IFwiICsgZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5cyA9IGRhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhID0gZGF0YTtcbiAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIG1vZGVsIFwiICsgZXhjZXB0aW9uUHJlZml4ICsgXCIgZXhwZWN0cyBcIiArIG5hbWVzLmxlbmd0aCArIFwiIFRlbnNvcihzKSwgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBvbmx5IHJlY2VpdmVkIG9uZSBUZW5zb3IuIEZvdW5kOiBUZW5zb3Igd2l0aCBzaGFwZSBcIiArIGRhdGEuc2hhcGUpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheXMgPSBbZGF0YV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2ldO1xuICAgICAgICBpZiAoYXJyYXkuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBhcnJheXNbaV0gPSBLLmV4cGFuZERpbXMoYXJyYXksIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZXMgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoc2hhcGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpXTtcbiAgICAgICAgICAgIGlmIChhcnJheS5zaGFwZS5sZW5ndGggIT09IHNoYXBlc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIgKyBleGNlcHRpb25QcmVmaXggKyBcIjogZXhwZWN0ZWQgXCIgKyBuYW1lc1tpXSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwidG8gaGF2ZSBcIiArIHNoYXBlc1tpXS5sZW5ndGggKyBcIiBkaW1lbnNpb24ocykuIGJ1dCBnb3QgYXJyYXkgd2l0aCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoXCJzaGFwZSBcIiArIGFycmF5LnNoYXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYXBlc1tpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmICFjaGVja0JhdGNoQXhpcykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGFycmF5LnNoYXBlW2pdO1xuICAgICAgICAgICAgICAgIHZhciByZWZEaW0gPSBzaGFwZXNbaV1bal07XG4gICAgICAgICAgICAgICAgaWYgKHJlZkRpbSAhPSBudWxsICYmIHJlZkRpbSA+PSAwICYmIGRpbSAhPT0gcmVmRGltKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIiArIGV4Y2VwdGlvblByZWZpeCArIFwiOiBleHBlY3RlZCBcIiArIG5hbWVzW2ldICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwidG8gaGF2ZSBzaGFwZSBbXCIgKyBzaGFwZXNbaV0gKyBcIl0sIGJ1dCBnb3QgYXJyYXkgd2l0aCBzaGFwZSBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiW1wiICsgYXJyYXkuc2hhcGUgKyBcIl0uXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5cztcbn1cbmV4cG9ydHMuc3RhbmRhcmRpemVJbnB1dERhdGEgPSBzdGFuZGFyZGl6ZUlucHV0RGF0YTtcbmZ1bmN0aW9uIGNoZWNrQXJyYXlMZW5ndGhzKGlucHV0cywgdGFyZ2V0cywgd2VpZ2h0cykge1xuICAgIHZhciBzZXRYID0gZ2VuZXJpY191dGlsc18xLnVuaXF1ZShpbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuc2hhcGVbMF07IH0pKTtcbiAgICBzZXRYLnNvcnQoKTtcbiAgICB2YXIgc2V0WSA9IGdlbmVyaWNfdXRpbHNfMS51bmlxdWUodGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0LnNoYXBlWzBdOyB9KSk7XG4gICAgc2V0WS5zb3J0KCk7XG4gICAgaWYgKHNldFgubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkFsbCBpbnB1dCBUZW5zb3JzICh4KSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2FtcGxlcy4gXCIgK1xuICAgICAgICAgICAgXCJHb3QgYXJyYXkgc2hhcGVzOiBcIiArXG4gICAgICAgICAgICAoXCJcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5zaGFwZTsgfSkpKSk7XG4gICAgfVxuICAgIGlmIChzZXRZLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJBbGwgdGFyZ2V0IFRlbnNvcnMgKHkpIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzLiBcIiArXG4gICAgICAgICAgICBcIkdvdCBhcnJheSBzaGFwZXM6IFwiICtcbiAgICAgICAgICAgIChcIlwiICsgSlNPTi5zdHJpbmdpZnkodGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0LnNoYXBlOyB9KSkpKTtcbiAgICB9XG4gICAgaWYgKHNldFgubGVuZ3RoID4gMCAmJiBzZXRZLmxlbmd0aCA+IDAgJiYgIXRmanNfY29yZV8xLnV0aWwuYXJyYXlzRXF1YWwoc2V0WCwgc2V0WSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbnB1dCBUZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzIGFzIHRhcmdldCBcIiArXG4gICAgICAgICAgICAoXCJUZW5zb3JzLiBGb3VuZCBcIiArIHNldFhbMF0gKyBcIiBpbnB1dCBzYW1wbGUocykgYW5kIFwiICsgc2V0WVswXSArIFwiIHRhcmdldCBcIikgK1xuICAgICAgICAgICAgXCJzYW1wbGUocykuXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tBcnJheUxlbmd0aHMgPSBjaGVja0FycmF5TGVuZ3RocztcbmZ1bmN0aW9uIGNoZWNrTG9zc0FuZFRhcmdldENvbXBhdGliaWxpdHkodGFyZ2V0cywgbG9zc0Zucywgb3V0cHV0U2hhcGVzKSB7XG4gICAgdmFyIGtleUxvc3NlcyA9IFtcbiAgICAgICAgbG9zc2VzLm1lYW5TcXVhcmVkRXJyb3IsIGxvc3Nlcy5iaW5hcnlDcm9zc2VudHJvcHksXG4gICAgICAgIGxvc3Nlcy5jYXRlZ29yaWNhbENyb3NzZW50cm9weVxuICAgIF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB5ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgdmFyIGxvc3MgPSBsb3NzRm5zW2ldO1xuICAgICAgICB2YXIgc2hhcGUgPSBvdXRwdXRTaGFwZXNbaV07XG4gICAgICAgIGlmIChsb3NzID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3NzID09PSBsb3NzZXMuY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkpIHtcbiAgICAgICAgICAgIGlmICh5LnNoYXBlW3kuc2hhcGUubGVuZ3RoIC0gMV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIllvdSBhcmUgcGFzc2luZyBhIHRhcmdldCBhcnJheSBvZiBzaGFwZSBcIiArIHkuc2hhcGUgKyBcIiB3aGlsZSB1c2luZyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYSBsb3NzICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknLiAnY2F0ZWdvcmljYWxfY3Jvc3NlbnRyb3B5J1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RzIHRhcmdldHMgdG8gYmUgYmluYXJ5IG1hdHJpY2VzICgxcyBhbmQgMHMpIG9mIHNoYXBlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJbc2FtcGxlcywgY2xhc3Nlc10uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlMb3NzZXMuaW5kZXhPZihsb3NzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBzbGljZWRZU2hhcGUgPSB5LnNoYXBlLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIHNsaWNlZFNoYXBlID0gc2hhcGUuc2xpY2UoMSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNsaWNlZFlTaGFwZS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXREaW0gPSBzbGljZWRZU2hhcGVbal07XG4gICAgICAgICAgICAgICAgdmFyIG91dERpbSA9IHNsaWNlZFNoYXBlW2pdO1xuICAgICAgICAgICAgICAgIGlmIChvdXREaW0gIT0gbnVsbCAmJiB0YXJnZXREaW0gIT09IG91dERpbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkEgdGFyZ2V0IFRlbnNvciB3aXRoIHNoYXBlIFwiICsgeS5zaGFwZSArIFwiIHdhcyBwYXNzZWQgZm9yIGFuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIm91dHB1dCBvZiBzaGFwZSBcIiArIHNoYXBlICsgXCIsIHdoaWxlIHVzaW5nIGEgbG9zcyBmdW5jdGlvbiB0aGF0IFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdHMgdGFyZ2V0cyB0byBoYXZlIHRoZSBzYW1lIHNoYXBlIGFzIHRoZSBvdXRwdXQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VCYXRjaGVzKHNpemUsIGJhdGNoU2l6ZSkge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgYmF0Y2hTdGFydCA9IDA7XG4gICAgdmFyIGJhdGNoRW5kID0gbnVsbDtcbiAgICB3aGlsZSAoYmF0Y2hTdGFydCA8IHNpemUpIHtcbiAgICAgICAgYmF0Y2hFbmQgPSBiYXRjaFN0YXJ0ICsgYmF0Y2hTaXplO1xuICAgICAgICBpZiAoYmF0Y2hFbmQgPj0gc2l6ZSkge1xuICAgICAgICAgICAgYmF0Y2hFbmQgPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKFtiYXRjaFN0YXJ0LCBiYXRjaEVuZF0pO1xuICAgICAgICBiYXRjaFN0YXJ0ID0gYmF0Y2hFbmQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLm1ha2VCYXRjaGVzID0gbWFrZUJhdGNoZXM7XG5mdW5jdGlvbiBzbGljZUFycmF5cyhhcnJheXMsIHN0YXJ0LCBzdG9wKSB7XG4gICAgaWYgKGFycmF5cyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlzKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlzLm1hcChmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheSwgc3RhcnQsIHN0b3AgLSBzdGFydCk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheXMsIHN0YXJ0LCBzdG9wIC0gc3RhcnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNsaWNlQXJyYXlzQnlJbmRpY2VzKGFycmF5cywgaW5kaWNlcykge1xuICAgIHJldHVybiB0ZmMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhcnJheXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlzLm1hcChmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIHNsaWNlQXJyYXlzQnlJbmRpY2VzKGFycmF5LCBpbmRpY2VzKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSy5nYXRoZXIoYXJyYXlzLCBpbmRpY2VzLmR0eXBlID09PSAnaW50MzInID8gaW5kaWNlcyA6IGluZGljZXMudG9JbnQoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc2xpY2VBcnJheXNCeUluZGljZXMgPSBzbGljZUFycmF5c0J5SW5kaWNlcztcbmZ1bmN0aW9uIGNoZWNrSW5wdXREYXRhKGRhdGEsIG5hbWVzLCBzaGFwZXMsIGNoZWNrQmF0Y2hBeGlzLCBleGNlcHRpb25QcmVmaXgpIHtcbiAgICBpZiAoY2hlY2tCYXRjaEF4aXMgPT09IHZvaWQgMCkgeyBjaGVja0JhdGNoQXhpcyA9IHRydWU7IH1cbiAgICBpZiAoZXhjZXB0aW9uUHJlZml4ID09PSB2b2lkIDApIHsgZXhjZXB0aW9uUHJlZml4ID0gJyc7IH1cbiAgICB2YXIgYXJyYXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgXCIgKyBleGNlcHRpb25QcmVmaXggKyBcIjogdGhlIEFycmF5IG9mIFwiICtcbiAgICAgICAgICAgICAgICBcIlRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ0aGUgbW9kZWwgZXhwZWN0ZWQuIEV4cGVjdGVkIHRvIHNlZSBcIiArIG5hbWVzLmxlbmd0aCArIFwiIFRlbnNvcihzKSxcIikgK1xuICAgICAgICAgICAgICAgIChcIiBidXQgaW5zdGVhZCBnb3QgXCIgKyBkYXRhLmxlbmd0aCArIFwiIFRlbnNvcnMocykuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheXMgPSBkYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIG1vZGVsIGV4cGVjdHMgXCIgKyBuYW1lcy5sZW5ndGggKyBcIiBcIiArIGV4Y2VwdGlvblByZWZpeCArIFwiIFRlbnNvcnMsIFwiICtcbiAgICAgICAgICAgICAgICBcImJ1dCBvbmx5IHJlY2VpdmVkIG9uZSBUZW5zb3IuIEZvdW5kOiBhcnJheSB3aXRoIHNoYXBlIFwiICtcbiAgICAgICAgICAgICAgICAoSlNPTi5zdHJpbmdpZnkoZGF0YS5zaGFwZSkgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5cyA9IFtkYXRhXTtcbiAgICB9XG4gICAgaWYgKHNoYXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzaGFwZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2ldO1xuICAgICAgICAgICAgaWYgKGFycmF5LnNoYXBlLmxlbmd0aCAhPT0gc2hhcGVzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIiArIGV4Y2VwdGlvblByZWZpeCArIFwiOiBleHBlY3RlZCBcIiArIG5hbWVzW2ldICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJ0byBoYXZlIFwiICsgc2hhcGVzW2ldLmxlbmd0aCArIFwiIGRpbWVuc2lvbihzKSwgYnV0IGdvdCBhcnJheSB3aXRoIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChcInNoYXBlIFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyYXkuc2hhcGUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYXBlc1tpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwICYmICFjaGVja0JhdGNoQXhpcykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGFycmF5LnNoYXBlW2pdO1xuICAgICAgICAgICAgICAgIHZhciByZWZEaW0gPSBzaGFwZXNbaV1bal07XG4gICAgICAgICAgICAgICAgaWYgKHJlZkRpbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZEaW0gIT09IGRpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIFwiICsgZXhjZXB0aW9uUHJlZml4ICsgXCI6IGV4cGVjdGVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZXNbaV0gKyBcIiB0byBoYXZlIHNoYXBlIFwiICsgSlNPTi5zdHJpbmdpZnkoc2hhcGVzW2ldKSArIFwiIGJ1dCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImdvdCBhcnJheSB3aXRoIHNoYXBlIFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyYXkuc2hhcGUpICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RNZXRyaWNzKG1ldHJpY3MsIG91dHB1dE5hbWVzKSB7XG4gICAgaWYgKG1ldHJpY3MgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG1ldHJpY3MpICYmIG1ldHJpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXROYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdOyB9KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWV0cmljcykpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWV0cmljczsgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldHJpY3MgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmVzdGVkTWV0cmljcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG91dHB1dE5hbWVzXzEgPSBvdXRwdXROYW1lczsgX2kgPCBvdXRwdXROYW1lc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG5hbWVfMiA9IG91dHB1dE5hbWVzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIG91dHB1dE1ldHJpY3MgPSBtZXRyaWNzLmhhc093blByb3BlcnR5KG5hbWVfMikgPyBtZXRyaWNzW25hbWVfMl0gOiBbXTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvdXRwdXRNZXRyaWNzKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dE1ldHJpY3MgPSBbb3V0cHV0TWV0cmljc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXN0ZWRNZXRyaWNzLnB1c2gob3V0cHV0TWV0cmljcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZE1ldHJpY3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlIG9mIG1ldHJpY3MgYXJndW1lbnQgbm90IHVuZGVyc3Rvb2QuIEV4cGVjdGVkIGFuIEFycmF5IG9yICcgK1xuICAgICAgICAgICAgJ09iamVjdCwgZm91bmQ6ICcgKyBtZXRyaWNzKTtcbiAgICB9XG59XG52YXIgTW9kZWxMb2dnaW5nVmVyYm9zaXR5O1xuKGZ1bmN0aW9uIChNb2RlbExvZ2dpbmdWZXJib3NpdHkpIHtcbiAgICBNb2RlbExvZ2dpbmdWZXJib3NpdHlbTW9kZWxMb2dnaW5nVmVyYm9zaXR5W1wiU0lMRU5UXCJdID0gMF0gPSBcIlNJTEVOVFwiO1xuICAgIE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eVtNb2RlbExvZ2dpbmdWZXJib3NpdHlbXCJWRVJCT1NFXCJdID0gMV0gPSBcIlZFUkJPU0VcIjtcbn0pKE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuTW9kZWxMb2dnaW5nVmVyYm9zaXR5IHx8IChleHBvcnRzLk1vZGVsTG9nZ2luZ1ZlcmJvc2l0eSA9IHt9KSk7XG52YXIgTW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb2RlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb2RlbChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICB9XG4gICAgTW9kZWwucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb25maWcubG9zcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcubG9zcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9zcyA9IGNvbmZpZy5sb3NzO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5vcHRpbWl6ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGltaXplciA9IG9wdGltaXplcnMuZ2V0T3B0aW1pemVyKGNvbmZpZy5vcHRpbWl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoY29uZmlnLm9wdGltaXplciBpbnN0YW5jZW9mIHRmanNfY29yZV8xLk9wdGltaXplcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlVzZXItZGVmaW5lZCBvcHRpbWl6ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB0Zi5PcHRpbWl6ZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpbWl6ZXIgPSBjb25maWcub3B0aW1pemVyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb3NzRnVuY3Rpb25zID0gW107XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWcubG9zcykgJiYgdHlwZW9mIGNvbmZpZy5sb3NzICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5sb3NzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25maWcubG9zcyA9IGNvbmZpZy5sb3NzO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8zIGluIGNvbmZpZy5sb3NzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lXzMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlVua25vd24gZW50cnkgaW4gbG9zcyBkaWN0aW9uYXJ5OiBcXFwiXCIgKyBuYW1lXzMgKyBcIlxcXCIuIE9ubHkgZXhwZWN0IHRoZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJmb2xsb3dpbmcga2V5czogXCIgKyB0aGlzLm91dHB1dE5hbWVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV80IGluIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvc3NbbmFtZV80XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk91dHB1dCBcXFwiXCIgKyBuYW1lXzQgKyBcIlxcXCIgaXMgbWlzc2luZyBmcm9tIGxvc3MgZGljdGlvbmFyeS4gV2UgYXNzdW1lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGhpcyB3YXMgZG9uZSBvbiBwdXJwb3NlLCBhbmQgd2Ugd2lsbCBub3QgYmUgZXhwZWN0aW5nIGRhdGEgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwidG8gYmUgcGFzc2VkIHRvIFwiICsgbmFtZV80ICsgXCIgZHVyaW5nIHRyYWluaW5nXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9zc0Z1bmN0aW9ucy5wdXNoKGxvc3Nlcy5nZXQoY29uZmlnLmxvc3NbbmFtZV80XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmxvc3MpKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxvc3MubGVuZ3RoICE9PSB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJXaGVuIHBhc3NpbmcgYW4gQXJyYXkgYXMgbG9zcywgaXQgc2hvdWxkIGhhdmUgb25lIGVudHJ5IHBlciBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIm1vZGVsIG91dHB1dC4gVGhlIG1vZGVsIGhhcyBcIiArIHRoaXMub3V0cHV0cy5sZW5ndGggKyBcIiBvdXRwdXQocyksIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChcImJ1dCB5b3UgcGFzc2VkIGxvc3M9XCIgKyBjb25maWcubG9zcyArIFwiLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGhlTG9zc2VzID0gY29uZmlnLmxvc3M7XG4gICAgICAgICAgICBsb3NzRnVuY3Rpb25zID0gdGhlTG9zc2VzLm1hcChmdW5jdGlvbiAobCkgeyByZXR1cm4gbG9zc2VzLmdldChsKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbG9zc0Z1bmN0aW9uXzEgPSBsb3NzZXMuZ2V0KGNvbmZpZy5sb3NzKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbG9zc0Z1bmN0aW9ucy5wdXNoKGxvc3NGdW5jdGlvbl8xKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9zc0Z1bmN0aW9ucyA9IGxvc3NGdW5jdGlvbnM7XG4gICAgICAgIHRoaXMuZmVlZE91dHB1dE5hbWVzID0gW107XG4gICAgICAgIHRoaXMuZmVlZE91dHB1dFNoYXBlcyA9IFtdO1xuICAgICAgICB0aGlzLmZlZWRMb3NzRm5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmludGVybmFsT3V0cHV0U2hhcGVzW2ldO1xuICAgICAgICAgICAgdmFyIG5hbWVfNSA9IHRoaXMub3V0cHV0TmFtZXNbaV07XG4gICAgICAgICAgICB0aGlzLmZlZWRPdXRwdXROYW1lcy5wdXNoKG5hbWVfNSk7XG4gICAgICAgICAgICB0aGlzLmZlZWRPdXRwdXRTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICAgICAgICB0aGlzLmZlZWRMb3NzRm5zLnB1c2godGhpcy5sb3NzRnVuY3Rpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2tpcFRhcmdldEluZGljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXRyaWNzID0gY29uZmlnLm1ldHJpY3M7XG4gICAgICAgIHRoaXMubWV0cmljc05hbWVzID0gWydsb3NzJ107XG4gICAgICAgIHRoaXMubWV0cmljc1RlbnNvcnMgPSBbXTtcbiAgICAgICAgSy5uYW1lU2NvcGUoJ2xvc3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFRhcmdldEluZGljZXMuaW5kZXhPZihpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRlZExvc3MgPSBfdGhpcy5sb3NzRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vdXRwdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWV0cmljc1RlbnNvcnMucHVzaChbd2VpZ2h0ZWRMb3NzLCBpXSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1ldHJpY3NOYW1lcy5wdXNoKF90aGlzLm91dHB1dE5hbWVzW2ldICsgJ19sb3NzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5lc3RlZE1ldHJpY3MgPSBjb2xsZWN0TWV0cmljcyhjb25maWcubWV0cmljcywgdGhpcy5vdXRwdXROYW1lcyk7XG4gICAgICAgIHZhciBhcHBlbmRNZXRyaWMgPSBmdW5jdGlvbiAob3V0cHV0SW5kZXgsIG1ldHJpY05hbWUsIG1ldHJpY1RlbnNvcikge1xuICAgICAgICAgICAgaWYgKF90aGlzLm91dHB1dE5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNOYW1lID0gX3RoaXMub3V0cHV0TmFtZXNbb3V0cHV0SW5kZXhdICsgJ18nICsgbWV0cmljTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1ldHJpY3NOYW1lcy5wdXNoKG1ldHJpY05hbWUpO1xuICAgICAgICAgICAgX3RoaXMubWV0cmljc1RlbnNvcnMucHVzaChbbWV0cmljVGVuc29yLCBvdXRwdXRJbmRleF0pO1xuICAgICAgICB9O1xuICAgICAgICBLLm5hbWVTY29wZSgnbWV0cmljJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIGlmIChza2lwVGFyZ2V0SW5kaWNlcy5pbmRleE9mKGkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0TWV0cmljcyA9IG5lc3RlZE1ldHJpY3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU1ldHJpY3MgPSBmdW5jdGlvbiAobWV0cmljcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0cmljTmFtZVByZWZpeCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0cmljTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY0ZuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ZWRNZXRyaWNGbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoWydhY2N1cmFjeScsICdhY2MnLCAnY3Jvc3NlbnRyb3B5JywgJ2NlJ10uaW5kZXhPZihtZXRyaWMpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gX3RoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDFdID09PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvc3NGdW5jdGlvbnNbaV0gPT09IGxvc3Nlcy5iaW5hcnlDcm9zc2VudHJvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFsnYWNjdXJhY3knLCAnYWNjJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjRm4gPSBNZXRyaWNzLmJpbmFyeUFjY3VyYWN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFsnY3Jvc3NlbnRyb3B5JywgJ2NlJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjRm4gPSBNZXRyaWNzLmJpbmFyeUNyb3NzZW50cm9weTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5sb3NzRnVuY3Rpb25zW2ldID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3NzZXMuc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFsnYWNjdXJhY3knLCAnYWNjJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjRm4gPSBNZXRyaWNzLnNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoWydjcm9zc2VudHJvcHknLCAnY2UnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NGbiA9IE1ldHJpY3Muc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbJ2FjY3VyYWN5JywgJ2FjYyddLmluZGV4T2YobWV0cmljKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY0ZuID0gTWV0cmljcy5jYXRlZ29yaWNhbEFjY3VyYWN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFsnY3Jvc3NlbnRyb3B5JywgJ2NlJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjRm4gPSBNZXRyaWNzLmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWZmaXggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFsnYWNjdXJhY3knLCAnYWNjJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSAnYWNjJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoWydjcm9zc2VudHJvcHknLCAnY2UnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICdjZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodGVkTWV0cmljRm4gPSBhY2NGbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNOYW1lID0gbWV0cmljTmFtZVByZWZpeCArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRyaWNGbiA9IE1ldHJpY3MuZ2V0KG1ldHJpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ZWRNZXRyaWNGbiA9IG1ldHJpY0ZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY05hbWUgPSBtZXRyaWNOYW1lUHJlZml4ICsgbWV0cmljO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldHJpY1Jlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEsubmFtZVNjb3BlKG1ldHJpY05hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNSZXN1bHQgPSB3ZWlnaHRlZE1ldHJpY0ZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRNZXRyaWMoaSwgbWV0cmljTmFtZSwgbWV0cmljUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBtZXRyaWNzXzEgPSBtZXRyaWNzOyBfaSA8IG1ldHJpY3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRyaWMgPSBtZXRyaWNzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMihtZXRyaWMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBoYW5kbGVNZXRyaWNzKG91dHB1dE1ldHJpY3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMgPSB0aGlzLnRyYWluYWJsZVdlaWdodHM7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWluYWJsZVdlaWdodHMubGVuZ3RoICE9PVxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNjcmVwYW5jeSBiZXR3ZWVuIHRyYWluYWJsZXdlaWdodHMgYW5kIGNvbGxlY3RlZCB0cmFpbmFibGUgJyArXG4gICAgICAgICAgICAgICAgJ3dlaWdodHMuIERpZCB5b3Ugc2V0IGBtb2RlbC50cmFpbmFibGVgIHdpdGhvdXQgY2FsbGluZyAnICtcbiAgICAgICAgICAgICAgICAnYG1vZGVsLmNvbXBpbGUoKWAgYWZ0ZXJ3YXJkcz8nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHgsIHksIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbmZpZy5iYXRjaFNpemUgPT0gbnVsbCA/IDMyIDogY29uZmlnLmJhdGNoU2l6ZTtcbiAgICAgICAgdmFyIHN0YW5kYXJkaXplZE91dHMgPSB0aGlzLnN0YW5kYXJkaXplVXNlckRhdGEoeCwgeSwgdHJ1ZSwgYmF0Y2hTaXplKTtcbiAgICAgICAgdmFyIGlucyA9IHN0YW5kYXJkaXplZE91dHNbMF0uY29uY2F0KHN0YW5kYXJkaXplZE91dHNbMV0pO1xuICAgICAgICB0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKTtcbiAgICAgICAgdmFyIGYgPSB0aGlzLnRlc3RGdW5jdGlvbjtcbiAgICAgICAgdmFyIHRlc3RPdXRzID0gdGhpcy50ZXN0TG9vcChmLCBpbnMsIGJhdGNoU2l6ZSwgY29uZmlnLnZlcmJvc2UsIGNvbmZpZy5zdGVwcyk7XG4gICAgICAgIHJldHVybiBnZW5lcmljX3V0aWxzXzEuc2luZ2xldG9uT3JBcnJheSh0ZXN0T3V0cyk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuY2hlY2tOdW1TYW1wbGVzID0gZnVuY3Rpb24gKGlucywgYmF0Y2hTaXplLCBzdGVwcywgc3RlcHNOYW1lKSB7XG4gICAgICAgIGlmIChzdGVwc05hbWUgPT09IHZvaWQgMCkgeyBzdGVwc05hbWUgPSAnc3RlcHMnOyB9XG4gICAgICAgIHZhciBudW1TYW1wbGVzO1xuICAgICAgICBpZiAoc3RlcHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbnVtU2FtcGxlcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklmIFwiICsgc3RlcHNOYW1lICsgXCIgaXMgc2V0LCBiYXRjaFNpemUgbXVzdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkdvdCBiYXRjaFNpemUgPSBcIiArIGJhdGNoU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnMpKSB7XG4gICAgICAgICAgICAgICAgbnVtU2FtcGxlcyA9IGluc1swXS5zaGFwZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG51bVNhbXBsZXMgPSBpbnMuc2hhcGVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkVpdGhlciB0aGUgaW5wdXQgZGF0YSBzaG91bGQgaGF2ZSBhIGRlZmluZWQgc2hhcGUsIG9yIFwiICtcbiAgICAgICAgICAgICAgICAoc3RlcHNOYW1lICsgXCIgc2hvdWQgYmUgc3BlY2lmaWVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVNhbXBsZXM7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUucHJlZGljdExvb3AgPSBmdW5jdGlvbiAoaW5zLCBiYXRjaFNpemUsIHZlcmJvc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGJhdGNoU2l6ZSA9PT0gdm9pZCAwKSB7IGJhdGNoU2l6ZSA9IDMyOyB9XG4gICAgICAgIGlmICh2ZXJib3NlID09PSB2b2lkIDApIHsgdmVyYm9zZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBudW1TYW1wbGVzID0gdGhpcy5jaGVja051bVNhbXBsZXMoaW5zKTtcbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdWZXJib3NlIHByZWRpY3RMb29wKCkgaXMgbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmF0Y2hlcyA9IG1ha2VCYXRjaGVzKG51bVNhbXBsZXMsIGJhdGNoU2l6ZSk7XG4gICAgICAgIHZhciBvdXRzID0gW107XG4gICAgICAgIHZhciBfbG9vcF8zID0gZnVuY3Rpb24gKGJhdGNoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBiYXRjaE91dHMgPSB0ZmMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoU3RhcnQgPSBiYXRjaGVzW2JhdGNoSW5kZXhdWzBdO1xuICAgICAgICAgICAgICAgIHZhciBiYXRjaEVuZCA9IGJhdGNoZXNbYmF0Y2hJbmRleF1bMV07XG4gICAgICAgICAgICAgICAgdmFyIGluc0JhdGNoID0gc2xpY2VBcnJheXMoaW5zLCBiYXRjaFN0YXJ0LCBiYXRjaEVuZCk7XG4gICAgICAgICAgICAgICAgdmFyIGZlZWRzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zQmF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zQmF0Y2gubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlZWRzLnB1c2goeyBrZXk6IF90aGlzLmlucHV0c1tpXSwgdmFsdWU6IGluc0JhdGNoW2ldIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZWVkcy5wdXNoKHsga2V5OiBfdGhpcy5pbnB1dHNbMF0sIHZhbHVlOiBpbnNCYXRjaCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZlZWREaWN0ID0gbmV3IGV4ZWN1dG9yXzEuRmVlZERpY3QoZmVlZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRvcl8xLmV4ZWN1dGUoX3RoaXMub3V0cHV0cywgZmVlZERpY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYmF0Y2hJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYmF0Y2hPdXRzXzEgPSBiYXRjaE91dHM7IF9pIDwgYmF0Y2hPdXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaE91dCA9IGJhdGNoT3V0c18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cy5wdXNoKGJhdGNoT3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoT3V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRzW2ldID0gSy5jb25jYXRBbG9uZ0ZpcnN0QXhpcyhvdXRzW2ldLCBiYXRjaE91dHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgYmF0Y2hJbmRleCA9IDA7IGJhdGNoSW5kZXggPCBiYXRjaGVzLmxlbmd0aDsgKytiYXRjaEluZGV4KSB7XG4gICAgICAgICAgICBfbG9vcF8zKGJhdGNoSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmljX3V0aWxzXzEuc2luZ2xldG9uT3JBcnJheShvdXRzKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24gKHgsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgY2hlY2tJbnB1dERhdGEoeCwgdGhpcy5pbnB1dE5hbWVzLCB0aGlzLmZlZWRJbnB1dFNoYXBlcywgZmFsc2UpO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29uZmlnLmJhdGNoU2l6ZSA9PSBudWxsID8gMzIgOiBjb25maWcuYmF0Y2hTaXplO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVkaWN0TG9vcCh4LCBiYXRjaFNpemUpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnByZWRpY3RPbkJhdGNoID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgY2hlY2tJbnB1dERhdGEoeCwgdGhpcy5pbnB1dE5hbWVzLCB0aGlzLmZlZWRJbnB1dFNoYXBlcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWRpY3RMb29wKHgsIHguc2hhcGVbMF0pO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnN0YW5kYXJkaXplVXNlckRhdGEgPSBmdW5jdGlvbiAoeCwgeSwgY2hlY2tCYXRjaEF4aXMsIGJhdGNoU2l6ZSkge1xuICAgICAgICBpZiAoY2hlY2tCYXRjaEF4aXMgPT09IHZvaWQgMCkgeyBjaGVja0JhdGNoQXhpcyA9IHRydWU7IH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW1pemVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SdW50aW1lRXJyb3IoJ1lvdSBtdXN0IGNvbXBpbGUgYSBtb2RlbCBiZWZvcmUgdHJhaW5pbmcvdGVzdGluZy4gVXNlICcgK1xuICAgICAgICAgICAgICAgICdNb2RlbC5jb21waWxlKG1vZGVsQ29tcGlsZUNvbmZpZykuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dFNoYXBlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmVlZE91dHB1dFNoYXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gdGhpcy5mZWVkT3V0cHV0U2hhcGVzW2ldO1xuICAgICAgICAgICAgdmFyIGxvc3NGbiA9IHRoaXMuZmVlZExvc3NGbnNbaV07XG4gICAgICAgICAgICBpZiAobG9zc0ZuID09PSBsb3NzZXMuc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZXMucHVzaChvdXRwdXRTaGFwZS5zbGljZSgwLCBvdXRwdXRTaGFwZS5sZW5ndGggLSAxKS5jb25jYXQoWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZXMucHVzaChvdXRwdXRTaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeCA9IHN0YW5kYXJkaXplSW5wdXREYXRhKHgsIHRoaXMuZmVlZElucHV0TmFtZXMsIHRoaXMuZmVlZElucHV0U2hhcGVzLCBmYWxzZSwgJ2lucHV0Jyk7XG4gICAgICAgIHkgPSBzdGFuZGFyZGl6ZUlucHV0RGF0YSh5LCB0aGlzLmZlZWRPdXRwdXROYW1lcywgb3V0cHV0U2hhcGVzLCBmYWxzZSwgJ3RhcmdldCcpO1xuICAgICAgICBjaGVja0FycmF5TGVuZ3Rocyh4LCB5LCBudWxsKTtcbiAgICAgICAgY2hlY2tMb3NzQW5kVGFyZ2V0Q29tcGF0aWJpbGl0eSh5LCB0aGlzLmZlZWRMb3NzRm5zLCB0aGlzLmZlZWRPdXRwdXRTaGFwZXMpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZWZ1bCAmJiBiYXRjaFNpemUgIT0gbnVsbCAmJiBiYXRjaFNpemUgPiAwKSB7XG4gICAgICAgICAgICBpZiAoeFswXS5zaGFwZVswXSAlIGJhdGNoU2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW4gYSBzdGF0ZWZ1bCBuZXR3b3JrLCB5b3Ugc2hvdWxkIG9ubHkgcGFzcyBpbnB1dHMgd2l0aCBhIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXIgb2Ygc2FtcGxlcyB0aGF0IGlzIGRpdmlzaWJsZSBieSB0aGUgYmF0Y2ggc2l6ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIChiYXRjaFNpemUgKyBcIi4gRm91bmQ6IFwiICsgeFswXS5zaGFwZVswXSArIFwiIHNhbXBsZShzKS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgbnVsbF07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZml0TG9vcCA9IGZ1bmN0aW9uIChmLCBpbnMsIG91dExhYmVscywgYmF0Y2hTaXplLCBlcG9jaHMsIHZlcmJvc2UsIGNhbGxiYWNrcywgdmFsRiwgdmFsSW5zLCBzaHVmZmxlLCBjYWxsYmFja01ldHJpY3MsIGluaXRpYWxFcG9jaCwgc3RlcHNQZXJFcG9jaCwgdmFsaWRhdGlvblN0ZXBzKSB7XG4gICAgICAgIGlmIChpbml0aWFsRXBvY2ggPT09IHZvaWQgMCkgeyBpbml0aWFsRXBvY2ggPSAwOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZG9WYWxpZGF0aW9uLCBudW1UcmFpblNhbXBsZXMsIGluZGV4QXJyYXksIGNhbGxiYWNrTGlzdCwgX2xvb3BfNCwgdGhpc18xLCBlcG9jaCwgc3RhdGVfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaFNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZSA9IDMyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVwb2NocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBvY2hzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaHVmZmxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHVmZmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRXBvY2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxFcG9jaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb1ZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxGICE9IG51bGwgJiYgdmFsSW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25TdGVwcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9WYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcHNQZXJFcG9jaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdDYW4gb25seSB1c2UgYHZhbGlkYXRpb25TdGVwc2Agd2hlbiBkb2luZyBzdGVwLXdpc2UgdHJhaW5pbmcsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2kuZS4sIGBzdGVwc1BlckVwb2NoYCBtdXN0IGJlIHNldC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1UcmFpblNhbXBsZXMgPSB0aGlzLmNoZWNrTnVtU2FtcGxlcyhpbnMsIGJhdGNoU2l6ZSwgc3RlcHNQZXJFcG9jaCwgJ3N0ZXBzX3Blcl9lcG9jaCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bVRyYWluU2FtcGxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhBcnJheSA9IG1hdGhfdXRpbHNfMS5yYW5nZSgwLCBudW1UcmFpblNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IGNhbGxiYWNrc18xLkhpc3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IFtuZXcgY2FsbGJhY2tzXzEuQmFzZUxvZ2dlcigpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IFtuZXcgY2FsbGJhY2tzXzEuQmFzZUxvZ2dlcigpXS5jb25jYXQoY2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb25jYXQoW3RoaXMuaGlzdG9yeV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ1ZlcmJvc2UgbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tMaXN0ID0gbmV3IGNhbGxiYWNrc18xLkNhbGxiYWNrTGlzdChjYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tMaXN0LnNldE1vZGVsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tMaXN0LnNldFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBvY2hzOiBlcG9jaHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcHM6IHN0ZXBzUGVyRXBvY2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyYm9zZTogdmVyYm9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1ZhbGlkYXRpb246IGRvVmFsaWRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzOiBjYWxsYmFja01ldHJpY3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbGJhY2tMaXN0Lm9uVHJhaW5CZWdpbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wVHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzQgPSBmdW5jdGlvbiAoZXBvY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXBvY2hMb2dzLCBlcG9jaEluZGV4QXJyYXkxRF8xLCBiYXRjaGVzXzEsIF9sb29wXzUsIGJhdGNoSW5kZXgsIHN0YXRlXzI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgY2FsbGJhY2tMaXN0Lm9uRXBvY2hCZWdpbihlcG9jaCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcG9jaExvZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGVwc1BlckVwb2NoICE9IG51bGwpKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdzdGVwc1BlckVwb2NoIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2h1ZmZsZSA9PT0gJ2JhdGNoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignYmF0Y2ggc2h1ZmZsaW5nIGlzIG5vdCBpbXBsZW1uZXRlZCB5ZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2h1ZmZsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZmpzX2NvcmVfMS51dGlsLnNodWZmbGUoaW5kZXhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwb2NoSW5kZXhBcnJheTFEXzEgPSB0ZmpzX2NvcmVfMS50ZW5zb3IxZChpbmRleEFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaGVzXzEgPSBtYWtlQmF0Y2hlcyhudW1UcmFpblNhbXBsZXMsIGJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfNSA9IGZ1bmN0aW9uIChiYXRjaEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaExvZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoTG9ncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGNhbGxiYWNrTGlzdC5vbkJhdGNoQmVnaW4oYmF0Y2hJbmRleCwgYmF0Y2hMb2dzKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmYy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaFN0YXJ0ID0gYmF0Y2hlc18xW2JhdGNoSW5kZXhdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoRW5kID0gYmF0Y2hlc18xW2JhdGNoSW5kZXhdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoSWRzID0gSy5zbGljZUFsb25nRmlyc3RBeGlzKGVwb2NoSW5kZXhBcnJheTFEXzEsIGJhdGNoU3RhcnQsIGJhdGNoRW5kIC0gYmF0Y2hTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaExvZ3NbJ2JhdGNoJ10gPSBiYXRjaEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hMb2dzWydzaXplJ10gPSBiYXRjaEVuZCAtIGJhdGNoU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zQmF0Y2ggPSBzbGljZUFycmF5c0J5SW5kaWNlcyhpbnMsIGJhdGNoSWRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRzID0gZihpbnNCYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IG91dExhYmVsc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gb3V0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaExvZ3NbbGFiZWxdID0gb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmYy5rZWVwKG91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2hJbmRleCA9PT0gYmF0Y2hlc18xLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxPdXRzID0gX3RoaXMudGVzdExvb3AodmFsRiwgdmFsSW5zLCBiYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gb3V0TGFiZWxzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IHZhbE91dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZmMua2VlcChvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBvY2hMb2dzWyd2YWxfJyArIGxhYmVsXSA9IG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbGJhY2tMaXN0Lm9uQmF0Y2hFbmQoYmF0Y2hJbmRleCwgYmF0Y2hMb2dzKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc18xLmRpc3Bvc2VUZW5zb3JzSW5Mb2dzKGJhdGNoTG9ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzXzEuc3RvcFRyYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFwiYnJlYWtcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmF0Y2hJbmRleCA8IGJhdGNoZXNfMS5sZW5ndGgpKSByZXR1cm4gWzMsIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSwgX2xvb3BfNShiYXRjaEluZGV4KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMiA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2JhdGNoSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcG9jaEluZGV4QXJyYXkxRF8xLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbNCwgY2FsbGJhY2tMaXN0Lm9uRXBvY2hFbmQoZXBvY2gsIGVwb2NoTG9ncyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc18xLnN0b3BUcmFpbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFwiYnJlYWtcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBvY2ggPSBpbml0aWFsRXBvY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGVwb2NoIDwgZXBvY2hzKSkgcmV0dXJuIFszLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSwgX2xvb3BfNChlcG9jaCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICArK2Vwb2NoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQsIGNhbGxiYWNrTGlzdC5vblRyYWluRW5kKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuaGlzdG9yeS5zeW5jRGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmhpc3RvcnldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS50ZXN0TG9vcCA9IGZ1bmN0aW9uIChmLCBpbnMsIGJhdGNoU2l6ZSwgdmVyYm9zZSwgc3RlcHMpIHtcbiAgICAgICAgaWYgKHZlcmJvc2UgPT09IHZvaWQgMCkgeyB2ZXJib3NlID0gMDsgfVxuICAgICAgICB2YXIgbnVtU2FtcGxlcyA9IHRoaXMuY2hlY2tOdW1TYW1wbGVzKGlucywgYmF0Y2hTaXplLCBzdGVwcywgJ3N0ZXBzJyk7XG4gICAgICAgIHZhciBvdXRzID0gW107XG4gICAgICAgIGlmICh2ZXJib3NlID09PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignVmVyYm9zZSBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZXBzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdzdGVwcyBtb2RlIGluIHRlc3RMb29wKCkgaXMgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJhdGNoZXMgPSBtYWtlQmF0Y2hlcyhudW1TYW1wbGVzLCBiYXRjaFNpemUpO1xuICAgICAgICAgICAgdmFyIGluZGV4QXJyYXkgPSB0ZmpzX2NvcmVfMS50ZW5zb3IxZChtYXRoX3V0aWxzXzEucmFuZ2UoMCwgbnVtU2FtcGxlcykpO1xuICAgICAgICAgICAgZm9yICh2YXIgYmF0Y2hJbmRleCA9IDA7IGJhdGNoSW5kZXggPCBiYXRjaGVzLmxlbmd0aDsgKytiYXRjaEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoU3RhcnQgPSBiYXRjaGVzW2JhdGNoSW5kZXhdWzBdO1xuICAgICAgICAgICAgICAgIHZhciBiYXRjaEVuZCA9IGJhdGNoZXNbYmF0Y2hJbmRleF1bMV07XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoSWRzID0gSy5zbGljZUFsb25nRmlyc3RBeGlzKGluZGV4QXJyYXksIGJhdGNoU3RhcnQsIGJhdGNoRW5kIC0gYmF0Y2hTdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIGluc0JhdGNoID0gc2xpY2VBcnJheXNCeUluZGljZXMoaW5zLCBiYXRjaElkcyk7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoT3V0cyA9IGYoaW5zQmF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hPdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRzLnB1c2goSy5nZXRTY2FsYXIoMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hPdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaE91dCA9IGJhdGNoT3V0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgb3V0c1tpXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZmMuYWRkKG91dHNbaV0sIEsuc2NhbGFyVGltZXNBcnJheShLLmdldFNjYWxhcihiYXRjaEVuZCAtIGJhdGNoU3RhcnQpLCBiYXRjaE91dCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG91dHNbaV0gPSB0ZmMuZGl2KG91dHNbaV0sIEsuZ2V0U2NhbGFyKG51bVNhbXBsZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cztcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5nZXREZWR1cGVkTWV0cmljc05hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0TGFiZWxzID0gdGhpcy5tZXRyaWNzTmFtZXM7XG4gICAgICAgIHZhciBkZWR1cGVkT3V0TGFiZWxzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBvdXRMYWJlbHNbaV07XG4gICAgICAgICAgICB2YXIgbmV3TGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIGlmIChnZW5lcmljX3V0aWxzXzEuY291bnQob3V0TGFiZWxzLCBsYWJlbCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR1cEluZGV4ID0gZ2VuZXJpY191dGlsc18xLmNvdW50KG91dExhYmVscy5zbGljZSgwLCBpKSwgbGFiZWwpO1xuICAgICAgICAgICAgICAgIG5ld0xhYmVsICs9IFwiX1wiICsgZHVwSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWR1cGVkT3V0TGFiZWxzLnB1c2gobmV3TGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWR1cGVkT3V0TGFiZWxzO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm1ha2VUZXN0RnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGVzdEZ1bmN0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZmMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbE91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxMb3NzO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHMgPSBkYXRhLnNsaWNlKDAsIF90aGlzLmlucHV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRzID0gZGF0YS5zbGljZShfdGhpcy5pbnB1dHMubGVuZ3RoLCBfdGhpcy5pbnB1dHMubGVuZ3RoICsgX3RoaXMub3V0cHV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBmZWVkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWRzLnB1c2goeyBrZXk6IF90aGlzLmlucHV0c1tpXSwgdmFsdWU6IGlucHV0c1tpXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZlZWREaWN0ID0gbmV3IGV4ZWN1dG9yXzEuRmVlZERpY3QoZmVlZHMpO1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRzID0gZXhlY3V0b3JfMS5leGVjdXRlKF90aGlzLm91dHB1dHMsIGZlZWREaWN0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmxvc3NGdW5jdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvc3NGdW5jdGlvbiA9IF90aGlzLmxvc3NGdW5jdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb3NzID0gdGZjLm1lYW4obG9zc0Z1bmN0aW9uKHRhcmdldHNbaV0sIG91dHB1dHNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTG9zcyA9IGxvc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbExvc3MgPSB0ZmMuYWRkKHRvdGFsTG9zcywgbG9zcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsT3V0cHV0cy5wdXNoKHRvdGFsTG9zcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubWV0cmljc1RlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldHJpYyA9IF90aGlzLm1ldHJpY3NUZW5zb3JzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSBfdGhpcy5tZXRyaWNzVGVuc29yc1tpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lYW5NZXRyaWMgPSB0ZmMubWVhbihtZXRyaWModGFyZ2V0c1tvdXRwdXRJbmRleF0sIG91dHB1dHNbb3V0cHV0SW5kZXhdKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbE91dHB1dHMucHVzaChtZWFuTWV0cmljKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbE91dHB1dHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoeCwgeSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSwgc3RhbmRhcmRpemVkT3V0cywgaW5wdXRzLCB0YXJnZXRzLCBkb1ZhbGlkYXRpb24sIHZhbFgsIHZhbFksIHZhbElucywgbmVlZFZhbGlkYXRpb25EaXNwb3NhbCwgdmFsU3RhbmRhcmRpemVkLCBzcGxpdEF0LCBvcmlnaW5hbEJhdGNoU2l6ZSwgaW5zLCB0cmFpbkZ1bmN0aW9uLCBvdXRMYWJlbHMsIHZhbEZ1bmN0aW9uLCBjYWxsYmFja01ldHJpY3MsIGNhbGxiYWNrcywgb3V0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplID0gY29uZmlnLmJhdGNoU2l6ZSA9PSBudWxsID8gMzIgOiBjb25maWcuYmF0Y2hTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRpemVkT3V0cyA9IHRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YSh4LCB5LCBmYWxzZSwgYmF0Y2hTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cyA9IHN0YW5kYXJkaXplZE91dHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzID0gc3RhbmRhcmRpemVkT3V0c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZFZhbGlkYXRpb25EaXNwb3NhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy52YWxpZGF0aW9uRGF0YSAhPSBudWxsICYmIGNvbmZpZy52YWxpZGF0aW9uRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9WYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnZhbGlkYXRpb25EYXRhLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxYID0gY29uZmlnLnZhbGlkYXRpb25EYXRhWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxZID0gY29uZmlnLnZhbGlkYXRpb25EYXRhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25maWcudmFsaWRhdGlvbkRhdGEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCd2YWxpZGF0aW9uRGF0YSBpbmNsdWRpbmcgc2FtcGxlIHdlaWdodHMgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIldoZW4gcGFzc2luZyB2YWxpZGF0aW9uIGRhdGEsIGl0IG11c3QgY29udGFpbiAyICh2YWxYLCB2YWxZKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yIDMgKHZhbFgsIHZhbFksIHZhbFNhbXBsZVdlaWdodCkgaXRlbXM7IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25maWcudmFsaWRhdGlvbkRhdGEgKyBcIiBpcyBpbnZhbGlkLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFN0YW5kYXJkaXplZCA9IHRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YSh2YWxYLCB2YWxZLCB0cnVlLCBiYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFggPSB2YWxTdGFuZGFyZGl6ZWRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsWSA9IHZhbFN0YW5kYXJkaXplZFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxJbnMgPSB2YWxYLmNvbmNhdCh2YWxZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy52YWxpZGF0aW9uU3BsaXQgIT0gbnVsbCAmJiBjb25maWcudmFsaWRhdGlvblNwbGl0ID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy52YWxpZGF0aW9uU3BsaXQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9WYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEF0ID0gTWF0aC5mbG9vcihpbnB1dHNbMF0uc2hhcGVbMF0gKiAoMSAtIGNvbmZpZy52YWxpZGF0aW9uU3BsaXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEJhdGNoU2l6ZSA9IGlucHV0c1swXS5zaGFwZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxYID0gc2xpY2VBcnJheXMoaW5wdXRzLCBzcGxpdEF0LCBvcmlnaW5hbEJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzID0gc2xpY2VBcnJheXMoaW5wdXRzLCAwLCBzcGxpdEF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxZID0gc2xpY2VBcnJheXModGFyZ2V0cywgc3BsaXRBdCwgb3JpZ2luYWxCYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHMgPSBzbGljZUFycmF5cyh0YXJnZXRzLCAwLCBzcGxpdEF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkVmFsaWRhdGlvbkRpc3Bvc2FsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxJbnMgPSB2YWxYLmNvbmNhdCh2YWxZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy52YWxpZGF0aW9uU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnMgPSBpbnB1dHMuY29uY2F0KHRhcmdldHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1RyYWluYWJsZVdlaWdodHNDb25zaXN0ZW5jeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaW5GdW5jdGlvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvc3NlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb3NzVmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0cyA9IGRhdGEuc2xpY2UoMCwgX3RoaXMuaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBkYXRhLnNsaWNlKF90aGlzLmlucHV0cy5sZW5ndGgsIF90aGlzLmlucHV0cy5sZW5ndGggKyBfdGhpcy5vdXRwdXRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldHJpY3NWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxMb3NzRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZWVkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVlZHMucHVzaCh7IGtleTogX3RoaXMuaW5wdXRzW2ldLCB2YWx1ZTogaW5wdXRzW2ldIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZWVkRGljdCA9IG5ldyBleGVjdXRvcl8xLkZlZWREaWN0KGZlZWRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dHMgPSBleGVjdXRvcl8xLmV4ZWN1dGUoX3RoaXMub3V0cHV0cywgZmVlZERpY3QsIHsgJ3RyYWluaW5nJzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsTG9zcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5sb3NzRnVuY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9zc0Z1bmN0aW9uID0gX3RoaXMubG9zc0Z1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb3NzID0gbG9zc0Z1bmN0aW9uKHRhcmdldHNbaV0sIG91dHB1dHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9zc2VzLnB1c2gobG9zcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVhbkxvc3MgPSB0ZmMubWVhbihsb3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvc3NWYWx1ZXMucHVzaChtZWFuTG9zcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTG9zcyA9IGxvc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbExvc3MgPSB0ZmMuYWRkKHRvdGFsTG9zcywgbG9zcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5tZXRyaWNzVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldHJpYyA9IF90aGlzLm1ldHJpY3NUZW5zb3JzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gX3RoaXMubWV0cmljc1RlbnNvcnNbaV1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVhbk1ldHJpYyA9IHRmYy5tZWFuKG1ldHJpYyh0YXJnZXRzW291dHB1dEluZGV4XSwgb3V0cHV0c1tvdXRwdXRJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmYy5rZWVwKG1lYW5NZXRyaWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljc1ZhbHVlcy5wdXNoKG1lYW5NZXRyaWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTG9zcyA9IHRmYy5tZWFuKHRvdGFsTG9zcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGN1bGF0ZUxvc3NlcygpLmZvckVhY2goZnVuY3Rpb24gKHJlZ3VsYXJpemVyTG9zcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMb3NzID0gdGZjLmFkZCh0b3RhbExvc3MsIHJlZ3VsYXJpemVyTG9zcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG90YWxMb3NzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlcyA9IF90aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ucmVhZCgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuQ29zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsTG9zc1ZhbHVlID0gX3RoaXMub3B0aW1pemVyLm1pbmltaXplKHRvdGFsTG9zc0Z1bmN0aW9uLCByZXR1cm5Db3N0LCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdG90YWxMb3NzVmFsdWVdLmNvbmNhdChtZXRyaWNzVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRMYWJlbHMgPSB0aGlzLmdldERlZHVwZWRNZXRyaWNzTmFtZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxGdW5jdGlvbiA9IHRoaXMudGVzdEZ1bmN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWV0cmljcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dExhYmVscy5zbGljZSgpLmNvbmNhdChvdXRMYWJlbHMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiAndmFsXycgKyBuOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsSW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNZXRyaWNzID0gb3V0TGFiZWxzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBjYWxsYmFja3NfMS5zdGFuZGFyZGl6ZUNhbGxiYWNrcyhjb25maWcuY2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5maXRMb29wKHRyYWluRnVuY3Rpb24sIGlucywgb3V0TGFiZWxzLCBiYXRjaFNpemUsIGNvbmZpZy5lcG9jaHMsIGNvbmZpZy52ZXJib3NlLCBjYWxsYmFja3MsIHZhbEZ1bmN0aW9uLCB2YWxJbnMsIGNvbmZpZy5zaHVmZmxlLCBjYWxsYmFja01ldHJpY3MsIG51bGwsIG51bGwsIG51bGwpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRWYWxpZGF0aW9uRGlzcG9zYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxJbnMuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7IHJldHVybiB0ZW5zb3IuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7IHJldHVybiB0ZW5zb3IuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG91dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmdldE5hbWVkV2VpZ2h0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIG5hbWVkV2VpZ2h0cyA9IHt9O1xuICAgICAgICB2YXIgdHJhaW5hYmxlT25seSA9IGNvbmZpZyAhPSBudWxsICYmIGNvbmZpZy50cmFpbmFibGVPbmx5O1xuICAgICAgICB2YXIgd2VpZ2h0cyA9IHRyYWluYWJsZU9ubHkgPyB0aGlzLnRyYWluYWJsZVdlaWdodHMgOiB0aGlzLndlaWdodHM7XG4gICAgICAgIHZhciB3ZWlnaHRWYWx1ZXMgPSB0aGlzLmdldFdlaWdodHModHJhaW5hYmxlT25seSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRyYWluYWJsZU9ubHkgJiYgIXdlaWdodHNbaV0udHJhaW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lZFdlaWdodHNbd2VpZ2h0c1tpXS5vcmlnaW5hbE5hbWVdID0gd2VpZ2h0VmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lZFdlaWdodHM7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChoYW5kbGVyT3JVUkwsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcnMsIHdlaWdodERhdGFBbmRTcGVjcywgcmV0dXJuU3RyaW5nLCB1bnVzZWRBcmcsIG1vZGVsQ29uZmlnO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyT3JVUkwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgPSB0ZmpzX2NvcmVfMS5pby5nZXRTYXZlSGFuZGxlcnMoaGFuZGxlck9yVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiQ2Fubm90IGZpbmQgYW55IHNhdmUgaGFuZGxlcnMgZm9yIFVSTCAnXCIgKyBoYW5kbGVyT3JVUkwgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJGb3VuZCBtb3JlIHRoYW4gb25lIChcIiArIGhhbmRsZXJzLmxlbmd0aCArIFwiKSBzYXZlIGhhbmRsZXJzIGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJVUkwgJ1wiICsgaGFuZGxlck9yVVJMICsgXCInXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlck9yVVJMID0gaGFuZGxlcnNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlck9yVVJMLnNhdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdNb2RlbC5zYXZlKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgSU9IYW5kbGVyIHByb3ZpZGVkIGRvZXMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdub3QgaGF2ZSB0aGUgYHNhdmVgIGF0dHJpYnV0ZSBkZWZpbmVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0ZmpzX2NvcmVfMS5pby5lbmNvZGVXZWlnaHRzKHRoaXMuZ2V0TmFtZWRXZWlnaHRzKGNvbmZpZykpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RGF0YUFuZFNwZWNzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnVzZWRBcmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxDb25maWcgPSB0aGlzLnRvSlNPTih1bnVzZWRBcmcsIHJldHVyblN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGhhbmRsZXJPclVSTC5zYXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxUb3BvbG9neTogbW9kZWxDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodERhdGE6IHdlaWdodERhdGFBbmRTcGVjcy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRTcGVjczogd2VpZ2h0RGF0YUFuZFNwZWNzLnNwZWNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1vZGVsLmNsYXNzTmFtZSA9ICdNb2RlbCc7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdIH0pXG4gICAgXSwgTW9kZWwucHJvdG90eXBlLCBcImNvbXBpbGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGNvbmZpZ1BhcmFtSW5kaWNlczogWzJdIH0pXG4gICAgXSwgTW9kZWwucHJvdG90eXBlLCBcImV2YWx1YXRlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnLCBjb25maWdQYXJhbUluZGljZXM6IFsxXSB9KVxuICAgIF0sIE1vZGVsLnByb3RvdHlwZSwgXCJwcmVkaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgTW9kZWwucHJvdG90eXBlLCBcInByZWRpY3RPbkJhdGNoXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnLCBjb25maWdQYXJhbUluZGljZXM6IFsyXSB9KVxuICAgIF0sIE1vZGVsLnByb3RvdHlwZSwgXCJmaXRcIiwgbnVsbCk7XG4gICAgTW9kZWwgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIE1vZGVsKTtcbiAgICByZXR1cm4gTW9kZWw7XG59KHRvcG9sb2d5XzEuQ29udGFpbmVyKSk7XG5leHBvcnRzLk1vZGVsID0gTW9kZWw7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTW9kZWwpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhaW5pbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBdHRyaWJ1dGVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF0dHJpYnV0ZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBdHRyaWJ1dGVFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBdHRyaWJ1dGVFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQXR0cmlidXRlRXJyb3IgPSBBdHRyaWJ1dGVFcnJvcjtcbnZhciBSdW50aW1lRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSdW50aW1lRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUnVudGltZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSdW50aW1lRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUnVudGltZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5SdW50aW1lRXJyb3IgPSBSdW50aW1lRXJyb3I7XG52YXIgVmFsdWVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbHVlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFsdWVFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgVmFsdWVFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBWYWx1ZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5WYWx1ZUVycm9yID0gVmFsdWVFcnJvcjtcbnZhciBOb3RJbXBsZW1lbnRlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90SW1wbGVtZW50ZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RJbXBsZW1lbnRlZEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBOb3RJbXBsZW1lbnRlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5vdEltcGxlbWVudGVkRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLk5vdEltcGxlbWVudGVkRXJyb3IgPSBOb3RJbXBsZW1lbnRlZEVycm9yO1xudmFyIEFzc2VydGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNzZXJ0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEFzc2VydGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xudmFyIEluZGV4RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmRleEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluZGV4RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEluZGV4RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW5kZXhFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuSW5kZXhFcnJvciA9IEluZGV4RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIGNvbnN0cmFpbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdHJhaW50c1wiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIHRyYWluaW5nXzEgPSByZXF1aXJlKFwiLi9lbmdpbmUvdHJhaW5pbmdcIik7XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi9pbml0aWFsaXplcnNcIik7XG52YXIgYWR2YW5jZWRfYWN0aXZhdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2xheWVycy9hZHZhbmNlZF9hY3RpdmF0aW9uc1wiKTtcbnZhciBjb252b2x1dGlvbmFsXzEgPSByZXF1aXJlKFwiLi9sYXllcnMvY29udm9sdXRpb25hbFwiKTtcbnZhciBjb252b2x1dGlvbmFsX2RlcHRod2lzZV8xID0gcmVxdWlyZShcIi4vbGF5ZXJzL2NvbnZvbHV0aW9uYWxfZGVwdGh3aXNlXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2xheWVycy9jb3JlXCIpO1xudmFyIGVtYmVkZGluZ3NfMSA9IHJlcXVpcmUoXCIuL2xheWVycy9lbWJlZGRpbmdzXCIpO1xudmFyIG1lcmdlXzEgPSByZXF1aXJlKFwiLi9sYXllcnMvbWVyZ2VcIik7XG52YXIgbm9ybWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4vbGF5ZXJzL25vcm1hbGl6YXRpb25cIik7XG52YXIgcGFkZGluZ18xID0gcmVxdWlyZShcIi4vbGF5ZXJzL3BhZGRpbmdcIik7XG52YXIgcG9vbGluZ18xID0gcmVxdWlyZShcIi4vbGF5ZXJzL3Bvb2xpbmdcIik7XG52YXIgcmVjdXJyZW50XzEgPSByZXF1aXJlKFwiLi9sYXllcnMvcmVjdXJyZW50XCIpO1xudmFyIHdyYXBwZXJzXzEgPSByZXF1aXJlKFwiLi9sYXllcnMvd3JhcHBlcnNcIik7XG52YXIgbG9zc2VzXzEgPSByZXF1aXJlKFwiLi9sb3NzZXNcIik7XG52YXIgbWV0cmljc18xID0gcmVxdWlyZShcIi4vbWV0cmljc1wiKTtcbnZhciBtb2RlbHNfMSA9IHJlcXVpcmUoXCIuL21vZGVsc1wiKTtcbnZhciByZWd1bGFyaXplcnNfMSA9IHJlcXVpcmUoXCIuL3JlZ3VsYXJpemVyc1wiKTtcbnZhciBNb2RlbEV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGVsRXhwb3J0cygpIHtcbiAgICB9XG4gICAgTW9kZWxFeHBvcnRzLm1vZGVsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHRyYWluaW5nXzEuTW9kZWwoY29uZmlnKTtcbiAgICB9O1xuICAgIE1vZGVsRXhwb3J0cy5zZXF1ZW50aWFsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IG1vZGVsc18xLlNlcXVlbnRpYWwoY29uZmlnKTtcbiAgICB9O1xuICAgIE1vZGVsRXhwb3J0cy5sb2FkTW9kZWwgPSBmdW5jdGlvbiAocGF0aE9ySU9IYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBtb2RlbHNfMS5sb2FkTW9kZWxJbnRlcm5hbChwYXRoT3JJT0hhbmRsZXIpO1xuICAgIH07XG4gICAgTW9kZWxFeHBvcnRzLmlucHV0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdG9wb2xvZ3lfMS5JbnB1dChjb25maWcpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nLCBjb25maWdQYXJhbUluZGljZXM6IFswXSB9KVxuICAgIF0sIE1vZGVsRXhwb3J0cywgXCJtb2RlbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicsIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdIH0pXG4gICAgXSwgTW9kZWxFeHBvcnRzLCBcInNlcXVlbnRpYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTW9kZWxzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdMb2FkaW5nJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnbG9hZE1vZGVsSW50ZXJuYWwnXG4gICAgICAgIH0pXG4gICAgXSwgTW9kZWxFeHBvcnRzLCBcImxvYWRNb2RlbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdNb2RlbHMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0lucHV0cycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0lucHV0JyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTW9kZWxFeHBvcnRzLCBcImlucHV0XCIsIG51bGwpO1xuICAgIHJldHVybiBNb2RlbEV4cG9ydHM7XG59KCkpO1xuZXhwb3J0cy5Nb2RlbEV4cG9ydHMgPSBNb2RlbEV4cG9ydHM7XG52YXIgTGF5ZXJFeHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXllckV4cG9ydHMoKSB7XG4gICAgfVxuICAgIExheWVyRXhwb3J0cy5pbnB1dExheWVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHRvcG9sb2d5XzEuSW5wdXRMYXllcihjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmVsdSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhZHZhbmNlZF9hY3RpdmF0aW9uc18xLkVMVShjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmxlYWt5UmVMVSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhZHZhbmNlZF9hY3RpdmF0aW9uc18xLkxlYWt5UmVMVShjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLnNvZnRtYXggPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgYWR2YW5jZWRfYWN0aXZhdGlvbnNfMS5Tb2Z0bWF4KGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMudGhyZXNob2xkZWRSZUxVID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGFkdmFuY2VkX2FjdGl2YXRpb25zXzEuVGhyZXNob2xkZWRSZUxVKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuY29udjFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbnZvbHV0aW9uYWxfMS5Db252MUQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5jb252MmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29udm9sdXRpb25hbF8xLkNvbnYyRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmNvbnYyZFRyYW5zcG9zZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb252b2x1dGlvbmFsXzEuQ29udjJEVHJhbnNwb3NlKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuc2VwYXJhYmxlQ29udjJkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbnZvbHV0aW9uYWxfMS5TZXBhcmFibGVDb252MkQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5jcm9wcGluZzJEID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbnZvbHV0aW9uYWxfMS5Dcm9wcGluZzJEKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMudXBTYW1wbGluZzJkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbnZvbHV0aW9uYWxfMS5VcFNhbXBsaW5nMkQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5kZXB0aHdpc2VDb252MmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29udm9sdXRpb25hbF9kZXB0aHdpc2VfMS5EZXB0aHdpc2VDb252MkQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5hY3RpdmF0aW9uID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvcmVfMS5BY3RpdmF0aW9uKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuZGVuc2UgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29yZV8xLkRlbnNlKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuZHJvcG91dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlXzEuRHJvcG91dChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29yZV8xLkZsYXR0ZW4oY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5yZXBlYXRWZWN0b3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29yZV8xLlJlcGVhdFZlY3Rvcihjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLnJlc2hhcGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29yZV8xLlJlc2hhcGUoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5lbWJlZGRpbmcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgZW1iZWRkaW5nc18xLkVtYmVkZGluZyhjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmFkZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXJnZV8xLkFkZChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmF2ZXJhZ2UgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgbWVyZ2VfMS5BdmVyYWdlKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuY29uY2F0ZW5hdGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgbWVyZ2VfMS5Db25jYXRlbmF0ZShjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLm1heGltdW0gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgbWVyZ2VfMS5NYXhpbXVtKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMubWluaW11bSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXJnZV8xLk1pbmltdW0oY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5tdWx0aXBseSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXJnZV8xLk11bHRpcGx5KGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuYmF0Y2hOb3JtYWxpemF0aW9uID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IG5vcm1hbGl6YXRpb25fMS5CYXRjaE5vcm1hbGl6YXRpb24oY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy56ZXJvUGFkZGluZzJkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHBhZGRpbmdfMS5aZXJvUGFkZGluZzJEKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuYXZlcmFnZVBvb2xpbmcxZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwb29saW5nXzEuQXZlcmFnZVBvb2xpbmcxRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmF2Z1Bvb2wxZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIExheWVyRXhwb3J0cy5hdmVyYWdlUG9vbGluZzFkKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuYXZnUG9vbGluZzFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gTGF5ZXJFeHBvcnRzLmF2ZXJhZ2VQb29saW5nMWQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5hdmVyYWdlUG9vbGluZzJkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHBvb2xpbmdfMS5BdmVyYWdlUG9vbGluZzJEKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuYXZnUG9vbDJkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gTGF5ZXJFeHBvcnRzLmF2ZXJhZ2VQb29saW5nMmQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5hdmdQb29saW5nMmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBMYXllckV4cG9ydHMuYXZlcmFnZVBvb2xpbmcyZChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmdsb2JhbEF2ZXJhZ2VQb29saW5nMWQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9vbGluZ18xLkdsb2JhbEF2ZXJhZ2VQb29saW5nMUQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5nbG9iYWxBdmVyYWdlUG9vbGluZzJkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHBvb2xpbmdfMS5HbG9iYWxBdmVyYWdlUG9vbGluZzJEKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuZ2xvYmFsTWF4UG9vbGluZzFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHBvb2xpbmdfMS5HbG9iYWxNYXhQb29saW5nMUQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5nbG9iYWxNYXhQb29saW5nMmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9vbGluZ18xLkdsb2JhbE1heFBvb2xpbmcyRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLm1heFBvb2xpbmcxZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwb29saW5nXzEuTWF4UG9vbGluZzFEKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMubWF4UG9vbGluZzJkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHBvb2xpbmdfMS5NYXhQb29saW5nMkQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5ncnUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVjdXJyZW50XzEuR1JVKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuZ3J1Q2VsbCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWN1cnJlbnRfMS5HUlVDZWxsKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMubHN0bSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWN1cnJlbnRfMS5MU1RNKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMubHN0bUNlbGwgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVjdXJyZW50XzEuTFNUTUNlbGwoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5zaW1wbGVSTk4gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVjdXJyZW50XzEuU2ltcGxlUk5OKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuc2ltcGxlUk5OQ2VsbCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWN1cnJlbnRfMS5TaW1wbGVSTk5DZWxsKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMucm5uID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHJlY3VycmVudF8xLlJOTihjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLnN0YWNrZWRSTk5DZWxscyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWN1cnJlbnRfMS5TdGFja2VkUk5OQ2VsbHMoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5iaWRpcmVjdGlvbmFsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHdyYXBwZXJzXzEuQmlkaXJlY3Rpb25hbChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLnRpbWVEaXN0cmlidXRlZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3cmFwcGVyc18xLlRpbWVEaXN0cmlidXRlZChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLkxheWVyID0gdG9wb2xvZ3lfMS5MYXllcjtcbiAgICBMYXllckV4cG9ydHMuUk5OID0gcmVjdXJyZW50XzEuUk5OO1xuICAgIExheWVyRXhwb3J0cy5STk5DZWxsID0gcmVjdXJyZW50XzEuUk5OQ2VsbDtcbiAgICBMYXllckV4cG9ydHMuaW5wdXQgPSBNb2RlbEV4cG9ydHMuaW5wdXQ7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdJbnB1dHMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnSW5wdXRMYXllcicsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJpbnB1dExheWVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQWR2YW5jZWQgQWN0aXZhdGlvbicsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdFTFUnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiZWx1XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQWR2YW5jZWQgQWN0aXZhdGlvbicsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdMZWFreVJlTFUnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwibGVha3lSZUxVXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQWR2YW5jZWQgQWN0aXZhdGlvbicsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdTb2Z0bWF4JyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInNvZnRtYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdBZHZhbmNlZCBBY3RpdmF0aW9uJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1RocmVzaG9sZGVkUmVMVScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJ0aHJlc2hvbGRlZFJlTFVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbmFsJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0NvbnYxRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJjb252MWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbmFsJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0NvbnYyRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJjb252MmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbmFsJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0NvbnYyRFRyYW5zcG9zZScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJjb252MmRUcmFuc3Bvc2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbmFsJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1NlcGFyYWJsZUNvbnYyRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJzZXBhcmFibGVDb252MmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbmFsJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0Nyb3BwaW5nMkQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiY3JvcHBpbmcyRFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uYWwnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnVXBTYW1wbGluZzJEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInVwU2FtcGxpbmcyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uYWwnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnRGVwdGh3aXNlQ29udjJEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImRlcHRod2lzZUNvbnYyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0Jhc2ljJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0FjdGl2YXRpb24nLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiYWN0aXZhdGlvblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0Jhc2ljJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0RlbnNlJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImRlbnNlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQmFzaWMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnRHJvcG91dCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJkcm9wb3V0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQmFzaWMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnRmxhdHRlbicsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJmbGF0dGVuXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQmFzaWMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnUmVwZWF0VmVjdG9yJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInJlcGVhdFZlY3RvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0Jhc2ljJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1Jlc2hhcGUnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwicmVzaGFwZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0Jhc2ljJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0VtYmVkZGluZycsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJlbWJlZGRpbmdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdNZXJnZScsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdBZGQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiYWRkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnTWVyZ2UnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQXZlcmFnZScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJhdmVyYWdlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnTWVyZ2UnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQ29uY2F0ZW5hdGUnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiY29uY2F0ZW5hdGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdNZXJnZScsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdNYXhpbXVtJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcIm1heGltdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdNZXJnZScsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdNaW5pbXVtJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcIm1pbmltdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdNZXJnZScsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdNdWx0aXBseScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJtdWx0aXBseVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ05vcm1hbGl6YXRpb24nLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQmF0Y2hOb3JtYWxpemF0aW9uJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImJhdGNoTm9ybWFsaXphdGlvblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1BhZGRpbmcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnWmVyb1BhZGRpbmcyRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJ6ZXJvUGFkZGluZzJkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnUG9vbGluZycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdBdmVyYWdlUG9vbGluZzFEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImF2ZXJhZ2VQb29saW5nMWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdQb29saW5nJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0F2ZXJhZ2VQb29saW5nMkQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiYXZlcmFnZVBvb2xpbmcyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1Bvb2xpbmcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJnbG9iYWxBdmVyYWdlUG9vbGluZzFkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnUG9vbGluZycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdHbG9iYWxBdmVyYWdlUG9vbGluZzJEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImdsb2JhbEF2ZXJhZ2VQb29saW5nMmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdQb29saW5nJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0dsb2JhbE1heFBvb2xpbmcxRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJnbG9iYWxNYXhQb29saW5nMWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdQb29saW5nJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0dsb2JhbE1heFBvb2xpbmcyRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJnbG9iYWxNYXhQb29saW5nMmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdQb29saW5nJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ01heFBvb2xpbmcxRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJtYXhQb29saW5nMWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdQb29saW5nJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ01heFBvb2xpbmcyRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJtYXhQb29saW5nMmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdSZWN1cnJlbnQnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnR1JVJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImdydVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1JlY3VycmVudCcsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdHUlVDZWxsJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImdydUNlbGxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdSZWN1cnJlbnQnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnTFNUTScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJsc3RtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnUmVjdXJyZW50JyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0xTVE1DZWxsJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImxzdG1DZWxsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnUmVjdXJyZW50JyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1NpbXBsZVJOTicsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJzaW1wbGVSTk5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdSZWN1cnJlbnQnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnU2ltcGxlUk5OQ2VsbCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJzaW1wbGVSTk5DZWxsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnUmVjdXJyZW50JyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1JOTicsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJybm5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdSZWN1cnJlbnQnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnUk5OJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInN0YWNrZWRSTk5DZWxsc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1dyYXBwZXInLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQmlkaXJlY3Rpb25hbCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJiaWRpcmVjdGlvbmFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnV3JhcHBlcicsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdUaW1lRGlzdHJpYnV0ZWQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwidGltZURpc3RyaWJ1dGVkXCIsIG51bGwpO1xuICAgIHJldHVybiBMYXllckV4cG9ydHM7XG59KCkpO1xuZXhwb3J0cy5MYXllckV4cG9ydHMgPSBMYXllckV4cG9ydHM7XG52YXIgQ29uc3RyYWludEV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnN0cmFpbnRFeHBvcnRzKCkge1xuICAgIH1cbiAgICBDb25zdHJhaW50RXhwb3J0cy5tYXhOb3JtID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbnN0cmFpbnRzXzEuTWF4Tm9ybShjb25maWcpO1xuICAgIH07XG4gICAgQ29uc3RyYWludEV4cG9ydHMudW5pdE5vcm0gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29uc3RyYWludHNfMS5Vbml0Tm9ybShjb25maWcpO1xuICAgIH07XG4gICAgQ29uc3RyYWludEV4cG9ydHMubm9uTmVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGNvbnN0cmFpbnRzXzEuTm9uTmVnKCk7XG4gICAgfTtcbiAgICBDb25zdHJhaW50RXhwb3J0cy5taW5NYXhOb3JtID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbnN0cmFpbnRzXzEuTWluTWF4Tm9ybShjb25maWcpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnQ29uc3RyYWludHMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnY29uc3RyYWludHMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdNYXhOb3JtJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgQ29uc3RyYWludEV4cG9ydHMsIFwibWF4Tm9ybVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdDb25zdHJhaW50cycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdjb25zdHJhaW50cycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1VuaXROb3JtJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgQ29uc3RyYWludEV4cG9ydHMsIFwidW5pdE5vcm1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdDb25zdHJhaW50cycsIG5hbWVzcGFjZTogJ2NvbnN0cmFpbnRzJywgdXNlRG9jc0Zyb206ICdOb25OZWcnIH0pXG4gICAgXSwgQ29uc3RyYWludEV4cG9ydHMsIFwibm9uTmVnXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0NvbnN0cmFpbnRzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2NvbnN0cmFpbnRzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnTWluTWF4Tm9ybUNvbmZpZycsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIENvbnN0cmFpbnRFeHBvcnRzLCBcIm1pbk1heE5vcm1cIiwgbnVsbCk7XG4gICAgcmV0dXJuIENvbnN0cmFpbnRFeHBvcnRzO1xufSgpKTtcbmV4cG9ydHMuQ29uc3RyYWludEV4cG9ydHMgPSBDb25zdHJhaW50RXhwb3J0cztcbnZhciBJbml0aWFsaXplckV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVyRXhwb3J0cygpIHtcbiAgICB9XG4gICAgSW5pdGlhbGl6ZXJFeHBvcnRzLnplcm9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLlplcm9zKCk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMub25lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbml0aWFsaXplcnNfMS5PbmVzKCk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMuY29uc3RhbnQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuQ29uc3RhbnQoY29uZmlnKTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyRXhwb3J0cy5yYW5kb21Vbmlmb3JtID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLlJhbmRvbVVuaWZvcm0oY29uZmlnKTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyRXhwb3J0cy5yYW5kb21Ob3JtYWwgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuUmFuZG9tTm9ybWFsKGNvbmZpZyk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMudHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLlRydW5jYXRlZE5vcm1hbChjb25maWcpO1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXJFeHBvcnRzLmlkZW50aXR5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLklkZW50aXR5KGNvbmZpZyk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMudmFyaWFuY2VTY2FsaW5nID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLlZhcmlhbmNlU2NhbGluZyhjb25maWcpO1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXJFeHBvcnRzLmdsb3JvdFVuaWZvcm0gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuR2xvcm90VW5pZm9ybShjb25maWcpO1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXJFeHBvcnRzLmdsb3JvdE5vcm1hbCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbml0aWFsaXplcnNfMS5HbG9yb3ROb3JtYWwoY29uZmlnKTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyRXhwb3J0cy5oZU5vcm1hbCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbml0aWFsaXplcnNfMS5IZU5vcm1hbChjb25maWcpO1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXJFeHBvcnRzLmxlQ3VuTm9ybWFsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLkxlQ3VuTm9ybWFsKGNvbmZpZyk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMub3J0aG9nb25hbCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbml0aWFsaXplcnNfMS5PcnRob2dvbmFsKGNvbmZpZyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdJbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnWmVyb3MnXG4gICAgICAgIH0pXG4gICAgXSwgSW5pdGlhbGl6ZXJFeHBvcnRzLCBcInplcm9zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnSW5pdGlhbGl6ZXJzJywgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJywgdXNlRG9jc0Zyb206ICdPbmVzJyB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJvbmVzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdDb25zdGFudCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJjb25zdGFudFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdJbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnUmFuZG9tVW5pZm9ybScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJyYW5kb21Vbmlmb3JtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdSYW5kb21Ob3JtYWwnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBJbml0aWFsaXplckV4cG9ydHMsIFwicmFuZG9tTm9ybWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdUcnVuY2F0ZWROb3JtYWwnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBJbml0aWFsaXplckV4cG9ydHMsIFwidHJ1bmNhdGVkTm9ybWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdJZGVudGl0eScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJpZGVudGl0eVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdJbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnVmFyaWFuY2VTY2FsaW5nJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgSW5pdGlhbGl6ZXJFeHBvcnRzLCBcInZhcmlhbmNlU2NhbGluZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdJbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnR2xvcm90VW5pZm9ybScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJnbG9yb3RVbmlmb3JtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdHbG9yb3ROb3JtYWwnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBJbml0aWFsaXplckV4cG9ydHMsIFwiZ2xvcm90Tm9ybWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdIZU5vcm1hbCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJoZU5vcm1hbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdJbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnTGVDdW5Ob3JtYWwnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBJbml0aWFsaXplckV4cG9ydHMsIFwibGVDdW5Ob3JtYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnSW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2luaXRpYWxpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ09ydGhvZ29uYWwnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBJbml0aWFsaXplckV4cG9ydHMsIFwib3J0aG9nb25hbFwiLCBudWxsKTtcbiAgICByZXR1cm4gSW5pdGlhbGl6ZXJFeHBvcnRzO1xufSgpKTtcbmV4cG9ydHMuSW5pdGlhbGl6ZXJFeHBvcnRzID0gSW5pdGlhbGl6ZXJFeHBvcnRzO1xudmFyIE1ldHJpY0V4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ldHJpY0V4cG9ydHMoKSB7XG4gICAgfVxuICAgIE1ldHJpY0V4cG9ydHMuYmluYXJ5QWNjdXJhY3kgPSBmdW5jdGlvbiAoeVRydWUsIHlQcmVkKSB7XG4gICAgICAgIHJldHVybiBtZXRyaWNzXzEuYmluYXJ5QWNjdXJhY3koeVRydWUsIHlQcmVkKTtcbiAgICB9O1xuICAgIE1ldHJpY0V4cG9ydHMuYmluYXJ5Q3Jvc3NlbnRyb3B5ID0gZnVuY3Rpb24gKHlUcnVlLCB5UHJlZCkge1xuICAgICAgICByZXR1cm4gbWV0cmljc18xLmJpbmFyeUNyb3NzZW50cm9weSh5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5jYXRlZ29yaWNhbEFjY3VyYWN5ID0gZnVuY3Rpb24gKHlUcnVlLCB5UHJlZCkge1xuICAgICAgICByZXR1cm4gbWV0cmljc18xLmNhdGVnb3JpY2FsQWNjdXJhY3koeVRydWUsIHlQcmVkKTtcbiAgICB9O1xuICAgIE1ldHJpY0V4cG9ydHMuY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkgPSBmdW5jdGlvbiAoeVRydWUsIHlQcmVkKSB7XG4gICAgICAgIHJldHVybiBsb3NzZXNfMS5jYXRlZ29yaWNhbENyb3NzZW50cm9weSh5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5jb3NpbmVQcm94aW1pdHkgPSBmdW5jdGlvbiAoeVRydWUsIHlQcmVkKSB7XG4gICAgICAgIHJldHVybiBsb3NzZXNfMS5jb3NpbmVQcm94aW1pdHkoeVRydWUsIHlQcmVkKTtcbiAgICB9O1xuICAgIE1ldHJpY0V4cG9ydHMucHJvdG90eXBlLm1lYW5BYnNvbHV0ZUVycm9yID0gZnVuY3Rpb24gKHlUcnVlLCB5UHJlZCkge1xuICAgICAgICByZXR1cm4gbG9zc2VzXzEubWVhbkFic29sdXRlRXJyb3IoeVRydWUsIHlQcmVkKTtcbiAgICB9O1xuICAgIE1ldHJpY0V4cG9ydHMucHJvdG90eXBlLm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvciA9IGZ1bmN0aW9uICh5VHJ1ZSwgeVByZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvc3Nlc18xLm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcih5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5wcm90b3R5cGUuTUFQRSA9IGZ1bmN0aW9uICh5VHJ1ZSwgeVByZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvc3Nlc18xLm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcih5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5wcm90b3R5cGUubWFwZSA9IGZ1bmN0aW9uICh5VHJ1ZSwgeVByZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvc3Nlc18xLm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcih5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5tZWFuU3F1YXJlZEVycm9yID0gZnVuY3Rpb24gKHlUcnVlLCB5UHJlZCkge1xuICAgICAgICByZXR1cm4gbG9zc2VzXzEubWVhblNxdWFyZWRFcnJvcih5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5NU0UgPSBmdW5jdGlvbiAoeVRydWUsIHlQcmVkKSB7XG4gICAgICAgIHJldHVybiBsb3NzZXNfMS5tZWFuU3F1YXJlZEVycm9yKHlUcnVlLCB5UHJlZCk7XG4gICAgfTtcbiAgICBNZXRyaWNFeHBvcnRzLm1zZSA9IGZ1bmN0aW9uICh5VHJ1ZSwgeVByZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvc3Nlc18xLm1lYW5TcXVhcmVkRXJyb3IoeVRydWUsIHlQcmVkKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ01ldHJpY3MnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbWV0cmljcycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ21lYW5BYnNvbHV0ZUVycm9yJ1xuICAgICAgICB9KVxuICAgIF0sIE1ldHJpY0V4cG9ydHMucHJvdG90eXBlLCBcIm1lYW5BYnNvbHV0ZUVycm9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ01ldHJpY3MnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbWV0cmljcycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ21lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcidcbiAgICAgICAgfSlcbiAgICBdLCBNZXRyaWNFeHBvcnRzLnByb3RvdHlwZSwgXCJtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3JcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNZXRyaWNzJywgbmFtZXNwYWNlOiAnbWV0cmljcycsIHVzZURvY3NGcm9tOiAnYmluYXJ5QWNjdXJhY3knIH0pXG4gICAgXSwgTWV0cmljRXhwb3J0cywgXCJiaW5hcnlBY2N1cmFjeVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdNZXRyaWNzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ21ldHJpY3MnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdiaW5hcnlDcm9zc2VudHJvcHknXG4gICAgICAgIH0pXG4gICAgXSwgTWV0cmljRXhwb3J0cywgXCJiaW5hcnlDcm9zc2VudHJvcHlcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTWV0cmljcycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdtZXRyaWNzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnY2F0ZWdvcmljYWxBY2N1cmFjeSdcbiAgICAgICAgfSlcbiAgICBdLCBNZXRyaWNFeHBvcnRzLCBcImNhdGVnb3JpY2FsQWNjdXJhY3lcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTWV0cmljcycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdtZXRyaWNzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnY2F0ZWdvcmljYWxDcm9zc2VudHJvcHknXG4gICAgICAgIH0pXG4gICAgXSwgTWV0cmljRXhwb3J0cywgXCJjYXRlZ29yaWNhbENyb3NzZW50cm9weVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdNZXRyaWNzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ21ldHJpY3MnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdjb3NpbmVQcm94aW1pdHknXG4gICAgICAgIH0pXG4gICAgXSwgTWV0cmljRXhwb3J0cywgXCJjb3NpbmVQcm94aW1pdHlcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTWV0cmljcycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdtZXRyaWNzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnbWVhblNxdWFyZWRFcnJvcidcbiAgICAgICAgfSlcbiAgICBdLCBNZXRyaWNFeHBvcnRzLCBcIm1lYW5TcXVhcmVkRXJyb3JcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE1ldHJpY0V4cG9ydHM7XG59KCkpO1xuZXhwb3J0cy5NZXRyaWNFeHBvcnRzID0gTWV0cmljRXhwb3J0cztcbnZhciBSZWd1bGFyaXplckV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZ3VsYXJpemVyRXhwb3J0cygpIHtcbiAgICB9XG4gICAgUmVndWxhcml6ZXJFeHBvcnRzLmwxbDIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVndWxhcml6ZXJzXzEuTDFMMihjb25maWcpO1xuICAgIH07XG4gICAgUmVndWxhcml6ZXJFeHBvcnRzLmwxID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gcmVndWxhcml6ZXJzXzEubDEoY29uZmlnKTtcbiAgICB9O1xuICAgIFJlZ3VsYXJpemVyRXhwb3J0cy5sMiA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHJlZ3VsYXJpemVyc18xLmwyKGNvbmZpZyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdSZWd1bGFyaXplcnMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAncmVndWxhcml6ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnTDFMMicsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIFJlZ3VsYXJpemVyRXhwb3J0cywgXCJsMWwyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ1JlZ3VsYXJpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdyZWd1bGFyaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdMMUwyJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgUmVndWxhcml6ZXJFeHBvcnRzLCBcImwxXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ1JlZ3VsYXJpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdyZWd1bGFyaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdMMUwyJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgUmVndWxhcml6ZXJFeHBvcnRzLCBcImwyXCIsIG51bGwpO1xuICAgIHJldHVybiBSZWd1bGFyaXplckV4cG9ydHM7XG59KCkpO1xuZXhwb3J0cy5SZWd1bGFyaXplckV4cG9ydHMgPSBSZWd1bGFyaXplckV4cG9ydHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBvcnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4cG9ydHNfMSA9IHJlcXVpcmUoXCIuL2V4cG9ydHNcIik7XG52YXIgY2FsbGJhY2tzXzEgPSByZXF1aXJlKFwiLi9jYWxsYmFja3NcIik7XG5leHBvcnRzLkNhbGxiYWNrID0gY2FsbGJhY2tzXzEuQ2FsbGJhY2s7XG5leHBvcnRzLkNhbGxiYWNrTGlzdCA9IGNhbGxiYWNrc18xLkNhbGxiYWNrTGlzdDtcbmV4cG9ydHMuQ3VzdG9tQ2FsbGJhY2sgPSBjYWxsYmFja3NfMS5DdXN0b21DYWxsYmFjaztcbnZhciB0cmFpbmluZ18xID0gcmVxdWlyZShcIi4vZW5naW5lL3RyYWluaW5nXCIpO1xuZXhwb3J0cy5Nb2RlbCA9IHRyYWluaW5nXzEuTW9kZWw7XG52YXIgcmVjdXJyZW50XzEgPSByZXF1aXJlKFwiLi9sYXllcnMvcmVjdXJyZW50XCIpO1xuZXhwb3J0cy5STk4gPSByZWN1cnJlbnRfMS5STk47XG52YXIgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG5leHBvcnRzLlNlcXVlbnRpYWwgPSBtb2RlbHNfMS5TZXF1ZW50aWFsO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmV4cG9ydHMuU3ltYm9saWNUZW5zb3IgPSB0eXBlc18xLlN5bWJvbGljVGVuc29yO1xudmFyIHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5leHBvcnRzLnZlcnNpb25fbGF5ZXJzID0gdmVyc2lvbl8xLnZlcnNpb247XG5leHBvcnRzLm1vZGVsID0gZXhwb3J0c18xLk1vZGVsRXhwb3J0cy5tb2RlbDtcbmV4cG9ydHMuc2VxdWVudGlhbCA9IGV4cG9ydHNfMS5Nb2RlbEV4cG9ydHMuc2VxdWVudGlhbDtcbmV4cG9ydHMubG9hZE1vZGVsID0gZXhwb3J0c18xLk1vZGVsRXhwb3J0cy5sb2FkTW9kZWw7XG5leHBvcnRzLmlucHV0ID0gZXhwb3J0c18xLk1vZGVsRXhwb3J0cy5pbnB1dDtcbmV4cG9ydHMubGF5ZXJzID0gZXhwb3J0c18xLkxheWVyRXhwb3J0cztcbmV4cG9ydHMuY29uc3RyYWludHMgPSBleHBvcnRzXzEuQ29uc3RyYWludEV4cG9ydHM7XG5leHBvcnRzLmluaXRpYWxpemVycyA9IGV4cG9ydHNfMS5Jbml0aWFsaXplckV4cG9ydHM7XG5leHBvcnRzLm1ldHJpY3MgPSBleHBvcnRzXzEuTWV0cmljRXhwb3J0cztcbmV4cG9ydHMucmVndWxhcml6ZXJzID0gZXhwb3J0c18xLlJlZ3VsYXJpemVyRXhwb3J0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIG1hdGhfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL21hdGhfdXRpbHNcIik7XG5leHBvcnRzLlZBTElEX0ZBTl9NT0RFX1ZBTFVFUyA9IFsnZmFuSW4nLCAnZmFuT3V0JywgJ2ZhbkF2ZyddO1xuZnVuY3Rpb24gY2hlY2tGYW5Nb2RlKHZhbHVlKSB7XG4gICAgZ2VuZXJpY191dGlsc18xLmNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoZXhwb3J0cy5WQUxJRF9GQU5fTU9ERV9WQUxVRVMsICdGYW5Nb2RlJywgdmFsdWUpO1xufVxuZXhwb3J0cy5jaGVja0Zhbk1vZGUgPSBjaGVja0Zhbk1vZGU7XG5leHBvcnRzLlZBTElEX0RJU1RSSUJVVElPTl9WQUxVRVMgPSBbJ25vcm1hbCcsICd1bmlmb3JtJ107XG5mdW5jdGlvbiBjaGVja0Rpc3RyaWJ1dGlvbih2YWx1ZSkge1xuICAgIGdlbmVyaWNfdXRpbHNfMS5jaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKGV4cG9ydHMuVkFMSURfRElTVFJJQlVUSU9OX1ZBTFVFUywgJ0Rpc3RyaWJ1dGlvbicsIHZhbHVlKTtcbn1cbmV4cG9ydHMuY2hlY2tEaXN0cmlidXRpb24gPSBjaGVja0Rpc3RyaWJ1dGlvbjtcbnZhciBJbml0aWFsaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluaXRpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEluaXRpYWxpemVyLnByb3RvdHlwZS5mcm9tQ29uZmlnVXNlc0N1c3RvbU9iamVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdJbml0aWFsaXplcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIG5hbWVzcGFjZTogJ2luaXRpYWxpemVycycgfSlcbiAgICBdLCBJbml0aWFsaXplcik7XG4gICAgcmV0dXJuIEluaXRpYWxpemVyO1xufSh0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSkpO1xuZXhwb3J0cy5Jbml0aWFsaXplciA9IEluaXRpYWxpemVyO1xudmFyIFplcm9zID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWmVyb3MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWmVyb3MoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgWmVyb3MucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEuemVyb3Moc2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIFplcm9zLmNsYXNzTmFtZSA9ICdaZXJvcyc7XG4gICAgcmV0dXJuIFplcm9zO1xufShJbml0aWFsaXplcikpO1xuZXhwb3J0cy5aZXJvcyA9IFplcm9zO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFplcm9zKTtcbnZhciBPbmVzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT25lcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPbmVzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9uZXMucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEub25lcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgT25lcy5jbGFzc05hbWUgPSAnT25lcyc7XG4gICAgcmV0dXJuIE9uZXM7XG59KEluaXRpYWxpemVyKSk7XG5leHBvcnRzLk9uZXMgPSBPbmVzO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKE9uZXMpO1xudmFyIENvbnN0YW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uc3RhbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uc3RhbnQoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gY29uZmlnLnZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnN0YW50LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gSy5zY2FsYXJUaW1lc0FycmF5KHRmanNfY29yZV8xLnNjYWxhcihfdGhpcy52YWx1ZSksIHRmanNfY29yZV8xLm9uZXMoc2hhcGUsIGR0eXBlKSk7IH0pO1xuICAgIH07XG4gICAgQ29uc3RhbnQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29uc3RhbnQuY2xhc3NOYW1lID0gJ0NvbnN0YW50JztcbiAgICByZXR1cm4gQ29uc3RhbnQ7XG59KEluaXRpYWxpemVyKSk7XG5leHBvcnRzLkNvbnN0YW50ID0gQ29uc3RhbnQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoQ29uc3RhbnQpO1xudmFyIFJhbmRvbVVuaWZvcm0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYW5kb21Vbmlmb3JtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhbmRvbVVuaWZvcm0oY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfTUlOVkFMID0gLTAuMDU7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfTUFYVkFMID0gMC4wNTtcbiAgICAgICAgX3RoaXMubWludmFsID0gY29uZmlnLm1pbnZhbCB8fCBfdGhpcy5ERUZBVUxUX01JTlZBTDtcbiAgICAgICAgX3RoaXMubWF4dmFsID0gY29uZmlnLm1heHZhbCB8fCBfdGhpcy5ERUZBVUxUX01BWFZBTDtcbiAgICAgICAgX3RoaXMuc2VlZCA9IGNvbmZpZy5zZWVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJhbmRvbVVuaWZvcm0ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEucmFuZG9tVW5pZm9ybShzaGFwZSwgdGhpcy5taW52YWwsIHRoaXMubWF4dmFsLCBkdHlwZSk7XG4gICAgfTtcbiAgICBSYW5kb21Vbmlmb3JtLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IG1pbnZhbDogdGhpcy5taW52YWwsIG1heHZhbDogdGhpcy5tYXh2YWwsIHNlZWQ6IHRoaXMuc2VlZCB9O1xuICAgIH07XG4gICAgUmFuZG9tVW5pZm9ybS5jbGFzc05hbWUgPSAnUmFuZG9tVW5pZm9ybSc7XG4gICAgcmV0dXJuIFJhbmRvbVVuaWZvcm07XG59KEluaXRpYWxpemVyKSk7XG5leHBvcnRzLlJhbmRvbVVuaWZvcm0gPSBSYW5kb21Vbmlmb3JtO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFJhbmRvbVVuaWZvcm0pO1xudmFyIFJhbmRvbU5vcm1hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhbmRvbU5vcm1hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYW5kb21Ob3JtYWwoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfTUVBTiA9IDAuO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX1NURERFViA9IDAuMDU7XG4gICAgICAgIF90aGlzLm1lYW4gPSBjb25maWcubWVhbiB8fCBfdGhpcy5ERUZBVUxUX01FQU47XG4gICAgICAgIF90aGlzLnN0ZGRldiA9IGNvbmZpZy5zdGRkZXYgfHwgX3RoaXMuREVGQVVMVF9TVERERVY7XG4gICAgICAgIF90aGlzLnNlZWQgPSBjb25maWcuc2VlZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSYW5kb21Ob3JtYWwucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJyYW5kb21Ob3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBib29sLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSy5yYW5kb21Ob3JtYWwoc2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRkZXYsIGR0eXBlLCB0aGlzLnNlZWQpO1xuICAgIH07XG4gICAgUmFuZG9tTm9ybWFsLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IG1lYW46IHRoaXMubWVhbiwgc3RkZGV2OiB0aGlzLnN0ZGRldiwgc2VlZDogdGhpcy5zZWVkIH07XG4gICAgfTtcbiAgICBSYW5kb21Ob3JtYWwuY2xhc3NOYW1lID0gJ1JhbmRvbU5vcm1hbCc7XG4gICAgcmV0dXJuIFJhbmRvbU5vcm1hbDtcbn0oSW5pdGlhbGl6ZXIpKTtcbmV4cG9ydHMuUmFuZG9tTm9ybWFsID0gUmFuZG9tTm9ybWFsO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFJhbmRvbU5vcm1hbCk7XG52YXIgVHJ1bmNhdGVkTm9ybWFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJ1bmNhdGVkTm9ybWFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRydW5jYXRlZE5vcm1hbChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9NRUFOID0gMC47XG4gICAgICAgIF90aGlzLkRFRkFVTFRfU1REREVWID0gMC4wNTtcbiAgICAgICAgX3RoaXMubWVhbiA9IGNvbmZpZy5tZWFuIHx8IF90aGlzLkRFRkFVTFRfTUVBTjtcbiAgICAgICAgX3RoaXMuc3RkZGV2ID0gY29uZmlnLnN0ZGRldiB8fCBfdGhpcy5ERUZBVUxUX1NURERFVjtcbiAgICAgICAgX3RoaXMuc2VlZCA9IGNvbmZpZy5zZWVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRydW5jYXRlZE5vcm1hbC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcihcInRydW5jYXRlZE5vcm1hbCBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIGJvb2wuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50cnVuY2F0ZWROb3JtYWwoc2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRkZXYsIGR0eXBlLCB0aGlzLnNlZWQpO1xuICAgIH07XG4gICAgVHJ1bmNhdGVkTm9ybWFsLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IG1lYW46IHRoaXMubWVhbiwgc3RkZGV2OiB0aGlzLnN0ZGRldiwgc2VlZDogdGhpcy5zZWVkIH07XG4gICAgfTtcbiAgICBUcnVuY2F0ZWROb3JtYWwuY2xhc3NOYW1lID0gJ1RydW5jYXRlZE5vcm1hbCc7XG4gICAgcmV0dXJuIFRydW5jYXRlZE5vcm1hbDtcbn0oSW5pdGlhbGl6ZXIpKTtcbmV4cG9ydHMuVHJ1bmNhdGVkTm9ybWFsID0gVHJ1bmNhdGVkTm9ybWFsO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFRydW5jYXRlZE5vcm1hbCk7XG52YXIgSWRlbnRpdHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJZGVudGl0eSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZGVudGl0eShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZ2FpbiA9IGNvbmZpZy5nYWluICE9IG51bGwgPyB0ZmpzX2NvcmVfMS5zY2FsYXIoY29uZmlnLmdhaW4pIDogSy5nZXRTY2FsYXIoMS4wKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJZGVudGl0eS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzaGFwZS5sZW5ndGggIT09IDIgfHwgc2hhcGVbMF0gIT09IHNoYXBlWzFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0lkZW50aXR5IG1hdHJpeCBpbml0aWFsaXplciBjYW4gb25seSBiZSB1c2VkIGZvcicgK1xuICAgICAgICAgICAgICAgICAgICAnIDJEIHNxdWFyZSBtYXRyaWNlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBLLnNjYWxhclRpbWVzQXJyYXkoX3RoaXMuZ2FpbiwgdGZqc19jb3JlXzEuZXllKHNoYXBlWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSWRlbnRpdHkucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgZ2FpbjogdGhpcy5nYWluLmdldCgpIH07XG4gICAgfTtcbiAgICBJZGVudGl0eS5jbGFzc05hbWUgPSAnSWRlbnRpdHknO1xuICAgIHJldHVybiBJZGVudGl0eTtcbn0oSW5pdGlhbGl6ZXIpKTtcbmV4cG9ydHMuSWRlbnRpdHkgPSBJZGVudGl0eTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihJZGVudGl0eSk7XG5mdW5jdGlvbiBjb21wdXRlRmFucyhzaGFwZSwgZGF0YUZvcm1hdCkge1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0YUZvcm1hdCA9ICdjaGFubmVsc0xhc3QnOyB9XG4gICAgdmFyIGZhbkluO1xuICAgIHZhciBmYW5PdXQ7XG4gICAgY29tbW9uXzEuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZmFuSW4gPSBzaGFwZVswXTtcbiAgICAgICAgZmFuT3V0ID0gc2hhcGVbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKFszLCA0LCA1XS5pbmRleE9mKHNoYXBlLmxlbmd0aCkgIT09IC0xKSB7XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgIHZhciByZWNlcHRpdmVGaWVsZFNpemUgPSBtYXRoX3V0aWxzXzEuYXJyYXlQcm9kKHNoYXBlLCAyKTtcbiAgICAgICAgICAgIGZhbkluID0gc2hhcGVbMV0gKiByZWNlcHRpdmVGaWVsZFNpemU7XG4gICAgICAgICAgICBmYW5PdXQgPSBzaGFwZVswXSAqIHJlY2VwdGl2ZUZpZWxkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgdmFyIHJlY2VwdGl2ZUZpZWxkU2l6ZSA9IG1hdGhfdXRpbHNfMS5hcnJheVByb2Qoc2hhcGUsIDAsIHNoYXBlLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgZmFuSW4gPSBzaGFwZVtzaGFwZS5sZW5ndGggLSAyXSAqIHJlY2VwdGl2ZUZpZWxkU2l6ZTtcbiAgICAgICAgICAgIGZhbk91dCA9IHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdICogcmVjZXB0aXZlRmllbGRTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgc2hhcGVQcm9kID0gbWF0aF91dGlsc18xLmFycmF5UHJvZChzaGFwZSk7XG4gICAgICAgIGZhbkluID0gTWF0aC5zcXJ0KHNoYXBlUHJvZCk7XG4gICAgICAgIGZhbk91dCA9IE1hdGguc3FydChzaGFwZVByb2QpO1xuICAgIH1cbiAgICByZXR1cm4gW2ZhbkluLCBmYW5PdXRdO1xufVxudmFyIFZhcmlhbmNlU2NhbGluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhcmlhbmNlU2NhbGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWYXJpYW5jZVNjYWxpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGlmIChjb25maWcuc2NhbGUgPCAwLjApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwic2NhbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGZsb2F0LiBHb3Q6IFwiICsgY29uZmlnLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zY2FsZSA9IGNvbmZpZy5zY2FsZSA9PSBudWxsID8gMS4wIDogY29uZmlnLnNjYWxlO1xuICAgICAgICBfdGhpcy5tb2RlID0gY29uZmlnLm1vZGU7XG4gICAgICAgIGNoZWNrRmFuTW9kZShfdGhpcy5tb2RlKTtcbiAgICAgICAgX3RoaXMuZGlzdHJpYnV0aW9uID0gY29uZmlnLmRpc3RyaWJ1dGlvbjtcbiAgICAgICAgY2hlY2tEaXN0cmlidXRpb24oX3RoaXMuZGlzdHJpYnV0aW9uKTtcbiAgICAgICAgX3RoaXMuc2VlZCA9IGNvbmZpZy5zZWVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZhcmlhbmNlU2NhbGluZy5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHZhciBmYW5zID0gY29tcHV0ZUZhbnMoc2hhcGUpO1xuICAgICAgICB2YXIgZmFuSW4gPSBmYW5zWzBdO1xuICAgICAgICB2YXIgZmFuT3V0ID0gZmFuc1sxXTtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2ZhbkluJykge1xuICAgICAgICAgICAgc2NhbGUgLz0gTWF0aC5tYXgoMSwgZmFuSW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbk91dCcpIHtcbiAgICAgICAgICAgIHNjYWxlIC89IE1hdGgubWF4KDEsIGZhbk91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2FsZSAvPSBNYXRoLm1heCgxLCAoZmFuSW4gKyBmYW5PdXQpIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uID09PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgdmFyIHN0ZGRldiA9IE1hdGguc3FydChzY2FsZSk7XG4gICAgICAgICAgICBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKHRoaXMuZ2V0Q2xhc3NOYW1lKCkgKyBcIiBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIGJvb2wuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRydW5jYXRlZE5vcm1hbChzaGFwZSwgMCwgc3RkZGV2LCBkdHlwZSwgdGhpcy5zZWVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaW1pdCA9IE1hdGguc3FydCgzICogc2NhbGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnJhbmRvbVVuaWZvcm0oc2hhcGUsIC1saW1pdCwgbGltaXQsIGR0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmFyaWFuY2VTY2FsaW5nLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgIGRpc3RyaWJ1dGlvbjogdGhpcy5kaXN0cmlidXRpb24sXG4gICAgICAgICAgICBzZWVkOiB0aGlzLnNlZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWUgPSAnVmFyaWFuY2VTY2FsaW5nJztcbiAgICByZXR1cm4gVmFyaWFuY2VTY2FsaW5nO1xufShJbml0aWFsaXplcikpO1xuZXhwb3J0cy5WYXJpYW5jZVNjYWxpbmcgPSBWYXJpYW5jZVNjYWxpbmc7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoVmFyaWFuY2VTY2FsaW5nKTtcbnZhciBHbG9yb3RVbmlmb3JtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2xvcm90VW5pZm9ybSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHbG9yb3RVbmlmb3JtKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgc2NhbGU6IDEuMCxcbiAgICAgICAgICAgIG1vZGU6ICdmYW5BdmcnLFxuICAgICAgICAgICAgZGlzdHJpYnV0aW9uOiAndW5pZm9ybScsXG4gICAgICAgICAgICBzZWVkOiBjb25maWcgPT0gbnVsbCA/IG51bGwgOiBjb25maWcuc2VlZFxuICAgICAgICB9KSB8fCB0aGlzO1xuICAgIH1cbiAgICBHbG9yb3RVbmlmb3JtLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb3JvdFVuaWZvcm07XG59KFZhcmlhbmNlU2NhbGluZykpO1xuZXhwb3J0cy5HbG9yb3RVbmlmb3JtID0gR2xvcm90VW5pZm9ybTtcbnZhciBHbG9yb3ROb3JtYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHbG9yb3ROb3JtYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2xvcm90Tm9ybWFsKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgc2NhbGU6IDEuMCxcbiAgICAgICAgICAgIG1vZGU6ICdmYW5BdmcnLFxuICAgICAgICAgICAgZGlzdHJpYnV0aW9uOiAnbm9ybWFsJyxcbiAgICAgICAgICAgIHNlZWQ6IGNvbmZpZyA9PSBudWxsID8gbnVsbCA6IGNvbmZpZy5zZWVkXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgfVxuICAgIEdsb3JvdE5vcm1hbC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBHbG9yb3ROb3JtYWw7XG59KFZhcmlhbmNlU2NhbGluZykpO1xuZXhwb3J0cy5HbG9yb3ROb3JtYWwgPSBHbG9yb3ROb3JtYWw7XG52YXIgSGVOb3JtYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZU5vcm1hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZU5vcm1hbChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHNjYWxlOiAyLjAsXG4gICAgICAgICAgICBtb2RlOiAnZmFuSW4nLFxuICAgICAgICAgICAgZGlzdHJpYnV0aW9uOiAnbm9ybWFsJyxcbiAgICAgICAgICAgIHNlZWQ6IGNvbmZpZyA9PSBudWxsID8gbnVsbCA6IGNvbmZpZy5zZWVkXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgfVxuICAgIEhlTm9ybWFsLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEhlTm9ybWFsO1xufShWYXJpYW5jZVNjYWxpbmcpKTtcbmV4cG9ydHMuSGVOb3JtYWwgPSBIZU5vcm1hbDtcbnZhciBMZUN1bk5vcm1hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlQ3VuTm9ybWFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExlQ3VuTm9ybWFsKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgc2NhbGU6IDEuMCxcbiAgICAgICAgICAgIG1vZGU6ICdmYW5JbicsXG4gICAgICAgICAgICBkaXN0cmlidXRpb246ICdub3JtYWwnLFxuICAgICAgICAgICAgc2VlZDogY29uZmlnID09IG51bGwgPyBudWxsIDogY29uZmlnLnNlZWRcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICB9XG4gICAgTGVDdW5Ob3JtYWwucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gTGVDdW5Ob3JtYWw7XG59KFZhcmlhbmNlU2NhbGluZykpO1xuZXhwb3J0cy5MZUN1bk5vcm1hbCA9IExlQ3VuTm9ybWFsO1xudmFyIE9ydGhvZ29uYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPcnRob2dvbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ydGhvZ29uYWwoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfR0FJTiA9IDE7XG4gICAgICAgIF90aGlzLmdhaW4gPSBjb25maWcuZ2FpbiA9PSBudWxsID8gX3RoaXMuREVGQVVMVF9HQUlOIDogY29uZmlnLmdhaW47XG4gICAgICAgIF90aGlzLnNlZWQgPSBjb25maWcuc2VlZDtcbiAgICAgICAgaWYgKF90aGlzLnNlZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ1JhbmRvbSBzZWVkIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgT3J0aG9nb25hbCBJbml0aWFsaXplciB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPcnRob2dvbmFsLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdUaGUgT3J0aG9nb25hbCBJbml0aWFsaXplciBkb2VzIG5vdCBzdXBwb3J0IG5vbi0yRCBzaGFwZXMgeWV0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNoYXBlWzBdICogc2hhcGVbMV0gPiAyMDAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiT3J0aG9nb25hbCBpbml0aWFsaXplciBpcyBiZWluZyBjYWxsZWQgb24gYSBtYXRyaXggd2l0aCBtb3JlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwidGhhbiAyMDAwIChcIiArIHNoYXBlWzBdICogc2hhcGVbMV0gKyBcIikgZWxlbWVudHM6IFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiU2xvd25lc3MgbWF5IHJlc3VsdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFNoYXBlID0gc2hhcGVbMF0gPiBzaGFwZVsxXSA/IFtzaGFwZVsxXSwgc2hhcGVbMF1dIDogc2hhcGU7XG4gICAgICAgICAgICB2YXIgYSA9IEsucmFuZG9tTm9ybWFsKG5vcm1hbGl6ZWRTaGFwZSwgMCwgMSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgICAgIHZhciBxID0gdGZqc19jb3JlXzEubGluYWxnLmdyYW1TY2htaWR0KGEpO1xuICAgICAgICAgICAgaWYgKHNoYXBlWzBdID4gc2hhcGVbMV0pIHtcbiAgICAgICAgICAgICAgICBxID0gcS50cmFuc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBLLnNjYWxhclRpbWVzQXJyYXkoSy5nZXRTY2FsYXIoX3RoaXMuZ2FpbiksIHEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ydGhvZ29uYWwucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdhaW46IHRoaXMuZ2FpbixcbiAgICAgICAgICAgIHNlZWQ6IHRoaXMuc2VlZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ydGhvZ29uYWwuY2xhc3NOYW1lID0gJ09ydGhvZ29uYWwnO1xuICAgIHJldHVybiBPcnRob2dvbmFsO1xufShJbml0aWFsaXplcikpO1xuZXhwb3J0cy5PcnRob2dvbmFsID0gT3J0aG9nb25hbDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihPcnRob2dvbmFsKTtcbmV4cG9ydHMuSU5JVElBTElaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQID0ge1xuICAgICdjb25zdGFudCc6ICdDb25zdGFudCcsXG4gICAgJ2dsb3JvdE5vcm1hbCc6ICdHbG9yb3ROb3JtYWwnLFxuICAgICdnbG9yb3RVbmlmb3JtJzogJ0dsb3JvdFVuaWZvcm0nLFxuICAgICdoZU5vcm1hbCc6ICdIZU5vcm1hbCcsXG4gICAgJ2lkZW50aXR5JzogJ0lkZW50aXR5JyxcbiAgICAnbGVDdW5Ob3JtYWwnOiAnTGVDdW5Ob3JtYWwnLFxuICAgICdvbmVzJzogJ09uZXMnLFxuICAgICdvcnRob2dvbmFsJzogJ09ydGhvZ29uYWwnLFxuICAgICdyYW5kb21Ob3JtYWwnOiAnUmFuZG9tTm9ybWFsJyxcbiAgICAncmFuZG9tVW5pZm9ybSc6ICdSYW5kb21Vbmlmb3JtJyxcbiAgICAndHJ1bmNhdGVkTm9ybWFsJzogJ1RydW5jYXRlZE5vcm1hbCcsXG4gICAgJ3ZhcmlhbmNlU2NhbGluZyc6ICdWYXJpYW5jZVNjYWxpbmcnLFxuICAgICd6ZXJvcyc6ICdaZXJvcydcbn07XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUluaXRpYWxpemVyKGNvbmZpZywgY3VzdG9tT2JqZWN0cykge1xuICAgIGlmIChjdXN0b21PYmplY3RzID09PSB2b2lkIDApIHsgY3VzdG9tT2JqZWN0cyA9IHt9OyB9XG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHNfMS5kZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGNvbmZpZywgdGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCwgY3VzdG9tT2JqZWN0cywgJ2luaXRpYWxpemVyJyk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVJbml0aWFsaXplcihpbml0aWFsaXplcikge1xuICAgIHJldHVybiBnZW5lcmljX3V0aWxzXzEuc2VyaWFsaXplS2VyYXNPYmplY3QoaW5pdGlhbGl6ZXIpO1xufVxuZXhwb3J0cy5zZXJpYWxpemVJbml0aWFsaXplciA9IHNlcmlhbGl6ZUluaXRpYWxpemVyO1xuZnVuY3Rpb24gZ2V0SW5pdGlhbGl6ZXIoaWRlbnRpZmllcikge1xuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGlkZW50aWZpZXIgaW4gZXhwb3J0cy5JTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVAgP1xuICAgICAgICAgICAgZXhwb3J0cy5JTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbaWRlbnRpZmllcl0gOlxuICAgICAgICAgICAgaWRlbnRpZmllcjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJ0dsb3JvdFVuaWZvcm0nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdsb3JvdFVuaWZvcm0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc05hbWUgPT09ICdHbG9yb3ROb3JtYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdsb3JvdE5vcm1hbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gJ0hlTm9ybWFsJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZU5vcm1hbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gJ0xlQ3VuTm9ybWFsJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMZUN1bk5vcm1hbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGNvbmZpZzoge30gfTtcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZUluaXRpYWxpemVyKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaWRlbnRpZmllciBpbnN0YW5jZW9mIEluaXRpYWxpemVyKSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplSW5pdGlhbGl6ZXIoaWRlbnRpZmllcik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRJbml0aWFsaXplciA9IGdldEluaXRpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdGlhbGl6ZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIGFjdGl2YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vYWN0aXZhdGlvbnNcIik7XG52YXIgdGZqc19iYWNrZW5kXzEgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgdGZqc19iYWNrZW5kXzIgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBMZWFreVJlTFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMZWFreVJlTFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVha3lSZUxVKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcgPT0gbnVsbCA/IHt9IDogY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0FMUEhBID0gMC4zO1xuICAgICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmFscGhhID0gY29uZmlnLmFscGhhID09IG51bGwgPyBfdGhpcy5ERUZBVUxUX0FMUEhBIDogY29uZmlnLmFscGhhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExlYWt5UmVMVS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgeCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEubGVha3lSZWx1KHgsIHRoaXMuYWxwaGEpO1xuICAgIH07XG4gICAgTGVha3lSZUxVLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXRTaGFwZTtcbiAgICB9O1xuICAgIExlYWt5UmVMVS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0geyBhbHBoYTogdGhpcy5hbHBoYSB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIExlYWt5UmVMVS5jbGFzc05hbWUgPSAnTGVha3lSZUxVJztcbiAgICByZXR1cm4gTGVha3lSZUxVO1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLkxlYWt5UmVMVSA9IExlYWt5UmVMVTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihMZWFreVJlTFUpO1xudmFyIEVMVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVMVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFTFUoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZyA9PSBudWxsID8ge30gOiBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQUxQSEEgPSAxLjA7XG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5hbHBoYSAhPSBudWxsICYmIGNvbmZpZy5hbHBoYSAhPT0gX3RoaXMuREVGQVVMVF9BTFBIQSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJOb24tZGVmYXVsdCBhbHBoYSB2YWx1ZSAoXCIgKyBjb25maWcuYWxwaGEgKyBcIikgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIFwiRUxVIGxheWVyIHlldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYWxwaGEgPSBjb25maWcuYWxwaGEgPT0gbnVsbCA/IF90aGlzLkRFRkFVTFRfQUxQSEEgOiBjb25maWcuYWxwaGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRUxVLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciB4ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS5lbHUoeCk7XG4gICAgfTtcbiAgICBFTFUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dFNoYXBlO1xuICAgIH07XG4gICAgRUxVLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGFscGhhOiB0aGlzLmFscGhhIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgRUxVLmNsYXNzTmFtZSA9ICdFTFUnO1xuICAgIHJldHVybiBFTFU7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuRUxVID0gRUxVO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEVMVSk7XG52YXIgVGhyZXNob2xkZWRSZUxVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyZXNob2xkZWRSZUxVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocmVzaG9sZGVkUmVMVShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnID09IG51bGwgPyB7fSA6IGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9USEVUQSA9IDEuMDtcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy50aGV0YSA9IGNvbmZpZy50aGV0YSA9PSBudWxsID8gX3RoaXMuREVGQVVMVF9USEVUQSA6IGNvbmZpZy50aGV0YTtcbiAgICAgICAgX3RoaXMudGhldGFUZW5zb3IgPSB0ZmpzX2JhY2tlbmRfMi5nZXRTY2FsYXIoX3RoaXMudGhldGEpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRocmVzaG9sZGVkUmVMVS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgeCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICByZXR1cm4geC5tdWwodGZqc19iYWNrZW5kXzEuY2FzdCh4LmdyZWF0ZXIodGhpcy50aGV0YVRlbnNvciksICdmbG9hdDMyJykpO1xuICAgIH07XG4gICAgVGhyZXNob2xkZWRSZUxVLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXRTaGFwZTtcbiAgICB9O1xuICAgIFRocmVzaG9sZGVkUmVMVS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0geyB0aGV0YTogdGhpcy50aGV0YSB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIFRocmVzaG9sZGVkUmVMVS5jbGFzc05hbWUgPSAnVGhyZXNob2xkZWRSZUxVJztcbiAgICByZXR1cm4gVGhyZXNob2xkZWRSZUxVO1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLlRocmVzaG9sZGVkUmVMVSA9IFRocmVzaG9sZGVkUmVMVTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihUaHJlc2hvbGRlZFJlTFUpO1xudmFyIFNvZnRtYXggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXgoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZyA9PSBudWxsID8ge30gOiBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQVhJUyA9IDEuMDtcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zb2Z0bWF4ID0gbmV3IGFjdGl2YXRpb25zXzEuU29mdG1heCgpLmFwcGx5O1xuICAgICAgICBfdGhpcy5heGlzID0gY29uZmlnLmF4aXMgPT0gbnVsbCA/IF90aGlzLkRFRkFVTFRfQVhJUyA6IGNvbmZpZy5heGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNvZnRtYXgucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIHggPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29mdG1heCh4LCB0aGlzLmF4aXMpO1xuICAgIH07XG4gICAgU29mdG1heC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0U2hhcGU7XG4gICAgfTtcbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGF4aXM6IHRoaXMuYXhpcyB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIFNvZnRtYXguY2xhc3NOYW1lID0gJ1NvZnRtYXgnO1xuICAgIHJldHVybiBTb2Z0bWF4O1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLlNvZnRtYXggPSBTb2Z0bWF4O1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFNvZnRtYXgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWR2YW5jZWRfYWN0aXZhdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBhY3RpdmF0aW9uc18xID0gcmVxdWlyZShcIi4uL2FjdGl2YXRpb25zXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvY29tbW9uXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgY29tbW9uXzIgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIGNvbnN0cmFpbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RyYWludHNcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGluaXRpYWxpemVyc18xID0gcmVxdWlyZShcIi4uL2luaXRpYWxpemVyc1wiKTtcbnZhciByZWd1bGFyaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9yZWd1bGFyaXplcnNcIik7XG52YXIgY29udl91dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbnZfdXRpbHNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xuZnVuY3Rpb24gcHJlcHJvY2Vzc0NvbnYyRElucHV0KHgsIGRhdGFGb3JtYXQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRmYy50cmFuc3Bvc2UoeCwgWzAsIDIsIDMsIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnByZXByb2Nlc3NDb252MkRJbnB1dCA9IHByZXByb2Nlc3NDb252MkRJbnB1dDtcbmZ1bmN0aW9uIGNvbnYxZFdpdGhCaWFzKHgsIGtlcm5lbCwgYmlhcywgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgZGlsYXRpb25SYXRlKSB7XG4gICAgaWYgKHN0cmlkZXMgPT09IHZvaWQgMCkgeyBzdHJpZGVzID0gMTsgfVxuICAgIGlmIChwYWRkaW5nID09PSB2b2lkIDApIHsgcGFkZGluZyA9ICd2YWxpZCc7IH1cbiAgICBpZiAoZGlsYXRpb25SYXRlID09PSB2b2lkIDApIHsgZGlsYXRpb25SYXRlID0gMTsgfVxuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YUZvcm1hdCA9IGNvbW1vbl8xLmltYWdlRGF0YUZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAgICAgaWYgKHguc2hhcGUubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSBpbnB1dCBvZiBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMywgYnV0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAoeC5zaGFwZS5sZW5ndGggKyBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlcm5lbC5zaGFwZS5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIGtlcm5lbCBmb3IgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDMsIGJ1dCBpcyBcIiArXG4gICAgICAgICAgICAgICAgKGtlcm5lbC5zaGFwZS5sZW5ndGggKyBcIiBpbnN0ZWFkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmlhcyAhPSBudWxsICYmIGJpYXMuc2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSBiaWFzIGZvciBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMSwgYnV0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAoa2VybmVsLnNoYXBlLmxlbmd0aCArIFwiIGluc3RlYWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgIHggPSB0ZmMudHJhbnNwb3NlKHgsIFswLCAyLCAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmcgPT09ICdjYXVzYWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjFkV2l0aEJpYXMgaXMgbm90ICcgK1xuICAgICAgICAgICAgICAgICdpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSB0ZmMuY29udjFkKHgsIGtlcm5lbCwgc3RyaWRlcywgcGFkZGluZyA9PT0gJ3NhbWUnID8gJ3NhbWUnIDogJ3ZhbGlkJywgJ05XQycsIGRpbGF0aW9uUmF0ZSk7XG4gICAgICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHkgPSBLLmJpYXNBZGQoeSwgYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbnYxZFdpdGhCaWFzID0gY29udjFkV2l0aEJpYXM7XG5mdW5jdGlvbiBjb252MWQoeCwga2VybmVsLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCBkaWxhdGlvblJhdGUpIHtcbiAgICBpZiAoc3RyaWRlcyA9PT0gdm9pZCAwKSB7IHN0cmlkZXMgPSAxOyB9XG4gICAgaWYgKHBhZGRpbmcgPT09IHZvaWQgMCkgeyBwYWRkaW5nID0gJ3ZhbGlkJzsgfVxuICAgIGlmIChkaWxhdGlvblJhdGUgPT09IHZvaWQgMCkgeyBkaWxhdGlvblJhdGUgPSAxOyB9XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgICAgIHJldHVybiBjb252MWRXaXRoQmlhcyh4LCBrZXJuZWwsIG51bGwsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsIGRpbGF0aW9uUmF0ZSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbnYxZCA9IGNvbnYxZDtcbmZ1bmN0aW9uIGNvbnYyZCh4LCBrZXJuZWwsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsIGRpbGF0aW9uUmF0ZSkge1xuICAgIGlmIChzdHJpZGVzID09PSB2b2lkIDApIHsgc3RyaWRlcyA9IFsxLCAxXTsgfVxuICAgIGlmIChwYWRkaW5nID09PSB2b2lkIDApIHsgcGFkZGluZyA9ICd2YWxpZCc7IH1cbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIGNvbnYyZFdpdGhCaWFzKHgsIGtlcm5lbCwgbnVsbCwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgZGlsYXRpb25SYXRlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29udjJkID0gY29udjJkO1xuZnVuY3Rpb24gY29udjJkV2l0aEJpYXMoeCwga2VybmVsLCBiaWFzLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCBkaWxhdGlvblJhdGUpIHtcbiAgICBpZiAoc3RyaWRlcyA9PT0gdm9pZCAwKSB7IHN0cmlkZXMgPSBbMSwgMV07IH1cbiAgICBpZiAocGFkZGluZyA9PT0gdm9pZCAwKSB7IHBhZGRpbmcgPSAndmFsaWQnOyB9XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhRm9ybWF0ID0gY29tbW9uXzEuaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uXzIuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgICAgICBpZiAoeC5yYW5rICE9PSAzICYmIHgucmFuayAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJjb252MmRXaXRoQmlhcyBleHBlY3RzIGlucHV0IHRvIGJlIG9mIHJhbmsgMyBvciA0LCBidXQgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXJuZWwucmFuayAhPT0gMyAmJiBrZXJuZWwucmFuayAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJjb252MmRXaXRoQmlhcyBleHBlY3RzIGtlcm5lbCB0byBiZSBvZiByYW5rIDMgb3IgNCwgYnV0IHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAoeC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeSA9IHByZXByb2Nlc3NDb252MkRJbnB1dCh4LCBkYXRhRm9ybWF0KTtcbiAgICAgICAgaWYgKHBhZGRpbmcgPT09ICdjYXVzYWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjFkV2l0aEJpYXMgaXMgbm90ICcgK1xuICAgICAgICAgICAgICAgICdpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgeSA9IHRmYy5jb252MmQoeSwga2VybmVsLCBzdHJpZGVzLCBwYWRkaW5nID09PSAnc2FtZScgPyAnc2FtZScgOiAndmFsaWQnLCAnTkhXQycsIGRpbGF0aW9uUmF0ZSk7XG4gICAgICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHkgPSBLLmJpYXNBZGQoeSwgYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgeSA9IHRmYy50cmFuc3Bvc2UoeSwgWzAsIDMsIDEsIDJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29udjJkV2l0aEJpYXMgPSBjb252MmRXaXRoQmlhcztcbnZhciBDb252ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252KHJhbmssIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmtlcm5lbCA9IG51bGw7XG4gICAgICAgIF90aGlzLmJpYXMgPSBudWxsO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiA9ICdnbG9yb3ROb3JtYWwnO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIgPSAnemVyb3MnO1xuICAgICAgICBfdGhpcy5yYW5rID0gcmFuaztcbiAgICAgICAgaWYgKF90aGlzLnJhbmsgIT09IDEgJiYgX3RoaXMucmFuayAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJDb252b2x1dGlvbiBsYXllciBmb3IgcmFuayBvdGhlciB0aGFuIDEgb3IgMiAoXCIgKyBfdGhpcy5yYW5rICsgXCIpIGlzIFwiICtcbiAgICAgICAgICAgICAgICBcIm5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmZpbHRlcnMgPSBjb25maWcuZmlsdGVycztcbiAgICAgICAgX3RoaXMua2VybmVsU2l6ZSA9IGNvbnZfdXRpbHNfMS5ub3JtYWxpemVBcnJheShjb25maWcua2VybmVsU2l6ZSwgcmFuaywgJ2tlcm5lbFNpemUnKTtcbiAgICAgICAgX3RoaXMuc3RyaWRlcyA9IGNvbnZfdXRpbHNfMS5ub3JtYWxpemVBcnJheShjb25maWcuc3RyaWRlcyA9PSBudWxsID8gMSA6IGNvbmZpZy5zdHJpZGVzLCByYW5rLCAnc3RyaWRlcycpO1xuICAgICAgICBfdGhpcy5wYWRkaW5nID0gY29uZmlnLnBhZGRpbmcgPT0gbnVsbCA/ICd2YWxpZCcgOiBjb25maWcucGFkZGluZztcbiAgICAgICAgY29tbW9uXzIuY2hlY2tQYWRkaW5nTW9kZShfdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgX3RoaXMuZGF0YUZvcm1hdCA9XG4gICAgICAgICAgICBjb25maWcuZGF0YUZvcm1hdCA9PSBudWxsID8gJ2NoYW5uZWxzTGFzdCcgOiBjb25maWcuZGF0YUZvcm1hdDtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tEYXRhRm9ybWF0KF90aGlzLmRhdGFGb3JtYXQpO1xuICAgICAgICBfdGhpcy5kaWxhdGlvblJhdGUgPSBjb25maWcuZGlsYXRpb25SYXRlID09IG51bGwgPyAxIDogY29uZmlnLmRpbGF0aW9uUmF0ZTtcbiAgICAgICAgaWYgKF90aGlzLnJhbmsgPT09IDEgJiZcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KF90aGlzLmRpbGF0aW9uUmF0ZSkgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5kaWxhdGlvblJhdGUubGVuZ3RoICE9PSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJkaWxhdGlvblJhdGUgbXVzdCBiZSBhIG51bWJlciBvciBhbiBhcnJheSBvZiBhIHNpbmdsZSBudW1iZXIgXCIgK1xuICAgICAgICAgICAgICAgIFwiZm9yIDFEIGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgIChcIlwiICsgSlNPTi5zdHJpbmdpZnkoX3RoaXMuZGlsYXRpb25SYXRlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5yYW5rID09PSAyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLmRpbGF0aW9uUmF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaWxhdGlvblJhdGUgPSBbX3RoaXMuZGlsYXRpb25SYXRlLCBfdGhpcy5kaWxhdGlvblJhdGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuZGlsYXRpb25SYXRlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYXJyYXkgb2YgdHdvIG51bWJlcnMgZm9yIDJEIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiY29udm9sdXRpb24sIGJ1dCByZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KF90aGlzLmRpbGF0aW9uUmF0ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbnNfMS5nZXRBY3RpdmF0aW9uKGNvbmZpZy5hY3RpdmF0aW9uKTtcbiAgICAgICAgX3RoaXMudXNlQmlhcyA9IGNvbmZpZy51c2VCaWFzID09IG51bGwgPyB0cnVlIDogY29uZmlnLnVzZUJpYXM7XG4gICAgICAgIF90aGlzLmtlcm5lbEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmtlcm5lbEluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMuYmlhc0luaXRpYWxpemVyID1cbiAgICAgICAgICAgIGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5iaWFzSW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMua2VybmVsQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcua2VybmVsQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmJpYXNDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmtlcm5lbFJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmtlcm5lbFJlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMuYmlhc1JlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmJpYXNSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcuYWN0aXZpdHlSZWd1bGFyaXplcik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udi5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIHZhciBjaGFubmVsQXhpcyA9IHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gMSA6IGlucHV0U2hhcGUubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dCBzaG91bGQgYmUgZGVmaW5lZC4gXCIgK1xuICAgICAgICAgICAgICAgIChcIkZvdW5kIFwiICsgaW5wdXRTaGFwZVtjaGFubmVsQXhpc10pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXTtcbiAgICAgICAgdmFyIGtlcm5lbFNoYXBlID0gdGhpcy5rZXJuZWxTaXplLmNvbmNhdChbaW5wdXREaW0sIHRoaXMuZmlsdGVyc10pO1xuICAgICAgICB0aGlzLmtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KCdrZXJuZWwnLCBrZXJuZWxTaGFwZSwgbnVsbCwgdGhpcy5rZXJuZWxJbml0aWFsaXplciwgdGhpcy5rZXJuZWxSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoJ2JpYXMnLCBbdGhpcy5maWx0ZXJzXSwgbnVsbCwgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0U3BlYyA9IFt7IG5kaW06IHRoaXMucmFuayArIDIsIGF4ZXM6IChfYSA9IHt9LCBfYVtjaGFubmVsQXhpc10gPSBpbnB1dERpbSwgX2EpIH1dO1xuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ29udi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRzO1xuICAgICAgICAgICAgdmFyIGJpYXNWYWx1ZSA9IF90aGlzLmJpYXMgPT0gbnVsbCA/IG51bGwgOiBfdGhpcy5iaWFzLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IGNvbnYxZFdpdGhCaWFzKGlucHV0cywgX3RoaXMua2VybmVsLnJlYWQoKSwgYmlhc1ZhbHVlLCBfdGhpcy5zdHJpZGVzWzBdLCBfdGhpcy5wYWRkaW5nLCBfdGhpcy5kYXRhRm9ybWF0LCBfdGhpcy5kaWxhdGlvblJhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBjb252MmRXaXRoQmlhcyhpbnB1dHMsIF90aGlzLmtlcm5lbC5yZWFkKCksIGJpYXNWYWx1ZSwgX3RoaXMuc3RyaWRlcywgX3RoaXMucGFkZGluZywgX3RoaXMuZGF0YUZvcm1hdCwgX3RoaXMuZGlsYXRpb25SYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignM0QgY29udm9sdXRpb24gaXMgbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gX3RoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnYucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIG5ld1NwYWNlID0gW107XG4gICAgICAgIHZhciBzcGFjZSA9ICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSA/XG4gICAgICAgICAgICBpbnB1dFNoYXBlLnNsaWNlKDEsIGlucHV0U2hhcGUubGVuZ3RoIC0gMSkgOlxuICAgICAgICAgICAgaW5wdXRTaGFwZS5zbGljZSgyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5ld0RpbSA9IGNvbnZfdXRpbHNfMS5jb252T3V0cHV0TGVuZ3RoKHNwYWNlW2ldLCB0aGlzLmtlcm5lbFNpemVbaV0sIHRoaXMucGFkZGluZywgdGhpcy5zdHJpZGVzW2ldLCB0eXBlb2YgdGhpcy5kaWxhdGlvblJhdGUgPT09ICdudW1iZXInID8gdGhpcy5kaWxhdGlvblJhdGUgOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlsYXRpb25SYXRlW2ldKTtcbiAgICAgICAgICAgIG5ld1NwYWNlLnB1c2gobmV3RGltKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXV07XG4gICAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlLmNvbmNhdChuZXdTcGFjZSk7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKHRoaXMuZmlsdGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKHRoaXMuZmlsdGVycyk7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlLmNvbmNhdChuZXdTcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICAgIH07XG4gICAgQ29udi5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgcmFuazogdGhpcy5yYW5rLFxuICAgICAgICAgICAgZmlsdGVyczogdGhpcy5maWx0ZXJzLFxuICAgICAgICAgICAga2VybmVsU2l6ZTogdGhpcy5rZXJuZWxTaXplLFxuICAgICAgICAgICAgc3RyaWRlczogdGhpcy5zdHJpZGVzLFxuICAgICAgICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxuICAgICAgICAgICAgZGF0YUZvcm1hdDogdGhpcy5kYXRhRm9ybWF0LFxuICAgICAgICAgICAgZGlsYXRpb25SYXRlOiB0aGlzLmRpbGF0aW9uUmF0ZSxcbiAgICAgICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25zXzEuc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAgICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICAgICAgICBrZXJuZWxSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiaWFzUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICAgICAgICBrZXJuZWxDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGJpYXNDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udjtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5Db252ID0gQ29udjtcbnZhciBDb252MkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb252MkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udjJEKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgMiwgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDb252MkQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ3JhbmsnXTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIENvbnYyRC5jbGFzc05hbWUgPSAnQ29udjJEJztcbiAgICByZXR1cm4gQ29udjJEO1xufShDb252KSk7XG5leHBvcnRzLkNvbnYyRCA9IENvbnYyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihDb252MkQpO1xudmFyIENvbnYyRFRyYW5zcG9zZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnYyRFRyYW5zcG9zZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252MkRUcmFuc3Bvc2UoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW25ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IG5kaW06IDQgfSldO1xuICAgICAgICBpZiAoX3RoaXMucGFkZGluZyAhPT0gJ3NhbWUnICYmIF90aGlzLnBhZGRpbmcgIT09ICd2YWxpZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiQ29udjJEVHJhbnNwb3NlIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IHBhZGRpbmcgbW9kZXMgJ3NhbWUnIFwiICtcbiAgICAgICAgICAgICAgICAoXCJhbmQgJ3ZhbGlkJywgYnV0IHJlY2VpdmVkIHBhZGRpbmcgbW9kZSBcIiArIF90aGlzLnBhZGRpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnYyRFRyYW5zcG9zZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0lucHV0IHNob3VsZCBoYXZlIHJhbmsgNDsgUmVjZWl2ZWQgaW5wdXQgc2hhcGU6ICcgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbEF4aXMgPSB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IDEgOiBpbnB1dFNoYXBlLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgc2hvdWxkIGJlIGRlZmluZWQuICcgK1xuICAgICAgICAgICAgICAgICdGb3VuZCBgTm9uZWAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0RGltID0gaW5wdXRTaGFwZVtjaGFubmVsQXhpc107XG4gICAgICAgIHZhciBrZXJuZWxTaGFwZSA9IHRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycywgaW5wdXREaW1dKTtcbiAgICAgICAgdGhpcy5rZXJuZWwgPSB0aGlzLmFkZFdlaWdodCgna2VybmVsJywga2VybmVsU2hhcGUsICdmbG9hdDMyJywgdGhpcy5rZXJuZWxJbml0aWFsaXplciwgdGhpcy5rZXJuZWxSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoJ2JpYXMnLCBbdGhpcy5maWx0ZXJzXSwgJ2Zsb2F0MzInLCB0aGlzLmJpYXNJbml0aWFsaXplciwgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRTcGVjID1cbiAgICAgICAgICAgIFtuZXcgdG9wb2xvZ3lfMS5JbnB1dFNwZWMoeyBuZGltOiA0LCBheGVzOiAoX2EgPSB7fSwgX2FbY2hhbm5lbEF4aXNdID0gaW5wdXREaW0sIF9hKSB9KV07XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBDb252MkRUcmFuc3Bvc2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmYy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnNoYXBlLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiQ29udjJEVHJhbnNwb3NlLmNhbGwoKSBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSByYW5rLTQsIGJ1dCBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcInJlY2VpdmVkIGEgdGVuc29yIG9mIHJhbmstXCIgKyBpbnB1dC5zaGFwZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnB1dFNoYXBlID0gaW5wdXQuc2hhcGU7XG4gICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0gaW5wdXRTaGFwZVswXTtcbiAgICAgICAgICAgIHZhciBoQXhpcztcbiAgICAgICAgICAgIHZhciB3QXhpcztcbiAgICAgICAgICAgIGlmIChfdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgICAgICBoQXhpcyA9IDI7XG4gICAgICAgICAgICAgICAgd0F4aXMgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaEF4aXMgPSAxO1xuICAgICAgICAgICAgICAgIHdBeGlzID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBpbnB1dFNoYXBlW2hBeGlzXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGlucHV0U2hhcGVbd0F4aXNdO1xuICAgICAgICAgICAgdmFyIGtlcm5lbEggPSBfdGhpcy5rZXJuZWxTaXplWzBdO1xuICAgICAgICAgICAgdmFyIGtlcm5lbFcgPSBfdGhpcy5rZXJuZWxTaXplWzFdO1xuICAgICAgICAgICAgdmFyIHN0cmlkZUggPSBfdGhpcy5zdHJpZGVzWzBdO1xuICAgICAgICAgICAgdmFyIHN0cmlkZVcgPSBfdGhpcy5zdHJpZGVzWzFdO1xuICAgICAgICAgICAgdmFyIG91dEhlaWdodCA9IGNvbnZfdXRpbHNfMS5kZWNvbnZMZW5ndGgoaGVpZ2h0LCBzdHJpZGVILCBrZXJuZWxILCBfdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIHZhciBvdXRXaWR0aCA9IGNvbnZfdXRpbHNfMS5kZWNvbnZMZW5ndGgod2lkdGgsIHN0cmlkZVcsIGtlcm5lbFcsIF90aGlzLnBhZGRpbmcpO1xuICAgICAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0SGVpZ2h0LCBvdXRXaWR0aCwgX3RoaXMuZmlsdGVyc107XG4gICAgICAgICAgICBpZiAoX3RoaXMuZGF0YUZvcm1hdCAhPT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRmYy50cmFuc3Bvc2UoaW5wdXQsIFswLCAyLCAzLCAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3V0cHV0cyA9IHRmYy5jb252MmRUcmFuc3Bvc2UoaW5wdXQsIF90aGlzLmtlcm5lbC5yZWFkKCksIG91dHB1dFNoYXBlLCBfdGhpcy5zdHJpZGVzLCBfdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kYXRhRm9ybWF0ICE9PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSB0ZmMudHJhbnNwb3NlKG91dHB1dHMsIFswLCAzLCAxLCAyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuYmlhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9XG4gICAgICAgICAgICAgICAgICAgIEsuYmlhc0FkZChvdXRwdXRzLCBfdGhpcy5iaWFzLnJlYWQoKSwgX3RoaXMuZGF0YUZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IF90aGlzLmFjdGl2YXRpb24uYXBwbHkob3V0cHV0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb252MkRUcmFuc3Bvc2UucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICAgICAgICB2YXIgY2hhbm5lbEF4aXM7XG4gICAgICAgIHZhciBoZWlnaHRBeGlzO1xuICAgICAgICB2YXIgd2lkdGhBeGlzO1xuICAgICAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgIGNoYW5uZWxBeGlzID0gMTtcbiAgICAgICAgICAgIGhlaWdodEF4aXMgPSAyO1xuICAgICAgICAgICAgd2lkdGhBeGlzID0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWxBeGlzID0gMztcbiAgICAgICAgICAgIGhlaWdodEF4aXMgPSAxO1xuICAgICAgICAgICAgd2lkdGhBeGlzID0gMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2VybmVsSCA9IHRoaXMua2VybmVsU2l6ZVswXTtcbiAgICAgICAgdmFyIGtlcm5lbFcgPSB0aGlzLmtlcm5lbFNpemVbMV07XG4gICAgICAgIHZhciBzdHJpZGVIID0gdGhpcy5zdHJpZGVzWzBdO1xuICAgICAgICB2YXIgc3RyaWRlVyA9IHRoaXMuc3RyaWRlc1sxXTtcbiAgICAgICAgb3V0cHV0U2hhcGVbY2hhbm5lbEF4aXNdID0gdGhpcy5maWx0ZXJzO1xuICAgICAgICBvdXRwdXRTaGFwZVtoZWlnaHRBeGlzXSA9XG4gICAgICAgICAgICBjb252X3V0aWxzXzEuZGVjb252TGVuZ3RoKG91dHB1dFNoYXBlW2hlaWdodEF4aXNdLCBzdHJpZGVILCBrZXJuZWxILCB0aGlzLnBhZGRpbmcpO1xuICAgICAgICBvdXRwdXRTaGFwZVt3aWR0aEF4aXNdID1cbiAgICAgICAgICAgIGNvbnZfdXRpbHNfMS5kZWNvbnZMZW5ndGgob3V0cHV0U2hhcGVbd2lkdGhBeGlzXSwgc3RyaWRlVywga2VybmVsVywgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICAgIH07XG4gICAgQ29udjJEVHJhbnNwb3NlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBkZWxldGUgY29uZmlnWydkaWxhdGlvblJhdGUnXTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIENvbnYyRFRyYW5zcG9zZS5jbGFzc05hbWUgPSAnQ29udjJEVHJhbnNwb3NlJztcbiAgICByZXR1cm4gQ29udjJEVHJhbnNwb3NlO1xufShDb252MkQpKTtcbmV4cG9ydHMuQ29udjJEVHJhbnNwb3NlID0gQ29udjJEVHJhbnNwb3NlO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKENvbnYyRFRyYW5zcG9zZSk7XG52YXIgU2VwYXJhYmxlQ29udiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcGFyYWJsZUNvbnYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VwYXJhYmxlQ29udihyYW5rLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmFuaywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0RFUFRIV0lTRV9JTklUSUFMSVpFUiA9ICdnbG9yb3RVbmlmb3JtJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9QT0lOVFdJU0VfSU5JVElBTElaRVIgPSAnZ2xvcm90VW5pZm9ybSc7XG4gICAgICAgIF90aGlzLmRlcHRod2lzZUtlcm5lbCA9IG51bGw7XG4gICAgICAgIF90aGlzLnBvaW50d2lzZUtlcm5lbCA9IG51bGw7XG4gICAgICAgIGlmIChjb25maWcuZmlsdGVycyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignVGhlIGBmaWx0ZXJzYCBjb25maWd1cmF0aW9uIGZpZWxkIGlzIHJlcXVpcmVkIGJ5IFNlcGFyYWJsZUNvbnYsICcgK1xuICAgICAgICAgICAgICAgICdidXQgaXMgdW5zcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5rZXJuZWxJbml0aWFsaXplciAhPSBudWxsIHx8IGNvbmZpZy5rZXJuZWxSZWd1bGFyaXplciAhPSBudWxsIHx8XG4gICAgICAgICAgICBjb25maWcua2VybmVsQ29uc3RyYWludCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignRmllbGRzIGtlcm5lbEluaXRpYWxpemVyLCBrZXJuZWxSZWd1bGFyaXplciBhbmQga2VybmVsQ29uc3RyYWludCAnICtcbiAgICAgICAgICAgICAgICAnYXJlIGludmFsaWQgZm9yIFNlcGFyYWJsZUNvbnYyRC4gVXNlIGRlcHRod2lzZUluaXRpYWxpemVyLCAnICtcbiAgICAgICAgICAgICAgICAnZGVwdGh3aXNlUmVndWxhcml6ZXIsIGRlcHRod2lzZUNvbnN0cmFpbnQsIHBvaW50d2lzZUluaXRpYWxpemVyLCAnICtcbiAgICAgICAgICAgICAgICAncG9pbnR3aXNlUmVndWxhcml6ZXIgYW5kIHBvaW50d2lzZUNvbnN0cmFpbnQgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnBhZGRpbmcgIT0gbnVsbCAmJiBjb25maWcucGFkZGluZyAhPT0gJ3NhbWUnICYmXG4gICAgICAgICAgICBjb25maWcucGFkZGluZyAhPT0gJ3ZhbGlkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJTZXBhcmFibGVDb252XCIgKyBfdGhpcy5yYW5rICsgXCJEIHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlczogXCIgK1xuICAgICAgICAgICAgICAgIChcIidzYW1lJyBhbmQgJ3ZhbGlkJywgYnV0IHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoY29uZmlnLnBhZGRpbmcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZGVwdGhNdWx0aXBsaWVyID1cbiAgICAgICAgICAgIGNvbmZpZy5kZXB0aE11bHRpcGxpZXIgPT0gbnVsbCA/IDEgOiBjb25maWcuZGVwdGhNdWx0aXBsaWVyO1xuICAgICAgICBfdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5kZXB0aHdpc2VJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0RFUFRIV0lTRV9JTklUSUFMSVpFUik7XG4gICAgICAgIF90aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmRlcHRod2lzZVJlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMuZGVwdGh3aXNlQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcuZGVwdGh3aXNlQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLnBvaW50d2lzZUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmRlcHRod2lzZUluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfUE9JTlRXSVNFX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMucG9pbnR3aXNlUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcucG9pbnR3aXNlUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5wb2ludHdpc2VDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5wb2ludHdpc2VDb25zdHJhaW50KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTZXBhcmFibGVDb252LnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoIDwgdGhpcy5yYW5rICsgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbnB1dHMgdG8gU2VwYXJhYmxlQ29udlwiICsgdGhpcy5yYW5rICsgXCJEIHNob3VsZCBoYXZlIHJhbmsgXCIgK1xuICAgICAgICAgICAgICAgICh0aGlzLnJhbmsgKyAyICsgXCIsIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZTogXCIpICtcbiAgICAgICAgICAgICAgICAoXCJcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5uZWxBeGlzID0gdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyAxIDogaW5wdXRTaGFwZS5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5wdXRTaGFwZVtjaGFubmVsQXhpc10gPT0gbnVsbCB8fCBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgc2hvdWxkIGJlIGRlZmluZWQsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZm91bmQgXCIgKyBKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXTtcbiAgICAgICAgdmFyIGRlcHRod2lzZUtlcm5lbFNoYXBlID0gdGhpcy5rZXJuZWxTaXplLmNvbmNhdChbaW5wdXREaW0sIHRoaXMuZGVwdGhNdWx0aXBsaWVyXSk7XG4gICAgICAgIHZhciBwb2ludHdpc2VLZXJuZWxTaGFwZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuazsgKytpKSB7XG4gICAgICAgICAgICBwb2ludHdpc2VLZXJuZWxTaGFwZS5wdXNoKDEpO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50d2lzZUtlcm5lbFNoYXBlLnB1c2goaW5wdXREaW0gKiB0aGlzLmRlcHRoTXVsdGlwbGllciwgdGhpcy5maWx0ZXJzKTtcbiAgICAgICAgdmFyIHRyYWluYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVwdGh3aXNlS2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ2RlcHRod2lzZV9rZXJuZWwnLCBkZXB0aHdpc2VLZXJuZWxTaGFwZSwgJ2Zsb2F0MzInLCB0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyLCB0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCB0cmFpbmFibGUsIHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCk7XG4gICAgICAgIHRoaXMucG9pbnR3aXNlS2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ3BvaW50d2lzZV9rZXJuZWwnLCBwb2ludHdpc2VLZXJuZWxTaGFwZSwgJ2Zsb2F0MzInLCB0aGlzLnBvaW50d2lzZUluaXRpYWxpemVyLCB0aGlzLnBvaW50d2lzZVJlZ3VsYXJpemVyLCB0cmFpbmFibGUsIHRoaXMucG9pbnR3aXNlQ29uc3RyYWludCk7XG4gICAgICAgIGlmICh0aGlzLnVzZUJpYXMpIHtcbiAgICAgICAgICAgIHRoaXMuYmlhcyA9IHRoaXMuYWRkV2VpZ2h0KCdiaWFzJywgW3RoaXMuZmlsdGVyc10sICdmbG9hdDMyJywgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cmFpbmFibGUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0U3BlYyA9XG4gICAgICAgICAgICBbbmV3IHRvcG9sb2d5XzEuSW5wdXRTcGVjKHsgbmRpbTogdGhpcy5yYW5rICsgMiwgYXhlczogKF9hID0ge30sIF9hW2NoYW5uZWxBeGlzXSA9IGlucHV0RGltLCBfYSkgfSldO1xuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgU2VwYXJhYmxlQ29udi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCcxRCBzZXBhcmFibGUgY29udm9sdXRpb24gaXMgbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cyA9IHRmYy50cmFuc3Bvc2UoaW5wdXRzLCBbMCwgMiwgMywgMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0ZmMuc2VwYXJhYmxlQ29udjJkKGlucHV0cywgX3RoaXMuZGVwdGh3aXNlS2VybmVsLnJlYWQoKSwgX3RoaXMucG9pbnR3aXNlS2VybmVsLnJlYWQoKSwgX3RoaXMuc3RyaWRlcywgX3RoaXMucGFkZGluZywgX3RoaXMuZGlsYXRpb25SYXRlLCAnTkhXQycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnVzZUJpYXMpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBLLmJpYXNBZGQob3V0cHV0LCBfdGhpcy5iaWFzLnJlYWQoKSwgX3RoaXMuZGF0YUZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gX3RoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRmYy50cmFuc3Bvc2Uob3V0cHV0LCBbMCwgMywgMSwgMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXBhcmFibGVDb252LnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBkZWxldGUgY29uZmlnWydyYW5rJ107XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ2tlcm5lbEluaXRpYWxpemVyJ107XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ2tlcm5lbFJlZ3VsYXJpemVyJ107XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ2tlcm5lbENvbnN0cmFpbnQnXTtcbiAgICAgICAgY29uZmlnWydkZXB0aHdpc2VJbml0aWFsaXplciddID1cbiAgICAgICAgICAgIGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIpO1xuICAgICAgICBjb25maWdbJ3BvaW50d2lzZUluaXRpYWxpemVyJ10gPVxuICAgICAgICAgICAgaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5wb2ludHdpc2VJbml0aWFsaXplcik7XG4gICAgICAgIGNvbmZpZ1snZGVwdGh3aXNlUmVndWxhcml6ZXInXSA9XG4gICAgICAgICAgICByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyKTtcbiAgICAgICAgY29uZmlnWydwb2ludHdpc2VSZWd1bGFyaXplciddID1cbiAgICAgICAgICAgIHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucG9pbnR3aXNlUmVndWxhcml6ZXIpO1xuICAgICAgICBjb25maWdbJ2RlcHRod2lzZUNvbnN0cmFpbnQnXSA9XG4gICAgICAgICAgICBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KTtcbiAgICAgICAgY29uZmlnWydwb2ludHdpc2VDb25zdHJhaW50J10gPVxuICAgICAgICAgICAgY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMucG9pbnR3aXNlQ29uc3RyYWludCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBTZXBhcmFibGVDb252LmNsYXNzTmFtZSA9ICdTZXBhcmFibGVDb252JztcbiAgICByZXR1cm4gU2VwYXJhYmxlQ29udjtcbn0oQ29udikpO1xuZXhwb3J0cy5TZXBhcmFibGVDb252ID0gU2VwYXJhYmxlQ29udjtcbnZhciBTZXBhcmFibGVDb252MkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXBhcmFibGVDb252MkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VwYXJhYmxlQ29udjJEKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgMiwgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTZXBhcmFibGVDb252MkQuY2xhc3NOYW1lID0gJ1NlcGFyYWJsZUNvbnYyRCc7XG4gICAgcmV0dXJuIFNlcGFyYWJsZUNvbnYyRDtcbn0oU2VwYXJhYmxlQ29udikpO1xuZXhwb3J0cy5TZXBhcmFibGVDb252MkQgPSBTZXBhcmFibGVDb252MkQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoU2VwYXJhYmxlQ29udjJEKTtcbnZhciBDb252MUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb252MUQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udjFEKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAxLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFt7IG5kaW06IDMgfV07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udjFELnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBkZWxldGUgY29uZmlnWydyYW5rJ107XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ2RhdGFGb3JtYXQnXTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIENvbnYxRC5jbGFzc05hbWUgPSAnQ29udjFEJztcbiAgICByZXR1cm4gQ29udjFEO1xufShDb252KSk7XG5leHBvcnRzLkNvbnYxRCA9IENvbnYxRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihDb252MUQpO1xudmFyIENyb3BwaW5nMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDcm9wcGluZzJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENyb3BwaW5nMkQoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuY3JvcHBpbmcgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgX3RoaXMuY3JvcHBpbmcgPSBbXG4gICAgICAgICAgICAgICAgW2NvbmZpZy5jcm9wcGluZywgY29uZmlnLmNyb3BwaW5nXSwgW2NvbmZpZy5jcm9wcGluZywgY29uZmlnLmNyb3BwaW5nXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZy5jcm9wcGluZ1swXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBfdGhpcy5jcm9wcGluZyA9IFtcbiAgICAgICAgICAgICAgICBbY29uZmlnLmNyb3BwaW5nWzBdLCBjb25maWcuY3JvcHBpbmdbMF1dLFxuICAgICAgICAgICAgICAgIFtjb25maWcuY3JvcHBpbmdbMV0sIGNvbmZpZy5jcm9wcGluZ1sxXV1cbiAgICAgICAgICAgIF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIF90aGlzLmNyb3BwaW5nID0gY29uZmlnLmNyb3BwaW5nO1xuICAgICAgICBfdGhpcy5kYXRhRm9ybWF0ID1cbiAgICAgICAgICAgIGNvbmZpZy5kYXRhRm9ybWF0ID09PSB1bmRlZmluZWQgPyAnY2hhbm5lbHNMYXN0JyA6IGNvbmZpZy5kYXRhRm9ybWF0O1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbeyBuZGltOiA0IH1dO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENyb3BwaW5nMkQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JylcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsxXSxcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlWzJdIC0gdGhpcy5jcm9wcGluZ1swXVswXSAtIHRoaXMuY3JvcHBpbmdbMF1bMV0sXG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZVsyXSAtIHRoaXMuY3JvcHBpbmdbMV1bMF0gLSB0aGlzLmNyb3BwaW5nWzFdWzFdXG4gICAgICAgICAgICBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGlucHV0U2hhcGVbMF0sXG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZVsxXSAtIHRoaXMuY3JvcHBpbmdbMF1bMF0gLSB0aGlzLmNyb3BwaW5nWzBdWzFdLFxuICAgICAgICAgICAgICAgIGlucHV0U2hhcGVbMl0gLSB0aGlzLmNyb3BwaW5nWzFdWzBdIC0gdGhpcy5jcm9wcGluZ1sxXVsxXSwgaW5wdXRTaGFwZVszXVxuICAgICAgICAgICAgXTtcbiAgICB9O1xuICAgIENyb3BwaW5nMkQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5wdXRzID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaFNsaWNlZCA9IEsuc2xpY2VBbG9uZ0F4aXMoaW5wdXRzLCBfdGhpcy5jcm9wcGluZ1swXVswXSwgaW5wdXRzLnNoYXBlWzFdIC0gX3RoaXMuY3JvcHBpbmdbMF1bMF0gLSBfdGhpcy5jcm9wcGluZ1swXVsxXSwgMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEsuc2xpY2VBbG9uZ0F4aXMoaFNsaWNlZCwgX3RoaXMuY3JvcHBpbmdbMV1bMF0sIGlucHV0cy5zaGFwZVsyXSAtIF90aGlzLmNyb3BwaW5nWzFdWzFdIC0gX3RoaXMuY3JvcHBpbmdbMV1bMF0sIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhTbGljZWQgPSBLLnNsaWNlQWxvbmdBeGlzKGlucHV0cywgX3RoaXMuY3JvcHBpbmdbMF1bMF0sIGlucHV0cy5zaGFwZVsyXSAtIF90aGlzLmNyb3BwaW5nWzBdWzBdIC0gX3RoaXMuY3JvcHBpbmdbMF1bMV0sIDMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBLLnNsaWNlQWxvbmdBeGlzKGhTbGljZWQsIF90aGlzLmNyb3BwaW5nWzFdWzBdLCBpbnB1dHMuc2hhcGVbM10gLSBfdGhpcy5jcm9wcGluZ1sxXVsxXSAtIF90aGlzLmNyb3BwaW5nWzFdWzBdLCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDcm9wcGluZzJELnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGNyb3BwaW5nOiB0aGlzLmNyb3BwaW5nLCBkYXRhRm9ybWF0OiB0aGlzLmRhdGFGb3JtYXQgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBDcm9wcGluZzJELmNsYXNzTmFtZSA9ICdDcm9wcGluZzJEJztcbiAgICByZXR1cm4gQ3JvcHBpbmcyRDtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5Dcm9wcGluZzJEID0gQ3JvcHBpbmcyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihDcm9wcGluZzJEKTtcbnZhciBVcFNhbXBsaW5nMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVcFNhbXBsaW5nMkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVXBTYW1wbGluZzJEKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfU0laRSA9IFsyLCAyXTtcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW3sgbmRpbTogNCB9XTtcbiAgICAgICAgX3RoaXMuc2l6ZSA9IGNvbmZpZy5zaXplID09PSB1bmRlZmluZWQgPyBfdGhpcy5ERUZBVUxUX1NJWkUgOiBjb25maWcuc2l6ZTtcbiAgICAgICAgX3RoaXMuZGF0YUZvcm1hdCA9XG4gICAgICAgICAgICBjb25maWcuZGF0YUZvcm1hdCA9PT0gdW5kZWZpbmVkID8gJ2NoYW5uZWxzTGFzdCcgOiBjb25maWcuZGF0YUZvcm1hdDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBVcFNhbXBsaW5nMkQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuc2l6ZVswXSAqIGlucHV0U2hhcGVbMl07XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnNpemVbMV0gKiBpbnB1dFNoYXBlWzNdO1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBpbnB1dFNoYXBlWzFdLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnNpemVbMF0gKiBpbnB1dFNoYXBlWzFdO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5zaXplWzFdICogaW5wdXRTaGFwZVsyXTtcbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaGVpZ2h0LCB3aWR0aCwgaW5wdXRTaGFwZVszXV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVwU2FtcGxpbmcyRC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZjLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICAgICAgICAgICAgaWYgKF90aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gdGZjLnRyYW5zcG9zZShpbnB1dCwgWzAsIDIsIDMsIDFdKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX3RoaXMuc2l6ZVswXSAqIGlucHV0U2hhcGVbMl07XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX3RoaXMuc2l6ZVsxXSAqIGlucHV0U2hhcGVbM107XG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZWQgPSBpbnB1dC5yZXNpemVOZWFyZXN0TmVpZ2hib3IoW2hlaWdodCwgd2lkdGhdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZjLnRyYW5zcG9zZShyZXNpemVkLCBbMCwgMywgMSwgMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IF90aGlzLnNpemVbMF0gKiBpbnB1dFNoYXBlWzFdO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IF90aGlzLnNpemVbMV0gKiBpbnB1dFNoYXBlWzJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXNpemVOZWFyZXN0TmVpZ2hib3IoW2hlaWdodCwgd2lkdGhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBVcFNhbXBsaW5nMkQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgc2l6ZTogdGhpcy5zaXplLCBkYXRhRm9ybWF0OiB0aGlzLmRhdGFGb3JtYXQgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBVcFNhbXBsaW5nMkQuY2xhc3NOYW1lID0gJ1VwU2FtcGxpbmcyRCc7XG4gICAgcmV0dXJuIFVwU2FtcGxpbmcyRDtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5VcFNhbXBsaW5nMkQgPSBVcFNhbXBsaW5nMkQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoVXBTYW1wbGluZzJEKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZvbHV0aW9uYWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL2NvbW1vblwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGNvbW1vbl8yID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciBjb25zdHJhaW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0cmFpbnRzXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBpbml0aWFsaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9pbml0aWFsaXplcnNcIik7XG52YXIgcmVndWxhcml6ZXJzXzEgPSByZXF1aXJlKFwiLi4vcmVndWxhcml6ZXJzXCIpO1xudmFyIGNvbnZfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9jb252X3V0aWxzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIGNvbnZvbHV0aW9uYWxfMSA9IHJlcXVpcmUoXCIuL2NvbnZvbHV0aW9uYWxcIik7XG5mdW5jdGlvbiBkZXB0aHdpc2VDb252MmQoeCwgZGVwdGh3aXNlS2VybmVsLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCBkaWxhdGlvblJhdGUpIHtcbiAgICBpZiAoc3RyaWRlcyA9PT0gdm9pZCAwKSB7IHN0cmlkZXMgPSBbMSwgMV07IH1cbiAgICBpZiAocGFkZGluZyA9PT0gdm9pZCAwKSB7IHBhZGRpbmcgPSAndmFsaWQnOyB9XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhRm9ybWF0ID0gY29tbW9uXzEuaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uXzIuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgICAgICB2YXIgeSA9IGNvbnZvbHV0aW9uYWxfMS5wcmVwcm9jZXNzQ29udjJESW5wdXQoeCwgZGF0YUZvcm1hdCk7XG4gICAgICAgIGlmICh4LnJhbmsgIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW5wdXQgZm9yIGRlcHRod2lzZUNvbnYyZCBpcyByZXF1aXJlZCB0byBiZSA0LUQsIGJ1dCBpcyBpbnN0ZWFkIFwiICtcbiAgICAgICAgICAgICAgICAoeC5yYW5rICsgXCItRFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcHRod2lzZUtlcm5lbC5yYW5rICE9PSA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcImRlcHRod2lzZUtlcm5lbCBpcyByZXF1aXJlZCB0byBiZSA0LUQsIGJ1dCBpcyBpbnN0ZWFkIFwiICtcbiAgICAgICAgICAgICAgICAoZGVwdGh3aXNlS2VybmVsLnJhbmsgKyBcIi1EXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB5ID0gdGZjLmRlcHRod2lzZUNvbnYyZCh5LCBkZXB0aHdpc2VLZXJuZWwsIHN0cmlkZXMsIHBhZGRpbmcgPT09ICdzYW1lJyA/ICdzYW1lJyA6ICd2YWxpZCcsICdOSFdDJywgZGlsYXRpb25SYXRlKTtcbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgeSA9IHRmYy50cmFuc3Bvc2UoeSwgWzAsIDMsIDEsIDJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVwdGh3aXNlQ29udjJkID0gZGVwdGh3aXNlQ29udjJkO1xudmFyIERlcHRod2lzZUNvbnYyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlcHRod2lzZUNvbnYyRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZXB0aHdpc2VDb252MkQoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVwdGh3aXNlS2VybmVsID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZGVwdGhNdWx0aXBsaWVyID1cbiAgICAgICAgICAgIGNvbmZpZy5kZXB0aE11bHRpcGxpZXIgPT0gbnVsbCA/IDEgOiBjb25maWcuZGVwdGhNdWx0aXBsaWVyO1xuICAgICAgICBfdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5kZXB0aHdpc2VJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUik7XG4gICAgICAgIF90aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLmRlcHRod2lzZUNvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5kZXB0aHdpc2VSZWd1bGFyaXplcik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGVwdGh3aXNlQ29udjJELnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzXzEuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklucHV0cyB0byBEZXB0aHdpc2VDb252MkQgc2hvdWxkIGhhdmUgcmFuayA0LiBcIiArXG4gICAgICAgICAgICAgICAgKFwiUmVjZWl2ZWQgaW5wdXQgc2hhcGU6IFwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFubmVsQXhpcyA9IHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gMSA6IDM7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSA9PSBudWxsIHx8IGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1RoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgJyArXG4gICAgICAgICAgICAgICAgKFwiYmUgZGVmaW5lZCwgYnV0IGlzIG5vdCAoXCIgKyBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSArIFwiKS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dERpbSA9IGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdO1xuICAgICAgICB2YXIgZGVwdGh3aXNlS2VybmVsU2hhcGUgPSBbXG4gICAgICAgICAgICB0aGlzLmtlcm5lbFNpemVbMF0sIHRoaXMua2VybmVsU2l6ZVsxXSwgaW5wdXREaW0sIHRoaXMuZGVwdGhNdWx0aXBsaWVyXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuZGVwdGh3aXNlS2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ2RlcHRod2lzZV9rZXJuZWwnLCBkZXB0aHdpc2VLZXJuZWxTaGFwZSwgbnVsbCwgdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplciwgdGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoJ2JpYXMnLCBbaW5wdXREaW0gKiB0aGlzLmRlcHRoTXVsdGlwbGllcl0sIG51bGwsIHRoaXMuYmlhc0luaXRpYWxpemVyLCB0aGlzLmJpYXNSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpYXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgIH07XG4gICAgRGVwdGh3aXNlQ29udjJELnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGdlbmVyaWNfdXRpbHNfMS5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICB2YXIgb3V0cHV0cyA9IGRlcHRod2lzZUNvbnYyZChpbnB1dHMsIF90aGlzLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksIF90aGlzLnN0cmlkZXMsIF90aGlzLnBhZGRpbmcsIF90aGlzLmRhdGFGb3JtYXQsIG51bGwpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnVzZUJpYXMpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gSy5iaWFzQWRkKG91dHB1dHMsIF90aGlzLmJpYXMucmVhZCgpLCBfdGhpcy5kYXRhRm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gX3RoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERlcHRod2lzZUNvbnYyRC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHNfMS5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyBpbnB1dFNoYXBlWzJdIDogaW5wdXRTaGFwZVsxXTtcbiAgICAgICAgdmFyIGNvbHMgPSB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IGlucHV0U2hhcGVbM10gOiBpbnB1dFNoYXBlWzJdO1xuICAgICAgICB2YXIgb3V0RmlsdGVycyA9IHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID9cbiAgICAgICAgICAgIGlucHV0U2hhcGVbMV0gKiB0aGlzLmRlcHRoTXVsdGlwbGllciA6XG4gICAgICAgICAgICBpbnB1dFNoYXBlWzNdICogdGhpcy5kZXB0aE11bHRpcGxpZXI7XG4gICAgICAgIHZhciBvdXRSb3dzID0gY29udl91dGlsc18xLmNvbnZPdXRwdXRMZW5ndGgocm93cywgdGhpcy5rZXJuZWxTaXplWzBdLCB0aGlzLnBhZGRpbmcsIHRoaXMuc3RyaWRlc1swXSk7XG4gICAgICAgIHZhciBvdXRDb2xzID0gY29udl91dGlsc18xLmNvbnZPdXRwdXRMZW5ndGgoY29scywgdGhpcy5rZXJuZWxTaXplWzFdLCB0aGlzLnBhZGRpbmcsIHRoaXMuc3RyaWRlc1sxXSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBvdXRGaWx0ZXJzLCBvdXRSb3dzLCBvdXRDb2xzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgb3V0Um93cywgb3V0Q29scywgb3V0RmlsdGVyc107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlcHRod2lzZUNvbnYyRC5jbGFzc05hbWUgPSAnRGVwdGh3aXNlQ29udjJEJztcbiAgICByZXR1cm4gRGVwdGh3aXNlQ29udjJEO1xufShjb252b2x1dGlvbmFsXzEuQ29udjJEKSk7XG5leHBvcnRzLkRlcHRod2lzZUNvbnYyRCA9IERlcHRod2lzZUNvbnYyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihEZXB0aHdpc2VDb252MkQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udm9sdXRpb25hbF9kZXB0aHdpc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgYWN0aXZhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9hY3RpdmF0aW9uc1wiKTtcbnZhciBLID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGNvbnN0cmFpbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RyYWludHNcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGluaXRpYWxpemVyc18xID0gcmVxdWlyZShcIi4uL2luaXRpYWxpemVyc1wiKTtcbnZhciByZWd1bGFyaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9yZWd1bGFyaXplcnNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIG1hdGhfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWF0aF91dGlsc1wiKTtcbnZhciBEcm9wb3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJvcG91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEcm9wb3V0KGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJhdGUgPSBNYXRoLm1heChNYXRoLm1pbihjb25maWcucmF0ZSwgMSksIDApO1xuICAgICAgICBfdGhpcy5yYXRlU2NhbGFyID0gSy5nZXRTY2FsYXIoX3RoaXMucmF0ZSk7XG4gICAgICAgIF90aGlzLm5vaXNlU2hhcGUgPSBjb25maWcubm9pc2VTaGFwZTtcbiAgICAgICAgX3RoaXMuc2VlZCA9IGNvbmZpZy5zZWVkO1xuICAgICAgICBpZiAoX3RoaXMuc2VlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignTm9uLWRlZmF1bHQgc2VlZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gRHJvcG91dCBsYXllciB5ZXQ6ICcgK1xuICAgICAgICAgICAgICAgIF90aGlzLnNlZWQpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHJvcG91dC5wcm90b3R5cGUuZ2V0Tm9pc2VTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5ub2lzZVNoYXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vaXNlU2hhcGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0U2hhcGUgPSBpbnB1dC5zaGFwZTtcbiAgICAgICAgdmFyIG5vaXNlU2hhcGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vaXNlU2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5vaXNlU2hhcGUucHVzaCh0aGlzLm5vaXNlU2hhcGVbaV0gPT0gbnVsbCA/IGlucHV0U2hhcGVbaV0gOiB0aGlzLm5vaXNlU2hhcGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2lzZVNoYXBlO1xuICAgIH07XG4gICAgRHJvcG91dC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnZva2VDYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5ub2lzZVNoYXBlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhdGZqc19jb3JlXzEudXRpbC5hcnJheXNFcXVhbChpbnB1dC5zaGFwZSwgX3RoaXMubm9pc2VTaGFwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignTm9uLWRlZmF1bHQgbm9pc2Ugc2hhcGUgaXMgbm90IGltcGxlbWVudGVkIGluIERyb3BvdXQgJyArXG4gICAgICAgICAgICAgICAgICAgICdsYXllciB5ZXQ6ICcgKyBKU09OLnN0cmluZ2lmeShfdGhpcy5ub2lzZVNoYXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCA8IF90aGlzLnJhdGUgJiYgX3RoaXMucmF0ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5pbmcgPSBrd2FyZ3NbJ3RyYWluaW5nJ10gPT0gbnVsbCA/IGZhbHNlIDoga3dhcmdzWyd0cmFpbmluZyddO1xuICAgICAgICAgICAgICAgIHZhciBub2lzZVNoYXBlXzEgPSBfdGhpcy5nZXROb2lzZVNoYXBlKGlucHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gSy5pblRyYWluUGhhc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gSy5kcm9wb3V0KGlucHV0LCBfdGhpcy5yYXRlU2NhbGFyLCBub2lzZVNoYXBlXzEsIF90aGlzLnNlZWQpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dDsgfSwgdHJhaW5pbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERyb3BvdXQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHJhdGU6IHRoaXMucmF0ZSxcbiAgICAgICAgICAgIG5vaXNlU2hhcGU6IHRoaXMubm9pc2VTaGFwZSxcbiAgICAgICAgICAgIHNlZWQ6IHRoaXMuc2VlZCxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBEcm9wb3V0LmNsYXNzTmFtZSA9ICdEcm9wb3V0JztcbiAgICByZXR1cm4gRHJvcG91dDtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5Ecm9wb3V0ID0gRHJvcG91dDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihEcm9wb3V0KTtcbnZhciBEZW5zZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlbnNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlbnNlKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb24gPSBudWxsO1xuICAgICAgICBfdGhpcy51c2VCaWFzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMua2VybmVsID0gbnVsbDtcbiAgICAgICAgX3RoaXMuYmlhcyA9IG51bGw7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSID0gJ2dsb3JvdE5vcm1hbCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiA9ICd6ZXJvcyc7XG4gICAgICAgIGlmIChjb25maWcuYmF0Y2hJbnB1dFNoYXBlID09IG51bGwgJiYgY29uZmlnLmlucHV0U2hhcGUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgY29uZmlnLmlucHV0RGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5iYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJhdGNoU2l6ZSA9IGNvbmZpZy5iYXRjaFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5iYXRjaElucHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBjb25maWcuaW5wdXREaW1dO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnVuaXRzID0gY29uZmlnLnVuaXRzO1xuICAgICAgICBfdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbnNfMS5nZXRBY3RpdmF0aW9uKGNvbmZpZy5hY3RpdmF0aW9uKTtcbiAgICAgICAgaWYgKGNvbmZpZy51c2VCaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLnVzZUJpYXMgPSBjb25maWcudXNlQmlhcztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5rZXJuZWxJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5rZXJuZWxJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUik7XG4gICAgICAgIF90aGlzLmJpYXNJbml0aWFsaXplciA9XG4gICAgICAgICAgICBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcuYmlhc0luaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUik7XG4gICAgICAgIF90aGlzLmtlcm5lbENvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5iaWFzQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5rZXJuZWxSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5rZXJuZWxSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmJpYXNSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5iaWFzUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmFjdGl2aXR5UmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbeyBtaW5ORGltOiAyIH1dO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERlbnNlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIGlucHV0TGFzdERpbSA9IGlucHV0U2hhcGVbaW5wdXRTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMua2VybmVsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ2tlcm5lbCcsIFtpbnB1dExhc3REaW0sIHRoaXMudW5pdHNdLCBudWxsLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLCB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmlhcyA9IHRoaXMuYWRkV2VpZ2h0KCdiaWFzJywgW3RoaXMudW5pdHNdLCBudWxsLCB0aGlzLmJpYXNJbml0aWFsaXplciwgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRTcGVjID0gW3sgbWluTkRpbTogMiwgYXhlczogKF9hID0ge30sIF9hWy0xXSA9IGlucHV0TGFzdERpbSwgX2EpIH1dO1xuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgRGVuc2UucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICAgICAgICBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXSA9IHRoaXMudW5pdHM7XG4gICAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICB9O1xuICAgIERlbnNlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IEsuZG90KGlucHV0LCBfdGhpcy5rZXJuZWwucmVhZCgpKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5iaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBLLmJpYXNBZGQob3V0cHV0LCBfdGhpcy5iaWFzLnJlYWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gX3RoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEZW5zZS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgdW5pdHM6IHRoaXMudW5pdHMsXG4gICAgICAgICAgICBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uc18xLnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxcbiAgICAgICAgICAgIHVzZUJpYXM6IHRoaXMudXNlQmlhcyxcbiAgICAgICAgICAgIGtlcm5lbEluaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGJpYXNJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAga2VybmVsUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYmlhc1JlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksXG4gICAgICAgICAgICBhY3Rpdml0eVJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLFxuICAgICAgICAgICAga2VybmVsQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCksXG4gICAgICAgICAgICBiaWFzQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgRGVuc2UuY2xhc3NOYW1lID0gJ0RlbnNlJztcbiAgICByZXR1cm4gRGVuc2U7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuRGVuc2UgPSBEZW5zZTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihEZW5zZSk7XG52YXIgRmxhdHRlbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZsYXR0ZW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmxhdHRlbihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnIHx8IHt9KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbeyBtaW5ORGltOiAzIH1dO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZsYXR0ZW4ucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGlucHV0U2hhcGUuc2xpY2UoMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGltID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKGRpbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgc2hhcGUgb2YgdGhlIGlucHV0IHRvIFxcXCJGbGF0dGVuXFxcIiBpcyBub3QgZnVsbHkgZGVmaW5lZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIihnb3QgXCIgKyBpbnB1dFNoYXBlLnNsaWNlKDEpICsgXCIpLiBNYWtlIHN1cmUgdG8gcGFzcyBhIGNvbXBsZXRlIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxcImlucHV0X3NoYXBlXFxcIiBvciBcXFwiYmF0Y2hfaW5wdXRfc2hhcGVcXFwiIGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibGF5ZXIgaW4geW91ciBtb2RlbC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBtYXRoX3V0aWxzLmFycmF5UHJvZChpbnB1dFNoYXBlLCAxKV07XG4gICAgfTtcbiAgICBGbGF0dGVuLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBLLmJhdGNoRmxhdHRlbihnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRmxhdHRlbi5jbGFzc05hbWUgPSAnRmxhdHRlbic7XG4gICAgcmV0dXJuIEZsYXR0ZW47XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuRmxhdHRlbiA9IEZsYXR0ZW47XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoRmxhdHRlbik7XG52YXIgQWN0aXZhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGl2YXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aXZhdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbnNfMS5nZXRBY3RpdmF0aW9uKGNvbmZpZy5hY3RpdmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBY3RpdmF0aW9uLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFjdGl2YXRpb24uYXBwbHkoaW5wdXQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFjdGl2YXRpb24ucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgYWN0aXZhdGlvbjogYWN0aXZhdGlvbnNfMS5zZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbikgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBBY3RpdmF0aW9uLmNsYXNzTmFtZSA9ICdBY3RpdmF0aW9uJztcbiAgICByZXR1cm4gQWN0aXZhdGlvbjtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5BY3RpdmF0aW9uID0gQWN0aXZhdGlvbjtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihBY3RpdmF0aW9uKTtcbnZhciBSZXBlYXRWZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBlYXRWZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZWF0VmVjdG9yKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm4gPSBjb25maWcubjtcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW3sgbmRpbTogMiB9XTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXBlYXRWZWN0b3IucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgdGhpcy5uLCBpbnB1dFNoYXBlWzFdXTtcbiAgICB9O1xuICAgIFJlcGVhdFZlY3Rvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzXzEuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgcmV0dXJuIEsucmVwZWF0KGlucHV0cywgX3RoaXMubik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVwZWF0VmVjdG9yLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBuOiB0aGlzLm4sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgUmVwZWF0VmVjdG9yLmNsYXNzTmFtZSA9ICdSZXBlYXRWZWN0b3InO1xuICAgIHJldHVybiBSZXBlYXRWZWN0b3I7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuUmVwZWF0VmVjdG9yID0gUmVwZWF0VmVjdG9yO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFJlcGVhdFZlY3Rvcik7XG52YXIgUmVzaGFwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc2hhcGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzaGFwZShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXRTaGFwZSA9IGNvbmZpZy50YXJnZXRTaGFwZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy50YXJnZXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzVW5rbm93bihfdGhpcy50YXJnZXRTaGFwZVtpXSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXRTaGFwZVtpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXNoYXBlLnByb3RvdHlwZS5pc1Vua25vd24gPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHJldHVybiBkaW0gPCAwIHx8IGRpbSA9PSBudWxsO1xuICAgIH07XG4gICAgUmVzaGFwZS5wcm90b3R5cGUuZml4VW5rbm93bkRpbWVuc2lvbiA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSkge1xuICAgICAgICB2YXIgZXJyb3JNc2cgPSAnVG90YWwgc2l6ZSBvZiBuZXcgYXJyYXkgbXVzdCBiZSB1bmNoYW5nZWQuJztcbiAgICAgICAgdmFyIGZpbmFsU2hhcGUgPSBvdXRwdXRTaGFwZS5zbGljZSgpO1xuICAgICAgICB2YXIga25vd24gPSAxO1xuICAgICAgICB2YXIgdW5rbm93biA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGRpbSA9IGZpbmFsU2hhcGVbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Vua25vd24oZGltKSkge1xuICAgICAgICAgICAgICAgIGlmICh1bmtub3duID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVua25vd24gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0NhbiBvbmx5IHNwZWNpZml5IG9uZSB1bmtub3duIGRpbWVuc2lvbi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrbm93biAqPSBkaW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbmFsU2l6ZSA9IG1hdGhfdXRpbHMuYXJyYXlQcm9kKGlucHV0U2hhcGUpO1xuICAgICAgICBpZiAodW5rbm93biAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtub3duID09PSAwIHx8IG9yaWdpbmFsU2l6ZSAlIGtub3duICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxTaGFwZVt1bmtub3duXSA9IG9yaWdpbmFsU2l6ZSAvIGtub3duO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9yaWdpbmFsU2l6ZSAhPT0ga25vd24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxTaGFwZTtcbiAgICB9O1xuICAgIFJlc2hhcGUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHZhciBhbnlVbmtub3duRGltcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVW5rbm93bihpbnB1dFNoYXBlW2ldKSkge1xuICAgICAgICAgICAgICAgIGFueVVua25vd25EaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55VW5rbm93bkRpbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFNoYXBlLnNsaWNlKDAsIDEpLmNvbmNhdCh0aGlzLnRhcmdldFNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFNoYXBlLnNsaWNlKDAsIDEpLmNvbmNhdCh0aGlzLmZpeFVua25vd25EaW1lbnNpb24oaW5wdXRTaGFwZS5zbGljZSgxKSwgdGhpcy50YXJnZXRTaGFwZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNoYXBlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIGlucHV0U2hhcGUgPSBLLnNoYXBlKGlucHV0KTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCwgMSkuY29uY2F0KF90aGlzLmZpeFVua25vd25EaW1lbnNpb24oaW5wdXRTaGFwZS5zbGljZSgxKSwgX3RoaXMudGFyZ2V0U2hhcGUpKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXNoYXBlKG91dHB1dFNoYXBlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXNoYXBlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICB0YXJnZXRTaGFwZTogdGhpcy50YXJnZXRTaGFwZSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBSZXNoYXBlLmNsYXNzTmFtZSA9ICdSZXNoYXBlJztcbiAgICByZXR1cm4gUmVzaGFwZTtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5SZXNoYXBlID0gUmVzaGFwZTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihSZXNoYXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBjb25zdHJhaW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0cmFpbnRzXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBpbml0aWFsaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9pbml0aWFsaXplcnNcIik7XG52YXIgcmVndWxhcml6ZXJzXzEgPSByZXF1aXJlKFwiLi4vcmVndWxhcml6ZXJzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBFbWJlZGRpbmcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbWJlZGRpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1iZWRkaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVtYmVkZGluZ3MgPSBudWxsO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0VNQkVERElOR1NfSU5JVElBTElaRVIgPSAncmFuZG9tVW5pZm9ybSc7XG4gICAgICAgIGlmIChjb25maWcuYmF0Y2hJbnB1dFNoYXBlID09IG51bGwgJiYgY29uZmlnLmlucHV0U2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmJhdGNoU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplID0gY29uZmlnLmJhdGNoU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcuaW5wdXRMZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmJhdGNoSW5wdXRTaGFwZSA9IFtiYXRjaFNpemUsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmF0Y2hJbnB1dFNoYXBlID1cbiAgICAgICAgICAgICAgICAgICAgW2JhdGNoU2l6ZV0uY29uY2F0KGdlbmVyaWNfdXRpbHMudG9MaXN0KGNvbmZpZy5pbnB1dExlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLmlucHV0RGltID0gY29uZmlnLmlucHV0RGltO1xuICAgICAgICBfdGhpcy5vdXRwdXREaW0gPSBjb25maWcub3V0cHV0RGltO1xuICAgICAgICBfdGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcuZW1iZWRkaW5nc0luaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfRU1CRURESU5HU19JTklUSUFMSVpFUik7XG4gICAgICAgIF90aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5lbWJlZGRpbmdzUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmFjdGl2aXR5UmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcuZW1iZWRkaW5nc0NvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5tYXNrWmVybyA9IGNvbmZpZy5tYXNrWmVybztcbiAgICAgICAgX3RoaXMuaW5wdXRMZW5ndGggPSBjb25maWcuaW5wdXRMZW5ndGg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRW1iZWRkaW5nLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHRoaXMuZW1iZWRkaW5ncyA9IHRoaXMuYWRkV2VpZ2h0KCdlbWJlZGRpbmdzJywgW3RoaXMuaW5wdXREaW0sIHRoaXMub3V0cHV0RGltXSwgdGhpcy5kdHlwZSwgdGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIsIHRoaXMuZW1iZWRkaW5nc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgfTtcbiAgICBFbWJlZGRpbmcucHJvdG90eXBlLmNvbXB1dGVNYXNrID0gZnVuY3Rpb24gKGlucHV0cywgbWFzaykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignY29tcHV0ZU1hc2sgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciBFbWJlZGRpbmcgeWV0Jyk7XG4gICAgfTtcbiAgICBFbWJlZGRpbmcucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRMZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0U2hhcGUuY29uY2F0KFt0aGlzLm91dHB1dERpbV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbkxlbnMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdCh0aGlzLmlucHV0TGVuZ3RoKTtcbiAgICAgICAgaWYgKGluTGVucy5sZW5ndGggIT09IGlucHV0U2hhcGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJcXFwiaW5wdXRMZW5ndGhcXFwiIGlzIFwiICsgdGhpcy5pbnB1dExlbmd0aCArIFwiLCBidXQgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgIChcImlucHV0IHNoYXBlIGhhcyBzaGFwZSBcIiArIGlucHV0U2hhcGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5MZW5zLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMxID0gaW5MZW5zW2tdO1xuICAgICAgICAgICAgICAgIHZhciBzMiA9IGlucHV0U2hhcGVbayArIDFdO1xuICAgICAgICAgICAgICAgIGlmICgoczEgIT0gbnVsbCkgJiYgKHMyICE9IG51bGwpICYmIChzMSAhPT0gczIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiXFxcImlucHV0TGVuZ3RoXFxcIiBpcyBcIiArIHRoaXMuaW5wdXRMZW5ndGggKyBcIiwgYnV0IHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImlucHV0IHNoYXBlIGhhcyBzaGFwZSBcIiArIGlucHV0U2hhcGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoczEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbkxlbnNbaV0gPSBzMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXV0uY29uY2F0KGluTGVucywgW3RoaXMub3V0cHV0RGltXSk7XG4gICAgfTtcbiAgICBFbWJlZGRpbmcucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICBpZiAoSy5kdHlwZShpbnB1dCkgIT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IEsuY2FzdChpbnB1dCwgJ2ludDMyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gSy5nYXRoZXIoX3RoaXMuZW1iZWRkaW5ncy5yZWFkKCksIGlucHV0LmFzMUQoKSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LnJlc2hhcGUoZ2VuZXJpY191dGlsc18xLmdldEV4YWN0bHlPbmVTaGFwZShfdGhpcy5jb21wdXRlT3V0cHV0U2hhcGUoaW5wdXQuc2hhcGUpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRW1iZWRkaW5nLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBpbnB1dERpbTogdGhpcy5pbnB1dERpbSxcbiAgICAgICAgICAgIG91dHB1dERpbTogdGhpcy5vdXRwdXREaW0sXG4gICAgICAgICAgICBlbWJlZGRpbmdzSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZW1iZWRkaW5nc0luaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGVtYmVkZGluZ3NSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5lbWJlZGRpbmdzUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYWN0aXZpdHlSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGVtYmVkZGluZ3NDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCksXG4gICAgICAgICAgICBtYXNrWmVybzogdGhpcy5tYXNrWmVybyxcbiAgICAgICAgICAgIGlucHV0TGVuZ3RoOiB0aGlzLmlucHV0TGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgRW1iZWRkaW5nLmNsYXNzTmFtZSA9ICdFbWJlZGRpbmcnO1xuICAgIHJldHVybiBFbWJlZGRpbmc7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuRW1iZWRkaW5nID0gRW1iZWRkaW5nO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEVtYmVkZGluZyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJlZGRpbmdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4uL2VuZ2luZS90b3BvbG9neVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIG1hdGhVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9tYXRoX3V0aWxzXCIpO1xudmFyIE1lcmdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2UoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZyB8fCB7fSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3VwcG9ydHNNYXNraW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZXJnZS5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlID0gZnVuY3Rpb24gKHNoYXBlMSwgc2hhcGUyKSB7XG4gICAgICAgIGlmIChzaGFwZTEgPT0gbnVsbCB8fCBzaGFwZTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hhcGUxLmxlbmd0aCA8IHNoYXBlMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUoc2hhcGUyLCBzaGFwZTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlMi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gc2hhcGUxLnNsaWNlKDAsIHNoYXBlMS5sZW5ndGggLSBzaGFwZTIubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaGFwZTIubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgIHZhciBpID0gc2hhcGUxW3NoYXBlMS5sZW5ndGggLSBzaGFwZTIubGVuZ3RoICsga107XG4gICAgICAgICAgICB2YXIgaiA9IHNoYXBlMltrXTtcbiAgICAgICAgICAgIGlmIChpID09IG51bGwgfHwgaiA9PSBudWxsIHx8IGkgPCAwIHx8IGogPCAwKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0U2hhcGUucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNoYXBlMSkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShzaGFwZTIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0U2hhcGUucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgfTtcbiAgICBNZXJnZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlKSAmJiAhQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlWzBdKSkge1xuICAgICAgICAgICAgaW5wdXRTaGFwZSA9IFtnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKV07XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdBIG1lcmdlIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYW4gQXJyYXkgb2YgYXQgbGVhc3QgMiBpbnB1dHMuJyArXG4gICAgICAgICAgICAgICAgKFwiIEdvdCBcIiArIGlucHV0U2hhcGUubGVuZ3RoICsgXCIgaW5wdXQocykuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmF0Y2hTaXplcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0U2hhcGVfMSA9IGlucHV0U2hhcGU7IF9pIDwgaW5wdXRTaGFwZV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gaW5wdXRTaGFwZV8xW19pXTtcbiAgICAgICAgICAgIGlmIChzaGFwZSAhPSBudWxsICYmIHNoYXBlWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplcy5wdXNoKHNoYXBlWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiYXRjaFNpemVzID0gZ2VuZXJpY191dGlscy51bmlxdWUoYmF0Y2hTaXplcyk7XG4gICAgICAgIGlmIChiYXRjaFNpemVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiQ2FuIG5vdCBtZXJnZSB0ZW5zb3JzIHdpdGggZGlmZmVyZW50IGJhdGNoIHNpemVzLiBcIiArXG4gICAgICAgICAgICAgICAgKFwiR290IHRlbnNvcnMgd2l0aCBzaGFwZXM6IFwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGVbMF0gPT0gbnVsbCA/IG51bGwgOiBpbnB1dFNoYXBlWzBdLnNsaWNlKDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGlucHV0U2hhcGVbaV0gPT0gbnVsbCA/IG51bGwgOiBpbnB1dFNoYXBlW2ldLnNsaWNlKDEpO1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSB0aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUob3V0cHV0U2hhcGUsIHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsUmFua3MgPSBpbnB1dFNoYXBlLm1hcChmdW5jdGlvbiAoc2hhcGUpIHsgcmV0dXJuIHNoYXBlLmxlbmd0aDsgfSk7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlLmluZGV4T2YobnVsbCkgPT09IC0xICYmXG4gICAgICAgICAgICBnZW5lcmljX3V0aWxzLnVuaXF1ZShhbGxSYW5rcykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2hhcGVSZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNoYXBlUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmVzaGFwZVJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc2hhcGVkSW5wdXRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0RGltcyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5yYW5rOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXREaW1zLmluZGV4T2YobnVsbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhORGltID0gbWF0aFV0aWxzLm1heChpbnB1dERpbXMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c18xID0gaW5wdXRzOyBfaSA8IGlucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBpbnB1dHNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeE5EaW0gPSB4LnJhbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG1heE5EaW0gLSB4TkRpbTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IEsuZXhwYW5kRGltcyh4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2hhcGVkSW5wdXRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1lcmdlRnVuY3Rpb24ocmVzaGFwZWRJbnB1dHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBpbnB1dHNfMiA9IGlucHV0czsgX2EgPCBpbnB1dHNfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gaW5wdXRzXzJbX2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhORGltID0geC5yYW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhORGltID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFNoYXBlID0gSy5zaGFwZSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0geFNoYXBlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IHhTaGFwZS5zbGljZSgxKS5jb25jYXQoW2JhdGNoU2l6ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4VHJhbnNwb3NlZCA9IHgucmVzaGFwZShbYmF0Y2hTaXplXS5jb25jYXQobWF0aFV0aWxzLmFycmF5UHJvZCh4U2hhcGUuc2xpY2UoMSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFRyYW5zcG9zZWQgPSB0ZmMudHJhbnNwb3NlKHhUcmFuc3Bvc2VkLCBbMSwgMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhUcmFuc3Bvc2VkID0geFRyYW5zcG9zZWQucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaGFwZWRJbnB1dHMucHVzaCh4VHJhbnNwb3NlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4TkRpbSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGltcyA9IG1hdGhVdGlscy5yYW5nZSgxLCB4TkRpbSkuY29uY2F0KFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaGFwZWRJbnB1dHMucHVzaCh0ZmMudHJhbnNwb3NlKHgsIGRpbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2hhcGVkSW5wdXRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBfdGhpcy5tZXJnZUZ1bmN0aW9uKHJlc2hhcGVkSW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlORGltID0geS5yYW5rO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHlORGltID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeVNoYXBlID0gSy5zaGFwZSh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeU5EaW1fMSA9IHlTaGFwZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHlTaGFwZVt5TkRpbV8xIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gW2JhdGNoU2l6ZV0uY29uY2F0KHlTaGFwZS5zbGljZSgwLCB5U2hhcGUubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0ZmMudHJhbnNwb3NlKHkucmVzaGFwZShbLTEsIGJhdGNoU2l6ZV0pLCBbMSwgMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHlORGltID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaW1zID0gW3lORGltIC0gMV0uY29uY2F0KG1hdGhVdGlscy5yYW5nZSgwLCB5TkRpbSAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gdGZjLnRyYW5zcG9zZSh5LCBkaW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWVyZ2VGdW5jdGlvbihpbnB1dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlO1xuICAgICAgICBpZiAoaW5wdXRTaGFwZVswXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGVbMF0uc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBpbnB1dFNoYXBlW2ldID09IG51bGwgPyBudWxsIDogaW5wdXRTaGFwZVtpXS5zbGljZSgxKTtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlID0gdGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKG91dHB1dFNoYXBlLCBzaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhdGNoU2l6ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dFNoYXBlXzIgPSBpbnB1dFNoYXBlOyBfaSA8IGlucHV0U2hhcGVfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGlucHV0U2hhcGVfMltfaV07XG4gICAgICAgICAgICBpZiAoc2hhcGUgIT0gbnVsbCAmJiBzaGFwZVswXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJhdGNoU2l6ZXMucHVzaChzaGFwZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmF0Y2hTaXplcyA9IGdlbmVyaWNfdXRpbHMudW5pcXVlKGJhdGNoU2l6ZXMpO1xuICAgICAgICBpZiAoYmF0Y2hTaXplcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlID0gYmF0Y2hTaXplcy5jb25jYXQob3V0cHV0U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSBbbnVsbF0uY29uY2F0KG91dHB1dFNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2U7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuTWVyZ2UgPSBNZXJnZTtcbnZhciBBZGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRkKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBZGQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0ZmMuemVyb3MoaW5wdXRzWzBdLnNoYXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRzXzMgPSBpbnB1dHM7IF9pIDwgaW5wdXRzXzMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzXzNbX2ldO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRmYy5hZGQob3V0cHV0LCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFkZC5jbGFzc05hbWUgPSAnQWRkJztcbiAgICByZXR1cm4gQWRkO1xufShNZXJnZSkpO1xuZXhwb3J0cy5BZGQgPSBBZGQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoQWRkKTtcbmZ1bmN0aW9uIGFkZChjb25maWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBBZGQoe30pO1xuICAgICAgICByZXR1cm4gbGF5ZXIuYXBwbHkoY29uZmlnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkKGNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5hZGQgPSBhZGQ7XG52YXIgTXVsdGlwbHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aXBseSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aXBseShjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICB9XG4gICAgTXVsdGlwbHkucHJvdG90eXBlLm1lcmdlRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0ZmMub25lcyhpbnB1dHNbMF0uc2hhcGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dHNfNCA9IGlucHV0czsgX2kgPCBpbnB1dHNfNC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfNFtfaV07XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGZjLm11bChvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTXVsdGlwbHkuY2xhc3NOYW1lID0gJ011bHRpcGx5JztcbiAgICByZXR1cm4gTXVsdGlwbHk7XG59KE1lcmdlKSk7XG5leHBvcnRzLk11bHRpcGx5ID0gTXVsdGlwbHk7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTXVsdGlwbHkpO1xuZnVuY3Rpb24gbXVsdGlwbHkoY29uZmlnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgTXVsdGlwbHkoe30pO1xuICAgICAgICByZXR1cm4gbGF5ZXIuYXBwbHkoY29uZmlnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlwbHkoY29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG52YXIgQXZlcmFnZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF2ZXJhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXZlcmFnZShjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICB9XG4gICAgQXZlcmFnZS5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRmYy56ZXJvcyhpbnB1dHNbMF0uc2hhcGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dHNfNSA9IGlucHV0czsgX2kgPCBpbnB1dHNfNS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfNVtfaV07XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGZjLmFkZChvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBLLnNjYWxhclRpbWVzQXJyYXkoSy5nZXRTY2FsYXIoMSAvIGlucHV0cy5sZW5ndGgpLCBvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF2ZXJhZ2UuY2xhc3NOYW1lID0gJ0F2ZXJhZ2UnO1xuICAgIHJldHVybiBBdmVyYWdlO1xufShNZXJnZSkpO1xuZXhwb3J0cy5BdmVyYWdlID0gQXZlcmFnZTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihBdmVyYWdlKTtcbmZ1bmN0aW9uIGF2ZXJhZ2UoY29uZmlnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgQXZlcmFnZSh7fSk7XG4gICAgICAgIHJldHVybiBsYXllci5hcHBseShjb25maWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdmVyYWdlKGNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5hdmVyYWdlID0gYXZlcmFnZTtcbnZhciBNYXhpbXVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4aW11bSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXhpbXVtKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNYXhpbXVtLnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gaW5wdXRzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0ZmMubWF4aW11bShvdXRwdXQsIGlucHV0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1heGltdW0uY2xhc3NOYW1lID0gJ01heGltdW0nO1xuICAgIHJldHVybiBNYXhpbXVtO1xufShNZXJnZSkpO1xuZXhwb3J0cy5NYXhpbXVtID0gTWF4aW11bTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihNYXhpbXVtKTtcbmZ1bmN0aW9uIG1heGltdW0oY29uZmlnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgTWF4aW11bSh7fSk7XG4gICAgICAgIHJldHVybiBsYXllci5hcHBseShjb25maWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXhpbXVtKGNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5tYXhpbXVtID0gbWF4aW11bTtcbnZhciBNaW5pbXVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWluaW11bSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaW5pbXVtKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNaW5pbXVtLnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gaW5wdXRzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0ZmMubWluaW11bShvdXRwdXQsIGlucHV0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1pbmltdW0uY2xhc3NOYW1lID0gJ01pbmltdW0nO1xuICAgIHJldHVybiBNaW5pbXVtO1xufShNZXJnZSkpO1xuZXhwb3J0cy5NaW5pbXVtID0gTWluaW11bTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihNaW5pbXVtKTtcbmZ1bmN0aW9uIG1pbmltdW0oY29uZmlnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgTWluaW11bSh7fSk7XG4gICAgICAgIHJldHVybiBsYXllci5hcHBseShjb25maWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNaW5pbXVtKGNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5taW5pbXVtID0gbWluaW11bTtcbnZhciBDb25jYXRlbmF0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdGVuYXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdGVuYXRlKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQVhJUyA9IC0xO1xuICAgICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmF4aXMgPSBjb25maWcuYXhpcyA9PSBudWxsID8gX3RoaXMuREVGQVVMVF9BWElTIDogY29uZmlnLmF4aXM7XG4gICAgICAgIF90aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJlc2hhcGVSZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhdGVuYXRlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoaW5wdXRTaGFwZSkgJiYgQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlWzBdKSkgfHxcbiAgICAgICAgICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGF0IGxlYXN0IDIgJyArXG4gICAgICAgICAgICAgICAgJ2lucHV0cycpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgYWxsTm9uZVNoYXBlID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dFNoYXBlXzMgPSBpbnB1dFNoYXBlOyBfaSA8IGlucHV0U2hhcGVfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGlucHV0U2hhcGVfM1tfaV07XG4gICAgICAgICAgICBpZiAoc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFsbE5vbmVTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxOb25lU2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhcGVTZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGVXaXRob3V0Q29uY2F0QXhpcyA9IGlucHV0U2hhcGVbaV0uc2xpY2UoKTtcbiAgICAgICAgICAgIHNoYXBlV2l0aG91dENvbmNhdEF4aXMuc3BsaWNlKHRoaXMuYXhpcywgMSk7XG4gICAgICAgICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNoYXBlU2V0XzEgPSBzaGFwZVNldDsgX2EgPCBzaGFwZVNldF8xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlU2V0XzFbX2FdO1xuICAgICAgICAgICAgICAgIGlmICh0ZmpzX2NvcmVfMS51dGlsLmFycmF5c0VxdWFsKHNoYXBlLCBzaGFwZVdpdGhvdXRDb25jYXRBeGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgICAgICAgIHNoYXBlU2V0LnB1c2goc2hhcGVXaXRob3V0Q29uY2F0QXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlU2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgcmVxdWlyZXMgaW5wdXRzIHdpdGggbWF0Y2hpbmcgc2hhcGVzICcgK1xuICAgICAgICAgICAgICAgICdleGNlcHQgZm9yIHRoZSBjb25jYXQgYXhpcy4gR290IGlucHV0IHNoYXBlczogJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25jYXRlbmF0ZS5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEsuY29uY2F0ZW5hdGUoaW5wdXRzLCBfdGhpcy5heGlzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25jYXRlbmF0ZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlKSAmJiBBcnJheS5pc0FycmF5KGlucHV0U2hhcGVbMF0pKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0EgYENvbmNhdGVuYXRlYCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBpbnB1dHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0U2hhcGVzID0gaW5wdXRTaGFwZTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZXNbMF0uc2xpY2UoKTtcbiAgICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4aXMgPCAwID8gb3V0cHV0U2hhcGUubGVuZ3RoICsgdGhpcy5heGlzIDogdGhpcy5heGlzO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gaW5wdXRTaGFwZXMuc2xpY2UoMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAob3V0cHV0U2hhcGVbYXhpc10gPT0gbnVsbCB8fCBzaGFwZVtheGlzXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVbYXhpc10gPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0U2hhcGVbYXhpc10gKz0gc2hhcGVbYXhpc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICAgIH07XG4gICAgQ29uY2F0ZW5hdGUucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICdheGlzJzogdGhpcy5heGlzLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIENvbmNhdGVuYXRlLmNsYXNzTmFtZSA9ICdDb25jYXRlbmF0ZSc7XG4gICAgcmV0dXJuIENvbmNhdGVuYXRlO1xufShNZXJnZSkpO1xuZXhwb3J0cy5Db25jYXRlbmF0ZSA9IENvbmNhdGVuYXRlO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKENvbmNhdGVuYXRlKTtcbmZ1bmN0aW9uIGNvbmNhdGVuYXRlKGNvbmZpZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbmV3IENvbmNhdGVuYXRlKHt9KTtcbiAgICAgICAgcmV0dXJuIGxheWVyLmFwcGx5KGNvbmZpZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IENvbmNhdGVuYXRlKGNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5jb25jYXRlbmF0ZSA9IGNvbmNhdGVuYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGNvbnN0cmFpbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RyYWludHNcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGluaXRpYWxpemVyc18xID0gcmVxdWlyZShcIi4uL2luaXRpYWxpemVyc1wiKTtcbnZhciByZWd1bGFyaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9yZWd1bGFyaXplcnNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIG1hdGhfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWF0aF91dGlsc1wiKTtcbmZ1bmN0aW9uIGJhdGNoTm9ybWFsaXphdGlvbih4LCBtZWFuLCB2YXJpYW5jZSwgYmV0YSwgZ2FtbWEsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS0zOyB9XG4gICAgdmFyIG91dDtcbiAgICBpZiAoeC5yYW5rID09PSAyKSB7XG4gICAgICAgIG91dCA9IHRmYy5iYXRjaE5vcm1hbGl6YXRpb24yZCh4LCBtZWFuLCB2YXJpYW5jZSwgZXBzaWxvbiwgZ2FtbWEsIGJldGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgb3V0ID0gdGZjLmJhdGNoTm9ybWFsaXphdGlvbjNkKHgsIG1lYW4sIHZhcmlhbmNlLCBlcHNpbG9uLCBnYW1tYSwgYmV0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucmFuayA9PT0gNCkge1xuICAgICAgICBvdXQgPSB0ZmMuYmF0Y2hOb3JtYWxpemF0aW9uNGQoeCwgbWVhbiwgdmFyaWFuY2UsIGVwc2lsb24sIGdhbW1hLCBiZXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2hOb3JtYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbW50ZWQgZm9yIGFycmF5IG9mIHJhbmsgXCIgKyB4LnJhbmsgKyBcIiBcIiArXG4gICAgICAgICAgICBcInlldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMuYmF0Y2hOb3JtYWxpemF0aW9uID0gYmF0Y2hOb3JtYWxpemF0aW9uO1xuZnVuY3Rpb24gcmVndWxhck5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyh4LCBnYW1tYSwgYmV0YSwgcmVkdWN0aW9uQXhlcywgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTM7IH1cbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWFuQW5kVmFyaWFuY2UgPSB0ZmMubW9tZW50cyh4LCByZWR1Y3Rpb25BeGVzKTtcbiAgICAgICAgdmFyIG1lYW4gPSBtZWFuQW5kVmFyaWFuY2UubWVhbjtcbiAgICAgICAgdmFyIHZhcmlhbmNlID0gbWVhbkFuZFZhcmlhbmNlLnZhcmlhbmNlO1xuICAgICAgICB2YXIgbm9ybWVkID0gYmF0Y2hOb3JtYWxpemF0aW9uKHgsIG1lYW4sIHZhcmlhbmNlLCBiZXRhLCBnYW1tYSwgZXBzaWxvbik7XG4gICAgICAgIHJldHVybiBbbm9ybWVkLCBtZWFuLCB2YXJpYW5jZV07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBicm9hZGNhc3ROb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoeCwgZ2FtbWEsIGJldGEsIHJlZHVjdGlvbkF4ZXMsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS0zOyB9XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVhbkFuZFZhcmlhbmNlID0gdGZjLm1vbWVudHMoeCwgcmVkdWN0aW9uQXhlcyk7XG4gICAgICAgIHZhciBtZWFuID0gbWVhbkFuZFZhcmlhbmNlLm1lYW47XG4gICAgICAgIHZhciB2YXJpYW5jZSA9IG1lYW5BbmRWYXJpYW5jZS52YXJpYW5jZTtcbiAgICAgICAgdmFyIHRhcmdldFNoYXBlID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtYXRoX3V0aWxzLnJhbmdlKDAsIHgucmFuayk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChyZWR1Y3Rpb25BeGVzLmluZGV4T2YoYXhpcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2hhcGUucHVzaCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlLnB1c2goeC5zaGFwZVtheGlzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJyb2FkY2FzdE1lYW4gPSBtZWFuLnJlc2hhcGUodGFyZ2V0U2hhcGUpO1xuICAgICAgICB2YXIgYnJvYWRjYXN0VmFyaWFuY2UgPSB2YXJpYW5jZS5yZXNoYXBlKHRhcmdldFNoYXBlKTtcbiAgICAgICAgdmFyIGJyb2FkY2FzdEdhbW1hID0gZ2FtbWEgPT0gbnVsbCA/IG51bGwgOiBnYW1tYS5yZXNoYXBlKHRhcmdldFNoYXBlKTtcbiAgICAgICAgdmFyIGJyb2FkY2FzdEJldGEgPSBiZXRhID09IG51bGwgPyBudWxsIDogYmV0YS5yZXNoYXBlKHRhcmdldFNoYXBlKTtcbiAgICAgICAgdmFyIG5vcm1lZCA9IGJhdGNoTm9ybWFsaXphdGlvbih4LCBicm9hZGNhc3RNZWFuLCBicm9hZGNhc3RWYXJpYW5jZSwgYnJvYWRjYXN0QmV0YSwgYnJvYWRjYXN0R2FtbWEsIGVwc2lsb24pO1xuICAgICAgICByZXR1cm4gW25vcm1lZCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKHgsIGdhbW1hLCBiZXRhLCByZWR1Y3Rpb25BeGVzLCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtMzsgfVxuICAgIGlmICh0ZmpzX2NvcmVfMS51dGlsLmFycmF5c0VxdWFsKHJlZHVjdGlvbkF4ZXMuc2xpY2UoKS5zb3J0KCksIG1hdGhfdXRpbHMucmFuZ2UoMCwgeC5yYW5rIC0gMSkpKSB7XG4gICAgICAgIHJldHVybiByZWd1bGFyTm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKHgsIGdhbW1hLCBiZXRhLCByZWR1Y3Rpb25BeGVzLCBlcHNpbG9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBicm9hZGNhc3ROb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoeCwgZ2FtbWEsIGJldGEsIHJlZHVjdGlvbkF4ZXMsIGVwc2lsb24pO1xuICAgIH1cbn1cbmV4cG9ydHMubm9ybWFsaXplQmF0Y2hJblRyYWluaW5nID0gbm9ybWFsaXplQmF0Y2hJblRyYWluaW5nO1xudmFyIEJhdGNoTm9ybWFsaXphdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhdGNoTm9ybWFsaXphdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXRjaE5vcm1hbGl6YXRpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3VwcG9ydHNNYXNraW5nID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGNvbmZpZy5heGlzID09IG51bGwgPyAtMSA6IGNvbmZpZy5heGlzO1xuICAgICAgICBfdGhpcy5tb21lbnR1bSA9IGNvbmZpZy5tb21lbnR1bSA9PSBudWxsID8gMC45OSA6IGNvbmZpZy5tb21lbnR1bTtcbiAgICAgICAgX3RoaXMuZXBzaWxvbiA9IGNvbmZpZy5lcHNpbG9uID09IG51bGwgPyAxZS0zIDogY29uZmlnLmVwc2lsb247XG4gICAgICAgIF90aGlzLmNlbnRlciA9IGNvbmZpZy5jZW50ZXIgPT0gbnVsbCA/IHRydWUgOiBjb25maWcuY2VudGVyO1xuICAgICAgICBfdGhpcy5zY2FsZSA9IGNvbmZpZy5zY2FsZSA9PSBudWxsID8gdHJ1ZSA6IGNvbmZpZy5zY2FsZTtcbiAgICAgICAgX3RoaXMuYmV0YUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmJldGFJbml0aWFsaXplciB8fCAnemVyb3MnKTtcbiAgICAgICAgX3RoaXMuZ2FtbWFJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5nYW1tYUluaXRpYWxpemVyIHx8ICdvbmVzJyk7XG4gICAgICAgIF90aGlzLm1vdmluZ01lYW5Jbml0aWFsaXplciA9XG4gICAgICAgICAgICBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcubW92aW5nTWVhbkluaXRpYWxpemVyIHx8ICd6ZXJvcycpO1xuICAgICAgICBfdGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyID1cbiAgICAgICAgICAgIGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyIHx8ICdvbmVzJyk7XG4gICAgICAgIF90aGlzLmJldGFDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5iZXRhQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmdhbW1hQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcuZ2FtbWFDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMuYmV0YVJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmJldGFSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmdhbW1hUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcuZ2FtbWFSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLnN0ZXBDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmF0Y2hOb3JtYWxpemF0aW9uLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4aXMgPj0gMCA/IHRoaXMuYXhpcyA6ICh0aGlzLmF4aXMgKyBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICAgIHZhciBkaW0gPSBpbnB1dFNoYXBlW2F4aXNdO1xuICAgICAgICBpZiAoZGltID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiQXhpcyBcIiArIGF4aXMgKyBcIiBvZiBpbnB1dCB0ZW5zb3Igc2hvdWxkIGhhdmUgYSBkZWZpbmVkIGRpbWVuc2lvbiBidXQgXCIgK1xuICAgICAgICAgICAgICAgIFwidGhlIGxheWVyIHJlY2VpdmVkIGFuIGlucHV0IHdpdGggc2hhcGUgXCIgK1xuICAgICAgICAgICAgICAgIChKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dFNwZWMgPVxuICAgICAgICAgICAgW25ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IG5kaW06IGlucHV0U2hhcGUubGVuZ3RoLCBheGVzOiAoX2EgPSB7fSwgX2FbYXhpc10gPSBkaW0sIF9hKSB9KV07XG4gICAgICAgIHZhciBzaGFwZSA9IFtkaW1dO1xuICAgICAgICBpZiAodGhpcy5zY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5nYW1tYSA9IHRoaXMuYWRkV2VpZ2h0KCdnYW1tYScsIHNoYXBlLCBudWxsLCB0aGlzLmdhbW1hSW5pdGlhbGl6ZXIsIHRoaXMuZ2FtbWFSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5nYW1tYUNvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgICAgICAgdGhpcy5iZXRhID0gdGhpcy5hZGRXZWlnaHQoJ2JldGEnLCBzaGFwZSwgbnVsbCwgdGhpcy5iZXRhSW5pdGlhbGl6ZXIsIHRoaXMuYmV0YVJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJldGFDb25zdHJhaW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmluZ01lYW4gPSB0aGlzLmFkZFdlaWdodCgnbW92aW5nX21lYW4nLCBzaGFwZSwgbnVsbCwgdGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tb3ZpbmdWYXJpYW5jZSA9IHRoaXMuYWRkV2VpZ2h0KCdtb3ZpbmdfdmFyaWFuY2UnLCBzaGFwZSwgbnVsbCwgdGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBCYXRjaE5vcm1hbGl6YXRpb24ucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRyYWluaW5nID0ga3dhcmdzWyd0cmFpbmluZyddID09IG51bGwgPyBmYWxzZSA6IGt3YXJnc1sndHJhaW5pbmcnXTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIGlucHV0U2hhcGUgPSBLLnNoYXBlKGlucHV0KTtcbiAgICAgICAgICAgIHZhciBuZGltID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgcmVkdWN0aW9uQXhlcyA9IG1hdGhfdXRpbHMucmFuZ2UoMCwgbmRpbSk7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IF90aGlzLmF4aXMgPj0gMCA/IF90aGlzLmF4aXMgOiAoX3RoaXMuYXhpcyArIG5kaW0pO1xuICAgICAgICAgICAgcmVkdWN0aW9uQXhlcy5zcGxpY2UoYXhpcywgMSk7XG4gICAgICAgICAgICB2YXIgYnJvYWRjYXN0U2hhcGUgPSBnZW5lcmljX3V0aWxzLnB5TGlzdFJlcGVhdCgxLCBuZGltKTtcbiAgICAgICAgICAgIGJyb2FkY2FzdFNoYXBlW2F4aXNdID0gaW5wdXRTaGFwZVtheGlzXTtcbiAgICAgICAgICAgIHZhciBzb3J0ZWRSZWR1Y3Rpb25BeGVzID0gcmVkdWN0aW9uQXhlcy5zbGljZSgpO1xuICAgICAgICAgICAgc29ydGVkUmVkdWN0aW9uQXhlcy5zb3J0KCk7XG4gICAgICAgICAgICB2YXIgbmVlZHNCcm9hZGNhc3RpbmcgPSAhdGZqc19jb3JlXzEudXRpbC5hcnJheXNFcXVhbChzb3J0ZWRSZWR1Y3Rpb25BeGVzLCBtYXRoX3V0aWxzLnJhbmdlKDAsIG5kaW0pLnNsaWNlKDAsIG5kaW0gLSAxKSk7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplSW5mZXJlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChuZWVkc0Jyb2FkY2FzdGluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnJvYWRjYXN0TW92aW5nTWVhbiA9IF90aGlzLm1vdmluZ01lYW4ucmVhZCgpLnJlc2hhcGUoYnJvYWRjYXN0U2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnJvYWRjYXN0TW92aW5nVmFyaWFuY2UgPSBfdGhpcy5tb3ZpbmdWYXJpYW5jZS5yZWFkKCkucmVzaGFwZShicm9hZGNhc3RTaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBicm9hZGNhc3RCZXRhID0gX3RoaXMuY2VudGVyID8gX3RoaXMuYmV0YS5yZWFkKCkucmVzaGFwZShicm9hZGNhc3RTaGFwZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnJvYWRjYXN0R2FtbWEgPSBfdGhpcy5zY2FsZSA/IF90aGlzLmdhbW1hLnJlYWQoKS5yZXNoYXBlKGJyb2FkY2FzdFNoYXBlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaE5vcm1hbGl6YXRpb24oaW5wdXQsIGJyb2FkY2FzdE1vdmluZ01lYW4sIGJyb2FkY2FzdE1vdmluZ1ZhcmlhbmNlLCBicm9hZGNhc3RCZXRhLCBicm9hZGNhc3RHYW1tYSwgX3RoaXMuZXBzaWxvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2hOb3JtYWxpemF0aW9uKGlucHV0LCBfdGhpcy5tb3ZpbmdNZWFuLnJlYWQoKSwgX3RoaXMubW92aW5nVmFyaWFuY2UucmVhZCgpLCBfdGhpcy5iZXRhID09IG51bGwgPyBudWxsIDogX3RoaXMuYmV0YS5yZWFkKCksIF90aGlzLmdhbW1hID09IG51bGwgPyBudWxsIDogX3RoaXMuZ2FtbWEucmVhZCgpLCBfdGhpcy5lcHNpbG9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF0cmFpbmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVJbmZlcmVuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhpbnB1dCwgX3RoaXMuZ2FtbWEucmVhZCgpLCBfdGhpcy5iZXRhLnJlYWQoKSwgcmVkdWN0aW9uQXhlcywgX3RoaXMuZXBzaWxvbiksIG5vcm1lZFRyYWluaW5nID0gX2FbMF0sIG1lYW4gPSBfYVsxXSwgdmFyaWFuY2UgPSBfYVsyXTtcbiAgICAgICAgICAgIHZhciBzYW1wbGVTaXplID0gbWF0aF91dGlscy5hcnJheVByb2QocmVkdWN0aW9uQXhlcy5tYXAoZnVuY3Rpb24gKGF4aXMpIHsgcmV0dXJuIGlucHV0LnNoYXBlW2F4aXNdOyB9KSk7XG4gICAgICAgICAgICB2YXIgdmFyaWFuY2VEZWJpYXNlZCA9IHZhcmlhbmNlLm11bChLLmdldFNjYWxhcihzYW1wbGVTaXplIC8gKHNhbXBsZVNpemUgLSAoMSArIF90aGlzLmVwc2lsb24pKSkpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZU1vdmluZ01lYW5BbmRWYXJpYW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGVwQ291bnQrKztcbiAgICAgICAgICAgICAgICB2YXIgbmV3TW92aW5nTWVhbiA9IHRmYy5tb3ZpbmdBdmVyYWdlKF90aGlzLm1vdmluZ01lYW4ucmVhZCgpLCBtZWFuLCBfdGhpcy5tb21lbnR1bSwgX3RoaXMuc3RlcENvdW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3ZpbmdNZWFuLndyaXRlKG5ld01vdmluZ01lYW4pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdNb3ZpbmdWYXJpYW5jZSA9IHRmYy5tb3ZpbmdBdmVyYWdlKF90aGlzLm1vdmluZ1ZhcmlhbmNlLnJlYWQoKSwgdmFyaWFuY2VEZWJpYXNlZCwgX3RoaXMubW9tZW50dW0sIF90aGlzLnN0ZXBDb3VudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubW92aW5nVmFyaWFuY2Uud3JpdGUobmV3TW92aW5nVmFyaWFuY2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHVwZGF0ZU1vdmluZ01lYW5BbmRWYXJpYW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1lZFRyYWluaW5nO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhdGNoTm9ybWFsaXphdGlvbi5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgYXhpczogdGhpcy5heGlzLFxuICAgICAgICAgICAgbW9tZW50dW06IHRoaXMubW9tZW50dW0sXG4gICAgICAgICAgICBlcHNpbG9uOiB0aGlzLmVwc2lsb24sXG4gICAgICAgICAgICBjZW50ZXI6IHRoaXMuY2VudGVyLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICAgICAgICBiZXRhSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmV0YUluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGdhbW1hSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZ2FtbWFJbml0aWFsaXplciksXG4gICAgICAgICAgICBtb3ZpbmdNZWFuSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIG1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMubW92aW5nVmFyaWFuY2VJbml0aWFsaXplciksXG4gICAgICAgICAgICBiZXRhUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmV0YVJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGdhbW1hUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZ2FtbWFSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiZXRhQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmV0YUNvbnN0cmFpbnQpLFxuICAgICAgICAgICAgZ2FtbWFDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5nYW1tYUNvbnN0cmFpbnQpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgQmF0Y2hOb3JtYWxpemF0aW9uLmNsYXNzTmFtZSA9ICdCYXRjaE5vcm1hbGl6YXRpb24nO1xuICAgIHJldHVybiBCYXRjaE5vcm1hbGl6YXRpb247XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuQmF0Y2hOb3JtYWxpemF0aW9uID0gQmF0Y2hOb3JtYWxpemF0aW9uO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEJhdGNoTm9ybWFsaXphdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vYmFja2VuZC9jb21tb25cIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xuZnVuY3Rpb24gdGVtcG9yYWxQYWRkaW5nKHgsIHBhZGRpbmcpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4LnJhbmsgIT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwidGVtcG9yYWxQYWRkaW5nIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIDMtRCwgYnV0IHJlY2VpdmVkIGEgXCIgK1xuICAgICAgICAgICAgICAgICh4LnJhbmsgKyBcIi1EIHRlbnNvci5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmcubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcInRlbXBvcmFsUGFkZGluZyBleHBlY3RzIGlucHV0IHBhZGRpbmcgcGF0dGVybiB0byBiZSBhIGxlbmd0aC0yIFwiICtcbiAgICAgICAgICAgICAgICAoXCJhcnJheSwgYnV0IHJlY2VpdmVkIGEgbGVuZ3RoLVwiICsgcGFkZGluZy5sZW5ndGggKyBcIiBhcnJheS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXR0ZXJuID0gW1swLCAwXSwgcGFkZGluZywgWzAsIDBdXTtcbiAgICAgICAgcmV0dXJuIHRmYy5wYWQoeCwgcGF0dGVybik7XG4gICAgfSk7XG59XG5leHBvcnRzLnRlbXBvcmFsUGFkZGluZyA9IHRlbXBvcmFsUGFkZGluZztcbmZ1bmN0aW9uIHNwYXRpYWwyZFBhZGRpbmcoeCwgcGFkZGluZywgZGF0YUZvcm1hdCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHgucmFuayAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJ0ZW1wb3JhbFBhZGRpbmcgZXhwZWN0cyBpbnB1dCB0ZW5zb3IgdG8gYmUgNC1ELCBidXQgcmVjZWl2ZWQgYSBcIiArXG4gICAgICAgICAgICAgICAgKHgucmFuayArIFwiLUQgdGVuc29yLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFkZGluZyA9IFtbMSwgMV0sIFsxLCAxXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmcubGVuZ3RoICE9PSAyIHx8IHBhZGRpbmdbMF0ubGVuZ3RoICE9PSAyIHx8XG4gICAgICAgICAgICBwYWRkaW5nWzFdLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ3NwYXRpYWwyZFBhZGRpbmcgZXhwZWN0cyBgcGFkZGluZ2AgdG8gYmUgYW4gQXJyYXkgb2YgdHdvIEFycmF5cywgJyArXG4gICAgICAgICAgICAgICAgJ2VhY2ggb2Ygd2hpY2ggaXMgYW4gQXJyYXkgb2YgdHdvIGludGVnZXJzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFGb3JtYXQgPSBjb21tb25fMS5pbWFnZURhdGFGb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUZvcm1hdCAhPT0gJ2NoYW5uZWxzTGFzdCcgJiYgZGF0YUZvcm1hdCAhPT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlVua25vd24gZGF0YSBmb3JtYXQ6IFwiICsgZGF0YUZvcm1hdCArIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgXCJTdXBwb3J0ZWQgZGF0YSBmb3JtYXRzIGFyZSAnY2hhbm5lbHNMYXN0JyBhbmQgJ2NoYW5uZWxzRmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXR0ZXJuO1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gW1swLCAwXSwgWzAsIDBdLCBwYWRkaW5nWzBdLCBwYWRkaW5nWzFdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBbWzAsIDBdLCBwYWRkaW5nWzBdLCBwYWRkaW5nWzFdLCBbMCwgMF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZmMucGFkKHgsIHBhdHRlcm4pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zcGF0aWFsMmRQYWRkaW5nID0gc3BhdGlhbDJkUGFkZGluZztcbnZhciBaZXJvUGFkZGluZzJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWmVyb1BhZGRpbmcyRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaZXJvUGFkZGluZzJEKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhRm9ybWF0ID1cbiAgICAgICAgICAgIGNvbmZpZy5kYXRhRm9ybWF0ID09IG51bGwgPyBjb21tb25fMS5pbWFnZURhdGFGb3JtYXQoKSA6IGNvbmZpZy5kYXRhRm9ybWF0O1xuICAgICAgICBpZiAoY29uZmlnLnBhZGRpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMucGFkZGluZyA9IFtbMSwgMV0sIFsxLCAxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZy5wYWRkaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgX3RoaXMucGFkZGluZyA9XG4gICAgICAgICAgICAgICAgW1tjb25maWcucGFkZGluZywgY29uZmlnLnBhZGRpbmddLCBbY29uZmlnLnBhZGRpbmcsIGNvbmZpZy5wYWRkaW5nXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25maWcucGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5wYWRkaW5nLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiWmVyb1BhZGRpbmcyRCBleHBlY3RzIHBhZGRpbmcgdG8gYmUgYSBsZW5ndGgtMiBhcnJheSwgYnV0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwicmVjZWl2ZWQgYSBsZW5ndGgtXCIgKyBjb25maWcucGFkZGluZy5sZW5ndGggKyBcIiBhcnJheS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlaWdodFBhZGRpbmcgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgd2lkdGhQYWRkaW5nID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcucGFkZGluZ1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHRQYWRkaW5nID1cbiAgICAgICAgICAgICAgICAgICAgW2NvbmZpZy5wYWRkaW5nWzBdLCBjb25maWcucGFkZGluZ1swXV07XG4gICAgICAgICAgICAgICAgd2lkdGhQYWRkaW5nID1cbiAgICAgICAgICAgICAgICAgICAgW2NvbmZpZy5wYWRkaW5nWzFdLCBjb25maWcucGFkZGluZ1sxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcucGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcucGFkZGluZ1swXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJaZXJvUGFkZGluZzJEIGV4cGVjdHMgaGVpZ2h0IHBhZGRpbmcgdG8gYmUgYSBsZW5ndGgtMiBhcnJheSwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnV0IHJlY2VpdmVkIGEgbGVuZ3RoLVwiICsgY29uZmlnLnBhZGRpbmdbMF0ubGVuZ3RoICsgXCIgYXJyYXkuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0UGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcucGFkZGluZ1sxXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJaZXJvUGFkZGluZzJEIGV4cGVjdHMgd2lkdGggcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJidXQgcmVjZWl2ZWQgYSBsZW5ndGgtXCIgKyBjb25maWcucGFkZGluZ1sxXS5sZW5ndGggKyBcIiBhcnJheS5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aWR0aFBhZGRpbmcgPSBjb25maWcucGFkZGluZ1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnBhZGRpbmcgPSBbaGVpZ2h0UGFkZGluZywgd2lkdGhQYWRkaW5nXTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbbmV3IHRvcG9sb2d5XzEuSW5wdXRTcGVjKHsgbmRpbTogNCB9KV07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWmVyb1BhZGRpbmcyRC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHNfMS5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIHZhciByb3dzO1xuICAgICAgICB2YXIgY29scztcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXRTaGFwZVsyXSAhPSBudWxsICYmIGlucHV0U2hhcGVbMl0gPj0gMCkge1xuICAgICAgICAgICAgICAgIHJvd3MgPSBpbnB1dFNoYXBlWzJdICsgdGhpcy5wYWRkaW5nWzBdWzBdICsgdGhpcy5wYWRkaW5nWzBdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRTaGFwZVszXSAhPSBudWxsICYmIGlucHV0U2hhcGVbM10gPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbHMgPSBpbnB1dFNoYXBlWzNdICsgdGhpcy5wYWRkaW5nWzFdWzBdICsgdGhpcy5wYWRkaW5nWzFdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29scyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGlucHV0U2hhcGVbMV0sIHJvd3MsIGNvbHNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlucHV0U2hhcGVbMV0gIT0gbnVsbCAmJiBpbnB1dFNoYXBlWzFdID49IDApIHtcbiAgICAgICAgICAgICAgICByb3dzID0gaW5wdXRTaGFwZVsxXSArIHRoaXMucGFkZGluZ1swXVswXSArIHRoaXMucGFkZGluZ1swXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvd3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0U2hhcGVbMl0gIT0gbnVsbCAmJiBpbnB1dFNoYXBlWzJdID49IDApIHtcbiAgICAgICAgICAgICAgICBjb2xzID0gaW5wdXRTaGFwZVsyXSArIHRoaXMucGFkZGluZ1sxXVswXSArIHRoaXMucGFkZGluZ1sxXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCByb3dzLCBjb2xzLCBpbnB1dFNoYXBlWzNdXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmVyb1BhZGRpbmcyRC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBzcGF0aWFsMmRQYWRkaW5nKGdlbmVyaWNfdXRpbHNfMS5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyksIF90aGlzLnBhZGRpbmcsIF90aGlzLmRhdGFGb3JtYXQpOyB9KTtcbiAgICB9O1xuICAgIFplcm9QYWRkaW5nMkQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyxcbiAgICAgICAgICAgIGRhdGFGb3JtYXQ6IHRoaXMuZGF0YUZvcm1hdCxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBaZXJvUGFkZGluZzJELmNsYXNzTmFtZSA9ICdaZXJvUGFkZGluZzJEJztcbiAgICByZXR1cm4gWmVyb1BhZGRpbmcyRDtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5aZXJvUGFkZGluZzJEID0gWmVyb1BhZGRpbmcyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihaZXJvUGFkZGluZzJEKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZGRpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL2NvbW1vblwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGNvbW1vbl8yID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4uL2VuZ2luZS90b3BvbG9neVwiKTtcbnZhciB0b3BvbG9neV8yID0gcmVxdWlyZShcIi4uL2VuZ2luZS90b3BvbG9neVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgY29udl91dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbnZfdXRpbHNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIGNvbnZvbHV0aW9uYWxfMSA9IHJlcXVpcmUoXCIuL2NvbnZvbHV0aW9uYWxcIik7XG5mdW5jdGlvbiBwb29sMmQoeCwgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsIHBvb2xNb2RlKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrUG9vbE1vZGUocG9vbE1vZGUpO1xuICAgICAgICBjb21tb25fMi5jaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgICAgICBpZiAoc3RyaWRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdHJpZGVzID0gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSAndmFsaWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFGb3JtYXQgPSBjb21tb25fMS5pbWFnZURhdGFGb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9vbE1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9vbE1vZGUgPSAnbWF4JztcbiAgICAgICAgfVxuICAgICAgICB4ID0gY29udm9sdXRpb25hbF8xLnByZXByb2Nlc3NDb252MkRJbnB1dCh4LCBkYXRhRm9ybWF0KTtcbiAgICAgICAgdmFyIHk7XG4gICAgICAgIHZhciBwYWRkaW5nU3RyaW5nID0gKHBhZGRpbmcgPT09ICdzYW1lJykgPyAnc2FtZScgOiAndmFsaWQnO1xuICAgICAgICBpZiAocG9vbE1vZGUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgICB5ID0gdGZjLm1heFBvb2woeCwgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmdTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeSA9IHRmYy5hdmdQb29sKHgsIHBvb2xTaXplLCBzdHJpZGVzLCBwYWRkaW5nU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICB5ID0gdGZjLnRyYW5zcG9zZSh5LCBbMCwgMywgMSwgMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH0pO1xufVxuZXhwb3J0cy5wb29sMmQgPSBwb29sMmQ7XG52YXIgUG9vbGluZzFEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9vbGluZzFELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvb2xpbmcxRChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZy5wb29sU2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcucG9vbFNpemUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5wb29sU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIF90aGlzLnBvb2xTaXplID0gW2NvbmZpZy5wb29sU2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb25maWcucG9vbFNpemUpICYmXG4gICAgICAgICAgICBjb25maWcucG9vbFNpemUubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnLnBvb2xTaXplWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgX3RoaXMucG9vbFNpemUgPSBjb25maWcucG9vbFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcInBvb2xTaXplIGZvciAxRCBjb252b2x1dGlvbmFsIGxheWVyIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gXCIgK1xuICAgICAgICAgICAgICAgIFwiQXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyLCBidXQgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgIChcIlwiICsgSlNPTi5zdHJpbmdpZnkoY29uZmlnLnBvb2xTaXplKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuc3RyaWRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5zdHJpZGVzID0gX3RoaXMucG9vbFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5zdHJpZGVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0cmlkZXMgPSBbY29uZmlnLnN0cmlkZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuc3RyaWRlcykgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuc3RyaWRlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uZmlnLnN0cmlkZXNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RyaWRlcyA9IGNvbmZpZy5zdHJpZGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJzdHJpZGVzIGZvciAxRCBjb252b2x1dGlvbmFsIGxheWVyIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIkFycmF5IG9mIGEgc2luZ2xlIG51bWJlciwgYnV0IHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyBKU09OLnN0cmluZ2lmeShjb25maWcuc3RyaWRlcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5wYWRkaW5nID0gY29uZmlnLnBhZGRpbmcgPT0gbnVsbCA/ICd2YWxpZCcgOiBjb25maWcucGFkZGluZztcbiAgICAgICAgY29tbW9uXzIuY2hlY2tQYWRkaW5nTW9kZShfdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW25ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IG5kaW06IDMgfSldO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvb2xpbmcxRC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29udl91dGlsc18xLmNvbnZPdXRwdXRMZW5ndGgoaW5wdXRTaGFwZVsxXSwgdGhpcy5wb29sU2l6ZVswXSwgdGhpcy5wYWRkaW5nLCB0aGlzLnN0cmlkZXNbMF0pO1xuICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGxlbmd0aCwgaW5wdXRTaGFwZVsyXV07XG4gICAgfTtcbiAgICBQb29saW5nMUQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgaW5wdXRzID0gSy5leHBhbmREaW1zKGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpLCAyKTtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBfdGhpcy5wb29saW5nRnVuY3Rpb24oZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyksIFtfdGhpcy5wb29sU2l6ZVswXSwgMV0sIFtfdGhpcy5zdHJpZGVzWzBdLCAxXSwgX3RoaXMucGFkZGluZywgJ2NoYW5uZWxzTGFzdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRmYy5zcXVlZXplKG91dHB1dCwgWzJdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb29saW5nMUQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHBvb2xTaXplOiB0aGlzLnBvb2xTaXplLFxuICAgICAgICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxuICAgICAgICAgICAgc3RyaWRlczogdGhpcy5zdHJpZGVzLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIHJldHVybiBQb29saW5nMUQ7XG59KHRvcG9sb2d5XzIuTGF5ZXIpKTtcbmV4cG9ydHMuUG9vbGluZzFEID0gUG9vbGluZzFEO1xudmFyIE1heFBvb2xpbmcxRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heFBvb2xpbmcxRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXhQb29saW5nMUQoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1heFBvb2xpbmcxRC5wcm90b3R5cGUucG9vbGluZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKGlucHV0cywgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQpIHtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgICAgICBjb21tb25fMi5jaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgICAgICByZXR1cm4gcG9vbDJkKGlucHV0cywgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsICdtYXgnKTtcbiAgICB9O1xuICAgIE1heFBvb2xpbmcxRC5jbGFzc05hbWUgPSAnTWF4UG9vbGluZzFEJztcbiAgICByZXR1cm4gTWF4UG9vbGluZzFEO1xufShQb29saW5nMUQpKTtcbmV4cG9ydHMuTWF4UG9vbGluZzFEID0gTWF4UG9vbGluZzFEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKE1heFBvb2xpbmcxRCk7XG52YXIgQXZlcmFnZVBvb2xpbmcxRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF2ZXJhZ2VQb29saW5nMUQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXZlcmFnZVBvb2xpbmcxRChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICB9XG4gICAgQXZlcmFnZVBvb2xpbmcxRC5wcm90b3R5cGUucG9vbGluZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKGlucHV0cywgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQpIHtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgICAgICBjb21tb25fMi5jaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgICAgICByZXR1cm4gcG9vbDJkKGlucHV0cywgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsICdhdmcnKTtcbiAgICB9O1xuICAgIEF2ZXJhZ2VQb29saW5nMUQuY2xhc3NOYW1lID0gJ0F2ZXJhZ2VQb29saW5nMUQnO1xuICAgIHJldHVybiBBdmVyYWdlUG9vbGluZzFEO1xufShQb29saW5nMUQpKTtcbmV4cG9ydHMuQXZlcmFnZVBvb2xpbmcxRCA9IEF2ZXJhZ2VQb29saW5nMUQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoQXZlcmFnZVBvb2xpbmcxRCk7XG52YXIgUG9vbGluZzJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9vbGluZzJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvb2xpbmcyRChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZy5wb29sU2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcucG9vbFNpemUgPSBbMiwgMl07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBvb2xTaXplID0gQXJyYXkuaXNBcnJheShjb25maWcucG9vbFNpemUpID9cbiAgICAgICAgICAgIGNvbmZpZy5wb29sU2l6ZSA6XG4gICAgICAgICAgICBbY29uZmlnLnBvb2xTaXplLCBjb25maWcucG9vbFNpemVdO1xuICAgICAgICBfdGhpcy5zdHJpZGVzID0gY29uZmlnLnN0cmlkZXMgPT0gbnVsbCA/IF90aGlzLnBvb2xTaXplIDogY29uZmlnLnN0cmlkZXM7XG4gICAgICAgIF90aGlzLnBhZGRpbmcgPSBjb25maWcucGFkZGluZyA9PSBudWxsID8gJ3ZhbGlkJyA6IGNvbmZpZy5wYWRkaW5nO1xuICAgICAgICBfdGhpcy5kYXRhRm9ybWF0ID1cbiAgICAgICAgICAgIGNvbmZpZy5kYXRhRm9ybWF0ID09IG51bGwgPyAnY2hhbm5lbHNMYXN0JyA6IGNvbmZpZy5kYXRhRm9ybWF0O1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoX3RoaXMuZGF0YUZvcm1hdCk7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrUGFkZGluZ01vZGUoX3RoaXMucGFkZGluZyk7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFtuZXcgdG9wb2xvZ3lfMS5JbnB1dFNwZWMoeyBuZGltOiA0IH0pXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb29saW5nMkQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IGlucHV0U2hhcGVbMl0gOiBpbnB1dFNoYXBlWzFdO1xuICAgICAgICB2YXIgY29scyA9IHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gaW5wdXRTaGFwZVszXSA6IGlucHV0U2hhcGVbMl07XG4gICAgICAgIHJvd3MgPVxuICAgICAgICAgICAgY29udl91dGlsc18xLmNvbnZPdXRwdXRMZW5ndGgocm93cywgdGhpcy5wb29sU2l6ZVswXSwgdGhpcy5wYWRkaW5nLCB0aGlzLnN0cmlkZXNbMF0pO1xuICAgICAgICBjb2xzID1cbiAgICAgICAgICAgIGNvbnZfdXRpbHNfMS5jb252T3V0cHV0TGVuZ3RoKGNvbHMsIHRoaXMucG9vbFNpemVbMV0sIHRoaXMucGFkZGluZywgdGhpcy5zdHJpZGVzWzFdKTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGlucHV0U2hhcGVbMV0sIHJvd3MsIGNvbHNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCByb3dzLCBjb2xzLCBpbnB1dFNoYXBlWzNdXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9vbGluZzJELnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wb29saW5nRnVuY3Rpb24oZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyksIF90aGlzLnBvb2xTaXplLCBfdGhpcy5zdHJpZGVzLCBfdGhpcy5wYWRkaW5nLCBfdGhpcy5kYXRhRm9ybWF0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb29saW5nMkQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHBvb2xTaXplOiB0aGlzLnBvb2xTaXplLFxuICAgICAgICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxuICAgICAgICAgICAgc3RyaWRlczogdGhpcy5zdHJpZGVzLFxuICAgICAgICAgICAgZGF0YUZvcm1hdDogdGhpcy5kYXRhRm9ybWF0XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgcmV0dXJuIFBvb2xpbmcyRDtcbn0odG9wb2xvZ3lfMi5MYXllcikpO1xuZXhwb3J0cy5Qb29saW5nMkQgPSBQb29saW5nMkQ7XG52YXIgTWF4UG9vbGluZzJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4UG9vbGluZzJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heFBvb2xpbmcyRChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICB9XG4gICAgTWF4UG9vbGluZzJELnByb3RvdHlwZS5wb29saW5nRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCkge1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrUGFkZGluZ01vZGUocGFkZGluZyk7XG4gICAgICAgIHJldHVybiBwb29sMmQoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgJ21heCcpO1xuICAgIH07XG4gICAgTWF4UG9vbGluZzJELmNsYXNzTmFtZSA9ICdNYXhQb29saW5nMkQnO1xuICAgIHJldHVybiBNYXhQb29saW5nMkQ7XG59KFBvb2xpbmcyRCkpO1xuZXhwb3J0cy5NYXhQb29saW5nMkQgPSBNYXhQb29saW5nMkQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTWF4UG9vbGluZzJEKTtcbnZhciBBdmVyYWdlUG9vbGluZzJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXZlcmFnZVBvb2xpbmcyRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdmVyYWdlUG9vbGluZzJEKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBdmVyYWdlUG9vbGluZzJELnByb3RvdHlwZS5wb29saW5nRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCkge1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrUGFkZGluZ01vZGUocGFkZGluZyk7XG4gICAgICAgIHJldHVybiBwb29sMmQoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgJ2F2ZycpO1xuICAgIH07XG4gICAgQXZlcmFnZVBvb2xpbmcyRC5jbGFzc05hbWUgPSAnQXZlcmFnZVBvb2xpbmcyRCc7XG4gICAgcmV0dXJuIEF2ZXJhZ2VQb29saW5nMkQ7XG59KFBvb2xpbmcyRCkpO1xuZXhwb3J0cy5BdmVyYWdlUG9vbGluZzJEID0gQXZlcmFnZVBvb2xpbmcyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihBdmVyYWdlUG9vbGluZzJEKTtcbnZhciBHbG9iYWxQb29saW5nMUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHbG9iYWxQb29saW5nMUQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2xvYmFsUG9vbGluZzFEKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFtuZXcgdG9wb2xvZ3lfMS5JbnB1dFNwZWMoeyBuZGltOiAzIH0pXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHbG9iYWxQb29saW5nMUQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsyXV07XG4gICAgfTtcbiAgICBHbG9iYWxQb29saW5nMUQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgICB9O1xuICAgIHJldHVybiBHbG9iYWxQb29saW5nMUQ7XG59KHRvcG9sb2d5XzIuTGF5ZXIpKTtcbmV4cG9ydHMuR2xvYmFsUG9vbGluZzFEID0gR2xvYmFsUG9vbGluZzFEO1xudmFyIEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHbG9iYWxBdmVyYWdlUG9vbGluZzFELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgfVxuICAgIEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGZjLm1lYW4oaW5wdXQsIDEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQuY2xhc3NOYW1lID0gJ0dsb2JhbEF2ZXJhZ2VQb29saW5nMUQnO1xuICAgIHJldHVybiBHbG9iYWxBdmVyYWdlUG9vbGluZzFEO1xufShHbG9iYWxQb29saW5nMUQpKTtcbmV4cG9ydHMuR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCA9IEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCk7XG52YXIgR2xvYmFsTWF4UG9vbGluZzFEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2xvYmFsTWF4UG9vbGluZzFELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdsb2JhbE1heFBvb2xpbmcxRChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICB9XG4gICAgR2xvYmFsTWF4UG9vbGluZzFELnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRmYy5tYXgoaW5wdXQsIDEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdsb2JhbE1heFBvb2xpbmcxRC5jbGFzc05hbWUgPSAnR2xvYmFsTWF4UG9vbGluZzFEJztcbiAgICByZXR1cm4gR2xvYmFsTWF4UG9vbGluZzFEO1xufShHbG9iYWxQb29saW5nMUQpKTtcbmV4cG9ydHMuR2xvYmFsTWF4UG9vbGluZzFEID0gR2xvYmFsTWF4UG9vbGluZzFEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEdsb2JhbE1heFBvb2xpbmcxRCk7XG52YXIgR2xvYmFsUG9vbGluZzJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2xvYmFsUG9vbGluZzJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdsb2JhbFBvb2xpbmcyRChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhRm9ybWF0ID1cbiAgICAgICAgICAgIGNvbmZpZy5kYXRhRm9ybWF0ID09IG51bGwgPyAnY2hhbm5lbHNMYXN0JyA6IGNvbmZpZy5kYXRhRm9ybWF0O1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoX3RoaXMuZGF0YUZvcm1hdCk7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFtuZXcgdG9wb2xvZ3lfMS5JbnB1dFNwZWMoeyBuZGltOiA0IH0pXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHbG9iYWxQb29saW5nMkQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgICAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBpbnB1dFNoYXBlWzNdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsxXV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdsb2JhbFBvb2xpbmcyRC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH07XG4gICAgR2xvYmFsUG9vbGluZzJELnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGRhdGFGb3JtYXQ6IHRoaXMuZGF0YUZvcm1hdCB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIHJldHVybiBHbG9iYWxQb29saW5nMkQ7XG59KHRvcG9sb2d5XzIuTGF5ZXIpKTtcbmV4cG9ydHMuR2xvYmFsUG9vbGluZzJEID0gR2xvYmFsUG9vbGluZzJEO1xudmFyIEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHbG9iYWxBdmVyYWdlUG9vbGluZzJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgR2xvYmFsQXZlcmFnZVBvb2xpbmcyRC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZmMubWVhbihpbnB1dCwgWzEsIDJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZmMubWVhbihpbnB1dCwgWzIsIDNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHbG9iYWxBdmVyYWdlUG9vbGluZzJELmNsYXNzTmFtZSA9ICdHbG9iYWxBdmVyYWdlUG9vbGluZzJEJztcbiAgICByZXR1cm4gR2xvYmFsQXZlcmFnZVBvb2xpbmcyRDtcbn0oR2xvYmFsUG9vbGluZzJEKSk7XG5leHBvcnRzLkdsb2JhbEF2ZXJhZ2VQb29saW5nMkQgPSBHbG9iYWxBdmVyYWdlUG9vbGluZzJEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQpO1xudmFyIEdsb2JhbE1heFBvb2xpbmcyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdsb2JhbE1heFBvb2xpbmcyRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHbG9iYWxNYXhQb29saW5nMkQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgR2xvYmFsTWF4UG9vbGluZzJELnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5tYXgoaW5wdXQsIFsxLCAyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZjLm1heChpbnB1dCwgWzIsIDNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHbG9iYWxNYXhQb29saW5nMkQuY2xhc3NOYW1lID0gJ0dsb2JhbE1heFBvb2xpbmcyRCc7XG4gICAgcmV0dXJuIEdsb2JhbE1heFBvb2xpbmcyRDtcbn0oR2xvYmFsUG9vbGluZzJEKSk7XG5leHBvcnRzLkdsb2JhbE1heFBvb2xpbmcyRCA9IEdsb2JhbE1heFBvb2xpbmcyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihHbG9iYWxNYXhQb29saW5nMkQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9vbGluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIGFjdGl2YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vYWN0aXZhdGlvbnNcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBjb25zdHJhaW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0cmFpbnRzXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIHRvcG9sb2d5XzIgPSByZXF1aXJlKFwiLi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBpbml0aWFsaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9pbml0aWFsaXplcnNcIik7XG52YXIgcmVndWxhcml6ZXJzXzEgPSByZXF1aXJlKFwiLi4vcmVndWxhcml6ZXJzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIG1hdGhfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWF0aF91dGlsc1wiKTtcbnZhciB2YXJpYWJsZXNfMSA9IHJlcXVpcmUoXCIuLi92YXJpYWJsZXNcIik7XG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXphdGlvblwiKTtcbmZ1bmN0aW9uIHJubihzdGVwRnVuY3Rpb24sIGlucHV0cywgaW5pdGlhbFN0YXRlcywgZ29CYWNrd2FyZHMsIG1hc2ssIGNvbnN0YW50cywgdW5yb2xsLCBpbnB1dExlbmd0aCkge1xuICAgIGlmIChnb0JhY2t3YXJkcyA9PT0gdm9pZCAwKSB7IGdvQmFja3dhcmRzID0gZmFsc2U7IH1cbiAgICBpZiAodW5yb2xsID09PSB2b2lkIDApIHsgdW5yb2xsID0gZmFsc2U7IH1cbiAgICB2YXIgbmRpbSA9IGlucHV0cy5zaGFwZS5sZW5ndGg7XG4gICAgaWYgKG5kaW0gPCAzKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW5wdXQgc2hvdWxkIGJlIGF0IGxlYXN0IDNELCBidXQgaXMgXCIgKyBuZGltICsgXCJELlwiKTtcbiAgICB9XG4gICAgdmFyIGF4ZXMgPSBbMSwgMF0uY29uY2F0KG1hdGhfdXRpbHMucmFuZ2UoMiwgbmRpbSkpO1xuICAgIGlucHV0cyA9IHRmYy50cmFuc3Bvc2UoaW5wdXRzLCBheGVzKTtcbiAgICBpZiAobWFzayAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdUaGUgcm5uKCkgZnVuY3Rpb24gb2YgdGhlIGRlZXBsZWFybi5qcyBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgJyArXG4gICAgICAgICAgICAnbWFza2luZyB5ZXQuJyk7XG4gICAgfVxuICAgIGlmIChjb25zdGFudHMgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignVGhlIHJubigpIGZ1bmN0b2luIG9mIHRoZSBkZWVwbGVhcm4uanMgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0ICcgK1xuICAgICAgICAgICAgJ2NvbnN0YW50cyB5ZXQuJyk7XG4gICAgfVxuICAgIGlmICh1bnJvbGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCYWNrZW5kIHJubigpOiB0aGUgdW5yb2xsID0gdHJ1ZSBvcHRpb24gaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlICcgK1xuICAgICAgICAgICAgJ2ltcGVyYXRpdmUgZGVlcGxlYXJuLmpzIGJhY2tlbmQuJyk7XG4gICAgfVxuICAgIGlmIChnb0JhY2t3YXJkcykge1xuICAgICAgICBpbnB1dHMgPSB0ZmMucmV2ZXJzZShpbnB1dHMsIDApO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0cztcbiAgICB2YXIgbGFzdE91dHB1dDtcbiAgICB2YXIgc3RhdGVzID0gaW5pdGlhbFN0YXRlcztcbiAgICB2YXIgdGltZVN0ZXBzID0gaW5wdXRzLnNoYXBlWzBdO1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGltZVN0ZXBzOyArK3QpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbnB1dCA9IEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhpbnB1dHMsIHQsIDEpO1xuICAgICAgICBjdXJyZW50SW5wdXQgPSBjdXJyZW50SW5wdXQucmVzaGFwZShjdXJyZW50SW5wdXQuc2hhcGUuc2xpY2UoMSkpO1xuICAgICAgICB2YXIgc3RlcE91dHB1dHMgPSBzdGVwRnVuY3Rpb24oY3VycmVudElucHV0LCBzdGF0ZXMpO1xuICAgICAgICBsYXN0T3V0cHV0ID0gc3RlcE91dHB1dHNbMF07XG4gICAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgICAgICBvdXRwdXRzID0gbGFzdE91dHB1dC5yZXNoYXBlKFsxXS5jb25jYXQobGFzdE91dHB1dC5zaGFwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0cyA9IEsuY29uY2F0QWxvbmdGaXJzdEF4aXMob3V0cHV0cywgbGFzdE91dHB1dC5yZXNoYXBlKFsxXS5jb25jYXQobGFzdE91dHB1dC5zaGFwZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZXMgPSBzdGVwT3V0cHV0c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGFzdE91dHB1dCxcbiAgICAgICAgdGZjLnRyYW5zcG9zZShvdXRwdXRzLCBbMSwgMF0uY29uY2F0KG1hdGhfdXRpbHMucmFuZ2UoMiwgb3V0cHV0cy5zaGFwZS5sZW5ndGgpKSksXG4gICAgICAgIHN0YXRlc1xuICAgIF07XG59XG5leHBvcnRzLnJubiA9IHJubjtcbnZhciBSTk4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSTk4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUk5OKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIHZhciBjZWxsO1xuICAgICAgICBpZiAoY29uZmlnLmNlbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ2NlbGwgcHJvcGVydHkgaXMgbWlzc2luZyBmb3IgdGhlIGNvbnN0cnVjdG9yIG9mIFJOTi4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5jZWxsKSkge1xuICAgICAgICAgICAgY2VsbCA9IG5ldyBTdGFja2VkUk5OQ2VsbHMoeyBjZWxsczogY29uZmlnLmNlbGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZWxsID0gY29uZmlnLmNlbGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGwuc3RhdGVTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdUaGUgUk5OIGNlbGwgc2hvdWxkIGhhdmUgYW4gYXR0cmlidXRlIGBzdGF0ZVNpemVgICh0dXBsZSBvZiAnICtcbiAgICAgICAgICAgICAgICAnaW50ZWdlcnMsIG9uZSBpbnRlZ2VyIHBlciBSTk4gc3RhdGUpLicpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNlbGwgPSBjZWxsO1xuICAgICAgICBfdGhpcy5yZXR1cm5TZXF1ZW5jZXMgPVxuICAgICAgICAgICAgY29uZmlnLnJldHVyblNlcXVlbmNlcyA9PSBudWxsID8gZmFsc2UgOiBjb25maWcucmV0dXJuU2VxdWVuY2VzO1xuICAgICAgICBfdGhpcy5yZXR1cm5TdGF0ZSA9IGNvbmZpZy5yZXR1cm5TdGF0ZSA9PSBudWxsID8gZmFsc2UgOiBjb25maWcucmV0dXJuU3RhdGU7XG4gICAgICAgIF90aGlzLmdvQmFja3dhcmRzID0gY29uZmlnLmdvQmFja3dhcmRzID09IG51bGwgPyBmYWxzZSA6IGNvbmZpZy5nb0JhY2t3YXJkcztcbiAgICAgICAgX3RoaXMuX3N0YXRlZnVsID0gY29uZmlnLnN0YXRlZnVsID09IG51bGwgPyBmYWxzZSA6IGNvbmZpZy5zdGF0ZWZ1bDtcbiAgICAgICAgX3RoaXMudW5yb2xsID0gY29uZmlnLnVucm9sbCA9PSBudWxsID8gZmFsc2UgOiBjb25maWcudW5yb2xsO1xuICAgICAgICBfdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbbmV3IHRvcG9sb2d5XzEuSW5wdXRTcGVjKHsgbmRpbTogMyB9KV07XG4gICAgICAgIF90aGlzLnN0YXRlU3BlYyA9IG51bGw7XG4gICAgICAgIF90aGlzLnN0YXRlcyA9IG51bGw7XG4gICAgICAgIF90aGlzLm51bUNvbnN0YW50cyA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUk5OLnByb3RvdHlwZS5nZXRTdGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbnVtU3RhdGVzID0gQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKSA/IHRoaXMuY2VsbC5zdGF0ZVNpemUubGVuZ3RoIDogMTtcbiAgICAgICAgICAgIHJldHVybiBtYXRoX3V0aWxzLnJhbmdlKDAsIG51bVN0YXRlcykubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBudWxsOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUk5OLnByb3RvdHlwZS5zZXRTdGF0ZXMgPSBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgIH07XG4gICAgUk5OLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpZiAoZ2VuZXJpY191dGlscy5pc0FycmF5T2ZTaGFwZXMoaW5wdXRTaGFwZSkpIHtcbiAgICAgICAgICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgc3RhdGVTaXplID0gdGhpcy5jZWxsLnN0YXRlU2l6ZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICAgIHN0YXRlU2l6ZSA9IFtzdGF0ZVNpemVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXREaW0gPSBzdGF0ZVNpemVbMF07XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZTtcbiAgICAgICAgaWYgKHRoaXMucmV0dXJuU2VxdWVuY2VzKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IFtpbnB1dFNoYXBlWzBdLCBpbnB1dFNoYXBlWzFdLCBvdXRwdXREaW1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXSwgb3V0cHV0RGltXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXR1cm5TdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlU2hhcGUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc3RhdGVTaXplXzEgPSBzdGF0ZVNpemU7IF9pIDwgc3RhdGVTaXplXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IHN0YXRlU2l6ZV8xW19pXTtcbiAgICAgICAgICAgICAgICBzdGF0ZVNoYXBlLnB1c2goW2lucHV0U2hhcGVbMF0sIGRpbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXRTaGFwZV0uY29uY2F0KHN0YXRlU2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSTk4ucHJvdG90eXBlLmNvbXB1dGVNYXNrID0gZnVuY3Rpb24gKGlucHV0cywgbWFzaykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignY29tcHV0ZU1hc2sgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciBSTk4geWV0Jyk7XG4gICAgfTtcbiAgICBSTk4ucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgdmFyIGNvbnN0YW50U2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5udW1Db25zdGFudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ0NvbnN0YW50cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBSTk4geWV0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmljX3V0aWxzLmlzQXJyYXlPZlNoYXBlcyhpbnB1dFNoYXBlKSkge1xuICAgICAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSB0aGlzLnN0YXRlZnVsID8gaW5wdXRTaGFwZVswXSA6IG51bGw7XG4gICAgICAgIHZhciBpbnB1dERpbSA9IGlucHV0U2hhcGVbaW5wdXRTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5pbnB1dFNwZWNbMF0gPSBuZXcgdG9wb2xvZ3lfMS5JbnB1dFNwZWMoeyBzaGFwZTogW2JhdGNoU2l6ZSwgbnVsbCwgaW5wdXREaW1dIH0pO1xuICAgICAgICB2YXIgc3RlcElucHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXV0uY29uY2F0KGlucHV0U2hhcGUuc2xpY2UoMikpO1xuICAgICAgICBpZiAoY29uc3RhbnRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignQ29uc3RhbnRzIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkIGluIFJOTiB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNlbGwuYnVpbGQoc3RlcElucHV0U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZVNpemU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgICBzdGF0ZVNpemUgPSB0aGlzLmNlbGwuc3RhdGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGVTaXplID0gW3RoaXMuY2VsbC5zdGF0ZVNpemVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlU3BlYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRmanNfY29yZV8xLnV0aWwuYXJyYXlzRXF1YWwodGhpcy5zdGF0ZVNwZWMubWFwKGZ1bmN0aW9uIChzcGVjKSB7IHJldHVybiBzcGVjLnNoYXBlW3NwZWMuc2hhcGUubGVuZ3RoIC0gMV07IH0pLCBzdGF0ZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJBbiBpbml0aWFsU3RhdGUgd2FzIHBhc3NlZCB0aGF0IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJjZWxsLnN0YXRlU2l6ZS4gUmVjZWl2ZWQgc3RhdGVTcGVjPVwiICsgdGhpcy5zdGF0ZVNwZWMgKyBcIjsgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwiSG93ZXZlciBjZWxsLnN0YXRlU2l6ZSBpcyBcIiArIHRoaXMuY2VsbC5zdGF0ZVNpemUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVTcGVjID1cbiAgICAgICAgICAgICAgICBzdGF0ZVNpemUubWFwKGZ1bmN0aW9uIChkaW0pIHsgcmV0dXJuIG5ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IHNoYXBlOiBbbnVsbCwgZGltXSB9KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGVmdWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdzdGF0ZWZ1bCBSTk4gbGF5ZXIgaXMgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSTk4ucHJvdG90eXBlLnJlc2V0U3RhdGVzID0gZnVuY3Rpb24gKHN0YXRlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuc3RhdGVmdWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXR0cmlidXRlRXJyb3IoJ0Nhbm5vdCBjYWxsIHJlc2V0U3RhdGUoKSBvbiBhbiBSTk4gTGF5ZXIgdGhhdCBpcyBub3Qgc3RhdGVmdWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0gX3RoaXMuaW5wdXRTcGVjWzBdLnNoYXBlWzBdO1xuICAgICAgICAgICAgaWYgKGJhdGNoU2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0lmIGFuIFJOTiBpcyBzdGF0ZWZ1bCwgaXQgbmVlZHMgdG8ga25vdyBpdHMgYmF0Y2ggc2l6ZS4gU3BlY2lmeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoZSBiYXRjaCBzaXplIG9mIHlvdXIgaW5wdXQgdGVuc29yczogXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICctIElmIHVzaW5nIGEgU2VxdWVudGlhbCBtb2RlbCwgc3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBieSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3Bhc3NpbmcgYSBgYmF0Y2hJbnB1dFNoYXBlYCBvcHRpb24gdG8geW91ciBmaXJzdCBsYXllci5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgJy0gSWYgdXNpbmcgdGhlIGZ1bmN0aW9uYWwgQVBJLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICAncGFzc2luZyBhIGBiYXRjaFNoYXBlYCBvcHRpb24gdG8geW91ciBJbnB1dCBsYXllci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KF90aGlzLmNlbGwuc3RhdGVTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2VsbC5zdGF0ZVNpemUubWFwKGZ1bmN0aW9uIChkaW0pIHsgcmV0dXJuIHRmYy56ZXJvcyhbYmF0Y2hTaXplLCBkaW1dKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZXMgPSBbdGZjLnplcm9zKFtiYXRjaFNpemUsIF90aGlzLmNlbGwuc3RhdGVTaXplXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3RoaXMuY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jZWxsLnN0YXRlU2l6ZS5tYXAoZnVuY3Rpb24gKGRpbSkgeyByZXR1cm4gdGZjLnplcm9zKFtiYXRjaFNpemUsIGRpbV0pOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlc1swXSA9IHRmYy56ZXJvcyhbYmF0Y2hTaXplLCBfdGhpcy5jZWxsLnN0YXRlU2l6ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IFtzdGF0ZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVzLmxlbmd0aCAhPT0gX3RoaXMuc3RhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkxheWVyIFwiICsgX3RoaXMubmFtZSArIFwiIGV4cGVjdHMgXCIgKyBfdGhpcy5zdGF0ZXMubGVuZ3RoICsgXCIgc3RhdGUocyksIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImJ1dCBpdCByZWNlaXZlZCBcIiArIHN0YXRlcy5sZW5ndGggKyBcIiBzdGF0ZSB2YWx1ZShzKS4gSW5wdXQgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcInJlY2VpdmVkOiBcIiArIHN0YXRlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgX3RoaXMuc3RhdGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdGF0ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltID0gQXJyYXkuaXNBcnJheShfdGhpcy5jZWxsLnN0YXRlU2l6ZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2VsbC5zdGF0ZVNpemVbaW5kZXhdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNlbGwuc3RhdGVTaXplO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwZWN0ZWRTaGFwZSA9IFtiYXRjaFNpemUsIGRpbV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGZqc19jb3JlXzEudXRpbC5hcnJheXNFcXVhbCh2YWx1ZS5zaGFwZSwgZXhwZWN0ZWRTaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiU3RhdGUgXCIgKyBpbmRleCArIFwiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiICsgX3RoaXMubmFtZSArIFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiZXhwZWN0ZWQgc2hhcGU9XCIgKyBleHBlY3RlZFNoYXBlICsgXCIsIHJlY2VpdmVkIHNoYXBlPVwiICsgdmFsdWUuc2hhcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJOTi5wcm90b3R5cGUuc3RhbmRhcmRpemVBcmdzID0gZnVuY3Rpb24gKGlucHV0cywgaW5pdGlhbFN0YXRlLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRzKSkge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSAhPSBudWxsIHx8IGNvbnN0YW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1doZW4gaW5wdXRzIGlzIGFuIGFycmF5LCBuZWl0aGVyIGluaXRpYWxTdGF0ZSBvciBjb25zdGFudHMgJyArXG4gICAgICAgICAgICAgICAgICAgICdzaG91bGQgYmUgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm51bUNvbnN0YW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3RhbnRzID1cbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnNsaWNlKGlucHV0cy5sZW5ndGggLSB0aGlzLm51bUNvbnN0YW50cywgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gaW5wdXRzLnNsaWNlKDAsIGlucHV0cy5sZW5ndGggLSB0aGlzLm51bUNvbnN0YW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsU3RhdGUgPSBpbnB1dHMuc2xpY2UoMSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9MaXN0T3JOdWxsKHgpIHtcbiAgICAgICAgICAgIGlmICh4ID09IG51bGwgfHwgQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsU3RhdGUgPSB0b0xpc3RPck51bGwoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgY29uc3RhbnRzID0gdG9MaXN0T3JOdWxsKGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB7IGlucHV0czogaW5wdXRzLCBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSwgY29uc3RhbnRzOiBjb25zdGFudHMgfTtcbiAgICB9O1xuICAgIFJOTi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snaW5pdGlhbFN0YXRlJ107XG4gICAgICAgIHZhciBjb25zdGFudHMgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ2NvbnN0YW50cyddO1xuICAgICAgICBpZiAoa3dhcmdzID09IG51bGwpIHtcbiAgICAgICAgICAgIGt3YXJncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFuZGFyZGl6ZWQgPSB0aGlzLnN0YW5kYXJkaXplQXJncyhpbnB1dHMsIGluaXRpYWxTdGF0ZSwgY29uc3RhbnRzKTtcbiAgICAgICAgaW5wdXRzID0gc3RhbmRhcmRpemVkLmlucHV0cztcbiAgICAgICAgaW5pdGlhbFN0YXRlID0gc3RhbmRhcmRpemVkLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgY29uc3RhbnRzID0gc3RhbmRhcmRpemVkLmNvbnN0YW50cztcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxJbnB1dHMgPSBbXTtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxTcGVjcyA9IFtdO1xuICAgICAgICBpZiAoaW5pdGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGt3YXJnc1snaW5pdGlhbFN0YXRlJ10gPSBpbml0aWFsU3RhdGU7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSW5wdXRzID0gYWRkaXRpb25hbElucHV0cy5jb25jYXQoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVTcGVjID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGluaXRpYWxTdGF0ZV8xID0gaW5pdGlhbFN0YXRlOyBfaSA8IGluaXRpYWxTdGF0ZV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGluaXRpYWxTdGF0ZV8xW19pXTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlU3BlYy5wdXNoKG5ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IHNoYXBlOiBzdGF0ZS5zaGFwZSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRpdGlvbmFsU3BlY3MgPSBhZGRpdGlvbmFsU3BlY3MuY29uY2F0KHRoaXMuc3RhdGVTcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RhbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGt3YXJnc1snY29uc3RhbnRzJ10gPSBjb25zdGFudHM7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSW5wdXRzID0gYWRkaXRpb25hbElucHV0cy5jb25jYXQoY29uc3RhbnRzKTtcbiAgICAgICAgICAgIHRoaXMubnVtQ29uc3RhbnRzID0gY29uc3RhbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNUZW5zb3IgPSBhZGRpdGlvbmFsSW5wdXRzWzBdIGluc3RhbmNlb2YgdHlwZXNfMS5TeW1ib2xpY1RlbnNvcjtcbiAgICAgICAgaWYgKGlzVGVuc29yKSB7XG4gICAgICAgICAgICB2YXIgZnVsbElucHV0ID0gW2lucHV0c10uY29uY2F0KGFkZGl0aW9uYWxJbnB1dHMpO1xuICAgICAgICAgICAgdmFyIGZ1bGxJbnB1dFNwZWMgPSB0aGlzLmlucHV0U3BlYy5jb25jYXQoYWRkaXRpb25hbFNwZWNzKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbElucHV0U3BlYyA9IHRoaXMuaW5wdXRTcGVjO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFNwZWMgPSBmdWxsSW5wdXRTcGVjO1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IF9zdXBlci5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLCBmdWxsSW5wdXQsIGt3YXJncyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3BlYyA9IG9yaWdpbmFsSW5wdXRTcGVjO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcywgaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSTk4ucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hc2sgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ21hc2snXTtcbiAgICAgICAgICAgIHZhciB0cmFpbmluZyA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1sndHJhaW5pbmcnXTtcbiAgICAgICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddO1xuICAgICAgICAgICAgaW5wdXRzID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGVmdWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ3N0YXRlZnVsIFJOTiBsYXllciBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFN0YXRlID0gX3RoaXMuZ2V0SW5pdGlhbFN0YXRlKGlucHV0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hc2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdNYXNraW5nIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgUk5OIHlldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG51bVN0YXRlcyA9IEFycmF5LmlzQXJyYXkoX3RoaXMuY2VsbC5zdGF0ZVNpemUpID8gX3RoaXMuY2VsbC5zdGF0ZVNpemUubGVuZ3RoIDogMTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsU3RhdGUubGVuZ3RoICE9PSBudW1TdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlJOTiBMYXllciBoYXMgXCIgKyBudW1TdGF0ZXMgKyBcIiBzdGF0ZShzKSBidXQgd2FzIHBhc3NlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIChpbml0aWFsU3RhdGUubGVuZ3RoICsgXCIgaW5pdGlhbCBzdGF0ZShzKS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlucHV0U2hhcGUgPSBpbnB1dHMuc2hhcGU7XG4gICAgICAgICAgICB2YXIgdGltZXN0ZXBzID0gaW5wdXRTaGFwZVsxXTtcbiAgICAgICAgICAgIGlmIChfdGhpcy51bnJvbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0lnbm9yaW5nIHVucm9sbCA9IHRydWUgZm9yIFJOTiBsYXllciwgZHVlIHRvIGltcGVyYXRpdmUgYmFja2VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjZWxsQ2FsbEt3YXJncyA9IHsgdHJhaW5pbmc6IHRyYWluaW5nIH07XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChpbnB1dHMsIHN0YXRlcykge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRzID0gX3RoaXMuY2VsbC5jYWxsKFtpbnB1dHNdLmNvbmNhdChzdGF0ZXMpLCBjZWxsQ2FsbEt3YXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXRzWzBdLCBvdXRwdXRzLnNsaWNlKDEpXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcm5uT3V0cHV0cyA9IHJubihzdGVwLCBpbnB1dHMsIGluaXRpYWxTdGF0ZSwgX3RoaXMuZ29CYWNrd2FyZHMsIG51bGwsIG51bGwsIF90aGlzLnVucm9sbCwgdGltZXN0ZXBzKTtcbiAgICAgICAgICAgIHZhciBsYXN0T3V0cHV0ID0gcm5uT3V0cHV0c1swXTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRzID0gcm5uT3V0cHV0c1sxXTtcbiAgICAgICAgICAgIHZhciBzdGF0ZXMgPSBybm5PdXRwdXRzWzJdO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlZnVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ3N0YXRlZnVsIFJOTiBsYXllciBpcyBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gX3RoaXMucmV0dXJuU2VxdWVuY2VzID8gb3V0cHV0cyA6IGxhc3RPdXRwdXQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW291dHB1dF0uY29uY2F0KHN0YXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJOTi5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGZjLnplcm9zKGlucHV0cy5zaGFwZSk7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGUgPSB0ZmMuc3VtKGluaXRpYWxTdGF0ZSwgWzEsIDJdKTtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IEsuZXhwYW5kRGltcyhpbml0aWFsU3RhdGUpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3RoaXMuY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNlbGwuc3RhdGVTaXplLm1hcChmdW5jdGlvbiAoZGltKSB7IHJldHVybiBkaW0gPiAxID8gSy50aWxlKGluaXRpYWxTdGF0ZSwgWzEsIGRpbV0pIDogaW5pdGlhbFN0YXRlOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jZWxsLnN0YXRlU2l6ZSA+IDEgP1xuICAgICAgICAgICAgICAgICAgICBbSy50aWxlKGluaXRpYWxTdGF0ZSwgWzEsIF90aGlzLmNlbGwuc3RhdGVTaXplXSldIDpcbiAgICAgICAgICAgICAgICAgICAgW2luaXRpYWxTdGF0ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJOTi5wcm90b3R5cGUsIFwidHJhaW5hYmxlV2VpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwudHJhaW5hYmxlV2VpZ2h0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJOTi5wcm90b3R5cGUsIFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwud2VpZ2h0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwubm9uVHJhaW5hYmxlV2VpZ2h0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUk5OLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICByZXR1cm5TZXF1ZW5jZXM6IHRoaXMucmV0dXJuU2VxdWVuY2VzLFxuICAgICAgICAgICAgcmV0dXJuU3RhdGU6IHRoaXMucmV0dXJuU3RhdGUsXG4gICAgICAgICAgICBnb0JhY2t3YXJkczogdGhpcy5nb0JhY2t3YXJkcyxcbiAgICAgICAgICAgIHN0YXRlZnVsOiB0aGlzLnN0YXRlZnVsLFxuICAgICAgICAgICAgdW5yb2xsOiB0aGlzLnVucm9sbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMubnVtQ29uc3RhbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5udW1Db25zdGFudHMgPSB0aGlzLm51bUNvbnN0YW50cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2VsbENvbmZpZyA9IHRoaXMuY2VsbC5nZXRDb25maWcoKTtcbiAgICAgICAgY29uZmlnLmNlbGwgPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuY2VsbC5nZXRDbGFzc05hbWUoKSxcbiAgICAgICAgICAgIGNvbmZpZzogY2VsbENvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBSTk4uY2xhc3NOYW1lID0gJ1JOTic7XG4gICAgcmV0dXJuIFJOTjtcbn0odG9wb2xvZ3lfMi5MYXllcikpO1xuZXhwb3J0cy5STk4gPSBSTk47XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoUk5OKTtcbnZhciBSTk5DZWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUk5OQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSTk5DZWxsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJOTkNlbGwgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ0xheWVycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFJOTkNlbGwpO1xuICAgIHJldHVybiBSTk5DZWxsO1xufSh0b3BvbG9neV8yLkxheWVyKSk7XG5leHBvcnRzLlJOTkNlbGwgPSBSTk5DZWxsO1xudmFyIFNpbXBsZVJOTkNlbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW1wbGVSTk5DZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbXBsZVJOTkNlbGwoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9BQ1RJVkFUSU9OID0gJ3RhbmgnO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiA9ICdnbG9yb3ROb3JtYWwnO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiA9ICdvcnRob2dvbmFsJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSID0gJ3plcm9zJztcbiAgICAgICAgX3RoaXMudW5pdHMgPSBjb25maWcudW5pdHM7XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb24gPSBhY3RpdmF0aW9uc18xLmdldEFjdGl2YXRpb24oY29uZmlnLmFjdGl2YXRpb24gPT0gbnVsbCA/IF90aGlzLkRFRkFVTFRfQUNUSVZBVElPTiA6XG4gICAgICAgICAgICBjb25maWcuYWN0aXZhdGlvbik7XG4gICAgICAgIF90aGlzLnVzZUJpYXMgPSBjb25maWcudXNlQmlhcyA9PSBudWxsID8gdHJ1ZSA6IGNvbmZpZy51c2VCaWFzO1xuICAgICAgICBfdGhpcy5rZXJuZWxJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5rZXJuZWxJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUik7XG4gICAgICAgIF90aGlzLnJlY3VycmVudEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLnJlY3VycmVudEluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMuYmlhc0luaXRpYWxpemVyID1cbiAgICAgICAgICAgIGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5iaWFzSW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMua2VybmVsUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcua2VybmVsUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5yZWN1cnJlbnRSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmJpYXNSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5iaWFzUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5rZXJuZWxDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50Q29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcucmVjdXJyZW50Q29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmJpYXNDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmRyb3BvdXQgPSBtYXRoX3V0aWxzLm1pbihbMSwgbWF0aF91dGlscy5tYXgoWzAsIGNvbmZpZy5kcm9wb3V0ID09IG51bGwgPyAwIDogY29uZmlnLmRyb3BvdXRdKV0pO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnREcm9wb3V0ID0gbWF0aF91dGlscy5taW4oW1xuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIG1hdGhfdXRpbHMubWF4KFswLCBjb25maWcucmVjdXJyZW50RHJvcG91dCA9PSBudWxsID8gMCA6IGNvbmZpZy5yZWN1cnJlbnREcm9wb3V0XSlcbiAgICAgICAgXSk7XG4gICAgICAgIF90aGlzLnN0YXRlU2l6ZSA9IF90aGlzLnVuaXRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNpbXBsZVJOTkNlbGwucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB0aGlzLmtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KCdrZXJuZWwnLCBbaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdLCB0aGlzLnVuaXRzXSwgbnVsbCwgdGhpcy5rZXJuZWxJbml0aWFsaXplciwgdGhpcy5rZXJuZWxSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy5yZWN1cnJlbnRLZXJuZWwgPSB0aGlzLmFkZFdlaWdodCgncmVjdXJyZW50X2tlcm5lbCcsIFt0aGlzLnVuaXRzLCB0aGlzLnVuaXRzXSwgbnVsbCwgdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciwgdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoJ2JpYXMnLCBbdGhpcy51bml0c10sIG51bGwsIHRoaXMuYmlhc0luaXRpYWxpemVyLCB0aGlzLmJpYXNSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpYXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgIH07XG4gICAgU2ltcGxlUk5OQ2VsbC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiU2ltcGxlUk5OQ2VsbCBleHBlY3RzIDIgaW5wdXQgVGVuc29ycywgZ290IFwiICsgaW5wdXRzLmxlbmd0aCArIFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2T3V0cHV0ID0gaW5wdXRzWzFdO1xuICAgICAgICAgICAgaW5wdXRzID0gaW5wdXRzWzBdO1xuICAgICAgICAgICAgaWYgKF90aGlzLmRyb3BvdXQgIT09IDAgfHwgX3RoaXMucmVjdXJyZW50RHJvcG91dCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdEcm9wb3V0IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgU2ltcGxlUk5OQ2VsbCB5ZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoID0gSy5kb3QoaW5wdXRzLCBfdGhpcy5rZXJuZWwucmVhZCgpKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5iaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoID0gSy5iaWFzQWRkKGgsIF90aGlzLmJpYXMucmVhZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0ZmMuYWRkKGgsIEsuZG90KHByZXZPdXRwdXQsIF90aGlzLnJlY3VycmVudEtlcm5lbC5yZWFkKCkpKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBfdGhpcy5hY3RpdmF0aW9uLmFwcGx5KG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW291dHB1dCwgb3V0cHV0XTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTaW1wbGVSTk5DZWxsLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICB1bml0czogdGhpcy51bml0cyxcbiAgICAgICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25zXzEuc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAgICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgcmVjdXJyZW50SW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICAgICAgICBrZXJuZWxSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiaWFzUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICAgICAgICBrZXJuZWxDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgICAgICAgIHJlY3VycmVudENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgYmlhc0NvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGRyb3BvdXQ6IHRoaXMuZHJvcG91dCxcbiAgICAgICAgICAgIHJlY3VycmVudERyb3BvdXQ6IHRoaXMucmVjdXJyZW50RHJvcG91dCxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBTaW1wbGVSTk5DZWxsLmNsYXNzTmFtZSA9ICdTaW1wbGVSTk5DZWxsJztcbiAgICByZXR1cm4gU2ltcGxlUk5OQ2VsbDtcbn0oUk5OQ2VsbCkpO1xuZXhwb3J0cy5TaW1wbGVSTk5DZWxsID0gU2ltcGxlUk5OQ2VsbDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihTaW1wbGVSTk5DZWxsKTtcbnZhciBTaW1wbGVSTk4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW1wbGVSTk4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2ltcGxlUk5OKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25maWcuY2VsbCA9IG5ldyBTaW1wbGVSTk5DZWxsKGNvbmZpZyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNpbXBsZVJOTi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFzayA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snbWFzayddO1xuICAgICAgICAgICAgdmFyIHRyYWluaW5nID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWyd0cmFpbmluZyddO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snaW5pdGlhbFN0YXRlJ107XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jYWxsLmNhbGwoX3RoaXMsIGlucHV0cywgeyBtYXNrOiBtYXNrLCB0cmFpbmluZzogdHJhaW5pbmcsIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcInVuaXRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnVuaXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJhY3RpdmF0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmFjdGl2YXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcInVzZUJpYXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwudXNlQmlhcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwia2VybmVsSW5pdGlhbGl6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwua2VybmVsSW5pdGlhbGl6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcInJlY3VycmVudEluaXRpYWxpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudEluaXRpYWxpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJiaWFzSW5pdGlhbGl6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJrZXJuZWxSZWd1bGFyaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxSZWd1bGFyaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwicmVjdXJyZW50UmVndWxhcml6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwucmVjdXJyZW50UmVndWxhcml6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcImJpYXNSZWd1bGFyaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcImtlcm5lbENvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwua2VybmVsQ29uc3RyYWludDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwicmVjdXJyZW50Q29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRDb25zdHJhaW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJiaWFzQ29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwiZHJvcG91dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5kcm9wb3V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJyZWN1cnJlbnREcm9wb3V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNpbXBsZVJOTi5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgdW5pdHM6IHRoaXMudW5pdHMsXG4gICAgICAgICAgICBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uc18xLnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxcbiAgICAgICAgICAgIHVzZUJpYXM6IHRoaXMudXNlQmlhcyxcbiAgICAgICAgICAgIGtlcm5lbEluaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIHJlY3VycmVudEluaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGJpYXNJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAga2VybmVsUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgcmVjdXJyZW50UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYmlhc1JlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksXG4gICAgICAgICAgICBhY3Rpdml0eVJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLFxuICAgICAgICAgICAga2VybmVsQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCksXG4gICAgICAgICAgICByZWN1cnJlbnRDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGJpYXNDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksXG4gICAgICAgICAgICBkcm9wb3V0OiB0aGlzLmRyb3BvdXQsXG4gICAgICAgICAgICByZWN1cnJlbnREcm9wb3V0OiB0aGlzLnJlY3VycmVudERyb3BvdXQsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgZGVsZXRlIGJhc2VDb25maWdbJ2NlbGwnXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgU2ltcGxlUk5OLmNsYXNzTmFtZSA9ICdTaW1wbGVSTk4nO1xuICAgIHJldHVybiBTaW1wbGVSTk47XG59KFJOTikpO1xuZXhwb3J0cy5TaW1wbGVSTk4gPSBTaW1wbGVSTk47XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoU2ltcGxlUk5OKTtcbnZhciBHUlVDZWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR1JVQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHUlVDZWxsKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQUNUSVZBVElPTiA9ICd0YW5oJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTiA9ICdoYXJkU2lnbW9pZCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSID0gJ2dsb3JvdE5vcm1hbCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSID0gJ29ydGhvZ29uYWwnO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIgPSAnemVyb3MnO1xuICAgICAgICBfdGhpcy51bml0cyA9IGNvbmZpZy51bml0cztcbiAgICAgICAgX3RoaXMuYWN0aXZhdGlvbiA9IGFjdGl2YXRpb25zXzEuZ2V0QWN0aXZhdGlvbihjb25maWcuYWN0aXZhdGlvbiA9PT0gdW5kZWZpbmVkID8gX3RoaXMuREVGQVVMVF9BQ1RJVkFUSU9OIDpcbiAgICAgICAgICAgIGNvbmZpZy5hY3RpdmF0aW9uKTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50QWN0aXZhdGlvbiA9IGFjdGl2YXRpb25zXzEuZ2V0QWN0aXZhdGlvbihjb25maWcuYWN0aXZhdGlvbiA9PT0gdW5kZWZpbmVkID8gX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTiA6XG4gICAgICAgICAgICBjb25maWcucmVjdXJyZW50QWN0aXZhdGlvbik7XG4gICAgICAgIF90aGlzLnVzZUJpYXMgPSBjb25maWcudXNlQmlhcyA9PSBudWxsID8gdHJ1ZSA6IGNvbmZpZy51c2VCaWFzO1xuICAgICAgICBfdGhpcy5rZXJuZWxJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5rZXJuZWxJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUik7XG4gICAgICAgIF90aGlzLnJlY3VycmVudEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLnJlY3VycmVudEluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMuYmlhc0luaXRpYWxpemVyID1cbiAgICAgICAgICAgIGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5iaWFzSW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMua2VybmVsUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcua2VybmVsUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5yZWN1cnJlbnRSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmJpYXNSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5iaWFzUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5rZXJuZWxDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50Q29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcucmVjdXJyZW50Q29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmJpYXNDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmRyb3BvdXQgPSBtYXRoX3V0aWxzLm1pbihbMSwgbWF0aF91dGlscy5tYXgoWzAsIGNvbmZpZy5kcm9wb3V0ID09IG51bGwgPyAwIDogY29uZmlnLmRyb3BvdXRdKV0pO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnREcm9wb3V0ID0gbWF0aF91dGlscy5taW4oW1xuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIG1hdGhfdXRpbHMubWF4KFswLCBjb25maWcucmVjdXJyZW50RHJvcG91dCA9PSBudWxsID8gMCA6IGNvbmZpZy5yZWN1cnJlbnREcm9wb3V0XSlcbiAgICAgICAgXSk7XG4gICAgICAgIF90aGlzLmltcGxlbWVudGF0aW9uID0gY29uZmlnLmltcGxlbWVudGF0aW9uO1xuICAgICAgICBfdGhpcy5zdGF0ZVNpemUgPSBfdGhpcy51bml0cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHUlVDZWxsLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIGlucHV0RGltID0gaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KCdrZXJuZWwnLCBbaW5wdXREaW0sIHRoaXMudW5pdHMgKiAzXSwgbnVsbCwgdGhpcy5rZXJuZWxJbml0aWFsaXplciwgdGhpcy5rZXJuZWxSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy5yZWN1cnJlbnRLZXJuZWwgPSB0aGlzLmFkZFdlaWdodCgncmVjdXJyZW50X2tlcm5lbCcsIFt0aGlzLnVuaXRzLCB0aGlzLnVuaXRzICogM10sIG51bGwsIHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsIHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsIHRydWUsIHRoaXMucmVjdXJyZW50Q29uc3RyYWludCk7XG4gICAgICAgIGlmICh0aGlzLnVzZUJpYXMpIHtcbiAgICAgICAgICAgIHRoaXMuYmlhcyA9IHRoaXMuYWRkV2VpZ2h0KCdiaWFzJywgW3RoaXMudW5pdHMgKiAzXSwgbnVsbCwgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmlhcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgfTtcbiAgICBHUlVDZWxsLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kcm9wb3V0ICE9PSAwIHx8IF90aGlzLnJlY3VycmVudERyb3BvdXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignRHJvcG91dCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEdSVUNlbGwgeWV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiR1JVQ2VsbCBleHBlY3RzIDIgaW5wdXQgVGVuc29ycyAoaW5wdXRzLCBoLCBjKSwgZ290IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGlucHV0cy5sZW5ndGggKyBcIi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhUTWludXMxID0gaW5wdXRzWzFdO1xuICAgICAgICAgICAgaW5wdXRzID0gaW5wdXRzWzBdO1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICAgIHZhciBoaDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbXBsZW1lbnRhdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXJuZWxaID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMua2VybmVsLnJlYWQoKSwgMCwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciBrZXJuZWxSID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMua2VybmVsLnJlYWQoKSwgX3RoaXMudW5pdHMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIga2VybmVsSCA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKF90aGlzLmtlcm5lbC5yZWFkKCksIF90aGlzLnVuaXRzICogMiwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciByZWN1cnJlbnRLZXJuZWxaID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSwgMCwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciByZWN1cnJlbnRLZXJuZWxSID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSwgX3RoaXMudW5pdHMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXJyZW50S2VybmVsSCA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKF90aGlzLnJlY3VycmVudEtlcm5lbC5yZWFkKCksIF90aGlzLnVuaXRzICogMiwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHNaID0gaW5wdXRzO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHNSID0gaW5wdXRzO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHNIID0gaW5wdXRzO1xuICAgICAgICAgICAgICAgIHZhciB4WiA9IEsuZG90KGlucHV0c1osIGtlcm5lbFopO1xuICAgICAgICAgICAgICAgIHZhciB4UiA9IEsuZG90KGlucHV0c1IsIGtlcm5lbFIpO1xuICAgICAgICAgICAgICAgIHZhciB4SCA9IEsuZG90KGlucHV0c0gsIGtlcm5lbEgpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaWFzWiA9IEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhfdGhpcy5iaWFzLnJlYWQoKSwgMCwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmlhc1IgPSBLLnNsaWNlQWxvbmdGaXJzdEF4aXMoX3RoaXMuYmlhcy5yZWFkKCksIF90aGlzLnVuaXRzLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaWFzSCA9IEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhfdGhpcy5iaWFzLnJlYWQoKSwgX3RoaXMudW5pdHMgKiAyLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHhaID0gSy5iaWFzQWRkKHhaLCBiaWFzWik7XG4gICAgICAgICAgICAgICAgICAgIHhSID0gSy5iaWFzQWRkKHhSLCBiaWFzUik7XG4gICAgICAgICAgICAgICAgICAgIHhIID0gSy5iaWFzQWRkKHhILCBiaWFzSCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBoVE1pbnVzMVogPSBoVE1pbnVzMTtcbiAgICAgICAgICAgICAgICB2YXIgaFRNaW51czFSID0gaFRNaW51czE7XG4gICAgICAgICAgICAgICAgdmFyIGhUTWludXMxSCA9IGhUTWludXMxO1xuICAgICAgICAgICAgICAgIHogPSBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeFosIEsuZG90KGhUTWludXMxWiwgcmVjdXJyZW50S2VybmVsWikpKTtcbiAgICAgICAgICAgICAgICByID0gX3RoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh0ZmMuYWRkKHhSLCBLLmRvdChoVE1pbnVzMVIsIHJlY3VycmVudEtlcm5lbFIpKSk7XG4gICAgICAgICAgICAgICAgaGggPSBfdGhpcy5hY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeEgsIEsuZG90KHRmYy5tdWwociwgaFRNaW51czFIKSwgcmVjdXJyZW50S2VybmVsSCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXRyaXhYID0gSy5kb3QoaW5wdXRzLCBfdGhpcy5rZXJuZWwucmVhZCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXhYID0gSy5iaWFzQWRkKG1hdHJpeFgsIF90aGlzLmJpYXMucmVhZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeElubmVyID0gSy5kb3QoaFRNaW51czEsIEsuc2xpY2VBbG9uZ0xhc3RBeGlzKF90aGlzLnJlY3VycmVudEtlcm5lbC5yZWFkKCksIDAsIDIgKiBfdGhpcy51bml0cykpO1xuICAgICAgICAgICAgICAgIHZhciB4WiA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKG1hdHJpeFgsIDAsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgeFIgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhtYXRyaXhYLCBfdGhpcy51bml0cywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciByZWN1cnJlbnRaID0gSy5zbGljZUFsb25nTGFzdEF4aXMobWF0cml4SW5uZXIsIDAsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXJyZW50UiA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKG1hdHJpeElubmVyLCBfdGhpcy51bml0cywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHogPSBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeFosIHJlY3VycmVudFopKTtcbiAgICAgICAgICAgICAgICByID0gX3RoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh0ZmMuYWRkKHhSLCByZWN1cnJlbnRSKSk7XG4gICAgICAgICAgICAgICAgdmFyIHhIID0gSy5zbGljZUFsb25nTGFzdEF4aXMobWF0cml4WCwgMiAqIF90aGlzLnVuaXRzLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VycmVudEggPSBLLmRvdCh0ZmMubXVsKHIsIGhUTWludXMxKSwgSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSwgMiAqIF90aGlzLnVuaXRzLCBfdGhpcy51bml0cykpO1xuICAgICAgICAgICAgICAgIGhoID0gX3RoaXMuYWN0aXZhdGlvbi5hcHBseSh0ZmMuYWRkKHhILCByZWN1cnJlbnRIKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaCA9IHRmYy5hZGQodGZjLm11bCh6LCBoVE1pbnVzMSksIHRmYy5tdWwoSy5zY2FsYXJQbHVzQXJyYXkoSy5nZXRTY2FsYXIoMSksIHRmYy5uZWcoeikpLCBoaCkpO1xuICAgICAgICAgICAgcmV0dXJuIFtoLCBoXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUlVDZWxsLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICB1bml0czogdGhpcy51bml0cyxcbiAgICAgICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25zXzEuc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAgICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgcmVjdXJyZW50SW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICAgICAgICBrZXJuZWxSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiaWFzUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICAgICAgICBrZXJuZWxDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgICAgICAgIHJlY3VycmVudENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgYmlhc0NvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGRyb3BvdXQ6IHRoaXMuZHJvcG91dCxcbiAgICAgICAgICAgIHJlY3VycmVudERyb3BvdXQ6IHRoaXMucmVjdXJyZW50RHJvcG91dCxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiB0aGlzLmltcGxlbWVudGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIEdSVUNlbGwuY2xhc3NOYW1lID0gJ0dSVUNlbGwnO1xuICAgIHJldHVybiBHUlVDZWxsO1xufShSTk5DZWxsKSk7XG5leHBvcnRzLkdSVUNlbGwgPSBHUlVDZWxsO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEdSVUNlbGwpO1xudmFyIEdSVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdSVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHUlUoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb25maWcuaW1wbGVtZW50YXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYGltcGxlbWVudGF0aW9uPTBgIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCBub3cgZGVmYXVsdHMgdG8gJyArXG4gICAgICAgICAgICAgICAgJ2BpbXBsZW1lbnRhdGlvbj0xYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGxheWVyIGNhbGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLmNlbGwgPSBuZXcgR1JVQ2VsbChjb25maWcpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHUlUucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hc2sgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ21hc2snXTtcbiAgICAgICAgICAgIHZhciB0cmFpbmluZyA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1sndHJhaW5pbmcnXTtcbiAgICAgICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddO1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY2FsbC5jYWxsKF90aGlzLCBpbnB1dHMsIHsgbWFzazogbWFzaywgdHJhaW5pbmc6IHRyYWluaW5nLCBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJ1bml0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC51bml0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwiYWN0aXZhdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5hY3RpdmF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJ1c2VCaWFzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnVzZUJpYXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcImtlcm5lbEluaXRpYWxpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJyZWN1cnJlbnRJbml0aWFsaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRJbml0aWFsaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwiYmlhc0luaXRpYWxpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmJpYXNJbml0aWFsaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwia2VybmVsUmVndWxhcml6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwua2VybmVsUmVndWxhcml6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcInJlY3VycmVudFJlZ3VsYXJpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudFJlZ3VsYXJpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJiaWFzUmVndWxhcml6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYmlhc1JlZ3VsYXJpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJrZXJuZWxDb25zdHJhaW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmtlcm5lbENvbnN0cmFpbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcInJlY3VycmVudENvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwucmVjdXJyZW50Q29uc3RyYWludDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwiYmlhc0NvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYmlhc0NvbnN0cmFpbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcImRyb3BvdXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuZHJvcG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwicmVjdXJyZW50RHJvcG91dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJpbXBsZW1lbnRhdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5pbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgR1JVLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICB1bml0czogdGhpcy51bml0cyxcbiAgICAgICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25zXzEuc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAgICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgcmVjdXJyZW50SW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICAgICAgICBrZXJuZWxSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiaWFzUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICAgICAgICBrZXJuZWxDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgICAgICAgIHJlY3VycmVudENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgYmlhc0NvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGRyb3BvdXQ6IHRoaXMuZHJvcG91dCxcbiAgICAgICAgICAgIHJlY3VycmVudERyb3BvdXQ6IHRoaXMucmVjdXJyZW50RHJvcG91dCxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiB0aGlzLmltcGxlbWVudGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIGRlbGV0ZSBiYXNlQ29uZmlnWydjZWxsJ107XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIEdSVS5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWdbJ2ltcGxtZW50YXRpb24nXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnWydpbXBsZW1lbnRhdGlvbiddID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNscyhjb25maWcpO1xuICAgIH07XG4gICAgR1JVLmNsYXNzTmFtZSA9ICdHUlUnO1xuICAgIHJldHVybiBHUlU7XG59KFJOTikpO1xuZXhwb3J0cy5HUlUgPSBHUlU7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoR1JVKTtcbnZhciBMU1RNQ2VsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExTVE1DZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExTVE1DZWxsKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQUNUSVZBVElPTiA9ICd0YW5oJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTiA9ICdoYXJkU2lnbW9pZCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSID0gJ2dsb3JvdE5vcm1hbCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSID0gJ29ydGhvZ29uYWwnO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIgPSAnemVyb3MnO1xuICAgICAgICBfdGhpcy51bml0cyA9IGNvbmZpZy51bml0cztcbiAgICAgICAgX3RoaXMuYWN0aXZhdGlvbiA9IGFjdGl2YXRpb25zXzEuZ2V0QWN0aXZhdGlvbihjb25maWcuYWN0aXZhdGlvbiA9PT0gdW5kZWZpbmVkID8gX3RoaXMuREVGQVVMVF9BQ1RJVkFUSU9OIDpcbiAgICAgICAgICAgIGNvbmZpZy5hY3RpdmF0aW9uKTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50QWN0aXZhdGlvbiA9IGFjdGl2YXRpb25zXzEuZ2V0QWN0aXZhdGlvbihjb25maWcuYWN0aXZhdGlvbiA9PT0gdW5kZWZpbmVkID8gX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTiA6XG4gICAgICAgICAgICBjb25maWcucmVjdXJyZW50QWN0aXZhdGlvbik7XG4gICAgICAgIF90aGlzLnVzZUJpYXMgPSBjb25maWcudXNlQmlhcyA9PSBudWxsID8gdHJ1ZSA6IGNvbmZpZy51c2VCaWFzO1xuICAgICAgICBfdGhpcy5rZXJuZWxJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5rZXJuZWxJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUik7XG4gICAgICAgIF90aGlzLnJlY3VycmVudEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLnJlY3VycmVudEluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMuYmlhc0luaXRpYWxpemVyID1cbiAgICAgICAgICAgIGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5iaWFzSW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMudW5pdEZvcmdldEJpYXMgPSBjb25maWcudW5pdEZvcmdldEJpYXM7XG4gICAgICAgIF90aGlzLmtlcm5lbFJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmtlcm5lbFJlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50UmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcucmVjdXJyZW50UmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5iaWFzUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcuYmlhc1JlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMua2VybmVsQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcua2VybmVsQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLnJlY3VycmVudENvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLnJlY3VycmVudENvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5iaWFzQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5kcm9wb3V0ID0gbWF0aF91dGlscy5taW4oWzEsIG1hdGhfdXRpbHMubWF4KFswLCBjb25maWcuZHJvcG91dCA9PSBudWxsID8gMCA6IGNvbmZpZy5kcm9wb3V0XSldKTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50RHJvcG91dCA9IG1hdGhfdXRpbHMubWluKFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBtYXRoX3V0aWxzLm1heChbMCwgY29uZmlnLnJlY3VycmVudERyb3BvdXQgPT0gbnVsbCA/IDAgOiBjb25maWcucmVjdXJyZW50RHJvcG91dF0pXG4gICAgICAgIF0pO1xuICAgICAgICBfdGhpcy5pbXBsZW1lbnRhdGlvbiA9IGNvbmZpZy5pbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgX3RoaXMuc3RhdGVTaXplID0gW190aGlzLnVuaXRzLCBfdGhpcy51bml0c107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTFNUTUNlbGwucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ2tlcm5lbCcsIFtpbnB1dERpbSwgdGhpcy51bml0cyAqIDRdLCBudWxsLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLCB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICB0aGlzLnJlY3VycmVudEtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KCdyZWN1cnJlbnRfa2VybmVsJywgW3RoaXMudW5pdHMsIHRoaXMudW5pdHMgKiA0XSwgbnVsbCwgdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciwgdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KTtcbiAgICAgICAgdmFyIGJpYXNJbml0aWFsaXplcjtcbiAgICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5pdEZvcmdldEJpYXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZWRCaWFzSW5pdF8xID0gdGhpcy5iaWFzSW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgdmFyIGNhcHR1cmVkVW5pdHNfMSA9IHRoaXMudW5pdHM7XG4gICAgICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyID0gbmV3IChfYSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2V4dGVuZHMoQ3VzdG9tSW5pdCwgX3N1cGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEN1c3RvbUluaXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgQ3VzdG9tSW5pdC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJJID0gY2FwdHVyZWRCaWFzSW5pdF8xLmFwcGx5KFtjYXB0dXJlZFVuaXRzXzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYkYgPSAobmV3IGluaXRpYWxpemVyc18xLk9uZXMoKSkuYXBwbHkoW2NhcHR1cmVkVW5pdHNfMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiQ0FuZEggPSBjYXB0dXJlZEJpYXNJbml0XzEuYXBwbHkoW2NhcHR1cmVkVW5pdHNfMSAqIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSy5jb25jYXRBbG9uZ0ZpcnN0QXhpcyhLLmNvbmNhdEFsb25nRmlyc3RBeGlzKGJJLCBiRiksIGJDQW5kSCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEN1c3RvbUluaXQ7XG4gICAgICAgICAgICAgICAgICAgIH0oaW5pdGlhbGl6ZXJzXzEuSW5pdGlhbGl6ZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgX2EuY2xhc3NOYW1lID0gJ0N1c3RvbUluaXQnLFxuICAgICAgICAgICAgICAgICAgICBfYSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpYXNJbml0aWFsaXplciA9IHRoaXMuYmlhc0luaXRpYWxpemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoJ2JpYXMnLCBbdGhpcy51bml0cyAqIDRdLCBudWxsLCBiaWFzSW5pdGlhbGl6ZXIsIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmlhcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIExTVE1DZWxsLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kcm9wb3V0ICE9PSAwIHx8IF90aGlzLnJlY3VycmVudERyb3BvdXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignRHJvcG91dCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIExTVE1DZWxsIHlldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkxTVE1DZWxsIGV4cGVjdHMgMyBpbnB1dCBUZW5zb3JzIChpbnB1dHMsIGgsIGMpLCBnb3QgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5wdXRzLmxlbmd0aCArIFwiLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaFRNaW51czEgPSBpbnB1dHNbMV07XG4gICAgICAgICAgICB2YXIgY1RNaW51czEgPSBpbnB1dHNbMl07XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHNbMF07XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBmO1xuICAgICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgICB2YXIgbztcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbXBsZW1lbnRhdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXJuZWxJID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMua2VybmVsLnJlYWQoKSwgMCwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciBrZXJuZWxGID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMua2VybmVsLnJlYWQoKSwgX3RoaXMudW5pdHMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIga2VybmVsQyA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKF90aGlzLmtlcm5lbC5yZWFkKCksIF90aGlzLnVuaXRzICogMiwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciBrZXJuZWxPID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMua2VybmVsLnJlYWQoKSwgX3RoaXMudW5pdHMgKiAzLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VycmVudEtlcm5lbEkgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLCAwLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VycmVudEtlcm5lbEYgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLCBfdGhpcy51bml0cywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciByZWN1cnJlbnRLZXJuZWxDID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSwgX3RoaXMudW5pdHMgKiAyLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VycmVudEtlcm5lbE8gPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLCBfdGhpcy51bml0cyAqIDMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRzSSA9IGlucHV0cztcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRzRiA9IGlucHV0cztcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRzQyA9IGlucHV0cztcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRzTyA9IGlucHV0cztcbiAgICAgICAgICAgICAgICB2YXIgeEkgPSBLLmRvdChpbnB1dHNJLCBrZXJuZWxJKTtcbiAgICAgICAgICAgICAgICB2YXIgeEYgPSBLLmRvdChpbnB1dHNGLCBrZXJuZWxGKTtcbiAgICAgICAgICAgICAgICB2YXIgeEMgPSBLLmRvdChpbnB1dHNDLCBrZXJuZWxDKTtcbiAgICAgICAgICAgICAgICB2YXIgeE8gPSBLLmRvdChpbnB1dHNPLCBrZXJuZWxPKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmlhc0kgPSBLLnNsaWNlQWxvbmdGaXJzdEF4aXMoX3RoaXMuYmlhcy5yZWFkKCksIDAsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpYXNGID0gSy5zbGljZUFsb25nRmlyc3RBeGlzKF90aGlzLmJpYXMucmVhZCgpLCBfdGhpcy51bml0cywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmlhc0MgPSBLLnNsaWNlQWxvbmdGaXJzdEF4aXMoX3RoaXMuYmlhcy5yZWFkKCksIF90aGlzLnVuaXRzICogMiwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmlhc08gPSBLLnNsaWNlQWxvbmdGaXJzdEF4aXMoX3RoaXMuYmlhcy5yZWFkKCksIF90aGlzLnVuaXRzICogMywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICB4SSA9IEsuYmlhc0FkZCh4SSwgYmlhc0kpO1xuICAgICAgICAgICAgICAgICAgICB4RiA9IEsuYmlhc0FkZCh4RiwgYmlhc0YpO1xuICAgICAgICAgICAgICAgICAgICB4QyA9IEsuYmlhc0FkZCh4QywgYmlhc0MpO1xuICAgICAgICAgICAgICAgICAgICB4TyA9IEsuYmlhc0FkZCh4TywgYmlhc08pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaFRNaW51czFJID0gaFRNaW51czE7XG4gICAgICAgICAgICAgICAgdmFyIGhUTWludXMxRiA9IGhUTWludXMxO1xuICAgICAgICAgICAgICAgIHZhciBoVE1pbnVzMUMgPSBoVE1pbnVzMTtcbiAgICAgICAgICAgICAgICB2YXIgaFRNaW51czFPID0gaFRNaW51czE7XG4gICAgICAgICAgICAgICAgaSA9IF90aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4SSwgSy5kb3QoaFRNaW51czFJLCByZWN1cnJlbnRLZXJuZWxJKSkpO1xuICAgICAgICAgICAgICAgIGYgPSBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeEYsIEsuZG90KGhUTWludXMxRiwgcmVjdXJyZW50S2VybmVsRikpKTtcbiAgICAgICAgICAgICAgICBjID0gdGZjLmFkZCh0ZmMubXVsKGYsIGNUTWludXMxKSwgdGZjLm11bChpLCBfdGhpcy5hY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeEMsIEsuZG90KGhUTWludXMxQywgcmVjdXJyZW50S2VybmVsQykpKSkpO1xuICAgICAgICAgICAgICAgIG8gPSBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeE8sIEsuZG90KGhUTWludXMxTywgcmVjdXJyZW50S2VybmVsTykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gSy5kb3QoaW5wdXRzLCBfdGhpcy5rZXJuZWwucmVhZCgpKTtcbiAgICAgICAgICAgICAgICB6ID0gdGZjLmFkZCh6LCBLLmRvdChoVE1pbnVzMSwgX3RoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHogPSBLLmJpYXNBZGQoeiwgX3RoaXMuYmlhcy5yZWFkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgejAgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyh6LCAwLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHoxID0gSy5zbGljZUFsb25nTGFzdEF4aXMoeiwgX3RoaXMudW5pdHMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgejIgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyh6LCBfdGhpcy51bml0cyAqIDIsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgejMgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyh6LCBfdGhpcy51bml0cyAqIDMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICBpID0gX3RoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh6MCk7XG4gICAgICAgICAgICAgICAgZiA9IF90aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoejEpO1xuICAgICAgICAgICAgICAgIGMgPSB0ZmMuYWRkKHRmYy5tdWwoZiwgY1RNaW51czEpLCB0ZmMubXVsKGksIF90aGlzLmFjdGl2YXRpb24uYXBwbHkoejIpKSk7XG4gICAgICAgICAgICAgICAgbyA9IF90aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoejMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGggPSB0ZmMubXVsKG8sIF90aGlzLmFjdGl2YXRpb24uYXBwbHkoYykpO1xuICAgICAgICAgICAgcmV0dXJuIFtoLCBoLCBjXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMU1RNQ2VsbC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgdW5pdHM6IHRoaXMudW5pdHMsXG4gICAgICAgICAgICBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uc18xLnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxcbiAgICAgICAgICAgIHVzZUJpYXM6IHRoaXMudXNlQmlhcyxcbiAgICAgICAgICAgIGtlcm5lbEluaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIHJlY3VycmVudEluaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGJpYXNJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgdW5pdEZvcmdldEJpYXM6IHRoaXMudW5pdEZvcmdldEJpYXMsXG4gICAgICAgICAgICBrZXJuZWxSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiaWFzUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICAgICAgICBrZXJuZWxDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgICAgICAgIHJlY3VycmVudENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgYmlhc0NvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGRyb3BvdXQ6IHRoaXMuZHJvcG91dCxcbiAgICAgICAgICAgIHJlY3VycmVudERyb3BvdXQ6IHRoaXMucmVjdXJyZW50RHJvcG91dCxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiB0aGlzLmltcGxlbWVudGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIExTVE1DZWxsLmNsYXNzTmFtZSA9ICdMU1RNQ2VsbCc7XG4gICAgcmV0dXJuIExTVE1DZWxsO1xufShSTk5DZWxsKSk7XG5leHBvcnRzLkxTVE1DZWxsID0gTFNUTUNlbGw7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTFNUTUNlbGwpO1xudmFyIExTVE0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMU1RNLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExTVE0oY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb25maWcuaW1wbGVtZW50YXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYGltcGxlbWVudGF0aW9uPTBgIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCBub3cgZGVmYXVsdHMgdG8gJyArXG4gICAgICAgICAgICAgICAgJ2BpbXBsZW1lbnRhdGlvbj0xYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGxheWVyIGNhbGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLmNlbGwgPSBuZXcgTFNUTUNlbGwoY29uZmlnKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTFNUTS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFzayA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snbWFzayddO1xuICAgICAgICAgICAgdmFyIHRyYWluaW5nID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWyd0cmFpbmluZyddO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snaW5pdGlhbFN0YXRlJ107XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jYWxsLmNhbGwoX3RoaXMsIGlucHV0cywgeyBtYXNrOiBtYXNrLCB0cmFpbmluZzogdHJhaW5pbmcsIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJ1bml0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC51bml0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcImFjdGl2YXRpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcInVzZUJpYXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwudXNlQmlhcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcImtlcm5lbEluaXRpYWxpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwicmVjdXJyZW50SW5pdGlhbGl6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJiaWFzSW5pdGlhbGl6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwidW5pdEZvcmdldEJpYXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwudW5pdEZvcmdldEJpYXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJrZXJuZWxSZWd1bGFyaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxSZWd1bGFyaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcInJlY3VycmVudFJlZ3VsYXJpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudFJlZ3VsYXJpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwiYmlhc1JlZ3VsYXJpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmJpYXNSZWd1bGFyaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcImtlcm5lbENvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwua2VybmVsQ29uc3RyYWludDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcInJlY3VycmVudENvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwucmVjdXJyZW50Q29uc3RyYWludDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcImJpYXNDb25zdHJhaW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmJpYXNDb25zdHJhaW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwiZHJvcG91dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5kcm9wb3V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwicmVjdXJyZW50RHJvcG91dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwiaW1wbGVtZW50YXRpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuaW1wbGVtZW50YXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExTVE0ucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHVuaXRzOiB0aGlzLnVuaXRzLFxuICAgICAgICAgICAgYWN0aXZhdGlvbjogYWN0aXZhdGlvbnNfMS5zZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksXG4gICAgICAgICAgICB1c2VCaWFzOiB0aGlzLnVzZUJpYXMsXG4gICAgICAgICAgICBrZXJuZWxJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksXG4gICAgICAgICAgICBiaWFzSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxcbiAgICAgICAgICAgIHVuaXRGb3JnZXRCaWFzOiB0aGlzLnVuaXRGb3JnZXRCaWFzLFxuICAgICAgICAgICAga2VybmVsUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgcmVjdXJyZW50UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYmlhc1JlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksXG4gICAgICAgICAgICBhY3Rpdml0eVJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLFxuICAgICAgICAgICAga2VybmVsQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCksXG4gICAgICAgICAgICByZWN1cnJlbnRDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGJpYXNDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksXG4gICAgICAgICAgICBkcm9wb3V0OiB0aGlzLmRyb3BvdXQsXG4gICAgICAgICAgICByZWN1cnJlbnREcm9wb3V0OiB0aGlzLnJlY3VycmVudERyb3BvdXQsXG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogdGhpcy5pbXBsZW1lbnRhdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBkZWxldGUgYmFzZUNvbmZpZ1snY2VsbCddO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBMU1RNLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1snaW1wbG1lbnRhdGlvbiddID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWdbJ2ltcGxlbWVudGF0aW9uJ10gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY2xzKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMU1RNLmNsYXNzTmFtZSA9ICdMU1RNJztcbiAgICByZXR1cm4gTFNUTTtcbn0oUk5OKSk7XG5leHBvcnRzLkxTVE0gPSBMU1RNO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKExTVE0pO1xudmFyIFN0YWNrZWRSTk5DZWxscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrZWRSTk5DZWxscywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFja2VkUk5OQ2VsbHMoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2VsbHMgPSBjb25maWcuY2VsbHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YWNrZWRSTk5DZWxscy5wcm90b3R5cGUsIFwic3RhdGVTaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVTaXplID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jZWxscy5zbGljZSgpLnJldmVyc2UoKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjZWxsLnN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTaXplLnB1c2guYXBwbHkoc3RhdGVTaXplLCBjZWxsLnN0YXRlU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVNpemUucHVzaChjZWxsLnN0YXRlU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlU2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RhY2tlZFJOTkNlbGxzLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIHZhciBzdGF0ZXMgPSBpbnB1dHMuc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgbmVzdGVkU3RhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMuY2VsbHMuc2xpY2UoKS5yZXZlcnNlKCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZFN0YXRlcy5wdXNoKHN0YXRlcy5zcGxpY2UoMCwgY2VsbC5zdGF0ZVNpemUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRTdGF0ZXMucHVzaChzdGF0ZXMuc3BsaWNlKDAsIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXN0ZWRTdGF0ZXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgdmFyIG5ld05lc3RlZFN0YXRlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNhbGxJbnB1dHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfdGhpcy5jZWxsc1tpXTtcbiAgICAgICAgICAgICAgICBzdGF0ZXMgPSBuZXN0ZWRTdGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbElucHV0cyA9IFtpbnB1dHNbMF1dLmNvbmNhdChzdGF0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbElucHV0cyA9IFtjYWxsSW5wdXRzWzBdXS5jb25jYXQoc3RhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbElucHV0cyA9IGNlbGwuY2FsbChjYWxsSW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgICAgIG5ld05lc3RlZFN0YXRlcy5wdXNoKGNhbGxJbnB1dHMuc2xpY2UoMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gbmV3TmVzdGVkU3RhdGVzLnNsaWNlKCkucmV2ZXJzZSgpOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsU3RhdGVzID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoLmFwcGx5KHN0YXRlcywgY2VsbFN0YXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2NhbGxJbnB1dHNbMF1dLmNvbmNhdChzdGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0YWNrZWRSTk5DZWxscy5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpZiAoZ2VuZXJpY191dGlscy5pc0FycmF5T2ZTaGFwZXMoaW5wdXRTaGFwZSkpIHtcbiAgICAgICAgICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgb3V0cHV0RGltO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jZWxsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gX2FbX2ldO1xuICAgICAgICAgICAgY2VsbC5idWlsZChpbnB1dFNoYXBlKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNlbGwuc3RhdGVTaXplKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dERpbSA9IGNlbGwuc3RhdGVTaXplWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0RGltID0gY2VsbC5zdGF0ZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNoYXBlID0gW2lucHV0U2hhcGVbMF0sIG91dHB1dERpbV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgfTtcbiAgICBTdGFja2VkUk5OQ2VsbHMucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGxDb25maWdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNlbGxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBfYVtfaV07XG4gICAgICAgICAgICBjZWxsQ29uZmlncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAnY2xhc3NOYW1lJzogdGhpcy5nZXRDbGFzc05hbWUoKSxcbiAgICAgICAgICAgICAgICAnY29uZmlnJzogY2VsbC5nZXRDb25maWcoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25maWcgPSB7ICdjZWxscyc6IGNlbGxDb25maWdzIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgU3RhY2tlZFJOTkNlbGxzLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcsIGN1c3RvbU9iamVjdHMpIHtcbiAgICAgICAgaWYgKGN1c3RvbU9iamVjdHMgPT09IHZvaWQgMCkgeyBjdXN0b21PYmplY3RzID0ge307IH1cbiAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb25maWdbJ2NlbGxzJ107IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbENvbmZpZyA9IF9hW19pXTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goc2VyaWFsaXphdGlvbl8xLmRlc2VyaWFsaXplKGNlbGxDb25maWcsIGN1c3RvbU9iamVjdHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNscyh7IGNlbGxzOiBjZWxscyB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGFja2VkUk5OQ2VsbHMucHJvdG90eXBlLCBcInRyYWluYWJsZVdlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50cmFpbmFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd2VpZ2h0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2VsbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cy5wdXNoLmFwcGx5KHdlaWdodHMsIGNlbGwudHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YWNrZWRSTk5DZWxscy5wcm90b3R5cGUsIFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdlaWdodHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNlbGxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHdlaWdodHMucHVzaC5hcHBseSh3ZWlnaHRzLCBjZWxsLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGVXZWlnaHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuY2VsbHM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICB0cmFpbmFibGVXZWlnaHRzLnB1c2guYXBwbHkodHJhaW5hYmxlV2VpZ2h0cywgY2VsbC50cmFpbmFibGVXZWlnaHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWluYWJsZVdlaWdodHMuY29uY2F0KHdlaWdodHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdlaWdodHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0YWNrZWRSTk5DZWxscy5wcm90b3R5cGUuZ2V0V2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdlaWdodHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2VsbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IF9hW19pXTtcbiAgICAgICAgICAgIHdlaWdodHMucHVzaC5hcHBseSh3ZWlnaHRzLCBjZWxsLndlaWdodHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZXNfMS5iYXRjaEdldFZhbHVlKHdlaWdodHMpO1xuICAgIH07XG4gICAgU3RhY2tlZFJOTkNlbGxzLnByb3RvdHlwZS5zZXRXZWlnaHRzID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcbiAgICAgICAgdmFyIHR1cGxlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jZWxsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIG51bVBhcmFtcyA9IGNlbGwud2VpZ2h0cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaW5wdXRXZWlnaHRzID0gd2VpZ2h0cy5zcGxpY2UobnVtUGFyYW1zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2VsbC53ZWlnaHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdHVwbGVzLnB1c2goW2NlbGwud2VpZ2h0c1tpXSwgaW5wdXRXZWlnaHRzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyaWFibGVzXzEuYmF0Y2hTZXRWYWx1ZSh0dXBsZXMpO1xuICAgIH07XG4gICAgU3RhY2tlZFJOTkNlbGxzLmNsYXNzTmFtZSA9ICdTdGFja2VkUk5OQ2VsbHMnO1xuICAgIHJldHVybiBTdGFja2VkUk5OQ2VsbHM7XG59KFJOTkNlbGwpKTtcbmV4cG9ydHMuU3RhY2tlZFJOTkNlbGxzID0gU3RhY2tlZFJOTkNlbGxzO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFN0YWNrZWRSTk5DZWxscyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWN1cnJlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xuZnVuY3Rpb24gZGVzZXJpYWxpemUoY29uZmlnLCBjdXN0b21PYmplY3RzKSB7XG4gICAgaWYgKGN1c3RvbU9iamVjdHMgPT09IHZvaWQgMCkgeyBjdXN0b21PYmplY3RzID0ge307IH1cbiAgICByZXR1cm4gZ2VuZXJpY191dGlsc18xLmRlc2VyaWFsaXplS2VyYXNPYmplY3QoY29uZmlnLCB0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLCBjdXN0b21PYmplY3RzLCAnbGF5ZXInKTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6YXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgcmVjdXJyZW50XzEgPSByZXF1aXJlKFwiLi9yZWN1cnJlbnRcIik7XG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXphdGlvblwiKTtcbnZhciBXcmFwcGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV3JhcHBlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXcmFwcGVyKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxheWVyID0gY29uZmlnLmxheWVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdyYXBwZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlci5wcm90b3R5cGUsIFwidHJhaW5hYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXllciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIudHJhaW5hYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXIudHJhaW5hYmxlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVyLnByb3RvdHlwZSwgXCJ0cmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllci50cmFpbmFibGVXZWlnaHRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlci5wcm90b3R5cGUsIFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZXIucHJvdG90eXBlLCBcInVwZGF0ZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVyLl91cGRhdGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlci5wcm90b3R5cGUsIFwibG9zc2VzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllci5sb3NzZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFdyYXBwZXIucHJvdG90eXBlLmdldFdlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyLmdldFdlaWdodHMoKTtcbiAgICB9O1xuICAgIFdyYXBwZXIucHJvdG90eXBlLnNldFdlaWdodHMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xuICAgICAgICB0aGlzLmxheWVyLnNldFdlaWdodHMod2VpZ2h0cyk7XG4gICAgfTtcbiAgICBXcmFwcGVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICAnbGF5ZXInOiB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzTmFtZSc6IHRoaXMubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksXG4gICAgICAgICAgICAgICAgJ2NvbmZpZyc6IHRoaXMubGF5ZXIuZ2V0Q29uZmlnKCksXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgV3JhcHBlci5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnLCBjdXN0b21PYmplY3RzKSB7XG4gICAgICAgIGlmIChjdXN0b21PYmplY3RzID09PSB2b2lkIDApIHsgY3VzdG9tT2JqZWN0cyA9IHt9OyB9XG4gICAgICAgIHZhciBsYXllckNvbmZpZyA9IGNvbmZpZ1snbGF5ZXInXTtcbiAgICAgICAgdmFyIGxheWVyID0gc2VyaWFsaXphdGlvbl8xLmRlc2VyaWFsaXplKGxheWVyQ29uZmlnLCBjdXN0b21PYmplY3RzKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZ1snbGF5ZXInXTtcbiAgICAgICAgdmFyIG5ld0NvbmZpZyA9IHsgbGF5ZXI6IGxheWVyIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3Q29uZmlnLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IGNscyhuZXdDb25maWcpO1xuICAgIH07XG4gICAgcmV0dXJuIFdyYXBwZXI7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuV3JhcHBlciA9IFdyYXBwZXI7XG52YXIgVGltZURpc3RyaWJ1dGVkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZURpc3RyaWJ1dGVkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVEaXN0cmlidXRlZChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRpbWVEaXN0cmlidXRlZC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGltZURpc3RyaWJ1dGVkIGxheWVyIGV4cGVjdHMgYW4gaW5wdXQgc2hhcGUgPj0gM0QsIGJ1dCByZWNlaXZlZCBcIiArXG4gICAgICAgICAgICAgICAgKFwiaW5wdXQgc2hhcGUgXCIgKyBKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRTcGVjID0gW3sgc2hhcGU6IGlucHV0U2hhcGUgfV07XG4gICAgICAgIHZhciBjaGlsZElucHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXV0uY29uY2F0KGlucHV0U2hhcGUuc2xpY2UoMikpO1xuICAgICAgICBpZiAoIXRoaXMubGF5ZXIuYnVpbHQpIHtcbiAgICAgICAgICAgIHRoaXMubGF5ZXIuYnVpbGQoY2hpbGRJbnB1dFNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMubGF5ZXIuYnVpbHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYnVpbGQuY2FsbCh0aGlzLCBpbnB1dFNoYXBlKTtcbiAgICB9O1xuICAgIFRpbWVEaXN0cmlidXRlZC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgY2hpbGRJbnB1dFNoYXBlID0gW2lucHV0U2hhcGVbMF1dLmNvbmNhdChpbnB1dFNoYXBlLnNsaWNlKDIpKTtcbiAgICAgICAgdmFyIGNoaWxkT3V0cHV0U2hhcGUgPSB0aGlzLmxheWVyLmNvbXB1dGVPdXRwdXRTaGFwZShjaGlsZElucHV0U2hhcGUpO1xuICAgICAgICB2YXIgdGltZXN0ZXBzID0gaW5wdXRTaGFwZVsxXTtcbiAgICAgICAgcmV0dXJuIFtjaGlsZE91dHB1dFNoYXBlWzBdLCB0aW1lc3RlcHNdLmNvbmNhdChjaGlsZE91dHB1dFNoYXBlLnNsaWNlKDEpKTtcbiAgICB9O1xuICAgIFRpbWVEaXN0cmlidXRlZC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKGlucHV0cywgc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IF90aGlzLmxheWVyLmNhbGwoaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbb3V0cHV0LCBbXV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJubk91dHB1dHMgPSByZWN1cnJlbnRfMS5ybm4oc3RlcCwgaW5wdXRzLCBbXSwgZmFsc2UsIG51bGwsIG51bGwsIGZhbHNlLCBpbnB1dHMuc2hhcGVbMV0pO1xuICAgICAgICAgICAgdmFyIHkgPSBybm5PdXRwdXRzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGltZURpc3RyaWJ1dGVkLmNsYXNzTmFtZSA9ICdUaW1lRGlzdHJpYnV0ZWQnO1xuICAgIHJldHVybiBUaW1lRGlzdHJpYnV0ZWQ7XG59KFdyYXBwZXIpKTtcbmV4cG9ydHMuVGltZURpc3RyaWJ1dGVkID0gVGltZURpc3RyaWJ1dGVkO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFRpbWVEaXN0cmlidXRlZCk7XG5leHBvcnRzLlZBTElEX0JJRElSRUNUSU9OQUxfTUVSR0VfTU9ERVMgPSBbJ3N1bScsICdtdWwnLCAnY29uY2F0JywgJ2F2ZSddO1xuZnVuY3Rpb24gY2hlY2tCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlKHZhbHVlKSB7XG4gICAgZ2VuZXJpY191dGlscy5jaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKGV4cG9ydHMuVkFMSURfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFUywgJ0JpZGlyZWN0aW9uYWxNZXJnZU1vZGUnLCB2YWx1ZSk7XG59XG5leHBvcnRzLmNoZWNrQmlkaXJlY3Rpb25hbE1lcmdlTW9kZSA9IGNoZWNrQmlkaXJlY3Rpb25hbE1lcmdlTW9kZTtcbnZhciBCaWRpcmVjdGlvbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmlkaXJlY3Rpb25hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaWRpcmVjdGlvbmFsKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIHZhciBsYXllckNvbmZpZyA9IGNvbmZpZy5sYXllci5nZXRDb25maWcoKTtcbiAgICAgICAgX3RoaXMuZm9yd2FyZExheWVyID1cbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25fMS5kZXNlcmlhbGl6ZSh7IGNsYXNzTmFtZTogY29uZmlnLmxheWVyLmdldENsYXNzTmFtZSgpLCBjb25maWc6IGxheWVyQ29uZmlnIH0pO1xuICAgICAgICBsYXllckNvbmZpZ1snZ29CYWNrd2FyZHMnXSA9XG4gICAgICAgICAgICBsYXllckNvbmZpZ1snZ29CYWNrd2FyZHMnXSA9PT0gdHJ1ZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgX3RoaXMuYmFja3dhcmRMYXllciA9XG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uXzEuZGVzZXJpYWxpemUoeyBjbGFzc05hbWU6IGNvbmZpZy5sYXllci5nZXRDbGFzc05hbWUoKSwgY29uZmlnOiBsYXllckNvbmZpZyB9KTtcbiAgICAgICAgX3RoaXMuZm9yd2FyZExheWVyLm5hbWUgPSAnZm9yd2FyZF8nICsgX3RoaXMuZm9yd2FyZExheWVyLm5hbWU7XG4gICAgICAgIF90aGlzLmJhY2t3YXJkTGF5ZXIubmFtZSA9ICdiYWNrd2FyZF8nICsgX3RoaXMuYmFja3dhcmRMYXllci5uYW1lO1xuICAgICAgICBjaGVja0JpZGlyZWN0aW9uYWxNZXJnZU1vZGUoY29uZmlnLm1lcmdlTW9kZSk7XG4gICAgICAgIF90aGlzLm1lcmdlTW9kZSA9IGNvbmZpZy5tZXJnZU1vZGU7XG4gICAgICAgIGlmIChjb25maWcud2VpZ2h0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ3dlaWdodHMgc3VwcG9ydCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEJpZGlyZWN0aW9uYWwgbGF5ZXIgeWV0LicpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9zdGF0ZWZ1bCA9IGNvbmZpZy5sYXllci5zdGF0ZWZ1bDtcbiAgICAgICAgX3RoaXMucmV0dXJuU2VxdWVuY2VzID0gY29uZmlnLmxheWVyLnJldHVyblNlcXVlbmNlcztcbiAgICAgICAgX3RoaXMucmV0dXJuU3RhdGUgPSBjb25maWcubGF5ZXIucmV0dXJuU3RhdGU7XG4gICAgICAgIF90aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgICAgIF90aGlzLl90cmFpbmFibGUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBjb25maWcubGF5ZXIuaW5wdXRTcGVjO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCaWRpcmVjdGlvbmFsLnByb3RvdHlwZSwgXCJ0cmFpbmFibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFpbmFibGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFpbmFibGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcndhcmRMYXllciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGF5ZXIudHJhaW5hYmxlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5iYWNrd2FyZExheWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJpZGlyZWN0aW9uYWwucHJvdG90eXBlLmdldFdlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcndhcmRMYXllci5nZXRXZWlnaHRzKCkuY29uY2F0KHRoaXMuYmFja3dhcmRMYXllci5nZXRXZWlnaHRzKCkpO1xuICAgIH07XG4gICAgQmlkaXJlY3Rpb25hbC5wcm90b3R5cGUuc2V0V2VpZ2h0cyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XG4gICAgICAgIHZhciBudW1XZWlnaHRzID0gd2VpZ2h0cy5sZW5ndGg7XG4gICAgICAgIHZhciBudW1laWdodHNPdmVyMiA9IE1hdGguZmxvb3IobnVtV2VpZ2h0cyAvIDIpO1xuICAgICAgICB0aGlzLmZvcndhcmRMYXllci5zZXRXZWlnaHRzKHdlaWdodHMuc2xpY2UoMCwgbnVtZWlnaHRzT3ZlcjIpKTtcbiAgICAgICAgdGhpcy5iYWNrd2FyZExheWVyLnNldFdlaWdodHMod2VpZ2h0cy5zbGljZShudW1laWdodHNPdmVyMikpO1xuICAgIH07XG4gICAgQmlkaXJlY3Rpb25hbC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgdmFyIGxheWVyU2hhcGVzID0gdGhpcy5mb3J3YXJkTGF5ZXIuY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGxheWVyU2hhcGVzKSAmJiBBcnJheS5pc0FycmF5KGxheWVyU2hhcGVzWzBdKSkpIHtcbiAgICAgICAgICAgIGxheWVyU2hhcGVzID0gW2xheWVyU2hhcGVzXTtcbiAgICAgICAgfVxuICAgICAgICBsYXllclNoYXBlcyA9IGxheWVyU2hhcGVzO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGU7XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZXM7XG4gICAgICAgIHZhciBzdGF0ZVNoYXBlO1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5TdGF0ZSkge1xuICAgICAgICAgICAgc3RhdGVTaGFwZSA9IGxheWVyU2hhcGVzLnNsaWNlKDEpO1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSBsYXllclNoYXBlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlID0gbGF5ZXJTaGFwZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgaWYgKHRoaXMubWVyZ2VNb2RlID09PSAnY29uY2F0Jykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV0gKj0gMjtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlcyA9IFtvdXRwdXRTaGFwZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tZXJnZU1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVzID0gW291dHB1dFNoYXBlLCBvdXRwdXRTaGFwZS5zbGljZSgpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlcyA9IFtvdXRwdXRTaGFwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lcmdlTW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFNoYXBlcy5jb25jYXQoc3RhdGVTaGFwZSkuY29uY2F0KHN0YXRlU2hhcGUuc2xpY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW291dHB1dFNoYXBlXS5jb25jYXQoc3RhdGVTaGFwZSkuY29uY2F0KHN0YXRlU2hhcGUuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShvdXRwdXRTaGFwZXMpO1xuICAgIH07XG4gICAgQmlkaXJlY3Rpb25hbC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChrd2FyZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5pdGlhbFN0YXRlID0ga3dhcmdzWydpbml0aWFsU3RhdGUnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGUgPSBpbnB1dHMuc2xpY2UoMSk7XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PSBudWxsIHx8IGluaXRpYWxTdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciBhcHBseU91dHB1dHMgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcywgaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5T3V0cHV0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdUaGUgc3VwcG9ydCBmb3IgaW5pdGlhbCBzdGF0ZXMgaXMgbm90IGltcGxlbWVudGVkIGZvciAnICtcbiAgICAgICAgICAgICAgICAnQmlkaXJlY3Rpb25hbCBsYXllcnMgeWV0LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCaWRpcmVjdGlvbmFsLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChrd2FyZ3NbJ21hc2snXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ1RoZSBzdXBwb3J0IGZvciBtYXNraW5nIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICdCaWRpcmVjdGlvbmFsIGxheWVycyB5ZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa3dhcmdzWydpbml0aWFsU3RhdGUnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ1RoZSBzdXBwb3J0IGZvciBpbml0aWFsIHN0YXRlcyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAnQmlkaXJlY3Rpb25hbCBsYXllcnMgeWV0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHkgPSBfdGhpcy5mb3J3YXJkTGF5ZXIuY2FsbChpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgICAgICB2YXIgeVJldiA9IF90aGlzLmJhY2t3YXJkTGF5ZXIuY2FsbChpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgICAgICB2YXIgc3RhdGVzO1xuICAgICAgICAgICAgaWYgKF90aGlzLnJldHVyblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVzID0geS5zbGljZSgxKS5jb25jYXQoeVJldi5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5ID0geVswXTtcbiAgICAgICAgICAgICAgICB5UmV2ID0geVJldlswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXR1cm5TZXF1ZW5jZXMpIHtcbiAgICAgICAgICAgICAgICB5UmV2ID0gdGZjLnJldmVyc2UoeVJldiwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3V0cHV0O1xuICAgICAgICAgICAgaWYgKF90aGlzLm1lcmdlTW9kZSA9PT0gJ2NvbmNhdCcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBLLmNvbmNhdGVuYXRlKFt5LCB5UmV2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5tZXJnZU1vZGUgPT09ICdzdW0nKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGZjLmFkZCh5LCB5UmV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm1lcmdlTW9kZSA9PT0gJ2F2ZScpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBLLnNjYWxhclRpbWVzQXJyYXkoSy5nZXRTY2FsYXIoMC41KSwgdGZjLmFkZCh5LCB5UmV2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5tZXJnZU1vZGUgPT09ICdtdWwnKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGZjLm11bCh5LCB5UmV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm1lcmdlTW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gW3ksIHlSZXZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnJldHVyblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm1lcmdlTW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQuY29uY2F0KHN0YXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbb3V0cHV0XS5jb25jYXQoc3RhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmlkaXJlY3Rpb25hbC5wcm90b3R5cGUucmVzZXRTdGF0ZXMgPSBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZExheWVyLnJlc2V0U3RhdGVzKCk7XG4gICAgICAgIHRoaXMuYmFja3dhcmRMYXllci5yZXNldFN0YXRlcygpO1xuICAgIH07XG4gICAgQmlkaXJlY3Rpb25hbC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBLLm5hbWVTY29wZSh0aGlzLmZvcndhcmRMYXllci5uYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5mb3J3YXJkTGF5ZXIuYnVpbGQoaW5wdXRTaGFwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBLLm5hbWVTY29wZSh0aGlzLmJhY2t3YXJkTGF5ZXIubmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYmFja3dhcmRMYXllci5idWlsZChpbnB1dFNoYXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpZGlyZWN0aW9uYWwucHJvdG90eXBlLCBcInRyYWluYWJsZVdlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcndhcmRMYXllci50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCaWRpcmVjdGlvbmFsLnByb3RvdHlwZSwgXCJub25UcmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCaWRpcmVjdGlvbmFsLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICAnbWVyZ2VNb2RlJzogdGhpcy5tZXJnZU1vZGUsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgQmlkaXJlY3Rpb25hbC5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIHZhciBybm5MYXllciA9IHNlcmlhbGl6YXRpb25fMS5kZXNlcmlhbGl6ZShjb25maWdbJ2xheWVyJ10pO1xuICAgICAgICBkZWxldGUgY29uZmlnWydsYXllciddO1xuICAgICAgICBpZiAoY29uZmlnWydudW1Db25zdGFudHMnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcihcIkRlc2VyaWFsaXphdGlvbiBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgd2l0aCBudW1Db25zdGFudHMgXCIgK1xuICAgICAgICAgICAgICAgIFwicHJlc2VudCBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgbmV3Q29uZmlnWydsYXllciddID0gcm5uTGF5ZXI7XG4gICAgICAgIHJldHVybiBuZXcgY2xzKG5ld0NvbmZpZyk7XG4gICAgfTtcbiAgICBCaWRpcmVjdGlvbmFsLmNsYXNzTmFtZSA9ICdCaWRpcmVjdGlvbmFsJztcbiAgICByZXR1cm4gQmlkaXJlY3Rpb25hbDtcbn0oV3JhcHBlcikpO1xuZXhwb3J0cy5CaWRpcmVjdGlvbmFsID0gQmlkaXJlY3Rpb25hbDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihCaWRpcmVjdGlvbmFsKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBwZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIGwyTm9ybWFsaXplKHgsIGF4aXMpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzcXVhcmVTdW0gPSB0ZmMuc3VtKEsuc3F1YXJlKHgpLCBheGlzLCB0cnVlKTtcbiAgICAgICAgdmFyIGVwc2lsb25UZW5zb3IgPSBLLnNjYWxhclRpbWVzQXJyYXkodGZqc19jb3JlXzEuc2NhbGFyKEsuZXBzaWxvbigpKSwgdGZjLm9uZXNMaWtlKHgpKTtcbiAgICAgICAgdmFyIG5vcm0gPSB0ZmMuc3FydCh0ZmMubWF4aW11bShzcXVhcmVTdW0sIGVwc2lsb25UZW5zb3IpKTtcbiAgICAgICAgcmV0dXJuIHRmYy5kaXYoeCwgbm9ybSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmwyTm9ybWFsaXplID0gbDJOb3JtYWxpemU7XG5mdW5jdGlvbiBtZWFuU3F1YXJlZEVycm9yKHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmYy5tZWFuKEsuc3F1YXJlKHRmYy5zdWIoeVByZWQsIHlUcnVlKSksIC0xKTsgfSk7XG59XG5leHBvcnRzLm1lYW5TcXVhcmVkRXJyb3IgPSBtZWFuU3F1YXJlZEVycm9yO1xuZnVuY3Rpb24gbWVhbkFic29sdXRlRXJyb3IoeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZjLm1lYW4odGZjLmFicyh0ZmMuc3ViKHlQcmVkLCB5VHJ1ZSkpLCAtMSk7IH0pO1xufVxuZXhwb3J0cy5tZWFuQWJzb2x1dGVFcnJvciA9IG1lYW5BYnNvbHV0ZUVycm9yO1xuZnVuY3Rpb24gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpZmYgPSB0ZmMuc3ViKHlUcnVlLCB5UHJlZCk7XG4gICAgICAgIHZhciBjbGlwcGVkVHJ1ZSA9IHRmYy5jbGlwQnlWYWx1ZSh0ZmMuYWJzKHlUcnVlKSwgSy5lcHNpbG9uKCksIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICB2YXIgYWJzUmVzdWx0ID0gdGZjLmFicyh0ZmMuZGl2KGRpZmYsIGNsaXBwZWRUcnVlKSk7XG4gICAgICAgIHJldHVybiBLLnNjYWxhclRpbWVzQXJyYXkoSy5nZXRTY2FsYXIoMTAwLjApLCB0ZmMubWVhbihhYnNSZXN1bHQsIC0xKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvciA9IG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjtcbmZ1bmN0aW9uIG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcih5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvbmUgPSBLLmdldFNjYWxhcigxLjApO1xuICAgICAgICB2YXIgY2xpcHBlZFByZWQgPSB0ZmMuY2xpcEJ5VmFsdWUoeVByZWQsIEsuZXBzaWxvbigpLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgdmFyIGZpcnN0TG9nID0gdGZjLmxvZyhLLnNjYWxhclBsdXNBcnJheShvbmUsIGNsaXBwZWRQcmVkKSk7XG4gICAgICAgIHZhciBjbGlwcGVkVHJ1ZSA9IHRmYy5jbGlwQnlWYWx1ZSh5VHJ1ZSwgSy5lcHNpbG9uKCksIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICB2YXIgc2Vjb25kTG9nID0gdGZjLmxvZyhLLnNjYWxhclBsdXNBcnJheShvbmUsIGNsaXBwZWRUcnVlKSk7XG4gICAgICAgIHJldHVybiB0ZmMubWVhbihLLnNxdWFyZSh0ZmMuc3ViKGZpcnN0TG9nLCBzZWNvbmRMb2cpKSwgLTEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5tZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3IgPSBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3I7XG5mdW5jdGlvbiBzcXVhcmVkSGluZ2UoeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgemVyb1RlbnNvciA9IEsuZ2V0U2NhbGFyKDAuMCk7XG4gICAgICAgIHZhciBvbmUgPSBLLmdldFNjYWxhcigxLjApO1xuICAgICAgICB2YXIgbWF4UmVzdWx0ID0gdGZjLm1heGltdW0oemVyb1RlbnNvciwgdGZjLnN1YihvbmUsIHRmYy5tdWwoeVRydWUsIHlQcmVkKSkpO1xuICAgICAgICByZXR1cm4gdGZjLm1lYW4oSy5zcXVhcmUobWF4UmVzdWx0KSwgLTEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zcXVhcmVkSGluZ2UgPSBzcXVhcmVkSGluZ2U7XG5mdW5jdGlvbiBoaW5nZSh5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB6ZXJvVGVuc29yID0gSy5nZXRTY2FsYXIoMC4wKTtcbiAgICAgICAgdmFyIG9uZSA9IEsuZ2V0U2NhbGFyKDEuMCk7XG4gICAgICAgIHZhciBtYXhSZXN1bHQgPSB0ZmMubWF4aW11bSh6ZXJvVGVuc29yLCB0ZmMuc3ViKG9uZSwgdGZjLm11bCh5VHJ1ZSwgeVByZWQpKSk7XG4gICAgICAgIHJldHVybiB0ZmMubWVhbihtYXhSZXN1bHQsIC0xKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGluZ2UgPSBoaW5nZTtcbmZ1bmN0aW9uIGNhdGVnb3JpY2FsSGluZ2UoeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgemVyb1RlbnNvciA9IEsuZ2V0U2NhbGFyKDAuMCk7XG4gICAgICAgIHZhciBvbmUgPSBLLmdldFNjYWxhcigxLjApO1xuICAgICAgICB2YXIgcG9zID0gdGZjLnN1bSh0ZmMubXVsKHlUcnVlLCB5UHJlZCksIC0xKTtcbiAgICAgICAgdmFyIG5lZyA9IHRmYy5tYXgodGZjLm11bCh0ZmMuc3ViKG9uZSwgeVRydWUpLCB5UHJlZCksIC0xKTtcbiAgICAgICAgcmV0dXJuIHRmYy5tYXhpbXVtKHplcm9UZW5zb3IsIEsuc2NhbGFyUGx1c0FycmF5KG9uZSwgdGZjLnN1YihuZWcsIHBvcykpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY2F0ZWdvcmljYWxIaW5nZSA9IGNhdGVnb3JpY2FsSGluZ2U7XG5mdW5jdGlvbiBsb2djb3NoKHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvZzIgPSBLLmdldFNjYWxhcihNYXRoLmxvZygyLjApKTtcbiAgICAgICAgdmFyIHByZWRpY3Rpb25EaWZmID0gdGZjLnN1Yih5UHJlZCwgeVRydWUpO1xuICAgICAgICB2YXIgbG9nY29zaFJlc3VsdCA9IHRmYy5zdWIodGZjLmFkZChwcmVkaWN0aW9uRGlmZiwgdGZjLnNvZnRwbHVzKEsuc2NhbGFyVGltZXNBcnJheShLLmdldFNjYWxhcigtMi4wKSwgcHJlZGljdGlvbkRpZmYpKSksIGxvZzIpO1xuICAgICAgICByZXR1cm4gdGZjLm1lYW4obG9nY29zaFJlc3VsdCwgLTEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2djb3NoID0gbG9nY29zaDtcbmZ1bmN0aW9uIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KHRhcmdldCwgb3V0cHV0LCBmcm9tTG9naXRzKSB7XG4gICAgaWYgKGZyb21Mb2dpdHMgPT09IHZvaWQgMCkgeyBmcm9tTG9naXRzID0gZmFsc2U7IH1cbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmcm9tTG9naXRzKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSB0ZmMuc29mdG1heChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG91dHB1dFN1bSA9IHRmYy5zdW0ob3V0cHV0LCBLLnNoYXBlKG91dHB1dCkubGVuZ3RoIC0gMSwgdHJ1ZSk7XG4gICAgICAgICAgICBvdXRwdXQgPSB0ZmMuZGl2KG91dHB1dCwgb3V0cHV0U3VtKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSB0ZmMuY2xpcEJ5VmFsdWUob3V0cHV0LCBLLmVwc2lsb24oKSwgMSAtIEsuZXBzaWxvbigpKTtcbiAgICAgICAgcmV0dXJuIHRmYy5uZWcodGZjLnN1bSh0ZmMubXVsKHRhcmdldC50b0Zsb2F0KCksIHRmYy5sb2cob3V0cHV0KSksIEsuc2hhcGUob3V0cHV0KS5sZW5ndGggLSAxKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5ID0gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk7XG5mdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSh0YXJnZXQsIG91dHB1dCwgZnJvbUxvZ2l0cykge1xuICAgIGlmIChmcm9tTG9naXRzID09PSB2b2lkIDApIHsgZnJvbUxvZ2l0cyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmxhdFRhcmdldCA9IHRmYy5mbG9vcihLLmZsYXR0ZW4odGFyZ2V0KSkudG9JbnQoKTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gSy5zaGFwZShvdXRwdXQpO1xuICAgICAgICB2YXIgb25lSG90VGFyZ2V0ID0gdGZjLm9uZUhvdChmbGF0VGFyZ2V0LCBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXSlcbiAgICAgICAgICAgIC5yZXNoYXBlKG91dHB1dFNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KG9uZUhvdFRhcmdldCwgb3V0cHV0LCBmcm9tTG9naXRzKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkgPSBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTtcbmZ1bmN0aW9uIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKHRhcmdldCwgb3V0cHV0KSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4T3V0cHV0ID0gdGZjLm1heGltdW0ob3V0cHV0LCB0ZmMuemVyb3NMaWtlKG91dHB1dCkpO1xuICAgICAgICB2YXIgb3V0cHV0WFRhcmdldCA9IHRmYy5tdWwob3V0cHV0LCB0YXJnZXQpO1xuICAgICAgICB2YXIgc2lnbW9pZE91dHB1dCA9IHRmYy5sb2codGZjLmFkZChLLmdldFNjYWxhcigxKSwgdGZjLmV4cCh0ZmMubmVnKHRmYy5hYnMob3V0cHV0KSkpKSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0ZmMuYWRkKHRmYy5zdWIobWF4T3V0cHV0LCBvdXRwdXRYVGFyZ2V0KSwgc2lnbW9pZE91dHB1dCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5leHBvcnRzLnNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzID0gc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHM7XG5mdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkoeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgeSA9IHRmYy5jbGlwQnlWYWx1ZSh5UHJlZCwgSy5lcHNpbG9uKCksIDEgLSBLLmVwc2lsb24oKSk7XG4gICAgICAgIHkgPSB0ZmMubG9nKHRmYy5kaXYoeSwgdGZjLnN1Yih0ZmMub25lc0xpa2UoeSksIHkpKSk7XG4gICAgICAgIHJldHVybiB0ZmMubWVhbihzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0cyh5VHJ1ZSwgeSksIC0xKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYmluYXJ5Q3Jvc3NlbnRyb3B5ID0gYmluYXJ5Q3Jvc3NlbnRyb3B5O1xuZnVuY3Rpb24ga3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZSh5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbGlwcGVkVHJ1ZSA9IHRmYy5jbGlwQnlWYWx1ZSh5VHJ1ZSwgSy5lcHNpbG9uKCksIDEpO1xuICAgICAgICB2YXIgY2xpcHBlZFByZWQgPSB0ZmMuY2xpcEJ5VmFsdWUoeVByZWQsIEsuZXBzaWxvbigpLCAxKTtcbiAgICAgICAgcmV0dXJuIHRmYy5zdW0odGZjLm11bCh5VHJ1ZSwgdGZjLmxvZyh0ZmMuZGl2KGNsaXBwZWRUcnVlLCBjbGlwcGVkUHJlZCkpKSwgLTEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5rdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlID0ga3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZTtcbmZ1bmN0aW9uIHBvaXNzb24oeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nUHJlZCA9IHRmYy5sb2coSy5zY2FsYXJQbHVzQXJyYXkoSy5nZXRTY2FsYXIoSy5lcHNpbG9uKCkpLCB5UHJlZCkpO1xuICAgICAgICByZXR1cm4gdGZjLm1lYW4odGZjLnN1Yih5UHJlZCwgdGZjLm11bCh5VHJ1ZSwgbG9nUHJlZCkpLCAtMSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnBvaXNzb24gPSBwb2lzc29uO1xuZnVuY3Rpb24gY29zaW5lUHJveGltaXR5KHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRydWVOb3JtYWxpemVkID0gbDJOb3JtYWxpemUoeVRydWUsIC0xKTtcbiAgICAgICAgdmFyIHByZWROb3JtYWxpemVkID0gbDJOb3JtYWxpemUoeVByZWQsIC0xKTtcbiAgICAgICAgdmFyIHRydWVYUHJlZCA9IHRmYy5tdWwodHJ1ZU5vcm1hbGl6ZWQsIHByZWROb3JtYWxpemVkKTtcbiAgICAgICAgcmV0dXJuIHRmYy5uZWcodGZjLnN1bSh0cnVlWFByZWQsIC0xKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvc2luZVByb3hpbWl0eSA9IGNvc2luZVByb3hpbWl0eTtcbmV4cG9ydHMubXNlID0gbWVhblNxdWFyZWRFcnJvcjtcbmV4cG9ydHMuTVNFID0gbWVhblNxdWFyZWRFcnJvcjtcbmV4cG9ydHMubWFlID0gbWVhbkFic29sdXRlRXJyb3I7XG5leHBvcnRzLk1BRSA9IG1lYW5BYnNvbHV0ZUVycm9yO1xuZXhwb3J0cy5tYXBlID0gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yO1xuZXhwb3J0cy5NQVBFID0gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yO1xuZXhwb3J0cy5tc2xlID0gbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yO1xuZXhwb3J0cy5NU0xFID0gbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yO1xuZXhwb3J0cy5rbGQgPSBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlO1xuZXhwb3J0cy5LTEQgPSBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlO1xuZXhwb3J0cy5jb3NpbmUgPSBjb3NpbmVQcm94aW1pdHk7XG5mdW5jdGlvbiBnZXQoaWRlbnRpZmllck9yRm4pIHtcbiAgICB2YXIgbG9zc2VzTWFwID0ge1xuICAgICAgICBtZWFuU3F1YXJlZEVycm9yOiBtZWFuU3F1YXJlZEVycm9yLFxuICAgICAgICBtZWFuQWJzb2x1dGVFcnJvcjogbWVhbkFic29sdXRlRXJyb3IsXG4gICAgICAgIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjogbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yLFxuICAgICAgICBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3I6IG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcixcbiAgICAgICAgc3F1YXJlZEhpbmdlOiBzcXVhcmVkSGluZ2UsXG4gICAgICAgIGhpbmdlOiBoaW5nZSxcbiAgICAgICAgY2F0ZWdvcmljYWxIaW5nZTogY2F0ZWdvcmljYWxIaW5nZSxcbiAgICAgICAgbG9nY29zaDogbG9nY29zaCxcbiAgICAgICAgY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6IGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LFxuICAgICAgICBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTogc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHksXG4gICAgICAgIGJpbmFyeUNyb3NzZW50cm9weTogYmluYXJ5Q3Jvc3NlbnRyb3B5LFxuICAgICAgICBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlOiBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlLFxuICAgICAgICBwb2lzc29uOiBwb2lzc29uLFxuICAgICAgICBjb3NpbmVQcm94aW1pdHk6IGNvc2luZVByb3hpbWl0eVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyT3JGbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXJPckZuIGluIGxvc3Nlc01hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvc3Nlc01hcFtpZGVudGlmaWVyT3JGbl07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJVbmtub3duIGxvc3MgXCIgKyBpZGVudGlmaWVyT3JGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllck9yRm47XG4gICAgfVxufVxuZXhwb3J0cy5nZXQgPSBnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb3NzZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIGxvc3Nlc18xID0gcmVxdWlyZShcIi4vbG9zc2VzXCIpO1xudmFyIGxvc3Nlc18yID0gcmVxdWlyZShcIi4vbG9zc2VzXCIpO1xuZnVuY3Rpb24gYmluYXJ5QWNjdXJhY3koeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhyZXNob2xkID0gSy5zY2FsYXJUaW1lc0FycmF5KEsuZ2V0U2NhbGFyKDAuNSksIHRmYy5vbmVzTGlrZSh5UHJlZCkpO1xuICAgICAgICB2YXIgeVByZWRUaHJlc2hvbGRlZCA9IEsuY2FzdCh0ZmMuZ3JlYXRlcih5UHJlZCwgdGhyZXNob2xkKSwgeVRydWUuZHR5cGUpO1xuICAgICAgICByZXR1cm4gdGZjLm1lYW4odGZjLmVxdWFsKHlUcnVlLCB5UHJlZFRocmVzaG9sZGVkKSwgLTEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5iaW5hcnlBY2N1cmFjeSA9IGJpbmFyeUFjY3VyYWN5O1xuZnVuY3Rpb24gY2F0ZWdvcmljYWxBY2N1cmFjeSh5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBLLmNhc3QodGZjLmVxdWFsKHRmYy5hcmdNYXgoeVRydWUsIC0xKSwgdGZjLmFyZ01heCh5UHJlZCwgLTEpKSwgJ2Zsb2F0MzInKTsgfSk7XG59XG5leHBvcnRzLmNhdGVnb3JpY2FsQWNjdXJhY3kgPSBjYXRlZ29yaWNhbEFjY3VyYWN5O1xuZnVuY3Rpb24gYmluYXJ5Q3Jvc3NlbnRyb3B5KHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiBsb3NzZXNfMi5iaW5hcnlDcm9zc2VudHJvcHkoeVRydWUsIHlQcmVkKTtcbn1cbmV4cG9ydHMuYmluYXJ5Q3Jvc3NlbnRyb3B5ID0gYmluYXJ5Q3Jvc3NlbnRyb3B5O1xuZnVuY3Rpb24gc3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeSh5VHJ1ZSwgeVByZWQpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcigpO1xufVxuZXhwb3J0cy5zcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5ID0gc3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeTtcbmZ1bmN0aW9uIHRvcEtDYXRlZ29yaWNhbEFjY3VyYWN5KHlUcnVlLCB5UHJlZCkge1xuICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCk7XG59XG5leHBvcnRzLnRvcEtDYXRlZ29yaWNhbEFjY3VyYWN5ID0gdG9wS0NhdGVnb3JpY2FsQWNjdXJhY3k7XG5mdW5jdGlvbiBzcGFyc2VUb3BLQ2F0ZWdvcmljYWxBY2N1cmFjeSh5VHJ1ZSwgeVByZWQpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcigpO1xufVxuZXhwb3J0cy5zcGFyc2VUb3BLQ2F0ZWdvcmljYWxBY2N1cmFjeSA9IHNwYXJzZVRvcEtDYXRlZ29yaWNhbEFjY3VyYWN5O1xuZXhwb3J0cy5tc2UgPSBsb3NzZXNfMS5tZWFuU3F1YXJlZEVycm9yO1xuZXhwb3J0cy5NU0UgPSBsb3NzZXNfMS5tZWFuU3F1YXJlZEVycm9yO1xuZXhwb3J0cy5tYWUgPSBsb3NzZXNfMS5tZWFuQWJzb2x1dGVFcnJvcjtcbmV4cG9ydHMuTUFFID0gbG9zc2VzXzEubWVhbkFic29sdXRlRXJyb3I7XG5leHBvcnRzLm1hcGUgPSBsb3NzZXNfMS5tZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I7XG5leHBvcnRzLk1BUEUgPSBsb3NzZXNfMS5tZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I7XG5leHBvcnRzLmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5ID0gbG9zc2VzXzEuY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk7XG5leHBvcnRzLmNvc2luZSA9IGxvc3Nlc18xLmNvc2luZVByb3hpbWl0eTtcbmV4cG9ydHMuc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkgPSBsb3NzZXNfMS5zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTtcbmZ1bmN0aW9uIGdldChpZGVudGlmaWVyKSB7XG4gICAgdmFyIG1ldHJpY3NNYXAgPSB7XG4gICAgICAgIGJpbmFyeUFjY3VyYWN5OiBiaW5hcnlBY2N1cmFjeSxcbiAgICAgICAgY2F0ZWdvcmljYWxBY2N1cmFjeTogY2F0ZWdvcmljYWxBY2N1cmFjeSxcbiAgICAgICAgY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6IGV4cG9ydHMuY2F0ZWdvcmljYWxDcm9zc2VudHJvcHksXG4gICAgICAgIHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OiBleHBvcnRzLnNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LFxuICAgICAgICBtc2U6IGV4cG9ydHMubXNlLFxuICAgICAgICBNU0U6IGV4cG9ydHMuTVNFLFxuICAgICAgICBtYWU6IGV4cG9ydHMubWFlLFxuICAgICAgICBNQUU6IGV4cG9ydHMuTUFFLFxuICAgICAgICBtYXBlOiBleHBvcnRzLm1hcGUsXG4gICAgICAgIE1BUEU6IGV4cG9ydHMuTUFQRSxcbiAgICAgICAgY29zaW5lOiBleHBvcnRzLmNvc2luZSxcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycgJiYgaWRlbnRpZmllciBpbiBtZXRyaWNzTWFwKSB7XG4gICAgICAgIHJldHVybiBtZXRyaWNzTWFwW2lkZW50aWZpZXJdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaWRlbnRpZmllciAhPT0gJ3N0cmluZycgJiYgaWRlbnRpZmllciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJVbmtub3duIG1ldHJpYyBcIiArIGlkZW50aWZpZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIHRyYWluaW5nXzEgPSByZXF1aXJlKFwiLi9lbmdpbmUvdHJhaW5pbmdcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4vbGF5ZXJzL3NlcmlhbGl6YXRpb25cIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgc2VyaWFsaXphdGlvbl91dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvc2VyaWFsaXphdGlvbl91dGlsc1wiKTtcbmZ1bmN0aW9uIG1vZGVsRnJvbUpTT04obW9kZWxBbmRXZWlnaHRzQ29uZmlnLCBjdXN0b21PYmplY3RzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbW9kZWxUb3BvbG9neSwgdHNDb25maWcsIG1vZGVsLCB3ZWlnaHRWYWx1ZXMsIHVuaXF1ZVdlaWdodFZhbHVlcywgX2ksIF9hLCB3ZWlnaHQsIHNraXBNaXNtYXRjaGVzLCBpc05hbWVkVGVuc29yTWFwO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5ID0gbW9kZWxBbmRXZWlnaHRzQ29uZmlnLm1vZGVsVG9wb2xvZ3k7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFRvcG9sb2d5Wydtb2RlbF9jb25maWcnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5ID0gbW9kZWxUb3BvbG9neVsnbW9kZWxfY29uZmlnJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHNDb25maWcgPSBzZXJpYWxpemF0aW9uX3V0aWxzXzEuY29udmVydFB5dGhvbmljVG9Ucyhtb2RlbFRvcG9sb2d5KTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBzZXJpYWxpemF0aW9uXzEuZGVzZXJpYWxpemUodHNDb25maWcsIGN1c3RvbU9iamVjdHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlbEFuZFdlaWdodHNDb25maWcud2VpZ2h0c01hbmlmZXN0ICE9IG51bGwpKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRmanNfY29yZV8xLmlvLmxvYWRXZWlnaHRzKG1vZGVsQW5kV2VpZ2h0c0NvbmZpZy53ZWlnaHRzTWFuaWZlc3QsIG1vZGVsQW5kV2VpZ2h0c0NvbmZpZy5wYXRoUHJlZml4LCBtb2RlbC53ZWlnaHRzLm1hcChmdW5jdGlvbiAod2VpZ2h0KSB7IHJldHVybiB3ZWlnaHQub3JpZ2luYWxOYW1lOyB9KSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0VmFsdWVzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVXZWlnaHRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9hID0gbW9kZWwud2VpZ2h0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZVdlaWdodFZhbHVlc1t3ZWlnaHQub3JpZ2luYWxOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0VmFsdWVzW3dlaWdodC5vcmlnaW5hbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNraXBNaXNtYXRjaGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaXNOYW1lZFRlbnNvck1hcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmxvYWRXZWlnaHRzKHVuaXF1ZVdlaWdodFZhbHVlcywgc2tpcE1pc21hdGNoZXMsIGlzTmFtZWRUZW5zb3JNYXApO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIsIG1vZGVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLm1vZGVsRnJvbUpTT04gPSBtb2RlbEZyb21KU09OO1xuZnVuY3Rpb24gbG9hZE1vZGVsSW50ZXJuYWwocGF0aE9ySU9IYW5kbGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFuZGxlcnM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aE9ySU9IYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gdGZqc19jb3JlXzEuaW8uZ2V0TG9hZEhhbmRsZXJzKHBhdGhPcklPSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKHRmanNfY29yZV8xLmlvLmJyb3dzZXJIVFRQUmVxdWVzdChwYXRoT3JJT0hhbmRsZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkZvdW5kIG1vcmUgdGhhbiBvbmUgKFwiICsgaGFuZGxlcnMubGVuZ3RoICsgXCIpIGxvYWQgaGFuZGxlcnMgZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIlVSTCAnXCIgKyBwYXRoT3JJT0hhbmRsZXIgKyBcIidcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoT3JJT0hhbmRsZXIgPSBoYW5kbGVyc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbMiwgbG9hZE1vZGVsRnJvbUlPSGFuZGxlcihwYXRoT3JJT0hhbmRsZXIpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRNb2RlbEludGVybmFsID0gbG9hZE1vZGVsSW50ZXJuYWw7XG5mdW5jdGlvbiBsb2FkTW9kZWxGcm9tSU9IYW5kbGVyKGhhbmRsZXIsIGN1c3RvbU9iamVjdHMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnRpZmFjdHMsIG1vZGVsVG9wb2xvZ3ksIG1vZGVsLCBza2lwTWlzbWF0Y2gsIGlzTmFtZWRUZW5zb3JNYXA7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmxvYWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0Nhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RvZXMgbm90IGhhdmUgdGhlIGBsb2FkYCBtZXRob2QgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBoYW5kbGVyLmxvYWQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhcnRpZmFjdHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9wb2xvZ3kgPSBhcnRpZmFjdHMubW9kZWxUb3BvbG9neTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsVG9wb2xvZ3lbJ21vZGVsX2NvbmZpZyddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVG9wb2xvZ3kgPSBtb2RlbFRvcG9sb2d5Wydtb2RlbF9jb25maWcnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IHNlcmlhbGl6YXRpb25fMS5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uX3V0aWxzXzEuY29udmVydFB5dGhvbmljVG9Ucyhtb2RlbFRvcG9sb2d5KSwgY3VzdG9tT2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnRpZmFjdHMud2VpZ2h0RGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJ0aWZhY3RzLndlaWdodFNwZWNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignTW9kZWwgYXJ0aWZhY3RzIGNvbnRhaW5zIHdlaWdodCBkYXRhLCBidXQgbm90IHdlaWdodCBzcGVjcy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGVyZWZvcmUgbG9hZGluZyBvZiB3ZWlnaHRzIGNhbm5vdCBwcm9jZWVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcE1pc21hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc05hbWVkVGVuc29yTWFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmxvYWRXZWlnaHRzKHRmanNfY29yZV8xLmlvLmRlY29kZVdlaWdodHMoYXJ0aWZhY3RzLndlaWdodERhdGEsIGFydGlmYWN0cy53ZWlnaHRTcGVjcyksIHNraXBNaXNtYXRjaCwgaXNOYW1lZFRlbnNvck1hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBtb2RlbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkTW9kZWxGcm9tSU9IYW5kbGVyID0gbG9hZE1vZGVsRnJvbUlPSGFuZGxlcjtcbnZhciBTZXF1ZW50aWFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VxdWVudGlhbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXF1ZW50aWFsKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7IGlucHV0czogW10sIG91dHB1dHM6IFtdIH0pIHx8IHRoaXM7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgX3RoaXMudHJhaW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX3VwZGF0YWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzLmJ1aWx0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm5hbWUgPSAoY29uZmlnLm5hbWUgIT0gbnVsbCkgPyBjb25maWcubmFtZSA6IEsuZ2V0VWlkKCdzZXF1ZW50aWFsXycpO1xuICAgICAgICBpZiAoY29uZmlnLmxheWVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29uZmlnLmxheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkKGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlcXVlbnRpYWxfMSA9IFNlcXVlbnRpYWw7XG4gICAgU2VxdWVudGlhbC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHZhciBpc0xheWVyTW9kZWxJbnN0YW5jZSA9IGxheWVyIGluc3RhbmNlb2YgU2VxdWVudGlhbF8xIHx8IGxheWVyIGluc3RhbmNlb2YgdHJhaW5pbmdfMS5Nb2RlbDtcbiAgICAgICAgdmFyIG1vZGVsTGF5ZXI7XG4gICAgICAgIGlmIChpc0xheWVyTW9kZWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgbW9kZWxMYXllciA9IGxheWVyO1xuICAgICAgICAgICAgaWYgKG1vZGVsTGF5ZXIub3V0cHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICdzaG91bGQgaGF2ZSBhIHNpbmdsZSBvdXRwdXQgdGVuc29yLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ0ZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSB0aGUgZnVuY3Rpb25hbCBBUEkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZWxMYXllci5pbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0FsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsICcgK1xuICAgICAgICAgICAgICAgICAgICAnc2hvdWxkIGhhdmUgYSBzaW5nbGUgaW5wdXQgdGVuc29yLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ0ZvciBtdWx0aS1pbnB1dCBsYXllcnMsICcgK1xuICAgICAgICAgICAgICAgICAgICAndXNlIHRoZSBmdW5jdGlvbmFsIEFQSS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRwdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGxheWVyLmluYm91bmROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuYmF0Y2hJbnB1dFNoYXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1RoZSBmaXJzdCBsYXllciBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgbXVzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXQgYW4gYGlucHV0U2hhcGVgIG9yIGBiYXRjaElucHV0U2hhcGVgIGFyZ3VtZW50LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRvcG9sb2d5XzEuSW5wdXQoe1xuICAgICAgICAgICAgICAgICAgICBiYXRjaFNoYXBlOiBsYXllci5iYXRjaElucHV0U2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIGR0eXBlOiBsYXllci5kdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbGF5ZXIubmFtZSArICdfaW5wdXQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGF5ZXIuYXBwbHkoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMYXllck1vZGVsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dHMgPSBtb2RlbExheWVyLm91dHB1dHM7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSBtb2RlbExheWVyLmlucHV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdBIGxheWVyIGFkZGVkIHRvIGEgU2VxdWVudGlhbCBtb2RlbCBtdXN0IG5vdCBhbHJlYWR5IGJlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiY29ubmVjdGVkIHNvbWV3aGVyZSBlbHNlLiBNb2RlbCByZWNlaXZlZCBsYXllciBcIiArIGxheWVyLm5hbWUgKyBcIiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwid2hpY2ggaGFzIFwiICsgbGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCArIFwiIHByZS1leGlzdGluZyBpbmJvdW5kIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29ubmVjdGlvbnMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0FsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dHMgPSBbbGF5ZXIuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF1dO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzID0gdG9wb2xvZ3lfMS5nZXRTb3VyY2VJbnB1dHModGhpcy5vdXRwdXRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldyB0b3BvbG9neV8xLk5vZGUoe1xuICAgICAgICAgICAgICAgIG91dGJvdW5kTGF5ZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5ib3VuZExheWVyczogW10sXG4gICAgICAgICAgICAgICAgbm9kZUluZGljZXM6IFtdLFxuICAgICAgICAgICAgICAgIHRlbnNvckluZGljZXM6IFtdLFxuICAgICAgICAgICAgICAgIGlucHV0VGVuc29yczogdGhpcy5pbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0VGVuc29yczogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIGlucHV0TWFza3M6IGdlbmVyaWNfdXRpbHMucHlMaXN0UmVwZWF0KG51bGwsIHRoaXMuaW5wdXRzLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgb3V0cHV0TWFza3M6IFtudWxsXSxcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlczogdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNoYXBlOyB9KSxcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZXM6IHRoaXMub3V0cHV0c1swXS5zaGFwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0VGVuc29yID0gbGF5ZXIuYXBwbHkodGhpcy5vdXRwdXRzWzBdKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dFRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuICcgK1xuICAgICAgICAgICAgICAgICAgICAnRm9yIG11bHRpLW91dHB1dCBsYXllcnMsICcgK1xuICAgICAgICAgICAgICAgICAgICAndXNlIHRoZSBmdW5jdGlvbmFsIEFQSS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3V0cHV0cyA9IFtvdXRwdXRUZW5zb3JdO1xuICAgICAgICAgICAgdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycyA9IHRoaXMub3V0cHV0cztcbiAgICAgICAgICAgIHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcyA9IFt0aGlzLm91dHB1dHNbMF0uc2hhcGVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICB0aGlzLmJ1aWx0ID0gZmFsc2U7XG4gICAgfTtcbiAgICBTZXF1ZW50aWFsLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZXJlIGFyZSBubyBsYXllcnMgaW4gdGhlIG1vZGVsLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5ZXJzLnBvcCgpO1xuICAgICAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5ib3VuZE5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLm91dGJvdW5kTm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsYXN0TGF5ZXJJbmRleCA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB0aGlzLmxheWVyc1tsYXN0TGF5ZXJJbmRleF0ub3V0Ym91bmROb2RlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRzID0gW3RoaXMubGF5ZXJzW2xhc3RMYXllckluZGV4XS5vdXRwdXRdO1xuICAgICAgICAgICAgdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycyA9IHRoaXMub3V0cHV0cztcbiAgICAgICAgICAgIHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcyA9IFt0aGlzLm91dHB1dHNbMF0uc2hhcGVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXF1ZW50aWFsLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jYWxsKGlucHV0cywga3dhcmdzKTtcbiAgICB9O1xuICAgIFNlcXVlbnRpYWwucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIGlmICh0aGlzLmlucHV0cy5sZW5ndGggPT09IDAgfHwgdGhpcy5vdXRwdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2VxdWVudGlhbCBtb2RlbCBjYW5ub3QgYmUgYnVpbHQ6IG1vZGVsIGlzIGVtcHR5LicgK1xuICAgICAgICAgICAgICAgICcgQWRkIHNvbWUgbGF5ZXJzIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBuZXcgdHJhaW5pbmdfMS5Nb2RlbCh7XG4gICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzWzBdLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lICsgJ19tb2RlbCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwudHJhaW5hYmxlID0gdGhpcy50cmFpbmFibGU7XG4gICAgICAgIHRoaXMubW9kZWwudXBkYXRhYmxlID0gdGhpcy51cGRhdGFibGU7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNNYXNraW5nID0gdGhpcy5tb2RlbC5zdXBwb3J0c01hc2tpbmc7XG4gICAgICAgIHRoaXMuaW5wdXRMYXllcnMgPSB0aGlzLm1vZGVsLmlucHV0TGF5ZXJzO1xuICAgICAgICB0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXMgPSB0aGlzLm1vZGVsLmlucHV0TGF5ZXJzTm9kZUluZGljZXM7XG4gICAgICAgIHRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzID0gdGhpcy5tb2RlbC5pbnB1dExheWVyc1RlbnNvckluZGljZXM7XG4gICAgICAgIHRoaXMub3V0cHV0TGF5ZXJzID0gdGhpcy5tb2RlbC5vdXRwdXRMYXllcnM7XG4gICAgICAgIHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMgPSB0aGlzLm1vZGVsLm91dHB1dExheWVyc05vZGVJbmRpY2VzO1xuICAgICAgICB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXMgPSB0aGlzLm1vZGVsLm91dHB1dExheWVyc1RlbnNvckluZGljZXM7XG4gICAgICAgIHRoaXMubm9kZXNCeURlcHRoID0gdGhpcy5tb2RlbC5ub2Rlc0J5RGVwdGg7XG4gICAgICAgIHRoaXMuY29udGFpbmVyTm9kZXMgPSB0aGlzLm1vZGVsLmNvbnRhaW5lck5vZGVzO1xuICAgICAgICB0aGlzLm91dHB1dE5hbWVzID0gdGhpcy5tb2RlbC5vdXRwdXROYW1lcztcbiAgICAgICAgdGhpcy5pbnB1dE5hbWVzID0gdGhpcy5tb2RlbC5pbnB1dE5hbWVzO1xuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNlcXVlbnRpYWwucHJvdG90eXBlLnNldFdlaWdodHMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xuICAgICAgICBpZiAodGhpcy5tb2RlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5zZXRXZWlnaHRzKHdlaWdodHMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcXVlbnRpYWwucHJvdG90eXBlLCBcInVwZGF0YWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0YWJsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC51cGRhdGFibGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0YWJsZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTZXF1ZW50aWFsLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh4LCB5LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIGlmICghdGhpcy5idWlsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJ1bnRpbWVFcnJvcignVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmV2YWx1YXRlKHgsIHksIGNvbmZpZyk7XG4gICAgfTtcbiAgICBTZXF1ZW50aWFsLnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24gKHgsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgaWYgKHRoaXMubW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnByZWRpY3QoeCwgY29uZmlnKTtcbiAgICB9O1xuICAgIFNlcXVlbnRpYWwucHJvdG90eXBlLnByZWRpY3RPbkJhdGNoID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnByZWRpY3RPbkJhdGNoKHgpO1xuICAgIH07XG4gICAgU2VxdWVudGlhbC5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgICAgICB0aGlzLm1vZGVsLmNvbXBpbGUoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpbWl6ZXIgPSB0aGlzLm1vZGVsLm9wdGltaXplcjtcbiAgICAgICAgdGhpcy5sb3NzID0gdGhpcy5tb2RlbC5sb3NzO1xuICAgICAgICB0aGlzLm1ldHJpY3MgPSB0aGlzLm1vZGVsLm1ldHJpY3M7XG4gICAgICAgIHRoaXMubWV0cmljc1RlbnNvcnMgPSB0aGlzLm1vZGVsLm1ldHJpY3NUZW5zb3JzO1xuICAgICAgICB0aGlzLm1ldHJpY3NOYW1lcyA9IHRoaXMubW9kZWwubWV0cmljc05hbWVzO1xuICAgIH07XG4gICAgU2VxdWVudGlhbC5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKHgsIHksIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5idWlsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUnVudGltZUVycm9yKCdUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JlaW5nIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5tb2RlbC5maXQoeCwgeSwgY29uZmlnKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXF1ZW50aWFsLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IGNscyh7fSk7XG4gICAgICAgIGlmICghKG1vZGVsIGluc3RhbmNlb2YgU2VxdWVudGlhbF8xKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJTZXF1ZW50aWFsLmZyb21Db25maWcgY2FsbGVkIG9uIG5vbi1TZXF1ZW50aWFsIGlucHV0OiBcIiArIG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjb25maWcgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiU2VxdWVudGlhbC5mcm9tQ29uZmlnIGNhbGxlZCB3aXRob3V0IGFuIGFycmF5IG9mIGNvbmZpZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY29uZmlnWzBdLmNsYXNzTmFtZSAhPSBudWxsKSB8fCBjb25maWdbMF1bJ2NsYXNzTmFtZSddID09PSAnTWVyZ2UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignTGVnYWN5IHNlcmlhbGl6YXRpb24gZm9ybWF0IG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb25maWc7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29uZiA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHNlcmlhbGl6YXRpb25fMS5kZXNlcmlhbGl6ZShjb25mKTtcbiAgICAgICAgICAgIG1vZGVsLmFkZChsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH07XG4gICAgU2VxdWVudGlhbC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmxheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgIGNvbmZpZy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGxheWVyLmdldENsYXNzTmFtZSgpLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogbGF5ZXIuZ2V0Q29uZmlnKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgU2VxdWVudGlhbC5jbGFzc05hbWUgPSAnU2VxdWVudGlhbCc7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBTZXF1ZW50aWFsLnByb3RvdHlwZSwgXCJhZGRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGNvbmZpZ1BhcmFtSW5kaWNlczogWzJdIH0pXG4gICAgXSwgU2VxdWVudGlhbC5wcm90b3R5cGUsIFwiZXZhbHVhdGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGNvbmZpZ1BhcmFtSW5kaWNlczogWzFdIH0pXG4gICAgXSwgU2VxdWVudGlhbC5wcm90b3R5cGUsIFwicHJlZGljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgY29uZmlnUGFyYW1JbmRpY2VzOiBbMl0gfSlcbiAgICBdLCBTZXF1ZW50aWFsLnByb3RvdHlwZSwgXCJmaXRcIiwgbnVsbCk7XG4gICAgU2VxdWVudGlhbCA9IFNlcXVlbnRpYWxfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgU2VxdWVudGlhbCk7XG4gICAgcmV0dXJuIFNlcXVlbnRpYWw7XG4gICAgdmFyIFNlcXVlbnRpYWxfMTtcbn0odHJhaW5pbmdfMS5Nb2RlbCkpO1xuZXhwb3J0cy5TZXF1ZW50aWFsID0gU2VxdWVudGlhbDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihTZXF1ZW50aWFsKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuZnVuY3Rpb24gZ2V0T3B0aW1pemVyKGlkZW50aWZpZXIpIHtcbiAgICB2YXIgb3B0aW1pemVyTWFwID0ge1xuICAgICAgICAnQWRhZ3JhZCc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmanNfY29yZV8xLnRyYWluLmFkYWdyYWQoLjAxKTsgfSxcbiAgICAgICAgJ0FkYW0nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZmpzX2NvcmVfMS50cmFpbi5hZGFtKC4wMDEsIC45LCAuOTk5LCBLLmVwc2lsb24oKSk7IH0sXG4gICAgICAgICdSTVNQcm9wJzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZqc19jb3JlXzEudHJhaW4ucm1zcHJvcCguMDAxLCAuOSwgbnVsbCwgSy5lcHNpbG9uKCkpOyB9LFxuICAgICAgICAnU0dEJzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZqc19jb3JlXzEudHJhaW4uc2dkKC4wMSk7IH1cbiAgICB9O1xuICAgIG9wdGltaXplck1hcFsnYWRhZ3JhZCddID0gb3B0aW1pemVyTWFwWydBZGFncmFkJ107XG4gICAgb3B0aW1pemVyTWFwWydhZGFtJ10gPSBvcHRpbWl6ZXJNYXBbJ0FkYW0nXTtcbiAgICBvcHRpbWl6ZXJNYXBbJ3Jtc3Byb3AnXSA9IG9wdGltaXplck1hcFsnUk1TUHJvcCddO1xuICAgIG9wdGltaXplck1hcFsnc2dkJ10gPSBvcHRpbWl6ZXJNYXBbJ1NHRCddO1xuICAgIGlmIChpZGVudGlmaWVyIGluIG9wdGltaXplck1hcCkge1xuICAgICAgICByZXR1cm4gb3B0aW1pemVyTWFwW2lkZW50aWZpZXJdKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVW5rbm93biBPcHRpbWl6ZXIgXCIgKyBpZGVudGlmaWVyKTtcbn1cbmV4cG9ydHMuZ2V0T3B0aW1pemVyID0gZ2V0T3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW1pemVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBSZWd1bGFyaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZ3VsYXJpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZ3VsYXJpemVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWd1bGFyaXplcjtcbn0odGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpKTtcbmV4cG9ydHMuUmVndWxhcml6ZXIgPSBSZWd1bGFyaXplcjtcbnZhciBMMUwyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTDFMMiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMMUwyKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgbDEgPSBjb25maWcgPT0gbnVsbCB8fCBjb25maWcubDEgPT0gbnVsbCA/IDAuMDEgOiBjb25maWcubDE7XG4gICAgICAgIHZhciBsMiA9IGNvbmZpZyA9PSBudWxsIHx8IGNvbmZpZy5sMiA9PSBudWxsID8gMC4wMSA6IGNvbmZpZy5sMjtcbiAgICAgICAgX3RoaXMuaGFzTDEgPSBsMSAhPT0gMDtcbiAgICAgICAgX3RoaXMuaGFzTDIgPSBsMiAhPT0gMDtcbiAgICAgICAgX3RoaXMubDEgPSBLLmdldFNjYWxhcihsMSk7XG4gICAgICAgIF90aGlzLmwyID0gSy5nZXRTY2FsYXIobDIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEwxTDIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlZ3VsYXJpemF0aW9uID0gdGZqc19jb3JlXzEuemVyb3MoWzFdKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5oYXNMMSkge1xuICAgICAgICAgICAgICAgIHJlZ3VsYXJpemF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdGZqc19jb3JlXzEuYWRkKHJlZ3VsYXJpemF0aW9uLCB0ZmpzX2NvcmVfMS5zdW0oSy5zY2FsYXJUaW1lc0FycmF5KF90aGlzLmwxLCB0ZmpzX2NvcmVfMS5hYnMoeCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuaGFzTDIpIHtcbiAgICAgICAgICAgICAgICByZWd1bGFyaXphdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIHRmanNfY29yZV8xLmFkZChyZWd1bGFyaXphdGlvbiwgdGZqc19jb3JlXzEuc3VtKEsuc2NhbGFyVGltZXNBcnJheShfdGhpcy5sMiwgSy5zcXVhcmUoeCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVndWxhcml6YXRpb24uYXNTY2FsYXIoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMMUwyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7ICdsMSc6IHRoaXMubDEuZGF0YVN5bmMoKVswXSwgJ2wyJzogdGhpcy5sMi5kYXRhU3luYygpWzBdIH07XG4gICAgfTtcbiAgICBMMUwyLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbHMoeyBsMTogY29uZmlnLmwxLCBsMjogY29uZmlnLmwyIH0pO1xuICAgIH07XG4gICAgTDFMMi5jbGFzc05hbWUgPSAnTDFMMic7XG4gICAgTDFMMiA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnUmVndWxhcml6ZXJzJywgbmFtZXNwYWNlOiAncmVndWxhcml6ZXJzJyB9KVxuICAgIF0sIEwxTDIpO1xuICAgIHJldHVybiBMMUwyO1xufShSZWd1bGFyaXplcikpO1xuZXhwb3J0cy5MMUwyID0gTDFMMjtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihMMUwyKTtcbmZ1bmN0aW9uIGwxKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgTDFMMih7IGwxOiBjb25maWcgIT0gbnVsbCA/IGNvbmZpZy5sMSA6IG51bGwsIGwyOiAwIH0pO1xufVxuZXhwb3J0cy5sMSA9IGwxO1xuZnVuY3Rpb24gbDIoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBMMUwyKHsgbDI6IGNvbmZpZyAhPSBudWxsID8gY29uZmlnLmwyIDogbnVsbCwgbDE6IDAgfSk7XG59XG5leHBvcnRzLmwyID0gbDI7XG5leHBvcnRzLlJFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUCA9IHtcbiAgICAnbDFsMic6ICdMMUwyJ1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZVJlZ3VsYXJpemVyKGNvbnN0cmFpbnQpIHtcbiAgICByZXR1cm4gZ2VuZXJpY191dGlsc18xLnNlcmlhbGl6ZUtlcmFzT2JqZWN0KGNvbnN0cmFpbnQpO1xufVxuZXhwb3J0cy5zZXJpYWxpemVSZWd1bGFyaXplciA9IHNlcmlhbGl6ZVJlZ3VsYXJpemVyO1xuZnVuY3Rpb24gZGVzZXJpYWxpemVSZWd1bGFyaXplcihjb25maWcsIGN1c3RvbU9iamVjdHMpIHtcbiAgICBpZiAoY3VzdG9tT2JqZWN0cyA9PT0gdm9pZCAwKSB7IGN1c3RvbU9iamVjdHMgPSB7fTsgfVxuICAgIHJldHVybiBnZW5lcmljX3V0aWxzXzEuZGVzZXJpYWxpemVLZXJhc09iamVjdChjb25maWcsIHRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsIGN1c3RvbU9iamVjdHMsICdyZWd1bGFyaXplcicpO1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZVJlZ3VsYXJpemVyID0gZGVzZXJpYWxpemVSZWd1bGFyaXplcjtcbmZ1bmN0aW9uIGdldFJlZ3VsYXJpemVyKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoaWRlbnRpZmllciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBpZGVudGlmaWVyIGluIGV4cG9ydHMuUkVHVUxBUklaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQID9cbiAgICAgICAgICAgIGV4cG9ydHMuUkVHVUxBUklaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQW2lkZW50aWZpZXJdIDpcbiAgICAgICAgICAgIGlkZW50aWZpZXI7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBjb25maWc6IHt9IH07XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKGNvbmZpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlkZW50aWZpZXIgaW5zdGFuY2VvZiBSZWd1bGFyaXplcikge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKGlkZW50aWZpZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0UmVndWxhcml6ZXIgPSBnZXRSZWd1bGFyaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ3VsYXJpemVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG52YXIgX25leHRVbmlxdWVUZW5zb3JJZCA9IDA7XG5mdW5jdGlvbiBnZXROZXh0VW5pcXVlVGVuc29ySWQoKSB7XG4gICAgcmV0dXJuIF9uZXh0VW5pcXVlVGVuc29ySWQrKztcbn1cbmV4cG9ydHMuZ2V0TmV4dFVuaXF1ZVRlbnNvcklkID0gZ2V0TmV4dFVuaXF1ZVRlbnNvcklkO1xudmFyIFN5bWJvbGljVGVuc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTeW1ib2xpY1RlbnNvcihkdHlwZSwgc2hhcGUsIHNvdXJjZUxheWVyLCBpbnB1dHMsIGNhbGxBcmdzLCBuYW1lLCBvdXRwdXRUZW5zb3JJbmRleCkge1xuICAgICAgICB0aGlzLmR0eXBlID0gZHR5cGU7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdGhpcy5zb3VyY2VMYXllciA9IHNvdXJjZUxheWVyO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5jYWxsQXJncyA9IGNhbGxBcmdzO1xuICAgICAgICB0aGlzLm91dHB1dFRlbnNvckluZGV4ID0gb3V0cHV0VGVuc29ySW5kZXg7XG4gICAgICAgIHRoaXMuaWQgPSBnZXROZXh0VW5pcXVlVGVuc29ySWQoKTtcbiAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbE5hbWUgPSBjb21tb25fMS5nZXRTY29wZWRUZW5zb3JOYW1lKG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gY29tbW9uXzEuZ2V0VW5pcXVlVGVuc29yTmFtZSh0aGlzLm9yaWdpbmFsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIH1cbiAgICBTeW1ib2xpY1RlbnNvciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgJ3N1YmhlYWRpbmcnOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBTeW1ib2xpY1RlbnNvcik7XG4gICAgcmV0dXJuIFN5bWJvbGljVGVuc29yO1xufSgpKTtcbmV4cG9ydHMuU3ltYm9saWNUZW5zb3IgPSBTeW1ib2xpY1RlbnNvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9nZW5lcmljX3V0aWxzXCIpO1xudmFyIG1hdGhfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL21hdGhfdXRpbHNcIik7XG5mdW5jdGlvbiBub3JtYWxpemVBcnJheSh2YWx1ZSwgbiwgbmFtZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmljX3V0aWxzXzEucHlMaXN0UmVwZWF0KHZhbHVlLCBuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIFwiICsgbmFtZSArIFwiIGFyZ3VtZW50IG11c3QgYmUgYSB0dXBsZSBvZiBcIiArIG4gKyBcIiBpbnRlZ2Vycy4gUmVjZWl2ZWQ6IFwiICtcbiAgICAgICAgICAgICAgICAodmFsdWUubGVuZ3RoICsgXCIgZWxlbWVudHMuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIHNpbmdsZVZhbHVlID0gdmFsdWVbaV07XG4gICAgICAgICAgICBpZiAoIW1hdGhfdXRpbHNfMS5pc0ludGVnZXIoc2luZ2xlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgXCIgKyBuYW1lICsgXCIgYXJndW1lbnQgbXVzdCBiZSBhIHR1cGxlIG9mIFwiICsgbiArIFwiIGludGVnZXJzLiBSZWNlaXZlZDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAoSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgXCIgaW5jbHVkaW5nIGEgbm9uLWludGVnZXIgbnVtYmVyIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgc2luZ2xlVmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5ub3JtYWxpemVBcnJheSA9IG5vcm1hbGl6ZUFycmF5O1xuZnVuY3Rpb24gY29udk91dHB1dExlbmd0aChpbnB1dExlbmd0aCwgZmlsdGVyU2l6ZSwgcGFkZGluZywgc3RyaWRlLCBkaWxhdGlvbikge1xuICAgIGlmIChkaWxhdGlvbiA9PT0gdm9pZCAwKSB7IGRpbGF0aW9uID0gMTsgfVxuICAgIGlmIChpbnB1dExlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpbnB1dExlbmd0aDtcbiAgICB9XG4gICAgdmFyIGRpbGF0ZWRGaWx0ZXJTaXplID0gZmlsdGVyU2l6ZSArIChmaWx0ZXJTaXplIC0gMSkgKiAoZGlsYXRpb24gLSAxKTtcbiAgICB2YXIgb3V0cHV0TGVuZ3RoO1xuICAgIGlmIChwYWRkaW5nID09PSAnc2FtZScpIHtcbiAgICAgICAgb3V0cHV0TGVuZ3RoID0gaW5wdXRMZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXRMZW5ndGggPSBpbnB1dExlbmd0aCAtIGRpbGF0ZWRGaWx0ZXJTaXplICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKG91dHB1dExlbmd0aCArIHN0cmlkZSAtIDEpIC8gc3RyaWRlKTtcbn1cbmV4cG9ydHMuY29udk91dHB1dExlbmd0aCA9IGNvbnZPdXRwdXRMZW5ndGg7XG5mdW5jdGlvbiBkZWNvbnZMZW5ndGgoZGltU2l6ZSwgc3RyaWRlU2l6ZSwga2VybmVsU2l6ZSwgcGFkZGluZykge1xuICAgIGlmIChkaW1TaXplID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwYWRkaW5nID09PSAndmFsaWQnKSB7XG4gICAgICAgIGRpbVNpemUgPSBkaW1TaXplICogc3RyaWRlU2l6ZSArIG1hdGhfdXRpbHNfMS5tYXgoW2tlcm5lbFNpemUgLSBzdHJpZGVTaXplLCAwXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhZGRpbmcgPT09ICdzYW1lJykge1xuICAgICAgICBkaW1TaXplID0gZGltU2l6ZSAqIHN0cmlkZVNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlVuc3VwcG9ydCBwYWRkaW5nIG1vZGU6IFwiICsgcGFkZGluZyArIFwiLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbVNpemU7XG59XG5leHBvcnRzLmRlY29udkxlbmd0aCA9IGRlY29udkxlbmd0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBweUxpc3RSZXBlYXQodmFsdWUsIG51bVZhbHVlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YXIgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgbmV3QXJyYXkgPSBuZXdBcnJheS5jb25jYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShudW1WYWx1ZXMpO1xuICAgICAgICBuZXdBcnJheS5maWxsKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgIH1cbn1cbmV4cG9ydHMucHlMaXN0UmVwZWF0ID0gcHlMaXN0UmVwZWF0O1xuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbWVzc2FnZSkge1xuICAgIGlmICghdmFsKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmZ1bmN0aW9uIGNvdW50KGFycmF5LCByZWZlcm5jZSkge1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFycmF5XzEgPSBhcnJheTsgX2kgPCBhcnJheV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFycmF5XzFbX2ldO1xuICAgICAgICBpZiAoaXRlbSA9PT0gcmVmZXJuY2UpIHtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRlcjtcbn1cbmV4cG9ydHMuY291bnQgPSBjb3VudDtcbmZ1bmN0aW9uIHNpbmdsZXRvbk9yQXJyYXkoeHMpIHtcbiAgICBpZiAoeHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB4c1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHhzO1xufVxuZXhwb3J0cy5zaW5nbGV0b25PckFycmF5ID0gc2luZ2xldG9uT3JBcnJheTtcbmZ1bmN0aW9uIHRvTGlzdCh4KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIHJldHVybiBbeF07XG59XG5leHBvcnRzLnRvTGlzdCA9IHRvTGlzdDtcbmZ1bmN0aW9uIG9iamVjdExpc3RVaWQob2Jqcykge1xuICAgIHZhciBvYmplY3RMaXN0ID0gdG9MaXN0KG9ianMpO1xuICAgIHZhciByZXRWYWwgPSAnJztcbiAgICBmb3IgKHZhciBfaSA9IDAsIG9iamVjdExpc3RfMSA9IG9iamVjdExpc3Q7IF9pIDwgb2JqZWN0TGlzdF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgb2JqID0gb2JqZWN0TGlzdF8xW19pXTtcbiAgICAgICAgaWYgKG9iai5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIk9iamVjdCBcIiArIG9iaiArIFwiIHBhc3NlZCB0byBvYmplY3RMaXN0VWlkIHdpdGhvdXQgYW4gaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldFZhbCAhPT0gJycpIHtcbiAgICAgICAgICAgIHJldFZhbCA9IHJldFZhbCArICcsICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0VmFsID0gcmV0VmFsICsgTWF0aC5hYnMob2JqLmlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldFZhbDtcbn1cbmV4cG9ydHMub2JqZWN0TGlzdFVpZCA9IG9iamVjdExpc3RVaWQ7XG5mdW5jdGlvbiBpc0FycmF5T2ZTaGFwZXMoeCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpICYmIEFycmF5LmlzQXJyYXkoeFswXSk7XG59XG5leHBvcnRzLmlzQXJyYXlPZlNoYXBlcyA9IGlzQXJyYXlPZlNoYXBlcztcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNoYXBlTGlzdCh4KSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHhbMF0pKSB7XG4gICAgICAgIHJldHVybiBbeF07XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxuZXhwb3J0cy5ub3JtYWxpemVTaGFwZUxpc3QgPSBub3JtYWxpemVTaGFwZUxpc3Q7XG5mdW5jdGlvbiB0b1NuYWtlQ2FzZShuYW1lKSB7XG4gICAgdmFyIGludGVybWVkaWF0ZSA9IG5hbWUucmVwbGFjZSgvKC4pKFtBLVpdW2EtejAtOV0rKS9nLCAnJDFfJDInKTtcbiAgICB2YXIgaW5zZWN1cmUgPSBpbnRlcm1lZGlhdGUucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxXyQyJykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaW5zZWN1cmVbMF0gIT09ICdfJykge1xuICAgICAgICByZXR1cm4gaW5zZWN1cmU7XG4gICAgfVxuICAgIHJldHVybiAncHJpdmF0ZScgKyBpbnNlY3VyZTtcbn1cbmV4cG9ydHMudG9TbmFrZUNhc2UgPSB0b1NuYWtlQ2FzZTtcbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoaWRlbnRpZmllci5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignXycpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXIucmVwbGFjZSgvW19dKyhcXHd8JCkvZywgZnVuY3Rpb24gKG0sIHAxKSB7IHJldHVybiBwMS50b1VwcGVyQ2FzZSgpOyB9KTtcbn1cbmV4cG9ydHMudG9DYW1lbENhc2UgPSB0b0NhbWVsQ2FzZTtcbnZhciBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTID0ge307XG5mdW5jdGlvbiBzZXJpYWxpemVLZXJhc09iamVjdChpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCB8fCBpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBjbGFzc05hbWU6IGluc3RhbmNlLmdldENsYXNzTmFtZSgpLCBjb25maWc6IGluc3RhbmNlLmdldENvbmZpZygpIH07XG59XG5leHBvcnRzLnNlcmlhbGl6ZUtlcmFzT2JqZWN0ID0gc2VyaWFsaXplS2VyYXNPYmplY3Q7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGlkZW50aWZpZXIsIG1vZHVsZU9iamVjdHMsIGN1c3RvbU9iamVjdHMsIHByaW50YWJsZU1vZHVsZU5hbWUpIHtcbiAgICBpZiAobW9kdWxlT2JqZWN0cyA9PT0gdm9pZCAwKSB7IG1vZHVsZU9iamVjdHMgPSB7fTsgfVxuICAgIGlmIChjdXN0b21PYmplY3RzID09PSB2b2lkIDApIHsgY3VzdG9tT2JqZWN0cyA9IHt9OyB9XG4gICAgaWYgKHByaW50YWJsZU1vZHVsZU5hbWUgPT09IHZvaWQgMCkgeyBwcmludGFibGVNb2R1bGVOYW1lID0gJ29iamVjdCc7IH1cbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBpZGVudGlmaWVyO1xuICAgICAgICB2YXIgZm4gPSB2b2lkIDA7XG4gICAgICAgIGlmIChmdW5jdGlvbk5hbWUgaW4gY3VzdG9tT2JqZWN0cykge1xuICAgICAgICAgICAgZm4gPSBjdXN0b21PYmplY3RzW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25OYW1lIGluIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpIHtcbiAgICAgICAgICAgIGZuID0gX0dMT0JBTF9DVVNUT01fT0JKRUNUU1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm4gPSBtb2R1bGVPYmplY3RzW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgICAgICBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVW5rbm93biBcIiArIHByaW50YWJsZU1vZHVsZU5hbWUgKyBcIjogXCIgKyBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY29uZmlnID0gaWRlbnRpZmllcjtcbiAgICAgICAgaWYgKGNvbmZpZy5jbGFzc05hbWUgPT0gbnVsbCB8fCBjb25maWcuY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKHByaW50YWJsZU1vZHVsZU5hbWUgKyBcIjogSW1wcm9wZXIgY29uZmlnIGZvcm1hdDogXCIgK1xuICAgICAgICAgICAgICAgIChKU09OLnN0cmluZ2lmeShjb25maWcpICsgXCIuXFxuXCIpICtcbiAgICAgICAgICAgICAgICBcIidjbGFzc05hbWUnIGFuZCAnY29uZmlnJyBtdXN0IHNldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNvbmZpZy5jbGFzc05hbWU7XG4gICAgICAgIHZhciBjbHMgPSB2b2lkIDAsIGZyb21Db25maWcgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjbGFzc05hbWUgaW4gY3VzdG9tT2JqZWN0cykge1xuICAgICAgICAgICAgX2EgPSBjdXN0b21PYmplY3RzLmdldChjbGFzc05hbWUpLCBjbHMgPSBfYVswXSwgZnJvbUNvbmZpZyA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSBpbiBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKSB7XG4gICAgICAgICAgICBfYiA9IF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMuY2xhc3NOYW1lLCBjbHMgPSBfYlswXSwgZnJvbUNvbmZpZyA9IF9iWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSBpbiBtb2R1bGVPYmplY3RzKSB7XG4gICAgICAgICAgICBfYyA9IG1vZHVsZU9iamVjdHNbY2xhc3NOYW1lXSwgY2xzID0gX2NbMF0sIGZyb21Db25maWcgPSBfY1sxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVW5rbm93biBcIiArIHByaW50YWJsZU1vZHVsZU5hbWUgKyBcIjogXCIgKyBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21PYmplY3RzQ29tYmluZWQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2QgPSBPYmplY3Qua2V5cyhfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKTsgX2kgPCBfZC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2RbX2ldO1xuICAgICAgICAgICAgICAgIGN1c3RvbU9iamVjdHNDb21iaW5lZFtrZXldID0gX0dMT0JBTF9DVVNUT01fT0JKRUNUU1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2UgPSAwLCBfZiA9IE9iamVjdC5rZXlzKGN1c3RvbU9iamVjdHMpOyBfZSA8IF9mLmxlbmd0aDsgX2UrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfZltfZV07XG4gICAgICAgICAgICAgICAgY3VzdG9tT2JqZWN0c0NvbWJpbmVkW2tleV0gPSBjdXN0b21PYmplY3RzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmVzdGVkQ29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICAgICAgICAgIG5lc3RlZENvbmZpZy5jdXN0b21PYmplY3RzID0gY3VzdG9tT2JqZWN0c0NvbWJpbmVkO1xuICAgICAgICAgICAgdmFyIGJhY2t1cEN1c3RvbU9iamVjdHMgPSBfX2Fzc2lnbih7fSwgX0dMT0JBTF9DVVNUT01fT0JKRUNUUyk7XG4gICAgICAgICAgICBmb3IgKHZhciBfZyA9IDAsIF9oID0gT2JqZWN0LmtleXMoY3VzdG9tT2JqZWN0cyk7IF9nIDwgX2gubGVuZ3RoOyBfZysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9oW19nXTtcbiAgICAgICAgICAgICAgICBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW2tleV0gPSBjdXN0b21PYmplY3RzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmV0dXJuT2JqID0gZnJvbUNvbmZpZyhjbHMsIGNvbmZpZy5jb25maWcpO1xuICAgICAgICAgICAgX0dMT0JBTF9DVVNUT01fT0JKRUNUUyA9IF9fYXNzaWduKHt9LCBiYWNrdXBDdXN0b21PYmplY3RzKTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmFja3VwQ3VzdG9tT2JqZWN0cyA9IF9fYXNzaWduKHt9LCBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMCwgX2sgPSBPYmplY3Qua2V5cyhjdXN0b21PYmplY3RzKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2tbX2pdO1xuICAgICAgICAgICAgICAgIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFNba2V5XSA9IGN1c3RvbU9iamVjdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXR1cm5PYmogPSBuZXcgY2xzKGNvbmZpZy5jb25maWcpO1xuICAgICAgICAgICAgX0dMT0JBTF9DVVNUT01fT0JKRUNUUyA9IF9fYXNzaWduKHt9LCBiYWNrdXBDdXN0b21PYmplY3RzKTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9hLCBfYiwgX2M7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplS2VyYXNPYmplY3QgPSBkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0O1xuZnVuY3Rpb24gZ2V0RXhhY3RseU9uZVRlbnNvcih4cykge1xuICAgIHZhciB4O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHhzKSkge1xuICAgICAgICBpZiAoeHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkV4cGVjdGVkIFRlbnNvciBsZW5ndGggdG8gYmUgMTsgZ290IFwiICsgeHMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB4ID0geHNbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB4ID0geHM7XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxuZXhwb3J0cy5nZXRFeGFjdGx5T25lVGVuc29yID0gZ2V0RXhhY3RseU9uZVRlbnNvcjtcbmZ1bmN0aW9uIGdldEV4YWN0bHlPbmVTaGFwZShzaGFwZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzaGFwZXMpICYmIEFycmF5LmlzQXJyYXkoc2hhcGVzWzBdKSkge1xuICAgICAgICBpZiAoc2hhcGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgc2hhcGVzID0gc2hhcGVzO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRXhwZWN0ZWQgZXhhY3RseSAxIFNoYXBlOyBnb3QgXCIgKyBzaGFwZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNoYXBlcztcbiAgICB9XG59XG5leHBvcnRzLmdldEV4YWN0bHlPbmVTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZTtcbmZ1bmN0aW9uIG51bWJlckNvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiAoYSA8IGIpID8gLTEgOiAoKGEgPiBiKSA/IDEgOiAwKTtcbn1cbmV4cG9ydHMubnVtYmVyQ29tcGFyZSA9IG51bWJlckNvbXBhcmU7XG5mdW5jdGlvbiByZXZlcnNlTnVtYmVyQ29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIC0xICogbnVtYmVyQ29tcGFyZShhLCBiKTtcbn1cbmV4cG9ydHMucmV2ZXJzZU51bWJlckNvbXBhcmUgPSByZXZlcnNlTnVtYmVyQ29tcGFyZTtcbmZ1bmN0aW9uIHN0cmluZ1RvRFR5cGUoZHR5cGUpIHtcbiAgICBzd2l0Y2ggKGR0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICAgICAgcmV0dXJuICdmbG9hdDMyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW52YWxpZCBkdHlwZTogXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5zdHJpbmdUb0RUeXBlID0gc3RyaW5nVG9EVHlwZTtcbmZ1bmN0aW9uIHN0cmluZ3NFcXVhbCh4cywgeXMpIHtcbiAgICBpZiAoeHMgPT0gbnVsbCB8fCB5cyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB4cyA9PT0geXM7XG4gICAgfVxuICAgIGlmICh4cy5sZW5ndGggIT09IHlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHhzW2ldICE9PSB5c1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5zdHJpbmdzRXF1YWwgPSBzdHJpbmdzRXF1YWw7XG5mdW5jdGlvbiB1bmlxdWUoeHMpIHtcbiAgICBpZiAoeHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geHM7XG4gICAgfVxuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHhzXzEgPSB4czsgX2kgPCB4c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgeCA9IHhzXzFbX2ldO1xuICAgICAgICBpZiAob3V0LmluZGV4T2YoeCkgPT09IC0xKSB7XG4gICAgICAgICAgICBvdXQucHVzaCh4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkludmFsaWQgdmFsdWUgaW4gb2JqOiBcIiArIEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc09iamVjdEVtcHR5ID0gaXNPYmplY3RFbXB0eTtcbmZ1bmN0aW9uIGNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUodmFsdWVzLCBsYWJlbCwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGEgdmFsaWQgXCIgKyBsYWJlbCArIFwiLiAgVmFsaWQgdmFsdWVzIGFyZSBcIiArIHZhbHVlcyArIFwiIG9yIG51bGwvdW5kZWZpbmVkLlwiKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUgPSBjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJpY191dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBpc0ludGVnZXIoeCkge1xuICAgIHJldHVybiB4ID09PSBwYXJzZUludCh4LnRvU3RyaW5nKCksIDEwKTtcbn1cbmV4cG9ydHMuaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuZnVuY3Rpb24gYXJyYXlQcm9kKGFycmF5LCBiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGJlZ2luID09IG51bGwpIHtcbiAgICAgICAgYmVnaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgcHJvZCA9IDE7XG4gICAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgcHJvZCAqPSBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Q7XG59XG5leHBvcnRzLmFycmF5UHJvZCA9IGFycmF5UHJvZDtcbmZ1bmN0aW9uIHRvQXJyYXkxRChhcnJheSkge1xuICAgIGFycmF5ID0gQXJyYXkuaXNBcnJheShhcnJheSkgPyBuZXcgRmxvYXQzMkFycmF5KGFycmF5KSA6IGFycmF5O1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50ZW5zb3IxZChhcnJheSk7XG59XG5mdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICByZXR1cm4gdGZjLm1pbih0b0FycmF5MUQoYXJyYXkpKS5kYXRhU3luYygpWzBdO1xufVxuZXhwb3J0cy5taW4gPSBtaW47XG5mdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICByZXR1cm4gdGZjLm1heCh0b0FycmF5MUQoYXJyYXkpKS5kYXRhU3luYygpWzBdO1xufVxuZXhwb3J0cy5tYXggPSBtYXg7XG5mdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICByZXR1cm4gdGZjLnN1bSh0b0FycmF5MUQoYXJyYXkpKS5kYXRhU3luYygpWzBdO1xufVxuZXhwb3J0cy5zdW0gPSBzdW07XG5mdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgcmV0dXJuIHN1bShhcnJheSkgLyBhcnJheS5sZW5ndGg7XG59XG5leHBvcnRzLm1lYW4gPSBtZWFuO1xuZnVuY3Rpb24gdmFyaWFuY2UoYXJyYXkpIHtcbiAgICB2YXIgZGVtZWFuZWQgPSB0ZmMuc3ViKHRvQXJyYXkxRChhcnJheSksIHRmanNfY29yZV8xLnNjYWxhcihtZWFuKGFycmF5KSkpO1xuICAgIHZhciBzdW1TcXVhcmUgPSB0ZmMuc3VtKHRmYy5tdWxTdHJpY3QoZGVtZWFuZWQsIGRlbWVhbmVkKSkuZGF0YVN5bmMoKVswXTtcbiAgICByZXR1cm4gc3VtU3F1YXJlIC8gYXJyYXkubGVuZ3RoO1xufVxuZXhwb3J0cy52YXJpYW5jZSA9IHZhcmlhbmNlO1xuZnVuY3Rpb24gbWVkaWFuKGFycmF5KSB7XG4gICAgdmFyIGFycmF5U29ydGVkID0gYXJyYXkuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgdmFyIGxvd0lkeCA9IE1hdGguZmxvb3IoKGFycmF5U29ydGVkLmxlbmd0aCAtIDEpIC8gMik7XG4gICAgdmFyIGhpZ2hJZHggPSBNYXRoLmNlaWwoKGFycmF5U29ydGVkLmxlbmd0aCAtIDEpIC8gMik7XG4gICAgaWYgKGxvd0lkeCA9PT0gaGlnaElkeCkge1xuICAgICAgICByZXR1cm4gYXJyYXlTb3J0ZWRbbG93SWR4XTtcbiAgICB9XG4gICAgcmV0dXJuIChhcnJheVNvcnRlZFtsb3dJZHhdICsgYXJyYXlTb3J0ZWRbaGlnaElkeF0pIC8gMjtcbn1cbmV4cG9ydHMubWVkaWFuID0gbWVkaWFuO1xuZnVuY3Rpb24gcmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPCBiZWdpbikge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcImVuZCAoXCIgKyBlbmQgKyBcIikgPCBiZWdpbiAoXCIgKyBiZWdpbiArIFwiKSBpcyBmb3JiaWRkZW4uXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgb3V0LnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnJhbmdlID0gcmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoX3V0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdlbmVyaWNfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbmZ1bmN0aW9uIGlzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUoa2V5LCBpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gKGtleSA9PT0gJ2luYm91bmROb2RlcycgfHwga2V5ID09PSAnb3V0cHV0TGF5ZXJzJyB8fFxuICAgICAgICBrZXkgPT09ICdpbnB1dExheWVycycpICYmXG4gICAgICAgIGluZGV4ID09PSAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBjb252ZXJ0UHl0aG9uaWNUb1RzKHB5dGhvbmljQ29uZmlnLCBrZXkpIHtcbiAgICBpZiAocHl0aG9uaWNDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBweXRob25pY0NvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMudG9DYW1lbENhc2UocHl0aG9uaWNDb25maWcpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZW9mIHB5dGhvbmljQ29uZmlnID09PSAnbnVtYmVyJykgfHxcbiAgICAgICAgKHR5cGVvZiBweXRob25pY0NvbmZpZyA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICByZXR1cm4gcHl0aG9uaWNDb25maWc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHB5dGhvbmljQ29uZmlnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFyIHRzQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGFycmF5TGVuZ3RoID0gcHl0aG9uaWNDb25maWcubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5TGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gcHl0aG9uaWNDb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZShrZXksIGksIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdHNBcnJheS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHNBcnJheS5wdXNoKGNvbnZlcnRQeXRob25pY1RvVHMoaXRlbSwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzQXJyYXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdHNEaWN0ID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhweXRob25pY0NvbmZpZyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHl0aG9uaWNLZXkgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgcHl0aG9uaWNWYWx1ZSA9IHB5dGhvbmljQ29uZmlnW3B5dGhvbmljS2V5XTtcbiAgICAgICAgICAgIGlmIChweXRob25pY0tleSA9PT0gJ25hbWUnICYmIHR5cGVvZiBweXRob25pY1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRzRGljdFtweXRob25pY0tleV0gPSBweXRob25pY1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRzS2V5ID0gZ2VuZXJpY191dGlscy50b0NhbWVsQ2FzZShweXRob25pY0tleSk7XG4gICAgICAgICAgICAgICAgdHNEaWN0W3RzS2V5XSA9IGNvbnZlcnRQeXRob25pY1RvVHMocHl0aG9uaWNWYWx1ZSwgdHNLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0c0RpY3Q7XG4gICAgfVxufVxuZXhwb3J0cy5jb252ZXJ0UHl0aG9uaWNUb1RzID0gY29udmVydFB5dGhvbmljVG9UcztcbmZ1bmN0aW9uIGNvbnZlcnRUc1RvUHl0aG9uaWModHNDb25maWcsIGtleSkge1xuICAgIGlmICh0c0NvbmZpZyA9PT0gbnVsbCB8fCB0c0NvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdHNDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmljX3V0aWxzLnRvU25ha2VDYXNlKHRzQ29uZmlnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGVvZiB0c0NvbmZpZyA9PT0gJ251bWJlcicpIHx8ICh0eXBlb2YgdHNDb25maWcgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgcmV0dXJuIHRzQ29uZmlnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0c0NvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhciBweUFycmF5ID0gW107XG4gICAgICAgIHZhciBhcnJheUxlbmd0aCA9IHRzQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRzQ29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUoa2V5LCBpLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgIHB5QXJyYXkucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB5QXJyYXkucHVzaChjb252ZXJ0VHNUb1B5dGhvbmljKGl0ZW0sIGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBweUFycmF5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHB5RGljdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXModHNDb25maWcpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHRzS2V5ID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHRzVmFsdWUgPSB0c0NvbmZpZ1t0c0tleV07XG4gICAgICAgICAgICB2YXIgcHlLZXkgPSBnZW5lcmljX3V0aWxzLnRvU25ha2VDYXNlKHRzS2V5KTtcbiAgICAgICAgICAgIGlmICgodHNLZXkgPT09ICduYW1lJyB8fCB0c0tleSA9PT0gJ2NsYXNzTmFtZScpICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRzVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHlEaWN0W3B5S2V5XSA9IHRzVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBweURpY3RbcHlLZXldID0gY29udmVydFRzVG9QeXRob25pYyh0c1ZhbHVlLCB0c0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB5RGljdDtcbiAgICB9XG59XG5leHBvcnRzLmNvbnZlcnRUc1RvUHl0aG9uaWMgPSBjb252ZXJ0VHNUb1B5dGhvbmljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXphdGlvbl91dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfYmFja2VuZF8xID0gcmVxdWlyZShcIi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIERFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVggPSAnVmFyaWFibGUnO1xudmFyIExheWVyVmFyaWFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExheWVyVmFyaWFibGUodmFsLCBkdHlwZSwgbmFtZSwgdHJhaW5hYmxlLCBjb25zdHJhaW50KSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IERFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVg7IH1cbiAgICAgICAgaWYgKHRyYWluYWJsZSA9PT0gdm9pZCAwKSB7IHRyYWluYWJsZSA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT09IHZvaWQgMCkgeyBjb25zdHJhaW50ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLmR0eXBlID0gZHR5cGUgPT0gbnVsbCA/ICdmbG9hdDMyJyA6IGR0eXBlO1xuICAgICAgICB0aGlzLnNoYXBlID0gdmFsLnNoYXBlO1xuICAgICAgICB0aGlzLmlkID0gdHlwZXNfMS5nZXROZXh0VW5pcXVlVGVuc29ySWQoKTtcbiAgICAgICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IERFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVggOiBuYW1lO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTmFtZSA9IGNvbW1vbl8xLmdldFNjb3BlZFRlbnNvck5hbWUobmFtZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGNvbW1vbl8xLmdldFVuaXF1ZVRlbnNvck5hbWUodGhpcy5vcmlnaW5hbE5hbWUpO1xuICAgICAgICB0aGlzLnRyYWluYWJsZSA9IHRyYWluYWJsZTtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50ID0gY29uc3RyYWludDtcbiAgICAgICAgdGhpcy52YWwgPSB0ZmMudmFyaWFibGUodmFsLCB0aGlzLnRyYWluYWJsZSwgdGhpcy5uYW1lLCB0aGlzLmR0eXBlKTtcbiAgICB9XG4gICAgTGF5ZXJWYXJpYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsO1xuICAgIH07XG4gICAgTGF5ZXJWYXJpYWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobmV3VmFsKSB7XG4gICAgICAgIGNoZWNrU2hhcGVzTWF0Y2godGhpcy52YWwsIG5ld1ZhbCk7XG4gICAgICAgIHRoaXMudmFsLmFzc2lnbihuZXdWYWwpO1xuICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmFsLmFzc2lnbih0aGlzLmNvbnN0cmFpbnQuYXBwbHkodGhpcy52YWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBMYXllclZhcmlhYmxlO1xufSgpKTtcbmV4cG9ydHMuTGF5ZXJWYXJpYWJsZSA9IExheWVyVmFyaWFibGU7XG5mdW5jdGlvbiBjaGVja1NoYXBlc01hdGNoKHgsIHkpIHtcbiAgICBpZiAoeC5zaGFwZS50b1N0cmluZygpICE9PSB5LnNoYXBlLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZSBtaXNtYXRjaDogJyArIEpTT04uc3RyaW5naWZ5KHguc2hhcGUpICsgJyB2cy4gJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh5LnNoYXBlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFyaWFibGUoeCwgZHR5cGUsIG5hbWUsIGNvbnN0cmFpbnQpIHtcbiAgICByZXR1cm4gbmV3IExheWVyVmFyaWFibGUoeCwgZHR5cGUsIG5hbWUsIHRydWUsIGNvbnN0cmFpbnQpO1xufVxuZXhwb3J0cy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuZnVuY3Rpb24gemVyb3NWYXJpYWJsZShzaGFwZSwgZHR5cGUsIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IExheWVyVmFyaWFibGUodGZjLnplcm9zKHNoYXBlKSwgZHR5cGUsIG5hbWUpO1xufVxuZXhwb3J0cy56ZXJvc1ZhcmlhYmxlID0gemVyb3NWYXJpYWJsZTtcbmZ1bmN0aW9uIHplcm9zTGlrZSh4LCBkdHlwZSwgbmFtZSkge1xuICAgIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZSh0ZmMuemVyb3NMaWtlKHgpLCBkdHlwZSwgbmFtZSk7XG59XG5leHBvcnRzLnplcm9zTGlrZSA9IHplcm9zTGlrZTtcbmZ1bmN0aW9uIG9uZXNWYXJpYWJsZShzaGFwZSwgZHR5cGUsIG5hbWUpIHtcbiAgICB2YXIgYWxsb2NhdGVkID0gdGZjLm9uZXMoc2hhcGUpO1xuICAgIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZShhbGxvY2F0ZWQsIGR0eXBlLCBuYW1lKTtcbn1cbmV4cG9ydHMub25lc1ZhcmlhYmxlID0gb25lc1ZhcmlhYmxlO1xuZnVuY3Rpb24gb25lc0xpa2UoeCwgZHR5cGUsIG5hbWUpIHtcbiAgICB2YXIgYWxsb2NhdGVkID0gdGZjLm9uZXNMaWtlKHgpO1xuICAgIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZShhbGxvY2F0ZWQsIGR0eXBlLCBuYW1lKTtcbn1cbmV4cG9ydHMub25lc0xpa2UgPSBvbmVzTGlrZTtcbmZ1bmN0aW9uIGV5ZVZhcmlhYmxlKHNpemUsIGR0eXBlLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKHRmYy5leWUoc2l6ZSksIGR0eXBlLCBuYW1lKTtcbn1cbmV4cG9ydHMuZXllVmFyaWFibGUgPSBleWVWYXJpYWJsZTtcbmZ1bmN0aW9uIHJhbmRvbVVuaWZvcm1WYXJpYWJsZShzaGFwZSwgbWludmFsLCBtYXh2YWwsIGR0eXBlLCBzZWVkLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gJ3JhbmRvbVVuaWZvcm0nOyB9XG4gICAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKHRmYy5yYW5kb21Vbmlmb3JtKHNoYXBlLCBtaW52YWwsIG1heHZhbCwgZHR5cGUpLCBkdHlwZSwgbmFtZSk7XG59XG5leHBvcnRzLnJhbmRvbVVuaWZvcm1WYXJpYWJsZSA9IHJhbmRvbVVuaWZvcm1WYXJpYWJsZTtcbmZ1bmN0aW9uIHRydW5jYXRlZE5vcm1hbFZhcmlhYmxlKHNoYXBlLCBtZWFuLCBzdGRkZXYsIGR0eXBlLCBzZWVkLCBuYW1lKSB7XG4gICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMC4wOyB9XG4gICAgaWYgKHN0ZGRldiA9PT0gdm9pZCAwKSB7IHN0ZGRldiA9IDEuMDsgfVxuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9ICd0cnVuY2F0ZWROb3JtYWwnOyB9XG4gICAgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJyYW5kb21Ob3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBib29sLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKHRmYy50cnVuY2F0ZWROb3JtYWwoc2hhcGUsIG1lYW4sIHN0ZGRldiwgZHR5cGUsIHNlZWQpLCBkdHlwZSwgbmFtZSk7XG59XG5leHBvcnRzLnRydW5jYXRlZE5vcm1hbFZhcmlhYmxlID0gdHJ1bmNhdGVkTm9ybWFsVmFyaWFibGU7XG5mdW5jdGlvbiByYW5kb21Ob3JtYWxWYXJpYWJsZShzaGFwZSwgbWVhbiwgc3RkZGV2LCBkdHlwZSwgc2VlZCwgbmFtZSkge1xuICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDAuMDsgfVxuICAgIGlmIChzdGRkZXYgPT09IHZvaWQgMCkgeyBzdGRkZXYgPSAxLjA7IH1cbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAncmFuZG9tTm9ybWFsJzsgfVxuICAgIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKFwicmFuZG9tTm9ybWFsVmFyaWFibGUgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBib29sLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKHRmanNfYmFja2VuZF8xLnJhbmRvbU5vcm1hbChzaGFwZSwgbWVhbiwgc3RkZGV2LCBkdHlwZSwgc2VlZCksIGR0eXBlLCBuYW1lKTtcbn1cbmV4cG9ydHMucmFuZG9tTm9ybWFsVmFyaWFibGUgPSByYW5kb21Ob3JtYWxWYXJpYWJsZTtcbmZ1bmN0aW9uIHVwZGF0ZSh4LCB4TmV3KSB7XG4gICAgcmV0dXJuIHgud3JpdGUoeE5ldyk7XG59XG5leHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbmZ1bmN0aW9uIHVwZGF0ZUFkZCh4LCBpbmNyZW1lbnQpIHtcbiAgICByZXR1cm4geC53cml0ZSh0ZmMuYWRkKHgucmVhZCgpLCBpbmNyZW1lbnQpKTtcbn1cbmV4cG9ydHMudXBkYXRlQWRkID0gdXBkYXRlQWRkO1xuZnVuY3Rpb24gdXBkYXRlU3ViKHgsIGRlY3JlbWVudCkge1xuICAgIHJldHVybiB4LndyaXRlKHRmYy5zdWIoeC5yZWFkKCksIGRlY3JlbWVudCkpO1xufVxuZXhwb3J0cy51cGRhdGVTdWIgPSB1cGRhdGVTdWI7XG5mdW5jdGlvbiBiYXRjaEdldFZhbHVlKHhzKSB7XG4gICAgcmV0dXJuIHhzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5yZWFkKCk7IH0pO1xufVxuZXhwb3J0cy5iYXRjaEdldFZhbHVlID0gYmF0Y2hHZXRWYWx1ZTtcbmZ1bmN0aW9uIGJhdGNoU2V0VmFsdWUodmFyaWFibGVzQW5kVmFsdWVzKSB7XG4gICAgdmFyaWFibGVzQW5kVmFsdWVzLm1hcChmdW5jdGlvbiAodmFyaWFibGVBbmRWYWx1ZSkge1xuICAgICAgICB2YXIgdmFyaWFibGUgPSB2YXJpYWJsZUFuZFZhbHVlWzBdO1xuICAgICAgICB2YXJpYWJsZS53cml0ZSh2YXJpYWJsZUFuZFZhbHVlWzFdKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYmF0Y2hTZXRWYWx1ZSA9IGJhdGNoU2V0VmFsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YXJpYWJsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmVyc2lvbiA9ICcwLjYuNic7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWxheWVyc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXJcIikpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2xheWVyc18xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtbGF5ZXJzXCIpO1xudmFyIHRmanNfY29udmVydGVyXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXJcIik7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMudmVyc2lvbiA9IHtcbiAgICAndGZqcy1jb3JlJzogdGZqc19jb3JlXzEudmVyc2lvbl9jb3JlLFxuICAgICd0ZmpzLWxheWVycyc6IHRmanNfbGF5ZXJzXzEudmVyc2lvbl9sYXllcnMsXG4gICAgJ3RmanMtY29udmVydGVyJzogdGZqc19jb252ZXJ0ZXJfMS52ZXJzaW9uX2NvbnZlcnRlcixcbiAgICAndGZqcyc6IHZlcnNpb25fMS52ZXJzaW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8gbWluaW1hbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LW1pbmltYWxcIik7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgcHJvdG9idWYgPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIHR5cGUsIG9uZSBvZiBgXCJmdWxsXCJgLCBgXCJsaWdodFwiYCBvciBgXCJtaW5pbWFsXCJgLlxyXG4gKiBAbmFtZSBidWlsZFxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKiBAY29uc3RcclxuICovXHJcbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XHJcblxyXG4vLyBTZXJpYWxpemF0aW9uXHJcbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcclxucHJvdG9idWYuQnVmZmVyV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyX2J1ZmZlclwiKTtcclxucHJvdG9idWYuUmVhZGVyICAgICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xyXG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xyXG5cclxuLy8gVXRpbGl0eVxyXG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XHJcbnByb3RvYnVmLnJwYyAgICAgICAgICA9IHJlcXVpcmUoXCIuL3JwY1wiKTtcclxucHJvdG9idWYucm9vdHMgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XHJcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbi8qKlxyXG4gKiBSZWNvbmZpZ3VyZXMgdGhlIGxpYnJhcnkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudC5cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcclxuICAgIHByb3RvYnVmLlJlYWRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlclJlYWRlcik7XHJcbiAgICBwcm90b2J1Zi51dGlsLl9jb25maWd1cmUoKTtcclxufVxyXG5cclxuLy8gQ29uZmlndXJlIHNlcmlhbGl6YXRpb25cclxucHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcclxuY29uZmlndXJlKCk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcclxuXHJcbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XHJcblxyXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcclxuXHJcbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxyXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcclxuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xyXG59XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyByZWFkZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxyXG4gKi9cclxuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBidWZmZXIuXHJcbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcclxufVxyXG5cclxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXHJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV90eXBlZF9hcnJheShidWZmZXIpIHtcclxuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheShidWZmZXIpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xyXG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XHJcbiAgICB9O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cclxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgYnVmZmVyYCBpcyBub3QgYSB2YWxpZCBidWZmZXJcclxuICovXHJcblJlYWRlci5jcmVhdGUgPSB1dGlsLkJ1ZmZlclxyXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXHJcbiAgICAgICAgICAgICAgICA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgfSkoYnVmZmVyKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICA6IGNyZWF0ZV9hcnJheTtcclxuXHJcblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG4vKipcclxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XHJcbiAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1OyAvLyBvcHRpbWl6ZXIgdHlwZS1oaW50LCB0ZW5kcyB0byBkZW9wdCBvdGhlcndpc2UgKD8hKVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xyXG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8ICA3KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAgMTUpIDw8IDI4KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikge1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xyXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHJlYWRfaW50MzIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcclxuICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XHJcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xyXG59O1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXHJcblxyXG5mdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpIHtcclxuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxyXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXHJcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcclxuICAgICAgICAgICAgLy8gMXN0Li40dGhcclxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNXRoXHJcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjgpID4+PiAwO1xyXG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcclxuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXHJcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKDsgaSA8IDM7ICsraSkge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxyXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA0dGhcclxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcclxuICAgICAgICByZXR1cm4gYml0cztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcclxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xyXG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcclxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcclxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XHJcbn1cclxuXHJcbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxyXG4gKiBAbmFtZSBSZWFkZXIjaW50NjRcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZS5cclxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cclxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgIT09IDA7XHJcbn07XHJcblxyXG5mdW5jdGlvbiByZWFkRml4ZWQzMl9lbmQoYnVmLCBlbmQpIHsgLy8gbm90ZSB0aGF0IHRoaXMgdXNlcyBgZW5kYCwgbm90IGBwb3NgXHJcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxyXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxyXG4gICAgICAgICAgfCBidWZbZW5kIC0gMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XHJcblxyXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhIHNpZ25lZCAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkMzIoKSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xyXG5cclxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpIHwgMDtcclxufTtcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xyXG5cclxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xyXG5cclxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XHJcbn1cclxuXHJcbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXHJcblxyXG4vKipcclxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cclxuICogQG5hbWUgUmVhZGVyI2ZpeGVkNjRcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIHppZy16YWcgZW5jb2RlZCBmaXhlZCA2NCBiaXRzLlxyXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XHJcblxyXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xyXG4gICAgdGhpcy5wb3MgKz0gNDtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gcmVhZF9kb3VibGUoKSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xyXG5cclxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XHJcbiAgICB0aGlzLnBvcyArPSA4O1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gcmVhZF9ieXRlcygpIHtcclxuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxyXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxyXG4gICAgICAgIGVuZCAgICA9IHRoaXMucG9zICsgbGVuZ3RoO1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGVuZCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xyXG5cclxuICAgIHRoaXMucG9zICs9IGxlbmd0aDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcclxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICByZXR1cm4gc3RhcnQgPT09IGVuZCAvLyBmaXggZm9yIElFIDEwL1dpbjggYW5kIG90aGVycycgc3ViYXJyYXkgcmV0dXJuaW5nIGFycmF5IG9mIHNpemUgMVxyXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXHJcbiAgICAgICAgOiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHN0cmluZyBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xyXG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xyXG4gICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcyBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBza2lwcyBhIHZhcmludC5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcclxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xyXG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcclxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XHJcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogU2tpcHMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHdpcmUgdHlwZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxyXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xyXG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICBkbyB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpID09PSA0KVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcclxuICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XHJcblxyXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcclxuICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xyXG5cclxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xyXG5cclxuLy8gZXh0ZW5kcyBSZWFkZXJcclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcclxuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxyXG4gKiBAZXh0ZW5kcyBSZWFkZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxyXG4gKi9cclxuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xyXG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYnVmZmVyLlxyXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxyXG4gICAgICogQHR5cGUge0J1ZmZlcn1cclxuICAgICAqL1xyXG59XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5pZiAodXRpbC5CdWZmZXIpXHJcbiAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xyXG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxyXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIE5hbWVkIHJvb3RzLlxyXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cclxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXHJcbiAqIEBuYW1lIHJvb3RzXHJcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cclxuICogQGV4YW1wbGVcclxuICogLy8gcGJqcyAtciBteXJvb3QgLW8gY29tcGlsZWQuanMgLi4uXHJcbiAqXHJcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxyXG4gKiByZXF1aXJlKFwiLi9jb21waWxlZC5qc1wiKTtcclxuICpcclxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxyXG4gKiB2YXIgcm9vdCA9IHByb3RvYnVmLnJvb3RzW1wibXlyb290XCJdO1xyXG4gKi9cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgcnBjID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXHJcbiAqIEB0eXBlZGVmIFJQQ0ltcGxcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSByZXF1ZXN0RGF0YSBSZXF1ZXN0IGRhdGFcclxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcclxuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxyXG4gKiAgICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBtZXRob2RcIik7XHJcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcclxuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XHJcbiAqICAgICB9KTtcclxuICogfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxyXG4gKiBAdHlwZWRlZiBSUENJbXBsQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcclxuICogQHBhcmFtIHtVaW50OEFycmF5fG51bGx9IFtyZXNwb25zZV0gUmVzcG9uc2UgZGF0YSBvciBgbnVsbGAgdG8gc2lnbmFsIGVuZCBvZiBzdHJlYW0sIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXHJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xyXG5cclxuLyoqXHJcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXHJcbiAqXHJcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxyXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXHJcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cclxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcclxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XHJcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcclxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXHJcbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXHJcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcclxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcblxyXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cclxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXHJcbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxyXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XHJcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cclxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgaWYgKCFyZXF1ZXN0KVxyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKCFjYWxsYmFjaylcclxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcclxuXHJcbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXHJcbiAqL1xyXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xyXG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xyXG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXHJcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMuXHJcbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxyXG4gKi9cclxuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XHJcblxyXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBjYXN0cyBiZWxvdyBhcmUgdGhlb3JldGljYWxseSB1bm5lY2Vzc2FyeSBhcyBvZiB0b2RheSwgYnV0IG9sZGVyIHN0YXRpY2FsbHlcclxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG93IGJpdHMuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWdoIGJpdHMuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBaZXJvIGJpdHMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXHJcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxyXG4gKi9cclxudmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xyXG5cclxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcclxuemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XHJcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xyXG5cclxuLyoqXHJcbiAqIFplcm8gaGFzaC5cclxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXHJcbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxyXG4gKi9cclxuTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gMClcclxuICAgICAgICByZXR1cm4gemVybztcclxuICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xyXG4gICAgaWYgKHNpZ24pXHJcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XHJcbiAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCxcclxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XHJcbiAgICBpZiAoc2lnbikge1xyXG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xyXG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xyXG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xyXG4gICAgICAgICAgICBsbyA9IDA7XHJcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcclxuICAgICAgICAgICAgICAgIGhpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gYSBudW1iZXIsIGxvbmcgb3Igc3RyaW5nLlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcclxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXHJcbiAqL1xyXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XHJcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICAgIGlmICh1dGlsLkxvbmcpXHJcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBwb3NzaWJseSB1bnNhZmUgSmF2YVNjcmlwdCBudW1iZXIuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xyXG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xyXG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCxcclxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XHJcbiAgICAgICAgaWYgKCFsbylcclxuICAgICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XHJcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5NjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gTG9uZ1xyXG4gKi9cclxuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIHV0aWwuTG9uZ1xyXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcclxufTtcclxuXHJcbnZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xyXG4gKi9cclxuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XHJcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXHJcbiAgICAgICAgcmV0dXJuIHplcm87XHJcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxyXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOFxyXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXHJcbiAgICAsXHJcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTZcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXHJcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXHJcbiAgICAgICAgdGhpcy5oaSAgICAgICAgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcclxuICAgIHZhciBtYXNrID0gICB0aGlzLmhpID4+IDMxO1xyXG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xyXG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcclxuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XHJcbiAgICB0aGlzLmxvICA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XHJcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBsb25nYml0cyB3aGVuIGVuY29kZWQgYXMgYSB2YXJpbnQuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxyXG4gKi9cclxuTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcclxuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxyXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcclxuICAgICAgICBwYXJ0MiA9ICB0aGlzLmhpID4+PiAyNDtcclxuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxyXG4gICAgICAgICA/IHBhcnQxID09PSAwXHJcbiAgICAgICAgICAgPyBwYXJ0MCA8IDE2Mzg0XHJcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcclxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcclxuICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcclxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxyXG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxyXG4gICAgICAgICA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHV0aWwgPSBleHBvcnRzO1xyXG5cclxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcclxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xyXG5cclxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcclxudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xyXG5cclxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxyXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XHJcblxyXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXHJcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XHJcblxyXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcclxudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XHJcblxyXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcclxudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XHJcblxyXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcclxuXHJcbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxyXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XHJcblxyXG4vKipcclxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEB0eXBlIHtBcnJheS48Kj59XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xyXG5cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcclxuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4oZ2xvYmFsLnByb2Nlc3MgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcclxuICovXHJcbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcclxuICovXHJcbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcclxuICovXHJcbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxyXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICovXHJcbnV0aWwuaXNzZXQgPVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICovXHJcbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcclxuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cclxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXHJcbiAqIEBpbnRlcmZhY2UgQnVmZmVyXHJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcclxuICovXHJcblxyXG4vKipcclxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXHJcbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxyXG4gKi9cclxudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xyXG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcclxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn0pKCk7XHJcblxyXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXHJcbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcclxuXHJcbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXHJcbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxyXG4gKi9cclxudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXHJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcclxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcclxuICAgICAgICA6IHV0aWwuQnVmZmVyXHJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXHJcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcclxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcclxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxyXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XHJcbiAqL1xyXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XHJcblxyXG4vKipcclxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cclxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXHJcbiAqIEBpbnRlcmZhY2UgTG9uZ1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cclxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxyXG4gKi9cclxudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZ2xvYmFsLmRjb2RlSU8uTG9uZyB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xyXG5cclxuLyoqXHJcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cclxuICogQHR5cGUge1JlZ0V4cH1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcclxuXHJcbi8qKlxyXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxyXG4gKiBAdHlwZSB7UmVnRXhwfVxyXG4gKiBAY29uc3RcclxuICovXHJcbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xyXG5cclxuLyoqXHJcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXHJcbiAqIEB0eXBlIHtSZWdFeHB9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcclxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxyXG4gKi9cclxudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXHJcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcclxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcclxuICovXHJcbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XHJcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XHJcbiAgICBpZiAodXRpbC5Mb25nKVxyXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xyXG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcclxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXHJcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXHJcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuXHJcbnV0aWwubWVyZ2UgPSBtZXJnZTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcclxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xyXG4gKi9cclxudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcclxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcclxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xyXG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogKG5ldyBFcnJvcigpKS5zdGFjayB8fCBcIlwiIH0pO1xyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcylcclxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XHJcbiAgICB9XHJcblxyXG4gICAgKEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmFtZTsgfSB9KTtcclxuXHJcbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XHJcbn1cclxuXHJcbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxyXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZXh0ZW5kcyBFcnJvclxyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB0cnkge1xyXG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gKiB9IGNhdGNoIChlKSB7XHJcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcclxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcclxuICogfVxyXG4gKi9cclxudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xyXG5cclxuLyoqXHJcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXHJcbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxyXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cclxuICovXHJcblxyXG4vKipcclxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxyXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xyXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXHJcbiAqL1xyXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xyXG4gICAgdmFyIGZpZWxkTWFwID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcclxuICAgICAqIEB0aGlzIE9iamVjdFxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cclxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxyXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxyXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcclxuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxyXG4gKi9cclxudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAgICAgKiBAdGhpcyBPYmplY3RcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcclxuICpcclxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xyXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xyXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXHJcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcclxuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXHJcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcclxuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xyXG4gKlxyXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxyXG4gKi9cclxudXRpbC50b0pTT05PcHRpb25zID0ge1xyXG4gICAgbG9uZ3M6IFN0cmluZyxcclxuICAgIGVudW1zOiBTdHJpbmcsXHJcbiAgICBieXRlczogU3RyaW5nLFxyXG4gICAganNvbjogdHJ1ZVxyXG59O1xyXG5cclxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghQnVmZmVyKSB7XHJcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXHJcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XHJcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xyXG4gICAgICAgIH07XHJcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xyXG4gICAgICAgIH07XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcclxuXHJcbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XHJcblxyXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcclxuXHJcbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxyXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXHJcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB3cml0ZXIgb3BlcmF0aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcclxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxyXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZm4gPSBmbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZW4gPSBsZW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cclxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cclxuICAgICAqIEB0eXBlIHsqfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcclxufVxyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBDb3BpZWQgd3JpdGVyIHN0YXRlLlxyXG4gKiBAbWVtYmVyb2YgV3JpdGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1dyaXRlcn0gd3JpdGVyIFdyaXRlciB0byBjb3B5IHN0YXRlIGZyb21cclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGhlYWQuXHJcbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgdGFpbC5cclxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBidWZmZXIgbGVuZ3RoLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmV4dCBzdGF0ZS5cclxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xyXG59XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIFdyaXRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZW4gPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cclxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xyXG5cclxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcclxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXHJcbiAgICAvLyBidWZmZXJzIG9mIHRoZSBleGFjdCByZXF1aXJlZCBzaXplIGFuZCByZWR1Y2VzIHRoZSBhbW91bnQgb2Ygd29yayB3ZSBoYXZlIHRvIGRvIGNvbXBhcmVkXHJcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXHJcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cclxuICovXHJcbldyaXRlci5jcmVhdGUgPSB1dGlsLkJ1ZmZlclxyXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xyXG4gICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXHJcbiAqL1xyXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XHJcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XHJcbn07XHJcblxyXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcclxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxyXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xyXG5cclxuLyoqXHJcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XHJcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xyXG4gICAgdGhpcy5sZW4gKz0gbGVuO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xyXG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xyXG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XHJcbiAgICAgICAgdmFsID4+Pj0gNztcclxuICAgIH1cclxuICAgIGJ1Zltwb3NdID0gdmFsO1xyXG59XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXHJcbiAqIEBleHRlbmRzIE9wXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcclxuICAgIHRoaXMubGVuID0gbGVuO1xyXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy52YWwgPSB2YWw7XHJcbn1cclxuXHJcblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcclxuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xyXG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXHJcbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxyXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxyXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxyXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXHJcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcclxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xyXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XHJcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXHJcbiAgICB2YWx1ZSkpLmxlbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA8IDBcclxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xyXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xyXG4gICAgd2hpbGUgKHZhbC5oaSkge1xyXG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XHJcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XHJcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcclxuICAgIH1cclxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcclxuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xyXG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcclxuICAgIH1cclxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xyXG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xyXG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cclxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XHJcblxyXG4vKipcclxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XHJcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xyXG59O1xyXG5cclxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcclxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xyXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcclxuICAgIGlmICghbGVuKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XHJcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcclxuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xyXG4gICAgICAgIHZhbHVlID0gYnVmO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xyXG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcclxuICAgIHJldHVybiBsZW5cclxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcclxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cclxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xyXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XHJcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XHJcbiAgICB0aGlzLmxlbiA9IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcclxuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XHJcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xyXG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xyXG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xyXG4gICAgICAgIHRoaXMubGVuICA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcclxuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxyXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXHJcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xyXG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xyXG4gICAgaWYgKGxlbikge1xyXG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcclxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xyXG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xyXG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXHJcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxyXG4gICAgICAgIHBvcyAgPSAwO1xyXG4gICAgd2hpbGUgKGhlYWQpIHtcclxuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XHJcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xyXG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XHJcbiAgICB9XHJcbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgcmV0dXJuIGJ1ZjtcclxufTtcclxuXHJcbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xyXG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xyXG5cclxuLy8gZXh0ZW5kcyBXcml0ZXJcclxudmFyIFdyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcclxuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxudmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHdyaXRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxyXG4gKiBAZXh0ZW5kcyBXcml0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XHJcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlclxyXG4gKi9cclxuQnVmZmVyV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2NfYnVmZmVyKHNpemUpIHtcclxuICAgIHJldHVybiAoQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKShzaXplKTtcclxufTtcclxuXHJcbnZhciB3cml0ZUJ5dGVzQnVmZmVyID0gQnVmZmVyICYmIEJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIEJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCJcclxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xyXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcclxuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcclxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcclxuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XHJcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xyXG4gICAgaWYgKGxlbilcclxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcclxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xyXG4gICAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcclxuICAgIHRoaXMudWludDMyKGxlbik7XHJcbiAgICBpZiAobGVuKVxyXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXHJcbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEZpbmlzaGVkIGJ1ZmZlclxyXG4gKi9cclxuIiwiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vIFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cblxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBBbGVhKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgbWFzaCA9IE1hc2goKTtcblxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAyMDkxNjM5ICogbWUuczAgKyBtZS5jICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICBtZS5zMCA9IG1lLnMxO1xuICAgIG1lLnMxID0gbWUuczI7XG4gICAgcmV0dXJuIG1lLnMyID0gdCAtIChtZS5jID0gdCB8IDApO1xuICB9O1xuXG4gIC8vIEFwcGx5IHRoZSBzZWVkaW5nIGFsZ29yaXRobSBmcm9tIEJhYWdvZS5cbiAgbWUuYyA9IDE7XG4gIG1lLnMwID0gbWFzaCgnICcpO1xuICBtZS5zMSA9IG1hc2goJyAnKTtcbiAgbWUuczIgPSBtYXNoKCcgJyk7XG4gIG1lLnMwIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMCA8IDApIHsgbWUuczAgKz0gMTsgfVxuICBtZS5zMSAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczEgPCAwKSB7IG1lLnMxICs9IDE7IH1cbiAgbWUuczIgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMyIDwgMCkgeyBtZS5zMiArPSAxOyB9XG4gIG1hc2ggPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5jID0gZi5jO1xuICB0LnMwID0gZi5zMDtcbiAgdC5zMSA9IGYuczE7XG4gIHQuczIgPSBmLnMyO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBBbGVhKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0geGcubmV4dDtcbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSAqIDB4MTAwMDAwMDAwKSB8IDA7IH1cbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJuZygpICsgKHBybmcoKSAqIDB4MjAwMDAwIHwgMCkgKiAxLjExMDIyMzAyNDYyNTE1NjVlLTE2OyAvLyAyXi01M1xuICB9O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuZnVuY3Rpb24gTWFzaCgpIHtcbiAgdmFyIG4gPSAweGVmYzgyNDlkO1xuXG4gIHZhciBtYXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIGggKj0gbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICB9XG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gIH07XG5cbiAgcmV0dXJuIG1hc2g7XG59XG5cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5hbGVhID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJUeWNoZS1pXCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqby5cbi8vIFNlZSBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kLCBhID0gbWUuYTtcbiAgICBiID0gKGIgPDwgMjUpIF4gKGIgPj4+IDcpIF4gYztcbiAgICBjID0gKGMgLSBkKSB8IDA7XG4gICAgZCA9IChkIDw8IDI0KSBeIChkID4+PiA4KSBeIGE7XG4gICAgYSA9IChhIC0gYikgfCAwO1xuICAgIG1lLmIgPSBiID0gKGIgPDwgMjApIF4gKGIgPj4+IDEyKSBeIGM7XG4gICAgbWUuYyA9IGMgPSAoYyAtIGQpIHwgMDtcbiAgICBtZS5kID0gKGQgPDwgMTYpIF4gKGMgPj4+IDE2KSBeIGE7XG4gICAgcmV0dXJuIG1lLmEgPSAoYSAtIGIpIHwgMDtcbiAgfTtcblxuICAvKiBUaGUgZm9sbG93aW5nIGlzIG5vbi1pbnZlcnRlZCB0eWNoZSwgd2hpY2ggaGFzIGJldHRlciBpbnRlcm5hbFxuICAgKiBiaXQgZGlmZnVzaW9uLCBidXQgd2hpY2ggaXMgYWJvdXQgMjUlIHNsb3dlciB0aGFuIHR5Y2hlLWkgaW4gSlMuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IG1lLmEsIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQ7XG4gICAgYSA9IChtZS5hICsgbWUuYiB8IDApID4+PiAwO1xuICAgIGQgPSBtZS5kIF4gYTsgZCA9IGQgPDwgMTYgXiBkID4+PiAxNjtcbiAgICBjID0gbWUuYyArIGQgfCAwO1xuICAgIGIgPSBtZS5iIF4gYzsgYiA9IGIgPDwgMTIgXiBkID4+PiAyMDtcbiAgICBtZS5hID0gYSA9IGEgKyBiIHwgMDtcbiAgICBkID0gZCBeIGE7IG1lLmQgPSBkID0gZCA8PCA4IF4gZCA+Pj4gMjQ7XG4gICAgbWUuYyA9IGMgPSBjICsgZCB8IDA7XG4gICAgYiA9IGIgXiBjO1xuICAgIHJldHVybiBtZS5iID0gKGIgPDwgNyBeIGIgPj4+IDI1KTtcbiAgfVxuICAqL1xuXG4gIG1lLmEgPSAwO1xuICBtZS5iID0gMDtcbiAgbWUuYyA9IDI2NTQ0MzU3NjkgfCAwO1xuICBtZS5kID0gMTM2NzEzMDU1MTtcblxuICBpZiAoc2VlZCA9PT0gTWF0aC5mbG9vcihzZWVkKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS5hID0gKHNlZWQgLyAweDEwMDAwMDAwMCkgfCAwO1xuICAgIG1lLmIgPSBzZWVkIHwgMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDIwOyBrKyspIHtcbiAgICBtZS5iIF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmEgPSBmLmE7XG4gIHQuYiA9IGYuYjtcbiAgdC5jID0gZi5jO1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufTtcblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy50eWNoZWkgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcjEyOFwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICBtZS54ID0gMDtcbiAgbWUueSA9IDA7XG4gIG1lLnogPSAwO1xuICBtZS53ID0gMDtcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBtZS54IF4gKG1lLnggPDwgMTEpO1xuICAgIG1lLnggPSBtZS55O1xuICAgIG1lLnkgPSBtZS56O1xuICAgIG1lLnogPSBtZS53O1xuICAgIHJldHVybiBtZS53IF49IChtZS53ID4+PiAxOSkgXiB0IF4gKHQgPj4+IDgpO1xuICB9O1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yMTI4ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiBSaWNoYXJkIEJyZW50J3MgWG9yZ2VucyB4b3I0MDk2IGFsZ29yaXRobS5cbi8vXG4vLyBUaGlzIGZhc3Qgbm9uLWNyeXB0b2dyYXBoaWMgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgaXMgZGVzaWduZWQgZm9yXG4vLyB1c2UgaW4gTW9udGUtQ2FybG8gYWxnb3JpdGhtcy4gSXQgY29tYmluZXMgYSBsb25nLXBlcmlvZCB4b3JzaGlmdFxuLy8gZ2VuZXJhdG9yIHdpdGggYSBXZXlsIGdlbmVyYXRvciwgYW5kIGl0IHBhc3NlcyBhbGwgY29tbW9uIGJhdHRlcmllc1xuLy8gb2Ygc3Rhc3RpY2lhbCB0ZXN0cyBmb3IgcmFuZG9tbmVzcyB3aGlsZSBjb25zdW1pbmcgb25seSBhIGZldyBuYW5vc2Vjb25kc1xuLy8gZm9yIGVhY2ggcHJuZyBnZW5lcmF0ZWQuICBGb3IgYmFja2dyb3VuZCBvbiB0aGUgZ2VuZXJhdG9yLCBzZWUgQnJlbnQnc1xuLy8gcGFwZXI6IFwiU29tZSBsb25nLXBlcmlvZCByYW5kb20gbnVtYmVyIGdlbmVyYXRvcnMgdXNpbmcgc2hpZnRzIGFuZCB4b3JzLlwiXG4vLyBodHRwOi8vYXJ4aXYub3JnL3BkZi8xMDA0LjMxMTV2MS5wZGZcbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgeG9yNDA5NiA9IHJlcXVpcmUoJ3hvcjQwOTYnKTtcbi8vIHJhbmRvbSA9IHhvcjQwOTYoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlZCB3aXRoIGludDMyIG9yIHN0cmluZy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20oKSwgMC4xNTIwNDM2NDUwNTM4NTQ3KTsgLy8gKDAsIDEpIHJhbmdlLCA1MyBiaXRzLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbS5pbnQzMigpLCAxODA2NTM0ODk3KTsgICAvLyBzaWduZWQgaW50MzIsIDMyIGJpdHMuXG4vL1xuLy8gRm9yIG5vbnplcm8gbnVtZXJpYyBrZXlzLCB0aGlzIGltcGVsZW1lbnRhdGlvbiBwcm92aWRlcyBhIHNlcXVlbmNlXG4vLyBpZGVudGljYWwgdG8gdGhhdCBieSBCcmVudCdzIHhvcmdlbnMgMyBpbXBsZW1lbnRhaW9uIGluIEMuICBUaGlzXG4vLyBpbXBsZW1lbnRhdGlvbiBhbHNvIHByb3ZpZGVzIGZvciBpbml0YWxpemluZyB0aGUgZ2VuZXJhdG9yIHdpdGhcbi8vIHN0cmluZyBzZWVkcywgb3IgZm9yIHNhdmluZyBhbmQgcmVzdG9yaW5nIHRoZSBzdGF0ZSBvZiB0aGUgZ2VuZXJhdG9yLlxuLy9cbi8vIE9uIENocm9tZSwgdGhpcyBwcm5nIGJlbmNobWFya3MgYWJvdXQgMi4xIHRpbWVzIHNsb3dlciB0aGFuXG4vLyBKYXZhc2NyaXB0J3MgYnVpbHQtaW4gTWF0aC5yYW5kb20oKS5cblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHcgPSBtZS53LFxuICAgICAgICBYID0gbWUuWCwgaSA9IG1lLmksIHQsIHY7XG4gICAgLy8gVXBkYXRlIFdleWwgZ2VuZXJhdG9yLlxuICAgIG1lLncgPSB3ID0gKHcgKyAweDYxYzg4NjQ3KSB8IDA7XG4gICAgLy8gVXBkYXRlIHhvciBnZW5lcmF0b3IuXG4gICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgIHYgXj0gdiA8PCAxMztcbiAgICB0IF49IHQgPDwgMTc7XG4gICAgdiBePSB2ID4+PiAxNTtcbiAgICB0IF49IHQgPj4+IDEyO1xuICAgIC8vIFVwZGF0ZSBYb3IgZ2VuZXJhdG9yIGFycmF5IHN0YXRlLlxuICAgIHYgPSBYW2ldID0gdiBeIHQ7XG4gICAgbWUuaSA9IGk7XG4gICAgLy8gUmVzdWx0IGlzIHRoZSBjb21iaW5hdGlvbi5cbiAgICByZXR1cm4gKHYgKyAodyBeICh3ID4+PiAxNikpKSB8IDA7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChtZSwgc2VlZCkge1xuICAgIHZhciB0LCB2LCBpLCBqLCB3LCBYID0gW10sIGxpbWl0ID0gMTI4O1xuICAgIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgICAvLyBOdW1lcmljIHNlZWRzIGluaXRpYWxpemUgdiwgd2hpY2ggaXMgdXNlZCB0byBnZW5lcmF0ZXMgWC5cbiAgICAgIHYgPSBzZWVkO1xuICAgICAgc2VlZCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0cmluZyBzZWVkcyBhcmUgbWl4ZWQgaW50byB2IGFuZCBYIG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lLlxuICAgICAgc2VlZCA9IHNlZWQgKyAnXFwwJztcbiAgICAgIHYgPSAwO1xuICAgICAgbGltaXQgPSBNYXRoLm1heChsaW1pdCwgc2VlZC5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBJbml0aWFsaXplIGNpcmN1bGFyIGFycmF5IGFuZCB3ZXlsIHZhbHVlLlxuICAgIGZvciAoaSA9IDAsIGogPSAtMzI7IGogPCBsaW1pdDsgKytqKSB7XG4gICAgICAvLyBQdXQgdGhlIHVuaWNvZGUgY2hhcmFjdGVycyBpbnRvIHRoZSBhcnJheSwgYW5kIHNodWZmbGUgdGhlbS5cbiAgICAgIGlmIChzZWVkKSB2IF49IHNlZWQuY2hhckNvZGVBdCgoaiArIDMyKSAlIHNlZWQubGVuZ3RoKTtcbiAgICAgIC8vIEFmdGVyIDMyIHNodWZmbGVzLCB0YWtlIHYgYXMgdGhlIHN0YXJ0aW5nIHcgdmFsdWUuXG4gICAgICBpZiAoaiA9PT0gMCkgdyA9IHY7XG4gICAgICB2IF49IHYgPDwgMTA7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdiBePSB2IDw8IDQ7XG4gICAgICB2IF49IHYgPj4+IDEzO1xuICAgICAgaWYgKGogPj0gMCkge1xuICAgICAgICB3ID0gKHcgKyAweDYxYzg4NjQ3KSB8IDA7ICAgICAvLyBXZXlsLlxuICAgICAgICB0ID0gKFhbaiAmIDEyN10gXj0gKHYgKyB3KSk7ICAvLyBDb21iaW5lIHhvciBhbmQgd2V5bCB0byBpbml0IGFycmF5LlxuICAgICAgICBpID0gKDAgPT0gdCkgPyBpICsgMSA6IDA7ICAgICAvLyBDb3VudCB6ZXJvZXMuXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgZGV0ZWN0ZWQgYWxsIHplcm9lczsgbWFrZSB0aGUga2V5IG5vbnplcm8uXG4gICAgaWYgKGkgPj0gMTI4KSB7XG4gICAgICBYWyhzZWVkICYmIHNlZWQubGVuZ3RoIHx8IDApICYgMTI3XSA9IC0xO1xuICAgIH1cbiAgICAvLyBSdW4gdGhlIGdlbmVyYXRvciA1MTIgdGltZXMgdG8gZnVydGhlciBtaXggdGhlIHN0YXRlIGJlZm9yZSB1c2luZyBpdC5cbiAgICAvLyBGYWN0b3JpbmcgdGhpcyBhcyBhIGZ1bmN0aW9uIHNsb3dzIHRoZSBtYWluIGdlbmVyYXRvciwgc28gaXQgaXMganVzdFxuICAgIC8vIHVucm9sbGVkIGhlcmUuICBUaGUgd2V5bCBnZW5lcmF0b3IgaXMgbm90IGFkdmFuY2VkIHdoaWxlIHdhcm1pbmcgdXAuXG4gICAgaSA9IDEyNztcbiAgICBmb3IgKGogPSA0ICogMTI4OyBqID4gMDsgLS1qKSB7XG4gICAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICAgIHYgXj0gdiA8PCAxMztcbiAgICAgIHQgXj0gdCA8PCAxNztcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB0IF49IHQgPj4+IDEyO1xuICAgICAgWFtpXSA9IHYgXiB0O1xuICAgIH1cbiAgICAvLyBTdG9yaW5nIHN0YXRlIGFzIG9iamVjdCBtZW1iZXJzIGlzIGZhc3RlciB0aGFuIHVzaW5nIGNsb3N1cmUgdmFyaWFibGVzLlxuICAgIG1lLncgPSB3O1xuICAgIG1lLlggPSBYO1xuICAgIG1lLmkgPSBpO1xuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQudyA9IGYudztcbiAgdC5YID0gZi5YLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuWCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcjQwOTYgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2luZG93IG9iamVjdCBvciBnbG9iYWxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yc2hpZnQ3XCIgYWxnb3JpdGhtIGJ5XG4vLyBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllcjpcbi8vIFwiT24gdGhlIFhvcmdzaGlmdCBSYW5kb20gTnVtYmVyIEdlbmVyYXRvcnNcIlxuLy8gaHR0cDovL3NhbHVjLmVuZ3IudWNvbm4uZWR1L3JlZnMvY3J5cHRvL3JuZy9wYW5uZXRvbjA1b250aGV4b3JzaGlmdC5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXBkYXRlIHhvciBnZW5lcmF0b3IuXG4gICAgdmFyIFggPSBtZS54LCBpID0gbWUuaSwgdCwgdiwgdztcbiAgICB0ID0gWFtpXTsgdCBePSAodCA+Pj4gNyk7IHYgPSB0IF4gKHQgPDwgMjQpO1xuICAgIHQgPSBYWyhpICsgMSkgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDEwKTtcbiAgICB0ID0gWFsoaSArIDMpICYgN107IHYgXj0gdCBeICh0ID4+PiAzKTtcbiAgICB0ID0gWFsoaSArIDQpICYgN107IHYgXj0gdCBeICh0IDw8IDcpO1xuICAgIHQgPSBYWyhpICsgNykgJiA3XTsgdCA9IHQgXiAodCA8PCAxMyk7IHYgXj0gdCBeICh0IDw8IDkpO1xuICAgIFhbaV0gPSB2O1xuICAgIG1lLmkgPSAoaSArIDEpICYgNztcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIGosIHcsIFggPSBbXTtcblxuICAgIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIGFycmF5IHVzaW5nIGEgMzItYml0IGludGVnZXIuXG4gICAgICB3ID0gWFswXSA9IHNlZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgdXNpbmcgYSBzdHJpbmcuXG4gICAgICBzZWVkID0gJycgKyBzZWVkO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgWFtqICYgN10gPSAoWFtqICYgN10gPDwgMTUpIF5cbiAgICAgICAgICAgIChzZWVkLmNoYXJDb2RlQXQoaikgKyBYWyhqICsgMSkgJiA3XSA8PCAxMyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVuZm9yY2UgYW4gYXJyYXkgbGVuZ3RoIG9mIDgsIG5vdCBhbGwgemVyb2VzLlxuICAgIHdoaWxlIChYLmxlbmd0aCA8IDgpIFgucHVzaCgwKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgOCAmJiBYW2pdID09PSAwOyArK2opO1xuICAgIGlmIChqID09IDgpIHcgPSBYWzddID0gLTE7IGVsc2UgdyA9IFhbal07XG5cbiAgICBtZS54ID0gWDtcbiAgICBtZS5pID0gMDtcblxuICAgIC8vIERpc2NhcmQgYW4gaW5pdGlhbCAyNTYgdmFsdWVzLlxuICAgIGZvciAoaiA9IDI1NjsgaiA+IDA7IC0taikge1xuICAgICAgbWUubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54LnNsaWNlKCk7XG4gIHQuaSA9IGYuaTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLngpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3JzaGlmdDcgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3J3b3dcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gKG1lLnggXiAobWUueCA+Pj4gMikpO1xuICAgIG1lLnggPSBtZS55OyBtZS55ID0gbWUuejsgbWUueiA9IG1lLnc7IG1lLncgPSBtZS52O1xuICAgIHJldHVybiAobWUuZCA9IChtZS5kICsgMzYyNDM3IHwgMCkpICtcbiAgICAgICAobWUudiA9IChtZS52IF4gKG1lLnYgPDwgNCkpIF4gKHQgXiAodCA8PCAxKSkpIHwgMDtcbiAgfTtcblxuICBtZS54ID0gMDtcbiAgbWUueSA9IDA7XG4gIG1lLnogPSAwO1xuICBtZS53ID0gMDtcbiAgbWUudiA9IDA7XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIGlmIChrID09IHN0cnNlZWQubGVuZ3RoKSB7XG4gICAgICBtZS5kID0gbWUueCA8PCAxMCBeIG1lLnggPj4+IDQ7XG4gICAgfVxuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICB0LnYgPSBmLnY7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yd293ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTQgRGF2aWQgQmF1LlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbklOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG5DTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcblNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG4oZnVuY3Rpb24gKHBvb2wsIG1hdGgpIHtcbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xudmFyIGdsb2JhbCA9IHRoaXMsXG4gICAgd2lkdGggPSAyNTYsICAgICAgICAvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gICAgY2h1bmtzID0gNiwgICAgICAgICAvLyBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gICAgZGlnaXRzID0gNTIsICAgICAgICAvLyB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICAgcm5nbmFtZSA9ICdyYW5kb20nLCAvLyBybmduYW1lOiBuYW1lIGZvciBNYXRoLnJhbmRvbSBhbmQgTWF0aC5zZWVkcmFuZG9tXG4gICAgc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxuICAgIHNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIGRpZ2l0cyksXG4gICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgIG1hc2sgPSB3aWR0aCAtIDEsXG4gICAgbm9kZWNyeXB0bzsgICAgICAgICAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG5cbi8vXG4vLyBzZWVkcmFuZG9tKClcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuLy9cbmZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGtleSA9IFtdO1xuICBvcHRpb25zID0gKG9wdGlvbnMgPT0gdHJ1ZSkgPyB7IGVudHJvcHk6IHRydWUgfSA6IChvcHRpb25zIHx8IHt9KTtcblxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cbiAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKFxuICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxuICAgIChzZWVkID09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuICB2YXIgcHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICBkID0gc3RhcnRkZW5vbSwgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIHwgMDsgfVxuICBwcm5nLnF1aWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDsgfVxuICBwcm5nLmRvdWJsZSA9IHBybmc7XG5cbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cbiAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xuXG4gIC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fFxuICAgICAgZnVuY3Rpb24ocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XG4gICAgICAgICAgLy8gT25seSBwcm92aWRlIHRoZSAuc3RhdGUgbWV0aG9kIGlmIHJlcXVlc3RlZCB2aWEgb3B0aW9ucy5zdGF0ZS5cbiAgICAgICAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KGFyYzQsIHt9KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXG4gICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHsgbWF0aFtybmduYW1lXSA9IHBybmc7IHJldHVybiBzZWVkOyB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxuICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxuICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xuICAgICAgfSkoXG4gIHBybmcsXG4gIHNob3J0c2VlZCxcbiAgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogKHRoaXMgPT0gbWF0aCksXG4gIG9wdGlvbnMuc3RhdGUpO1xufVxubWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XG5cbi8vXG4vLyBBUkM0XG4vL1xuLy8gQW4gQVJDNCBpbXBsZW1lbnRhdGlvbi4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIGtleSBpbiB0aGUgZm9ybSBvZlxuLy8gYW4gYXJyYXkgb2YgYXQgbW9zdCAod2lkdGgpIGludGVnZXJzIHRoYXQgc2hvdWxkIGJlIDAgPD0geCA8ICh3aWR0aCkuXG4vL1xuLy8gVGhlIGcoY291bnQpIG1ldGhvZCByZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgdGhhdCBjb25jYXRlbmF0ZXNcbi8vIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBmcm9tIEFSQzQuICBJdHMgcmV0dXJuIHZhbHVlIGlzIGEgbnVtYmVyIHhcbi8vIHRoYXQgaXMgaW4gdGhlIHJhbmdlIDAgPD0geCA8ICh3aWR0aCBeIGNvdW50KS5cbi8vXG5mdW5jdGlvbiBBUkM0KGtleSkge1xuICB2YXIgdCwga2V5bGVuID0ga2V5Lmxlbmd0aCxcbiAgICAgIG1lID0gdGhpcywgaSA9IDAsIGogPSBtZS5pID0gbWUuaiA9IDAsIHMgPSBtZS5TID0gW107XG5cbiAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cbiAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxuXG4gIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXG4gIHdoaWxlIChpIDwgd2lkdGgpIHtcbiAgICBzW2ldID0gaSsrO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIGtleVtpICUga2V5bGVuXSArICh0ID0gc1tpXSkpXTtcbiAgICBzW2pdID0gdDtcbiAgfVxuXG4gIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cbiAgKG1lLmcgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIFVzaW5nIGluc3RhbmNlIG1lbWJlcnMgaW5zdGVhZCBvZiBjbG9zdXJlIHN0YXRlIG5lYXJseSBkb3VibGVzIHNwZWVkLlxuICAgIHZhciB0LCByID0gMCxcbiAgICAgICAgaSA9IG1lLmksIGogPSBtZS5qLCBzID0gbWUuUztcbiAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgdCA9IHNbaSA9IG1hc2sgJiAoaSArIDEpXTtcbiAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoKHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyB0KV0pICsgKHNbal0gPSB0KSldO1xuICAgIH1cbiAgICBtZS5pID0gaTsgbWUuaiA9IGo7XG4gICAgcmV0dXJuIHI7XG4gICAgLy8gRm9yIHJvYnVzdCB1bnByZWRpY3RhYmlsaXR5LCB0aGUgZnVuY3Rpb24gY2FsbCBiZWxvdyBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZGlzY2FyZHMgYW4gaW5pdGlhbCBiYXRjaCBvZiB2YWx1ZXMuICBUaGlzIGlzIGNhbGxlZCBSQzQtZHJvcFsyNTZdLlxuICAgIC8vIFNlZSBodHRwOi8vZ29vZ2xlLmNvbS9zZWFyY2g/cT1yc2ErZmx1aHJlcityZXNwb25zZSZidG5JXG4gIH0pKHdpZHRoKTtcbn1cblxuLy9cbi8vIGNvcHkoKVxuLy8gQ29waWVzIGludGVybmFsIHN0YXRlIG9mIEFSQzQgdG8gb3IgZnJvbSBhIHBsYWluIG9iamVjdC5cbi8vXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LmogPSBmLmo7XG4gIHQuUyA9IGYuUy5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbi8vXG4vLyBmbGF0dGVuKClcbi8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbi8vXG5mdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLCB0eXAgPSAodHlwZW9mIG9iaiksIHByb3A7XG4gIGlmIChkZXB0aCAmJiB0eXAgPT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICB0cnkgeyByZXN1bHQucHVzaChmbGF0dGVuKG9ialtwcm9wXSwgZGVwdGggLSAxKSk7IH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG4gIHJldHVybiAocmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IHR5cCA9PSAnc3RyaW5nJyA/IG9iaiA6IG9iaiArICdcXDAnKTtcbn1cblxuLy9cbi8vIG1peGtleSgpXG4vLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4vLyByZXR1cm5zIGEgc2hvcnRlbmVkIHN0cmluZyBzZWVkIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgcmVzdWx0IGtleS5cbi8vXG5mdW5jdGlvbiBtaXhrZXkoc2VlZCwga2V5KSB7XG4gIHZhciBzdHJpbmdzZWVkID0gc2VlZCArICcnLCBzbWVhciwgaiA9IDA7XG4gIHdoaWxlIChqIDwgc3RyaW5nc2VlZC5sZW5ndGgpIHtcbiAgICBrZXlbbWFzayAmIGpdID1cbiAgICAgIG1hc2sgJiAoKHNtZWFyIF49IGtleVttYXNrICYgal0gKiAxOSkgKyBzdHJpbmdzZWVkLmNoYXJDb2RlQXQoaisrKSk7XG4gIH1cbiAgcmV0dXJuIHRvc3RyaW5nKGtleSk7XG59XG5cbi8vXG4vLyBhdXRvc2VlZCgpXG4vLyBSZXR1cm5zIGFuIG9iamVjdCBmb3IgYXV0b3NlZWRpbmcsIHVzaW5nIHdpbmRvdy5jcnlwdG8gYW5kIE5vZGUgY3J5cHRvXG4vLyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuLy9cbmZ1bmN0aW9uIGF1dG9zZWVkKCkge1xuICB0cnkge1xuICAgIHZhciBvdXQ7XG4gICAgaWYgKG5vZGVjcnlwdG8gJiYgKG91dCA9IG5vZGVjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XG4gICAgICAvLyBUaGUgdXNlIG9mICdvdXQnIHRvIHJlbWVtYmVyIHJhbmRvbUJ5dGVzIG1ha2VzIHRpZ2h0IG1pbmlmaWVkIGNvZGUuXG4gICAgICBvdXQgPSBvdXQod2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBuZXcgVWludDhBcnJheSh3aWR0aCk7XG4gICAgICAoZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyhvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9zdHJpbmcob3V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBicm93c2VyID0gZ2xvYmFsLm5hdmlnYXRvcixcbiAgICAgICAgcGx1Z2lucyA9IGJyb3dzZXIgJiYgYnJvd3Nlci5wbHVnaW5zO1xuICAgIHJldHVybiBbK25ldyBEYXRlLCBnbG9iYWwsIHBsdWdpbnMsIGdsb2JhbC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcbiAgfVxufVxuXG4vL1xuLy8gdG9zdHJpbmcoKVxuLy8gQ29udmVydHMgYW4gYXJyYXkgb2YgY2hhcmNvZGVzIHRvIGEgc3RyaW5nXG4vL1xuZnVuY3Rpb24gdG9zdHJpbmcoYSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLCBhKTtcbn1cblxuLy9cbi8vIFdoZW4gc2VlZHJhbmRvbS5qcyBpcyBsb2FkZWQsIHdlIGltbWVkaWF0ZWx5IG1peCBhIGZldyBiaXRzXG4vLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuLy8gbm90IHdhbnQgdG8gaW50ZXJmZXJlIHdpdGggZGV0ZXJtaW5pc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxuLy8gc2VlZHJhbmRvbSB3aWxsIG5vdCBjYWxsIG1hdGgucmFuZG9tIG9uIGl0cyBvd24gYWdhaW4gYWZ0ZXJcbi8vIGluaXRpYWxpemF0aW9uLlxuLy9cbm1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcblxuLy9cbi8vIE5vZGVqcyBhbmQgQU1EIHN1cHBvcnQ6IGV4cG9ydCB0aGUgaW1wbGVtZW50YXRpb24gYXMgYSBtb2R1bGUgdXNpbmdcbi8vIGVpdGhlciBjb252ZW50aW9uLlxuLy9cbmlmICgodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBzZWVkcmFuZG9tO1xuICAvLyBXaGVuIGluIG5vZGUuanMsIHRyeSB1c2luZyBjcnlwdG8gcGFja2FnZSBmb3IgYXV0b3NlZWRpbmcuXG4gIHRyeSB7XG4gICAgbm9kZWNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICB9IGNhdGNoIChleCkge31cbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBzZWVkcmFuZG9tOyB9KTtcbn1cblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KShcbiAgW10sICAgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIE1hdGggICAgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuKTtcbiIsIiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiJdfQ==
