(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
const tf = require('@tensorflow/tfjs')


testing = true

if(testing){
  window.tf = tf
  /*
  var s = 10 
  var eye = tf.eye(s).mul(tf.scalar(1))
  eye = eye.matMul(createRollMatrix(s, -1))
  eye.print()
  eye = tf.batchNormalization(eye,tf.zerosLike(eye), tf.onesLike(eye).mul(tf.tensor([1])))//.print()
  eye.print()
  var bb = orthoNormal({shape:[12,12], mean:1, dev:2}) 
  var bbb = orthoUniform({shape: [6, 12], min:-1, max:1})
  console.log(b)
  b.print()
  bb.print()
  bbb.print()
  let c = b.slice([0,0],1)
  let d = bb.slice([1,0], 1)
  let e = bbb.slice([2,0], 1)
  d.print()
  c.print()
  c.dot(d.transpose()).print()
  e.matMul(c.transpose()).print()
  d.matMul(e.transpose()).print()
  */
  var b = orthoTruncated({shape: [2,12], mean:1, dev:2}) 
  b.print()
  b.transpose().print()
  let i = 1, j = 4, k = 2, l = 8 
  var t = tf.stack([tf.ones([i,j],'float32'), tf.reshape(tf.linspace(0, 1, 4), [i,j])],0).squeeze()
  console.log(t)
  var x = orthoNormal({shape: [j,l]})//.print()
  var y = orthoNormal({shape: [j,l]})//.print()
  x.print()
  y.print()
  t.print()
  //x = tf.concat([y, x], 1)
  x.print()
  tf.matMul(t ,x ).print()
}



// ex: input will be 256 samples + time, topology will be default with array of dense unit layers
// and for experiments, the latent_spacetime is known, shared across distributed and disparate training sessions
// noting that an evolutionary algorithm for possibly finding latent_spacetime that is somehow better adoapted to the whole
// and then there is the study of comparative spacetimes, to see what's out there

var ortholizers = {orthoUniform, orthoTruncated, orthoNormal}

let input_shape = [2, 256] // first row is signal, second is time, this is a 2d flattened [1,256,2]
let topology =  [1024, 512, 256, 128, 64, 32, 16]
// it seems like the first should be bigger than input_shape[1]
// or maybe don't use orthos all the way?  only beginning and end? or only end?

// try first one filter for both the signal and time (to correlate them), ergo one dimension of 2d output instead of [16,16, 2]
let latent_spacetime = orthoNormal({shape: [16, 16]})

let elTopo = vaejs({input_shape, topology, latent_spacetime})
var xt = tf.ones(input_shape)
var {out, pre} = elTopo(xt)
pre.print()
out.print()

function vaejs({input_shape, topology, latent_spacetime}){
  // an array of functions, or a reduce into a fancy fuction?
  var lastOutput = input_shape[1] 
  var topo = topology.reduce((a,e,i,o) => {
    let units = e
    let shape = [lastOutput, e] 

    // if the the unit size is larger than the last output
    // expand the dimensionality through orthogonal space
    // else use a regular random weight... why not?
    var tensor
    if(lastOutput < e) tensor = orthoNormal({shape})
    else tensor = randomNormal({shape}) // createDenseOrthogon({shape})
    lastOutput = e
    let fn = a
    return function(input){
      var output = fn(input)
      return output.matMul(tensor)
    }}, function(input){
      return input
  })    

  return function(input){
    let pre = topo(input)
    let out = pre.matMul(latent_spacetime)
    return {out, pre}
  }

}


async function nextTick(fn){ await tf.nextFrame(); fn()}




//Â¿ cruel and unnecessary abstraction ?
function createDenseOrthogon({shape, init='orthoNormal', min=-1, max=1, mean=0, dev=1, dtype='float32'}){
  return ortholizers[init](arguments)
}

function orthoUniform({shape, min=-1, max=1, type='float32'}){
  return tf.linalg.gramSchmidt(tf.randomUniform(shape, min, max, type))
}

function orthoTruncated({shape, mean=0, dev=1, type='float32'}){
  return tf.linalg.gramSchmidt(tf.truncatedNormal(shape, mean, dev, type))
}

function randomNormal({shape, mean=0, dev=1, type='float32'}){
  return tf.randomNormal(shape, mean, dev, type)
}

function orthoNormal({shape, mean=0, dev=1, type='float32'}){
  return tf.linalg.gramSchmidt(tf.randomNormal(shape, mean, dev, type))
}

function createRollMatrix(s, t){

  return roll(s, t)

  function roll(s, t){ 
    l = s * s
    var one = t > 0 ? rollRightOne(l) : rollLeftOne(Math.abs(l))
    var rm = tf.eye(Math.sqrt(l))
    for(var x = 0; x < Math.abs(t); x++){
       rm = tf.matMul(rm, one)
    }
    return rm
  }

  function rollLeftOne(l){
    var a = new Float32Array(l)
    var n = Math.sqrt(l)
    a.fill(0)
    a.forEach((e,i,a) => (i - n) % (n + 1) === 0 ? a[i] = 1 : a[i] = 0)
    a[n - 1] = 1
    return tf.tensor(a, [n,n], 'float32')
  }

  function rollRightOne(l){
    var a = new Float32Array(l)
    var n = Math.sqrt(l)
    a.fill(0)
    a.forEach((e,i,a) => (i - 1) % (n + 1) === 0 ? a[i] = 1 : a[i] = 0)
    a[l - n] = 1
    return tf.tensor(a, [n,n], 'float32')
  }

}

},{"@tensorflow/tfjs":195}],2:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],3:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],6:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],9:[function(require,module,exports){
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

var $Reader = $protobuf.Reader, $util = $protobuf.util;

var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.tensorflow = (function() {

    var tensorflow = {};

    tensorflow.Any = (function() {

        function Any(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Any.prototype.typeUrl = "";
        Any.prototype.value = $util.newBuffer([]);

        Any.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.Any();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.typeUrl = r.string();
                    break;
                case 2:
                    m.value = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Any;
    })();

    tensorflow.DataType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DT_INVALID"] = 0;
        values[valuesById[1] = "DT_FLOAT"] = 1;
        values[valuesById[2] = "DT_DOUBLE"] = 2;
        values[valuesById[3] = "DT_INT32"] = 3;
        values[valuesById[4] = "DT_UINT8"] = 4;
        values[valuesById[5] = "DT_INT16"] = 5;
        values[valuesById[6] = "DT_INT8"] = 6;
        values[valuesById[7] = "DT_STRING"] = 7;
        values[valuesById[8] = "DT_COMPLEX64"] = 8;
        values[valuesById[9] = "DT_INT64"] = 9;
        values[valuesById[10] = "DT_BOOL"] = 10;
        values[valuesById[11] = "DT_QINT8"] = 11;
        values[valuesById[12] = "DT_QUINT8"] = 12;
        values[valuesById[13] = "DT_QINT32"] = 13;
        values[valuesById[14] = "DT_BFLOAT16"] = 14;
        values[valuesById[101] = "DT_FLOAT_REF"] = 101;
        values[valuesById[102] = "DT_DOUBLE_REF"] = 102;
        values[valuesById[103] = "DT_INT32_REF"] = 103;
        values[valuesById[104] = "DT_UINT8_REF"] = 104;
        values[valuesById[105] = "DT_INT16_REF"] = 105;
        values[valuesById[106] = "DT_INT8_REF"] = 106;
        values[valuesById[107] = "DT_STRING_REF"] = 107;
        values[valuesById[108] = "DT_COMPLEX64_REF"] = 108;
        values[valuesById[109] = "DT_INT64_REF"] = 109;
        values[valuesById[110] = "DT_BOOL_REF"] = 110;
        values[valuesById[111] = "DT_QINT8_REF"] = 111;
        values[valuesById[112] = "DT_QUINT8_REF"] = 112;
        values[valuesById[113] = "DT_QINT32_REF"] = 113;
        values[valuesById[114] = "DT_BFLOAT16_REF"] = 114;
        return values;
    })();

    tensorflow.TensorShape = (function() {

        function TensorShape(p) {
            this.dim = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        TensorShape.prototype.dim = $util.emptyArray;
        TensorShape.prototype.unknownRank = false;

        TensorShape.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorShape();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    if (!(m.dim && m.dim.length))
                        m.dim = [];
                    m.dim.push($root.tensorflow.TensorShape.Dim.decode(r, r.uint32()));
                    break;
                case 3:
                    m.unknownRank = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        TensorShape.Dim = (function() {

            function Dim(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Dim.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            Dim.prototype.name = "";

            Dim.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorShape.Dim();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.size = r.int64();
                        break;
                    case 2:
                        m.name = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Dim;
        })();

        return TensorShape;
    })();

    tensorflow.Tensor = (function() {

        function Tensor(p) {
            this.floatVal = [];
            this.doubleVal = [];
            this.intVal = [];
            this.stringVal = [];
            this.scomplexVal = [];
            this.int64Val = [];
            this.boolVal = [];
            this.uint32Val = [];
            this.uint64Val = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        Tensor.prototype.dtype = 0;
        Tensor.prototype.tensorShape = null;
        Tensor.prototype.versionNumber = 0;
        Tensor.prototype.tensorContent = $util.newBuffer([]);
        Tensor.prototype.floatVal = $util.emptyArray;
        Tensor.prototype.doubleVal = $util.emptyArray;
        Tensor.prototype.intVal = $util.emptyArray;
        Tensor.prototype.stringVal = $util.emptyArray;
        Tensor.prototype.scomplexVal = $util.emptyArray;
        Tensor.prototype.int64Val = $util.emptyArray;
        Tensor.prototype.boolVal = $util.emptyArray;
        Tensor.prototype.uint32Val = $util.emptyArray;
        Tensor.prototype.uint64Val = $util.emptyArray;

        Tensor.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.Tensor();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.dtype = r.int32();
                    break;
                case 2:
                    m.tensorShape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                case 3:
                    m.versionNumber = r.int32();
                    break;
                case 4:
                    m.tensorContent = r.bytes();
                    break;
                case 5:
                    if (!(m.floatVal && m.floatVal.length))
                        m.floatVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.floatVal.push(r.float());
                    } else
                        m.floatVal.push(r.float());
                    break;
                case 6:
                    if (!(m.doubleVal && m.doubleVal.length))
                        m.doubleVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.doubleVal.push(r.double());
                    } else
                        m.doubleVal.push(r.double());
                    break;
                case 7:
                    if (!(m.intVal && m.intVal.length))
                        m.intVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.intVal.push(r.int32());
                    } else
                        m.intVal.push(r.int32());
                    break;
                case 8:
                    if (!(m.stringVal && m.stringVal.length))
                        m.stringVal = [];
                    m.stringVal.push(r.bytes());
                    break;
                case 9:
                    if (!(m.scomplexVal && m.scomplexVal.length))
                        m.scomplexVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.scomplexVal.push(r.float());
                    } else
                        m.scomplexVal.push(r.float());
                    break;
                case 10:
                    if (!(m.int64Val && m.int64Val.length))
                        m.int64Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.int64Val.push(r.int64());
                    } else
                        m.int64Val.push(r.int64());
                    break;
                case 11:
                    if (!(m.boolVal && m.boolVal.length))
                        m.boolVal = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.boolVal.push(r.bool());
                    } else
                        m.boolVal.push(r.bool());
                    break;
                case 16:
                    if (!(m.uint32Val && m.uint32Val.length))
                        m.uint32Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.uint32Val.push(r.uint32());
                    } else
                        m.uint32Val.push(r.uint32());
                    break;
                case 17:
                    if (!(m.uint64Val && m.uint64Val.length))
                        m.uint64Val = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.uint64Val.push(r.uint64());
                    } else
                        m.uint64Val.push(r.uint64());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Tensor;
    })();

    tensorflow.AttrValue = (function() {

        function AttrValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        AttrValue.prototype.list = null;
        AttrValue.prototype.s = $util.newBuffer([]);
        AttrValue.prototype.i = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        AttrValue.prototype.f = 0;
        AttrValue.prototype.b = false;
        AttrValue.prototype.type = 0;
        AttrValue.prototype.shape = null;
        AttrValue.prototype.tensor = null;
        AttrValue.prototype.placeholder = "";
        AttrValue.prototype.func = null;

        var $oneOfFields;

        Object.defineProperty(AttrValue.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["list", "s", "i", "f", "b", "type", "shape", "tensor", "placeholder", "func"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        AttrValue.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AttrValue();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.list = $root.tensorflow.AttrValue.ListValue.decode(r, r.uint32());
                    break;
                case 2:
                    m.s = r.bytes();
                    break;
                case 3:
                    m.i = r.int64();
                    break;
                case 4:
                    m.f = r.float();
                    break;
                case 5:
                    m.b = r.bool();
                    break;
                case 6:
                    m.type = r.int32();
                    break;
                case 7:
                    m.shape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                case 8:
                    m.tensor = $root.tensorflow.Tensor.decode(r, r.uint32());
                    break;
                case 9:
                    m.placeholder = r.string();
                    break;
                case 10:
                    m.func = $root.tensorflow.NameAttrList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        AttrValue.ListValue = (function() {

            function ListValue(p) {
                this.s = [];
                this.i = [];
                this.f = [];
                this.b = [];
                this.type = [];
                this.shape = [];
                this.tensor = [];
                this.func = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            ListValue.prototype.s = $util.emptyArray;
            ListValue.prototype.i = $util.emptyArray;
            ListValue.prototype.f = $util.emptyArray;
            ListValue.prototype.b = $util.emptyArray;
            ListValue.prototype.type = $util.emptyArray;
            ListValue.prototype.shape = $util.emptyArray;
            ListValue.prototype.tensor = $util.emptyArray;
            ListValue.prototype.func = $util.emptyArray;

            ListValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AttrValue.ListValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 2:
                        if (!(m.s && m.s.length))
                            m.s = [];
                        m.s.push(r.bytes());
                        break;
                    case 3:
                        if (!(m.i && m.i.length))
                            m.i = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.i.push(r.int64());
                        } else
                            m.i.push(r.int64());
                        break;
                    case 4:
                        if (!(m.f && m.f.length))
                            m.f = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.f.push(r.float());
                        } else
                            m.f.push(r.float());
                        break;
                    case 5:
                        if (!(m.b && m.b.length))
                            m.b = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.b.push(r.bool());
                        } else
                            m.b.push(r.bool());
                        break;
                    case 6:
                        if (!(m.type && m.type.length))
                            m.type = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.type.push(r.int32());
                        } else
                            m.type.push(r.int32());
                        break;
                    case 7:
                        if (!(m.shape && m.shape.length))
                            m.shape = [];
                        m.shape.push($root.tensorflow.TensorShape.decode(r, r.uint32()));
                        break;
                    case 8:
                        if (!(m.tensor && m.tensor.length))
                            m.tensor = [];
                        m.tensor.push($root.tensorflow.Tensor.decode(r, r.uint32()));
                        break;
                    case 9:
                        if (!(m.func && m.func.length))
                            m.func = [];
                        m.func.push($root.tensorflow.NameAttrList.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ListValue;
        })();

        return AttrValue;
    })();

    tensorflow.NameAttrList = (function() {

        function NameAttrList(p) {
            this.attr = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        NameAttrList.prototype.name = "";
        NameAttrList.prototype.attr = $util.emptyObject;

        NameAttrList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.NameAttrList(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NameAttrList;
    })();

    tensorflow.NodeDef = (function() {

        function NodeDef(p) {
            this.input = [];
            this.attr = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        NodeDef.prototype.name = "";
        NodeDef.prototype.op = "";
        NodeDef.prototype.input = $util.emptyArray;
        NodeDef.prototype.device = "";
        NodeDef.prototype.attr = $util.emptyObject;

        NodeDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.NodeDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    m.op = r.string();
                    break;
                case 3:
                    if (!(m.input && m.input.length))
                        m.input = [];
                    m.input.push(r.string());
                    break;
                case 4:
                    m.device = r.string();
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NodeDef;
    })();

    tensorflow.VersionDef = (function() {

        function VersionDef(p) {
            this.badConsumers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        VersionDef.prototype.producer = 0;
        VersionDef.prototype.minConsumer = 0;
        VersionDef.prototype.badConsumers = $util.emptyArray;

        VersionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.VersionDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.producer = r.int32();
                    break;
                case 2:
                    m.minConsumer = r.int32();
                    break;
                case 3:
                    if (!(m.badConsumers && m.badConsumers.length))
                        m.badConsumers = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.badConsumers.push(r.int32());
                    } else
                        m.badConsumers.push(r.int32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return VersionDef;
    })();

    tensorflow.GraphDef = (function() {

        function GraphDef(p) {
            this.node = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        GraphDef.prototype.node = $util.emptyArray;
        GraphDef.prototype.versions = null;
        GraphDef.prototype.library = null;

        GraphDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.GraphDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.node && m.node.length))
                        m.node = [];
                    m.node.push($root.tensorflow.NodeDef.decode(r, r.uint32()));
                    break;
                case 4:
                    m.versions = $root.tensorflow.VersionDef.decode(r, r.uint32());
                    break;
                case 2:
                    m.library = $root.tensorflow.FunctionDefLibrary.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GraphDef;
    })();

    tensorflow.CollectionDef = (function() {

        function CollectionDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        CollectionDef.prototype.nodeList = null;
        CollectionDef.prototype.bytesList = null;
        CollectionDef.prototype.int64List = null;
        CollectionDef.prototype.floatList = null;
        CollectionDef.prototype.anyList = null;

        var $oneOfFields;

        Object.defineProperty(CollectionDef.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["nodeList", "bytesList", "int64List", "floatList", "anyList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        CollectionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.nodeList = $root.tensorflow.CollectionDef.NodeList.decode(r, r.uint32());
                    break;
                case 2:
                    m.bytesList = $root.tensorflow.CollectionDef.BytesList.decode(r, r.uint32());
                    break;
                case 3:
                    m.int64List = $root.tensorflow.CollectionDef.Int64List.decode(r, r.uint32());
                    break;
                case 4:
                    m.floatList = $root.tensorflow.CollectionDef.FloatList.decode(r, r.uint32());
                    break;
                case 5:
                    m.anyList = $root.tensorflow.CollectionDef.AnyList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        CollectionDef.NodeList = (function() {

            function NodeList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            NodeList.prototype.value = $util.emptyArray;

            NodeList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.NodeList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push(r.string());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return NodeList;
        })();

        CollectionDef.BytesList = (function() {

            function BytesList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            BytesList.prototype.value = $util.emptyArray;

            BytesList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.BytesList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push(r.bytes());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BytesList;
        })();

        CollectionDef.Int64List = (function() {

            function Int64List(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            Int64List.prototype.value = $util.emptyArray;

            Int64List.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.Int64List();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.value.push(r.int64());
                        } else
                            m.value.push(r.int64());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int64List;
        })();

        CollectionDef.FloatList = (function() {

            function FloatList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            FloatList.prototype.value = $util.emptyArray;

            FloatList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.FloatList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        if ((t & 7) === 2) {
                            var c2 = r.uint32() + r.pos;
                            while (r.pos < c2)
                                m.value.push(r.float());
                        } else
                            m.value.push(r.float());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return FloatList;
        })();

        CollectionDef.AnyList = (function() {

            function AnyList(p) {
                this.value = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            AnyList.prototype.value = $util.emptyArray;

            AnyList.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.AnyList();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        if (!(m.value && m.value.length))
                            m.value = [];
                        m.value.push($root.tensorflow.Any.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return AnyList;
        })();

        return CollectionDef;
    })();

    tensorflow.SaverDef = (function() {

        function SaverDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SaverDef.prototype.filenameTensorName = "";
        SaverDef.prototype.saveTensorName = "";
        SaverDef.prototype.restoreOpName = "";
        SaverDef.prototype.maxToKeep = 0;
        SaverDef.prototype.sharded = false;
        SaverDef.prototype.keepCheckpointEveryNHours = 0;
        SaverDef.prototype.version = 0;

        SaverDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SaverDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.filenameTensorName = r.string();
                    break;
                case 2:
                    m.saveTensorName = r.string();
                    break;
                case 3:
                    m.restoreOpName = r.string();
                    break;
                case 4:
                    m.maxToKeep = r.int32();
                    break;
                case 5:
                    m.sharded = r.bool();
                    break;
                case 6:
                    m.keepCheckpointEveryNHours = r.float();
                    break;
                case 7:
                    m.version = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        SaverDef.CheckpointFormatVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LEGACY"] = 0;
            values[valuesById[1] = "V1"] = 1;
            values[valuesById[2] = "V2"] = 2;
            return values;
        })();

        return SaverDef;
    })();

    tensorflow.TensorInfo = (function() {

        function TensorInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        TensorInfo.prototype.name = "";
        TensorInfo.prototype.cooSparse = null;
        TensorInfo.prototype.dtype = 0;
        TensorInfo.prototype.tensorShape = null;

        var $oneOfFields;

        Object.defineProperty(TensorInfo.prototype, "encoding", {
            get: $util.oneOfGetter($oneOfFields = ["name", "cooSparse"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        TensorInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 4:
                    m.cooSparse = $root.tensorflow.TensorInfo.CooSparse.decode(r, r.uint32());
                    break;
                case 2:
                    m.dtype = r.int32();
                    break;
                case 3:
                    m.tensorShape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        TensorInfo.CooSparse = (function() {

            function CooSparse(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            CooSparse.prototype.valuesTensorName = "";
            CooSparse.prototype.indicesTensorName = "";
            CooSparse.prototype.denseShapeTensorName = "";

            CooSparse.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorInfo.CooSparse();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.valuesTensorName = r.string();
                        break;
                    case 2:
                        m.indicesTensorName = r.string();
                        break;
                    case 3:
                        m.denseShapeTensorName = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return CooSparse;
        })();

        return TensorInfo;
    })();

    tensorflow.SignatureDef = (function() {

        function SignatureDef(p) {
            this.inputs = {};
            this.outputs = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SignatureDef.prototype.inputs = $util.emptyObject;
        SignatureDef.prototype.outputs = $util.emptyObject;
        SignatureDef.prototype.methodName = "";

        SignatureDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SignatureDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    r.skip().pos++;
                    if (m.inputs === $util.emptyObject)
                        m.inputs = {};
                    k = r.string();
                    r.pos++;
                    m.inputs[k] = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 2:
                    r.skip().pos++;
                    if (m.outputs === $util.emptyObject)
                        m.outputs = {};
                    k = r.string();
                    r.pos++;
                    m.outputs[k] = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 3:
                    m.methodName = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignatureDef;
    })();

    tensorflow.AssetFileDef = (function() {

        function AssetFileDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        AssetFileDef.prototype.tensorInfo = null;
        AssetFileDef.prototype.filename = "";

        AssetFileDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AssetFileDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tensorInfo = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                    break;
                case 2:
                    m.filename = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AssetFileDef;
    })();

    tensorflow.OpDef = (function() {

        function OpDef(p) {
            this.inputArg = [];
            this.outputArg = [];
            this.attr = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        OpDef.prototype.name = "";
        OpDef.prototype.inputArg = $util.emptyArray;
        OpDef.prototype.outputArg = $util.emptyArray;
        OpDef.prototype.attr = $util.emptyArray;
        OpDef.prototype.deprecation = null;
        OpDef.prototype.summary = "";
        OpDef.prototype.description = "";
        OpDef.prototype.isCommutative = false;
        OpDef.prototype.isAggregate = false;
        OpDef.prototype.isStateful = false;
        OpDef.prototype.allowsUninitializedInput = false;

        OpDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    if (!(m.inputArg && m.inputArg.length))
                        m.inputArg = [];
                    m.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(r, r.uint32()));
                    break;
                case 3:
                    if (!(m.outputArg && m.outputArg.length))
                        m.outputArg = [];
                    m.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(r, r.uint32()));
                    break;
                case 4:
                    if (!(m.attr && m.attr.length))
                        m.attr = [];
                    m.attr.push($root.tensorflow.OpDef.AttrDef.decode(r, r.uint32()));
                    break;
                case 8:
                    m.deprecation = $root.tensorflow.OpDef.OpDeprecation.decode(r, r.uint32());
                    break;
                case 5:
                    m.summary = r.string();
                    break;
                case 6:
                    m.description = r.string();
                    break;
                case 18:
                    m.isCommutative = r.bool();
                    break;
                case 16:
                    m.isAggregate = r.bool();
                    break;
                case 17:
                    m.isStateful = r.bool();
                    break;
                case 19:
                    m.allowsUninitializedInput = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        OpDef.ArgDef = (function() {

            function ArgDef(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            ArgDef.prototype.name = "";
            ArgDef.prototype.description = "";
            ArgDef.prototype.type = 0;
            ArgDef.prototype.typeAttr = "";
            ArgDef.prototype.numberAttr = "";
            ArgDef.prototype.typeListAttr = "";
            ArgDef.prototype.isRef = false;

            ArgDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.ArgDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.name = r.string();
                        break;
                    case 2:
                        m.description = r.string();
                        break;
                    case 3:
                        m.type = r.int32();
                        break;
                    case 4:
                        m.typeAttr = r.string();
                        break;
                    case 5:
                        m.numberAttr = r.string();
                        break;
                    case 6:
                        m.typeListAttr = r.string();
                        break;
                    case 16:
                        m.isRef = r.bool();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ArgDef;
        })();

        OpDef.AttrDef = (function() {

            function AttrDef(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            AttrDef.prototype.name = "";
            AttrDef.prototype.type = "";
            AttrDef.prototype.defaultValue = null;
            AttrDef.prototype.description = "";
            AttrDef.prototype.hasMinimum = false;
            AttrDef.prototype.minimum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
            AttrDef.prototype.allowedValues = null;

            AttrDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.AttrDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.name = r.string();
                        break;
                    case 2:
                        m.type = r.string();
                        break;
                    case 3:
                        m.defaultValue = $root.tensorflow.AttrValue.decode(r, r.uint32());
                        break;
                    case 4:
                        m.description = r.string();
                        break;
                    case 5:
                        m.hasMinimum = r.bool();
                        break;
                    case 6:
                        m.minimum = r.int64();
                        break;
                    case 7:
                        m.allowedValues = $root.tensorflow.AttrValue.decode(r, r.uint32());
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return AttrDef;
        })();

        OpDef.OpDeprecation = (function() {

            function OpDeprecation(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            OpDeprecation.prototype.version = 0;
            OpDeprecation.prototype.explanation = "";

            OpDeprecation.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.OpDeprecation();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.version = r.int32();
                        break;
                    case 2:
                        m.explanation = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return OpDeprecation;
        })();

        return OpDef;
    })();

    tensorflow.OpList = (function() {

        function OpList(p) {
            this.op = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        OpList.prototype.op = $util.emptyArray;

        OpList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.op && m.op.length))
                        m.op = [];
                    m.op.push($root.tensorflow.OpDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return OpList;
    })();

    tensorflow.MetaGraphDef = (function() {

        function MetaGraphDef(p) {
            this.collectionDef = {};
            this.signatureDef = {};
            this.assetFileDef = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        MetaGraphDef.prototype.metaInfoDef = null;
        MetaGraphDef.prototype.graphDef = null;
        MetaGraphDef.prototype.saverDef = null;
        MetaGraphDef.prototype.collectionDef = $util.emptyObject;
        MetaGraphDef.prototype.signatureDef = $util.emptyObject;
        MetaGraphDef.prototype.assetFileDef = $util.emptyArray;

        MetaGraphDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.MetaGraphDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.metaInfoDef = $root.tensorflow.MetaGraphDef.MetaInfoDef.decode(r, r.uint32());
                    break;
                case 2:
                    m.graphDef = $root.tensorflow.GraphDef.decode(r, r.uint32());
                    break;
                case 3:
                    m.saverDef = $root.tensorflow.SaverDef.decode(r, r.uint32());
                    break;
                case 4:
                    r.skip().pos++;
                    if (m.collectionDef === $util.emptyObject)
                        m.collectionDef = {};
                    k = r.string();
                    r.pos++;
                    m.collectionDef[k] = $root.tensorflow.CollectionDef.decode(r, r.uint32());
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.signatureDef === $util.emptyObject)
                        m.signatureDef = {};
                    k = r.string();
                    r.pos++;
                    m.signatureDef[k] = $root.tensorflow.SignatureDef.decode(r, r.uint32());
                    break;
                case 6:
                    if (!(m.assetFileDef && m.assetFileDef.length))
                        m.assetFileDef = [];
                    m.assetFileDef.push($root.tensorflow.AssetFileDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        MetaGraphDef.MetaInfoDef = (function() {

            function MetaInfoDef(p) {
                this.tags = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            MetaInfoDef.prototype.metaGraphVersion = "";
            MetaInfoDef.prototype.strippedOpList = null;
            MetaInfoDef.prototype.anyInfo = null;
            MetaInfoDef.prototype.tags = $util.emptyArray;
            MetaInfoDef.prototype.tensorflowVersion = "";
            MetaInfoDef.prototype.tensorflowGitVersion = "";

            MetaInfoDef.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.MetaGraphDef.MetaInfoDef();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.metaGraphVersion = r.string();
                        break;
                    case 2:
                        m.strippedOpList = $root.tensorflow.OpList.decode(r, r.uint32());
                        break;
                    case 3:
                        m.anyInfo = $root.tensorflow.Any.decode(r, r.uint32());
                        break;
                    case 4:
                        if (!(m.tags && m.tags.length))
                            m.tags = [];
                        m.tags.push(r.string());
                        break;
                    case 5:
                        m.tensorflowVersion = r.string();
                        break;
                    case 6:
                        m.tensorflowGitVersion = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return MetaInfoDef;
        })();

        return MetaGraphDef;
    })();

    tensorflow.SavedModel = (function() {

        function SavedModel(p) {
            this.metaGraphs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        SavedModel.prototype.savedModelSchemaVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
        SavedModel.prototype.metaGraphs = $util.emptyArray;

        SavedModel.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SavedModel();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.savedModelSchemaVersion = r.int64();
                    break;
                case 2:
                    if (!(m.metaGraphs && m.metaGraphs.length))
                        m.metaGraphs = [];
                    m.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SavedModel;
    })();

    tensorflow.FunctionDefLibrary = (function() {

        function FunctionDefLibrary(p) {
            this["function"] = [];
            this.gradient = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        FunctionDefLibrary.prototype["function"] = $util.emptyArray;
        FunctionDefLibrary.prototype.gradient = $util.emptyArray;

        FunctionDefLibrary.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.FunctionDefLibrary();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m["function"] && m["function"].length))
                        m["function"] = [];
                    m["function"].push($root.tensorflow.FunctionDef.decode(r, r.uint32()));
                    break;
                case 2:
                    if (!(m.gradient && m.gradient.length))
                        m.gradient = [];
                    m.gradient.push($root.tensorflow.GradientDef.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FunctionDefLibrary;
    })();

    tensorflow.FunctionDef = (function() {

        function FunctionDef(p) {
            this.attr = {};
            this.nodeDef = [];
            this.ret = {};
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        FunctionDef.prototype.signature = null;
        FunctionDef.prototype.attr = $util.emptyObject;
        FunctionDef.prototype.nodeDef = $util.emptyArray;
        FunctionDef.prototype.ret = $util.emptyObject;

        FunctionDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.FunctionDef(), k;
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.signature = $root.tensorflow.OpDef.decode(r, r.uint32());
                    break;
                case 5:
                    r.skip().pos++;
                    if (m.attr === $util.emptyObject)
                        m.attr = {};
                    k = r.string();
                    r.pos++;
                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                    break;
                case 3:
                    if (!(m.nodeDef && m.nodeDef.length))
                        m.nodeDef = [];
                    m.nodeDef.push($root.tensorflow.NodeDef.decode(r, r.uint32()));
                    break;
                case 4:
                    r.skip().pos++;
                    if (m.ret === $util.emptyObject)
                        m.ret = {};
                    k = r.string();
                    r.pos++;
                    m.ret[k] = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FunctionDef;
    })();

    tensorflow.GradientDef = (function() {

        function GradientDef(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        GradientDef.prototype.functionName = "";
        GradientDef.prototype.gradientFunc = "";

        GradientDef.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.GradientDef();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.functionName = r.string();
                    break;
                case 2:
                    m.gradientFunc = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GradientDef;
    })();

    return tensorflow;
})();

module.exports = $root;

},{"protobufjs/minimal":197}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ExecutionContext = (function () {
    function ExecutionContext(weightMap) {
        this.weightMap = weightMap;
        this.rootContext = { id: 0, frameName: '', iterationId: 0 };
        this.contexts = [this.rootContext];
        this.lastId = 0;
        this.generateCurrentContextIds();
    }
    ExecutionContext.prototype.newFrame = function (id, frameName) {
        return { id: id, frameName: frameName, iterationId: 0 };
    };
    Object.defineProperty(ExecutionContext.prototype, "currentContext", {
        get: function () {
            return this.contexts;
        },
        set: function (contexts) {
            if (this.contexts !== contexts) {
                this.contexts = contexts;
                this.generateCurrentContextIds();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExecutionContext.prototype, "currentContextId", {
        get: function () {
            return this._currentContextIds[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExecutionContext.prototype, "currentContextIds", {
        get: function () {
            return this._currentContextIds;
        },
        enumerable: true,
        configurable: true
    });
    ExecutionContext.prototype.generateCurrentContextIds = function () {
        var names = [];
        for (var i = 0; i < this.contexts.length - 1; i++) {
            var contexts = this.contexts.slice(0, this.contexts.length - i);
            names.push(this.contextIdforContexts(contexts));
        }
        names.push('');
        this._currentContextIds = names;
    };
    ExecutionContext.prototype.contextIdforContexts = function (contexts) {
        return contexts ?
            contexts
                .map(function (context) { return (context.id === 0 && context.iterationId === 0) ?
                '' :
                context.frameName + "-" + context.iterationId; })
                .join('/') :
            '';
    };
    ExecutionContext.prototype.enterFrame = function (frameId) {
        if (this.contexts) {
            this.lastId++;
            this.contexts = this.contexts.slice();
            this.contexts.push(this.newFrame(this.lastId, frameId));
            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
        }
    };
    ExecutionContext.prototype.exitFrame = function () {
        if (this.contexts && this.contexts.length > 1) {
            this.contexts = this.contexts.slice();
            this.contexts.splice(-1);
            this.currentContextIds.shift();
        }
        else {
            throw new Error('Cannot exit frame, the context is empty');
        }
    };
    ExecutionContext.prototype.nextIteration = function () {
        if (this.contexts && this.contexts.length > 0) {
            this.contexts = this.contexts.slice();
            this.lastId++;
            var context = Object.assign({}, this.contexts[this.contexts.length - 1]);
            context.iterationId += 1;
            context.id = this.lastId;
            this.contexts.splice(-1, 1, context);
            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
        }
        else {
            throw new Error('Cannot increase frame iteration, the context is empty');
        }
    };
    ExecutionContext.prototype.getWeight = function (name) {
        return this.weightMap[name];
    };
    return ExecutionContext;
}());
exports.ExecutionContext = ExecutionContext;

},{}],11:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var Url = require("url");
var compiled_api_1 = require("../data/compiled_api");
var operation_mapper_1 = require("../operations/operation_mapper");
var graph_executor_1 = require("./graph_executor");
var FrozenModel = (function () {
    function FrozenModel(modelUrl, weightManifestUrl, requestOption) {
        this.modelUrl = modelUrl;
        this.weightManifestUrl = weightManifestUrl;
        this.requestOption = requestOption;
        this.version = 'n/a';
        this.pathPrefix = this.getPathPrefix();
    }
    Object.defineProperty(FrozenModel.prototype, "modelVersion", {
        get: function () {
            return this.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "inputNodes", {
        get: function () {
            return this.executor.inputNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrozenModel.prototype, "outputNodes", {
        get: function () {
            return this.executor.outputNodes;
        },
        enumerable: true,
        configurable: true
    });
    FrozenModel.prototype.getPathPrefix = function () {
        var url = Url.parse(this.weightManifestUrl);
        var segments = url.pathname.split('/');
        segments.splice(-1);
        url.pathname = segments.join('/');
        return Url.format(url) + '/';
    };
    FrozenModel.prototype.loadRemoteProtoFile = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, _a, _b, _c, error_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 3, , 4]);
                        return [4, fetch(this.modelUrl, this.requestOption)];
                    case 1:
                        response = _d.sent();
                        _b = (_a = compiled_api_1.tensorflow.GraphDef).decode;
                        _c = Uint8Array.bind;
                        return [4, response.arrayBuffer()];
                    case 2: return [2, _b.apply(_a, [new (_c.apply(Uint8Array, [void 0, _d.sent()]))()])];
                    case 3:
                        error_1 = _d.sent();
                        throw new Error(this.modelUrl + " not found. " + error_1);
                    case 4: return [2];
                }
            });
        });
    };
    FrozenModel.prototype.loadWeightManifest = function () {
        return __awaiter(this, void 0, void 0, function () {
            var manifest, _a, error_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 3, , 4]);
                        return [4, fetch(this.weightManifestUrl, this.requestOption)];
                    case 1:
                        manifest = _b.sent();
                        _a = this;
                        return [4, manifest.clone().json()];
                    case 2:
                        _a.weightManifest = _b.sent();
                        return [3, 4];
                    case 3:
                        error_2 = _b.sent();
                        throw new Error(this.weightManifestUrl + " not found. " + error_2);
                    case 4: return [2];
                }
            });
        });
    };
    FrozenModel.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var graphPromise, manifestPromise, graph, weightMap;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        graphPromise = this.loadRemoteProtoFile();
                        manifestPromise = this.loadWeightManifest();
                        return [4, Promise.all([graphPromise, manifestPromise])];
                    case 1:
                        graph = (_a.sent())[0];
                        this.version = graph.versions.producer + "." + graph.versions.minConsumer;
                        return [4, tfc.io.loadWeights(this.weightManifest, this.pathPrefix, undefined, this.requestOption)];
                    case 2:
                        weightMap = _a.sent();
                        this.executor =
                            new graph_executor_1.GraphExecutor(operation_mapper_1.OperationMapper.Instance.transformGraph(graph));
                        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
                        return [2, true];
                }
            });
        });
    };
    FrozenModel.prototype.predict = function (inputs, config) {
        return this.execute(inputs, this.outputNodes);
    };
    FrozenModel.prototype.constructTensorMap = function (inputs) {
        var inputArray = inputs instanceof tfc.Tensor ? [inputs] : inputs;
        if (inputArray.length !== this.inputNodes.length) {
            throw new Error('Input tensor count mismatch,' +
                ("the frozen model has " + this.inputNodes.length + " placeholders, ") +
                ("while there are " + inputArray.length + " input tensors."));
        }
        return this.inputNodes.reduce(function (map, inputName, i) {
            map[inputName] = inputArray[i];
            return map;
        }, {});
    };
    FrozenModel.prototype.execute = function (inputs, outputs) {
        outputs = outputs || this.outputNodes;
        if (inputs instanceof tfc.Tensor || Array.isArray(inputs)) {
            inputs = this.constructTensorMap(inputs);
        }
        if (this.executor.isControlFlowModel) {
            throw new Error('The model contains control flow ops, ' +
                'please use executeAsync method');
        }
        var result = this.executor.execute(this.convertTensorMapToTensorsMap(inputs), outputs);
        var keys = Object.keys(result);
        return (Array.isArray(outputs) && outputs.length > 1) ?
            outputs.map(function (node) { return result[node]; }) :
            result[keys[0]];
    };
    FrozenModel.prototype.executeAsync = function (inputs, outputs) {
        return __awaiter(this, void 0, void 0, function () {
            var result, keys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.executor.isControlFlowModel) {
                            throw new Error('The model does not contain control flow ops, ' +
                                'please use execute method for better performance.');
                        }
                        outputs = outputs || this.outputNodes;
                        if (inputs instanceof tfc.Tensor || Array.isArray(inputs)) {
                            inputs = this.constructTensorMap(inputs);
                        }
                        return [4, this.executor.executeAsync(this.convertTensorMapToTensorsMap(inputs), outputs)];
                    case 1:
                        result = _a.sent();
                        keys = Object.keys(result);
                        return [2, Array.isArray(outputs) && outputs.length > 1 ?
                                outputs.map(function (node) { return result[node]; }) :
                                result[keys[0]]];
                }
            });
        });
    };
    FrozenModel.prototype.convertTensorMapToTensorsMap = function (map) {
        return Object.keys(map).reduce(function (newMap, key) {
            newMap[key] = [map[key]];
            return newMap;
        }, {});
    };
    FrozenModel.prototype.dispose = function () {
        this.executor.dispose();
    };
    return FrozenModel;
}());
exports.FrozenModel = FrozenModel;
function loadFrozenModel(modelUrl, weightsManifestUrl, requestOption) {
    return __awaiter(this, void 0, void 0, function () {
        var model;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    model = new FrozenModel(modelUrl, weightsManifestUrl, requestOption);
                    return [4, model.load()];
                case 1:
                    _a.sent();
                    return [2, model];
            }
        });
    });
}
exports.loadFrozenModel = loadFrozenModel;

},{"../data/compiled_api":9,"../operations/operation_mapper":42,"./graph_executor":12,"@tensorflow/tfjs-core":51,"url":222}],12:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var utils_1 = require("../operations/executors/utils");
var operation_executor_1 = require("../operations/operation_executor");
var execution_context_1 = require("./execution_context");
var GraphExecutor = (function () {
    function GraphExecutor(graph) {
        this.graph = graph;
        this.compiledOrder = [];
        this._weightMap = {};
        this.placeholders = graph.placeholders.map(function (node) { return node.name; });
        this.outputs = graph.outputs.map(function (node) { return node.name; });
        this.compile();
    }
    Object.defineProperty(GraphExecutor.prototype, "weightMap", {
        get: function () {
            return this._weightMap;
        },
        set: function (weightMap) {
            var weightIds = Object.keys(weightMap).map(function (key) { return weightMap[key].map(function (tensor) { return tensor.id; }); });
            this.weightIds = [].concat.apply([], weightIds);
            this._weightMap = weightMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "inputNodes", {
        get: function () {
            return this.placeholders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "outputNodes", {
        get: function () {
            return this.outputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphExecutor.prototype, "isControlFlowModel", {
        get: function () {
            return this.graph.withControlFlow;
        },
        enumerable: true,
        configurable: true
    });
    GraphExecutor.prototype.compile = function () {
        if (this.graph.withControlFlow) {
            return;
        }
        var stack = this.graph.inputs.slice();
        var visited = {};
        while (stack.length > 0) {
            var node = stack.pop();
            visited[node.name] = true;
            this.compiledOrder.push(node);
            node.children.forEach(function (childNode) {
                if (!visited[childNode.name] && childNode.inputNames.every(function (name) {
                    var nodeName = utils_1.getNodeNameAndIndex(name)[0];
                    return visited[nodeName];
                })) {
                    stack.push(childNode);
                }
            });
        }
    };
    GraphExecutor.prototype.execute = function (inputs, outputs) {
        var _this = this;
        this.checkInput(inputs);
        var result = tfjs_core_1.tidy(function () {
            var context = new execution_context_1.ExecutionContext(_this._weightMap);
            var tensors = _this.compiledOrder.reduce(function (map, node) {
                map[node.name] = operation_executor_1.executeOp(node, map, context);
                return map;
            }, __assign({}, _this.weightMap, inputs));
            return _this.findOutputs(tensors, context, outputs);
        });
        return result;
    };
    GraphExecutor.prototype.executeAsync = function (inputs, outputs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var context, tensors, results, outputIds, inputIdArray, inputIds;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        context = new execution_context_1.ExecutionContext(this._weightMap);
                        return [4, this.executeWithControlFlow(inputs, context)];
                    case 1:
                        tensors = _a.sent();
                        results = this.findOutputs(tensors, context, outputs);
                        outputIds = Object.keys(results).map(function (key) { return results[key].id; });
                        inputIdArray = Object.keys(inputs).map(function (key) { return inputs[key].map(function (input) { return input.id; }); });
                        inputIds = [].concat.apply([], inputIdArray);
                        Object.keys(tensors).forEach(function (key) {
                            var tensorArray = tensors[key];
                            tensorArray.forEach(function (tensor) {
                                if (tensor && outputIds.indexOf(tensor.id) === -1 &&
                                    inputIds.indexOf(tensor.id) === -1 &&
                                    _this.weightIds.indexOf(tensor.id) === -1) {
                                    tensor.dispose();
                                }
                            });
                        });
                        return [2, results];
                }
            });
        });
    };
    GraphExecutor.prototype.executeWithControlFlow = function (inputs, context) {
        return __awaiter(this, void 0, void 0, function () {
            var stack, tensorMap, added, item, tensors, nodeName, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        stack = this.graph.inputs.map(function (node) {
                            return { node: node, contexts: context.currentContext };
                        });
                        tensorMap = __assign({}, this.weightMap, inputs);
                        added = {};
                        _c.label = 1;
                    case 1:
                        if (!(stack.length > 0)) return [3, 3];
                        item = stack.pop();
                        context.currentContext = item.contexts;
                        tensors = operation_executor_1.executeOp(item.node, tensorMap, context);
                        nodeName = utils_1.getNodeNameAndIndex(item.node.name, context)[0];
                        _a = tensorMap;
                        _b = nodeName;
                        return [4, tensors];
                    case 2:
                        _a[_b] = _c.sent();
                        item.node.children.forEach(function (childNode) {
                            var nodeName = utils_1.getNodeNameAndIndex(childNode.name, context)[0];
                            if (!added[nodeName]) {
                                if (childNode.op === 'merge') {
                                    if (childNode.inputNames.some(function (name) {
                                        return !!utils_1.getTensor(name, tensorMap, context);
                                    })) {
                                        added[nodeName] = true;
                                        stack.push({ contexts: context.currentContext, node: childNode });
                                    }
                                }
                                else if (childNode.inputNames.every(function (name) {
                                    return !!utils_1.getTensor(name, tensorMap, context);
                                })) {
                                    added[nodeName] = true;
                                    stack.push({ contexts: context.currentContext, node: childNode });
                                }
                            }
                        });
                        return [3, 1];
                    case 3: return [2, tensorMap];
                }
            });
        });
    };
    GraphExecutor.prototype.findOutputs = function (tensorMap, context, outputs) {
        if (outputs && !(outputs instanceof Array)) {
            outputs = [outputs];
        }
        var requestedOutputs = (outputs || this.graph.outputs.map(function (node) { return node.name; }));
        return requestedOutputs.reduce(function (map, name) {
            map[name] = utils_1.getTensor(name, tensorMap, context);
            return map;
        }, {});
    };
    GraphExecutor.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.weightMap)
            .forEach(function (key) { return _this.weightMap[key].forEach(function (tensor) { return tensor.dispose(); }); });
    };
    GraphExecutor.prototype.checkInput = function (inputs) {
        var _this = this;
        var inputKeys = Object.keys(inputs);
        var missing = [];
        var extra = [];
        this.placeholders.forEach(function (name) {
            if (inputKeys.indexOf(name) === -1)
                missing.push(name);
        });
        inputKeys.forEach(function (name) {
            if (_this.placeholders.indexOf(name) === -1)
                extra.push(name);
        });
        if (missing.length > 0) {
            throw new Error("The dict provided in model.execute(dict) has the keys " +
                ("[" + inputKeys + "], but is missing the required keys: [" + missing + "]."));
        }
        if (extra.length > 0) {
            throw new Error("The dict provided in model.execute(dict) has " +
                ("unused keys: [" + extra + "]. Please provide only the following keys: ") +
                ("[" + this.placeholders + "]."));
        }
    };
    return GraphExecutor;
}());
exports.GraphExecutor = GraphExecutor;

},{"../operations/executors/utils":27,"../operations/operation_executor":41,"./execution_context":10,"@tensorflow/tfjs-core":51}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var frozen_model_1 = require("./executor/frozen_model");
exports.FrozenModel = frozen_model_1.FrozenModel;
exports.loadFrozenModel = frozen_model_1.loadFrozenModel;
var version_1 = require("./version");
exports.version_converter = version_1.version;

},{"./executor/frozen_model":11,"./version":43}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'add': {
            return [tfc.add(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'mod':
            return [tfc.mod(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        case 'mul':
            return [tfc.mul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        case 'div': {
            return [tfc.div(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'sub': {
            return [tfc.sub(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'minimum': {
            return [tfc.minimum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'maximum': {
            return [tfc.maximum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'pow': {
            return [tfc.pow(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'squaredDifference': {
            return [tfc.squaredDifference(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'arithmetic';

},{"./utils":27,"@tensorflow/tfjs-core":51}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'abs':
            return [tfc.abs(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'acos':
            return [tfc.acos(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'acosh':
            return [tfc.acosh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'asin':
            return [tfc.asin(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'asinh':
            return [tfc.asinh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'atan':
            return [tfc.atan(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'atanh':
            return [tfc.atanh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'ceil':
            return [tfc.ceil(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'cos':
            return [tfc.cos(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'cosh':
            return [tfc.cosh(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'elu':
            return [tfc.elu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'erf':
            return [tfc.erf(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'exp':
            return [tfc.exp(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'expm1': {
            return [tfc.expm1(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'floor':
            return [tfc.floor(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'log':
            return [tfc.log(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'log1p': {
            return [tfc.log1p(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'neg':
            return [tfc.neg(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'reciprocal': {
            return [tfc.reciprocal(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'relu':
            return [tfc.relu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'round': {
            return [tfc.round(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'selu':
            return [tfc.selu(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sigmoid':
            return [tfc.sigmoid(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sin':
            return [tfc.sin(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'sign': {
            return [tfc.sign(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'sinh': {
            return [tfc.sinh(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'softplus': {
            return [tfc.softplus(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'sqrt': {
            return [tfc.sqrt(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'square': {
            return [tfc.square(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'tanh': {
            return [tfc.tanh(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'tan':
            return [tfc.tan(utils_1.getParamValue('x', node, tensorMap, context))];
        case 'clipByValue':
            return [tfc.clipByValue(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('clipValueMin', node, tensorMap, context), utils_1.getParamValue('clipValueMax', node, tensorMap, context))];
        case 'rsqrt':
            return [tfc.div(tfc.scalar(1.0, 'float32'), tfc.sqrt(utils_1.getTensor(node.inputNames[0], tensorMap, context)))];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'basic_math';

},{"./utils":27,"@tensorflow/tfjs-core":51}],16:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
function executeOp(node, tensorMap, context) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, pred, data_1, inputName, frameId, data, tensor, input;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = node.op;
                    switch (_a) {
                        case 'loopCond': return [3, 1];
                        case 'switch': return [3, 2];
                        case 'merge': return [3, 4];
                        case 'enter': return [3, 5];
                        case 'exit': return [3, 6];
                        case 'nextIteration': return [3, 7];
                    }
                    return [3, 8];
                case 1: return [2, [utils_1.getParamValue('pred', node, tensorMap, context)]];
                case 2:
                    pred = utils_1.getParamValue('pred', node, tensorMap, context);
                    data_1 = utils_1.getParamValue('data', node, tensorMap, context);
                    return [4, pred.data()];
                case 3: return [2, (_b.sent())[0] ? [undefined, data_1] : [data_1, undefined]];
                case 4:
                    inputName = node.inputNames.find(function (name) { return utils_1.getTensor(name, tensorMap, context) !== undefined; });
                    return [2, inputName ? [utils_1.getTensor(inputName, tensorMap, context)] : undefined];
                case 5:
                    frameId = utils_1.getParamValue('frameName', node, tensorMap, context);
                    data = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.enterFrame(frameId);
                    return [2, [data]];
                case 6:
                    tensor = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.exitFrame();
                    return [2, [tensor]];
                case 7:
                    input = utils_1.getParamValue('tensor', node, tensorMap, context);
                    context.nextIteration();
                    return [2, [input]];
                case 8: throw TypeError("Node type " + node.op + " is not implemented");
            }
        });
    });
}
exports.executeOp = executeOp;
exports.CATEGORY = 'control';

},{"./utils":27}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'conv1d': {
            var stride = utils_1.getParamValue('stride', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            var dilation = utils_1.getParamValue('dilation', node, tensorMap, context);
            return [tfc.conv1d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];
        }
        case 'conv2d': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);
            return [tfc.conv2d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];
        }
        case 'conv2dTranspose': {
            var shape = utils_1.getParamValue('outputShape', node, tensorMap, context);
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            return [tfc.conv2dTranspose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];
        }
        case 'depthwiseConv2d': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);
            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)
                .toUpperCase();
            return [tfc.depthwiseConv2d(utils_1.getParamValue('input', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];
        }
        case 'avgPool': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);
            return [tfc.avgPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
        }
        case 'maxPool': {
            var stride = utils_1.getParamValue('strides', node, tensorMap, context);
            var pad = utils_1.getParamValue('pad', node, tensorMap, context);
            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);
            return [tfc.maxPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'convolution';

},{"./utils":27,"@tensorflow/tfjs-core":51}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'fill': {
            var shape = utils_1.getParamValue('shape', node, tensorMap, context);
            var value = utils_1.getParamValue('value', node, tensorMap, context);
            return [tfc.fill(shape, value)];
        }
        case 'linspace': {
            var start = utils_1.getParamValue('start', node, tensorMap, context);
            var stop_1 = utils_1.getParamValue('stop', node, tensorMap, context);
            var num = utils_1.getParamValue('num', node, tensorMap, context);
            return [tfc.linspace(start, stop_1, num)];
        }
        case 'oneHot': {
            var indices = utils_1.getParamValue('indices', node, tensorMap, context);
            var depth = utils_1.getParamValue('depth', node, tensorMap, context);
            var onValue = utils_1.getParamValue('onValue', node, tensorMap, context);
            var offValue = utils_1.getParamValue('offValue', node, tensorMap, context);
            return [tfc.oneHot(indices, depth, onValue, offValue)];
        }
        case 'ones': {
            return [tfc.ones(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'onesLike': {
            return [tfc.onesLike(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        case 'randomUniform': {
            return [tfc.randomUniform(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('minval', node, tensorMap, context), utils_1.getParamValue('maxval', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'range': {
            var start = utils_1.getParamValue('start', node, tensorMap, context);
            var stop_2 = utils_1.getParamValue('stop', node, tensorMap, context);
            var step = utils_1.getParamValue('step', node, tensorMap, context);
            return [tfc.range(start, stop_2, step, utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'truncatedNormal': {
            var shape = utils_1.getParamValue('shape', node, tensorMap, context);
            var mean = utils_1.getParamValue('mean', node, tensorMap, context);
            var stdDev = utils_1.getParamValue('stdDev', node, tensorMap, context);
            var seed = utils_1.getParamValue('seed', node, tensorMap, context);
            return [tfc.truncatedNormal(shape, mean, stdDev, utils_1.getParamValue('dtype', node, tensorMap, context), seed)];
        }
        case 'zeros': {
            return [tfc.zeros(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'zerosLike': {
            return [tfc.zerosLike(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'creation';

},{"./utils":27,"@tensorflow/tfjs-core":51}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'const': {
            return tensorMap[node.name];
        }
        case 'placeholder':
            var def = utils_1.getParamValue('default', node, tensorMap, context);
            return [utils_1.getTensor(node.name, tensorMap, context) || def];
        case 'identity':
        case 'stopGradient':
        case 'fakeQuantWithMinMaxVars':
            return [utils_1.getParamValue('x', node, tensorMap, context)];
        case 'snapshot':
            var snapshot = utils_1.getParamValue('x', node, tensorMap, context);
            return [snapshot.clone()];
        case 'shape':
            return [tfc.tensor1d(utils_1.getParamValue('x', node, tensorMap, context).shape, 'int32')];
        case 'noop':
            return [];
        case 'print':
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            var data = utils_1.getParamValue('data', node, tensorMap, context);
            var message = utils_1.getParamValue('message', node, tensorMap, context);
            var summarize = utils_1.getParamValue('summarize', node, tensorMap, context);
            console.warn('The graph has a tf.print() operation,' +
                'usually used for debugging, which slows down performance.');
            console.log(message);
            for (var i = 0; i < data.length; i++) {
                console.log(Array.prototype.slice.call(data[0].dataSync()).slice(0, summarize));
            }
            return [input];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'graph';

},{"./utils":27,"@tensorflow/tfjs-core":51}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'resizeBilinear': {
            var images = utils_1.getParamValue('images', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);
            return [tfc.image.resizeBilinear(images, [size[0], size[1]], alignCorners)];
        }
        case 'resizeNearestNeighbor': {
            var images = utils_1.getParamValue('images', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);
            return [tfc.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'image';

},{"./utils":27,"@tensorflow/tfjs-core":51}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'equal': {
            return [tfc.equal(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'notEqual': {
            return [tfc.notEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'greater': {
            return [tfc.greater(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'greaterEqual': {
            return [tfc.greaterEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'less': {
            return [tfc.less(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'lessEqual': {
            return [tfc.lessEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'logicalAnd': {
            return [tfc.logicalAnd(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'logicalNot': {
            return [tfc.logicalNot(utils_1.getParamValue('a', node, tensorMap, context))];
        }
        case 'logicalOr': {
            return [tfc.logicalOr(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        case 'where': {
            return [tfc.where(utils_1.getParamValue('condition', node, tensorMap, context), utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'logical';

},{"./utils":27,"@tensorflow/tfjs-core":51}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'matMul':
            return [tfc.matMul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context), utils_1.getParamValue('transposeA', node, tensorMap, context), utils_1.getParamValue('transposeB', node, tensorMap, context))];
        case 'transpose':
            return [tfc.transpose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('perm', node, tensorMap, context))];
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'matrices';

},{"./utils":27,"@tensorflow/tfjs-core":51}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'batchNormalization': {
            return [tfc.batchNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('mean', node, tensorMap, context), utils_1.getParamValue('variance', node, tensorMap, context), utils_1.getParamValue('epsilon', node, tensorMap, context), utils_1.getParamValue('scale', node, tensorMap, context), utils_1.getParamValue('offset', node, tensorMap, context))];
        }
        case 'localResponseNormalization': {
            return [tfc.localResponseNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('radius', node, tensorMap, context), utils_1.getParamValue('bias', node, tensorMap, context), utils_1.getParamValue('alpha', node, tensorMap, context), utils_1.getParamValue('beta', node, tensorMap, context))];
        }
        case 'softmax': {
            return [tfc.softmax(utils_1.getParamValue('x', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'normalization';

},{"./utils":27,"@tensorflow/tfjs-core":51}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'max': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.max(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'mean': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.mean(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'min': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.min(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'sum': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);
            return [tfc.sum(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];
        }
        case 'argMax': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.argMax(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'argMin': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            return [tfc.argMin(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'reduction';

},{"./utils":27,"@tensorflow/tfjs-core":51}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'concat': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var inputs = utils_1.getParamValue('tensors', node, tensorMap, context);
            return [tfc.concat(inputs, axis)];
        }
        case 'gather': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            var indices = utils_1.getParamValue('indices', node, tensorMap, context);
            return [tfc.gather(input, indices, axis)];
        }
        case 'reverse': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var input = utils_1.getParamValue('x', node, tensorMap, context);
            return [tfc.reverse(input, axis)];
        }
        case 'slice': {
            var begin = utils_1.getParamValue('begin', node, tensorMap, context);
            var size = utils_1.getParamValue('size', node, tensorMap, context);
            return [tfc.slice(utils_1.getParamValue('x', node, tensorMap, context), begin, size)];
        }
        case 'stridedSlice': {
            var begin = utils_1.getParamValue('begin', node, tensorMap, context);
            var end = utils_1.getParamValue('end', node, tensorMap, context);
            var strides = utils_1.getParamValue('strides', node, tensorMap, context);
            var beginMask = utils_1.getParamValue('beginMask', node, tensorMap, context);
            var endMask = utils_1.getParamValue('endMask', node, tensorMap, context);
            return [tfc.stridedSlice(utils_1.getParamValue('x', node, tensorMap, context), begin, end, strides, beginMask, endMask)];
        }
        case 'stack': {
            return tfc.tidy(function () {
                var axis = utils_1.getParamValue('axis', node, tensorMap, context);
                var tensors = utils_1.getParamValue('tensors', node, tensorMap, context);
                var shape = tensors[0].shape;
                var squeezedShape = tensors[0].squeeze().shape;
                var mapped = tensors.map(function (tensor) {
                    var sameShape = tfc.util.arraysEqual(tensor.shape, shape);
                    if (!sameShape &&
                        !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {
                        throw new Error('the input tensors shape does not match');
                    }
                    return sameShape ? tensor : tensor.reshape(shape);
                });
                return [tfc.stack(mapped, axis)];
            });
        }
        case 'tile': {
            var reps = utils_1.getParamValue('reps', node, tensorMap, context);
            return [tfc.tile(utils_1.getParamValue('x', node, tensorMap, context), reps)];
        }
        case 'split': {
            var axis = utils_1.getParamValue('axis', node, tensorMap, context);
            var numOrSizeSplits = utils_1.getParamValue('numOrSizeSplits', node, tensorMap, context);
            return tfc.split(utils_1.getParamValue('x', node, tensorMap, context), numOrSizeSplits, axis);
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'slice_join';

},{"./utils":27,"@tensorflow/tfjs-core":51}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var utils_1 = require("./utils");
exports.executeOp = function (node, tensorMap, context) {
    switch (node.op) {
        case 'cast': {
            return [tfc.cast(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];
        }
        case 'expandDims': {
            var axis = node.params['axis'].value;
            return [tfc.expandDims(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'squeeze': {
            var axis = node.params['axis'].value;
            return [tfc.squeeze(utils_1.getParamValue('x', node, tensorMap, context), axis)];
        }
        case 'reshape': {
            return [tfc.reshape(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('shape', node, tensorMap, context))];
        }
        case 'pad': {
            return [tfc.pad(utils_1.getParamValue('x', node, tensorMap, context), utils_1.split(utils_1.getParamValue('padding', node, tensorMap, context), 2), utils_1.getParamValue('constantValue', node, tensorMap, context))];
        }
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
};
exports.CATEGORY = 'transformation';

},{"./utils":27,"@tensorflow/tfjs-core":51}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getParamValue(paramName, node, tensorMap, context) {
    var param = node.params[paramName];
    if (param && param.inputIndex !== undefined) {
        if (param.type === 'tensor') {
            return getTensor(node.inputNames[param.inputIndex], tensorMap, context);
        }
        if (param.type === 'tensors') {
            var inputs = param.inputIndex === 0 ?
                (param.inputParamLength === 0 ?
                    node.inputNames :
                    node.inputNames.slice(param.inputIndex, -param.inputParamLength)) :
                node.inputNames.splice(param.inputIndex);
            return inputs.map(function (name) { return getTensor(name, tensorMap, context); });
        }
        var data = Array.prototype.slice.call(getTensor(node.inputNames.slice(param.inputIndex)[0], tensorMap, context)
            .dataSync());
        return param.type === 'number' ? data[0] : data;
    }
    return param && param.value;
}
exports.getParamValue = getParamValue;
function getTensor(name, tensorsMap, context) {
    var _a = parseNodeName(name), nodeName = _a[0], index = _a[1];
    var contextId = context.currentContextIds.find(function (contextId) {
        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];
    });
    return contextId !== undefined ?
        tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :
        undefined;
}
exports.getTensor = getTensor;
function getNodeNameAndIndex(inputName, context) {
    var _a = parseNodeName(inputName), nodeName = _a[0], index = _a[1];
    return [
        getNodeNameWithContextId(nodeName, context && context.currentContextId),
        index
    ];
}
exports.getNodeNameAndIndex = getNodeNameAndIndex;
function getNodeNameWithContextId(name, contextId) {
    return !!contextId ? name + "-" + contextId : name;
}
function parseNodeName(name) {
    var index = name.lastIndexOf(':');
    if (index === -1)
        return [name, 0];
    var nodeName = name.substring(0, index);
    return [nodeName, Number(name.substring(index + 1))];
}
exports.parseNodeName = parseNodeName;
function split(arr, size) {
    var res = [];
    for (var i = 0; i < arr.length; i += size) {
        res.push(arr.slice(i, i + size));
    }
    return res;
}
exports.split = split;

},{}],28:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Add",
    "dlOpName": "add",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "BiasAdd",
    "dlOpName": "add",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sub",
    "dlOpName": "sub",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "RealDiv",
    "dlOpName": "div",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Div",
    "dlOpName": "div",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Mul",
    "dlOpName": "mul",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Maximum",
    "dlOpName": "maximum",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Minimum",
    "dlOpName": "minimum",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Pow",
    "dlOpName": "pow",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "SquaredDifference",
    "dlOpName": "squaredDifference",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Mod",
    "dlOpName": "mod",
    "category": "arithmetic",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],29:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Abs",
    "dlOpName": "abs",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Acos",
    "dlOpName": "acos",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Asin",
    "dlOpName": "asin",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "atan",
    "dlOpName": "atan",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Ceil",
    "dlOpName": "ceil",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ClipByValue",
    "dlOpName": "clipByValue",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "clip_value_min",
        "dlParamName": "clipValueMin",
        "type": "number"
      },
      {
        "tfParamName": "clip_value_max",
        "dlParamName": "clipValueMax",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Cos",
    "dlOpName": "cos",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Cosh",
    "dlOpName": "cosh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Elu",
    "dlOpName": "elu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Exp",
    "dlOpName": "exp",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Floor",
    "dlOpName": "floor",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Log",
    "dlOpName": "log",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Neg",
    "dlOpName": "neg",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Relu",
    "dlOpName": "relu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Relu6",
    "dlOpName": "clipByValue",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "dlParamName": "clipValueMin",
        "type": "number",
        "defaultValue": 0
      },
      {
        "dlParamName": "clipValueMax",
        "type": "number",
        "defaultValue": 6
      }
    ]
  },
  {
    "tfOpName": "Selu",
    "dlOpName": "selu",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sigmoid",
    "dlOpName": "sigmoid",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sin",
    "dlOpName": "sin",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sinh",
    "dlOpName": "sinh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sqrt",
    "dlOpName": "sqrt",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Rsqrt",
    "dlOpName": "rsqrt",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Square",
    "dlOpName": "square",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tan",
    "dlOpName": "tan",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tanh",
    "dlOpName": "tanh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sign",
    "dlOpName": "sign",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Round",
    "dlOpName": "round",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Expm1",
    "dlOpName": "expm1",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Log1p",
    "dlOpName": "log1p",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reciprocal",
    "dlOpName": "reciprocal",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reciprocal",
    "dlOpName": "reciprocal",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Softplus",
    "dlOpName": "softplus",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Asinh",
    "dlOpName": "asinh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Acosh",
    "dlOpName": "acosh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Atanh",
    "dlOpName": "atanh",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Erf",
    "dlOpName": "erf",
    "category": "basic_math",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],30:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "LoopCond",
    "dlOpName": "loopCond",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "pred",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Switch",
    "dlOpName": "switch",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "data",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "pred",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Merge",
    "dlOpName": "merge",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "tfInputParamLength": 0,
        "dlParamName": "tensors",
        "type": "tensors"
      }
    ]
  },
  {
    "tfOpName": "Enter",
    "dlOpName": "enter",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "frame_name",
        "dlParamName": "frameName",
        "type": "string"
      },
      {
        "tfParamName": "is_constant",
        "dlParamName": "isConstant",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Exit",
    "dlOpName": "exit",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "NextIteration",
    "dlOpName": "nextIteration",
    "category": "control",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "tensor",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],31:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "AvgPool",
    "dlOpName": "avgPool",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfParamName": "ksize",
        "dlParamName": "kernelSize",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "MaxPool",
    "dlOpName": "maxPool",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfParamName": "ksize",
        "dlParamName": "kernelSize",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Conv1D",
    "dlOpName": "conv1d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "stride",
        "dlParamName": "stride",
        "type": "number"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NWC"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "dilation",
        "dlParamName": "dilation",
        "type": "number",
        "defaultValue": 1
      }
    ]
  },
  {
    "tfOpName": "Conv2D",
    "dlOpName": "conv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "useCudnnOnGpu",
        "dlParamName": "useCudnnOnGpu",
        "type": "bool"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Conv2DBackpropInput",
    "dlOpName": "conv2dTranspose",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 2,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfInputIndex": 0,
        "dlParamName": "outputShape",
        "type": "number[]"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2d",
    "dlOpName": "depthwiseConv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "input",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2dNative",
    "dlOpName": "depthwiseConv2d",
    "category": "convolution",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "input",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "filter",
        "type": "tensor"
      },
      {
        "tfParamName": "strides",
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "padding",
        "dlParamName": "pad",
        "type": "string"
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfParamName": "dilations",
        "dlParamName": "dilations",
        "type": "number[]"
      }
    ]
  }
]

},{}],32:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Fill",
    "dlOpName": "fill",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "value",
        "type": "number"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LinSpace",
    "dlOpName": "linspace",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "start",
        "type": "number"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "stop",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "num",
        "type": "number"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "OneHot",
    "dlOpName": "oneHot",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "depth",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "onValue",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "offValue",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "notSupported": true
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Ones",
    "dlOpName": "ones",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "OnesLike",
    "dlOpName": "onesLike",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "RandomUniform",
    "dlOpName": "randomUniform",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "minval",
        "dlParamName": "minval",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "maxval",
        "dlParamName": "maxval",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      },
      {
        "tfParamName": "seed",
        "dlParamName": "seed",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "seed2",
        "dlParamName": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfParamName": "T",
        "dlParamName": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Range",
    "dlOpName": "range",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "start",
        "type": "number"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "stop",
        "type": "number"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "step",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "Tidx",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "truncatedNormal",
    "dlOpName": "truncatedNormal",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "means",
        "dlParamName": "mean",
        "type": "number",
        "defaultValue": 0.0
      },
      {
        "tfParamName": "stddev",
        "dlParamName": "stdDev",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "seed",
        "dlParamName": "seed",
        "type": "number"
      },
      {
        "tfParamName": "seed2",
        "dlParamName": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfParamName": "dtype",
        "dlParamName": "dtype",
        "type": "dtype"
      },
      {
        "tfParamName": "T",
        "dlParamName": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Zeros",
    "dlOpName": "zeros",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "shape",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "ZerosLike",
    "dlOpName": "zerosLike",
    "category": "creation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  }
]

},{}],33:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "PlaceholderWithDefault",
    "dlOpName": "placeholder",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "default",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Placeholder",
    "dlOpName": "placeholder",
    "category": "graph"
  },
  {
    "tfOpName": "Const",
    "dlOpName": "const",
    "category": "graph"
  },
  {
    "tfOpName": "Identity",
    "dlOpName": "identity",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Snapshot",
    "dlOpName": "snapshot",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Shape",
    "dlOpName": "shape",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Print",
    "dlOpName": "print",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "tfInputParamLength": 1,
        "dlParamName": "data",
        "type": "tensors"
      },
      {
        "tfParamName": "message",
        "dlParamName": "message",
        "type": "string"
      },
      {
        "tfParamName": "first_n",
        "dlParamName": "firstN",
        "type": "number",
        "notSupprted": true
      },
      {
        "tfParamName": "summarize",
        "dlParamName": "summarize",
        "type": "number",
        "defaultValue": 3
      }
    ]
  },
  {
    "tfOpName": "NoOp",
    "dlOpName": "noop",
    "category": "graph",
    "params": []
  },
  {
    "tfOpName": "StopGradient",
    "dlOpName": "stopGradient",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "FakeQuantWithMinMaxVars",
    "dlOpName": "fakeQuantWithMinMaxVars",
    "category": "graph",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "min",
        "dlParamName": "min",
        "type": "number"
      },
      {
        "tfParamName": "max",
        "dlParamName": "max",
        "type": "number"
      }
    ]
  }
]

},{}],34:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "ResizeBilinear",
    "dlOpName": "resizeBilinear",
    "category": "image",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "images",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "size",
        "type": "number[]"
      },
      {
        "tfParamName": "align_corners",
        "dlParamName": "alignCorners",
        "type": "bool"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ResizeNearestNeighbor",
    "dlOpName": "resizeNearestNeighbor",
    "category": "image",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "images",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "size",
        "type": "number[]"
      },
      {
        "tfParamName": "align_corners",
        "dlParamName": "alignCorners",
        "type": "bool"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],35:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Equal",
    "dlOpName": "equal",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "NotEqual",
    "dlOpName": "notEqual",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Greater",
    "dlOpName": "greater",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "GreaterEqual",
    "dlOpName": "greaterEqual",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Less",
    "dlOpName": "less",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LessEqual",
    "dlOpName": "lessEqual",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalAnd",
    "dlOpName": "logicalAnd",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalNot",
    "dlOpName": "logicalNot",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalOr",
    "dlOpName": "logicalOr",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Select",
    "dlOpName": "where",
    "category": "logical",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "condition",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],36:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "MatMul",
    "dlOpName": "matMul",
    "category": "matrices",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "a",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "b",
        "type": "tensor"
      },
      {
        "tfParamName": "transpose_a",
        "dlParamName": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfParamName": "transpose_b",
        "dlParamName": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Transpose",
    "dlOpName": "transpose",
    "category": "matrices",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "perm",
        "dlParamName": "perm",
        "type": "number[]"
      },
      {
        "tfParamName": "T",
        "dlParamName": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
]

},{}],37:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "FusedBatchNorm",
    "dlOpName": "batchNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "scale",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "offset",
        "type": "tensor"
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "mean",
        "type": "tensor"
      },
      {
        "tfInputIndex": 4,
        "dlParamName": "variance",
        "type": "tensor"
      },
      {
        "tfParamName": "epsilon",
        "dlParamName": "epsilon",
        "type": "number",
        "defaultValue": 0.001
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FusedBatchNormV2",
    "dlOpName": "batchNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "scale",
        "type": "tensor"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "offset",
        "type": "tensor"
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "mean",
        "type": "tensor"
      },
      {
        "tfInputIndex": 4,
        "dlParamName": "variance",
        "type": "tensor"
      },
      {
        "tfParamName": "epsilon",
        "dlParamName": "epsilon",
        "type": "number",
        "defaultValue": 0.001
      },
      {
        "tfParamName": "data_format",
        "dlParamName": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LRN",
    "dlOpName": "localResponseNormalization",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "depth_radius",
        "dlParamName": "radius",
        "type": "number",
        "defaultValue": 5
      },
      {
        "tfParamName": "bias",
        "dlParamName": "bias",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "alpha",
        "dlParamName": "alpha",
        "type": "number",
        "defaultValue": 1.0
      },
      {
        "tfParamName": "beta",
        "dlParamName": "beta",
        "type": "number",
        "defaultValue": 0.5
      }
    ]
  },  {
    "tfOpName": "Softmax",
    "dlOpName": "softmax",
    "category": "normalization",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      }
    ]
  }
]

},{}],38:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Max",
    "dlOpName": "max",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Mean",
    "dlOpName": "mean",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Min",
    "dlOpName": "min",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Sum",
    "dlOpName": "sum",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number[]"
      },
      {
        "tfParamName": "keep_dims",
        "dlParamName": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "ArgMax",
    "dlOpName": "argMax",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "ArgMin",
    "dlOpName": "argMin",
    "category": "reduction",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  }
]

},{}],39:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "ConcatV2",
    "dlOpName": "concat",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "tfInputParamLength": 1,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfInputIndex": -1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Concat",
    "dlOpName": "concat",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 1,
        "tfInputParamLength": 1,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfInputIndex": 0,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "GatherV2",
    "dlOpName": "gather",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Gather",
    "dlOpName": "gather",
    "category": "slice_join",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "indices",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "validate_indices",
        "dlParamName": "validateIndices",
        "type": "bool",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reverse",
    "dlOpName": "reverse",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "ReverseV2",
    "dlOpName": "reverse",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Slice",
    "dlOpName": "slice",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "begin",
        "type": "number[]"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "size",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "StridedSlice",
    "dlOpName": "stridedSlice",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "begin",
        "type": "number[]"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "end",
        "type": "number[]"
      },
      {
        "tfInputIndex": 3,
        "dlParamName": "strides",
        "type": "number[]"
      },
      {
        "tfParamName": "begin_mask",
        "dlParamName": "beginMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfParamName": "end_mask",
        "dlParamName": "endMask",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Pack",
    "dlOpName": "stack",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "tfInputParamLength": 0,
        "dlParamName": "tensors",
        "type": "tensors"
      },
      {
        "tfParamName": "axis",
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Tile",
    "dlOpName": "tile",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "reps",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Split",
    "dlOpName": "split",
    "category": "slice_join",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "axis",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "num_split",
        "dlParamName": "numOrSizeSplits",
        "type": "number",
        "defaultValue": 1
      }
    ]
  }
]

},{}],40:[function(require,module,exports){
module.exports=[
  {
    "tfOpName": "Cast",
    "dlOpName": "cast",
    "category": "transformation",
    "params": [
      {
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "SrcT",
        "dlParamName": "sdtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfParamName": "DstT",
        "dlParamName": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "ExpandDims",
    "dlOpName": "expandDims",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "tfParamNameDeprecated": "dim",
        "dlParamName": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Pad",
    "dlOpName": "pad",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "padding",
        "type": "number[]"
      },
      {
        "tfParamName": "constant_value",
        "dlParamName": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "PadV2",
    "dlOpName": "pad",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "padding",
        "type": "number[]"
      },
      {
        "tfInputIndex": 2,
        "dlParamName": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Reshape",
    "dlOpName": "reshape",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfInputIndex": 1,
        "dlParamName": "shape",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Squeeze",
    "dlOpName": "squeeze",
    "category": "transformation",
    "params": [{
        "tfInputIndex": 0,
        "dlParamName": "x",
        "type": "tensor"
      },
      {
        "tfParamName": "axis",
        "tfParamNameDeprecated": "squeeze_dims",
        "dlParamName": "axis",
        "type": "number[]"
      }
    ]
  }
]

},{}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var arithmetic = require("./executors/arithmetic_executor");
var basicMath = require("./executors/basic_math_executor");
var control = require("./executors/control_executor");
var convolution = require("./executors/convolution_executor");
var creation = require("./executors/creation_executor");
var graph = require("./executors/graph_executor");
var image = require("./executors/image_executor");
var logical = require("./executors/logical_executor");
var matrices = require("./executors/matrices_executor");
var normalization = require("./executors/normalization_executor");
var reduction = require("./executors/reduction_executor");
var sliceJoin = require("./executors/slice_join_executor");
var transformation = require("./executors/transformation_executor");
function executeOp(node, tensorMap, context) {
    switch (node.category) {
        case 'arithmetic':
            return arithmetic.executeOp(node, tensorMap, context);
        case 'basic_math':
            return basicMath.executeOp(node, tensorMap, context);
        case 'control':
            return control.executeOp(node, tensorMap, context);
        case 'convolution':
            return convolution.executeOp(node, tensorMap, context);
        case 'creation':
            return creation.executeOp(node, tensorMap, context);
        case 'image':
            return image.executeOp(node, tensorMap, context);
        case 'graph':
            return graph.executeOp(node, tensorMap, context);
        case 'logical':
            return logical.executeOp(node, tensorMap, context);
        case 'matrices':
            return matrices.executeOp(node, tensorMap, context);
        case 'normalization':
            return normalization.executeOp(node, tensorMap, context);
        case 'reduction':
            return reduction.executeOp(node, tensorMap, context);
        case 'slice_join':
            return sliceJoin.executeOp(node, tensorMap, context);
        case 'transformation':
            return transformation.executeOp(node, tensorMap, context);
        default:
            throw TypeError("Node type " + node.op + " is not implemented");
    }
}
exports.executeOp = executeOp;

},{"./executors/arithmetic_executor":14,"./executors/basic_math_executor":15,"./executors/control_executor":16,"./executors/convolution_executor":17,"./executors/creation_executor":18,"./executors/graph_executor":19,"./executors/image_executor":20,"./executors/logical_executor":21,"./executors/matrices_executor":22,"./executors/normalization_executor":23,"./executors/reduction_executor":24,"./executors/slice_join_executor":25,"./executors/transformation_executor":26}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var compiled_api_1 = require("../data/compiled_api");
var utils_1 = require("./executors/utils");
var arithmetic = require("./op_list/arithmetic.json");
var basicMath = require("./op_list/basic_math.json");
var control = require("./op_list/control.json");
var convolution = require("./op_list/convolution.json");
var creation = require("./op_list/creation.json");
var graph = require("./op_list/graph.json");
var image = require("./op_list/image.json");
var logical = require("./op_list/logical.json");
var matrices = require("./op_list/matrices.json");
var normalization = require("./op_list/normalization.json");
var reduction = require("./op_list/reduction.json");
var sliceJoin = require("./op_list/slice_join.json");
var transformation = require("./op_list/transformation.json");
var CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration'];
var OperationMapper = (function () {
    function OperationMapper() {
        var ops = [
            arithmetic, basicMath, control, convolution, creation, logical, image,
            graph, matrices, normalization, reduction, sliceJoin, transformation
        ];
        var mappersJson = [].concat.apply([], ops.map(function (op) { return op.default ? op.default : op; }));
        this.opMappers = mappersJson.reduce(function (map, mapper) {
            map[mapper.tfOpName] = mapper;
            return map;
        }, {});
    }
    Object.defineProperty(OperationMapper, "Instance", {
        get: function () {
            return this._instance || (this._instance = new this());
        },
        enumerable: true,
        configurable: true
    });
    OperationMapper.prototype.isControlFlow = function (node) {
        return CONTROL_FLOW_OPS.some(function (op) { return op === node.op; });
    };
    OperationMapper.prototype.transformGraph = function (graph) {
        var _this = this;
        var tfNodes = graph.node;
        var withControlFlow = false;
        var placeholders = [];
        var nodes = tfNodes.reduce(function (map, node) {
            map[node.name] = _this.mapNode(node);
            if (_this.isControlFlow(node))
                withControlFlow = true;
            if (node.op === 'Placeholder')
                placeholders.push(map[node.name]);
            return map;
        }, {});
        var inputs = [];
        var outputs = [];
        Object.keys(nodes).forEach(function (key) {
            var node = nodes[key];
            node.inputNames.forEach(function (name) {
                var nodeName = utils_1.getNodeNameAndIndex(name)[0];
                node.inputs.push(nodes[nodeName]);
                nodes[nodeName].children.push(node);
            });
            if (node.inputs.length === 0)
                inputs.push(node);
        });
        Object.keys(nodes).forEach(function (key) {
            var node = nodes[key];
            if (node.children.length === 0)
                outputs.push(node);
        });
        return { nodes: nodes, inputs: inputs, outputs: outputs, placeholders: placeholders, withControlFlow: withControlFlow };
    };
    OperationMapper.prototype.mapNode = function (node) {
        var _this = this;
        var mapper = this.opMappers[node.op];
        if (mapper === undefined) {
            throw new Error('Tensorflow Op is not supported: ' + node.op);
        }
        var newNode = {
            name: node.name,
            op: mapper.dlOpName,
            category: mapper.category,
            inputNames: (node.input ||
                []).map(function (input) { return input.startsWith('^') ? input.substr(1) : input; }),
            inputs: [],
            children: [],
            params: {}
        };
        if (!!mapper.params) {
            newNode.params = mapper.params.reduce(function (map, param) {
                var inputIndex = param.tfInputIndex;
                var inputParamLength = param.tfInputParamLength;
                var type = param.type;
                var value = undefined;
                if (inputIndex === undefined) {
                    switch (param.type) {
                        case 'string':
                            value = _this.getStringParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getStringParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'number':
                            value = _this.getNumberParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getNumberParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'number[]':
                            value = _this.getNumericArrayParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getNumericArrayParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'bool':
                            value = _this.getBoolParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getBoolParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'shape':
                            value = _this.getTensorShapeParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getTensorShapeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'dtype':
                            value = _this.getDtypeParam(node.attr, param.tfParamName, param.defaultValue);
                            if (value === undefined && !!param.tfParamNameDeprecated) {
                                value = _this.getDtypeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue);
                            }
                            break;
                        case 'tensor':
                        case 'tensors':
                            break;
                        default:
                            throw new Error("Unsupported param type: " + param.type + " for op: " + node.op);
                    }
                }
                map[param.dlParamName] = { value: value, inputIndex: inputIndex, type: type, inputParamLength: inputParamLength };
                return map;
            }, {});
        }
        return newNode;
    };
    OperationMapper.prototype.getStringParam = function (attrs, name, def, keepCase) {
        if (keepCase === void 0) { keepCase = false; }
        var param = attrs[name];
        if (param !== undefined) {
            var value = String.fromCharCode.apply(null, param.s);
            return keepCase ? value : value.toLowerCase();
        }
        return def;
    };
    OperationMapper.prototype.getBoolParam = function (attrs, name, def) {
        var param = attrs[name];
        return param ? param.b : def;
    };
    OperationMapper.prototype.getNumberParam = function (attrs, name, def) {
        var param = attrs[name];
        var value = (param ? ((param.f !== undefined) ? param.f : param.i) : def);
        return (typeof value === 'number') ? value : value['toInt']();
    };
    OperationMapper.prototype.getDtypeParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param && param.type) {
            switch (param.type) {
                case compiled_api_1.tensorflow.DataType.DT_FLOAT:
                    return 'float32';
                case compiled_api_1.tensorflow.DataType.DT_INT32:
                    return 'int32';
                case compiled_api_1.tensorflow.DataType.DT_BOOL:
                    return 'bool';
                default:
                    return def;
            }
        }
        return def;
    };
    OperationMapper.prototype.getTensorShapeParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param && param.shape) {
            return param.shape.dim.map(function (dim) { return dim.size; });
        }
        return def;
    };
    OperationMapper.prototype.getNumericArrayParam = function (attrs, name, def) {
        var param = attrs[name];
        if (param) {
            return ((param.list.f && param.list.f.length ? param.list.f :
                param.list.i))
                .map(function (v) { return (typeof v === 'number') ? v : v['toInt'](); });
        }
        return def;
    };
    return OperationMapper;
}());
exports.OperationMapper = OperationMapper;

},{"../data/compiled_api":9,"./executors/utils":27,"./op_list/arithmetic.json":28,"./op_list/basic_math.json":29,"./op_list/control.json":30,"./op_list/convolution.json":31,"./op_list/creation.json":32,"./op_list/graph.json":33,"./op_list/image.json":34,"./op_list/logical.json":35,"./op_list/matrices.json":36,"./op_list/normalization.json":37,"./op_list/reduction.json":38,"./op_list/slice_join.json":39,"./op_list/transformation.json":40}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.4.1';
exports.version = version;

},{}],44:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var BrowserUtil = (function () {
    function BrowserUtil() {
    }
    BrowserUtil.nextFrame = function () {
        return new Promise(function (resolve) { return requestAnimationFrame(function () { return resolve(); }); });
    };
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Timing' })
    ], BrowserUtil, "nextFrame", null);
    return BrowserUtil;
}());
exports.BrowserUtil = BrowserUtil;

},{"./doc":46}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;

},{}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function doc(info) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
}
exports.doc = doc;

},{}],47:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var globals_1 = require("./globals");
var ops = require("./ops/ops");
var profiler_1 = require("./profiler");
var tape_1 = require("./tape");
var tensor_1 = require("./tensor");
var util = require("./util");
var Engine = (function () {
    function Engine(backend, safeMode) {
        this.backend = backend;
        this.safeMode = safeMode;
        this.registeredVariables = {};
        this.refCounter = new WeakMap();
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numDataBuffers = 0;
        this.gradientScopeCount = 0;
        this.customGradientDepth = 0;
        this.keepTensors = new Set();
        this.activeScope = { track: [] };
        this.scopeStack = [this.activeScope];
        this.profiler = new profiler_1.Profiler(backend);
    }
    Engine.prototype.runKernel = function (forwardFunc, inputs, backwardsFunc) {
        var _this = this;
        var result;
        var saved = [];
        var saveFunc = function (x) {
            saved.push(x);
            return x;
        };
        var scopeName = this.activeScope.name;
        this.customGradientDepth++;
        if (!environment_1.ENV.get('DEBUG')) {
            result = forwardFunc(this.backend, saveFunc);
        }
        else {
            result = this.profiler.profileKernel(scopeName, function () { return forwardFunc(_this.backend, saveFunc); });
        }
        this.customGradientDepth--;
        if (this.shouldRecord()) {
            var tapeNode = {
                id: this.nextTapeNodeId++,
                name: scopeName,
                inputs: inputs,
                output: result,
            };
            if (backwardsFunc != null) {
                tapeNode.gradient = function (dy) { return backwardsFunc(dy, saved); };
            }
            this.activeTape.push(tapeNode);
        }
        return result;
    };
    Engine.prototype.registerTensor = function (a) {
        var refCount = this.refCounter.has(a.dataId) ? this.refCounter.get(a.dataId) : 0;
        this.numTensors++;
        if (refCount === 0) {
            this.numDataBuffers++;
            this.numBytes +=
                util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
            this.backend.register(a.dataId, a.shape, a.dtype);
        }
        this.refCounter.set(a.dataId, refCount + 1);
        if (!(a instanceof tensor_1.Variable)) {
            this.track(a);
        }
    };
    Engine.prototype.registerVariable = function (v) {
        if (this.registeredVariables[v.name] != null) {
            throw new Error("Variable with name " + v.name + " was already registered");
        }
        this.registeredVariables[v.name] = v;
    };
    Engine.prototype.disposeTensor = function (a) {
        if (!this.refCounter.has(a.dataId)) {
            return;
        }
        this.numTensors--;
        var refCount = this.refCounter.get(a.dataId);
        if (refCount <= 1) {
            this.refCounter.delete(a.dataId);
            this.backend.disposeData(a.dataId);
            this.numDataBuffers--;
            this.numBytes -=
                util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
        }
        else {
            this.refCounter.set(a.dataId, refCount - 1);
        }
    };
    Engine.prototype.disposeVariables = function () {
        for (var varName in this.registeredVariables) {
            var v = this.registeredVariables[varName];
            this.disposeTensor(v);
            delete this.registeredVariables[varName];
        }
    };
    Engine.prototype.memory = function () {
        var info = this.backend.memory();
        info.numTensors = this.numTensors;
        info.numDataBuffers = this.numDataBuffers;
        info.numBytes = this.numBytes;
        return info;
    };
    Engine.prototype.shouldRecord = function () {
        return this.activeTape != null && this.customGradientDepth === 0;
    };
    Engine.prototype.addTapeNode = function (inputs, result, gradientsFunc) {
        var inputsMap = {};
        inputs.forEach(function (input, idx) {
            inputsMap[idx] = input;
        });
        var gradient = function (dy) {
            var res = gradientsFunc(dy);
            var resMap = {};
            res.forEach(function (r, idx) {
                resMap[idx] = function () { return r; };
            });
            return resMap;
        };
        var tapeNode = {
            id: this.nextTapeNodeId++,
            name: this.activeScope.name,
            inputs: inputsMap,
            output: result,
            gradient: gradient
        };
        this.activeTape.push(tapeNode);
    };
    Engine.prototype.keep = function (result) {
        if (this.scopeStack.length === 1 && environment_1.ENV.engine.safeMode) {
            throw new Error('Safe mode is ON. Enclose all tensor operations inside tf.tidy(): ' +
                'tf.tidy(() => {...}) to avoid memory leaks.');
        }
        this.keepTensors.add(result.id);
        return result;
    };
    Engine.prototype.startScope = function (name, gradientsMode) {
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (gradientsMode && this.gradientScopeCount === 0) {
            this.activeTape = [];
        }
        if (gradientsMode) {
            this.gradientScopeCount++;
        }
        var scopeInfo = { track: [] };
        if (name) {
            scopeInfo.name = name;
        }
        this.scopeStack.push(scopeInfo);
        this.activeScope = scopeInfo;
    };
    Engine.prototype.endScope = function (result, gradientsMode) {
        var _this = this;
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (gradientsMode) {
            this.gradientScopeCount--;
            if (this.gradientScopeCount === 0) {
                this.activeTape = null;
            }
        }
        var tensorsToKeep = new Set(this.keepTensors);
        var tensorsToTrackInParent = util.getTensorsInContainer(result);
        tensorsToTrackInParent.forEach(function (tensor) { return tensorsToKeep.add(tensor.id); });
        for (var i = 0; i < this.activeScope.track.length; i++) {
            var tensor = this.activeScope.track[i];
            if (tensorsToKeep.has(tensor.id)) {
                continue;
            }
            if (this.activeTape != null) {
                tensorsToTrackInParent.push(tensor);
            }
            else {
                tensor.dispose();
            }
        }
        var oldScope = this.scopeStack.pop();
        this.activeScope = this.scopeStack.length === 0 ?
            { track: [] } :
            this.scopeStack[this.scopeStack.length - 1];
        tensorsToTrackInParent.forEach(function (tensor) {
            if (!_this.keepTensors.has(tensor.id) &&
                util.isTensorInList(tensor, oldScope.track)) {
                _this.track(tensor);
            }
        });
    };
    Engine.prototype.gradients = function (f, xs, dy, allowNoGradients) {
        var _this = this;
        if (allowNoGradients === void 0) { allowNoGradients = false; }
        util.assert(xs.length > 0, 'gradients() received an empty list of xs.');
        return globals_1.tidy('gradients', function () {
            var y = f();
            util.assert(y instanceof tensor_1.Tensor, 'The result y returned by f() must be a tensor.');
            var filteredTape = tape_1.getFilteredNodesXToY(_this.activeTape, xs, y);
            if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
                throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' +
                    'that the f you passed encloses all operations that lead from x ' +
                    'to y.');
            }
            var accumulatedGradientMap = {};
            accumulatedGradientMap[y.id] = (dy == null) ? ops.ones(y.shape) : dy;
            tape_1.backpropagateGradients(accumulatedGradientMap, filteredTape);
            var grads = xs.map(function (x) { return accumulatedGradientMap[x.id]; });
            return { value: y, grads: grads };
        }, true);
    };
    Engine.prototype.customGrad = function (f) {
        var _this = this;
        util.assert(util.isFunction(f), 'The f passed in customGrad(f) must be a function.');
        return function () {
            var inputs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                inputs[_i] = arguments[_i];
            }
            util.assert(inputs.every(function (t) { return t instanceof tensor_1.Tensor; }), 'The args passed in customGrad(f)(x1, x2,...) must all be tensors');
            _this.customGradientDepth++;
            var gradientsFunc;
            var gradientsMode = true;
            var result = globals_1.tidy(f.name, function () {
                var _a = f.apply(void 0, inputs), value = _a.value, gradFunc = _a.gradFunc;
                util.assert(value instanceof tensor_1.Tensor, 'The function f passed in customGrad(f) must return an object ' +
                    'where `obj.value` is a tensor');
                util.assert(util.isFunction(gradFunc), 'The function f passed in customGrad(f) must return an object ' +
                    'where `obj.gradFunc` is a function.');
                gradientsFunc = gradFunc;
                return value;
            }, gradientsMode);
            _this.customGradientDepth--;
            if (_this.shouldRecord()) {
                var gradFunc = function (dy) {
                    var res = gradientsFunc(dy);
                    var grads = Array.isArray(res) ? res : [res];
                    util.assert(grads.length === inputs.length, 'The function f passed in customGrad(f) must return an object ' +
                        'where `obj.gradFunc` is a function that returns the same ' +
                        'number of tensors as inputs passed to f(...).');
                    util.assert(grads.every(function (t) { return t instanceof tensor_1.Tensor; }), 'The function f passed in customGrad(f) must return an object ' +
                        'where `obj.gradFunc` is a function that returns a list of ' +
                        'only tensors.');
                    return grads;
                };
                _this.addTapeNode(inputs, result, gradFunc);
            }
            return result;
        };
    };
    Engine.prototype.write = function (dataId, values) {
        this.backend.write(dataId, values);
    };
    Engine.prototype.readSync = function (dataId) {
        return this.backend.readSync(dataId);
    };
    Engine.prototype.read = function (dataId) {
        return this.backend.read(dataId);
    };
    Engine.prototype.fromPixels = function (pixels, numChannels) {
        return this.backend.fromPixels(pixels, numChannels);
    };
    Engine.prototype.time = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var start, timingInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = performance.now();
                        return [4, this.backend.time(query)];
                    case 1:
                        timingInfo = _a.sent();
                        timingInfo.wallMs = performance.now() - start;
                        return [2, timingInfo];
                }
            });
        });
    };
    Engine.prototype.track = function (result) {
        if (this.scopeStack.length === 1 && this.safeMode) {
            throw new Error('Safe mode is ON. Enclose all tensor operations inside tf.tidy(): ' +
                'tf.tidy(() => {op();...}); to avoid memory leaks.');
        }
        this.activeScope.track.push(result);
        return result;
    };
    return Engine;
}());
exports.Engine = Engine;

},{"./environment":48,"./globals":49,"./ops/ops":124,"./profiler":146,"./tape":148,"./tensor":149,"./util":155}],48:[function(require,module,exports){
(function (process,global){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var device_util = require("./device_util");
var doc_1 = require("./doc");
var engine_1 = require("./engine");
var util = require("./util");
var Type;
(function (Type) {
    Type[Type["NUMBER"] = 0] = "NUMBER";
    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
    Type[Type["STRING"] = 2] = "STRING";
})(Type = exports.Type || (exports.Type = {}));
exports.URL_PROPERTIES = [
    { name: 'DEBUG', type: Type.BOOLEAN }, { name: 'IS_BROWSER', type: Type.BOOLEAN },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },
    { name: 'WEBGL_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN }, {
        name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',
        type: Type.BOOLEAN
    },
    { name: 'BACKEND', type: Type.STRING }
];
function hasExtension(gl, extensionName) {
    var ext = gl.getExtension(extensionName);
    return ext != null;
}
function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion === 0 || !exports.ENV.get('IS_BROWSER')) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    var tempCanvas = document.createElement('canvas');
    if (webGLVersion === 1) {
        return (tempCanvas.getContext('webgl') ||
            tempCanvas.getContext('experimental-webgl'));
    }
    return tempCanvas.getContext('webgl2');
}
function loseContext(gl) {
    if (gl != null) {
        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
        if (loseContextExtension == null) {
            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
        }
        loseContextExtension.loseContext();
    }
}
function isWebGLVersionEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    if (gl != null) {
        loseContext(gl);
        return true;
    }
    return false;
}
function getWebGLDisjointQueryTimerVersion(webGLVersion) {
    if (webGLVersion === 0) {
        return 0;
    }
    var queryTimerVersion;
    var gl = getWebGLRenderingContext(webGLVersion);
    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&
        webGLVersion === 2) {
        queryTimerVersion = 2;
    }
    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {
        queryTimerVersion = 1;
    }
    else {
        queryTimerVersion = 0;
    }
    if (gl != null) {
        loseContext(gl);
    }
    return queryTimerVersion;
}
function isFloatTextureReadPixelsEnabled(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    if (webGLVersion === 1) {
        if (!hasExtension(gl, 'OES_texture_float')) {
            return false;
        }
    }
    else {
        if (!hasExtension(gl, 'EXT_color_buffer_float')) {
            return false;
        }
    }
    var frameBuffer = gl.createFramebuffer();
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
    loseContext(gl);
    return frameBufferComplete && readPixelsNoError;
}
function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
    if (webGLVersion > 0) {
        return false;
    }
    if (webGLVersion !== 2) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    var isEnabled = hasExtension(gl, 'WEBGL_get_buffer_sub_data_async');
    loseContext(gl);
    return isEnabled;
}
var Environment = (function () {
    function Environment(features) {
        this.features = {};
        this.registry = {};
        if (features != null) {
            this.features = features;
        }
        if (this.get('DEBUG')) {
            console.warn('Debugging mode is ON. The output of every math call will ' +
                'be downloaded to CPU and checked for NaNs. ' +
                'This significantly impacts performance.');
        }
    }
    Environment.setBackend = function (backendType, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        if (!(backendType in exports.ENV.registry)) {
            throw new Error("Backend type '" + backendType + "' not found in registry");
        }
        exports.ENV.initBackend(backendType, safeMode);
    };
    Environment.getBackend = function () {
        exports.ENV.initDefaultBackend();
        return exports.ENV.currentBackend;
    };
    Environment.disposeVariables = function () {
        exports.ENV.engine.disposeVariables();
    };
    Environment.memory = function () {
        return exports.ENV.engine.memory();
    };
    Environment.prototype.get = function (feature) {
        if (feature in this.features) {
            return this.features[feature];
        }
        this.features[feature] = this.evaluateFeature(feature);
        return this.features[feature];
    };
    Environment.prototype.set = function (feature, value) {
        this.features[feature] = value;
    };
    Environment.prototype.getBestBackendType = function () {
        var _this = this;
        if (Object.keys(this.registry).length === 0) {
            throw new Error('No backend found in registry.');
        }
        var sortedBackends = Object.keys(this.registry)
            .map(function (name) {
            return { name: name, entry: _this.registry[name] };
        })
            .sort(function (a, b) {
            return b.entry.priority - a.entry.priority;
        });
        return sortedBackends[0].name;
    };
    Environment.prototype.evaluateFeature = function (feature) {
        if (feature === 'DEBUG') {
            return false;
        }
        else if (feature === 'IS_BROWSER') {
            return typeof window !== 'undefined';
        }
        else if (feature === 'IS_NODE') {
            return (typeof process !== 'undefined') &&
                (typeof process.versions.node !== 'undefined');
        }
        else if (feature === 'BACKEND') {
            return this.getBestBackendType();
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') {
            var webGLVersion = this.get('WEBGL_VERSION');
            if (webGLVersion === 0) {
                return 0;
            }
            return getWebGLDisjointQueryTimerVersion(webGLVersion);
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&
                !device_util.isMobile();
        }
        else if (feature === 'WEBGL_VERSION') {
            if (isWebGLVersionEnabled(2)) {
                return 2;
            }
            else if (isWebGLVersionEnabled(1)) {
                return 1;
            }
            return 0;
        }
        else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {
            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));
        }
        else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {
            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));
        }
        throw new Error("Unknown feature " + feature + ".");
    };
    Environment.prototype.setFeatures = function (features) {
        this.features = features;
    };
    Environment.prototype.reset = function () {
        this.features = getFeaturesFromURL();
        if (this.globalEngine != null) {
            this.globalEngine = null;
        }
    };
    Environment.prototype.initBackend = function (backendType, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        this.currentBackend = backendType;
        var backend = exports.ENV.findBackend(backendType);
        this.globalEngine = new engine_1.Engine(backend, safeMode);
    };
    Environment.prototype.findBackend = function (name) {
        if (!(name in this.registry)) {
            return null;
        }
        return this.registry[name].backend;
    };
    Environment.prototype.registerBackend = function (name, factory, priority) {
        if (priority === void 0) { priority = 1; }
        if (name in this.registry) {
            console.warn(name + " backend was already registered");
        }
        try {
            var backend = factory();
            this.registry[name] = { backend: backend, priority: priority };
            return true;
        }
        catch (err) {
            console.warn("Registration of backend " + name + " failed");
            console.warn(err.stack || err.message);
            return false;
        }
    };
    Environment.prototype.removeBackend = function (name) {
        if (!(name in this.registry)) {
            throw new Error(name + " backend not found in registry");
        }
        this.registry[name].backend.dispose();
        delete this.registry[name];
    };
    Object.defineProperty(Environment.prototype, "engine", {
        get: function () {
            this.initDefaultBackend();
            return this.globalEngine;
        },
        enumerable: true,
        configurable: true
    });
    Environment.prototype.initDefaultBackend = function () {
        if (this.globalEngine == null) {
            this.initBackend(exports.ENV.get('BACKEND'), false);
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Environment' })
    ], Environment, "setBackend", null);
    __decorate([
        doc_1.doc({ heading: 'Environment' })
    ], Environment, "getBackend", null);
    __decorate([
        doc_1.doc({ heading: 'Environment' })
    ], Environment, "disposeVariables", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Environment, "memory", null);
    return Environment;
}());
exports.Environment = Environment;
var TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';
function getFeaturesFromURL() {
    var features = {};
    if (typeof window === 'undefined' || typeof window.location === 'undefined') {
        return features;
    }
    var urlParams = util.getQueryParams(window.location.search);
    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
        var urlFlags_1 = {};
        var keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');
        keyValues.forEach(function (keyValue) {
            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
            urlFlags_1[key] = value;
        });
        exports.URL_PROPERTIES.forEach(function (urlProperty) {
            if (urlProperty.name in urlFlags_1) {
                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                    ("" + urlFlags_1[urlProperty.name]));
                if (urlProperty.type === Type.NUMBER) {
                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                }
                else if (urlProperty.type === Type.BOOLEAN) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                }
                else if (urlProperty.type === Type.STRING) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name];
                }
                else {
                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                }
            }
        });
    }
    return features;
}
function getGlobalNamespace() {
    var ns;
    if (typeof (window) !== 'undefined') {
        ns = window;
    }
    else if (typeof (global) !== 'undefined') {
        ns = global;
    }
    else {
        throw new Error('Could not find a global object');
    }
    return ns;
}
function getOrMakeEnvironment() {
    var ns = getGlobalNamespace();
    ns.ENV = ns.ENV || new Environment(getFeaturesFromURL());
    return ns.ENV;
}
exports.ENV = getOrMakeEnvironment();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./device_util":45,"./doc":46,"./engine":47,"./util":155,"_process":217}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gradients_1 = require("./gradients");
var tracking_1 = require("./tracking");
exports.tidy = tracking_1.Tracking.tidy;
exports.keep = tracking_1.Tracking.keep;
exports.dispose = tracking_1.Tracking.dispose;
exports.time = tracking_1.Tracking.time;
exports.grad = gradients_1.Gradients.grad;
exports.valueAndGrad = gradients_1.Gradients.valueAndGrad;
exports.grads = gradients_1.Gradients.grads;
exports.valueAndGrads = gradients_1.Gradients.valueAndGrads;
exports.variableGrads = gradients_1.Gradients.variableGrads;
exports.customGrad = gradients_1.Gradients.customGrad;

},{"./gradients":50,"./tracking":152}],50:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var globals_1 = require("./globals");
var tensor_1 = require("./tensor");
var util = require("./util");
var Gradients = (function () {
    function Gradients() {
    }
    Gradients.gradScope = function (nameOrScopeFn, scopeFn) {
        return globals_1.tidy(nameOrScopeFn, scopeFn, true);
    };
    Gradients.grad = function (f) {
        util.assert(util.isFunction(f), 'The f passed in grad(f) must be a function');
        return function (x, dy) {
            util.assert(x instanceof tensor_1.Tensor, 'The x passed in grad(f)(x) must be a tensor');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in grad(f)(x, dy) must be a tensor');
            return globals_1.tidy(function () {
                var _a = environment_1.ENV.engine.gradients(function () { return f(x); }, [x], dy), value = _a.value, grads = _a.grads;
                if (dy != null) {
                    util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grad(f)(x, dy) must match the shape ' +
                        'returned by f(x)');
                }
                checkGrads(grads);
                return grads[0];
            });
        };
    };
    Gradients.grads = function (f) {
        util.assert(util.isFunction(f), 'The f passed in grads(f) must be a function');
        return function (args, dy) {
            util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof tensor_1.Tensor; }), 'The args passed in grads(f)(args) must be an array of tensors');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in grads(f)(args, dy) must be a tensor');
            return globals_1.tidy(function () {
                var _a = environment_1.ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy), value = _a.value, grads = _a.grads;
                if (dy != null) {
                    util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grads(f)([x1,...], dy) must ' +
                        'match the shape returned by f([x1,...])');
                }
                checkGrads(grads);
                return grads;
            });
        };
    };
    Gradients.valueAndGrad = function (f) {
        util.assert(util.isFunction(f), 'The f passed in valueAndGrad(f) must be a function');
        return function (x, dy) {
            util.assert(x instanceof tensor_1.Tensor, 'The x passed in valueAndGrad(f)(x) must be a tensor');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in valueAndGrad(f)(x, dy) must be a tensor');
            var _a = environment_1.ENV.engine.gradients(function () { return f(x); }, [x], dy), grads = _a.grads, value = _a.value;
            checkGrads(grads);
            return { grad: grads[0], value: value };
        };
    };
    Gradients.valueAndGrads = function (f) {
        util.assert(util.isFunction(f), 'The f passed in valueAndGrads(f) must be a function');
        return function (args, dy) {
            util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof tensor_1.Tensor; }), 'The args passed in valueAndGrads(f)(args) must be array of tensors');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in valueAndGrads(f)(args, dy) must be a tensor');
            var res = environment_1.ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy);
            if (dy != null) {
                util.assertShapesMatch(res.value.shape, dy.shape, 'The shape of dy passed in valueAndGrads(f)([x1,...], dy) must ' +
                    'match the shape returned by f([x1,...])');
            }
            checkGrads(res.grads);
            return res;
        };
    };
    Gradients.variableGrads = function (f, varList) {
        util.assert(util.isFunction(f), 'The f passed in variableGrads(f) must be a function');
        util.assert(varList == null ||
            Array.isArray(varList) && varList.every(function (v) { return v instanceof tensor_1.Variable; }), 'The varList passed in variableGrads(f, varList) must be an array ' +
            'of variables');
        if (varList == null) {
            varList = [];
            for (var varName in environment_1.ENV.engine.registeredVariables) {
                varList.push(environment_1.ENV.engine.registeredVariables[varName]);
            }
        }
        var originalVarCount = varList.length;
        varList = varList.filter(function (variable) { return variable.trainable; });
        util.assert(varList.length > 0, "variableGrads() expects at least one of the input variables to be " +
            ("trainable, but none of the " + originalVarCount + " variables is ") +
            "trainable.");
        var allowNoGradients = true;
        var _a = environment_1.ENV.engine.gradients(f, varList, null, allowNoGradients), value = _a.value, grads = _a.grads;
        util.assert(grads.some(function (g) { return g != null; }), 'Cannot find a connection between any variable and the result of the ' +
            'loss function y=f(x). Please make sure the operations that use ' +
            'variables are inside the function f passed to minimize().');
        util.assert(value.rank === 0, "The f passed in variableGrads(f) must return a scalar, but it " +
            ("returned a rank-" + value.rank + " tensor"));
        var namedGrads = {};
        varList.forEach(function (v, i) {
            if (grads[i] != null) {
                namedGrads[v.name] = grads[i];
            }
        });
        return { value: value, grads: namedGrads };
    };
    Gradients.customGrad = function (f) {
        return environment_1.ENV.engine.customGrad(f);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "grad", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "grads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "valueAndGrad", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "valueAndGrads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "variableGrads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "customGrad", null);
    return Gradients;
}());
exports.Gradients = Gradients;
function checkGrads(grads) {
    var numNullGradients = grads.filter(function (g) { return g == null; }).length;
    if (numNullGradients > 0) {
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
    }
}

},{"./doc":46,"./environment":48,"./globals":49,"./tensor":149,"./util":155}],51:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
require("./kernels/backend_webgl");
require("./kernels/backend_cpu");
var browser_util_1 = require("./browser_util");
var environment = require("./environment");
exports.environment = environment;
var environment_1 = require("./environment");
var io = require("./io/io");
exports.io = io;
var serialization = require("./serialization");
exports.serialization = serialization;
var test_util = require("./test_util");
exports.test_util = test_util;
var util = require("./util");
exports.util = util;
var version_1 = require("./version");
exports.version_core = version_1.version;
var webgl = require("./webgl");
exports.webgl = webgl;
var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
var adam_optimizer_1 = require("./optimizers/adam_optimizer");
exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
var optimizer_1 = require("./optimizers/optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
var tensor_1 = require("./tensor");
exports.Tensor = tensor_1.Tensor;
exports.TensorBuffer = tensor_1.TensorBuffer;
exports.variable = tensor_1.variable;
exports.Variable = tensor_1.Variable;
var types_1 = require("./types");
exports.Rank = types_1.Rank;
__export(require("./ops/ops"));
var loss_ops_1 = require("./ops/loss_ops");
exports.Reduction = loss_ops_1.Reduction;
__export(require("./train"));
__export(require("./globals"));
var environment_2 = require("./environment");
exports.ENV = environment_2.ENV;
exports.Environment = environment_2.Environment;
exports.setBackend = environment_1.Environment.setBackend;
exports.getBackend = environment_1.Environment.getBackend;
exports.disposeVariables = environment_1.Environment.disposeVariables;
exports.memory = environment_1.Environment.memory;
var doc_1 = require("./doc");
exports.doc = doc_1.doc;
exports.nextFrame = browser_util_1.BrowserUtil.nextFrame;

},{"./browser_util":44,"./doc":46,"./environment":48,"./globals":49,"./io/io":55,"./kernels/backend_cpu":62,"./kernels/backend_webgl":64,"./ops/loss_ops":117,"./ops/ops":124,"./optimizers/adadelta_optimizer":137,"./optimizers/adagrad_optimizer":138,"./optimizers/adam_optimizer":139,"./optimizers/adamax_optimizer":140,"./optimizers/momentum_optimizer":141,"./optimizers/optimizer":142,"./optimizers/rmsprop_optimizer":144,"./optimizers/sgd_optimizer":145,"./serialization":147,"./tensor":149,"./test_util":151,"./train":153,"./types":154,"./util":155,"./version":156,"./webgl":157}],52:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var io_utils_1 = require("./io_utils");
var router_registry_1 = require("./router_registry");
var DEFAULT_FILE_NAME_PREFIX = 'model';
var DEFAULT_JSON_EXTENSION_NAME = '.json';
var DEFAULT_WEIGHT_DATA_EXTENSION_NAME = '.weights.bin';
var BrowserDownloads = (function () {
    function BrowserDownloads(fileNamePrefix) {
        if (!environment_1.ENV.get('IS_BROWSER')) {
            throw new Error('triggerDownloads() cannot proceed because the current environment ' +
                'is not a browser.');
        }
        if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
            fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
        }
        if (fileNamePrefix == null || fileNamePrefix.length === 0) {
            fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
        }
        this.modelTopologyFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
        this.weightDataFileName =
            fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
    }
    BrowserDownloads.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var weightsURL, weightsManifest, modelTopologyAndWeightManifest, modelTopologyAndWeightManifestURL, jsonAnchor, weightDataAnchor;
            return __generator(this, function (_a) {
                weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: 'application/octet-stream' }));
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('DownloadTrigger.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                else {
                    weightsManifest = [{
                            paths: ['./' + this.weightDataFileName],
                            weights: modelArtifacts.weightSpecs
                        }];
                    modelTopologyAndWeightManifest = {
                        modelTopology: modelArtifacts.modelTopology,
                        weightsManifest: weightsManifest
                    };
                    modelTopologyAndWeightManifestURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: 'application/json' }));
                    jsonAnchor = this.jsonAnchor == null ? document.createElement('a') :
                        this.jsonAnchor;
                    jsonAnchor.download = this.modelTopologyFileName;
                    jsonAnchor.href = modelTopologyAndWeightManifestURL;
                    jsonAnchor.click();
                    if (modelArtifacts.weightData != null) {
                        weightDataAnchor = this.weightDataAnchor == null ?
                            document.createElement('a') :
                            this.weightDataAnchor;
                        weightDataAnchor.download = this.weightDataFileName;
                        weightDataAnchor.href = weightsURL;
                        weightDataAnchor.click();
                    }
                    return [2, { modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts) }];
                }
                return [2];
            });
        });
    };
    BrowserDownloads.URL_SCHEME = 'downloads://';
    return BrowserDownloads;
}());
exports.BrowserDownloads = BrowserDownloads;
var BrowserFiles = (function () {
    function BrowserFiles(files) {
        if (files == null || files.length < 1) {
            throw new Error("When calling browserFiles, at least 1 file is required, " +
                ("but received " + files));
        }
        this.files = files;
    }
    BrowserFiles.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var jsonFile, weightFiles;
            return __generator(this, function (_a) {
                jsonFile = this.files[0];
                weightFiles = this.files.slice(1);
                return [2, new Promise(function (resolve, reject) {
                        var jsonReader = new FileReader();
                        jsonReader.onload = function (event) {
                            var modelJSON = JSON.parse(event.target.result);
                            var modelTopology = modelJSON.modelTopology;
                            if (modelTopology == null) {
                                reject(new Error("modelTopology field is missing from file " + jsonFile.name));
                                return;
                            }
                            if (weightFiles.length === 0) {
                                resolve({ modelTopology: modelTopology });
                            }
                            var weightsManifest = modelJSON.weightsManifest;
                            if (weightsManifest == null) {
                                reject(new Error("weightManifest field is missing from file " + jsonFile.name));
                                return;
                            }
                            var pathToFile;
                            try {
                                pathToFile =
                                    _this.checkManifestAndWeightFiles(weightsManifest, weightFiles);
                            }
                            catch (err) {
                                reject(err);
                                return;
                            }
                            var weightSpecs = [];
                            var paths = [];
                            var perFileBuffers = [];
                            weightsManifest.forEach(function (weightsGroup) {
                                weightsGroup.paths.forEach(function (path) {
                                    paths.push(path);
                                    perFileBuffers.push(null);
                                });
                                weightSpecs.push.apply(weightSpecs, weightsGroup.weights);
                            });
                            weightsManifest.forEach(function (weightsGroup) {
                                weightsGroup.paths.forEach(function (path) {
                                    var weightFileReader = new FileReader();
                                    weightFileReader.onload = function (event) {
                                        var weightData = event.target.result;
                                        var index = paths.indexOf(path);
                                        perFileBuffers[index] = weightData;
                                        if (perFileBuffers.indexOf(null) === -1) {
                                            resolve({
                                                modelTopology: modelTopology,
                                                weightSpecs: weightSpecs,
                                                weightData: io_utils_1.concatenateArrayBuffers(perFileBuffers),
                                            });
                                        }
                                    };
                                    weightFileReader.onerror = function (error) {
                                        reject("Failed to weights data from file of path '" + path + "'.");
                                        return;
                                    };
                                    weightFileReader.readAsArrayBuffer(pathToFile[path]);
                                });
                            });
                        };
                        jsonReader.onerror = function (error) {
                            reject("Failed to read model topology and weights manifest JSON " +
                                ("from file '" + jsonFile.name + "'. BrowserFiles supports loading ") +
                                "Keras-style tf.Model artifacts only.");
                            return;
                        };
                        jsonReader.readAsText(jsonFile);
                    })];
            });
        });
    };
    BrowserFiles.prototype.checkManifestAndWeightFiles = function (manifest, files) {
        var basenames = [];
        var fileNames = files.map(function (file) { return io_utils_1.basename(file.name); });
        var pathToFile = {};
        for (var _i = 0, manifest_1 = manifest; _i < manifest_1.length; _i++) {
            var group = manifest_1[_i];
            group.paths.forEach(function (path) {
                var pathBasename = io_utils_1.basename(path);
                if (basenames.indexOf(pathBasename) !== -1) {
                    throw new Error("Duplicate file basename found in weights manifest: " +
                        ("'" + pathBasename + "'"));
                }
                basenames.push(pathBasename);
                if (fileNames.indexOf(pathBasename) === -1) {
                    throw new Error("Weight file with basename '" + pathBasename + "' is not provided.");
                }
                else {
                    pathToFile[path] = files[fileNames.indexOf(pathBasename)];
                }
            });
        }
        if (basenames.length !== files.length) {
            throw new Error("Mismatch in the number of files in weights manifest " +
                ("(" + basenames.length + ") and the number of weight files provided ") +
                ("(" + files.length + ")."));
        }
        return pathToFile;
    };
    return BrowserFiles;
}());
exports.browserDownloadsRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (url.startsWith(BrowserDownloads.URL_SCHEME)) {
            return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.browserDownloadsRouter);
function browserDownloads(fileNamePrefix) {
    if (fileNamePrefix === void 0) { fileNamePrefix = 'model'; }
    return new BrowserDownloads(fileNamePrefix);
}
exports.browserDownloads = browserDownloads;
function browserFiles(files) {
    return new BrowserFiles(files);
}
exports.browserFiles = browserFiles;

},{"../environment":48,"./io_utils":56,"./router_registry":59}],53:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util_1 = require("../util");
var io_utils_1 = require("./io_utils");
var router_registry_1 = require("./router_registry");
var weights_loader_1 = require("./weights_loader");
var BrowserHTTPRequest = (function () {
    function BrowserHTTPRequest(path, requestInit) {
        this.DEFAULT_METHOD = 'POST';
        if (!environment_1.ENV.get('IS_BROWSER')) {
            throw new Error('browserHTTPRequest is not supported outside the web browser.');
        }
        util_1.assert(path != null && path.length > 0, 'URL path for browserHTTPRequest must not be null, undefined or ' +
            'empty.');
        this.path = path;
        if (requestInit != null && requestInit.body != null) {
            throw new Error('requestInit is expected to have no pre-existing body, but has one.');
        }
        this.requestInit = requestInit || {};
    }
    BrowserHTTPRequest.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var init, weightsManifest, modelTopologyAndWeightManifest, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                            throw new Error('BrowserHTTPRequest.save() does not support saving model topology ' +
                                'in binary formats yet.');
                        }
                        init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
                        init.body = new FormData();
                        weightsManifest = [{
                                paths: ['./model.weights.bin'],
                                weights: modelArtifacts.weightSpecs,
                            }];
                        modelTopologyAndWeightManifest = {
                            modelTopology: modelArtifacts.modelTopology,
                            weightsManifest: weightsManifest
                        };
                        init.body.append('model.json', new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: 'application/json' }), 'model.json');
                        if (modelArtifacts.weightData != null) {
                            init.body.append('model.weights.bin', new Blob([modelArtifacts.weightData], { type: 'application/octet-stream' }), 'model.weights.bin');
                        }
                        return [4, fetch(this.path, init)];
                    case 1:
                        response = _a.sent();
                        if (response.status === 200) {
                            return [2, {
                                    modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts),
                                    responses: [response],
                                }];
                        }
                        else {
                            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " +
                                (response.status + "."));
                        }
                        return [2];
                }
            });
        });
    };
    BrowserHTTPRequest.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var modelConfigRequest, modelConfig, modelTopology, weightsManifest, weightSpecs, weightData, weightsManifest_1, _i, weightsManifest_2, entry, pathPrefix_1, fetchURLs_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, fetch(this.path, this.requestInit)];
                    case 1:
                        modelConfigRequest = _b.sent();
                        return [4, modelConfigRequest.json()];
                    case 2:
                        modelConfig = _b.sent();
                        modelTopology = modelConfig['modelTopology'];
                        weightsManifest = modelConfig['weightsManifest'];
                        if (modelTopology == null && weightsManifest == null) {
                            throw new Error("The JSON from HTTP path " + this.path + " contains neither model " +
                                "topology or manifest for weights.");
                        }
                        if (!(weightsManifest != null)) return [3, 4];
                        weightsManifest_1 = modelConfig['weightsManifest'];
                        weightSpecs = [];
                        for (_i = 0, weightsManifest_2 = weightsManifest_1; _i < weightsManifest_2.length; _i++) {
                            entry = weightsManifest_2[_i];
                            weightSpecs.push.apply(weightSpecs, entry.weights);
                        }
                        pathPrefix_1 = this.path.substring(0, this.path.lastIndexOf('/'));
                        if (!pathPrefix_1.endsWith('/')) {
                            pathPrefix_1 = pathPrefix_1 + '/';
                        }
                        fetchURLs_1 = [];
                        weightsManifest_1.forEach(function (weightsGroup) {
                            weightsGroup.paths.forEach(function (path) {
                                fetchURLs_1.push(pathPrefix_1 + path);
                            });
                        });
                        _a = io_utils_1.concatenateArrayBuffers;
                        return [4, weights_loader_1.loadWeightsAsArrayBuffer(fetchURLs_1, this.requestInit)];
                    case 3:
                        weightData = _a.apply(void 0, [_b.sent()]);
                        _b.label = 4;
                    case 4: return [2, { modelTopology: modelTopology, weightSpecs: weightSpecs, weightData: weightData }];
                }
            });
        });
    };
    BrowserHTTPRequest.URL_SCHEMES = ['http://', 'https://'];
    return BrowserHTTPRequest;
}());
exports.BrowserHTTPRequest = BrowserHTTPRequest;
exports.httpRequestRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        for (var _i = 0, _a = BrowserHTTPRequest.URL_SCHEMES; _i < _a.length; _i++) {
            var scheme = _a[_i];
            if (url.startsWith(scheme)) {
                return browserHTTPRequest(url);
            }
        }
        return null;
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.httpRequestRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.httpRequestRouter);
function browserHTTPRequest(path, requestInit) {
    return new BrowserHTTPRequest(path, requestInit);
}
exports.browserHTTPRequest = browserHTTPRequest;

},{"../environment":48,"../util":155,"./io_utils":56,"./router_registry":59,"./weights_loader":61}],54:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var io_utils_1 = require("./io_utils");
var model_management_1 = require("./model_management");
var router_registry_1 = require("./router_registry");
var DATABASE_NAME = 'tensorflowjs';
var DATABASE_VERSION = 1;
var MODEL_STORE_NAME = 'models_store';
var INFO_STORE_NAME = 'model_info_store';
function deleteDatabase() {
    return __awaiter(this, void 0, void 0, function () {
        var idbFactory;
        return __generator(this, function (_a) {
            idbFactory = getIndexedDBFactory();
            return [2, new Promise(function (resolve, reject) {
                    var deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);
                    deleteRequest.onsuccess = function () { return resolve(); };
                    deleteRequest.onerror = function (error) { return reject(error); };
                })];
        });
    });
}
exports.deleteDatabase = deleteDatabase;
function getIndexedDBFactory() {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        throw new Error('Failed to obtain IndexedDB factory because the current environment' +
            'is not a web browser.');
    }
    var theWindow = window;
    var factory = theWindow.indexedDB || theWindow.mozIndexedDB ||
        theWindow.webkitIndexedDB || theWindow.msIndexedDB ||
        theWindow.shimIndexedDB;
    if (factory == null) {
        throw new Error('The current browser does not appear to support IndexedDB.');
    }
    return factory;
}
function setUpDatabase(openRequest) {
    var db = openRequest.result;
    db.createObjectStore(MODEL_STORE_NAME, { keyPath: 'modelPath' });
    db.createObjectStore(INFO_STORE_NAME, { keyPath: 'modelPath' });
}
var BrowserIndexedDB = (function () {
    function BrowserIndexedDB(modelPath) {
        this.indexedDB = getIndexedDBFactory();
        if (modelPath == null || !modelPath) {
            throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');
        }
        this.modelPath = modelPath;
    }
    BrowserIndexedDB.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                return [2, this.databaseAction(this.modelPath, modelArtifacts)];
            });
        });
    };
    BrowserIndexedDB.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.databaseAction(this.modelPath)];
            });
        });
    };
    BrowserIndexedDB.prototype.databaseAction = function (modelPath, modelArtifacts) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
            openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
            openRequest.onsuccess = function () {
                var db = openRequest.result;
                if (modelArtifacts == null) {
                    var modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');
                    var modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                    var getRequest_1 = modelStore.get(_this.modelPath);
                    getRequest_1.onsuccess = function () {
                        if (getRequest_1.result == null) {
                            db.close();
                            return reject(new Error("Cannot find model with path '" + _this.modelPath + "' " +
                                "in IndexedDB."));
                        }
                        else {
                            resolve(getRequest_1.result.modelArtifacts);
                        }
                    };
                    getRequest_1.onerror = function (error) {
                        db.close();
                        return reject(getRequest_1.error);
                    };
                    modelTx.oncomplete = function () { return db.close(); };
                }
                else {
                    var modelArtifactsInfo_1 = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);
                    var infoTx_1 = db.transaction(INFO_STORE_NAME, 'readwrite');
                    var infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);
                    var putInfoRequest_1 = infoStore_1.put({ modelPath: _this.modelPath, modelArtifactsInfo: modelArtifactsInfo_1 });
                    var modelTx_1;
                    putInfoRequest_1.onsuccess = function () {
                        modelTx_1 = db.transaction(MODEL_STORE_NAME, 'readwrite');
                        var modelStore = modelTx_1.objectStore(MODEL_STORE_NAME);
                        var putModelRequest = modelStore.put({
                            modelPath: _this.modelPath,
                            modelArtifacts: modelArtifacts,
                            modelArtifactsInfo: modelArtifactsInfo_1
                        });
                        putModelRequest.onsuccess = function () { return resolve({ modelArtifactsInfo: modelArtifactsInfo_1 }); };
                        putModelRequest.onerror = function (error) {
                            infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);
                            var deleteInfoRequest = infoStore_1.delete(_this.modelPath);
                            deleteInfoRequest.onsuccess = function () {
                                db.close();
                                return reject(putModelRequest.error);
                            };
                            deleteInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(putModelRequest.error);
                            };
                        };
                    };
                    putInfoRequest_1.onerror = function (error) {
                        db.close();
                        return reject(putInfoRequest_1.error);
                    };
                    infoTx_1.oncomplete = function () {
                        if (modelTx_1 == null) {
                            db.close();
                        }
                        else {
                            modelTx_1.oncomplete = function () { return db.close(); };
                        }
                    };
                }
            };
            openRequest.onerror = function (error) { return reject(openRequest.error); };
        });
    };
    BrowserIndexedDB.URL_SCHEME = 'indexeddb://';
    return BrowserIndexedDB;
}());
exports.BrowserIndexedDB = BrowserIndexedDB;
exports.indexedDBRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
            return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.indexedDBRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.indexedDBRouter);
function browserIndexedDB(modelPath) {
    return new BrowserIndexedDB(modelPath);
}
exports.browserIndexedDB = browserIndexedDB;
function maybeStripScheme(key) {
    return key.startsWith(BrowserIndexedDB.URL_SCHEME) ?
        key.slice(BrowserIndexedDB.URL_SCHEME.length) :
        key;
}
var BrowserIndexedDBManager = (function () {
    function BrowserIndexedDBManager() {
        this.indexedDB = getIndexedDBFactory();
    }
    BrowserIndexedDBManager.prototype.listModels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, new Promise(function (resolve, reject) {
                        var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                        openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
                        openRequest.onsuccess = function () {
                            var db = openRequest.result;
                            var tx = db.transaction(INFO_STORE_NAME, 'readonly');
                            var store = tx.objectStore(INFO_STORE_NAME);
                            var getAllInfoRequest = store.getAll();
                            getAllInfoRequest.onsuccess = function () {
                                var out = {};
                                for (var _i = 0, _a = getAllInfoRequest.result; _i < _a.length; _i++) {
                                    var item = _a[_i];
                                    out[item.modelPath] = item.modelArtifactsInfo;
                                }
                                resolve(out);
                            };
                            getAllInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(getAllInfoRequest.error);
                            };
                            tx.oncomplete = function () { return db.close(); };
                        };
                        openRequest.onerror = function (error) { return reject(openRequest.error); };
                    })];
            });
        });
    };
    BrowserIndexedDBManager.prototype.removeModel = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                path = maybeStripScheme(path);
                return [2, new Promise(function (resolve, reject) {
                        var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                        openRequest.onupgradeneeded = function () { return setUpDatabase(openRequest); };
                        openRequest.onsuccess = function () {
                            var db = openRequest.result;
                            var infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');
                            var infoStore = infoTx.objectStore(INFO_STORE_NAME);
                            var getInfoRequest = infoStore.get(path);
                            var modelTx;
                            getInfoRequest.onsuccess = function () {
                                if (getInfoRequest.result == null) {
                                    db.close();
                                    return reject(new Error("Cannot find model with path '" + path + "' " +
                                        "in IndexedDB."));
                                }
                                else {
                                    var deleteInfoRequest = infoStore.delete(path);
                                    var deleteModelData_1 = function () {
                                        modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');
                                        var modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                                        var deleteModelRequest = modelStore.delete(path);
                                        deleteModelRequest.onsuccess = function () {
                                            return resolve(getInfoRequest.result.modelArtifactsInfo);
                                        };
                                        deleteModelRequest.onerror = function (error) {
                                            return reject(getInfoRequest.error);
                                        };
                                    };
                                    deleteInfoRequest.onsuccess = deleteModelData_1;
                                    deleteInfoRequest.onerror = function (error) {
                                        deleteModelData_1();
                                        db.close();
                                        return reject(getInfoRequest.error);
                                    };
                                }
                            };
                            getInfoRequest.onerror = function (error) {
                                db.close();
                                return reject(getInfoRequest.error);
                            };
                            infoTx.oncomplete = function () {
                                if (modelTx == null) {
                                    db.close();
                                }
                                else {
                                    modelTx.oncomplete = function () { return db.close(); };
                                }
                            };
                        };
                        openRequest.onerror = function (error) { return reject(openRequest.error); };
                    })];
            });
        });
    };
    return BrowserIndexedDBManager;
}());
exports.BrowserIndexedDBManager = BrowserIndexedDBManager;
if (environment_1.ENV.get('IS_BROWSER')) {
    try {
        model_management_1.ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
    }
    catch (err) {
    }
}

},{"../environment":48,"./io_utils":56,"./model_management":58,"./router_registry":59}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./indexed_db");
require("./local_storage");
var browser_files_1 = require("./browser_files");
exports.browserFiles = browser_files_1.browserFiles;
var browser_http_1 = require("./browser_http");
exports.browserHTTPRequest = browser_http_1.browserHTTPRequest;
var io_utils_1 = require("./io_utils");
exports.decodeWeights = io_utils_1.decodeWeights;
exports.encodeWeights = io_utils_1.encodeWeights;
exports.getModelArtifactsInfoForJSON = io_utils_1.getModelArtifactsInfoForJSON;
var model_management_1 = require("./model_management");
var router_registry_1 = require("./router_registry");
var weights_loader_1 = require("./weights_loader");
exports.loadWeights = weights_loader_1.loadWeights;
var registerSaveRouter = router_registry_1.IORouterRegistry.registerSaveRouter;
exports.registerSaveRouter = registerSaveRouter;
var registerLoadRouter = router_registry_1.IORouterRegistry.registerLoadRouter;
exports.registerLoadRouter = registerLoadRouter;
var getSaveHandlers = router_registry_1.IORouterRegistry.getSaveHandlers;
exports.getSaveHandlers = getSaveHandlers;
var getLoadHandlers = router_registry_1.IORouterRegistry.getLoadHandlers;
exports.getLoadHandlers = getLoadHandlers;
var copyModel = model_management_1.ModelManagement.copyModel;
exports.copyModel = copyModel;
var listModels = model_management_1.ModelManagement.listModels;
exports.listModels = listModels;
var moveModel = model_management_1.ModelManagement.moveModel;
exports.moveModel = moveModel;
var removeModel = model_management_1.ModelManagement.removeModel;
exports.removeModel = removeModel;

},{"./browser_files":52,"./browser_http":53,"./indexed_db":54,"./io_utils":56,"./local_storage":57,"./model_management":58,"./router_registry":59,"./weights_loader":61}],56:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var array_ops_1 = require("../ops/array_ops");
var util_1 = require("../util");
var types_1 = require("./types");
function encodeWeights(tensors) {
    return __awaiter(this, void 0, void 0, function () {
        var specs, dataPromises, name_1, t, tensorValues;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    specs = [];
                    dataPromises = [];
                    for (name_1 in tensors) {
                        t = tensors[name_1];
                        if (t.dtype !== 'float32' && t.dtype !== 'int32' && t.dtype !== 'bool') {
                            throw new Error("Unsupported dtype in weight '" + name_1 + "': " + t.dtype);
                        }
                        specs.push({ name: name_1, shape: t.shape, dtype: t.dtype });
                        dataPromises.push(t.data());
                    }
                    return [4, Promise.all(dataPromises)];
                case 1:
                    tensorValues = _a.sent();
                    return [2, { data: concatenateTypedArrays(tensorValues), specs: specs }];
            }
        });
    });
}
exports.encodeWeights = encodeWeights;
function decodeWeights(buffer, specs) {
    var out = {};
    var offset = 0;
    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
        var spec = specs_1[_i];
        var name_2 = spec.name;
        var dtype = spec.dtype;
        var shape = spec.shape;
        if (spec.quantization != null) {
            throw new Error("decodeWeights does not support quantization yet, but encountered " +
                ("weight '" + name_2 + " with quantization.'"));
        }
        var size = util_1.sizeFromShape(shape);
        var value = void 0;
        if (dtype === 'float32') {
            value = array_ops_1.ArrayOps.tensor(new Float32Array(buffer, offset, size), shape, 'float32');
        }
        else if (dtype === 'int32') {
            value =
                array_ops_1.ArrayOps.tensor(new Int32Array(buffer, offset, size), shape, 'int32');
        }
        else if (dtype === 'bool') {
            value =
                array_ops_1.ArrayOps.tensor(new Uint8Array(buffer, offset, size), shape, 'bool');
        }
        else {
            throw new Error("Unsupported dtype in weight '" + name_2 + "': " + dtype);
        }
        out[name_2] = value;
        offset += size * types_1.DTYPE_VALUE_SIZE_MAP[dtype];
    }
    return out;
}
exports.decodeWeights = decodeWeights;
function concatenateTypedArrays(xs) {
    if (xs === null) {
        throw new Error("Invalid input value: " + JSON.stringify(xs));
    }
    var totalByteLength = 0;
    xs.forEach(function (x) {
        if (x instanceof Float32Array || x instanceof Int32Array) {
            totalByteLength += x.length * 4;
        }
        else if (x instanceof Uint8Array) {
            totalByteLength += x.length;
        }
        else {
            throw new Error("Unsupported TypedArray subtype: " + x.constructor.name);
        }
    });
    var y = new Uint8Array(totalByteLength);
    var offset = 0;
    xs.forEach(function (x) {
        y.set(new Uint8Array(x.buffer), offset);
        if (x instanceof Float32Array || x instanceof Int32Array) {
            offset += x.length * 4;
        }
        else {
            offset += x.length;
        }
    });
    return y.buffer;
}
exports.concatenateTypedArrays = concatenateTypedArrays;
function stringByteLength(str) {
    return new Blob([str]).size;
}
exports.stringByteLength = stringByteLength;
function arrayBufferToBase64String(buffer) {
    return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
}
exports.arrayBufferToBase64String = arrayBufferToBase64String;
function base64StringToArrayBuffer(str) {
    var s = atob(str);
    var buffer = new Uint8Array(s.length);
    for (var i = 0; i < s.length; ++i) {
        buffer.set([s.charCodeAt(i)], i);
    }
    return buffer.buffer;
}
exports.base64StringToArrayBuffer = base64StringToArrayBuffer;
function concatenateArrayBuffers(buffers) {
    var totalByteLength = 0;
    buffers.forEach(function (buffer) {
        totalByteLength += buffer.byteLength;
    });
    var temp = new Uint8Array(totalByteLength);
    var offset = 0;
    buffers.forEach(function (buffer) {
        temp.set(new Uint8Array(buffer), offset);
        offset += buffer.byteLength;
    });
    return temp.buffer;
}
exports.concatenateArrayBuffers = concatenateArrayBuffers;
function basename(path) {
    var SEPARATOR = '/';
    path = path.trim();
    while (path.endsWith(SEPARATOR)) {
        path = path.slice(0, path.length - 1);
    }
    var items = path.split(SEPARATOR);
    return items[items.length - 1];
}
exports.basename = basename;
function getModelArtifactsInfoForJSON(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error('Expected JSON model topology, received ArrayBuffer.');
    }
    return {
        dateSaved: new Date(),
        modelTopologyType: 'JSON',
        modelTopologyBytes: modelArtifacts.modelTopology == null ?
            0 :
            stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
        weightSpecsBytes: modelArtifacts.weightSpecs == null ?
            0 :
            stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
        weightDataBytes: modelArtifacts.weightData == null ?
            0 :
            modelArtifacts.weightData.byteLength,
    };
}
exports.getModelArtifactsInfoForJSON = getModelArtifactsInfoForJSON;

},{"../ops/array_ops":103,"../util":155,"./types":60}],57:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var util_1 = require("../util");
var io_utils_1 = require("./io_utils");
var model_management_1 = require("./model_management");
var router_registry_1 = require("./router_registry");
var PATH_SEPARATOR = '/';
var PATH_PREFIX = 'tensorflowjs_models';
var INFO_SUFFIX = 'info';
var MODEL_TOPOLOGY_SUFFIX = 'model_topology';
var WEIGHT_SPECS_SUFFIX = 'weight_specs';
var WEIGHT_DATA_SUFFIX = 'weight_data';
function purgeLocalStorageArtifacts() {
    if (!environment_1.ENV.get('IS_BROWSER') || typeof window.localStorage === 'undefined') {
        throw new Error('purgeLocalStorageModels() cannot proceed because local storage is ' +
            'unavailable in the current environment.');
    }
    var LS = window.localStorage;
    var purgedModelPaths = [];
    for (var i = 0; i < LS.length; ++i) {
        var key = LS.key(i);
        var prefix = PATH_PREFIX + PATH_SEPARATOR;
        if (key.startsWith(prefix) && key.length > prefix.length) {
            LS.removeItem(key);
            var modelName = getModelPathFromKey(key);
            if (purgedModelPaths.indexOf(modelName) === -1) {
                purgedModelPaths.push(modelName);
            }
        }
    }
    return purgedModelPaths;
}
exports.purgeLocalStorageArtifacts = purgeLocalStorageArtifacts;
function getModelKeys(path) {
    return {
        info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
        topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
        weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
        weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)
    };
}
function getModelPathFromKey(key) {
    var items = key.split(PATH_SEPARATOR);
    if (items.length < 3) {
        throw new Error("Invalid key format: " + key);
    }
    return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
}
function maybeStripScheme(key) {
    return key.startsWith(BrowserLocalStorage.URL_SCHEME) ?
        key.slice(BrowserLocalStorage.URL_SCHEME.length) :
        key;
}
var BrowserLocalStorage = (function () {
    function BrowserLocalStorage(modelPath) {
        if (!environment_1.ENV.get('IS_BROWSER') || typeof window.localStorage === 'undefined') {
            throw new Error('The current environment does not support local storage.');
        }
        this.LS = window.localStorage;
        if (modelPath == null || !modelPath) {
            throw new Error('For local storage, modelPath must not be null, undefined or empty.');
        }
        this.modelPath = modelPath;
        this.keys = getModelKeys(this.modelPath);
    }
    BrowserLocalStorage.prototype.save = function (modelArtifacts) {
        return __awaiter(this, void 0, void 0, function () {
            var topology, weightSpecs, modelArtifactsInfo, key;
            return __generator(this, function (_a) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error('BrowserLocalStorage.save() does not support saving model topology ' +
                        'in binary formats yet.');
                }
                else {
                    topology = JSON.stringify(modelArtifacts.modelTopology);
                    weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
                    modelArtifactsInfo = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);
                    try {
                        this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
                        this.LS.setItem(this.keys.topology, topology);
                        this.LS.setItem(this.keys.weightSpecs, weightSpecs);
                        this.LS.setItem(this.keys.weightData, io_utils_1.arrayBufferToBase64String(modelArtifacts.weightData));
                        return [2, { modelArtifactsInfo: modelArtifactsInfo }];
                    }
                    catch (err) {
                        for (key in this.keys) {
                            this.LS.removeItem(this.keys[key]);
                        }
                        throw new Error("Failed to save model '" + this.modelPath + "' to local storage: " +
                            "size quota being exceeded is a possible cause of this failure: " +
                            ("modelTopologyBytes=" + modelArtifactsInfo.modelTopologyBytes + ", ") +
                            ("weightSpecsBytes=" + modelArtifactsInfo.weightSpecsBytes + ", ") +
                            ("weightDataBytes=" + modelArtifactsInfo.weightDataBytes + "."));
                    }
                }
                return [2];
            });
        });
    };
    BrowserLocalStorage.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var info, out, topology, weightSpecs, weightDataBase64;
            return __generator(this, function (_a) {
                info = JSON.parse(this.LS.getItem(this.keys.info));
                if (info == null) {
                    throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
                }
                if (info.modelTopologyType !== 'JSON') {
                    throw new Error('BrowserLocalStorage does not support loading non-JSON model ' +
                        'topology yet.');
                }
                out = {};
                topology = JSON.parse(this.LS.getItem(this.keys.topology));
                if (topology == null) {
                    throw new Error("In local storage, the topology of model '" + this.modelPath + "' " +
                        "is missing.");
                }
                out.modelTopology = topology;
                weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
                if (weightSpecs == null) {
                    throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' " +
                        "are missing.");
                }
                out.weightSpecs = weightSpecs;
                weightDataBase64 = this.LS.getItem(this.keys.weightData);
                if (weightDataBase64 == null) {
                    throw new Error("In local storage, the binary weight values of model " +
                        ("'" + this.modelPath + "' are missing."));
                }
                out.weightData = io_utils_1.base64StringToArrayBuffer(weightDataBase64);
                return [2, out];
            });
        });
    };
    BrowserLocalStorage.URL_SCHEME = 'localstorage://';
    return BrowserLocalStorage;
}());
exports.BrowserLocalStorage = BrowserLocalStorage;
exports.localStorageRouter = function (url) {
    if (!environment_1.ENV.get('IS_BROWSER')) {
        return null;
    }
    else {
        if (url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
            return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
        }
        else {
            return null;
        }
    }
};
router_registry_1.IORouterRegistry.registerSaveRouter(exports.localStorageRouter);
router_registry_1.IORouterRegistry.registerLoadRouter(exports.localStorageRouter);
function browserLocalStorage(modelPath) {
    return new BrowserLocalStorage(modelPath);
}
exports.browserLocalStorage = browserLocalStorage;
var BrowserLocalStorageManager = (function () {
    function BrowserLocalStorageManager() {
        util_1.assert(environment_1.ENV.get('IS_BROWSER'), 'Current environment is not a web browser');
        util_1.assert(typeof window.localStorage !== 'undefined', 'Current browser does not appear to support localStorage');
        this.LS = window.localStorage;
    }
    BrowserLocalStorageManager.prototype.listModels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var out, prefix, suffix, i, key, modelPath;
            return __generator(this, function (_a) {
                out = {};
                prefix = PATH_PREFIX + PATH_SEPARATOR;
                suffix = PATH_SEPARATOR + INFO_SUFFIX;
                for (i = 0; i < this.LS.length; ++i) {
                    key = this.LS.key(i);
                    if (key.startsWith(prefix) && key.endsWith(suffix)) {
                        modelPath = getModelPathFromKey(key);
                        out[modelPath] = JSON.parse(this.LS.getItem(key));
                    }
                }
                return [2, out];
            });
        });
    };
    BrowserLocalStorageManager.prototype.removeModel = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var keys, info;
            return __generator(this, function (_a) {
                path = maybeStripScheme(path);
                keys = getModelKeys(path);
                if (this.LS.getItem(keys.info) == null) {
                    throw new Error("Cannot find model at path '" + path + "'");
                }
                info = JSON.parse(this.LS.getItem(keys.info));
                this.LS.removeItem(keys.info);
                this.LS.removeItem(keys.topology);
                this.LS.removeItem(keys.weightSpecs);
                this.LS.removeItem(keys.weightData);
                return [2, info];
            });
        });
    };
    return BrowserLocalStorageManager;
}());
exports.BrowserLocalStorageManager = BrowserLocalStorageManager;
if (environment_1.ENV.get('IS_BROWSER')) {
    try {
        model_management_1.ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
    }
    catch (err) {
    }
}

},{"../environment":48,"../util":155,"./io_utils":56,"./model_management":58,"./router_registry":59}],58:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util_1 = require("../util");
var router_registry_1 = require("./router_registry");
var URL_SCHEME_SUFFIX = '://';
var ModelStoreManagerRegistry = (function () {
    function ModelStoreManagerRegistry() {
        this.managers = {};
    }
    ModelStoreManagerRegistry.getInstance = function () {
        if (ModelStoreManagerRegistry.instance == null) {
            ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
        }
        return ModelStoreManagerRegistry.instance;
    };
    ModelStoreManagerRegistry.registerManager = function (scheme, manager) {
        util_1.assert(scheme != null, 'scheme must not be undefined or null.');
        if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
            scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
        }
        util_1.assert(scheme.length > 0, 'scheme must not be an empty string.');
        var registry = ModelStoreManagerRegistry.getInstance();
        util_1.assert(registry.managers[scheme] == null, "A model store manager is already registered for scheme '" + scheme + "'.");
        registry.managers[scheme] = manager;
    };
    ModelStoreManagerRegistry.getManager = function (scheme) {
        var manager = this.getInstance().managers[scheme];
        if (manager == null) {
            throw new Error("Cannot find model manager for scheme '" + scheme + "'");
        }
        return manager;
    };
    ModelStoreManagerRegistry.getSchemes = function () {
        return Object.keys(this.getInstance().managers);
    };
    return ModelStoreManagerRegistry;
}());
exports.ModelStoreManagerRegistry = ModelStoreManagerRegistry;
function parseURL(url) {
    if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
        throw new Error("The url string provided does not contain a scheme. " +
            "Supported schemes are: " +
            ("" + ModelStoreManagerRegistry.getSchemes().join(',')));
    }
    return {
        scheme: url.split(URL_SCHEME_SUFFIX)[0],
        path: url.split(URL_SCHEME_SUFFIX)[1],
    };
}
function cloneModelInternal(sourceURL, destURL, deleteSource) {
    if (deleteSource === void 0) { deleteSource = false; }
    return __awaiter(this, void 0, void 0, function () {
        var loadHandlers, loadHandler, saveHandlers, saveHandler, sourceScheme, sourcePath, sameMedium, modelArtifacts, saveResult;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    util_1.assert(sourceURL !== destURL, "Old path and new path are the same: '" + sourceURL + "'");
                    loadHandlers = router_registry_1.IORouterRegistry.getLoadHandlers(sourceURL);
                    util_1.assert(loadHandlers.length > 0, "Copying failed because no load handler is found for source URL " + sourceURL + ".");
                    util_1.assert(loadHandlers.length < 2, "Copying failed because more than one (" + loadHandlers.length + ") " +
                        ("load handlers for source URL " + sourceURL + "."));
                    loadHandler = loadHandlers[0];
                    saveHandlers = router_registry_1.IORouterRegistry.getSaveHandlers(destURL);
                    util_1.assert(saveHandlers.length > 0, "Copying failed because no save handler is found for destination URL " +
                        (destURL + "."));
                    util_1.assert(saveHandlers.length < 2, "Copying failed because more than one (" + loadHandlers.length + ") " +
                        ("save handlers for destination URL " + destURL + "."));
                    saveHandler = saveHandlers[0];
                    sourceScheme = parseURL(sourceURL).scheme;
                    sourcePath = parseURL(sourceURL).path;
                    sameMedium = sourceScheme === parseURL(sourceURL).scheme;
                    return [4, loadHandler.load()];
                case 1:
                    modelArtifacts = _a.sent();
                    if (!(deleteSource && sameMedium)) return [3, 3];
                    return [4, ModelStoreManagerRegistry.getManager(sourceScheme)
                            .removeModel(sourcePath)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [4, saveHandler.save(modelArtifacts)];
                case 4:
                    saveResult = _a.sent();
                    if (!(deleteSource && !sameMedium)) return [3, 6];
                    return [4, ModelStoreManagerRegistry.getManager(sourceScheme)
                            .removeModel(sourcePath)];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6: return [2, saveResult.modelArtifactsInfo];
            }
        });
    });
}
var ModelManagement = (function () {
    function ModelManagement() {
    }
    ModelManagement.listModels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var schemes, out, _i, schemes_1, scheme, schemeOut, path, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        schemes = ModelStoreManagerRegistry.getSchemes();
                        out = {};
                        _i = 0, schemes_1 = schemes;
                        _a.label = 1;
                    case 1:
                        if (!(_i < schemes_1.length)) return [3, 4];
                        scheme = schemes_1[_i];
                        return [4, ModelStoreManagerRegistry.getManager(scheme).listModels()];
                    case 2:
                        schemeOut = _a.sent();
                        for (path in schemeOut) {
                            url = scheme + URL_SCHEME_SUFFIX + path;
                            out[url] = schemeOut[path];
                        }
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2, out];
                }
            });
        });
    };
    ModelManagement.removeModel = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var schemeAndPath, manager;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        schemeAndPath = parseURL(url);
                        manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
                        return [4, manager.removeModel(schemeAndPath.path)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    ModelManagement.copyModel = function (sourceURL, destURL) {
        return __awaiter(this, void 0, void 0, function () {
            var deleteSource;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deleteSource = false;
                        return [4, cloneModelInternal(sourceURL, destURL, deleteSource)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    ModelManagement.moveModel = function (sourceURL, destURL) {
        return __awaiter(this, void 0, void 0, function () {
            var deleteSource;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deleteSource = true;
                        return [4, cloneModelInternal(sourceURL, destURL, deleteSource)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    __decorate([
        doc_1.doc({ heading: 'Models', subheading: 'Management', namespace: 'io' })
    ], ModelManagement, "listModels", null);
    __decorate([
        doc_1.doc({ heading: 'Models', subheading: 'Management', namespace: 'io' })
    ], ModelManagement, "removeModel", null);
    __decorate([
        doc_1.doc({ heading: 'Models', subheading: 'Management', namespace: 'io' })
    ], ModelManagement, "copyModel", null);
    __decorate([
        doc_1.doc({ heading: 'Models', subheading: 'Management', namespace: 'io' })
    ], ModelManagement, "moveModel", null);
    return ModelManagement;
}());
exports.ModelManagement = ModelManagement;

},{"../doc":46,"../util":155,"./router_registry":59}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var IORouterRegistry = (function () {
    function IORouterRegistry() {
        this.saveRouters = [];
        this.loadRouters = [];
    }
    IORouterRegistry.getInstance = function () {
        if (IORouterRegistry.instance == null) {
            IORouterRegistry.instance = new IORouterRegistry();
        }
        return IORouterRegistry.instance;
    };
    IORouterRegistry.registerSaveRouter = function (saveRouter) {
        IORouterRegistry.getInstance().saveRouters.push(saveRouter);
    };
    IORouterRegistry.registerLoadRouter = function (loadRouter) {
        IORouterRegistry.getInstance().loadRouters.push(loadRouter);
    };
    IORouterRegistry.getSaveHandlers = function (url) {
        return IORouterRegistry.getHandlers(url, 'save');
    };
    IORouterRegistry.getLoadHandlers = function (url) {
        return IORouterRegistry.getHandlers(url, 'load');
    };
    IORouterRegistry.getHandlers = function (url, handlerType) {
        var validHandlers = [];
        var routers = handlerType === 'load' ? this.getInstance().loadRouters :
            this.getInstance().saveRouters;
        routers.forEach(function (router) {
            var handler = router(url);
            if (handler !== null) {
                validHandlers.push(handler);
            }
        });
        return validHandlers;
    };
    return IORouterRegistry;
}());
exports.IORouterRegistry = IORouterRegistry;

},{}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DTYPE_VALUE_SIZE_MAP = {
    'float32': 4,
    'int32': 4,
    'uint16': 2,
    'uint8': 1,
    'bool': 1,
};

},{}],61:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ops_1 = require("../ops/ops");
var util = require("../util");
var types_1 = require("./types");
function loadWeightsAsArrayBuffer(fetchURLs, requestOptions) {
    return __awaiter(this, void 0, void 0, function () {
        var requests, responses, buffers;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    requests = fetchURLs.map(function (fetchURL) { return fetch(fetchURL, requestOptions); });
                    return [4, Promise.all(requests)];
                case 1:
                    responses = _a.sent();
                    return [4, Promise.all(responses.map(function (response) { return response.arrayBuffer(); }))];
                case 2:
                    buffers = _a.sent();
                    return [2, buffers];
            }
        });
    });
}
exports.loadWeightsAsArrayBuffer = loadWeightsAsArrayBuffer;
function loadWeights(manifest, filePathPrefix, weightNames, requestOptions) {
    if (filePathPrefix === void 0) { filePathPrefix = ''; }
    return __awaiter(this, void 0, void 0, function () {
        var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames, weightsNotFound, groupIndicesToFetch, fetchUrls, buffers, weightsTensorMap, bufferIndexOffset;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    groupIndicesToFetchMap = manifest.map(function () { return false; });
                    groupWeightsToFetch = {};
                    weightsFound = weightNames != null ? weightNames.map(function () { return false; }) : [];
                    allManifestWeightNames = [];
                    manifest.forEach(function (manifestGroupConfig, groupIndex) {
                        var groupOffset = 0;
                        manifestGroupConfig.weights.forEach(function (weightsEntry) {
                            var rawDtype = ('quantization' in weightsEntry) ?
                                weightsEntry.quantization.dtype :
                                weightsEntry.dtype;
                            var weightsBytes = types_1.DTYPE_VALUE_SIZE_MAP[rawDtype] *
                                util.sizeFromShape(weightsEntry.shape);
                            var enqueueWeightsForFetchingFn = function () {
                                groupIndicesToFetchMap[groupIndex] = true;
                                if (groupWeightsToFetch[groupIndex] == null) {
                                    groupWeightsToFetch[groupIndex] = [];
                                }
                                groupWeightsToFetch[groupIndex].push({
                                    manifestEntry: weightsEntry,
                                    groupOffset: groupOffset,
                                    sizeBytes: weightsBytes
                                });
                            };
                            if (weightNames != null) {
                                weightNames.forEach(function (weightName, weightIndex) {
                                    if (weightName === weightsEntry.name) {
                                        enqueueWeightsForFetchingFn();
                                        weightsFound[weightIndex] = true;
                                    }
                                });
                            }
                            else {
                                enqueueWeightsForFetchingFn();
                            }
                            allManifestWeightNames.push(weightsEntry.name);
                            groupOffset += weightsBytes;
                        });
                    });
                    if (!weightsFound.every(function (found) { return found; })) {
                        weightsNotFound = weightNames.filter(function (weight, i) { return !weightsFound[i]; });
                        throw new Error("Could not find weights in manifest with names: " +
                            (weightsNotFound.join(', ') + ". \n") +
                            "Manifest JSON has weights with names: " +
                            (allManifestWeightNames.join(', ') + "."));
                    }
                    groupIndicesToFetch = groupIndicesToFetchMap.reduce(function (accumulator, shouldFetch, i) {
                        if (shouldFetch) {
                            accumulator.push(i);
                        }
                        return accumulator;
                    }, []);
                    fetchUrls = [];
                    groupIndicesToFetch.forEach(function (i) {
                        manifest[i].paths.forEach(function (filepath) {
                            var fetchUrl = filePathPrefix +
                                (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;
                            fetchUrls.push(fetchUrl);
                        });
                    });
                    return [4, loadWeightsAsArrayBuffer(fetchUrls, requestOptions)];
                case 1:
                    buffers = _a.sent();
                    weightsTensorMap = {};
                    bufferIndexOffset = 0;
                    groupIndicesToFetch.forEach(function (i) {
                        var numBuffers = manifest[i].paths.length;
                        var groupBytes = 0;
                        for (var i_1 = 0; i_1 < numBuffers; i_1++) {
                            groupBytes += buffers[bufferIndexOffset + i_1].byteLength;
                        }
                        var groupBuffer = new ArrayBuffer(groupBytes);
                        var groupByteBuffer = new Uint8Array(groupBuffer);
                        var groupBufferOffset = 0;
                        for (var i_2 = 0; i_2 < numBuffers; i_2++) {
                            var buffer = new Uint8Array(buffers[bufferIndexOffset + i_2]);
                            groupByteBuffer.set(buffer, groupBufferOffset);
                            groupBufferOffset += buffer.byteLength;
                        }
                        var weightsEntries = groupWeightsToFetch[i];
                        weightsEntries.forEach(function (weightsEntry) {
                            var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
                            var typedArray;
                            var dtype = weightsEntry.manifestEntry.dtype;
                            if ('quantization' in weightsEntry.manifestEntry) {
                                var quantization_1 = weightsEntry.manifestEntry.quantization;
                                if (quantization_1.dtype !== 'uint8' && quantization_1.dtype !== 'uint16') {
                                    throw new Error("Weight " + weightsEntry.manifestEntry.name + " has unknown " +
                                        ("quantization dtype " + quantization_1.dtype + "."));
                                }
                                var quantizedArray = (quantization_1.dtype === 'uint8') ?
                                    new Uint8Array(byteBuffer) :
                                    new Uint16Array(byteBuffer);
                                if (dtype === 'float32') {
                                    typedArray = Float32Array.from(quantizedArray, function (v) { return v * quantization_1.scale + quantization_1.min; });
                                }
                                else if (dtype === 'int32') {
                                    typedArray = Int32Array.from(quantizedArray, function (v) { return Math.round(v * quantization_1.scale + quantization_1.min); });
                                }
                                else {
                                    throw new Error("Weight " + weightsEntry.manifestEntry.name + " has a dtype not " +
                                        ("supported by quantization: " + dtype));
                                }
                            }
                            else {
                                if (dtype === 'float32') {
                                    typedArray = new Float32Array(byteBuffer);
                                }
                                else if (dtype === 'int32') {
                                    typedArray = new Int32Array(byteBuffer);
                                }
                                else {
                                    throw new Error("Weight " + weightsEntry.manifestEntry.name + " has unknown dtype " +
                                        (dtype + "."));
                                }
                            }
                            var weightName = weightsEntry.manifestEntry.name;
                            if (weightsTensorMap[weightName] != null) {
                                throw new Error("Duplicate weight with name " + weightName + ". " +
                                    "Please make sure weights names are unique in the manifest JSON.");
                            }
                            weightsTensorMap[weightName] = ops_1.tensor(typedArray, weightsEntry.manifestEntry.shape, weightsEntry.manifestEntry.dtype);
                        });
                        bufferIndexOffset += numBuffers;
                    });
                    return [2, weightsTensorMap];
            }
        });
    });
}
exports.loadWeights = loadWeights;

},{"../ops/ops":124,"../util":155,"./types":60}],62:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var environment_1 = require("../environment");
var axis_util = require("../ops/axis_util");
var broadcast_util = require("../ops/broadcast_util");
var concat_util = require("../ops/concat_util");
var erf_util = require("../ops/erf_util");
var ops = require("../ops/ops");
var ops_1 = require("../ops/ops");
var selu_util = require("../ops/selu_util");
var slice_util_1 = require("../ops/slice_util");
var tensor_1 = require("../tensor");
var types = require("../types");
var util = require("../util");
var backend_util = require("./backend_util");
var MathBackendCPU = (function () {
    function MathBackendCPU() {
        this.data = new WeakMap();
        this.firstUse = true;
        if (environment_1.ENV.get('IS_BROWSER')) {
            this.canvas = document.createElement('canvas');
        }
    }
    MathBackendCPU.prototype.register = function (dataId, shape, dtype) {
        if (this.firstUse) {
            this.firstUse = false;
            if (environment_1.ENV.get('IS_NODE')) {
                console.warn('\n============================\n' +
                    'Hi there ð. Looks like you are running TensorFlow.js in ' +
                    'Node.js. To speed things up dramatically, install our node ' +
                    'backend, which binds to TensorFlow C++, by running ' +
                    'npm i @tensorflow/tfjs-node, ' +
                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +
                    'Then call require(\'tensorflow/tfjs-node\'); (-gpu ' +
                    'suffix for CUDA) at the start of your program. ' +
                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +
                    '\n============================\n');
            }
        }
        if (this.data.has(dataId)) {
            throw new Error("Data buffer is already registered");
        }
        this.data.set(dataId, null);
    };
    MathBackendCPU.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendCPU.write(): values can not be null');
        }
        this.throwIfNoData(dataId);
        this.data.set(dataId, values);
    };
    MathBackendCPU.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('MathBackendCPU.writePixels(): pixels can not be null');
        }
        var vals;
        if (pixels instanceof ImageData) {
            vals = pixels.data;
        }
        else if (pixels instanceof HTMLCanvasElement) {
            vals = pixels.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else if (pixels instanceof HTMLImageElement ||
            pixels instanceof HTMLVideoElement) {
            if (this.canvas == null) {
                throw new Error('Can\'t read pixels from HTMLImageElement outside ' +
                    'the browser.');
            }
            this.canvas.width = pixels.width;
            this.canvas.height = pixels.height;
            this.canvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            vals = this.canvas.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else {
            throw new Error("pixels is of unknown type: " + pixels.constructor.name);
        }
        var values;
        if (numChannels === 4) {
            values = new Int32Array(vals);
        }
        else {
            var numPixels = pixels.width * pixels.height;
            values = new Int32Array(numPixels * numChannels);
            for (var i = 0; i < numPixels; i++) {
                for (var channel = 0; channel < numChannels; ++channel) {
                    values[i * numChannels + channel] = vals[i * 4 + channel];
                }
            }
        }
        var outShape = [pixels.height, pixels.width, numChannels];
        return ops_1.tensor3d(values, outShape, 'int32');
    };
    MathBackendCPU.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.readSync(dataId)];
            });
        });
    };
    MathBackendCPU.prototype.readSync = function (dataId) {
        this.throwIfNoData(dataId);
        return this.data.get(dataId);
    };
    MathBackendCPU.prototype.disposeData = function (dataId) {
        if (this.data.has(dataId)) {
            this.data.delete(dataId);
        }
    };
    MathBackendCPU.prototype.time = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var start, kernelMs;
            return __generator(this, function (_a) {
                start = performance.now();
                f();
                kernelMs = performance.now() - start;
                return [2, { kernelMs: kernelMs }];
            });
        });
    };
    MathBackendCPU.prototype.memory = function () {
        return {
            unreliable: true
        };
    };
    MathBackendCPU.prototype.throwIfNoData = function (dataId) {
        if (!this.data.has(dataId)) {
            throw new Error("CPU backend: No data found for this tensor. " +
                "Did you change your backend in the middle of the program? " +
                "New backends can't use Tensors created with previous backends");
        }
    };
    MathBackendCPU.prototype.slice = function (x, begin, size) {
        var buffer = ops.buffer(size, x.dtype);
        for (var i = 0; i < buffer.size; ++i) {
            var loc = buffer.indexToLoc(i);
            var xLoc = loc.map(function (idx, j) { return idx + begin[j]; });
            buffer.set.apply(buffer, [x.get.apply(x, xLoc)].concat(loc));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
        var _a = slice_util_1.getStridedSlicedInfo(x.shape, begin, end, strides, beginMask, endMask), beginIndex = _a[0], size = _a[1];
        if (size.some(function (axis) { return axis === 0; })) {
            return ops.tensor([], size);
        }
        var buffer = ops.buffer(size, x.dtype);
        for (var i = 0; i < buffer.size; i++) {
            var loc = buffer.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var j = 0; j < newLoc.length; j++) {
                newLoc[j] = loc[j] * strides[j] + beginIndex[j];
            }
            buffer.set.apply(buffer, [x.get.apply(x, newLoc)].concat(loc));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.reverse = function (x, axis) {
        var buffer = ops.buffer(x.shape, x.dtype);
        var xBuffer = x.buffer();
        var _loop_1 = function (i) {
            var outLoc = buffer.indexToLoc(i);
            var inLoc = outLoc.slice();
            axis.forEach(function (ax) { return inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]; });
            buffer.set.apply(buffer, [xBuffer.get.apply(xBuffer, inLoc)].concat(outLoc));
        };
        for (var i = 0; i < buffer.size; i++) {
            _loop_1(i);
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.concat = function (a, b) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, 1);
        var buffer = ops.buffer(outShape, a.dtype);
        if (a.shape[0] === 1 && b.shape[0] === 1) {
            var aVals = a.dataSync();
            var bVals = b.dataSync();
            var vals = buffer.values;
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return buffer.toTensor();
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < a.shape[1]; ++j) {
                buffer.set(a.get(i, j), i, j);
            }
            for (var j = 0; j < b.shape[1]; ++j) {
                buffer.set(b.get(i, j), i, j + a.shape[1]);
            }
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.neg = function (x) {
        return this.multiply(ops.scalar(-1), x);
    };
    MathBackendCPU.prototype.add = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue + bValue; });
    };
    MathBackendCPU.prototype.subtract = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue - bValue; });
    };
    MathBackendCPU.prototype.pow = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) { return Math.pow(aValue, bValue); });
    };
    MathBackendCPU.prototype.matMul = function (a, b, transposeA, transposeB) {
        var sharedDim = transposeA ? a.shape[0] : a.shape[1];
        var leftDim = transposeA ? a.shape[1] : a.shape[0];
        var rightDim = transposeB ? b.shape[0] : b.shape[1];
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var _a = transposeA ? [1, a.strides[0]] : [a.strides[0], 1], aOuterStep = _a[0], aInnerStep = _a[1];
        var _b = transposeB ? [b.strides[0], 1] : [1, b.strides[0]], bOuterStep = _b[0], bInnerStep = _b[1];
        var aOuterEnd = leftDim * aOuterStep;
        var bOuterEnd = rightDim * bOuterStep;
        var result = new Float32Array(leftDim * rightDim);
        var resultIndex = 0;
        for (var aOuter = 0; aOuter < aOuterEnd; aOuter += aOuterStep) {
            for (var bOuter = 0; bOuter < bOuterEnd; bOuter += bOuterStep) {
                var aInner = aOuter;
                var bInner = bOuter;
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aValues[aInner] * bValues[bInner];
                    aInner += aInnerStep;
                    bInner += bInnerStep;
                }
                result[resultIndex++] = sum;
            }
        }
        return ops.tensor2d(result, [leftDim, rightDim]);
    };
    MathBackendCPU.prototype.multiply = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue * bValue; });
    };
    MathBackendCPU.prototype.realDivide = function (a, b) {
        var op = function (a, b) { return a / b; };
        var outputDtype = 'float32';
        return this.broadcastedBinaryOp(a, b, outputDtype, op);
    };
    MathBackendCPU.prototype.floorDiv = function (a, b) {
        var op = function (a, b) { return Math.floor(a / b); };
        var outputDtype = 'int32';
        return this.broadcastedBinaryOp(a, b, outputDtype, op);
    };
    MathBackendCPU.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = types.upcastType(x.dtype, 'int32');
        var result = ops.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var sum = 0;
            for (var j = 0; j < reduceSize; ++j) {
                sum += aVals[offset + j];
            }
            vals[i] = sum;
        }
        return result;
    };
    MathBackendCPU.prototype.argMin = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            var minIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value < min) {
                    min = value;
                    minIndex = j;
                }
            }
            vals[i] = minIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.argMax = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            var maxIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value > max) {
                    max = value;
                    maxIndex = j;
                }
            }
            vals[i] = maxIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.cumsum = function (x, axis, exclusive, reverse) {
        if (axis !== x.rank - 1) {
            throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (x.rank - 1) + " " +
                ("but got axis=" + axis));
        }
        var resultDtype = types.upcastType(x.dtype, 'int32');
        var result = ops.zeros(x.shape, resultDtype);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        var finalDim = x.shape[x.rank - 1];
        var indexAdjuster = reverse ?
            function (i, j) { return i + finalDim - j - 1; } :
            function (i, j) { return i + j; };
        for (var i = 0; i < aVals.length; i += finalDim) {
            for (var j = 0; j < finalDim; j++) {
                var idx = indexAdjuster(i, j);
                if (j === 0) {
                    vals[idx] = exclusive ? 0 : aVals[idx];
                }
                else {
                    var prevIdx = indexAdjuster(i, j - 1);
                    vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] :
                        aVals[idx] + vals[prevIdx];
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.equal = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal === bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.notEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal !== bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.less = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal < bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.lessEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal <= bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.greater = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal > bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.greaterEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return (aVal >= bVal) ? 1 : 0;
        });
    };
    MathBackendCPU.prototype.logicalNot = function (x) {
        var values = x.dataSync();
        var newValues = new Int32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = values[i] ? 0 : 1;
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues }, 'bool');
    };
    MathBackendCPU.prototype.logicalAnd = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return aVal && bVal;
        });
    };
    MathBackendCPU.prototype.logicalOr = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            return aVal || bVal;
        });
    };
    MathBackendCPU.prototype.where = function (condition, a, b, dtype) {
        var values = condition.dataSync();
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var result = ops.zeros(a.shape, dtype);
        var newValues = result.dataSync();
        var index = 0;
        var offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ?
            1 :
            a.shape[1];
        for (var i = 0; i < values.length; i++) {
            for (var j = 0; j < offset; j++) {
                if (values[i] === 1) {
                    newValues[index++] = aValues[i];
                }
                else {
                    newValues[index++] = bValues[i];
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.topKValues = function (x, k) {
        return this.topK(x, k).values;
    };
    MathBackendCPU.prototype.topKIndices = function (x, k) {
        return this.topK(x, k).indices;
    };
    MathBackendCPU.prototype.topK = function (x, k) {
        var values = x.dataSync();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = util.getTypedArrayFromDType(x.dtype, k);
        var topkIndices = new Int32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return {
            values: ops.tensor1d(topkValues, x.dtype),
            indices: ops.tensor1d(topkIndices, 'int32')
        };
    };
    MathBackendCPU.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[0];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value < min) {
                    min = value;
                }
            }
            vals[i] = min;
        }
        return result;
    };
    MathBackendCPU.prototype.minimum = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.min(aVal, bVal); });
    };
    MathBackendCPU.prototype.mod = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
            var rem = aVal % bVal;
            if ((aVal < 0 && bVal < 0) || (aVal >= 0 && bVal >= 0)) {
                return rem;
            }
            else {
                return (rem + bVal) % bVal;
            }
        });
    };
    MathBackendCPU.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (value > max) {
                    max = value;
                }
            }
            vals[i] = max;
        }
        return result;
    };
    MathBackendCPU.prototype.maximum = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.max(aVal, bVal); });
    };
    MathBackendCPU.prototype.squaredDifference = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
            var diff = aVal - bVal;
            return diff * diff;
        });
    };
    MathBackendCPU.prototype.ceil = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.ceil(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.floor = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.floor(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.sign = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            if (values[i] < 0) {
                newValues[i] = -1;
            }
            else if (values[i] > 0) {
                newValues[i] = 1;
            }
            else {
                newValues[i] = 0;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.round = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var base = Math.floor(values[i]);
            if (values[i] - base < 0.5) {
                newValues[i] = Math.floor(values[i]);
            }
            else if (values[i] - base > 0.5) {
                newValues[i] = Math.ceil(values[i]);
            }
            else {
                if (base % 2.0 === 0.0) {
                    newValues[i] = base;
                }
                else {
                    newValues[i] = base + 1.0;
                }
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.exp = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.expm1 = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.expm1(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.log = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.log1p = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log1p(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.sqrt = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.sqrt(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.rsqrt = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = 1 / Math.sqrt(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.square = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = value * value;
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.reciprocal = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = 1 / values[i];
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.relu = function (x) {
        var res = ops.zeros(x.shape, x.dtype);
        var resVals = res.dataSync();
        var inVals = x.dataSync();
        for (var i = 0; i < inVals.length; ++i) {
            resVals[i] = Math.max(0, inVals[i]);
        }
        return res;
    };
    MathBackendCPU.prototype.elu = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = (Math.exp(v) - 1);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.eluDer = function (dy, y) {
        var resultValues = new Float32Array(y.size);
        var values = y.dataSync();
        var dyValues = dy.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 1) {
                resultValues[i] = dyValues[i];
            }
            else {
                resultValues[i] = dyValues[i] * (v + 1);
            }
        }
        return tensor_1.Tensor.make(y.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.selu = function (x) {
        var scaleAlpha = selu_util.SELU_SCALEALPHA;
        var scale = selu_util.SELU_SCALE;
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = scale * v;
            }
            else {
                resultValues[i] = scaleAlpha * (Math.exp(v) - 1);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.clip = function (x, min, max) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.min(max, Math.max(min, values[i]));
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.abs = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.abs(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.int = function (x) {
        var resultValues = new Int32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = values[i];
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues }, 'int32');
    };
    MathBackendCPU.prototype.sigmoid = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.softplus = function (x) {
        var epsilon = 1.1920928955078125e-7;
        var threshold = Math.log(epsilon) + 2.0;
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var tooLarge = values[i] > -threshold;
            var tooSmall = values[i] < threshold;
            var expX = Math.exp(values[i]);
            var result = void 0;
            if (tooSmall) {
                result = expX;
            }
            else if (tooLarge) {
                result = values[i];
            }
            else {
                result = Math.log(1.0 + expX);
            }
            resultValues[i] = result;
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.sin = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cos = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cos(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tan = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.tan(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.asin = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asin(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.acos = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acos(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atan = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atan(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atan2 = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) { return Math.atan2(aValue, bValue); });
    };
    MathBackendCPU.prototype.sinh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sinh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cosh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cosh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tanh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.asinh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asinh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.acosh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acosh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atanh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atanh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.erf = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var p = erf_util.ERF_P;
        var a1 = erf_util.ERF_A1;
        var a2 = erf_util.ERF_A2;
        var a3 = erf_util.ERF_A3;
        var a4 = erf_util.ERF_A4;
        var a5 = erf_util.ERF_A5;
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            var t = 1.0 / (1.0 + p * v);
            resultValues[i] = 1.0 -
                (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t *
                    Math.exp(-v * v);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0; }
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                resultValues[i] = NaN;
            }
            else {
                resultValues[i] = value > 0 ? 1 : alpha;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.conv2d = function (x, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var y = ops.buffer(convInfo.outShape, x.dtype);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; wR++) {
                            var xR = xRCorner + wR * dilationHeight;
                            if (xR < 0 || xR >= convInfo.inHeight) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; wC++) {
                                var xC = xCCorner + wC * dilationWidth;
                                if (xC < 0 || xC >= convInfo.inWidth) {
                                    continue;
                                }
                                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                    var pixel = x.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, d2);
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        y.set(dotProd, b, yR, yC, d2);
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var dx = ops.buffer(convInfo.inShape, 'float32');
        var dxValues = dx.values;
        var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2];
        var dyValues = dy.dataSync();
        var _b = dy.strides, dyS0 = _b[0], dyS1 = _b[1], dyS2 = _b[2];
        var fltValues = filter.dataSync();
        var _c = filter.strides, fltS0 = _c[0], fltS1 = _c[1], fltS2 = _c[2];
        var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        for (var b = 0; b < batchSize; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var xR = 0; xR < inHeight; ++xR) {
                    var xRCorner = xR - topPad;
                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                    var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
                    for (var xC = 0; xC < inWidth; ++xC) {
                        var xCCorner = xC - leftPad;
                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                        var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                        var dotProd = 0;
                        for (var yR = xRMin; yR < yRMax; ++yR) {
                            var wR = yR * strideHeight - xRCorner;
                            for (var yC = xCMin; yC < yCMax; ++yC) {
                                var wC = yC * strideWidth - xCCorner;
                                var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                                var fltOffset = fltS0 * (filterHeight - 1 - wR) +
                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                                for (var d2 = 0; d2 < outChannels; ++d2) {
                                    var pixel = dyValues[dyOffset + d2];
                                    var weight = fltValues[fltOffset + d2];
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dW = ops.buffer(convInfo.filterShape, 'float32');
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                    for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                        var dotProd = 0;
                        for (var b = 0; b < convInfo.batchSize; ++b) {
                            for (var yR = yRMin; yR < yRMax; ++yR) {
                                var xR = wR + yR * strideHeight - topPad;
                                for (var yC = yCMin; yC < yCMax; ++yC) {
                                    var xC = wC + yC * strideWidth - leftPad;
                                    dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                                }
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var chMul = convInfo.outChannels / convInfo.inChannels;
        var y = ops.buffer(convInfo.outShape, x.dtype);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        for (var q = 0; q < chMul; ++q) {
                            var dotProd = 0;
                            for (var wR = 0; wR < filterHeight; ++wR) {
                                var xR = xRCorner + wR * dilationHeight;
                                if (xR < 0 || xR >= convInfo.inHeight) {
                                    continue;
                                }
                                for (var wC = 0; wC < filterWidth; ++wC) {
                                    var xC = xCCorner + wC * dilationWidth;
                                    if (xC < 0 || xC >= convInfo.inWidth) {
                                        continue;
                                    }
                                    var pixel = x.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, q);
                                    dotProd += pixel * weight;
                                }
                            }
                            y.set(dotProd, b, yR, yC, d1 * chMul + q);
                        }
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
        var dx = ops.buffer(convInfo.inShape, 'float32');
        var dxValues = dx.values;
        var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2];
        var dyValues = dy.dataSync();
        var _b = dy.strides, dyS0 = _b[0], dyS1 = _b[1], dyS2 = _b[2];
        var fltValues = filter.dataSync();
        var _c = filter.strides, fltS0 = _c[0], fltS1 = _c[1], fltS2 = _c[2];
        var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight, filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels, inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels, outHeight = convInfo.outHeight, outWidth = convInfo.outWidth, strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        var chMul = outChannels / inChannels;
        for (var b = 0; b < batchSize; ++b) {
            for (var d1 = 0; d1 < inChannels; ++d1) {
                for (var xR = 0; xR < inHeight; ++xR) {
                    var xRCorner = xR - topPad;
                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                    var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
                    for (var xC = 0; xC < inWidth; ++xC) {
                        var xCCorner = xC - leftPad;
                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                        var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                        var dotProd = 0;
                        for (var yR = xRMin; yR < yRMax; ++yR) {
                            var wR = yR * strideHeight - xRCorner;
                            for (var yC = xCMin; yC < yCMax; ++yC) {
                                var wC = yC * strideWidth - xCCorner;
                                var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                                var fltOffset = fltS0 * (filterHeight - 1 - wR) +
                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                                for (var dm = 0; dm < chMul; ++dm) {
                                    var d2 = d1 * chMul + dm;
                                    var pixel = dyValues[dyOffset + d2];
                                    var weight = fltValues[fltOffset + dm];
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2DDerFilter = function (x, dy, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dW = ops.buffer(convInfo.filterShape, 'float32');
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        var chMul = convInfo.outChannels / convInfo.inChannels;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                    var d1 = Math.trunc(d2 / chMul);
                    var dm = d2 % chMul;
                    var dotProd = 0;
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var yR = yRMin; yR < yRMax; ++yR) {
                            var xR = wR + yR * strideHeight - topPad;
                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                var xC = wC + yC * strideWidth - leftPad;
                                dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                            }
                        }
                    }
                    dW.set(dotProd, wR, wC, d1, dm);
                }
            }
        }
        return dW.toTensor();
    };
    MathBackendCPU.prototype.tile = function (x, reps) {
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[i] * reps[i];
        }
        var result = ops.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < result.values.length; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = new Array(x.rank);
            for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                originalLoc[i_1] = newLoc[i_1] % x.shape[i_1];
            }
            var originalIndex = xBuf.locToIndex(originalLoc);
            result.values[i] = xBuf.values[originalIndex];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.pad = function (x, paddings, constantValue) {
        var outShape = paddings.map(function (p, i) { return p[0] + x.shape[i] + p[1]; });
        var start = paddings.map(function (p) { return p[0]; });
        var xBuffer = x.buffer();
        var buffer = ops.buffer(outShape, x.dtype);
        if (constantValue !== 0) {
            buffer.values.fill(constantValue);
        }
        for (var i = 0; i < x.size; i++) {
            var coords = xBuffer.indexToLoc(i);
            var outCoords = coords.map(function (c, i) { return c + start[i]; });
            buffer.set.apply(buffer, [x.get.apply(x, coords)].concat(outCoords));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.transpose = function (x, perm) {
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[perm[i]];
        }
        var values = x.dataSync();
        var result = ops_1.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < x.size; ++i) {
            var loc = xBuf.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                newLoc[i_2] = loc[perm[i_2]];
            }
            var newIndex = result.locToIndex(newLoc);
            result.values[newIndex] = values[i];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.gather = function (x, indices, axis) {
        var newShape = x.shape.slice();
        var indicesValues = indices.dataSync();
        newShape[axis] = indicesValues.length;
        var result = ops_1.buffer(newShape, x.dtype);
        var xBuf = x.buffer();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = newLoc.slice();
            originalLoc[axis] = indicesValues[newLoc[axis]];
            var originalIndex = xBuf.locToIndex(originalLoc);
            result.values[i] = xBuf.values[originalIndex];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.pool = function (x, convInfo, poolType) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var y = ops.buffer(convInfo.outShape, 'float32');
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                            Number.POSITIVE_INFINITY);
                        var avgValue = 0;
                        var count = 0;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var pixel = x.get(b, xR, xC, d);
                                if ((poolType === 'max' && pixel > minMaxValue)) {
                                    minMaxValue = pixel;
                                }
                                else if (poolType === 'avg') {
                                    avgValue += pixel;
                                    count++;
                                }
                            }
                            if (isNaN(minMaxValue)) {
                                break;
                            }
                        }
                        y.set(poolType === 'avg' ? avgValue / count : minMaxValue, b, yR, yC, d);
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.maxPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'max');
    };
    MathBackendCPU.prototype.maxPoolPositions = function (x, convInfo) {
        var maxPositions = ops.buffer(convInfo.outShape, 'int32');
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var maxValue = Number.NEGATIVE_INFINITY;
                        var maxPosition = -1;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            var wR = xR - xRCorner;
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var wC = xC - xCCorner;
                                var pixel = x.get(b, xR, xC, d);
                                if (pixel > maxValue) {
                                    maxValue = pixel;
                                    maxPosition = wR * filterWidth + wC;
                                }
                            }
                        }
                        maxPositions.set(maxPosition, b, yR, yC, d);
                    }
                }
            }
        }
        return maxPositions.toTensor();
    };
    MathBackendCPU.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
        var maxPositions = this.maxPoolPositions(x, convInfo);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.buffer(x.shape, 'float32');
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var maxPos = filterHeight * filterWidth - 1 -
                                    maxPositions.get(b, dyR, dyC, d);
                                var curPos = wR * filterWidth + wC;
                                var mask = maxPos === curPos ? 1 : 0;
                                if (mask === 0) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel * mask;
                            }
                        }
                        dx.set(dotProd, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.buffer(x.shape, 'float32');
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel;
                            }
                        }
                        dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.cast = function (x, dtype) {
        return backend_util.castTensor(x, dtype, this);
    };
    MathBackendCPU.prototype.reshape = function (x, shape) {
        return backend_util.reshapeTensor(x, shape);
    };
    MathBackendCPU.prototype.avgPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'avg').toFloat();
    };
    MathBackendCPU.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
        var output = ops.buffer([batch, newHeight, newWidth, numChannels], x.dtype);
        var effectiveInputSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        var effectiveOutputSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < newHeight; r++) {
                for (var c = 0; c < newWidth; c++) {
                    for (var d = 0; d < numChannels; d++) {
                        var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                        var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                        var sourceRowFloor = Math.floor(sourceFracRow);
                        var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
                        var sourceColFloor = Math.floor(sourceFracCol);
                        var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
                        var topLeft = x.get(b, sourceRowFloor, sourceColFloor, d);
                        var bottomLeft = x.get(b, sourceRowCeil, sourceColFloor, d);
                        var topRight = x.get(b, sourceRowFloor, sourceColCeil, d);
                        var bottomRight = x.get(b, sourceRowCeil, sourceColCeil, d);
                        var rowFrac = sourceFracRow - sourceRowFloor;
                        var colFrac = sourceFracCol - sourceColFloor;
                        var top_1 = topLeft + (topRight - topLeft) * colFrac;
                        var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                        var newValue = top_1 + (bottom - top_1) * rowFrac;
                        output.set(newValue, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
        var _a = x.shape, batch = _a[0], xHeight = _a[1], xWidth = _a[2], depth = _a[3];
        var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
        var output = ops.buffer([batch, xHeight, xWidth, depth], x.dtype);
        var effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        var effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        var heightScale = effectiveXSize[0] / effectiveYSize[0];
        var widthScale = effectiveXSize[1] / effectiveYSize[1];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < yHeight; r++) {
                var dxR = r * heightScale;
                var topDxRIndex = Math.floor(dxR);
                var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
                var dxRLerp = dxR - topDxRIndex;
                var inverseDxRLerp = 1.0 - dxRLerp;
                for (var c = 0; c < yWidth; c++) {
                    var dxC = c * widthScale;
                    var leftDxCIndex = Math.floor(dxC);
                    var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
                    var dxCLerp = dxC - leftDxCIndex;
                    var inverseDxCLerp = 1.0 - dxCLerp;
                    for (var d = 0; d < depth; d++) {
                        var dyVal = dy.get(b, r, c, d);
                        var topLeft = output.get(b, topDxRIndex, leftDxCIndex, d);
                        topLeft += dyVal * inverseDxRLerp * inverseDxCLerp;
                        output.set(topLeft, b, topDxRIndex, leftDxCIndex, d);
                        var topRight = output.get(b, topDxRIndex, rightDxCIndex, d);
                        topRight += dyVal * inverseDxRLerp * dxCLerp;
                        output.set(topRight, b, topDxRIndex, rightDxCIndex, d);
                        var bottomLeft = output.get(b, bottomDxRIndex, leftDxCIndex, d);
                        bottomLeft += dyVal * dxRLerp * inverseDxCLerp;
                        output.set(bottomLeft, b, bottomDxRIndex, leftDxCIndex, d);
                        var bottomRight = output.get(b, bottomDxRIndex, rightDxCIndex, d);
                        bottomRight += dyVal * dxRLerp * dxCLerp;
                        output.set(bottomRight, b, bottomDxRIndex, rightDxCIndex, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
        var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
        var output = ops.buffer([batch, newHeight, newWidth, numChannels], x.dtype);
        var effectiveInputSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
        var effectiveOutputSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < newHeight; r++) {
                for (var c = 0; c < newWidth; c++) {
                    for (var d = 0; d < numChannels; d++) {
                        var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                        var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                        var sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) :
                            Math.floor(sourceFracRow));
                        var sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :
                            Math.floor(sourceFracCol));
                        var newValue = x.get(b, sourceNearestRow, sourceNearestCol, d);
                        output.set(newValue, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.dataSync();
        var meanValues = mean.dataSync();
        var varianceValues = variance.dataSync();
        var scaleValues = scale ? scale.dataSync() : new Float32Array([1]);
        var offsetValues = offset ? offset.dataSync() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ops_1.tensor4d(outValues, x.shape);
    };
    MathBackendCPU.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
        var output = ops.buffer(x.shape, 'float32');
        var rad = radius;
        var maxD = output.shape[3] - 1;
        function sumAcrossChannels(b, r, c, d) {
            var sum = 0.0;
            for (var j = Math.max(0, d - rad); j <= Math.min(d + rad, maxD); j++) {
                var z = x.get(b, r, c, j);
                sum += z * z;
            }
            return sum;
        }
        for (var b = 0; b < output.shape[0]; b++) {
            for (var r = 0; r <= output.shape[1]; r++) {
                for (var c = 0; c < output.shape[2]; c++) {
                    for (var d = 0; d < output.shape[3]; d++) {
                        var sum = sumAcrossChannels(b, r, c, d);
                        var val = x.get(b, r, c, d) * Math.pow(bias + alpha * sum, -beta);
                        output.set(val, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.multinomial = function (logits, normalized, numSamples, seed) {
        var probabilities = normalized ? logits : ops.softmax(logits);
        var batchSize = probabilities.shape[0];
        var numEvents = probabilities.shape[1];
        var res = ops.zeros([batchSize, numSamples], 'int32');
        var resVals = res.dataSync();
        var probVals = probabilities.dataSync();
        for (var b = 0; b < batchSize; ++b) {
            var offset = b * numEvents;
            var cdf = new Float32Array(numEvents - 1);
            cdf[0] = probVals[offset];
            for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
            }
            var random = seedrandom.alea(seed.toString());
            var outOffset = b * numSamples;
            for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                var r = random();
                resVals[outOffset + sampleId] = cdf.length;
                for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                    if (r < cdf[event_2]) {
                        resVals[outOffset + sampleId] = event_2;
                        break;
                    }
                }
            }
        }
        return res;
    };
    MathBackendCPU.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        for (var event_3 = 0; event_3 < indices.size; ++event_3) {
            res[event_3 * depth + indices.get(event_3)] = onValue;
        }
        return ops.tensor2d(res, [indices.size, depth]);
    };
    MathBackendCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var result = ops.buffer(newShape, dtype);
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var aBuf = a.buffer();
        var bBuf = b.buffer();
        var _loop_2 = function (i) {
            var loc = result.indexToLoc(i);
            var aLoc = loc.slice(-a.rank);
            aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
            var aIndex = aBuf.locToIndex(aLoc);
            var bLoc = loc.slice(-b.rank);
            bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
            var bIndex = bBuf.locToIndex(bLoc);
            result.values[i] = op(aValues[aIndex], bValues[bIndex]);
        };
        for (var i = 0; i < result.values.length; ++i) {
            _loop_2(i);
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.dispose = function () { };
    return MathBackendCPU;
}());
exports.MathBackendCPU = MathBackendCPU;
environment_1.ENV.registerBackend('cpu', function () { return new MathBackendCPU(); }, 1);

},{"../environment":48,"../ops/axis_util":104,"../ops/broadcast_util":107,"../ops/concat_util":110,"../ops/erf_util":113,"../ops/ops":124,"../ops/selu_util":130,"../ops/slice_util":132,"../tensor":149,"../types":154,"../util":155,"./backend_util":63,"seedrandom":208}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var array_ops_1 = require("../ops/array_ops");
function castTensor(x, dtype, backend) {
    if (!__1.util.hasEncodingLoss(x.dtype, dtype)) {
        return __1.Tensor.make(x.shape, { dataId: x.dataId }, dtype);
    }
    if (dtype === 'int32') {
        return backend.int(x);
    }
    else if (dtype === 'bool') {
        return backend.notEqual(x, array_ops_1.ArrayOps.scalar(0, x.dtype));
    }
    else {
        throw new Error("Error in Cast: unknown dtype argument (" + dtype + ")");
    }
}
exports.castTensor = castTensor;
function reshapeTensor(x, shape) {
    return __1.Tensor.make(shape, { dataId: x.dataId }, x.dtype);
}
exports.reshapeTensor = reshapeTensor;

},{"..":51,"../ops/array_ops":103}],64:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var axis_util = require("../ops/axis_util");
var ops = require("../ops/ops");
var reduce_util = require("../ops/reduce_util");
var slice_util_1 = require("../ops/slice_util");
var tensor_1 = require("../tensor");
var types = require("../types");
var util = require("../util");
var backend_util = require("./backend_util");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var avg_pool_backprop_gpu_1 = require("./webgl/avg_pool_backprop_gpu");
var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
var binaryop_gpu = require("./webgl/binaryop_gpu");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var clip_gpu_1 = require("./webgl/clip_gpu");
var concat_gpu_1 = require("./webgl/concat_gpu");
var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
var conv_backprop_gpu_depthwise_1 = require("./webgl/conv_backprop_gpu_depthwise");
var conv_gpu_1 = require("./webgl/conv_gpu");
var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
var cumsum_gpu_1 = require("./webgl/cumsum_gpu");
var from_pixels_gpu_1 = require("./webgl/from_pixels_gpu");
var gather_gpu_1 = require("./webgl/gather_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var gpgpu_math = require("./webgl/gpgpu_math");
var gpgpu_util = require("./webgl/gpgpu_util");
var logical_gpu_1 = require("./webgl/logical_gpu");
var lrn_gpu_1 = require("./webgl/lrn_gpu");
var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
var onehot_gpu_1 = require("./webgl/onehot_gpu");
var pad_gpu_1 = require("./webgl/pad_gpu");
var pool_gpu_1 = require("./webgl/pool_gpu");
var reduce_gpu_1 = require("./webgl/reduce_gpu");
var resize_bilinear_backprop_gpu_1 = require("./webgl/resize_bilinear_backprop_gpu");
var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
var resize_nearest_neighbor_gpu_1 = require("./webgl/resize_nearest_neighbor_gpu");
var reverse_gpu_1 = require("./webgl/reverse_gpu");
var slice_gpu_1 = require("./webgl/slice_gpu");
var strided_slice_gpu_1 = require("./webgl/strided_slice_gpu");
var tex_util_1 = require("./webgl/tex_util");
var texture_manager_1 = require("./webgl/texture_manager");
var tile_gpu_1 = require("./webgl/tile_gpu");
var transpose_gpu_1 = require("./webgl/transpose_gpu");
var unary_op = require("./webgl/unaryop_gpu");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var webgl_util = require("./webgl/webgl_util");
var BEFORE_PAGING_CONSTANT = 300;
var MathBackendWebGL = (function () {
    function MathBackendWebGL(gpgpu, delayedStorage) {
        if (delayedStorage === void 0) { delayedStorage = true; }
        this.gpgpu = gpgpu;
        this.delayedStorage = delayedStorage;
        this.texData = new WeakMap();
        this.pendingRead = new WeakMap();
        this.pendingDisposal = new WeakSet();
        this.lruDataGPU = [];
        this.numBytesInGPU = 0;
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        this.binaryCache = {};
        this.disposed = false;
        if (environment_1.ENV.get('WEBGL_VERSION') < 1) {
            throw new Error('WebGL is not supported on this device');
        }
        if (environment_1.ENV.get('IS_BROWSER')) {
            this.canvas = document.createElement('canvas');
        }
        if (gpgpu == null) {
            this.gpgpu = new gpgpu_context_1.GPGPUContext(gpgpu_util.createWebGLContext(this.canvas));
            this.gpgpuCreatedLocally = true;
        }
        else {
            this.gpgpuCreatedLocally = false;
        }
        this.NUM_BYTES_BEFORE_PAGING =
            (window.screen.height * window.screen.width * window.devicePixelRatio) *
                BEFORE_PAGING_CONSTANT;
        this.textureManager = new texture_manager_1.TextureManager(this.gpgpu);
    }
    MathBackendWebGL.prototype.register = function (dataId, shape, dtype) {
        if (this.texData.has(dataId)) {
            throw new Error('Data buffer is already registered');
        }
        this.texData.set(dataId, {
            shape: shape,
            dtype: dtype,
            values: null,
            texture: null,
            texShape: null,
            texType: tex_util_1.TextureType.FLOAT
        });
    };
    MathBackendWebGL.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('MathBackendWebGL.writePixels(): pixels can not be null');
        }
        var texShape = [pixels.height, pixels.width];
        var outShape = [pixels.height, pixels.width, numChannels];
        if (pixels instanceof HTMLVideoElement) {
            if (this.fromPixelsCanvas == null) {
                if (!environment_1.ENV.get('IS_BROWSER')) {
                    throw new Error('Can\'t read pixels from HTMLImageElement outside the browser.');
                }
                if (document.readyState !== 'complete') {
                    throw new Error('The DOM is not ready yet. Please call tf.fromPixels() ' +
                        'once the DOM is ready. One way to do that is to add an event ' +
                        'listener for `DOMContentLoaded` on the document object');
                }
                this.fromPixelsCanvas = document.createElement('canvas');
            }
            this.fromPixelsCanvas.width = pixels.width;
            this.fromPixelsCanvas.height = pixels.height;
            this.fromPixelsCanvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            pixels = this.fromPixelsCanvas;
        }
        var tempPixelArray = tensor_1.Tensor.make(texShape, {}, 'int32');
        this.texData.get(tempPixelArray.dataId).texType = tex_util_1.TextureType.UNSIGNED_BYTE;
        this.gpgpu.uploadPixelDataToTexture(this.getTexture(tempPixelArray.dataId), pixels);
        var program = new from_pixels_gpu_1.FromPixelsProgram(outShape);
        var res = this.compileAndRun(program, [tempPixelArray]);
        tempPixelArray.dispose();
        return res;
    };
    MathBackendWebGL.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendWebGL.write(): values can not be null');
        }
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var texture = texData.texture, texShape = texData.texShape, texType = texData.texType;
        if (texture != null) {
            this.releaseTexture(dataId, texture, texShape, texType);
            texData.texture = null;
            texData.texShape = null;
        }
        texData.values = values;
        if (!this.delayedStorage) {
            this.uploadToGPU(dataId);
        }
    };
    MathBackendWebGL.prototype.readSync = function (dataId) {
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var texture = texData.texture, values = texData.values, texShape = texData.texShape;
        if (values != null) {
            this.cacheOnCPU(dataId);
            return values;
        }
        var shouldTimeProgram = this.activeTimers != null;
        var start;
        if (shouldTimeProgram) {
            start = performance.now();
        }
        var float32Values = this.gpgpu.downloadMatrixFromTexture(texture, texShape[0], texShape[1]);
        if (shouldTimeProgram) {
            this.downloadWaitMs += performance.now() - start;
        }
        this.cacheOnCPU(dataId, float32Values);
        return texData.values;
    };
    MathBackendWebGL.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            var subscribers_1, texData, texture, values, texShape, float32Values, subscribers, vals;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.pendingRead.has(dataId)) {
                            subscribers_1 = this.pendingRead.get(dataId);
                            return [2, new Promise(function (resolve) { return subscribers_1.push(resolve); })];
                        }
                        this.throwIfNoData(dataId);
                        texData = this.texData.get(dataId);
                        texture = texData.texture, values = texData.values, texShape = texData.texShape;
                        if (values != null) {
                            this.cacheOnCPU(dataId);
                            return [2, values];
                        }
                        if (!environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) return [3, 2];
                        return [4, this.gpgpu.downloadMatrixFromTextureAsync(texture, texShape[0], texShape[1])];
                    case 1:
                        float32Values = _a.sent();
                        this.cacheOnCPU(dataId, float32Values);
                        return [2, texData.values];
                    case 2:
                        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 0) {
                            return [2, this.readSync(dataId)];
                        }
                        this.pendingRead.set(dataId, []);
                        return [4, this.gpgpu.runQuery(function () { })];
                    case 3:
                        _a.sent();
                        subscribers = this.pendingRead.get(dataId);
                        this.pendingRead.delete(dataId);
                        vals = this.readSync(dataId);
                        subscribers.forEach(function (resolve) { return resolve(vals); });
                        if (this.pendingDisposal.has(dataId)) {
                            this.pendingDisposal.delete(dataId);
                            this.disposeData(dataId);
                        }
                        return [2, vals];
                }
            });
        });
    };
    MathBackendWebGL.prototype.time = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var oldActiveTimers, newActiveTimers, outerMostTime, flattenedActiveTimers, kernelMs, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        oldActiveTimers = this.activeTimers;
                        newActiveTimers = [];
                        outerMostTime = false;
                        if (this.programTimersStack == null) {
                            this.programTimersStack = newActiveTimers;
                            outerMostTime = true;
                        }
                        else {
                            this.activeTimers.push(newActiveTimers);
                        }
                        this.activeTimers = newActiveTimers;
                        f();
                        flattenedActiveTimers = util.flatten(this.activeTimers);
                        this.activeTimers = oldActiveTimers;
                        if (outerMostTime) {
                            this.programTimersStack = null;
                        }
                        return [4, Promise.all(flattenedActiveTimers).then(function (results) {
                                var sum = 0;
                                results.forEach(function (result) { return sum += result; });
                                return sum;
                            })];
                    case 1:
                        kernelMs = _a.sent();
                        res = {
                            uploadWaitMs: this.uploadWaitMs,
                            downloadWaitMs: this.downloadWaitMs,
                            kernelMs: kernelMs,
                            wallMs: null
                        };
                        this.uploadWaitMs = 0;
                        this.downloadWaitMs = 0;
                        return [2, res];
                }
            });
        });
    };
    MathBackendWebGL.prototype.memory = function () {
        return { unreliable: false, numBytesInGPU: this.numBytesInGPU };
    };
    MathBackendWebGL.prototype.startTimer = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            return this.gpgpu.beginQuery();
        }
        return { startMs: performance.now(), endMs: null };
    };
    MathBackendWebGL.prototype.endTimer = function (query) {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            this.gpgpu.endQuery();
            return query;
        }
        query.endMs = performance.now();
        return query;
    };
    MathBackendWebGL.prototype.getQueryTime = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var timerQuery;
            return __generator(this, function (_a) {
                if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
                    return [2, this.gpgpu.pollQueryTime(query)];
                }
                timerQuery = query;
                return [2, timerQuery.endMs - timerQuery.startMs];
            });
        });
    };
    MathBackendWebGL.prototype.disposeData = function (dataId) {
        if (this.pendingDisposal.has(dataId)) {
            return;
        }
        if (this.pendingRead.has(dataId)) {
            this.pendingDisposal.add(dataId);
            return;
        }
        if (this.texData.has(dataId)) {
            var _a = this.texData.get(dataId), texture = _a.texture, texShape = _a.texShape, texType = _a.texType;
            if (texture != null) {
                this.releaseTexture(dataId, texture, texShape, texType);
            }
            this.texData.delete(dataId);
        }
    };
    MathBackendWebGL.prototype.getTexture = function (dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture;
    };
    MathBackendWebGL.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    MathBackendWebGL.prototype.getCanvas = function () {
        return this.canvas;
    };
    MathBackendWebGL.prototype.slice = function (x, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
        var _a = slice_util_1.getStridedSlicedInfo(x.shape, begin, end, strides, beginMask, endMask), beginIndex = _a[0], size = _a[1];
        if (size.some(function (axis) { return axis === 0; })) {
            return ops.tensor([], size);
        }
        var program = new strided_slice_gpu_1.StridedSliceProgram(beginIndex, strides, size);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.reverse = function (x, axis) {
        var program = new reverse_gpu_1.ReverseProgram(x.shape, axis);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.concat = function (a, b) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.neg = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.NEG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.matMul = function (a, b, transposeA, transposeB) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, transposeA, transposeB);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.multiply = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
        var program = new lrn_gpu_1.LRNProgram(x.shape, radius, bias, alpha, beta);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tile = function (x, reps) {
        var program = new tile_gpu_1.TileProgram(x.shape, reps);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.pad = function (x, paddings, constantValue) {
        var program = new pad_gpu_1.PadProgram(x.shape, paddings, constantValue);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.transpose = function (x, perm) {
        var program = new transpose_gpu_1.TransposeProgram(x.shape, perm);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.gather = function (x, indices, axis) {
        var program = new gather_gpu_1.GatherProgram(x.shape, indices.size, axis);
        return this.compileAndRun(program, [x, indices]);
    };
    MathBackendWebGL.prototype.reduce = function (x, reduceType, dtype) {
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], dtype);
        this.compileAndRun(program, [x], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    MathBackendWebGL.prototype.argReduce = function (x, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], 'int32');
        var inputs = [x];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(x, reduceType, output);
    };
    MathBackendWebGL.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        var outputDType = types.sumOutType(x.dtype);
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    MathBackendWebGL.prototype.argMin = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    MathBackendWebGL.prototype.argMax = function (x, axis) {
        var axes = [axis];
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    MathBackendWebGL.prototype.cumsum = function (x, axis, exclusive, reverse) {
        if (axis !== x.rank - 1) {
            throw new Error("WebGL cumsum shader expects an inner-most axis=" + (x.rank - 1) + " " +
                ("but got axis=" + axis));
        }
        var program = new cumsum_gpu_1.CumSumProgram(x.shape, exclusive, reverse);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.equal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.notEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.less = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.lessEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greater = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greaterEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalNot = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.logicalAnd = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalOr = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.where = function (condition, a, b, dtype) {
        var program = new logical_gpu_1.WhereProgram(condition.rank, a.shape, a.rank);
        var output = this.makeOutputArray(program.outputShape, dtype);
        return this.compileAndRun(program, [condition, a, b], output);
    };
    MathBackendWebGL.prototype.topKValues = function (x, k) {
        throw new Error('topKValues GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.topKIndices = function (x, k) {
        throw new Error('topKIndices GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.minimum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.mod = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MOD, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.maximum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.squaredDifference = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SQUARED_DIFFERENCE, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.realDivide = function (a, b) {
        var op = binaryop_gpu.DIV;
        var outputDtype = 'float32';
        var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, outputDtype);
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.floorDiv = function (a, b) {
        var op = binaryop_gpu.INT_DIV;
        var outputDtype = 'int32';
        var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, outputDtype);
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.add = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.subtract = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.pow = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.ceil = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.CEIL);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.floor = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sign = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.round = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ROUND);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.exp = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXP);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.expm1 = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXPM1);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.log = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.log1p = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG1P);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sqrt = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQRT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.rsqrt = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RSQRT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.square = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.reciprocal = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RECIPROCAL);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.relu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.elu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.eluDer = function (dy, y) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ELU_DER, dy.shape, y.shape);
        return this.compileAndRun(program, [dy, y]);
    };
    MathBackendWebGL.prototype.selu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.int = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TO_INT);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.clip = function (x, min, max) {
        var program = new clip_gpu_1.ClipProgram(x.shape, min, max);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.abs = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ABS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sigmoid = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.softplus = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SOFTPLUS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.asin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.acos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atan2 = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ATAN2, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.sinh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SINH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cosh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COSH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tanh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TANH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.asinh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASINH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.acosh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOSH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atanh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATANH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.erf = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ERF);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.step = function (x, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.conv2d = function (x, filter, convInfo) {
        var program = new conv_gpu_1.Conv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
    };
    MathBackendWebGL.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_depthwise_1.DepthwiseConv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.depthwiseConv2DDerFilter = function (x, dy, convInfo) {
        var program = new conv_backprop_gpu_depthwise_1.DepthwiseConv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
    };
    MathBackendWebGL.prototype.maxPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        var output = this.makeOutputArray(program.outputShape, x.dtype);
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.avgPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(maxPoolBackPropProgram.outputShape, x.dtype);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions], output);
        maxPoolPositions.dispose();
        return result;
    };
    MathBackendWebGL.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var avgPoolBackpropProgram = new avg_pool_backprop_gpu_1.AvgPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(avgPoolBackpropProgram.outputShape, x.dtype);
        return this.compileAndRun(avgPoolBackpropProgram, [dy], output);
    };
    MathBackendWebGL.prototype.cast = function (x, dtype) {
        return backend_util.castTensor(x, dtype, this);
    };
    MathBackendWebGL.prototype.reshape = function (x, shape) {
        return backend_util.reshapeTensor(x, shape);
    };
    MathBackendWebGL.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
        var program = new resize_bilinear_backprop_gpu_1.ResizeBilinearBackpropProgram(dy, x, alignCorners);
        return this.compileAndRun(program, [dy]);
    };
    MathBackendWebGL.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
        var program = new resize_nearest_neighbor_gpu_1.ResizeNearestNeighborProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.multinomial = function (logits, normalized, numSamples, seed) {
        var probs = normalized ? logits : ops.softmax(logits);
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {
        return tensor_1.Tensor.make(shape, {}, dtype);
    };
    MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup) {
        var _this = this;
        if (output == null) {
            output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        var inputsData = inputs.map(function (input) {
            _this.uploadToGPU(input.dataId);
            return { tensor: input, texData: _this.texData.get(input.dataId) };
        });
        this.uploadToGPU(output.dataId);
        var outputData = {
            tensor: output,
            texData: this.texData.get(output.dataId)
        };
        var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputsData, outputData);
        });
        var shouldTimeProgram = this.activeTimers != null;
        var query;
        if (shouldTimeProgram) {
            query = this.startTimer();
        }
        gpgpu_math.runProgram(binary, inputsData, outputData, customSetup);
        if (this.numBytesInGPU > this.NUM_BYTES_BEFORE_PAGING) {
            var numBytesToPage = this.numBytesInGPU - this.NUM_BYTES_BEFORE_PAGING;
            while (numBytesToPage > 0) {
                var dataId = this.lruDataGPU.shift();
                var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
                numBytesToPage -= this.computeBytes(shape, dtype);
                this.read(dataId);
            }
        }
        if (shouldTimeProgram) {
            query = this.endTimer(query);
            this.activeTimers.push(this.getQueryTime(query));
        }
        return output;
    };
    MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    MathBackendWebGL.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    MathBackendWebGL.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        this.canvas.remove();
        if (this.fromPixelsCanvas != null) {
            this.fromPixelsCanvas.remove();
        }
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
        this.disposed = true;
    };
    MathBackendWebGL.prototype.throwIfNoData = function (dataId) {
        if (!this.texData.has(dataId)) {
            throw new Error("WebGL backend: No data found for this tensor. " +
                "Did you change your backend in the middle of the program? " +
                "New backends can't use Tensors created with previous backends");
        }
    };
    MathBackendWebGL.prototype.uploadToGPU = function (dataId) {
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var shape = texData.shape, values = texData.values, texture = texData.texture, dtype = texData.dtype, texType = texData.texType;
        if (texture != null) {
            this.lruDataGPU.splice(this.lruDataGPU.indexOf(dataId), 1);
            this.lruDataGPU.push(dataId);
            return;
        }
        var shouldTimeProgram = this.activeTimers != null;
        var start;
        if (shouldTimeProgram) {
            start = performance.now();
        }
        var texShape = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        texData.texShape = texShape;
        var newTexture = this.acquireTexture(dataId, texShape, texType);
        texData.texture = newTexture;
        if (values != null) {
            this.gpgpu.uploadMatrixToTexture(newTexture, texShape[0], texShape[1], typedArrayToFloat32(values, dtype));
            texData.values = null;
            if (shouldTimeProgram) {
                this.uploadWaitMs += performance.now() - start;
            }
        }
    };
    MathBackendWebGL.prototype.cacheOnCPU = function (dataId, float32Values) {
        var dontKeepCopyOnGPU = this.delayedStorage;
        var texData = this.texData.get(dataId);
        var texture = texData.texture, texShape = texData.texShape, dtype = texData.dtype, texType = texData.texType;
        if (dontKeepCopyOnGPU && texture != null) {
            this.releaseTexture(dataId, texture, texShape, texType);
            texData.texture = null;
            texData.texShape = null;
        }
        if (float32Values != null) {
            texData.values = float32ToTypedArray(float32Values, dtype);
        }
    };
    MathBackendWebGL.prototype.releaseTexture = function (dataId, texture, texShape, texType) {
        var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
        var idx = this.lruDataGPU.indexOf(dataId);
        if (idx >= 0) {
            this.lruDataGPU.splice(idx, 1);
        }
        this.numBytesInGPU -= this.computeBytes(shape, dtype);
        this.textureManager.releaseTexture(texture, texShape, texType);
    };
    MathBackendWebGL.prototype.acquireTexture = function (dataId, texShape, texType) {
        var _a = this.texData.get(dataId), shape = _a.shape, dtype = _a.dtype;
        this.lruDataGPU.push(dataId);
        this.numBytesInGPU += this.computeBytes(shape, dtype);
        return this.textureManager.acquireTexture(texShape, texType);
    };
    MathBackendWebGL.prototype.computeBytes = function (shape, dtype) {
        return util.sizeFromShape(shape) * util.bytesPerElement(dtype);
    };
    return MathBackendWebGL;
}());
exports.MathBackendWebGL = MathBackendWebGL;
if (environment_1.ENV.get('IS_BROWSER')) {
    environment_1.ENV.registerBackend('webgl', function () { return new MathBackendWebGL(); }, 2);
}
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        var result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (var i = 0; i < result.length; ++i) {
            result[i] = Math.round(a[i]);
        }
        return result;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
function typedArrayToFloat32(a, dtype) {
    return (a instanceof Float32Array) ? a : new Float32Array(a);
}

},{"../environment":48,"../ops/axis_util":104,"../ops/ops":124,"../ops/reduce_util":127,"../ops/slice_util":132,"../tensor":149,"../types":154,"../util":155,"./backend_util":63,"./webgl/argminmax_gpu":65,"./webgl/avg_pool_backprop_gpu":66,"./webgl/batchnorm_gpu":67,"./webgl/binaryop_gpu":68,"./webgl/clip_gpu":69,"./webgl/concat_gpu":70,"./webgl/conv_backprop_gpu":71,"./webgl/conv_backprop_gpu_depthwise":72,"./webgl/conv_gpu":73,"./webgl/conv_gpu_depthwise":74,"./webgl/cumsum_gpu":75,"./webgl/from_pixels_gpu":76,"./webgl/gather_gpu":77,"./webgl/gpgpu_context":78,"./webgl/gpgpu_math":79,"./webgl/gpgpu_util":80,"./webgl/logical_gpu":81,"./webgl/lrn_gpu":82,"./webgl/max_pool_backprop_gpu":83,"./webgl/mulmat_gpu":84,"./webgl/multinomial_gpu":85,"./webgl/onehot_gpu":86,"./webgl/pad_gpu":87,"./webgl/pool_gpu":88,"./webgl/reduce_gpu":89,"./webgl/resize_bilinear_backprop_gpu":90,"./webgl/resize_bilinear_gpu":91,"./webgl/resize_nearest_neighbor_gpu":92,"./webgl/reverse_gpu":93,"./webgl/slice_gpu":95,"./webgl/strided_slice_gpu":96,"./webgl/tex_util":97,"./webgl/texture_manager":98,"./webgl/tile_gpu":99,"./webgl/transpose_gpu":100,"./webgl/unaryop_gpu":101,"./webgl/webgl_util":102}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        var compOp = (op === 'max') ? '>' : '<';
        var indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AvgPool2DBackpropProgram = (function () {
    function AvgPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float avgMultiplier = float(" + avgMultiplier + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return AvgPool2DBackpropProgram;
}());
exports.AvgPool2DBackpropProgram = AvgPool2DBackpropProgram;

},{}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var BatchNormProgram = (function () {
    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.supportsBroadcasting = true;
        this.variableNames = ['x', 'mean', 'variance'];
        broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
        broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
        var offsetSnippet = '0.0';
        if (offsetShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        var scaleSnippet = '1.0';
        if (scaleShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale * inversesqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    }
    return BatchNormProgram;
}());
exports.BatchNormProgram = BatchNormProgram;

},{"../../ops/broadcast_util":107}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var CHECK_NAN_SNIPPET = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n";
exports.ADD = 'return a + b;';
exports.SUB = 'return a - b;';
exports.MUL = 'return a * b;';
exports.DIV = 'return a / b;';
exports.INT_DIV = "\n  float resultSign = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  int result = ia / ib;\n  int amodb = ia - ib * result;\n\n  if (resultSign < 0.0 && amodb != 0) {\n    result -= 1;\n  }\n  return float(result);\n";
exports.POW = "\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
exports.SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';
exports.EQUAL = "return float(a == b);";
exports.NOT_EQUAL = "return float(a != b);";
exports.LESS = "return float(a < b);";
exports.LESS_EQUAL = "return float(a <= b);";
exports.GREATER = "return float(a > b);";
exports.GREATER_EQUAL = "return float(a >= b);";
exports.LOGICAL_AND = "return float(a >= 1.0 && b >= 1.0);";
exports.LOGICAL_OR = "return float(a >= 1.0 || b >= 1.0);";
exports.MAX = CHECK_NAN_SNIPPET + "\n  return max(a, b);\n";
exports.MIN = CHECK_NAN_SNIPPET + "\n  return min(a, b);\n";
exports.MOD = "return mod(a, b);";
exports.ATAN2 = CHECK_NAN_SNIPPET + "\n  return atan(a, b);\n";
exports.ELU_DER = "return (b >= 1.0) ? a : a * (b + 1.0);";
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../../ops/broadcast_util":107}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClipProgram = (function () {
    function ClipProgram(aShape, min, max) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        var minFixed = min.toFixed(20);
        var maxFixed = max.toFixed(20);
        this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    ";
    }
    return ClipProgram;
}());
exports.ClipProgram = ClipProgram;

},{}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../../ops/concat_util");
var ConcatProgram = (function () {
    function ConcatProgram(aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        this.outputShape =
            concat_util.computeOutShape(aShape, bShape, 1);
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < " + aShape[1] + ") {\n          value = getA(yR, yC);\n        } else {\n          yC -= " + aShape[1] + ";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ConcatProgram;
}());
exports.ConcatProgram = ConcatProgram;

},{"../../ops/concat_util":110}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DDerFilterProgram = (function () {
    function Conv2DDerFilterProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerFilterProgram;
}());
exports.Conv2DDerFilterProgram = Conv2DDerFilterProgram;
var Conv2DDerInputProgram = (function () {
    function Conv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + convInfo.outChannels + "; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerInputProgram;
}());
exports.Conv2DDerInputProgram = Conv2DDerInputProgram;

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DDerFilterProgram = (function () {
    function DepthwiseConv2DDerFilterProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + channelMul + " + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DDerFilterProgram;
}());
exports.DepthwiseConv2DDerFilterProgram = DepthwiseConv2DDerFilterProgram;
var DepthwiseConv2DDerInputProgram = (function () {
    function DepthwiseConv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + channelMul + "; dm++) {\n              int d2 = d1 * " + channelMul + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DDerInputProgram;
}());
exports.DepthwiseConv2DDerInputProgram = DepthwiseConv2DDerInputProgram;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DProgram = (function () {
    function Conv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        var inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR * " + dilationHeight + ";\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC * " + dilationWidth + ";\n\n            if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DProgram;
}());
exports.Conv2DProgram = Conv2DProgram;

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DProgram = (function () {
    function DepthwiseConv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var xNumRows = convInfo.inHeight;
        var xNumCols = convInfo.inWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dilationHeight = convInfo.dilationHeight;
        var dilationWidth = convInfo.dilationWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR * " + dilationHeight + ";\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC * " + dilationWidth + ";\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DProgram;
}());
exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var CumSumProgram = (function () {
    function CumSumProgram(shape, exclusive, reverse) {
        this.variableNames = ['x'];
        this.outputShape = shape;
        var rank = shape.length;
        var finalDim = shape[shape.length - 1];
        var comparator = reverse ? '<' : '>';
        this.userCode = "\n      int getIndex(int i) {\n        " + (reverse ? "return " + finalDim + " -i - 1;" : 'return i;') + "\n      }\n\n      void main() {\n        " + shader_compiler_1.getCoordsDataType(rank) + " coords = getOutputCoords();\n        int end = " + getFinalCoord(rank, 'coords') + ";\n        float val = 0.0;\n        for (int i = " + finalDim + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + comparator + " end) {\n            continue;\n          }\n          if (idx == end && " + exclusive + ") {\n            continue;\n          }\n          " + getFinalCoord(rank, 'coords') + " = idx;\n          val += getX(" + getCoords(rank, 'coords') + ");\n        }\n        setOutput(val);\n      }\n    ";
    }
    return CumSumProgram;
}());
exports.CumSumProgram = CumSumProgram;
function getCoords(rank, name) {
    if (rank === 1) {
        return "" + name;
    }
    else if (rank === 2) {
        return name + ".x, " + name + ".y";
    }
    else if (rank === 3) {
        return name + ".x, " + name + ".y, " + name + ".z";
    }
    else if (rank === 4) {
        return name + ".x, " + name + ".y, " + name + ".z, " + name + ".w";
    }
    else {
        throw Error("Cumulative sum for rank " + rank + " is not yet supported");
    }
}
function getFinalCoord(rank, name) {
    if (rank === 1) {
        return "" + name;
    }
    else if (rank === 2) {
        return name + ".y";
    }
    else if (rank === 3) {
        return name + ".z";
    }
    else if (rank === 4) {
        return name + ".w";
    }
    else {
        throw Error("Cumulative sum for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":94}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FromPixelsProgram = (function () {
    function FromPixelsProgram(outputShape) {
        this.variableNames = ['A'];
        var height = outputShape[0], width = outputShape[1];
        this.outputShape = outputShape;
        this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + width + ".0, " + height + ".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
    }
    return FromPixelsProgram;
}());
exports.FromPixelsProgram = FromPixelsProgram;

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var GatherProgram = (function () {
    function GatherProgram(aShape, indicesLength, axis) {
        this.variableNames = ['A', 'indices'];
        var outputShape = aShape.slice();
        outputShape[axis] = indicesLength;
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape, axis);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return GatherProgram;
}());
exports.GatherProgram = GatherProgram;
function getSourceCoords(aShape, axis) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Gather for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "int(getIndices(resRC))";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        if (i === axis) {
            sourceCoords.push("int(getIndices(" + currentCoords[i] + "))");
        }
        else {
            sourceCoords.push("" + currentCoords[i]);
        }
    }
    return sourceCoords.join();
}

},{"./shader_compiler":94}],78:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        this.vertexAttrsAreBound = false;
        this.itemsToPoll = [];
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
            this.colorBufferFloatExtension =
                this.gl.getExtension('WEBGL_color_buffer_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) {
            this.getBufferSubDataAsyncExtension =
                this.gl.getExtension('WEBGL_get_buffer_sub_data_async');
        }
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        if (this.disposed) {
            return;
        }
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.getBufferSubDataAsyncExtension == null) {
                    throw new Error("Cannot download matrix from output texture asynchronously, " +
                        "WEBGL_get_buffer_sub_data_async is not enabled.");
                }
                return [2, this.downloadMatrixDriverAsync(texture, function () { return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns); })];
            });
        });
    };
    GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels); });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        if (!this.vertexAttrsAreBound) {
            this.setProgram(program);
            this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (program, uniformName, shouldThrow) {
        if (shouldThrow === void 0) { shouldThrow = true; }
        this.throwIfDisposed();
        if (shouldThrow) {
            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
        }
        else {
            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);
        }
    };
    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
        var _this = this;
        this.throwIfDisposed();
        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
    };
    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function () {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.getQueryTimerExtension = function () {
        if (this.disjointQueryTimerExtension == null) {
            this.disjointQueryTimerExtension =
                webgl_util.getExtensionOrThrow(this.gl, environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?
                    'EXT_disjoint_timer_query_webgl2' :
                    'EXT_disjoint_timer_query');
        }
        return this.disjointQueryTimerExtension;
    };
    GPGPUContext.prototype.getQueryTimerExtensionWebGL2 = function () {
        return this.getQueryTimerExtension();
    };
    GPGPUContext.prototype.getQueryTimerExtensionWebGL1 = function () {
        return this.getQueryTimerExtension();
    };
    GPGPUContext.prototype.runQuery = function (queryFn) {
        var query = this.beginQuery();
        queryFn();
        this.endQuery();
        return this.pollQueryTime(query);
    };
    GPGPUContext.prototype.beginQuery = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            var gl2 = this.gl;
            var ext_1 = this.getQueryTimerExtensionWebGL2();
            var query_1 = gl2.createQuery();
            gl2.beginQuery(ext_1.TIME_ELAPSED_EXT, query_1);
            return query_1;
        }
        var ext = this.getQueryTimerExtensionWebGL1();
        var query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        return query;
    };
    GPGPUContext.prototype.endQuery = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            var gl2 = this.gl;
            var ext_2 = this.getQueryTimerExtensionWebGL2();
            gl2.endQuery(ext_2.TIME_ELAPSED_EXT);
            return;
        }
        var ext = this.getQueryTimerExtensionWebGL1();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    };
    GPGPUContext.prototype.isQueryAvailable = function (query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return true;
        }
        if (queryTimerVersion === 2) {
            var gl2 = this.gl;
            var ext = this.getQueryTimerExtensionWebGL2();
            var available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            if (this.disjoint == null) {
                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            }
            return available && !this.disjoint;
        }
        else {
            var ext = this.getQueryTimerExtensionWebGL1();
            var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
            if (this.disjoint == null) {
                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            }
            return available && !this.disjoint;
        }
    };
    GPGPUContext.prototype.pollQueryTime = function (query) {
        var _this = this;
        return new Promise(function (resolve) {
            var queryTimerVersion = environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION');
            _this.addItemToPoll(function () { return _this.isQueryAvailable(query, queryTimerVersion); }, function () { return resolve(_this.getQueryTime(query, queryTimerVersion)); });
        });
    };
    GPGPUContext.prototype.pollItems = function () {
        var index = binSearchLastTrue(this.itemsToPoll.map(function (x) { return x.isDoneFn; }));
        for (var i = 0; i <= index; ++i) {
            var resolveFn = this.itemsToPoll[i].resolveFn;
            resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index + 1);
    };
    GPGPUContext.prototype.addItemToPoll = function (isDoneFn, resolveFn) {
        var _this = this;
        this.itemsToPoll.push({ isDoneFn: isDoneFn, resolveFn: resolveFn });
        if (this.itemsToPoll.length > 1) {
            return;
        }
        util.repeatedTry(function () {
            _this.pollItems();
            return _this.itemsToPoll.length === 0;
        });
    };
    GPGPUContext.prototype.getQueryTime = function (query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return null;
        }
        if (queryTimerVersion === 2) {
            var gl2 = this.gl;
            var timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            return timeElapsedNanos / 1000000;
        }
        else {
            var ext = this.getQueryTimerExtensionWebGL1();
            var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
            return timeElapsedNanos / 1000000;
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(this.gl);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.downloadMatrixDriverSetup(texture);
        var result = downloadAndDecode();
        this.downloadMatrixDriverTeardown();
        return result;
    };
    GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.downloadMatrixDriverSetup(texture);
                        return [4, downloadAndDecode()];
                    case 1:
                        result = _a.sent();
                        this.downloadMatrixDriverTeardown();
                        return [2, result];
                }
            });
        });
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;
function binSearchLastTrue(arr) {
    var start = 0;
    var end = arr.length - 1;
    var best = -1;
    while (start <= end) {
        var mid = (start + end) >> 1;
        var isDone = arr[mid]();
        if (isDone) {
            best = mid;
            start = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
    return best;
}
exports.binSearchLastTrue = binSearchLastTrue;

},{"../../environment":48,"../../util":155,"./gpgpu_util":80,"./tex_util":97,"./webgl_util":102}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var shader_compiler = require("./shader_compiler");
var NAN_UNIFORM_NAME = 'NaN';
function shouldUploadNaNUniform() {
    return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
}
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = inputs.map(function (input, i) {
        var shapeInfo = {
            logicalShape: input.tensor.shape,
            texShape: input.texData.texShape
        };
        return { name: program.variableNames[i], shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.tensor.shape,
        texShape: output.texData.texShape
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    var webGLProgram = gpgpu.createProgram(source);
    var uniformLocations = {};
    for (var i = 0; i < program.variableNames.length; i++) {
        var uniformName = program.variableNames[i];
        uniformLocations[uniformName] =
            gpgpu.getUniformLocation(webGLProgram, uniformName);
    }
    if (shouldUploadNaNUniform()) {
        var throwIfNaNUniformIsNotUsed = false;
        uniformLocations[NAN_UNIFORM_NAME] = gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME, throwIfNaNUniformIsNotUsed);
    }
    return {
        program: program,
        source: source,
        webGLProgram: webGLProgram,
        uniformLocations: uniformLocations,
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
            ("was executed with " + inputs.length + " inputs"));
    }
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = inputs[i].tensor.shape;
        var texShapeB = inputs[i].texData.texShape;
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.texData.texture;
    var outTexShape = output.texData.texShape;
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.texData.texture;
        var variableName = binary.program.variableNames[i];
        var variableUniformLocation = binary.uniformLocations[variableName];
        gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
    });
    if (shouldUploadNaNUniform()) {
        gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
    }
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram();
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var keyInputs = '';
    inputs.concat(output).forEach(function (x) {
        keyInputs += x.tensor.shape + "_" + x.texData.texShape;
    });
    var keyUserCode = program.userCode;
    var keyBroadcast = (program.supportsBroadcasting === true).toString();
    var key = program.constructor.name;
    key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
    return key;
}
exports.makeShaderKey = makeShaderKey;

},{"../../environment":48,"../../util":155,"./shader_compiler":94}],80:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA;
        }
        return gl.RED;
    }
    return gl.RGBA;
}
function getTextureType(gl) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.UNSIGNED_BYTE;
    }
    return gl.FLOAT;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    var success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);
    return success &&
        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var unpackedArray;
    if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
        if (channelsPerTexture === 1) {
            unpackedArray = matrix;
        }
        else {
            unpackedArray =
                new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
            tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
        }
    }
    else {
        unpackedArray = tex_util.encodeFloatArray(matrix);
    }
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
var floatDownloadBuffer = null;
var byteDownloadBuffer = null;
function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    var neededSize = rows * columns * channelsPerTexture;
    if (isFloatTexture) {
        if (floatDownloadBuffer == null ||
            floatDownloadBuffer.length < neededSize) {
            floatDownloadBuffer = new Float32Array(neededSize);
        }
    }
    else {
        if (byteDownloadBuffer == null || byteDownloadBuffer.length < neededSize) {
            byteDownloadBuffer = new Uint8Array(neededSize);
        }
    }
    return (isFloatTexture ? floatDownloadBuffer : byteDownloadBuffer)
        .subarray(0, neededSize);
}
function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    if (isFloatTexture) {
        var matrix = new Float32Array(rows * columns);
        tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
        return matrix;
    }
    else {
        return tex_util.decodeToFloatArray(downloadTarget);
    }
}
function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
    return __awaiter(this, void 0, void 0, function () {
        var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    gl2 = gl;
                    channelsPerPixel = 4;
                    downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                    bufferSizeBytes = downloadTarget instanceof Float32Array ?
                        downloadTarget.length * 4 :
                        downloadTarget;
                    buffer = gl.createBuffer();
                    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });
                    webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW); });
                    webgl_util.callAndCheck(gl, function () {
                        return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
                    });
                    return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                case 1:
                    _a.sent();
                    return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
            }
        });
    });
}
exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerPixel = 4;
    var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });
    return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
    var size = rows * columns * 4;
    var downloadTarget = new Uint8Array(size);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget); });
    var packedRGBA = new Float32Array(size);
    for (var i = 0; i < downloadTarget.length; i++) {
        packedRGBA[i] = downloadTarget[i];
    }
    var matrix = new Float32Array(rows * columns * channels);
    tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
    return matrix;
}
exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"../../environment":48,"./tex_util":97,"./webgl_util":102}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var WhereProgram = (function () {
    function WhereProgram(cRank, shape, rank) {
        this.variableNames = ['c', 'a', 'b'];
        this.outputShape = shape;
        var cCoords;
        var abCoords;
        if (rank > 4) {
            throw Error("Where for rank " + rank + " is not yet supported");
        }
        if (rank === 1) {
            abCoords = "resRC";
            cCoords = "resRC";
        }
        else {
            var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
            var cCoordVars = [];
            var abCoordVars = [];
            for (var i = 0; i < shape.length; i++) {
                abCoordVars.push("" + currentCoords[i]);
                if (i < cRank) {
                    cCoordVars.push("" + currentCoords[i]);
                }
            }
            cCoords = cCoordVars.join();
            abCoords = abCoordVars.join();
        }
        var dtype = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        float cVal = getC(" + cCoords + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + abCoords + "));\n        } else {\n          setOutput(getB(" + abCoords + "));\n        }\n      }\n    ";
    }
    return WhereProgram;
}());
exports.WhereProgram = WhereProgram;

},{"./shader_compiler":94}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRNProgram = (function () {
    function LRNProgram(xShape, radius, bias, alpha, beta) {
        this.variableNames = ['x'];
        this.outputShape = [];
        var rad = radius;
        var maxD = xShape[3] - 1;
        this.outputShape = xShape;
        var powOperator;
        var basis = "float(" + bias + ") + float(" + alpha + ") * sum";
        if (beta === 0.5) {
            powOperator = "inversesqrt(" + basis + ")";
        }
        else if (beta === 1.0) {
            powOperator = "1.0/(" + basis + ")";
        }
        else {
            powOperator = "exp(log(" + basis + ") * float(-" + beta + "));";
        }
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + rad + "; j <= " + rad + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + maxD + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + powOperator + ";\n        setOutput(val);\n      }\n    ";
    }
    return LRNProgram;
}());
exports.LRNProgram = LRNProgram;

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MaxPool2DBackpropProgram = (function () {
    function MaxPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var lastIndex = filterHeight * filterWidth - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return MaxPool2DBackpropProgram;
}());
exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;

},{}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.variableNames = ['matrixA', 'matrixB'];
        var outerShapeA = transposeA ? aShape[1] : aShape[0];
        var outerShapeB = transposeB ? bShape[0] : bShape[1];
        var sharedDim = transposeA ? aShape[0] : aShape[1];
        this.outputShape = [outerShapeA, outerShapeB];
        var aSnippetFromOffset = function (vec4Offset, indexVar) {
            return transposeA ? indexVar + " + " + vec4Offset + ", aRow" :
                "aRow, " + indexVar + " + " + vec4Offset;
        };
        var bSnippetFromOffset = function (vec4Offset, indexVar) {
            return transposeB ? "bCol, " + indexVar + " + " + vec4Offset :
                indexVar + " + " + vec4Offset + ", bCol";
        };
        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
        var sharedDimVec4Remainder = sharedDim % 4;
        this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MultinomialProgram = (function () {
    function MultinomialProgram(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
    }
    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return MultinomialProgram;
}());
exports.MultinomialProgram = MultinomialProgram;

},{}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OneHotProgram = (function () {
    function OneHotProgram(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
    }
    return OneHotProgram;
}());
exports.OneHotProgram = OneHotProgram;

},{}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var PadProgram = (function () {
    function PadProgram(xShape, paddings, constantValue) {
        this.variableNames = ['x'];
        this.outputShape = paddings.map(function (p, i) { return p[0] + xShape[i] + p[1]; });
        var rank = xShape.length;
        var type = shader_compiler_1.getCoordsDataType(rank);
        var start = paddings.map(function (p) { return p[0]; }).join(',');
        var end = paddings.map(function (p, i) { return p[0] + xShape[i]; }).join(',');
        var unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);
        if (rank === 1) {
            this.userCode = "\n        int start = " + start + ";\n        int end = " + end + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + constantValue + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
            return;
        }
        this.userCode = "\n      " + type + " start = " + type + "(" + start + ");\n      " + type + " end = " + type + "(" + end + ");\n\n      void main() {\n        " + type + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + constantValue + "));\n        } else {\n          " + type + " coords = outC - start;\n          setOutput(getX(" + unpackedCoords + "));\n        }\n      }\n    ";
    }
    return PadProgram;
}());
exports.PadProgram = PadProgram;

},{"./shader_compiler":94}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool2DProgram = (function () {
    function Pool2DProgram(convInfo, poolType, computePositions) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        var isAvgPool = poolType === 'avg';
        var initializationValue = '0.0';
        if (!isAvgPool) {
            initializationValue = '-1.0 / 0.0';
        }
        if (computePositions) {
            var compareOp_1 = '>=';
            this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            return;
        }
        var compareOp = 'max';
        var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = "avgValue / count";
        }
        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        var filterWidthVec4Remainder = filterWidth % 4;
        var updateSnippet = "\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return Pool2DProgram;
}());
exports.Pool2DProgram = Pool2DProgram;

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceProgram = (function () {
    function ReduceProgram(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var isReduceSum = reduceType === 'sum';
        var initializationValue = '0.0';
        if (!isReduceSum) {
            if (reduceType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        var compareOp = reduceType === 'min' ? 'min' : 'max';
        var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = "sumValue";
        }
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        var checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return ReduceProgram;
}());
exports.ReduceProgram = ReduceProgram;

},{}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinearBackpropProgram = (function () {
    function ResizeBilinearBackpropProgram(dy, x, alignCorners) {
        this.variableNames = ['dy'];
        this.outputShape = [];
        this.outputShape = x.shape;
        var _a = x.shape, xHeight = _a[1], xWidth = _a[2];
        var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
        var effectiveXSize = [
            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,
            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth
        ];
        var effectiveYSize = [
            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,
            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth
        ];
        var heightScale = effectiveXSize[0] / effectiveYSize[0];
        var widthScale = effectiveXSize[1] / effectiveYSize[1];
        var invHeightScale = 1 / heightScale;
        var invWidthScale = 1 / widthScale;
        var winHeight = (Math.ceil(invHeightScale) * 2) + 2;
        var winWidth = (Math.ceil(invWidthScale) * 2) + 2;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + heightScale + ");\n        const float widthScale = float(" + widthScale + ");\n\n        const float invHeightScale = float(" + invHeightScale + ");\n        const float invWidthScale = float(" + invWidthScale + ");\n\n        const int winHeight = int(" + winHeight + ");\n        const int winWidth = int(" + winWidth + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + yHeight + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + yWidth + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (xHeight - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (xWidth - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
    }
    return ResizeBilinearBackpropProgram;
}());
exports.ResizeBilinearBackpropProgram = ResizeBilinearBackpropProgram;

},{}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinearProgram = (function () {
    function ResizeBilinearProgram(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];
        this.outputShape = [batch, newHeight, newWidth, depth];
        var effectiveInSize = [
            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,
            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth
        ];
        var effectiveOutSize = [
            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,
            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth
        ];
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeBilinearProgram;
}());
exports.ResizeBilinearProgram = ResizeBilinearProgram;

},{}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeNearestNeighborProgram = (function () {
    function ResizeNearestNeighborProgram(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];
        this.outputShape = [batch, newHeight, newWidth, depth];
        var effectiveInSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
        var effectiveOutSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
        var roundBase = alignCorners ? '0.5' : '0.0';
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + roundBase + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeNearestNeighborProgram;
}());
exports.ResizeNearestNeighborProgram = ResizeNearestNeighborProgram;

},{}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var ReverseProgram = (function () {
    function ReverseProgram(xShape, axis) {
        this.variableNames = ['x'];
        var rank = xShape.length;
        if (rank > 4) {
            throw new Error("WebGL backend: Reverse of rank-" + rank + " tensor is not yet supported");
        }
        this.outputShape = xShape;
        if (rank === 1) {
            this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + xShape[0] + " - coord - 1));\n        }\n      ";
            return;
        }
        var getInCoord = function (i) {
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
                return xShape[i] + " - coords[" + i + "] - 1";
            }
            return "coords[" + i + "]";
        };
        var inCoords = xShape.map(function (_, i) { return getInCoord(i); }).join(',');
        var type = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + type + " coords = getOutputCoords();\n        setOutput(getX(" + inCoords + "));\n      }\n    ";
    }
    return ReverseProgram;
}());
exports.ReverseProgram = ReverseProgram;

},{"./shader_compiler":94}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var broadcast_util = require("../../ops/broadcast_util");
var tex_util = require("./tex_util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var sampleSnippet = getSampleSnippet();
    var setOutputSnippet = getSetOutputSnippet();
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
        outputSamplingSnippet, inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getSampleSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SAMPLE_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
}
function getSetOutputSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
}
function getSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        case 5:
            return getSampler5D(inInfo);
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var res = getSamplerFlat(inInfo);
    res += getSamplerFromInInfo(inInfo);
    if (broadcast ||
        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
    }
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        case 5:
            return getOutput5DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_5D_SNIPPET = "\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int row, int col, int depth,\n    int depth2, int depth3) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + \n              depth * stride2 + depth2 * stride3 + depth3;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    vec4 sampleValue = texture2D(textureSampler, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n";
var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  struct ivec5\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n  };\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n  " + SAMPLE_5D_SNIPPET + "\n";
function getOutputScalarCoords() {
    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
    }
    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function getOutput5DCoords(shape, texShape) {
    var stride3 = shape[4];
    var stride2 = shape[3] * stride3;
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + texShape[0] + ",\n                             " + texShape[1] + "));\n\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      index -= d * " + stride2 + ";\n\n      int d2 = index  / " + stride3 + ";\n      int d3 = index - d2 * " + stride3 + ";\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
    }
    if (shape[1] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
    }
    if (shape[0] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
    }
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function getSamplerScalar(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return sampleTexture(" + texName + ", halfCR);\n    }\n  ";
}
function getSampler1D(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
}
function getSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    if (texNumR === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sampleTexture(" + texName + ", uv);\n  }\n";
}
function getSampler3D(inputInfo) {
    var texShape = inputInfo.shapeInfo.texShape;
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col', 'depth'];
        return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
    }
    if (texNumC === stride0) {
        return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sampleTexture(" + texName + ", uv);\n        }\n      ";
    }
    if (texNumC === stride1) {
        return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
    }
    return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sampleTexture(" + texName + ", uv);\n      }\n  ";
}
function getSampler4D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride2) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getSampler5D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride3 = shape[4];
    var stride2 = shape[3] * stride3;
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2', 'depth3'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " +\n                   depth2 * " + stride3 + " + depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride3) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " +\n                   depth * " + shape[3] + " + depth2;\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n      vec2 uv = UVfrom5D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", " + stride3 + ", row, col, depth, depth2, depth3);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getSamplerFlat(inputInfo) {
    var texName = inputInfo.name;
    var texShape = inputInfo.shapeInfo.texShape;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        return sampleTexture(" + texName + ", halfCR);\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sampleTexture(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var type = 'int';
    if (outRank === 2) {
        type = 'ivec2';
    }
    else if (outRank === 3) {
        type = 'ivec3';
    }
    else if (outRank === 4) {
        type = 'ivec4';
    }
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var rankDiff = outRank - inRank;
    var coordsSnippet;
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(function (d) { return "coords[" + (d + rankDiff) + "] = 0;"; }).join('\n');
    }
    var unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map(function (s, i) { return "coords[" + (i + rankDiff) + "]"; })
            .join(', ');
    }
    return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
    var inTexShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
    if (doBroadcast && !broadcastOverOuter) {
        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
    }
    var outTexShape = outShapeInfo.texShape;
    if (util.arraysEqual(inTexShape, outTexShape)) {
        return "\n      float " + funcName + "() {\n        return sampleTexture(" + texName + ", resultUV);\n      }\n    ";
    }
    var inSize = util.sizeFromShape(inTexShape);
    var broadcastSnippet = '';
    if (doBroadcast && broadcastOverOuter) {
        broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
    }
    return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexShape[1] + ";\n      int texC = index - texR * " + inTexShape[1] + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      return sampleTexture(" + texName + ", uv);\n    }\n  ";
}
function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else if (rank === 5) {
        return 'ivec5';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;
function squeezeInputInfo(inInfo, squeezedShape) {
    var newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}

},{"../../environment":48,"../../ops/broadcast_util":107,"../../util":155,"./tex_util":97}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var SliceProgram = (function () {
    function SliceProgram(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getCoords(this.rank);
        this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
    }
    SliceProgram.prototype.getCustomSetupFunc = function (start) {
        var _this = this;
        if (start.length !== this.rank) {
            throw Error("The rank (" + this.rank + ") of the program must match the " +
                ("length of start (" + start.length + ")"));
        }
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (_this.startLoc == null) {
                    return;
                }
            }
            if (_this.rank === 1) {
                gpgpu.gl.uniform1i(_this.startLoc, start[0]);
            }
            else if (_this.rank === 2) {
                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
            }
            else if (_this.rank === 3) {
                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
            }
            else if (_this.rank === 4) {
                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
            }
            else {
                throw Error("Slicing for rank " + _this.rank + " is not yet supported");
            }
        };
    };
    return SliceProgram;
}());
exports.SliceProgram = SliceProgram;
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank === 2) {
        return 'sourceLoc.x, sourceLoc.y';
    }
    else if (rank === 3) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
    }
    else if (rank === 4) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
    }
    else {
        throw Error("Slicing for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":94}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var StridedSliceProgram = (function () {
    function StridedSliceProgram(begin, strides, shape) {
        this.variableNames = ['x'];
        this.outputShape = shape;
        this.rank = shape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var newCoords = '';
        if (this.rank === 1) {
            newCoords = 'coords * strides + begin';
        }
        else {
            newCoords =
                shape.map(function (_, i) { return "coords[" + i + "] * strides[" + i + "] + begin[" + i + "]"; })
                    .join(',');
        }
        this.userCode = "\n      " + dtype + " begin = " + dtype + "(" + begin + ");\n      " + dtype + " strides = " + dtype + "(" + strides + ");\n\n      void main() {\n        " + dtype + " coords = getOutputCoords();\n        setOutput(getX(" + newCoords + "));\n      }\n    ";
    }
    return StridedSliceProgram;
}());
exports.StridedSliceProgram = StridedSliceProgram;

},{"./shader_compiler":94}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureType;
(function (TextureType) {
    TextureType[TextureType["FLOAT"] = 0] = "FLOAT";
    TextureType[TextureType["UNSIGNED_BYTE"] = 1] = "UNSIGNED_BYTE";
})(TextureType = exports.TextureType || (exports.TextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
            ("" + channelsPerTexture));
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
            ("" + requiredSize));
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
exports.FLOAT_MAX = 20000;
exports.FLOAT_MIN = -exports.FLOAT_MAX;
var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
var FLOAT_POWERS = [1, 255, 255 * 255];
exports.BYTE_NAN_VALUE = 0;
function encodeFloatArray(floatArray) {
    var uintArray = new Uint8Array(floatArray.length * 4);
    var _loop_1 = function (i) {
        var value = floatArray[i / 4];
        if (isNaN(value)) {
            uintArray[i] = exports.BYTE_NAN_VALUE;
            uintArray[i + 1] = exports.BYTE_NAN_VALUE;
            uintArray[i + 2] = exports.BYTE_NAN_VALUE;
            uintArray[i + 3] = exports.BYTE_NAN_VALUE;
            return "continue";
        }
        var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
        var enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });
        var buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });
        uintArray[i] = Math.floor(normalizedValue);
        uintArray[i + 1] = buckets[0];
        uintArray[i + 2] = buckets[1];
        uintArray[i + 3] = buckets[2];
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_1(i);
    }
    return uintArray;
}
exports.encodeFloatArray = encodeFloatArray;
function decodeToFloatArray(uintArray) {
    var floatArray = new Float32Array(uintArray.length / 4);
    var _loop_2 = function (i) {
        if (uintArray[i] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
            floatArray[i / 4] = NaN;
            return "continue";
        }
        var dot = 0;
        FLOAT_DELTAS.forEach(function (delta, j) {
            dot += delta * uintArray[i + j];
        });
        var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
        floatArray[i / 4] = value;
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_2(i);
    }
    return floatArray;
}
exports.decodeToFloatArray = decodeToFloatArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    var requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += 4) {
        for (var c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tex_util_1 = require("./tex_util");
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextures = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC, texType) {
        if (texType === void 0) { texType = tex_util_1.TextureType.FLOAT; }
        var shapeKey = getKeyFromTextureShape(shapeRC, texType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextures)) {
            this.usedTextures[shapeKey] = [];
        }
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            var newTexture_1 = this.freeTextures[shapeKey].shift();
            this.usedTextures[shapeKey].push(newTexture_1);
            return newTexture_1;
        }
        this.numUsedTextures++;
        this.log();
        var newTexture = this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
        this.usedTextures[shapeKey].push(newTexture);
        return newTexture;
    };
    TextureManager.prototype.releaseTexture = function (texture, shape, texType) {
        if (texType === void 0) { texType = tex_util_1.TextureType.FLOAT; }
        var shapeKey = getKeyFromTextureShape(shape, texType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        var texList = this.usedTextures[shapeKey];
        var texIndex = texList.indexOf(texture);
        if (texIndex < 0) {
            throw new Error('Cannot release a texture that was never provided by this ' +
                'texture manager');
        }
        texList.splice(texIndex, 1);
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        var _this = this;
        if (this.freeTextures == null) {
            return;
        }
        for (var texShape in this.freeTextures) {
            this.freeTextures[texShape].forEach(function (tex) {
                _this.gpgpu.deleteMatrixTexture(tex);
            });
        }
        for (var texShape in this.usedTextures) {
            this.usedTextures[texShape].forEach(function (tex) {
                _this.gpgpu.deleteMatrixTexture(tex);
            });
        }
        this.freeTextures = null;
        this.usedTextures = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol, texType) {
    return shapeRowsCol[0] + "_" + shapeRowsCol[1] + "_" + texType;
}

},{"./tex_util":97}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TileProgram = (function () {
    function TileProgram(aShape, reps) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return TileProgram;
}());
exports.TileProgram = TileProgram;
function getSourceCoords(aShape) {
    var rank = aShape.length;
    if (rank > 5) {
        throw Error("Tile for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "imod(resRC, " + aShape[0] + ")";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
    }
    return sourceCoords.join();
}

},{"./shader_compiler":94}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TransposeProgram = (function () {
    function TransposeProgram(aShape, newDim) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var switched = getSwitchedCoords(newDim);
        this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
    }
    return TransposeProgram;
}());
exports.TransposeProgram = TransposeProgram;
function getSwitchedCoords(newDim) {
    var rank = newDim.length;
    if (rank > 5) {
        throw Error("Transpose for rank " + rank + " is not yet supported");
    }
    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];
    var switchedCoords = new Array(rank);
    for (var i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}

},{"./shader_compiler":94}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var erf_util = require("../../ops/erf_util");
var selu_util = require("../../ops/selu_util");
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
var CHECK_NAN_SNIPPET = "if (isNaN(x)) return x;";
exports.ABS = "return abs(x);";
exports.RELU = CHECK_NAN_SNIPPET + "\n  return (x < 0.0) ? 0.0 : x;\n";
exports.ELU = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
exports.SELU = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + selu_util.SELU_SCALEALPHA + ";\n  float scale = " + selu_util.SELU_SCALE + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
function STEP(alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    return CHECK_NAN_SNIPPET + ("\n    return x > 0.0 ? 1.0 : float(" + alpha + ");\n  ");
}
exports.STEP = STEP;
exports.NEG = "return -x;";
exports.CEIL = "return ceil(x);";
exports.FLOOR = "return floor(x);";
exports.SIGN = "\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n";
exports.ROUND = "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n";
exports.EXP = "return exp(x);";
exports.EXPM1 = "return exp(x) - 1.0;";
exports.LOG = "return log(x);";
exports.LOG1P = "return log(1.0 + x);";
exports.SQRT = "return sqrt(x);";
exports.RSQRT = "return inversesqrt(x);";
exports.SIGMOID = "return 1.0 / (1.0 + exp(-1.0 * x));";
exports.SOFTPLUS = "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n";
exports.SIN = "return sin(x);";
exports.COS = "return cos(x);";
exports.TAN = "return tan(x);";
exports.ASIN = "return asin(x);";
exports.ACOS = "return acos(x);";
exports.ATAN = CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
exports.ASINH = "return log(x + sqrt(x * x + 1.0));";
exports.ACOSH = "return log(x + sqrt(x * x - 1.0));";
exports.ATANH = "return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
exports.ERF = "\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = " + erf_util.ERF_P + ";\n  float a1 = " + erf_util.ERF_A1 + ";\n  float a2 = " + erf_util.ERF_A2 + ";\n  float a3 = " + erf_util.ERF_A3 + ";\n  float a4 = " + erf_util.ERF_A4 + ";\n  float a5 = " + erf_util.ERF_A5 + ";\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n";
exports.SQUARE = "return x * x;";
exports.RECIPROCAL = "return 1.0 / x;";
exports.LOGICAL_NOT = "return float(!(x >= 1.0));";
exports.TO_INT = "return float(int(x));";

},{"../../ops/erf_util":113,"../../ops/selu_util":130}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MAX_TEXTURE_SIZE = null;
var util = require("../../util");
var environment_1 = require("../../environment");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
    if (webglVersion === 2) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else if (webglVersion === 1) {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (webglVersion === 0 || gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return "Unknown error code " + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log("Couldn't parse line number in error: " + shaderInfoLog);
        console.log(shaderSource);
        return;
    }
    var lineNumber = +lineNumberRegexResult[1];
    var shaderLines = shaderSource.split('\n');
    var pad = shaderLines.length.toString().length + 2;
    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
        return util.rightPad((lineNumber + 1).toString(), pad) + line;
    });
    var maxLineLength = 0;
    for (var i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return 4;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = "[" + width + "x" + height + "]";
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = "[" + width + "x" + height + "]";
        var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    var loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
        return false;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
    return true;
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function getProgramUniformLocation(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
}
exports.getProgramUniformLocation = getProgramUniformLocation;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return "unknown error " + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
        throw new Error("textureUnit must be in " + textureUnitRange + ".");
    }
}
function getTextureShapeFromLogicalShape(gl, logShape) {
    if (logShape.length !== 2) {
        var squeezeResult = util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../environment":48,"../../util":155}],103:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var tensor_1 = require("../tensor");
var tensor_util = require("../tensor_util");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var concat_1 = require("./concat");
var operation_1 = require("./operation");
var rand_1 = require("./rand");
var reduction_ops_1 = require("./reduction_ops");
var ArrayOps = (function () {
    function ArrayOps() {
    }
    ArrayOps.tensor = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (shape != null && inferredShape.length !== 1) {
            util.assertShapesMatch(shape, inferredShape, "Error creating a new Tensor. " +
                ("Inferred shape (" + inferredShape + ") does not match the ") +
                ("provided shape (" + shape + "). "));
        }
        if (!util.isTypedArray(values) && !Array.isArray(values)) {
            values = [values];
        }
        shape = shape || inferredShape;
        return tensor_1.Tensor.make(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    ArrayOps.scalar = function (value, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (util.isTypedArray(value) || Array.isArray(value)) {
            throw new Error('Error creating a new Scalar: value must be a primitive ' +
                '(number|boolean)');
        }
        return ArrayOps.tensor(value, [], dtype);
    };
    ArrayOps.tensor1d = function (values, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 1) {
            throw new Error('tensor1d() requires values to be a flat/TypedArray');
        }
        return ArrayOps.tensor(values, inferredShape, dtype);
    };
    ArrayOps.tensor2d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (shape != null && shape.length !== 2) {
            throw new Error('tensor2d() requires shape to have two numbers');
        }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 2 && inferredShape.length !== 1) {
            throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');
        }
        if (inferredShape.length === 1 && shape == null) {
            throw new Error('tensor2d() requires shape to be provided when `values` ' +
                'are a flat/TypedArray');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.tensor3d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (shape != null && shape.length !== 3) {
            throw new Error('tensor3d() requires shape to have three numbers');
        }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 3 && inferredShape.length !== 1) {
            throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray');
        }
        if (inferredShape.length === 1 && shape == null) {
            throw new Error('tensor3d() requires shape to be provided when `values` ' +
                'are a flat array');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.tensor4d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (shape != null && shape.length !== 4) {
            throw new Error('tensor4d() requires shape to have four numbers');
        }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 4 && inferredShape.length !== 1) {
            throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray');
        }
        if (inferredShape.length === 1 && shape == null) {
            throw new Error('tensor4d() requires shape to be provided when `values` ' +
                'are a flat array');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.tensor5d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (shape != null && shape.length !== 5) {
            throw new Error('tensor5d() requires shape to have five numbers');
        }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 5 && inferredShape.length !== 1) {
            throw new Error('tensor5d() requires values to be \
           number[][][][][] or flat/TypedArray');
        }
        if (inferredShape.length === 1 && shape == null) {
            throw new Error('tensor5d() requires shape to be provided when `values` ' +
                'are a flat array');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.ones = function (shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = makeOnesTypedArray(util.sizeFromShape(shape), dtype);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.zeros = function (shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.fill = function (shape, value, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = util.getTypedArrayFromDType(dtype, util.sizeFromShape(shape));
        values.fill(value);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.onesLike = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'onesLike');
        return ArrayOps.ones(x.shape, x.dtype);
    };
    ArrayOps.zerosLike = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'zerosLike');
        return ArrayOps.zeros(x.shape, x.dtype);
    };
    ArrayOps.clone = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'clone');
        var der = function (dy) {
            return { x: function () { return dy.toFloat(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) {
            return tensor_1.Tensor.make(x.shape, { dataId: x.dataId }, x.dtype);
        }, { x: x }, der);
    };
    ArrayOps.eye = function (numRows, numColumns, batchShape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (numColumns == null) {
            numColumns = numRows;
        }
        var buffer = ArrayOps.buffer([numRows, numColumns], dtype);
        var n = numRows <= numColumns ? numRows : numColumns;
        for (var i = 0; i < n; ++i) {
            buffer.set(1, i, i);
        }
        var out = buffer.toTensor().as2D(numRows, numColumns);
        if (batchShape == null) {
            return out;
        }
        else {
            if (batchShape.length === 1) {
                return ArrayOps.tile(ArrayOps.expandDims(out, 0), [batchShape[0], 1, 1]);
            }
            else if (batchShape.length === 2) {
                return ArrayOps.tile(ArrayOps.expandDims(ArrayOps.expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
            }
            else {
                throw new Error("eye() currently supports only 1D and 2D " +
                    ("batchShapes, but received " + batchShape.length + "D."));
            }
        }
    };
    ArrayOps.randomNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        if (dtype != null && dtype === 'bool') {
            throw new Error("Unsupported data type " + dtype);
        }
        var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
        var res = ArrayOps.buffer(shape, dtype);
        for (var i = 0; i < res.values.length; i++) {
            res.values[i] = randGauss.nextValue();
        }
        return res.toTensor();
    };
    ArrayOps.truncatedNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        if (dtype != null && dtype === 'bool') {
            throw new Error("Unsupported data type " + dtype);
        }
        var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
        var res = ArrayOps.buffer(shape, dtype);
        for (var i = 0; i < res.values.length; i++) {
            res.values[i] = randGauss.nextValue();
        }
        return res.toTensor();
    };
    ArrayOps.randomUniform = function (shape, minval, maxval, dtype) {
        if (minval === void 0) { minval = 0; }
        if (maxval === void 0) { maxval = 1; }
        if (dtype === void 0) { dtype = 'float32'; }
        var res = ArrayOps.buffer(shape, dtype);
        for (var i = 0; i < res.values.length; i++) {
            res.values[i] = util.randUniform(minval, maxval);
        }
        return res.toTensor();
    };
    ArrayOps.rand = function (shape, randFunction, dtype) {
        var size = util.sizeFromShape(shape);
        var values = null;
        if (dtype == null || dtype === 'float32') {
            values = new Float32Array(size);
        }
        else if (dtype === 'int32') {
            values = new Int32Array(size);
        }
        else if (dtype === 'bool') {
            values = new Uint8Array(size);
        }
        else {
            throw new Error("Unknown data type " + dtype);
        }
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.multinomial = function (logits, numSamples, seed, normalized) {
        if (normalized === void 0) { normalized = false; }
        util.assertArgumentsAreTensors({ logits: logits }, 'multinomial');
        var numOutcomes = logits.size;
        var origRank = logits.rank;
        if (numOutcomes < 2) {
            throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
                (numOutcomes + "."));
        }
        if (origRank > 2) {
            throw new Error("Rank of probabilities must be 1 or 2, but is " + origRank);
        }
        seed = seed || Math.random();
        var logits2D = origRank === 1 ? logits.as2D(1, -1) : logits;
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.multinomial(logits2D, normalized, numSamples, seed); }, { logits2D: logits2D });
        return origRank === 1 ? res.as1D() : res;
    };
    ArrayOps.oneHot = function (indices, depth, onValue, offValue) {
        if (onValue === void 0) { onValue = 1; }
        if (offValue === void 0) { offValue = 0; }
        util.assert(indices.dtype === 'int32', 'Indices must be of dtype `int32`');
        if (depth < 2) {
            throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.oneHot(indices, depth, onValue, offValue); }, { indices: indices });
    };
    ArrayOps.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        if (numChannels > 4) {
            throw new Error('Cannot construct Tensor with more than 4 channels from pixels.');
        }
        return environment_1.ENV.engine.fromPixels(pixels, numChannels);
    };
    ArrayOps.toPixels = function (img, canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, height, width, depth, minTensor, maxTensor, min, max, data, multiplier, bytes, i, r, g, b, a, j, ctx, imageData;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        util.assertArgumentsAreTensors({ img: img }, 'toPixels');
                        if (img.rank !== 2 && img.rank !== 3) {
                            throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + img.rank + ".");
                        }
                        _a = img.shape.slice(0, 2), height = _a[0], width = _a[1];
                        depth = img.rank === 2 ? 1 : img.shape[2];
                        if (depth > 4 || depth === 2) {
                            throw new Error("toPixels only supports depth of size " +
                                ("1, 3 or 4 but got " + depth));
                        }
                        minTensor = img.min();
                        maxTensor = img.max();
                        return [4, minTensor.data()];
                    case 1:
                        min = (_b.sent())[0];
                        return [4, maxTensor.data()];
                    case 2:
                        max = (_b.sent())[0];
                        minTensor.dispose();
                        maxTensor.dispose();
                        if (img.dtype === 'float32') {
                            if (min < 0 || max > 1) {
                                throw new Error("Tensor values for a float32 Tensor must be in the " +
                                    ("range [0 - 1] but got range [" + min + " - " + max + "]."));
                            }
                        }
                        else if (img.dtype === 'int32') {
                            if (min < 0 || max > 255) {
                                throw new Error("Tensor values for a int32 Tensor must be in the " +
                                    ("range [0 - 255] but got range [" + min + " - " + max + "]."));
                            }
                        }
                        else {
                            throw new Error("Unsupported type for toPixels: " + img.dtype + "." +
                                " Please use float32 or int32 tensors.");
                        }
                        return [4, img.data()];
                    case 3:
                        data = _b.sent();
                        multiplier = img.dtype === 'float32' ? 255 : 1;
                        bytes = new Uint8ClampedArray(width * height * 4);
                        for (i = 0; i < height * width; ++i) {
                            r = void 0, g = void 0, b = void 0, a = void 0;
                            if (depth === 1) {
                                r = data[i] * multiplier;
                                g = data[i] * multiplier;
                                b = data[i] * multiplier;
                                a = 255;
                            }
                            else if (depth === 3) {
                                r = data[i * 3] * multiplier;
                                g = data[i * 3 + 1] * multiplier;
                                b = data[i * 3 + 2] * multiplier;
                                a = 255;
                            }
                            else if (depth === 4) {
                                r = data[i * 4] * multiplier;
                                g = data[i * 4 + 1] * multiplier;
                                b = data[i * 4 + 2] * multiplier;
                                a = data[i * 4 + 3] * multiplier;
                            }
                            j = i * 4;
                            bytes[j + 0] = Math.round(r);
                            bytes[j + 1] = Math.round(g);
                            bytes[j + 2] = Math.round(b);
                            bytes[j + 3] = Math.round(a);
                        }
                        if (canvas != null) {
                            canvas.width = width;
                            canvas.height = height;
                            ctx = canvas.getContext('2d');
                            imageData = new ImageData(bytes, width, height);
                            ctx.putImageData(imageData, 0, 0);
                        }
                        return [2, bytes];
                }
            });
        });
    };
    ArrayOps.reshape = function (x, shape) {
        util.assertArgumentsAreTensors({ x: x }, 'reshape');
        shape = util.inferFromImplicitShape(shape, x.size);
        util.assert(x.size === util.sizeFromShape(shape), 'new shape and old shape must have the same number of elements.');
        var grad = function (dy) {
            return { x: function () { return dy.reshape(x.shape); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.reshape(x, shape); }, { x: x }, grad);
    };
    ArrayOps.squeeze = function (x, axis) {
        util.assertArgumentsAreTensors({ x: x }, 'squeeze');
        return ArrayOps.reshape(x, util.squeezeShape(x.shape, axis).newShape);
    };
    ArrayOps.cast = function (x, dtype) {
        util.assertArgumentsAreTensors({ x: x }, 'cast');
        var grad = function (dy) {
            return { x: function () { return dy.clone(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cast(x, dtype); }, { x: x }, grad);
    };
    ArrayOps.tile = function (x, reps) {
        util.assertArgumentsAreTensors({ x: x }, 'tile');
        util.assert(x.rank === reps.length, "Error in transpose: rank of input " + x.rank + " " +
            ("must match length of reps " + reps + "."));
        var grad = function (dy) {
            var derX = function () {
                var xGrad = ArrayOps.zerosLike(x);
                if (x.rank === 1) {
                    for (var i = 0; i < reps[0]; ++i) {
                        xGrad = xGrad.add(dy.slice([i * x.shape[0]], [x.shape[0]]));
                    }
                }
                else if (x.rank === 2) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1]], [x.shape[0], x.shape[1]]));
                        }
                    }
                }
                else if (x.rank === 3) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            for (var k = 0; k < reps[2]; ++k) {
                                xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));
                            }
                        }
                    }
                }
                else if (x.rank === 4) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            for (var k = 0; k < reps[2]; ++k) {
                                for (var l = 0; l < reps[3]; ++l) {
                                    xGrad = xGrad.add(dy.slice([
                                        i * x.shape[0], j * x.shape[1], k * x.shape[2],
                                        l * x.shape[3]
                                    ], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));
                                }
                            }
                        }
                    }
                }
                else {
                    throw new Error("Gradient for tile operation is not implemented for rank-" +
                        (x.rank + " tensors yet."));
                }
                return xGrad;
            };
            return { x: derX };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.tile(x, reps); }, { x: x }, grad);
    };
    ArrayOps.gather = function (x, indices, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x, indices: indices }, 'gather');
        util.assert(indices.dtype === 'int32', 'Indices must be of dtype `int32`');
        axis = axis_util_1.parseAxisParam(axis, x.shape)[0];
        var grad = function (dy) {
            var derX = function () {
                return reduction_ops_1.ReductionOps.unsortedSegmentSum(dy, indices, x.shape[axis], axis);
            };
            return { x: derX };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.gather(x, indices, axis); }, { x: x }, grad);
    };
    ArrayOps.pad1d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 2, 'Invalid number of paddings. Must be length of 2.');
        return ArrayOps.pad(x, [paddings], constantValue);
    };
    ArrayOps.pad2d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 2 && paddings[0].length === 2 &&
            paddings[1].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad3d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 3 && paddings[0].length === 2 &&
            paddings[1].length === 2 && paddings[2].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad4d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 4 && paddings[0].length === 2 &&
            paddings[1].length === 2 && paddings[2].length === 2 &&
            paddings[3].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'pad');
        if (x.rank === 0) {
            throw new Error('pad(scalar) is not defined. Pass non-scalar to pad');
        }
        var begin = paddings.map(function (p) { return p[0]; });
        var grad = function (dy) {
            return { x: function () { return dy.slice(begin, x.shape); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.pad(x, paddings, constantValue); }, { x: x }, grad);
    };
    ArrayOps.stack = function (tensors, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ tensors: tensors }, 'stack');
        util.assert(tensors.length >= 1, 'Pass at least one tensor to tf.stack');
        if (tensors.length === 1) {
            return tensors[0].expandDims(axis);
        }
        var rank = tensors[0].rank;
        var shape = tensors[0].shape;
        var dtype = tensors[0].dtype;
        util.assert(axis <= rank, 'Axis must be <= rank of the tensor');
        tensors.forEach(function (t) {
            util.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');
        });
        tensors.forEach(function (t) {
            util.assert(dtype === t.dtype, 'All tensors passed to stack must have matching dtypes');
        });
        var expandedTensors = tensors.map(function (t) { return t.expandDims(axis); });
        return concat_1.ConcatOps.concat(expandedTensors, axis);
    };
    ArrayOps.unstack = function (value, axis) {
        if (axis === void 0) { axis = 0; }
        var num = value.shape[axis];
        var outputShape = Array(value.rank - 1).fill(0);
        var outIndex = 0;
        for (var i = 0; i < value.rank; i++) {
            if (i !== axis) {
                outputShape[outIndex] = value.shape[i];
                outIndex++;
            }
        }
        var splitSizes;
        splitSizes = Array(num).fill(1);
        var begin = Array(value.rank).fill(0);
        var size = value.shape.slice();
        return splitSizes.map(function (s) {
            size[axis] = s;
            var slice = value.slice(begin, size);
            begin[axis] += s;
            return slice.reshape(outputShape);
        });
    };
    ArrayOps.split = function (x, numOrSizeSplits, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'split');
        axis = axis_util_1.parseAxisParam(axis, x.shape)[0];
        var splitSizes;
        if (typeof (numOrSizeSplits) === 'number') {
            util.assert(x.shape[axis] % numOrSizeSplits === 0, 'Number of splits must evenly divide the axis.');
            splitSizes = Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
        }
        else {
            util.assert(x.shape[axis] === numOrSizeSplits.reduce(function (a, b) { return a + b; }), 'The sum of sizes must match the size of the axis dimension.');
            splitSizes = numOrSizeSplits;
        }
        var begin = Array(x.rank).fill(0);
        var size = x.shape.slice();
        return splitSizes.map(function (s) {
            size[axis] = s;
            var slice = x.slice(begin, size);
            begin[axis] += s;
            return slice;
        });
    };
    ArrayOps.cumsum = function (x, axis, exclusive, reverse) {
        if (axis === void 0) { axis = 0; }
        if (exclusive === void 0) { exclusive = false; }
        if (reverse === void 0) { reverse = false; }
        util.assertArgumentsAreTensors({ x: x }, 'cumsum');
        axis = axis | 0;
        var permutation = axis_util_1.getAxesPermutation([axis], x.rank);
        var permutedX = x;
        if (permutation != null) {
            permutedX = x.transpose(permutation);
        }
        var permutedAxis = axis_util_1.getInnerMostAxes(1, x.rank)[0];
        var grad = function (dy) {
            return { permutedX: function () { return dy.cumsum(axis, exclusive, !reverse); } };
        };
        var value = environment_1.ENV.engine.runKernel(function (backend) { return backend.cumsum(permutedX, permutedAxis, exclusive, reverse); }, { permutedX: permutedX }, grad);
        if (permutation != null) {
            value = value.transpose(permutation);
        }
        return value;
    };
    ArrayOps.expandDims = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'expandDims');
        util.assert(axis <= x.rank, 'Axis must be <= rank of the tensor');
        var newShape = x.shape.slice();
        newShape.splice(axis, 0, 1);
        return ArrayOps.reshape(x, newShape);
    };
    ArrayOps.linspace = function (start, stop, num) {
        if (num === 0) {
            throw new Error('Cannot request zero samples');
        }
        var step = (stop - start) / (num - 1);
        var values = makeZerosTypedArray(num, 'float32');
        values[0] = start;
        for (var i = 1; i < values.length; i++) {
            values[i] = values[i - 1] + step;
        }
        return ArrayOps.tensor1d(values, 'float32');
    };
    ArrayOps.range = function (start, stop, step, dtype) {
        if (step === void 0) { step = 1; }
        if (dtype === void 0) { dtype = 'float32'; }
        if (step === 0) {
            throw new Error('Cannot have a step of zero');
        }
        var sameStartStop = start === stop;
        var increasingRangeNegativeStep = start < stop && step < 0;
        var decreasingRangePositiveStep = stop < start && step > 1;
        if (sameStartStop || increasingRangeNegativeStep ||
            decreasingRangePositiveStep) {
            return ArrayOps.zeros([0], dtype);
        }
        var numElements = Math.abs(Math.ceil((stop - start) / step));
        var values = makeZerosTypedArray(numElements, dtype);
        if (stop < start && step === 1) {
            step = -1;
        }
        values[0] = start;
        for (var i = 1; i < values.length; i++) {
            values[i] = values[i - 1] + step;
        }
        return ArrayOps.tensor1d(values, dtype);
    };
    ArrayOps.buffer = function (shape, dtype, values) {
        if (dtype === void 0) { dtype = 'float32'; }
        return new tensor_1.TensorBuffer(shape, dtype, values);
    };
    ArrayOps.print = function (x, verbose) {
        if (verbose === void 0) { verbose = false; }
        console.log(tensor_util.tensorToString(x, verbose));
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "scalar", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor1d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor2d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor3d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor4d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor5d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "ones", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "zeros", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "fill", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "onesLike", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "zerosLike", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "clone", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "eye", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "randomNormal", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "truncatedNormal", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "randomUniform", null);
    __decorate([
        operation_1.operation
    ], ArrayOps, "rand", null);
    __decorate([
        operation_1.operation
    ], ArrayOps, "multinomial", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "oneHot", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "fromPixels", null);
    __decorate([
        doc_1.doc({ heading: 'Visualization' })
    ], ArrayOps, "toPixels", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "reshape", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' })
    ], ArrayOps, "squeeze", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "cast", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "tile", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "gather", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "pad", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "stack", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "unstack", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "split", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Scan' })
    ], ArrayOps, "cumsum", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "expandDims", null);
    __decorate([
        operation_1.operation,
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "linspace", null);
    __decorate([
        operation_1.operation,
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "range", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "buffer", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "print", null);
    return ArrayOps;
}());
exports.ArrayOps = ArrayOps;
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type $ {dtype}");
    }
}
function makeOnesTypedArray(size, dtype) {
    var array = makeZerosTypedArray(size, dtype);
    for (var i = 0; i < array.length; i++) {
        array[i] = 1;
    }
    return array;
}
function toTypedArray(a, dtype) {
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (Array.isArray(a)) {
        a = util.flatten(a);
    }
    return util.copyTypedArray(a, dtype);
}
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}

},{"../doc":46,"../environment":48,"../tensor":149,"../tensor_util":150,"../util":155,"./axis_util":104,"./concat":109,"./operation":123,"./rand":126,"./reduction_ops":128}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function axesAreInnerMostDims(axes, rank) {
    for (var i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
        }
    }
    return true;
}
exports.axesAreInnerMostDims = axesAreInnerMostDims;
function combineLocations(outputLoc, reduceLoc, axes) {
    var rank = outputLoc.length + reduceLoc.length;
    var loc = [];
    var outIdx = 0;
    var reduceIdx = 0;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
exports.combineLocations = combineLocations;
function computeOutAndReduceShapes(aShape, axes) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            outShape.push(aShape[dim]);
        }
    }
    var reduceShape = axes.map(function (dim) { return aShape[dim]; });
    return [outShape, reduceShape];
}
exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
function expandShapeToKeepDim(shape, axes) {
    var reduceSubShape = axes.map(function (x) { return 1; });
    return combineLocations(shape, reduceSubShape, axes);
}
exports.expandShapeToKeepDim = expandShapeToKeepDim;
function parseAxisParam(axis, shape) {
    var rank = shape.length;
    axis = axis == null ? shape.map(function (s, i) { return i; }) : [].concat(axis);
    util.assert(axis.every(function (ax) { return ax >= -rank && ax < rank; }), "All values in axis param must be in range [-" + rank + ", " + rank + ") but " +
        ("got axis " + axis));
    util.assert(axis.every(function (ax) { return util.isInt(ax); }), "All values in axis param must be integers but " +
        ("got axis " + axis));
    return axis.map(function (a) { return a < 0 ? rank + a : a; });
}
exports.parseAxisParam = parseAxisParam;
function assertAxesAreInnerMostDims(msg, axes, rank) {
    util.assert(axesAreInnerMostDims(axes, rank), msg + " supports only inner-most axes for now. " +
        ("Got axes " + axes + " and rank-" + rank + " input."));
}
exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
function getAxesPermutation(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
        return null;
    }
    var result = [];
    for (var i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
            result.push(i);
        }
    }
    axes.forEach(function (axis) { return result.push(axis); });
    return result;
}
exports.getAxesPermutation = getAxesPermutation;
function getUndoAxesPermutation(axes) {
    return axes.map(function (axis, i) { return [i, axis]; })
        .sort(function (a, b) { return a[1] - b[1]; })
        .map(function (x) { return x[0]; });
}
exports.getUndoAxesPermutation = getUndoAxesPermutation;
function getInnerMostAxes(numAxes, rank) {
    var res = [];
    for (var i = rank - numAxes; i < rank; ++i) {
        res.push(i);
    }
    return res;
}
exports.getInnerMostAxes = getInnerMostAxes;

},{"../util":155}],105:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var array_ops_1 = require("./array_ops");
var broadcast_util_1 = require("./broadcast_util");
var operation_1 = require("./operation");
var ops_1 = require("./ops");
var BatchNormOps = (function () {
    function BatchNormOps() {
    }
    BatchNormOps.batchNormalization2d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization3d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization4d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 4, "Error in batchNormalization4D: x must be rank 4 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 4 || mean.rank === 1, "Error in batchNormalization4D: mean must be rank 4 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 4 || variance.rank === 1, "Error in batchNormalization4D: variance must be rank 4 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 4 || scale.rank === 1, "Error in batchNormalization4D: scale must be rank 4 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 4 || offset.rank === 1, "Error in batchNormalization4D: offset must be rank 4 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assertArgumentsAreTensors({ x: x, mean: mean, variance: variance }, 'batchNormalization');
        if (scale != null) {
            util.assertArgumentsAreTensors({ scale: scale }, 'batchNormalization');
        }
        if (offset != null) {
            util.assertArgumentsAreTensors({ offset: offset }, 'batchNormalization');
        }
        util.assert(mean.rank === variance.rank, 'Batch normalization gradient requires mean and variance to have ' +
            'equal ranks.');
        util.assert(offset == null || mean.rank === offset.rank, 'Batch normalization gradient requires mean and offset to have ' +
            'equal ranks.');
        util.assert(scale == null || mean.rank === scale.rank, 'Batch normalization gradient requires mean and scale to have ' +
            'equal ranks.');
        var x4D;
        if (x.rank === 0 || x.rank === 1) {
            x4D = x.as4D(1, 1, 1, x.size);
        }
        else if (x.rank === 2) {
            x4D = x.as4D(1, 1, x.shape[0], x.shape[1]);
        }
        else if (x.rank === 3) {
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        else {
            x4D = x;
        }
        var der = function (dy) {
            var scaleValue = scale == null ? array_ops_1.ArrayOps.scalar(1) : scale;
            var reductionAxes = broadcast_util_1.getReductionAxes(mean.shape, x4D.shape);
            var tileShape = [];
            if (mean.rank === 1) {
                for (var i = 0; i < x4D.shape.length - 1; ++i) {
                    tileShape.push(x4D.shape[i]);
                }
                tileShape.push(1);
            }
            var xMinusMean = x.sub(mean);
            var dyTimesScaleValue = dy.mul(scaleValue);
            var oneOverSqrtVariance = ops_1.rsqrt(variance.add(array_ops_1.ArrayOps.scalar(varianceEpsilon)));
            var minusHalfRCube = oneOverSqrtVariance.mul(oneOverSqrtVariance)
                .mul(oneOverSqrtVariance)
                .mul(array_ops_1.ArrayOps.scalar(-0.5));
            var derX = function () {
                if (mean.rank === 1) {
                    return dy
                        .mul(array_ops_1.ArrayOps.tile(oneOverSqrtVariance.as4D(1, 1, 1, mean.shape[0]), tileShape))
                        .mul(scaleValue)
                        .reshape(x.shape);
                }
                else {
                    return dy.mul(oneOverSqrtVariance).mul(scaleValue).reshape(x.shape);
                }
            };
            var derMean = function () {
                var meanDer = oneOverSqrtVariance.mul(array_ops_1.ArrayOps.scalar(-1)).mul(dyTimesScaleValue);
                if (mean.rank === 1) {
                    meanDer = meanDer.sum(reductionAxes);
                }
                return meanDer.reshape(mean.shape);
            };
            var derVariance = function () {
                var varianceDer = minusHalfRCube.mul(xMinusMean).mul(dyTimesScaleValue);
                if (mean.rank === 1) {
                    varianceDer = varianceDer.sum(reductionAxes);
                }
                return varianceDer.reshape(mean.shape);
            };
            var derScale = function () {
                var xMinusMean2TimesRsqrt = xMinusMean.mul(oneOverSqrtVariance);
                var scaleDer = dy.mul(xMinusMean2TimesRsqrt);
                if (mean.rank === 1) {
                    scaleDer = scaleDer.sum(reductionAxes);
                }
                return scaleDer.reshape(mean.shape);
            };
            var derOffset = function () {
                var offsetDer = dy;
                if (mean.rank === 1) {
                    offsetDer = offsetDer.sum(reductionAxes);
                }
                return offsetDer.reshape(mean.shape);
            };
            return {
                x: derX,
                mean: derMean,
                variance: derVariance,
                scale: derScale,
                offset: derOffset
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.batchNormalization(x4D, batchnormReshape4D(mean), batchnormReshape4D(variance), varianceEpsilon, batchnormReshape4D(scale), batchnormReshape4D(offset)); }, { x: x, mean: mean, variance: variance, scale: scale, offset: offset }, der);
        return res.reshape(x.shape);
    };
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization2d", null);
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization3d", null);
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization4d", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' })
    ], BatchNormOps, "batchNormalization", null);
    return BatchNormOps;
}());
exports.BatchNormOps = BatchNormOps;
function batchnormReshape4D(x) {
    if (x == null) {
        return null;
    }
    if (x.rank === 0) {
        return x.as1D();
    }
    else if (x.rank === 1) {
        return x;
    }
    else if (x.rank === 2) {
        return x.as4D(1, 1, x.shape[0], x.shape[1]);
    }
    else if (x.rank === 3) {
        return x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
    }
    return x;
}

},{"../doc":46,"../environment":48,"../util":155,"./array_ops":103,"./broadcast_util":107,"./operation":123,"./ops":124}],106:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var types_1 = require("../types");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var ops_1 = require("./ops");
var BinaryOps = (function () {
    function BinaryOps() {
    }
    BinaryOps.add = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'add');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.add(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return a.add(b);
    };
    BinaryOps.sub = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'sub');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.neg().reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.subtract(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return a.sub(b);
    };
    BinaryOps.pow = function (base, exp) {
        util.assertArgumentsAreTensors({ base: base, exp: exp }, 'pow');
        var outShape = broadcast_util.assertAndGetBroadcastShape(base.shape, exp.shape);
        base = base.cast(types_1.upcastType(base.dtype, exp.dtype));
        exp = exp.cast(types_1.upcastType(base.dtype, exp.dtype));
        var grad = function (dy, saved) {
            var y = saved[0];
            var derBase = function () {
                var res = dy.mul(exp.toFloat().mul(y.div(base)));
                var reduceAxes = broadcast_util.getReductionAxes(base.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(base.shape);
            };
            var derExp = function () {
                var res = dy.mul(y.mul(base.log()).toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(exp.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(exp.shape);
            };
            return { base: derBase, exp: derExp };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.pow(base, exp)); }, { base: base, exp: exp }, grad);
    };
    BinaryOps.powStrict = function (base, exp) {
        util.assertShapesMatch(base.shape, exp.shape, 'Error in powStrict: ');
        return base.pow(exp);
    };
    BinaryOps.mul = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'mul');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy.mul(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(b.shape);
                }
                return res;
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.multiply(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.mulStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return a.mul(b);
    };
    BinaryOps.div = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'div');
        util.assertTypesMatch(a, b);
        var forwardFunc;
        if (a.dtype === 'int32' && b.dtype === 'int32') {
            return BinaryOps.floorDiv(a, b);
        }
        else {
            forwardFunc = function (backend) { return backend.realDivide(a, b); };
        }
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy.div(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes).reshape(b.shape);
                }
                var tmp = b.square();
                return res.div(tmp.toFloat()).neg();
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(forwardFunc, { a: a, b: b }, der);
    };
    BinaryOps.floorDiv = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'floorDiv');
        util.assertTypesMatch(a, b);
        var forwardFunc = function (backend) { return backend.floorDiv(a, b); };
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy.div(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes).reshape(b.shape);
                }
                var tmp = b.square();
                return res.div(tmp.toFloat()).neg();
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(forwardFunc, { a: a, b: b }, der);
    };
    BinaryOps.divStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return a.div(b);
    };
    BinaryOps.mod = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'mod');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return dy.sum(reduceAxes).reshape(a.shape);
                }
                return dy;
            };
            var derB = function () {
                var res = dy.mul(a.div(b).floor().neg());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(b.shape);
                }
                return res;
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.mod(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.modStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in modStrict: ');
        return a.mod(b);
    };
    BinaryOps.minimum = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'minimum');
        util.assertTypesMatch(a, b);
        if (a.dtype === 'bool') {
            a = a.toInt();
        }
        if (b.dtype === 'bool') {
            b = b.toInt();
        }
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () { return dy.mul(a.lessEqual(b).toFloat()); };
            var derB = function () { return dy.mul(a.greater(b).toFloat()); };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.minimum(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.minimumStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
        return a.minimum(b);
    };
    BinaryOps.maximum = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'maximum');
        util.assertTypesMatch(a, b);
        if (a.dtype === 'bool') {
            a = a.toInt();
        }
        if (b.dtype === 'bool') {
            b = b.toInt();
        }
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () { return dy.mul(a.greaterEqual(b).toFloat()); };
            var derB = function () { return dy.mul(a.less(b).toFloat()); };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.maximum(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.maximumStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
        return a.maximum(b);
    };
    BinaryOps.squaredDifference = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'squaredDifference');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var two = ops_1.scalar(2);
            var derA = function () { return dy.mul(a.sub(b).mul(two)); };
            var derB = function () { return dy.mul(b.sub(a).mul(two)); };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.squaredDifference(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.squaredDifferenceStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in squaredDifferenceStrict: ');
        return a.squaredDifference(b);
    };
    BinaryOps.atan2 = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'atan2');
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var d = BinaryOps.add(ops_1.square(a), ops_1.square(b));
                var res = dy.mul(b.div(d));
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var d = BinaryOps.add(ops_1.square(a), ops_1.square(b));
                var res = ops_1.neg(dy.mul(a.div(d)));
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atan2(a, b); }, { a: a, b: b }, der);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "add", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "addStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "sub", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "subStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "pow", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "powStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "mul", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "mulStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "div", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "floorDiv", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "divStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "mod", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "modStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "minimum", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "minimumStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "maximum", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "maximumStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "squaredDifference", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "squaredDifferenceStrict", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "atan2", null);
    return BinaryOps;
}());
exports.BinaryOps = BinaryOps;

},{"../doc":46,"../environment":48,"../types":154,"../util":155,"./broadcast_util":107,"./operation":123,"./ops":124}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getBroadcastDims(inShape, outShape) {
    var inRank = inShape.length;
    var dims = [];
    for (var i = 0; i < inRank; i++) {
        var dim = inRank - 1 - i;
        var a = inShape[dim] || 1;
        var b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
            dims.unshift(dim);
        }
    }
    return dims;
}
exports.getBroadcastDims = getBroadcastDims;
function getReductionAxes(inShape, outShape) {
    var result = [];
    for (var i = 0; i < outShape.length; i++) {
        var inDim = inShape[inShape.length - i - 1];
        var outAxis = outShape.length - i - 1;
        var outDim = outShape[outAxis];
        if (inDim == null || (inDim === 1 && outDim > 1)) {
            result.unshift(outAxis);
        }
    }
    return result;
}
exports.getReductionAxes = getReductionAxes;
function broadcastDimsAreOuter(dims) {
    for (var i = 0; i < dims.length; i++) {
        if (dims[i] !== i) {
            return false;
        }
    }
    return true;
}
exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
function assertAndGetBroadcastShape(shapeA, shapeB) {
    var result = [];
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ".");
    var l = Math.max(shapeA.length, shapeB.length);
    for (var i = 0; i < l; i++) {
        var a = shapeA[shapeA.length - i - 1] || 1;
        var b = shapeB[shapeB.length - i - 1] || 1;
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.unshift(Math.max(a, b));
    }
    return result;
}
exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;

},{}],108:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var CompareOps = (function () {
    function CompareOps() {
    }
    CompareOps.notEqual = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'notEqual');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.notEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.notEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in notEqualStrict: ');
        return a.notEqual(b);
    };
    CompareOps.less = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'less');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.less(a, b); }, { a: a, b: b });
    };
    CompareOps.lessStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in lessStrict: ');
        return a.less(b);
    };
    CompareOps.equal = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'equal');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.equal(a, b); }, { a: a, b: b });
    };
    CompareOps.equalStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in equalStrict: ');
        return a.equal(b);
    };
    CompareOps.lessEqual = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'lessEqual');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.lessEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.lessEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in lessEqualStrict: ');
        return a.lessEqual(b);
    };
    CompareOps.greater = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'greater');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.greater(a, b); }, { a: a, b: b });
    };
    CompareOps.greaterStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in greaterStrict: ');
        return a.greater(b);
    };
    CompareOps.greaterEqual = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'greaterEqual');
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.greaterEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.greaterEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in greaterEqualStrict: ');
        return a.greaterEqual(b);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "notEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "notEqualStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "less", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "lessStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "equal", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "equalStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "lessEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "lessEqualStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "greater", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "greaterStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "greaterEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "greaterEqualStrict", null);
    return CompareOps;
}());
exports.CompareOps = CompareOps;

},{"../doc":46,"../environment":48,"../util":155,"./broadcast_util":107,"./operation":123}],109:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var concat_util = require("./concat_util");
var operation_1 = require("./operation");
var ConcatOps = (function () {
    function ConcatOps() {
    }
    ConcatOps.concat1d = function (tensors) {
        return ConcatOps.concat(tensors, 0);
    };
    ConcatOps.concat2d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat3d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat4d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat = function (tensors, axis) {
        if (axis === void 0) { axis = 0; }
        util.assert(tensors.length >= 1, 'Pass at least one tensor to concat');
        util.assertArgumentsAreTensors({ tensors: tensors }, 'concat');
        var result = tensors[0];
        if (tensors.length === 1) {
            return result;
        }
        var axes = axis_util_1.parseAxisParam(axis, result.shape);
        for (var i = 1; i < tensors.length; ++i) {
            result = concat2Tensors(result, tensors[i], axes[0]);
        }
        return result;
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ConcatOps, "concat", null);
    return ConcatOps;
}());
exports.ConcatOps = ConcatOps;
function concat2Tensors(a, b, axis) {
    concat_util.assertParams(a.shape, b.shape, axis);
    var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
    var a2D = a.as2D(-1, util.sizeFromShape(a.shape.slice(axis)));
    var b2D = b.as2D(-1, util.sizeFromShape(b.shape.slice(axis)));
    var _a = concat_util.computeGradientSliceShapes(a2D.shape, b2D.shape), aBegin = _a.aBegin, aSize = _a.aSize, bBegin = _a.bBegin, bSize = _a.bSize;
    var der = function (dy) {
        return { a: function () { return dy.slice(aBegin, aSize); }, b: function () { return dy.slice(bBegin, bSize); } };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.concat(a2D, b2D); }, { a: a2D, b: b2D }, der);
    return res.reshape(outShape);
}

},{"../doc":46,"../environment":48,"../util":155,"./axis_util":104,"./concat_util":110,"./operation":123}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParams(aShape, bShape, axis) {
    var aRank = aShape.length;
    var bRank = bShape.length;
    util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " +
        "must be the same.");
    util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " +
        ("between 0 and " + (aRank - 1) + "."));
    for (var i = 0; i < aRank; i++) {
        util.assert((i === axis) || (aShape[i] === bShape[i]), "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " +
            ("(" + bShape + ") along the non-concatenated axis " + i + "."));
    }
}
exports.assertParams = assertParams;
function computeOutShape1D(x1Shape, x2Shape) {
    util.assert(x1Shape.length === 1 && x2Shape.length === 1, 'x1 and x2 should be 1d array.');
    var outputShape = x1Shape.slice();
    outputShape[0] += x2Shape[0];
    return outputShape;
}
exports.computeOutShape1D = computeOutShape1D;
function computeOutShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeOutShape = computeOutShape;
function computeGradientSliceShapes(aShape, bShape) {
    return {
        aBegin: [0, 0],
        aSize: aShape,
        bBegin: [0, aShape[1]],
        bSize: bShape
    };
}
exports.computeGradientSliceShapes = computeGradientSliceShapes;

},{"../util":155}],111:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var conv_util = require("./conv_util");
var operation_1 = require("./operation");
var ConvOps = (function () {
    function ConvOps() {
    }
    ConvOps.conv1d = function (x, filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NWC'; }
        if (dilation === void 0) { dilation = 1; }
        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv1d');
        var x3D = x;
        var reshapedTo3D = false;
        if (x.rank === 2) {
            reshapedTo3D = true;
            x3D = x.as3D(1, x.shape[0], x.shape[1]);
        }
        util.assert(x3D.rank === 3, "Error in conv1d: input must be rank 3, but got rank " + x3D.rank + ".");
        util.assert(filter.rank === 3, "Error in conv1d: filter must be rank 3, but got rank " +
            (filter.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv1d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        util.assert(x3D.shape[2] === filter.shape[1], "Error in conv1d: depth of input (" + x3D.shape[2] + ") must match " +
            ("input depth for filter " + filter.shape[1] + "."));
        util.assert(eitherStridesOrDilationsAreOne(stride, dilation), 'Error in conv1D: Either stride or dilation must be 1. ' +
            ("Got stride " + stride + " and dilation '" + dilation + "'"));
        util.assert(dataFormat === 'NWC', "Error in conv1d: got dataFormat of " + dataFormat + " but only NWC is currently supported.");
        var filter4D = filter.as4D(1, filter.shape[0], filter.shape[1], filter.shape[2]);
        var input4D = x3D.as4D(x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]);
        var strides = [1, stride];
        var dilations = [1, dilation];
        var conv2dDataFormat = 'NHWC';
        var res = ConvOps.conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);
        if (reshapedTo3D) {
            return res.as2D(res.shape[2], res.shape[3]);
        }
        return res.as3D(res.shape[0], res.shape[2], res.shape[3]);
    };
    ConvOps.conv2d = function (x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv2d');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in conv2d: input must be rank 4, but got rank " + x4D.rank + ".");
        util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        util.assert(x4D.shape[3] === filter.shape[2], "Error in conv2d: depth of input (" + x4D.shape[3] + ") must match " +
            ("input depth for filter " + filter.shape[2] + "."));
        util.assert(eitherStridesOrDilationsAreOne(strides, dilations), 'Error in conv2D: Either strides or dilations must be 1. ' +
            ("Got strides " + strides + " and dilations '" + dilations + "'"));
        util.assert(dataFormat === 'NHWC', "Error in conv2d: got dataFormat of " + dataFormat + " but only NHWC is currently supported.");
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode);
        var grad = function (dy) {
            util.assert(tupleValuesAreOne(dilations), 'Error in gradient of conv2D: dilation rates greater than 1 are not' +
                ("yet supported in gradients. Got dilations '" + dilations + "'"));
            return {
                x: function () { return ConvOps.conv2dDerInput(x4D.shape, dy, filter, strides, pad); },
                filter: function () {
                    return ConvOps.conv2dDerFilter(x4D, dy, filter.shape, strides, pad);
                }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2d(x4D, filter, convInfo); }, { x: x4D, filter: filter }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ConvOps.conv2dDerInput = function (xShape, dy, filter, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ dy: dy, filter: filter }, 'conv2dDerInput');
        util.assert(xShape.length === dy.rank, "Length of inShape " +
            ("(" + xShape.length + ") and rank of dy (" + dy.rank + ") must match"));
        var xShape4D = xShape;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (dy.rank === 3) {
            reshapedTo4D = true;
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
            xShape4D = [1, xShape[0], xShape[1], xShape[2]];
        }
        var inDepth = xShape4D[3];
        var outDepth = dy4D.shape[3];
        util.assert(xShape4D.length === 4, "Error in conv2dDerInput: inShape must be length 4, but got length " +
            (xShape4D.length + "."));
        util.assert(dy4D.rank === 4, "Error in conv2dDerInput: dy must be rank 4, but got " +
            ("rank " + dy4D.rank));
        util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
            ("rank " + filter.rank));
        util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
            ("match input depth for filter " + filter.shape[2] + "."));
        util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must " +
            ("match output depth for filter " + filter.shape[3] + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2dDerInput: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var dilations = 1;
        var convInfo = conv_util.computeConv2DInfo(xShape4D, filter.shape, strides, dilations, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerInput(dy4D, filter, convInfo); }, { dy4D: dy4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ConvOps.conv2dDerFilter = function (x, dy, filterShape, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ x: x, dy: dy }, 'conv2dDerFilter');
        var x4D = x;
        if (x.rank === 3) {
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        var dy4D = dy;
        if (dy4D.rank === 3) {
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in conv2dDerFilter: input must be rank 4, but got shape " +
            (x4D.shape + "."));
        util.assert(dy4D.rank === 4, "Error in conv2dDerFilter: dy must be rank 4, but got shape " +
            (dy4D.shape + "."));
        util.assert(filterShape.length === 4, "Error in conv2dDerFilter: filterShape must be length 4, but got " +
            (filterShape + "."));
        util.assert(x4D.shape[3] === filterShape[2], "Error in conv2dDerFilter: depth of input " + x4D.shape[3] + ") must " +
            ("match input depth in filter (" + filterShape[2] + "."));
        util.assert(dy4D.shape[3] === filterShape[3], "Error in conv2dDerFilter: depth of dy (" + dy4D.shape[3] + ") must " +
            ("match output depth for filter (" + filterShape[3] + ")."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2dDerFilter: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var dilations = 1;
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerFilter(x4D, dy4D, convInfo); }, { x4D: x4D, dy4D: dy4D });
    };
    ConvOps.conv2dTranspose = function (x, filter, outputShape, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv2dTranspose');
        return ConvOps.conv2dDerInput(outputShape, x, filter, strides, pad, dimRoundingMode);
    };
    ConvOps.depthwiseConv2d = function (x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'depthwiseConv2d');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in depthwiseConv2d: input must be rank 4, but got " +
            ("rank " + x4D.rank + "."));
        util.assert(filter.rank === 4, "Error in depthwiseConv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        util.assert(x4D.shape[3] === filter.shape[2], "Error in depthwiseConv2d: number of input channels " +
            ("(" + x4D.shape[3] + ") must match the inChannels dimension in ") +
            ("filter " + filter.shape[2] + "."));
        if (dilations == null) {
            dilations = [1, 1];
        }
        util.assert(eitherStridesOrDilationsAreOne(strides, dilations), 'Error in depthwiseConv2d: Either strides or dilations must be 1. ' +
            ("Got strides " + strides + " and dilations '" + dilations + "'"));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in depthwiseConv2d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode, true);
        var grad = function (dy) {
            util.assert(tupleValuesAreOne(dilations), 'Error in gradient of depthwiseConv2d: dilation rates greater than ' +
                ("1 are not yet supported. Got dilations '" + dilations + "'"));
            return {
                x: function () { return depthwiseConv2dDerInput(x4D.shape, dy, filter, convInfo); },
                filter: function () { return depthwiseConv2dDerFilter(x4D, dy, filter.shape, convInfo); },
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2D(x4D, filter, convInfo); }, { x: x4D, filter: filter }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ConvOps.separableConv2d = function (x, depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat) {
        if (dilation === void 0) { dilation = [1, 1]; }
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        util.assertArgumentsAreTensors({ x: x, depthwiseFilter: depthwiseFilter, pointwiseFilter: pointwiseFilter }, 'separableConv2d');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        if (dataFormat === 'NCHW') {
            throw new Error('separableConv2d currently does not support dataFormat NCHW; only ' +
                'NHWC is supported');
        }
        util.assert(x4D.rank === 4, "Error in separableConv2d: input must be rank 4, but got " +
            ("rank " + x4D.rank + "."));
        util.assert(depthwiseFilter.rank === 4, "Error in separableConv2d: depthwise filter must be rank 4, but got " +
            ("rank " + depthwiseFilter.rank + "."));
        util.assert(pointwiseFilter.rank === 4, "Error in separableConv2d: pointwise filter must be rank 4, but got " +
            ("rank " + depthwiseFilter.rank + "."));
        util.assert(pointwiseFilter.shape[0] === 1, "Error in separableConv2d: the first dimension of pointwise filter " +
            (" must be 1, but got " + pointwiseFilter.shape[0] + "."));
        util.assert(pointwiseFilter.shape[1] === 1, "Error in separableConv2d: the second dimension of pointwise filter " +
            (" must be 1, but got " + pointwiseFilter.shape[1] + "."));
        var inChannels = depthwiseFilter.shape[2];
        var channelMultiplier = depthwiseFilter.shape[3];
        util.assert(pointwiseFilter.shape[2] === inChannels * channelMultiplier, "Error in separableConv2d: the third dimension of pointwise filter " +
            ("must be " + inChannels * channelMultiplier + ", ") +
            ("but got " + pointwiseFilter.shape[2] + "."));
        var depthwise = ConvOps.depthwiseConv2d(x4D, depthwiseFilter, strides, pad, dataFormat, dilation);
        var pointwiseStride = 1;
        var res = ConvOps.conv2d(depthwise, pointwiseFilter, pointwiseStride, 'valid', dataFormat);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv1d", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv2d", null);
    __decorate([
        operation_1.operation
    ], ConvOps, "conv2dDerInput", null);
    __decorate([
        operation_1.operation
    ], ConvOps, "conv2dDerFilter", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv2dTranspose", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "depthwiseConv2d", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "separableConv2d", null);
    return ConvOps;
}());
exports.ConvOps = ConvOps;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function tupleValuesAreOne(param) {
    var _a = parseTupleParam(param), dimA = _a[0], dimB = _a[1];
    return dimA === 1 && dimB === 1;
}
function eitherStridesOrDilationsAreOne(strides, dilations) {
    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
}
function depthwiseConv2dDerInput(xShape, dy, filter, convInfo) {
    var dy4D = dy;
    var reshapedTo4D = false;
    if (dy.rank === 3) {
        reshapedTo4D = true;
        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
    }
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2DDerInput(dy4D, filter, convInfo); }, { dy4D: dy4D });
    if (reshapedTo4D) {
        return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
    }
    return res;
}
function depthwiseConv2dDerFilter(x, dy, filterShape, convInfo) {
    var x4D = x;
    if (x.rank === 3) {
        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
    }
    var dy4D = dy;
    if (dy4D.rank === 3) {
        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
    }
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2DDerFilter(x4D, dy4D, convInfo); }, { x4D: x4D, dy4D: dy4D });
}

},{"../doc":46,"../environment":48,"../util":155,"./conv_util":112,"./operation":123}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computePool2DInfo(inShape, filterSize, strides, pad, roundingMode, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
    var filterShape;
    if (dataFormat === 'channelsLast') {
        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    }
    else if (dataFormat === 'channelsFirst') {
        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var dilations = 1;
    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);
}
exports.computePool2DInfo = computePool2DInfo;
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise, dataFormat) {
    if (depthwise === void 0) { depthwise = false; }
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = [-1, -1, -1, -1], batchSize = _a[0], inHeight = _a[1], inWidth = _a[2], inChannels = _a[3];
    if (dataFormat === 'channelsLast') {
        batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3];
    }
    else if (dataFormat === 'channelsFirst') {
        batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var filterHeight = filterShape[0], filterWidth = filterShape[1], filterChannels = filterShape[3];
    var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
    var _c = parseTupleParam(dilations), dilationHeight = _c[0], dilationWidth = _c[1];
    var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    var _d = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode), padInfo = _d.padInfo, outHeight = _d.outHeight, outWidth = _d.outWidth;
    var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    var outShape;
    if (dataFormat === 'channelsFirst') {
        outShape = [batchSize, outChannels, outHeight, outWidth];
    }
    else if (dataFormat === 'channelsLast') {
        outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
        batchSize: batchSize,
        dataFormat: dataFormat,
        inHeight: inHeight,
        inWidth: inWidth,
        inChannels: inChannels,
        outHeight: outHeight,
        outWidth: outWidth,
        outChannels: outChannels,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        dilationHeight: dilationHeight,
        dilationWidth: dilationWidth,
        inShape: inShape,
        outShape: outShape,
        filterShape: filterShape
    };
}
exports.computeConv2DInfo = computeConv2DInfo;
function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    var inputRows = inShape[0];
    var inputCols = inShape[1];
    var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, outDepth];
}
function computeDefaultPad(inputShape, fieldSize, stride, dilation) {
    if (dilation === void 0) { dilation = 1; }
    var effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) {
        return filterSize;
    }
    return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode) {
    var padInfo;
    var outHeight;
    var outWidth;
    if (typeof pad === 'number') {
        var padType = (pad === 0) ? 'VALID' : 'NUMBER';
        padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };
        var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        var top_1 = Math.floor(padAlongHeight / 2);
        var bottom = padAlongHeight - top_1;
        var left = Math.floor(padAlongWidth / 2);
        var right = padAlongWidth - left;
        padInfo = { top: top_1, bottom: bottom, left: left, right: right, type: 'SAME' };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: 'VALID' };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else {
        throw Error("Unknown padding parameter: " + pad);
    }
    return { padInfo: padInfo, outHeight: outHeight, outWidth: outWidth };
}
function conditionalRound(value, roundingMode) {
    if (!roundingMode) {
        return value;
    }
    switch (roundingMode) {
        case 'round':
            return Math.round(value);
        case 'ceil':
            return Math.ceil(value);
        case 'floor':
            return Math.floor(value);
        default:
            throw new Error("Unknown roundingMode " + roundingMode);
    }
}

},{"../util":155}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERF_P = 0.3275911;
exports.ERF_A1 = 0.254829592;
exports.ERF_A2 = -0.284496736;
exports.ERF_A3 = 1.421413741;
exports.ERF_A4 = -1.453152027;
exports.ERF_A5 = 1.061405429;

},{}],114:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var ImageOps = (function () {
    function ImageOps() {
    }
    ImageOps.resizeBilinear = function (images, size, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        util.assertArgumentsAreTensors({ images: images }, 'resizeBilinear');
        util.assert(images.rank === 3 || images.rank === 4, "Error in resizeBilinear: x must be rank 3 or 4, but got " +
            ("rank " + images.rank + "."));
        util.assert(size.length === 2, "Error in resizeBilinear: new shape must 2D, but got shape " +
            (size + "."));
        var batchImages = images;
        var reshapedTo4D = false;
        if (images.rank === 3) {
            reshapedTo4D = true;
            batchImages =
                images.as4D(1, images.shape[0], images.shape[1], images.shape[2]);
        }
        var newHeight = size[0], newWidth = size[1];
        var forward = function (backend, save) {
            return backend.resizeBilinear(batchImages, newHeight, newWidth, alignCorners);
        };
        var backward = function (dy, saved) {
            return {
                batchImages: function () { return environment_1.ENV.engine.runKernel(function (backend) {
                    return backend.resizeBilinearBackprop(dy, batchImages, alignCorners);
                }, {}); }
            };
        };
        var res = environment_1.ENV.engine.runKernel(forward, { batchImages: batchImages }, backward);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ImageOps.resizeNearestNeighbor = function (images, size, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        util.assertArgumentsAreTensors({ images: images }, 'resizeNearestNeighbor');
        util.assert(images.rank === 3 || images.rank === 4, "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got " +
            ("rank " + images.rank + "."));
        util.assert(size.length === 2, "Error in resizeNearestNeighbor: new shape must 2D, but got shape " +
            (size + "."));
        util.assert(images.dtype === 'float32' || images.dtype === 'int32', '`images` must have `int32` or `float32` as dtype');
        var batchImages = images;
        var reshapedTo4D = false;
        if (images.rank === 3) {
            reshapedTo4D = true;
            batchImages =
                images.as4D(1, images.shape[0], images.shape[1], images.shape[2]);
        }
        var newHeight = size[0], newWidth = size[1];
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.resizeNearestNeighbor(batchImages, newHeight, newWidth, alignCorners); }, { batchImages: batchImages });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Images', namespace: 'image' }),
        operation_1.operation
    ], ImageOps, "resizeBilinear", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Images', namespace: 'image' }),
        operation_1.operation
    ], ImageOps, "resizeNearestNeighbor", null);
    return ImageOps;
}());
exports.ImageOps = ImageOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123}],115:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var tracking_1 = require("../tracking");
var util_1 = require("../util");
var operation_1 = require("./operation");
var ops_1 = require("./ops");
var LinalgOps = (function () {
    function LinalgOps() {
    }
    LinalgOps.gramSchmidt = function (xs) {
        var inputIsTensor2D;
        if (Array.isArray(xs)) {
            inputIsTensor2D = false;
            util_1.assert(xs != null && xs.length > 0, 'Gram-Schmidt process: input must not be null, undefined, or empty');
            var dim = xs[0].shape[0];
            for (var i = 1; i < xs.length; ++i) {
                util_1.assert(xs[i].shape[0] === dim, 'Gram-Schmidt: Non-unique lengths found in the input vectors: ' +
                    ("(" + xs[i].shape[0] + " vs. " + dim + ")"));
            }
        }
        else {
            inputIsTensor2D = true;
            xs = ops_1.split(xs, xs.shape[0], 0).map(function (x) { return ops_1.squeeze(x, [0]); });
        }
        util_1.assert(xs.length <= xs[0].shape[0], "Gram-Schmidt: Number of vectors (" + xs.length + ") exceeds " +
            ("number of dimensions (" + xs[0].shape[0] + ")."));
        var ys = [];
        var xs1d = xs;
        var _loop_1 = function (i) {
            ys.push(tracking_1.Tracking.tidy(function () {
                var x = xs1d[i];
                if (i > 0) {
                    for (var j = 0; j < i; ++j) {
                        var proj = ops_1.sum(ys[j].mulStrict(x)).mul(ys[j]);
                        x = x.sub(proj);
                    }
                }
                return x.div(ops_1.norm(x, 'euclidean'));
            }));
        };
        for (var i = 0; i < xs.length; ++i) {
            _loop_1(i);
        }
        if (inputIsTensor2D) {
            return ops_1.stack(ys, 0);
        }
        else {
            return ys;
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Linear Algebra' }),
        operation_1.operation
    ], LinalgOps, "gramSchmidt", null);
    return LinalgOps;
}());
exports.LinalgOps = LinalgOps;

},{"../doc":46,"../tracking":152,"../util":155,"./operation":123,"./ops":124}],116:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var types = require("../types");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var LogicalOps = (function () {
    function LogicalOps() {
    }
    LogicalOps.logicalNot = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'logicalNot');
        util.assert(x.dtype === 'bool', 'Error Array must be of type bool.');
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalNot(x); }, { x: x });
    };
    LogicalOps.logicalAnd = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalAnd');
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalAnd(a, b); }, { a: a, b: b });
    };
    LogicalOps.logicalOr = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalOr');
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalOr(a, b); }, { a: a, b: b });
    };
    LogicalOps.logicalXor = function (a, b) {
        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalXor');
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return LogicalOps.logicalOr(a, b).logicalAnd(LogicalOps.logicalAnd(a, b).logicalNot());
    };
    LogicalOps.where = function (condition, a, b) {
        util.assertArgumentsAreTensors({ condition: condition, a: a, b: b }, 'where');
        util.assert(condition.dtype === 'bool', 'Error Condition must be of type bool.');
        util.assertShapesMatch(a.shape, b.shape, 'Error in where: ');
        if (condition.rank === 1) {
            util.assert(condition.shape[0] === a.shape[0], 'The first dimension of `a` must match the size of `condition`.');
        }
        else {
            util.assertShapesMatch(condition.shape, b.shape, 'Error in where: ');
        }
        var dtype = types.upcastType(a.dtype, b.dtype);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.where(condition, a, b, dtype); }, { condition: condition, a: a, b: b });
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalNot", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalAnd", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalOr", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalXor", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "where", null);
    return LogicalOps;
}());
exports.LogicalOps = LogicalOps;

},{"../doc":46,"../environment":48,"../types":154,"../util":155,"./broadcast_util":107,"./operation":123}],117:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util = require("../util");
var operation_1 = require("./operation");
var ops = require("./ops");
var Reduction;
(function (Reduction) {
    Reduction[Reduction["NONE"] = 0] = "NONE";
    Reduction[Reduction["MEAN"] = 1] = "MEAN";
    Reduction[Reduction["SUM"] = 2] = "SUM";
    Reduction[Reduction["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Reduction = exports.Reduction || (exports.Reduction = {}));
var LossOps = (function () {
    function LossOps() {
    }
    LossOps.computeWeightedLoss = function (losses, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ losses: losses }, 'computeWeightedLoss');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'computeWeightedLoss');
        }
        var weightedLoss = (weights == null) ? losses : losses.mul(weights);
        if (reduction === Reduction.NONE) {
            return weightedLoss;
        }
        if (reduction === Reduction.SUM) {
            return weightedLoss.sum();
        }
        if (reduction === Reduction.MEAN) {
            return (weights == null) ? weightedLoss.mean() :
                weightedLoss.sum().div(weights.sum());
        }
        if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {
            if (weights == null) {
                return weightedLoss.sum().div(ops.scalar(losses.size));
            }
            else {
                var numNonZeros = weights.notEqual(ops.scalar(0)).sum().toFloat();
                return weightedLoss.sum().div(numNonZeros);
            }
        }
        throw Error("Unknown reduction: " + reduction);
    };
    LossOps.absoluteDifference = function (labels, predictions, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'absoluteDifference');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'absoluteDifference');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in absoluteDifference: ');
        var losses = labels.sub(predictions).abs();
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.meanSquaredError = function (labels, predictions, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'meanSquaredError');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'meanSquaredError');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in meanSquaredError: ');
        var losses = labels.squaredDifference(predictions);
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.cosineDistance = function (labels, predictions, axis, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'cosineDistance');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'cosineDistance');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in cosineDistance: ');
        var one = ops.scalar(1);
        var losses = one.sub(labels.mul(predictions).sum(axis, true));
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.hingeLoss = function (labels, predictions, weights, reduction) {
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'hingeLoss');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'hingeLoss');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in hingeLoss: ');
        var one = ops.scalar(1);
        labels = ops.scalar(2).mul(labels).sub(one);
        var losses = one.sub(labels.mul(predictions)).relu();
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.logLoss = function (labels, predictions, weights, epsilon, reduction) {
        if (epsilon === void 0) { epsilon = 1e-7; }
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'logLoss');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'logLoss');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in logLoss: ');
        var one = ops.scalar(1);
        var epsilonScalar = ops.scalar(epsilon);
        var losses = labels.mul(predictions.add(epsilonScalar).log())
            .neg()
            .sub(one.sub(labels).mul(one.sub(predictions).add(epsilonScalar).log()));
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    LossOps.huberLoss = function (labels, predictions, weights, delta, reduction) {
        if (delta === void 0) { delta = 1.0; }
        if (reduction === void 0) { reduction = Reduction.SUM_BY_NONZERO_WEIGHTS; }
        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'huberLoss');
        if (weights != null) {
            util.assertArgumentsAreTensors({ weights: weights }, 'huberLoss');
        }
        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in huberLoss: ');
        var deltaScalar = ops.scalar(delta);
        var error = predictions.sub(labels).abs();
        var quadratic = ops.minimum(error, deltaScalar);
        var linear = error.sub(quadratic);
        var losses = ops.scalar(0.5).mul(quadratic.square()).add(deltaScalar.mul(linear));
        return LossOps.computeWeightedLoss(losses, weights, reduction);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "computeWeightedLoss", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "absoluteDifference", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "meanSquaredError", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "cosineDistance", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "hingeLoss", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "logLoss", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], LossOps, "huberLoss", null);
    return LossOps;
}());
exports.LossOps = LossOps;

},{"../doc":46,"../util":155,"./operation":123,"./ops":124}],118:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var LRNOps = (function () {
    function LRNOps() {
    }
    LRNOps.localResponseNormalization = function (x, depthRadius, bias, alpha, beta) {
        if (depthRadius === void 0) { depthRadius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        util.assertArgumentsAreTensors({ x: x }, 'localResponseNormalization');
        util.assert(x.rank === 4 || x.rank === 3, "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + x.rank + ".");
        util.assert(util.isInt(depthRadius), "Error in localResponseNormalization: depthRadius must be an integer\n                     but got depthRadius " + depthRadius + ".");
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.localResponseNormalization4D(x4D, depthRadius, bias, alpha, beta); }, { x4D: x4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        else {
            return res;
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], LRNOps, "localResponseNormalization", null);
    return LRNOps;
}());
exports.LRNOps = LRNOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123}],119:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util = require("../util");
var operation_1 = require("./operation");
var LSTMOps = (function () {
    function LSTMOps() {
    }
    LSTMOps.multiRNNCell = function (lstmCells, data, c, h) {
        util.assertArgumentsAreTensors({ data: data, c: c, h: h }, 'multiRNNCell');
        var input = data;
        var newStates = [];
        for (var i = 0; i < lstmCells.length; i++) {
            var output = lstmCells[i](input, c[i], h[i]);
            newStates.push(output[0]);
            newStates.push(output[1]);
            input = output[1];
        }
        var newC = [];
        var newH = [];
        for (var i = 0; i < newStates.length; i += 2) {
            newC.push(newStates[i]);
            newH.push(newStates[i + 1]);
        }
        return [newC, newH];
    };
    LSTMOps.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        util.assertArgumentsAreTensors({ forgetBias: forgetBias, lstmKernel: lstmKernel, lstmBias: lstmBias, data: data, c: c, h: h }, 'basicLSTMCell');
        var combined = data.concat(h, 1);
        var weighted = combined.matMul(lstmKernel);
        var res = weighted.add(lstmBias);
        var batchSize = res.shape[0];
        var sliceCols = res.shape[1] / 4;
        var sliceSize = [batchSize, sliceCols];
        var i = res.slice([0, 0], sliceSize);
        var j = res.slice([0, sliceCols], sliceSize);
        var f = res.slice([0, sliceCols * 2], sliceSize);
        var o = res.slice([0, sliceCols * 3], sliceSize);
        var newC = i.sigmoid().mulStrict(j.tanh()).addStrict(c.mulStrict(forgetBias.add(f).sigmoid()));
        var newH = newC.tanh().mulStrict(o.sigmoid());
        return [newC, newH];
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'RNN' }),
        operation_1.operation
    ], LSTMOps, "multiRNNCell", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'RNN' }),
        operation_1.operation
    ], LSTMOps, "basicLSTMCell", null);
    return LSTMOps;
}());
exports.LSTMOps = LSTMOps;

},{"../doc":46,"../util":155,"./operation":123}],120:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var MatmulOps = (function () {
    function MatmulOps() {
    }
    MatmulOps.matMul = function (a, b, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        util.assertArgumentsAreTensors({ a: a, b: b }, 'matMul');
        var innerShapeA = transposeA ? a.shape[0] : a.shape[1];
        var innerShapeB = transposeB ? b.shape[1] : b.shape[0];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            (" and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of Tensors with shapes " + a.shape + " and ") +
            (b.shape + " and transposeA=" + transposeA) +
            (" and transposeB=" + transposeB + " must match."));
        var grad = function (dy) {
            if (!transposeA && !transposeB) {
                return {
                    a: function () { return dy.matMul(b.toFloat(), false, true); },
                    b: function () { return a.toFloat().matMul(dy, true, false); }
                };
            }
            else if (!transposeA && transposeB) {
                return {
                    a: function () { return dy.matMul(b.toFloat(), false, false); },
                    b: function () { return dy.matMul(a.toFloat(), true, false); }
                };
            }
            else if (transposeA && !transposeB) {
                return {
                    a: function () { return b.toFloat().matMul(dy, false, true); },
                    b: function () { return a.toFloat().matMul(dy, false, false); }
                };
            }
            else {
                return {
                    a: function () { return b.toFloat().matMul(dy, true, true); },
                    b: function () { return dy.matMul(a.toFloat(), true, true); }
                };
            }
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.matMul(a, b, transposeA, transposeB); }, { a: a, b: b }, grad);
    };
    MatmulOps.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " +
            ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
        return v.as2D(1, -1).matMul(matrix).as1D();
    };
    MatmulOps.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return matrix.matMul(v.as2D(-1, 1)).as1D();
    };
    MatmulOps.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return v1.as2D(1, -1).matMul(v2.as2D(-1, 1)).asScalar();
    };
    MatmulOps.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return v1.as2D(-1, 1).matMul(v2.as2D(1, -1));
    };
    MatmulOps.dot = function (t1, t2) {
        util.assert((t1.rank === 1 || t1.rank === 2) && (t2.rank === 1 || t2.rank === 2), "Error in dot: inputs must all be rank 1 or 2, but got ranks " +
            (t1.rank + " and " + t2.rank + "."));
        var t1Inner = (t1.rank === 1 ? t1.size : t1.shape[1]);
        var t2Inner = (t2.rank === 1 ? t2.size : t2.shape[0]);
        util.assert(t1Inner === t2Inner, "Error in dot: inner dimensions of inputs must match, but got " +
            (t1Inner + " and " + t2Inner + "."));
        if (t1.rank === 1 && t2.rank === 1) {
            return t1.as2D(1, -1).matMul(t2.as2D(-1, 1)).asScalar();
        }
        else if (t1.rank === 1 && t2.rank === 2) {
            return t1.as2D(1, -1).matMul(t2.as2D(t2.shape[0], t2.shape[1])).as1D();
        }
        else if (t1.rank === 2 && t2.rank === 1) {
            return t1.matMul(t2.as2D(-1, 1)).as1D();
        }
        else {
            return t1.matMul(t2.as2D(t2.shape[0], t2.shape[1]));
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], MatmulOps, "matMul", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "vectorTimesMatrix", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "matrixTimesVector", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "dotProduct", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], MatmulOps, "outerProduct", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], MatmulOps, "dot", null);
    return MatmulOps;
}());
exports.MatmulOps = MatmulOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123}],121:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util = require("../util");
var array_ops_1 = require("./array_ops");
var binary_ops_1 = require("./binary_ops");
var operation_1 = require("./operation");
var MovingAverageOps = (function () {
    function MovingAverageOps() {
    }
    MovingAverageOps.movingAverage = function (v, x, decay, step, zeroDebias) {
        if (zeroDebias === void 0) { zeroDebias = true; }
        util.assertArgumentsAreTensors({ v: v, x: x }, 'movingAverage');
        util.assertTypesMatch(v, x);
        util.assert(util.arraysEqual(v.shape, x.shape), 'Shape mismatch in v and x');
        var one = array_ops_1.ArrayOps.scalar(1);
        decay = typeof decay === 'number' ? array_ops_1.ArrayOps.scalar(decay) : decay;
        var oneMinusDecay = one.sub(decay);
        var update = x.sub(v).mul(oneMinusDecay);
        if (zeroDebias) {
            util.assert(step != null, 'When using zeroDebias: true, step is required.');
            step = typeof step === 'number' ? array_ops_1.ArrayOps.scalar(step) : step;
            update = update.div(one.sub(binary_ops_1.BinaryOps.pow(decay, step)));
        }
        return v.add(update);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Moving Average' }),
        operation_1.operation
    ], MovingAverageOps, "movingAverage", null);
    return MovingAverageOps;
}());
exports.MovingAverageOps = MovingAverageOps;

},{"../doc":46,"../util":155,"./array_ops":103,"./binary_ops":106,"./operation":123}],122:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var NormOps = (function () {
    function NormOps() {
    }
    NormOps.norm = function (x, ord, axis, keepDims) {
        if (ord === void 0) { ord = 'euclidean'; }
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'norm');
        var norm = normImpl(x, ord, axis);
        var keepDimsShape = norm.shape;
        if (keepDims) {
            var axes = axis_util.parseAxisParam(axis, x.shape);
            keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);
        }
        return norm.reshape(keepDimsShape);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], NormOps, "norm", null);
    return NormOps;
}());
exports.NormOps = NormOps;
function normImpl(x, p, axis) {
    if (axis === void 0) { axis = null; }
    if (x.rank === 0) {
        return x.abs();
    }
    if (x.rank !== 1 && axis === null) {
        return normImpl(x.reshape([-1]), p, axis);
    }
    if (x.rank === 1 || typeof axis === 'number' ||
        axis instanceof Array && axis.length === 1) {
        if (p === 1) {
            return x.abs().sum(axis);
        }
        if (p === Infinity) {
            return x.abs().max(axis);
        }
        if (p === -Infinity) {
            return x.abs().min(axis);
        }
        if (p === 'euclidean' || p === 2) {
            return x.abs().pow(ops.scalar(2, 'int32')).sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    if (axis instanceof Array && axis.length === 2) {
        if (p === 1) {
            return x.abs().sum(axis[0]).max(axis[1] - 1);
        }
        if (p === Infinity) {
            return x.abs().sum(axis[1]).max(axis[0]);
        }
        if (p === -Infinity) {
            return x.abs().sum(axis[1]).min(axis[0]);
        }
        if (p === 'fro' || p === 'euclidean') {
            return x.square().sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    throw new Error("Error in norm: invalid axis: " + axis);
}

},{"../doc":46,"../util":155,"./axis_util":104,"./operation":123,"./ops":124}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
function operation(target, name, descriptor) {
    var fn = descriptor.value;
    descriptor.value = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return globals_1.tidy(name, function () { return fn.apply(void 0, args); });
    };
    return descriptor;
}
exports.operation = operation;

},{"../globals":49}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var array_ops_1 = require("./array_ops");
var batchnorm_1 = require("./batchnorm");
var binary_ops_1 = require("./binary_ops");
var compare_1 = require("./compare");
var concat_1 = require("./concat");
var conv_1 = require("./conv");
var image_ops_1 = require("./image_ops");
var linalg_ops_1 = require("./linalg_ops");
var logical_ops_1 = require("./logical_ops");
var loss_ops_1 = require("./loss_ops");
var lrn_1 = require("./lrn");
var lstm_1 = require("./lstm");
var matmul_1 = require("./matmul");
var moving_average_1 = require("./moving_average");
var norm_1 = require("./norm");
var pool_1 = require("./pool");
var reduction_ops_1 = require("./reduction_ops");
var reverse_1 = require("./reverse");
var slice_1 = require("./slice");
var softmax_1 = require("./softmax");
var strided_slice_1 = require("./strided_slice");
var transpose_1 = require("./transpose");
var unary_ops_1 = require("./unary_ops");
exports.batchNormalization = batchnorm_1.BatchNormOps.batchNormalization;
exports.batchNormalization2d = batchnorm_1.BatchNormOps.batchNormalization2d;
exports.batchNormalization3d = batchnorm_1.BatchNormOps.batchNormalization3d;
exports.batchNormalization4d = batchnorm_1.BatchNormOps.batchNormalization4d;
exports.concat = concat_1.ConcatOps.concat;
exports.concat1d = concat_1.ConcatOps.concat1d;
exports.concat2d = concat_1.ConcatOps.concat2d;
exports.concat3d = concat_1.ConcatOps.concat3d;
exports.concat4d = concat_1.ConcatOps.concat4d;
exports.conv1d = conv_1.ConvOps.conv1d;
exports.conv2d = conv_1.ConvOps.conv2d;
exports.conv2dTranspose = conv_1.ConvOps.conv2dTranspose;
exports.depthwiseConv2d = conv_1.ConvOps.depthwiseConv2d;
exports.separableConv2d = conv_1.ConvOps.separableConv2d;
exports.matMul = matmul_1.MatmulOps.matMul;
exports.matrixTimesVector = matmul_1.MatmulOps.matrixTimesVector;
exports.outerProduct = matmul_1.MatmulOps.outerProduct;
exports.vectorTimesMatrix = matmul_1.MatmulOps.vectorTimesMatrix;
exports.dot = matmul_1.MatmulOps.dot;
exports.avgPool = pool_1.PoolOps.avgPool;
exports.maxPool = pool_1.PoolOps.maxPool;
exports.transpose = transpose_1.TransposeOps.transpose;
exports.reverse = reverse_1.ReverseOps.reverse;
exports.reverse1d = reverse_1.ReverseOps.reverse1d;
exports.reverse2d = reverse_1.ReverseOps.reverse2d;
exports.reverse3d = reverse_1.ReverseOps.reverse3d;
exports.reverse4d = reverse_1.ReverseOps.reverse4d;
exports.slice = slice_1.SliceOps.slice;
exports.slice1d = slice_1.SliceOps.slice1d;
exports.slice2d = slice_1.SliceOps.slice2d;
exports.slice3d = slice_1.SliceOps.slice3d;
exports.slice4d = slice_1.SliceOps.slice4d;
exports.stridedSlice = strided_slice_1.StridedSliceOps.stridedSlice;
exports.argMax = reduction_ops_1.ReductionOps.argMax;
exports.argMin = reduction_ops_1.ReductionOps.argMin;
exports.logSumExp = reduction_ops_1.ReductionOps.logSumExp;
exports.max = reduction_ops_1.ReductionOps.max;
exports.mean = reduction_ops_1.ReductionOps.mean;
exports.min = reduction_ops_1.ReductionOps.min;
exports.moments = reduction_ops_1.ReductionOps.moments;
exports.sum = reduction_ops_1.ReductionOps.sum;
exports.unsortedSegmentSum = reduction_ops_1.ReductionOps.unsortedSegmentSum;
exports.equal = compare_1.CompareOps.equal;
exports.equalStrict = compare_1.CompareOps.equalStrict;
exports.greater = compare_1.CompareOps.greater;
exports.greaterStrict = compare_1.CompareOps.greaterStrict;
exports.greaterEqual = compare_1.CompareOps.greaterEqual;
exports.greaterEqualStrict = compare_1.CompareOps.greaterEqualStrict;
exports.less = compare_1.CompareOps.less;
exports.lessStrict = compare_1.CompareOps.lessStrict;
exports.lessEqual = compare_1.CompareOps.lessEqual;
exports.lessEqualStrict = compare_1.CompareOps.lessEqualStrict;
exports.notEqual = compare_1.CompareOps.notEqual;
exports.notEqualStrict = compare_1.CompareOps.notEqualStrict;
exports.logicalNot = logical_ops_1.LogicalOps.logicalNot;
exports.logicalAnd = logical_ops_1.LogicalOps.logicalAnd;
exports.logicalOr = logical_ops_1.LogicalOps.logicalOr;
exports.logicalXor = logical_ops_1.LogicalOps.logicalXor;
exports.where = logical_ops_1.LogicalOps.where;
exports.abs = unary_ops_1.UnaryOps.abs;
exports.acos = unary_ops_1.UnaryOps.acos;
exports.acosh = unary_ops_1.UnaryOps.acosh;
exports.asin = unary_ops_1.UnaryOps.asin;
exports.asinh = unary_ops_1.UnaryOps.asinh;
exports.atan = unary_ops_1.UnaryOps.atan;
exports.atanh = unary_ops_1.UnaryOps.atanh;
exports.ceil = unary_ops_1.UnaryOps.ceil;
exports.clipByValue = unary_ops_1.UnaryOps.clipByValue;
exports.cos = unary_ops_1.UnaryOps.cos;
exports.cosh = unary_ops_1.UnaryOps.cosh;
exports.elu = unary_ops_1.UnaryOps.elu;
exports.exp = unary_ops_1.UnaryOps.exp;
exports.expm1 = unary_ops_1.UnaryOps.expm1;
exports.floor = unary_ops_1.UnaryOps.floor;
exports.sign = unary_ops_1.UnaryOps.sign;
exports.leakyRelu = unary_ops_1.UnaryOps.leakyRelu;
exports.log = unary_ops_1.UnaryOps.log;
exports.log1p = unary_ops_1.UnaryOps.log1p;
exports.logSigmoid = unary_ops_1.UnaryOps.logSigmoid;
exports.neg = unary_ops_1.UnaryOps.neg;
exports.prelu = unary_ops_1.UnaryOps.prelu;
exports.relu = unary_ops_1.UnaryOps.relu;
exports.reciprocal = unary_ops_1.UnaryOps.reciprocal;
exports.round = unary_ops_1.UnaryOps.round;
exports.selu = unary_ops_1.UnaryOps.selu;
exports.sigmoid = unary_ops_1.UnaryOps.sigmoid;
exports.sin = unary_ops_1.UnaryOps.sin;
exports.sinh = unary_ops_1.UnaryOps.sinh;
exports.softplus = unary_ops_1.UnaryOps.softplus;
exports.sqrt = unary_ops_1.UnaryOps.sqrt;
exports.rsqrt = unary_ops_1.UnaryOps.rsqrt;
exports.square = unary_ops_1.UnaryOps.square;
exports.step = unary_ops_1.UnaryOps.step;
exports.tan = unary_ops_1.UnaryOps.tan;
exports.tanh = unary_ops_1.UnaryOps.tanh;
exports.erf = unary_ops_1.UnaryOps.erf;
exports.add = binary_ops_1.BinaryOps.add;
exports.addStrict = binary_ops_1.BinaryOps.addStrict;
exports.atan2 = binary_ops_1.BinaryOps.atan2;
exports.div = binary_ops_1.BinaryOps.div;
exports.floorDiv = binary_ops_1.BinaryOps.floorDiv;
exports.divStrict = binary_ops_1.BinaryOps.divStrict;
exports.maximum = binary_ops_1.BinaryOps.maximum;
exports.maximumStrict = binary_ops_1.BinaryOps.maximumStrict;
exports.minimum = binary_ops_1.BinaryOps.minimum;
exports.minimumStrict = binary_ops_1.BinaryOps.minimumStrict;
exports.mod = binary_ops_1.BinaryOps.mod;
exports.modStrict = binary_ops_1.BinaryOps.modStrict;
exports.mul = binary_ops_1.BinaryOps.mul;
exports.mulStrict = binary_ops_1.BinaryOps.mulStrict;
exports.pow = binary_ops_1.BinaryOps.pow;
exports.powStrict = binary_ops_1.BinaryOps.powStrict;
exports.sub = binary_ops_1.BinaryOps.sub;
exports.subStrict = binary_ops_1.BinaryOps.subStrict;
exports.squaredDifference = binary_ops_1.BinaryOps.squaredDifference;
exports.squaredDifferenceStrict = binary_ops_1.BinaryOps.squaredDifferenceStrict;
exports.norm = norm_1.NormOps.norm;
exports.cast = array_ops_1.ArrayOps.cast;
exports.clone = array_ops_1.ArrayOps.clone;
exports.fromPixels = array_ops_1.ArrayOps.fromPixels;
exports.toPixels = array_ops_1.ArrayOps.toPixels;
exports.ones = array_ops_1.ArrayOps.ones;
exports.onesLike = array_ops_1.ArrayOps.onesLike;
exports.zeros = array_ops_1.ArrayOps.zeros;
exports.zerosLike = array_ops_1.ArrayOps.zerosLike;
exports.eye = array_ops_1.ArrayOps.eye;
exports.rand = array_ops_1.ArrayOps.rand;
exports.randomNormal = array_ops_1.ArrayOps.randomNormal;
exports.truncatedNormal = array_ops_1.ArrayOps.truncatedNormal;
exports.randomUniform = array_ops_1.ArrayOps.randomUniform;
exports.multinomial = array_ops_1.ArrayOps.multinomial;
exports.reshape = array_ops_1.ArrayOps.reshape;
exports.squeeze = array_ops_1.ArrayOps.squeeze;
exports.tile = array_ops_1.ArrayOps.tile;
exports.gather = array_ops_1.ArrayOps.gather;
exports.oneHot = array_ops_1.ArrayOps.oneHot;
exports.linspace = array_ops_1.ArrayOps.linspace;
exports.range = array_ops_1.ArrayOps.range;
exports.buffer = array_ops_1.ArrayOps.buffer;
exports.fill = array_ops_1.ArrayOps.fill;
exports.tensor = array_ops_1.ArrayOps.tensor;
exports.scalar = array_ops_1.ArrayOps.scalar;
exports.tensor1d = array_ops_1.ArrayOps.tensor1d;
exports.tensor2d = array_ops_1.ArrayOps.tensor2d;
exports.tensor3d = array_ops_1.ArrayOps.tensor3d;
exports.tensor4d = array_ops_1.ArrayOps.tensor4d;
exports.tensor5d = array_ops_1.ArrayOps.tensor5d;
exports.print = array_ops_1.ArrayOps.print;
exports.expandDims = array_ops_1.ArrayOps.expandDims;
exports.stack = array_ops_1.ArrayOps.stack;
exports.unstack = array_ops_1.ArrayOps.unstack;
exports.split = array_ops_1.ArrayOps.split;
exports.cumsum = array_ops_1.ArrayOps.cumsum;
exports.pad = array_ops_1.ArrayOps.pad;
exports.pad1d = array_ops_1.ArrayOps.pad1d;
exports.pad2d = array_ops_1.ArrayOps.pad2d;
exports.pad3d = array_ops_1.ArrayOps.pad3d;
exports.pad4d = array_ops_1.ArrayOps.pad4d;
exports.movingAverage = moving_average_1.MovingAverageOps.movingAverage;
exports.basicLSTMCell = lstm_1.LSTMOps.basicLSTMCell;
exports.multiRNNCell = lstm_1.LSTMOps.multiRNNCell;
exports.softmax = softmax_1.SoftmaxOps.softmax;
exports.localResponseNormalization = lrn_1.LRNOps.localResponseNormalization;
exports.linalg = linalg_ops_1.LinalgOps;
var operation_1 = require("./operation");
exports.operation = operation_1.operation;
var tensor_1 = require("../tensor");
var types_1 = require("../types");
[tensor_1.Tensor, types_1.Rank];
[loss_ops_1.Reduction];
exports.losses = {
    absoluteDifference: loss_ops_1.LossOps.absoluteDifference,
    computeWeightedLoss: loss_ops_1.LossOps.computeWeightedLoss,
    cosineDistance: loss_ops_1.LossOps.cosineDistance,
    hingeLoss: loss_ops_1.LossOps.hingeLoss,
    huberLoss: loss_ops_1.LossOps.huberLoss,
    logLoss: loss_ops_1.LossOps.logLoss,
    meanSquaredError: loss_ops_1.LossOps.meanSquaredError,
    softmaxCrossEntropy: softmax_1.SoftmaxOps.softmaxCrossEntropy
};
exports.image = {
    resizeBilinear: image_ops_1.ImageOps.resizeBilinear,
    resizeNearestNeighbor: image_ops_1.ImageOps.resizeNearestNeighbor,
};

},{"../tensor":149,"../types":154,"./array_ops":103,"./batchnorm":105,"./binary_ops":106,"./compare":108,"./concat":109,"./conv":111,"./image_ops":114,"./linalg_ops":115,"./logical_ops":116,"./loss_ops":117,"./lrn":118,"./lstm":119,"./matmul":120,"./moving_average":121,"./norm":122,"./operation":123,"./pool":125,"./reduction_ops":128,"./reverse":129,"./slice":131,"./softmax":133,"./strided_slice":134,"./transpose":135,"./unary_ops":136}],125:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var conv_util = require("./conv_util");
var operation_1 = require("./operation");
var PoolOps = (function () {
    function PoolOps() {
    }
    PoolOps.maxPool = function (x, filterSize, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ x: x }, 'maxPool');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in maxPool: input must be rank 4 but got rank " + x4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in maxPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad, dimRoundingMode);
        var grad = function (dy, saved) {
            var y4D = saved[0];
            return {
                x: function () { return PoolOps.maxPoolBackprop(dy, x4D, y4D, filterSize, strides, pad); }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.maxPool(x4D, convInfo)); }, { x: x4D }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    PoolOps.maxPoolBackprop = function (dy, input, output, filterSize, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ dy: dy, input: input, output: output }, 'maxPoolBackprop');
        util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
        util.assert(dy.rank === 4, "Error in maxPoolBackprop: dy must be rank 4 but got rank " +
            (dy.rank + "."));
        util.assert(input.rank === 4, "Error in maxPoolBackprop: input must be rank 4 but got rank " +
            (input.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in maxPoolBackprop: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(input.shape, filterSize, strides, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.maxPoolBackprop(dy, input, output, convInfo); }, { dy: dy, input: input });
        return res;
    };
    PoolOps.avgPool = function (x, filterSize, strides, pad, dimRoundingMode) {
        util.assertArgumentsAreTensors({ x: x }, 'avgPool');
        util.assert(x.dtype === 'float32', 'The input dtype to avgPool must be float32');
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in avgPool: x must be rank 4 but got rank " + x4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in avgPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad);
        var grad = function (dy) {
            return {
                x: function () { return PoolOps.avgPoolBackprop(dy, x4D, filterSize, strides, pad); }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.avgPool(x4D, convInfo); }, { x: x4D }, grad);
        res = res.cast(x.dtype);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    PoolOps.avgPoolBackprop = function (dy, input, filterSize, strides, pad) {
        util.assertArgumentsAreTensors({ dy: dy, input: input }, 'avgPoolBackprop');
        util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
        var input4D = input;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(dy4D.rank === 4, "Error in avgPoolBackprop: dy must be rank 4 but got rank " +
            (dy4D.rank + "."));
        util.assert(input4D.rank === 4, "Error in avgPoolBackprop: input must be rank 4 but got rank " +
            (input4D.rank + "."));
        var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.avgPoolBackprop(dy4D, input4D, convInfo); }, { dy4D: dy4D, input4D: input4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], PoolOps, "maxPool", null);
    __decorate([
        operation_1.operation
    ], PoolOps, "maxPoolBackprop", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], PoolOps, "avgPool", null);
    __decorate([
        operation_1.operation
    ], PoolOps, "avgPoolBackprop", null);
    return PoolOps;
}());
exports.PoolOps = PoolOps;

},{"../doc":46,"../environment":48,"../util":155,"./conv_util":112,"./operation":123}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var MPRandGauss = (function () {
    function MPRandGauss(mean, stdDeviation, dtype, truncated, seed) {
        this.mean = mean;
        this.stdDev = stdDeviation;
        this.dtype = dtype;
        this.nextVal = NaN;
        this.truncated = truncated;
        if (this.truncated) {
            this.upper = this.mean + this.stdDev * 2;
            this.lower = this.mean - this.stdDev * 2;
        }
        var seedValue = seed ? seed : Math.random();
        this.random = seedrandom.alea(seedValue.toString());
    }
    MPRandGauss.prototype.nextValue = function () {
        if (!isNaN(this.nextVal)) {
            var value = this.nextVal;
            this.nextVal = NaN;
            return value;
        }
        var resultX, resultY;
        var isValid = false;
        while (!isValid) {
            var v1 = void 0, v2 = void 0, s = void 0;
            do {
                v1 = 2 * this.random() - 1;
                v2 = 2 * this.random() - 1;
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s === 0);
            var mul = Math.sqrt(-2.0 * Math.log(s) / s);
            resultX = this.mean + this.stdDev * v1 * mul;
            resultY = this.mean + this.stdDev * v2 * mul;
            if (!this.truncated || this.isValidTruncated(resultX)) {
                isValid = true;
            }
        }
        if (!this.truncated || this.isValidTruncated(resultY)) {
            this.nextVal = this.convertValue(resultY);
        }
        return this.convertValue(resultX);
    };
    MPRandGauss.prototype.convertValue = function (value) {
        if (this.dtype == null || this.dtype === 'float32') {
            return value;
        }
        return Math.round(value);
    };
    MPRandGauss.prototype.isValidTruncated = function (value) {
        return value <= this.upper && value >= this.lower;
    };
    return MPRandGauss;
}());
exports.MPRandGauss = MPRandGauss;

},{"seedrandom":208}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
    if (inSize <= exports.PARALLELIZE_THRESHOLD) {
        return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
exports.computeOptimalWindowSize = computeOptimalWindowSize;
function nearestDivisor(size, start) {
    for (var i = start; i < size; ++i) {
        if (size % i === 0) {
            return i;
        }
    }
    return size;
}

},{}],128:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var ReductionOps = (function () {
    function ReductionOps() {
    }
    ReductionOps.logSumExp = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'logSumExp');
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var xMax = x.max(axes, true);
        var a = x.sub(xMax);
        var b = a.exp();
        var c = b.sum(axes);
        var d = c.log();
        var res = xMax.reshape(d.shape).add(d);
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.sum = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'sum');
        if (x.dtype === 'bool') {
            x = x.toInt();
        }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var customOp = globals_1.customGrad(function (x) {
            var permutation = axis_util.getAxesPermutation(axes, x.rank);
            var reductionAxes = axes;
            var permutedX = x;
            if (permutation != null) {
                permutedX = x.transpose(permutation);
                reductionAxes =
                    axis_util.getInnerMostAxes(reductionAxes.length, x.rank);
            }
            var value = environment_1.ENV.engine.runKernel(function (backend) { return backend.sum(permutedX, reductionAxes); }, { permutedX: permutedX });
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(value.shape, axes);
                value = value.reshape(newShape);
            }
            var gradFunc = function (dy) {
                var expandedDyShape = x.shape.slice();
                axes.forEach(function (axis) {
                    expandedDyShape[axis] = 1;
                });
                var expandedDy = dy.reshape(expandedDyShape);
                var derX = expandedDy.mul(ops.ones(x.shape, 'float32'));
                return derX;
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(x);
    };
    ReductionOps.mean = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'mean');
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
        var reduceShape = shapes[1];
        var reduceSize = util.sizeFromShape(reduceShape);
        var customOp = globals_1.customGrad(function (x) {
            var reduceSizeScalar = ops.scalar(reduceSize);
            var xReduce = reduceSizeScalar.dtype === x.dtype ?
                x :
                x.cast(reduceSizeScalar.dtype);
            var res = xReduce.div(reduceSizeScalar);
            var value = res.sum(axis, keepDims);
            var gradFunc = function (dy) {
                var expandedDyShape = x.shape.slice();
                axes.forEach(function (axis) {
                    expandedDyShape[axis] = 1;
                });
                var expandedDy = dy.reshape(expandedDyShape);
                var derX = expandedDy.mul(ops.ones(x.shape, 'float32')).div(reduceSizeScalar);
                return derX;
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(x);
    };
    ReductionOps.min = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'min');
        var origAxes = axis_util.parseAxisParam(axis, x.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.min(x, axes); }, { x: x });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.max = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'max');
        var origAxes = axis_util.parseAxisParam(axis, x.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.max(x, axes); }, { x: x });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.argMin = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'argMin');
        if (axis == null) {
            axis = 0;
        }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.argMin(x, axes[0]); }, { x: x });
    };
    ReductionOps.argMax = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'argMax');
        if (axis == null) {
            axis = 0;
        }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.argMax(x, axes[0]); }, { x: x });
    };
    ReductionOps.moments = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        util.assertArgumentsAreTensors({ x: x }, 'moments');
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var mean = x.mean(axes, keepDims);
        var keepDimsShape = mean.shape;
        if (!keepDims) {
            keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
        }
        var devSquared = x.toFloat().sub(mean.reshape(keepDimsShape)).square();
        var variance = devSquared.mean(axes, keepDims);
        return { mean: mean, variance: variance };
    };
    ReductionOps.unsortedSegmentSum = function (x, segmentIds, numSegments, axis) {
        if (axis === void 0) { axis = 0; }
        util.assertArgumentsAreTensors({ x: x, segmentIds: segmentIds }, 'unsortedSegmentSum');
        util.assert(segmentIds.dtype === 'int32', 'Segment Ids must be of dtype `int32`');
        axis = axis_util.parseAxisParam(axis, x.shape)[0];
        var res = [];
        var dim = segmentIds.shape[0];
        var newShape = [];
        for (var i = 0; i < x.shape.length; i++) {
            if (i === axis) {
                newShape.push(dim);
            }
            else {
                newShape.push(1);
            }
        }
        var reshapedSegmentIds = ops.reshape(segmentIds, newShape);
        for (var i = 0; i < numSegments; i++) {
            var segmentId = ops.scalar(i, 'int32');
            var mask = ops.equal(segmentId, reshapedSegmentIds).asType('float32');
            var sum = mask.mul(x).sum(axis);
            res.push(sum);
        }
        return ops.stack(res, axis);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "logSumExp", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "sum", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "mean", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "min", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "max", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "argMin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "argMax", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], ReductionOps, "moments", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "unsortedSegmentSum", null);
    return ReductionOps;
}());
exports.ReductionOps = ReductionOps;

},{"../doc":46,"../environment":48,"../globals":49,"../util":155,"./axis_util":104,"./operation":123,"./ops":124}],129:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var operation_1 = require("./operation");
var ReverseOps = (function () {
    function ReverseOps() {
    }
    ReverseOps.reverse1d = function (x) {
        util.assert(x.rank === 1, "Error in reverse1D: x must be rank 1 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, 0);
    };
    ReverseOps.reverse2d = function (x, axis) {
        util.assert(x.rank === 2, "Error in reverse2D: x must be rank 2 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse3d = function (x, axis) {
        util.assert(x.rank === 3, "Error in reverse3D: x must be rank 3 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse4d = function (x, axis) {
        util.assert(x.rank === 4, "Error in reverse4D: x must be rank 4 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse = function (x, axis) {
        util.assertArgumentsAreTensors({ x: x }, 'reverse');
        if (x.rank === 0) {
            return x.clone();
        }
        var axes = axis_util_1.parseAxisParam(axis, x.shape);
        var grad = function (dy) {
            return { x: function () { return dy.reverse(axes); } };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.reverse(x, axes); }, { x: x }, grad);
        return res.reshapeAs(x);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ReverseOps, "reverse", null);
    return ReverseOps;
}());
exports.ReverseOps = ReverseOps;

},{"../doc":46,"../environment":48,"../util":155,"./axis_util":104,"./operation":123}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SELU_SCALEALPHA = 1.7580993408473768599402175208123;
exports.SELU_SCALE = 1.0507009873554804934193349852946;

},{}],131:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var slice_util = require("./slice_util");
var SliceOps = (function () {
    function SliceOps() {
    }
    SliceOps.slice1d = function (x, begin, size) {
        util.assert(x.rank === 1, "slice1d expects a rank-1 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, [begin], [size]);
    };
    SliceOps.slice2d = function (x, begin, size) {
        util.assert(x.rank === 2, "slice1d expects a rank-2 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice3d = function (x, begin, size) {
        util.assert(x.rank === 3, "slice1d expects a rank-3 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice4d = function (x, begin, size) {
        util.assert(x.rank === 4, "slice1d expects a rank-4 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice = function (x, begin, size) {
        util.assertArgumentsAreTensors({ x: x }, 'slice');
        if (x.rank === 0) {
            throw new Error('Slicing scalar is not possible');
        }
        var begin_;
        if (typeof begin === 'number') {
            begin_ = [begin].concat(new Array(x.rank - 1).fill(0));
        }
        else if (begin.length < x.rank) {
            begin_ = begin.concat(new Array(x.rank - begin.length).fill(0));
        }
        else {
            begin_ = begin;
        }
        var size_;
        if (size == null) {
            size_ = new Array(x.rank).fill(-1);
        }
        else if (typeof size === 'number') {
            size_ = [size].concat(new Array(x.rank - 1).fill(-1));
        }
        else if (size.length < x.rank) {
            size_ = size.concat(new Array(x.rank - size.length).fill(-1));
        }
        else {
            size_ = size;
        }
        size_ = size_.map(function (d, i) {
            if (d >= 0) {
                return d;
            }
            else {
                util.assert(d === -1, 'Bad value in size');
                return x.shape[i] - begin_[i];
            }
        });
        slice_util.assertParamsValid(x, begin_, size_);
        var inputShape = x.shape;
        var grad = function (dy) {
            var paddings = [];
            for (var i = 0; i < dy.rank; i++) {
                paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);
            }
            return { x: function () { return dy.pad(paddings); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.slice(x, begin_, size_); }, { x: x }, grad);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], SliceOps, "slice", null);
    return SliceOps;
}());
exports.SliceOps = SliceOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123,"./slice_util":132}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParamsValid(input, begin, size) {
    util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    for (var i = 0; i < input.rank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
            ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
    }
}
exports.assertParamsValid = assertParamsValid;
function getStridedSlicedInfo(shape, begin, end, strides, beginMask, endMask) {
    if (beginMask === void 0) { beginMask = 0; }
    if (endMask === void 0) { endMask = 0; }
    var startIndex = [];
    var endIndex = [];
    for (var i = 0; i < shape.length; i++) {
        startIndex[i] = startForAxis(beginMask, begin, strides, shape, i);
        endIndex[i] = stopForAxis(endMask, end, strides, shape, i);
    }
    var size = new Array(shape.length).fill(0);
    size = size.map(function (d, i) {
        var count = 0;
        for (var start = startIndex[i]; !(strides[i] > 0 ? start >= endIndex[i] : start <= endIndex[i]); start += strides[i]) {
            count += 1;
        }
        return count;
    });
    return [startIndex, size];
}
exports.getStridedSlicedInfo = getStridedSlicedInfo;
function startForAxis(beginMask, startIndices, strides, inputShape, axis) {
    var start = startIndices[axis];
    if (beginMask & 1 << axis) {
        if (strides[axis] > 0) {
            start = Number.MIN_SAFE_INTEGER;
        }
        else {
            start = Number.MAX_SAFE_INTEGER;
        }
    }
    var axisSize = inputShape[axis];
    if (start < 0) {
        start += axisSize;
    }
    start = util.clamp(0, start, axisSize - 1);
    return start;
}
exports.startForAxis = startForAxis;
function stopForAxis(endMask, stopIndices, strides, inputShape, axis) {
    var stop = stopIndices[axis];
    if (endMask & (1 << axis)) {
        if (strides[axis] > 0) {
            stop = Number.MAX_SAFE_INTEGER;
        }
        else {
            stop = Number.MIN_SAFE_INTEGER;
        }
    }
    var axisSize = inputShape[axis];
    if (stop < 0) {
        stop += axisSize;
    }
    if (strides[axis] > 0) {
        stop = util.clamp(0, stop, axisSize);
    }
    else {
        stop = util.clamp(-1, stop, axisSize - 1);
    }
    return stop;
}
exports.stopForAxis = stopForAxis;

},{"../util":155}],133:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var globals_1 = require("../globals");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var SoftmaxOps = (function () {
    function SoftmaxOps() {
    }
    SoftmaxOps.softmax = function (logits, dim) {
        if (dim === void 0) { dim = -1; }
        util.assertArgumentsAreTensors({ logits: logits }, 'softmax');
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error('Softmax along a non-last dimension is not yet supported. ' +
                ("Logits was rank " + logits.rank + " and dim was " + dim));
        }
        var customOp = globals_1.customGrad(function (logits) {
            var keepDims = true;
            var lse = logits.logSumExp([dim], keepDims);
            var logResult = logits.toFloat().sub(lse);
            var y = logResult.exp();
            var gradFunc = function (dy) {
                var dyTimesY = dy.mul(y);
                var keepDims = true;
                return dyTimesY.sub(dyTimesY.sum([dim], keepDims).mul(y));
            };
            return { value: y, gradFunc: gradFunc };
        });
        return customOp(logits);
    };
    SoftmaxOps.softmaxCrossEntropy = function (labels, logits, dim) {
        if (dim === void 0) { dim = -1; }
        util.assertArgumentsAreTensors({ labels: labels, logits: logits }, 'softmaxCrossEntropy');
        util.assertShapesMatch(labels.shape, logits.shape, 'Error in softmaxCrossEntropy: ');
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error("Softmax cross entropy along a non-last dimension is not yet " +
                ("supported. Labels / logits was rank " + logits.rank + " ") +
                ("and dim was " + dim));
        }
        var customOp = globals_1.customGrad(function (labels, logits) {
            var predictedProbs = logits.softmax(dim);
            var costVector = ops.scalar(1e-5).add(predictedProbs).log().mul(labels).neg();
            var value = costVector.sum([dim]);
            var gradFunc = function (dy) {
                var dyShape = axis_util.expandShapeToKeepDim(dy.shape, [dim]);
                return [
                    dy.reshape(dyShape).mul(labels.toFloat().sub(predictedProbs)),
                    dy.reshape(dyShape).mul(predictedProbs.sub(labels.toFloat())),
                ];
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(labels, logits);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], SoftmaxOps, "softmax", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], SoftmaxOps, "softmaxCrossEntropy", null);
    return SoftmaxOps;
}());
exports.SoftmaxOps = SoftmaxOps;

},{"../doc":46,"../globals":49,"../util":155,"./axis_util":104,"./operation":123,"./ops":124}],134:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var StridedSliceOps = (function () {
    function StridedSliceOps() {
    }
    StridedSliceOps.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
        if (beginMask === void 0) { beginMask = 0; }
        if (endMask === void 0) { endMask = 0; }
        util.assertArgumentsAreTensors({ x: x }, 'stridedSlice');
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.stridedSlice(x, begin, end, strides, beginMask, endMask); }, { x: x });
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], StridedSliceOps, "stridedSlice", null);
    return StridedSliceOps;
}());
exports.StridedSliceOps = StridedSliceOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123}],135:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var TransposeOps = (function () {
    function TransposeOps() {
    }
    TransposeOps.transpose = function (x, perm) {
        util.assertArgumentsAreTensors({ x: x }, 'transpose');
        if (perm == null) {
            perm = x.shape.map(function (s, i) { return i; }).reverse();
        }
        util.assert(x.rank === perm.length, "Error in transpose: rank of input " + x.rank + " " +
            ("must match length of perm " + perm + "."));
        perm.forEach(function (axis) {
            util.assert(axis >= 0 && axis < x.rank, "All entries in 'perm' must be between 0 and " + (x.rank - 1) +
                (" but got " + perm));
        });
        if (x.rank <= 1) {
            return x.clone();
        }
        var der = function (dy) {
            var undoPerm = axis_util.getUndoAxesPermutation(perm);
            return { x: function () { return dy.transpose(undoPerm); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.transpose(x, perm); }, { x: x }, der);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], TransposeOps, "transpose", null);
    return TransposeOps;
}());
exports.TransposeOps = TransposeOps;

},{"../doc":46,"../environment":48,"../util":155,"./axis_util":104,"./operation":123}],136:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var ops = require("./ops");
var ops_1 = require("./ops");
var selu_util = require("./selu_util");
var UnaryOps = (function () {
    function UnaryOps() {
    }
    UnaryOps.neg = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'neg');
        var grad = function (dy) {
            return { x: function () { return dy.neg(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.neg(x); }, { x: x }, grad);
    };
    UnaryOps.ceil = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'ceil');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.ceil(x); }, { x: x }, grad);
    };
    UnaryOps.floor = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'floor');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.floor(x); }, { x: x }, grad);
    };
    UnaryOps.sign = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sign');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sign(x); }, { x: x }, grad);
    };
    UnaryOps.round = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'round');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.round(x); }, { x: x }, grad);
    };
    UnaryOps.exp = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'exp');
        var bck = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return dy.mulStrict(y); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.exp(x)); }, { x: x }, bck);
    };
    UnaryOps.expm1 = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'expm1');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.exp()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.expm1(x); }, { x: x }, grad);
    };
    UnaryOps.log = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'log');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.toFloat()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.log(x); }, { x: x }, grad);
    };
    UnaryOps.log1p = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'log1p');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.add(ops.scalar(1))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.log1p(x); }, { x: x }, grad);
    };
    UnaryOps.sqrt = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sqrt');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.toFloat().sqrt().mul(ops.scalar(2))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sqrt(x); }, { x: x }, grad);
    };
    UnaryOps.rsqrt = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'rsqrt');
        var grad = function (dy) {
            return {
                x: function () { return dy.divStrict(x.pow(ops.scalar(1.5)).mul(ops.scalar(2))).neg(); }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.rsqrt(x); }, { x: x }, grad);
    };
    UnaryOps.square = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'square');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.toFloat().mul(ops.scalar(2))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.square(x); }, { x: x }, grad);
    };
    UnaryOps.reciprocal = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'reciprocal');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.square().neg()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.reciprocal(x); }, { x: x }, grad);
    };
    UnaryOps.abs = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'abs');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.toFloat().step(-1)); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.abs(x); }, { x: x }, grad);
    };
    UnaryOps.clipByValue = function (x, clipValueMin, clipValueMax) {
        util.assertArgumentsAreTensors({ x: x }, 'clipByValue');
        util.assert((clipValueMin <= clipValueMax), "Error in clip: min (" + clipValueMin + ") must be " +
            ("less than or equal to max (" + clipValueMax + ")."));
        var grad = function (dy) {
            return {
                x: function () { return dy.where(x.greaterEqual(ops.scalar(clipValueMin))
                    .logicalAnd(x.lessEqual(ops.scalar(clipValueMax))), ops_1.zerosLike(dy)); },
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.clip(x, clipValueMin, clipValueMax); }, { x: x }, grad);
    };
    UnaryOps.relu = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'relu');
        if (x.dtype === 'bool') {
            return x.toInt();
        }
        var grad = function (dy) {
            var stepRes = x.step();
            return { x: function () { return dy.mulStrict(stepRes.toFloat()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.relu(x); }, { x: x }, grad);
    };
    UnaryOps.elu = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'elu');
        var grad = function (dy, saved) {
            var y = saved[0];
            return {
                x: function () {
                    return environment_1.ENV.engine.runKernel(function (backend) { return backend.eluDer(dy, y); }, { dy: dy, y: y });
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.elu(x)); }, { x: x }, grad);
    };
    UnaryOps.selu = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'selu');
        var grad = function (dy) {
            return {
                x: function () {
                    var mask = x.greater(ops.scalar(0));
                    var scaleAlpha = ops.scalar(selu_util.SELU_SCALEALPHA);
                    var scale = ops.scalar(selu_util.SELU_SCALE);
                    var greaterThanZeroDer = dy.mul(scale);
                    var lessEqualZeroDer = dy.mul(scaleAlpha).mul(x.toFloat().exp());
                    return ops.where(mask, greaterThanZeroDer, lessEqualZeroDer);
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.selu(x); }, { x: x }, grad);
    };
    UnaryOps.leakyRelu = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        util.assertArgumentsAreTensors({ x: x }, 'leakyRelu');
        return ops.maximum(ops.scalar(alpha).mul(x), x);
    };
    UnaryOps.prelu = function (x, alpha) {
        util.assertArgumentsAreTensors({ x: x, alpha: alpha }, 'prelu');
        var zero = ops.scalar(0);
        return ops.maximum(zero, x).add(alpha.mul(ops.minimum(zero, x)));
    };
    UnaryOps.sigmoid = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sigmoid');
        var grad = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return dy.mulStrict(y.mul(ops.scalar(1).sub(y))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.sigmoid(x)); }, { x: x }, grad);
    };
    UnaryOps.logSigmoid = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'logSigmoid');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.neg().sigmoid()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.softplus(x.neg()).neg(); }, { x: x }, grad);
    };
    UnaryOps.softplus = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'softplus');
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.sigmoid()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.softplus(x); }, { x: x }, grad);
    };
    UnaryOps.sin = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sin');
        var grad = function (dy) {
            return { x: function () { return x.toFloat().cos().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sin(x); }, { x: x }, grad);
    };
    UnaryOps.cos = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'cos');
        var grad = function (dy) {
            return { x: function () { return x.toFloat().sin().neg().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cos(x); }, { x: x }, grad);
    };
    UnaryOps.tan = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'tan');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.cos().square()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.tan(x); }, { x: x }, grad);
    };
    UnaryOps.asin = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'asin');
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(x.toFloat().square())));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.asin(x); }, { x: x }, grad);
    };
    UnaryOps.acos = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'acos');
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(x.toFloat().square())))
                        .neg();
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.acos(x); }, { x: x }, grad);
    };
    UnaryOps.atan = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'atan');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(ops.scalar(1).add(x.toFloat().square())); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atan(x); }, { x: x }, grad);
    };
    UnaryOps.sinh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'sinh');
        var grad = function (dy) {
            return { x: function () { return x.toFloat().cosh().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sinh(x); }, { x: x }, grad);
    };
    UnaryOps.cosh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'cosh');
        var grad = function (dy) {
            return { x: function () { return x.toFloat().sinh().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cosh(x); }, { x: x }, grad);
    };
    UnaryOps.tanh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'tanh');
        var grad = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return ops.scalar(1).sub(y.square()).mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.tanh(x)); }, { x: x }, grad);
    };
    UnaryOps.asinh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'asinh');
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).add(x.toFloat().square())));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.asinh(x); }, { x: x }, grad);
    };
    UnaryOps.acosh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'acosh');
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(x.toFloat().square().sub(ops.scalar(1))));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.acosh(x); }, { x: x }, grad);
    };
    UnaryOps.atanh = function (x) {
        util.assertArgumentsAreTensors({ x: x }, 'atanh');
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(ops.scalar(1).sub(x.toFloat().square())); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atanh(x); }, { x: x }, grad);
    };
    UnaryOps.erf = function (x) {
        util.assert(x.dtype === 'int32' || x.dtype === 'float32', 'Input dtype must be `int32` or `float32`.');
        if (x.dtype === 'int32') {
            x = x.toFloat();
        }
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.mulStrict(ops.scalar(2 / Math.sqrt(Math.PI))
                        .mul(x.square().neg().exp()));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.erf(x); }, { x: x }, grad);
    };
    UnaryOps.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        util.assertArgumentsAreTensors({ x: x }, 'step');
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.step(x, alpha); }, { x: x }, grad);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "neg", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "ceil", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "floor", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sign", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "round", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "exp", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "expm1", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "log", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "log1p", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sqrt", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "rsqrt", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "square", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "reciprocal", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "abs", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "clipByValue", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "relu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "elu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "selu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "leakyRelu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "prelu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sigmoid", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "logSigmoid", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "softplus", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "cos", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "tan", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "asin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "acos", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "atan", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sinh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "cosh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "tanh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "asinh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "acosh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "atanh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "erf", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "step", null);
    return UnaryOps;
}());
exports.UnaryOps = UnaryOps;

},{"../doc":46,"../environment":48,"../util":155,"./operation":123,"./ops":124,"./selu_util":130}],137:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdadeltaOptimizer = (function (_super) {
    __extends(AdadeltaOptimizer, _super);
    function AdadeltaOptimizer(learningRate, rho, epsilon) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.rho = rho;
        _this.epsilon = epsilon;
        _this.accumulatedGrads = {};
        _this.accumulatedUpdates = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsilonScalar = globals_1.keep(ops_1.scalar(epsilon));
        _this.rhoScalar = globals_1.keep(ops_1.scalar(rho));
        _this.oneMinusRho = globals_1.keep(ops_1.scalar(1 - rho));
        return _this;
    }
    AdadeltaOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedGrads[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedGrads[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            if (this_1.accumulatedUpdates[variableName] == null) {
                var trainable_2 = false;
                globals_1.tidy(function () {
                    _this.accumulatedUpdates[variableName] =
                        ops_1.zerosLike(value).variable(trainable_2);
                });
            }
            var gradient = variableGradients[variableName];
            var accumulatedGrad = this_1.accumulatedGrads[variableName];
            var accumulatedUpdate = this_1.accumulatedUpdates[variableName];
            globals_1.tidy(function () {
                var newAccumulatedGrad = _this.rhoScalar.mul(accumulatedGrad)
                    .add(_this.oneMinusRho.mul(gradient.square()));
                var updates = accumulatedUpdate.add(_this.epsilonScalar)
                    .sqrt()
                    .div(accumulatedGrad.add(_this.epsilonScalar).sqrt())
                    .mul(gradient);
                var newAccumulatedUpdate = _this.rhoScalar.mul(accumulatedUpdate)
                    .add(_this.oneMinusRho.mul(updates.square()));
                _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                _this.accumulatedUpdates[variableName].assign(newAccumulatedUpdate);
                var newValue = _this.c.mul(updates).add(value);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    AdadeltaOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsilonScalar.dispose();
        this.rhoScalar.dispose();
        this.oneMinusRho.dispose();
        if (this.accumulatedUpdates != null) {
            Object.keys(this.accumulatedUpdates)
                .forEach(function (name) { return _this.accumulatedUpdates[name].dispose(); });
            Object.keys(this.accumulatedGrads)
                .forEach(function (name) { return _this.accumulatedGrads[name].dispose(); });
        }
    };
    AdadeltaOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            rho: this.rho,
            epsilon: this.epsilon
        };
    };
    AdadeltaOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.rho, config.epsilon);
    };
    AdadeltaOptimizer.className = 'AdadeltaOptimizer';
    return AdadeltaOptimizer;
}(optimizer_1.Optimizer));
exports.AdadeltaOptimizer = AdadeltaOptimizer;
serialization_1.SerializationMap.register(AdadeltaOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],138:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdagradOptimizer = (function (_super) {
    __extends(AdagradOptimizer, _super);
    function AdagradOptimizer(learningRate, initialAccumulatorValue) {
        if (initialAccumulatorValue === void 0) { initialAccumulatorValue = 0.1; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.initialAccumulatorValue = initialAccumulatorValue;
        _this.accumulatedGrads = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsilon = globals_1.keep(ops_1.scalar(1e-8));
        return _this;
    }
    AdagradOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedGrads[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedGrads[variableName] =
                        ops_1.fill(value.shape, _this.initialAccumulatorValue)
                            .variable(trainable_1);
                });
            }
            var gradient = variableGradients[variableName];
            var accumulatedGrad = this_1.accumulatedGrads[variableName];
            globals_1.tidy(function () {
                var newAccumulatedGrad = accumulatedGrad.add(gradient.square());
                _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                var newValue = _this.c
                    .mul(gradient.div(newAccumulatedGrad.add(_this.epsilon).sqrt()))
                    .add(value);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    AdagradOptimizer.prototype.dispose = function () {
        var _this = this;
        this.epsilon.dispose();
        this.c.dispose();
        if (this.accumulatedGrads != null) {
            Object.keys(this.accumulatedGrads)
                .forEach(function (name) { return _this.accumulatedGrads[name].dispose(); });
        }
    };
    AdagradOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            initialAccumulatorValue: this.initialAccumulatorValue,
        };
    };
    AdagradOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.initialAccumulatorValue);
    };
    AdagradOptimizer.className = 'AdagradOptimizer';
    return AdagradOptimizer;
}(optimizer_1.Optimizer));
exports.AdagradOptimizer = AdagradOptimizer;
serialization_1.SerializationMap.register(AdagradOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],139:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdamOptimizer = (function (_super) {
    __extends(AdamOptimizer, _super);
    function AdamOptimizer(learningRate, beta1, beta2, epsilon) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.epsilon = epsilon;
        _this.accumulatedFirstMoment = {};
        _this.accumulatedSecondMoment = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsScalar = globals_1.keep(ops_1.scalar(epsilon));
        _this.beta1Scalar = globals_1.keep(ops_1.scalar(beta1));
        _this.beta2Scalar = globals_1.keep(ops_1.scalar(beta2));
        globals_1.tidy(function () {
            _this.accBeta1 = ops_1.scalar(beta1).variable();
            _this.accBeta2 = ops_1.scalar(beta2).variable();
        });
        _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
        _this.oneMinusBeta2 = globals_1.keep(ops_1.scalar(1 - beta2));
        _this.one = globals_1.keep(ops_1.scalar(1));
        return _this;
    }
    AdamOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var oneMinusAccBeta2 = _this.one.sub(_this.accBeta2);
            for (var variableName in variableGradients) {
                var value = environment_1.ENV.engine.registeredVariables[variableName];
                if (_this.accumulatedFirstMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedFirstMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                if (_this.accumulatedSecondMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedSecondMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                var gradient = variableGradients[variableName];
                var firstMoment = _this.accumulatedFirstMoment[variableName];
                var secondMoment = _this.accumulatedSecondMoment[variableName];
                var newFirstMoment = _this.beta1Scalar.mul(firstMoment)
                    .add(_this.oneMinusBeta1.mul(gradient));
                var newSecondMoment = _this.beta2Scalar.mul(secondMoment)
                    .add(_this.oneMinusBeta2.mul(gradient.square()));
                var biasCorrectedFirstMoment = newFirstMoment.div(oneMinusAccBeta1);
                var biasCorrectedSecondMoment = newSecondMoment.div(oneMinusAccBeta2);
                _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                _this.accumulatedSecondMoment[variableName].assign(newSecondMoment);
                var newValue = _this.c
                    .mul(biasCorrectedFirstMoment.div(_this.epsScalar.add(biasCorrectedSecondMoment.sqrt())))
                    .add(value);
                value.assign(newValue);
            }
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar));
            _this.accBeta2.assign(_this.accBeta2.mul(_this.beta2Scalar));
        });
    };
    AdamOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsScalar.dispose();
        this.beta1Scalar.dispose();
        this.beta2Scalar.dispose();
        this.accBeta1.dispose();
        this.accBeta2.dispose();
        this.oneMinusBeta1.dispose();
        this.oneMinusBeta2.dispose();
        this.one.dispose();
        if (this.accumulatedFirstMoment != null) {
            Object.keys(this.accumulatedFirstMoment)
                .forEach(function (name) { return _this.accumulatedFirstMoment[name].dispose(); });
        }
        if (this.accumulatedSecondMoment != null) {
            Object.keys(this.accumulatedSecondMoment)
                .forEach(function (name) { return _this.accumulatedSecondMoment[name].dispose(); });
        }
    };
    AdamOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
        };
    };
    AdamOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.beta1, config.beta2, config.epsilon);
    };
    AdamOptimizer.className = 'AdamOptimizer';
    return AdamOptimizer;
}(optimizer_1.Optimizer));
exports.AdamOptimizer = AdamOptimizer;
serialization_1.SerializationMap.register(AdamOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],140:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var AdamaxOptimizer = (function (_super) {
    __extends(AdamaxOptimizer, _super);
    function AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (decay === void 0) { decay = 0.0; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.beta1 = beta1;
        _this.beta2 = beta2;
        _this.epsilon = epsilon;
        _this.decay = decay;
        _this.accumulatedFirstMoment = {};
        _this.accumulatedWeightedInfNorm = {};
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsScalar = globals_1.keep(ops_1.scalar(epsilon));
        _this.beta1Scalar = globals_1.keep(ops_1.scalar(beta1));
        _this.beta2Scalar = globals_1.keep(ops_1.scalar(beta2));
        _this.decayScalar = globals_1.keep(ops_1.scalar(decay));
        globals_1.tidy(function () {
            _this.iteration = ops_1.scalar(0).variable();
            _this.accBeta1 = ops_1.scalar(beta1).variable();
        });
        _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
        _this.one = globals_1.keep(ops_1.scalar(1));
        return _this;
    }
    AdamaxOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var lr = _this.c.div(_this.one.add(_this.decayScalar.mul(_this.iteration)));
            for (var variableName in variableGradients) {
                var value = environment_1.ENV.engine.registeredVariables[variableName];
                if (_this.accumulatedFirstMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedFirstMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                if (_this.accumulatedWeightedInfNorm[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedWeightedInfNorm[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                var gradient = variableGradients[variableName];
                var firstMoment = _this.accumulatedFirstMoment[variableName];
                var weightedInfNorm = _this.accumulatedWeightedInfNorm[variableName];
                var newFirstMoment = _this.beta1Scalar.mul(firstMoment)
                    .add(_this.oneMinusBeta1.mul(gradient));
                var ut0 = _this.beta2Scalar.mul(weightedInfNorm);
                var ut1 = gradient.abs();
                var newWeightedInfNorm = ut0.maximum(ut1);
                _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                _this.accumulatedWeightedInfNorm[variableName].assign(newWeightedInfNorm);
                var newValue = lr.div(oneMinusAccBeta1)
                    .mul(newFirstMoment.div(_this.epsScalar.add(newWeightedInfNorm)))
                    .add(value);
                value.assign(newValue);
            }
            _this.iteration.assign(_this.iteration.add(_this.one));
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar));
        });
    };
    AdamaxOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsScalar.dispose();
        this.accBeta1.dispose();
        this.beta1Scalar.dispose();
        this.beta2Scalar.dispose();
        this.oneMinusBeta1.dispose();
        this.decayScalar.dispose();
        this.iteration.dispose();
        this.one.dispose();
        if (this.accumulatedFirstMoment != null) {
            Object.keys(this.accumulatedFirstMoment)
                .forEach(function (name) { return _this.accumulatedFirstMoment[name].dispose(); });
        }
        if (this.accumulatedWeightedInfNorm != null) {
            Object.keys(this.accumulatedWeightedInfNorm)
                .forEach(function (name) { return _this.accumulatedWeightedInfNorm[name].dispose(); });
        }
    };
    AdamaxOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
            decay: this.decay
        };
    };
    AdamaxOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.beta1, config.beta2, config.epsilon, config.decay);
    };
    AdamaxOptimizer.className = 'AdamaxOptimizer';
    return AdamaxOptimizer;
}(optimizer_1.Optimizer));
exports.AdamaxOptimizer = AdamaxOptimizer;
serialization_1.SerializationMap.register(AdamaxOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],141:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var sgd_optimizer_1 = require("./sgd_optimizer");
var MomentumOptimizer = (function (_super) {
    __extends(MomentumOptimizer, _super);
    function MomentumOptimizer(learningRate, momentum, useNesterov) {
        if (useNesterov === void 0) { useNesterov = false; }
        var _this = _super.call(this, learningRate) || this;
        _this.learningRate = learningRate;
        _this.momentum = momentum;
        _this.useNesterov = useNesterov;
        _this.m = ops_1.scalar(_this.momentum);
        _this.accumulations = {};
        return _this;
    }
    MomentumOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulations[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulations[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            var accumulation = this_1.accumulations[variableName];
            var gradient = variableGradients[variableName];
            globals_1.tidy(function () {
                var newValue;
                var newAccumulation = _this.m.mul(accumulation).add(gradient);
                if (_this.useNesterov) {
                    newValue =
                        _this.c.mul(gradient.add(newAccumulation.mul(_this.m))).add(value);
                }
                else {
                    newValue = _this.c.mul(newAccumulation).add(value);
                }
                _this.accumulations[variableName].assign(newAccumulation);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    MomentumOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.m.dispose();
        if (this.accumulations != null) {
            for (var variableName in this.accumulations) {
                this.accumulations[variableName].dispose();
            }
        }
    };
    MomentumOptimizer.prototype.setMomentum = function (momentum) {
        this.momentum = momentum;
    };
    MomentumOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            momentum: this.momentum,
            useNesterov: this.useNesterov
        };
    };
    MomentumOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.momentum, config.useNesterov);
    };
    MomentumOptimizer.className = 'MomentumOptimizer';
    return MomentumOptimizer;
}(sgd_optimizer_1.SGDOptimizer));
exports.MomentumOptimizer = MomentumOptimizer;
serialization_1.SerializationMap.register(MomentumOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./sgd_optimizer":145}],142:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var globals_1 = require("../globals");
var serialization_1 = require("../serialization");
var Optimizer = (function (_super) {
    __extends(Optimizer, _super);
    function Optimizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Optimizer.prototype.minimize = function (f, returnCost, varList) {
        if (returnCost === void 0) { returnCost = false; }
        var _a = this.computeGradients(f, varList), value = _a.value, grads = _a.grads;
        this.applyGradients(grads);
        var varNames = Object.keys(grads);
        varNames.forEach(function (varName) { return grads[varName].dispose(); });
        if (returnCost) {
            return value;
        }
        else {
            value.dispose();
            return null;
        }
    };
    Optimizer.prototype.computeGradients = function (f, varList) {
        return globals_1.variableGrads(f, varList);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers' })
    ], Optimizer.prototype, "minimize", null);
    Optimizer = __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Classes', namespace: 'train' })
    ], Optimizer);
    return Optimizer;
}(serialization_1.Serializable));
exports.Optimizer = Optimizer;

},{"../doc":46,"../globals":49,"../serialization":147}],143:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var adadelta_optimizer_1 = require("./adadelta_optimizer");
var adagrad_optimizer_1 = require("./adagrad_optimizer");
var adam_optimizer_1 = require("./adam_optimizer");
var adamax_optimizer_1 = require("./adamax_optimizer");
var momentum_optimizer_1 = require("./momentum_optimizer");
var rmsprop_optimizer_1 = require("./rmsprop_optimizer");
var sgd_optimizer_1 = require("./sgd_optimizer");
var OptimizerConstructors = (function () {
    function OptimizerConstructors() {
    }
    OptimizerConstructors.sgd = function (learningRate) {
        return new sgd_optimizer_1.SGDOptimizer(learningRate);
    };
    OptimizerConstructors.momentum = function (learningRate, momentum, useNesterov) {
        if (useNesterov === void 0) { useNesterov = false; }
        return new momentum_optimizer_1.MomentumOptimizer(learningRate, momentum, useNesterov);
    };
    OptimizerConstructors.rmsprop = function (learningRate, decay, momentum, epsilon, centered) {
        if (decay === void 0) { decay = .9; }
        if (momentum === void 0) { momentum = 0.0; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (centered === void 0) { centered = false; }
        return new rmsprop_optimizer_1.RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered);
    };
    OptimizerConstructors.adam = function (learningRate, beta1, beta2, epsilon) {
        if (learningRate === void 0) { learningRate = 0.001; }
        if (beta1 === void 0) { beta1 = 0.9; }
        if (beta2 === void 0) { beta2 = 0.999; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        return new adam_optimizer_1.AdamOptimizer(learningRate, beta1, beta2, epsilon);
    };
    OptimizerConstructors.adadelta = function (learningRate, rho, epsilon) {
        if (learningRate === void 0) { learningRate = .001; }
        if (rho === void 0) { rho = .95; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        return new adadelta_optimizer_1.AdadeltaOptimizer(learningRate, rho, epsilon);
    };
    OptimizerConstructors.adamax = function (learningRate, beta1, beta2, epsilon, decay) {
        if (learningRate === void 0) { learningRate = 0.002; }
        if (beta1 === void 0) { beta1 = 0.9; }
        if (beta2 === void 0) { beta2 = 0.999; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (decay === void 0) { decay = 0.0; }
        return new adamax_optimizer_1.AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay);
    };
    OptimizerConstructors.adagrad = function (learningRate, initialAccumulatorValue) {
        if (initialAccumulatorValue === void 0) { initialAccumulatorValue = 0.1; }
        return new adagrad_optimizer_1.AdagradOptimizer(learningRate, initialAccumulatorValue);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "sgd", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "momentum", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "rmsprop", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adam", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adadelta", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adamax", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adagrad", null);
    return OptimizerConstructors;
}());
exports.OptimizerConstructors = OptimizerConstructors;

},{"../doc":46,"./adadelta_optimizer":137,"./adagrad_optimizer":138,"./adam_optimizer":139,"./adamax_optimizer":140,"./momentum_optimizer":141,"./rmsprop_optimizer":144,"./sgd_optimizer":145}],144:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var RMSPropOptimizer = (function (_super) {
    __extends(RMSPropOptimizer, _super);
    function RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered) {
        if (decay === void 0) { decay = 0.9; }
        if (momentum === void 0) { momentum = 0.0; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (centered === void 0) { centered = false; }
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.decay = decay;
        _this.momentum = momentum;
        _this.epsilon = epsilon;
        _this.accumulatedMeanSquares = {};
        _this.accumulatedMeanGrads = {};
        _this.accumulatedMoments = {};
        _this.c = globals_1.keep(ops_1.scalar(learningRate));
        _this.epsilonScalar = globals_1.keep(ops_1.scalar(epsilon));
        _this.decayScalar = globals_1.keep(ops_1.scalar(decay));
        _this.momentumScalar = globals_1.keep(ops_1.scalar(momentum));
        _this.oneMinusDecay = globals_1.keep(ops_1.scalar(1 - decay));
        _this.centered = centered;
        return _this;
    }
    RMSPropOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedMeanSquares[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMeanSquares[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            if (this_1.accumulatedMeanGrads[variableName] == null && this_1.centered) {
                var trainable_2 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMeanGrads[variableName] =
                        ops_1.zerosLike(value).variable(trainable_2);
                });
            }
            if (this_1.accumulatedMoments[variableName] == null) {
                var trainable_3 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMoments[variableName] =
                        ops_1.zerosLike(value).variable(trainable_3);
                });
            }
            var accumulatedMeanSquare = this_1.accumulatedMeanSquares[variableName];
            var accumulatedMeanGrad = this_1.accumulatedMeanGrads[variableName];
            var accumulatedMoments = this_1.accumulatedMoments[variableName];
            var gradient = variableGradients[variableName];
            globals_1.tidy(function () {
                var newAccumulatedMeanSquare = _this.decayScalar.mul(accumulatedMeanSquare)
                    .add(_this.oneMinusDecay.mul(gradient.square()));
                if (_this.centered) {
                    var newAccumulatedMeanGrad = _this.decayScalar.mul(accumulatedMeanGrad)
                        .add(_this.oneMinusDecay.mul(gradient));
                    var newAccumulatedMoments = _this.momentumScalar.mul(accumulatedMoments)
                        .add(_this.c.mul(gradient).div(newAccumulatedMeanSquare
                        .sub(newAccumulatedMeanGrad.square().add(_this.epsilonScalar))
                        .sqrt()));
                    _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare);
                    _this.accumulatedMeanGrads[variableName].assign(newAccumulatedMeanGrad);
                    _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                    var newValue = value.sub(newAccumulatedMoments);
                    value.assign(newValue);
                }
                else {
                    var newAccumulatedMeanSquare_1 = _this.decayScalar.mul(accumulatedMeanSquare)
                        .add(_this.oneMinusDecay.mul(gradient.square()));
                    var newAccumulatedMoments = _this.momentumScalar.mul(accumulatedMoments)
                        .add(_this.c.mul(gradient).div(newAccumulatedMeanSquare_1.add(_this.epsilonScalar).sqrt()));
                    _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare_1);
                    _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                    var newValue = value.sub(newAccumulatedMoments);
                    value.assign(newValue);
                }
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    RMSPropOptimizer.prototype.dispose = function () {
        var _this = this;
        this.c.dispose();
        this.epsilonScalar.dispose();
        this.decayScalar.dispose();
        this.momentumScalar.dispose();
        this.oneMinusDecay.dispose();
        if (this.accumulatedMeanSquares != null) {
            Object.keys(this.accumulatedMeanSquares)
                .forEach(function (name) { return _this.accumulatedMeanSquares[name].dispose(); });
        }
        if (this.accumulatedMeanGrads != null && this.centered) {
            Object.keys(this.accumulatedMeanGrads)
                .forEach(function (name) { return _this.accumulatedMeanGrads[name].dispose(); });
        }
        if (this.accumulatedMoments != null) {
            Object.keys(this.accumulatedMoments)
                .forEach(function (name) { return _this.accumulatedMoments[name].dispose(); });
        }
    };
    RMSPropOptimizer.prototype.getConfig = function () {
        return {
            learningRate: this.learningRate,
            decay: this.decay,
            momentum: this.momentum,
            epsilon: this.epsilon,
            centered: this.centered
        };
    };
    RMSPropOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate, config.decay, config.momentum, config.epsilon, config.centered);
    };
    RMSPropOptimizer.className = 'RMSPropOptimizer';
    return RMSPropOptimizer;
}(optimizer_1.Optimizer));
exports.RMSPropOptimizer = RMSPropOptimizer;
serialization_1.SerializationMap.register(RMSPropOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var ops_1 = require("../ops/ops");
var serialization_1 = require("../serialization");
var optimizer_1 = require("./optimizer");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate) {
        var _this = _super.call(this) || this;
        _this.learningRate = learningRate;
        _this.setLearningRate(learningRate);
        return _this;
    }
    SGDOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var varNames = Object.keys(variableGradients);
        varNames.forEach(function (varName) {
            var gradient = variableGradients[varName];
            var value = environment_1.ENV.engine.registeredVariables[varName];
            globals_1.tidy(function () {
                var newValue = _this.c.mul(gradient).add(value);
                value.assign(newValue);
            });
        });
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
        if (this.c != null) {
            this.c.dispose();
        }
        this.c = globals_1.keep(ops_1.scalar(-learningRate));
    };
    SGDOptimizer.prototype.dispose = function () {
        this.c.dispose();
    };
    SGDOptimizer.prototype.getConfig = function () {
        return { learningRate: this.learningRate };
    };
    SGDOptimizer.fromConfig = function (cls, config) {
        return new cls(config.learningRate);
    };
    SGDOptimizer.className = 'SGDOptimizer';
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;
serialization_1.SerializationMap.register(SGDOptimizer);

},{"../environment":48,"../globals":49,"../ops/ops":124,"../serialization":147,"./optimizer":142}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var Profiler = (function () {
    function Profiler(backendTimer, logger) {
        this.backendTimer = backendTimer;
        this.logger = logger;
        if (logger == null) {
            this.logger = new Logger();
        }
    }
    Profiler.prototype.profileKernel = function (name, f) {
        var _this = this;
        var result;
        var holdResultWrapperFn = function () {
            result = f();
        };
        var timer = this.backendTimer.time(holdResultWrapperFn);
        var vals = result.dataSync();
        util.checkForNaN(vals, result.dtype, name);
        timer.then(function (timing) {
            _this.logger.logKernelProfile(name, result, vals, timing.kernelMs);
        });
        return result;
    };
    return Profiler;
}());
exports.Profiler = Profiler;
var Logger = (function () {
    function Logger() {
    }
    Logger.prototype.logKernelProfile = function (name, result, vals, timeMs) {
        var time = util.rightPad(timeMs + "ms", 9);
        var paddedName = util.rightPad(name, 25);
        var rank = result.rank;
        var size = result.size;
        var shape = util.rightPad(result.shape.toString(), 14);
        console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
    };
    return Logger;
}());
exports.Logger = Logger;

},{"./util":155}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Serializable = (function () {
    function Serializable() {
    }
    Serializable.prototype.getClassName = function () {
        return this.constructor
            .className;
    };
    Serializable.fromConfig = function (cls, config) {
        return new cls(config);
    };
    return Serializable;
}());
exports.Serializable = Serializable;
var SerializationMap = (function () {
    function SerializationMap() {
        this.classNameMap = {};
    }
    SerializationMap.getMap = function () {
        if (SerializationMap.instance == null) {
            SerializationMap.instance = new SerializationMap();
        }
        return SerializationMap.instance;
    };
    SerializationMap.register = function (cls) {
        this.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
    };
    return SerializationMap;
}());
exports.SerializationMap = SerializationMap;

},{}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
function getFilteredNodesXToY(tape, xs, y) {
    var tensorsFromX = {};
    var nodesFromX = {};
    for (var i = 0; i < xs.length; i++) {
        tensorsFromX[xs[i].id] = true;
    }
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        var nodeInputs = node.inputs;
        for (var inputName in nodeInputs) {
            var input = nodeInputs[inputName];
            var anyInputFromX = false;
            for (var j = 0; j < xs.length; j++) {
                if (tensorsFromX[input.id]) {
                    tensorsFromX[node.output.id] = true;
                    anyInputFromX = true;
                    nodesFromX[node.id] = true;
                    break;
                }
            }
            if (anyInputFromX) {
                break;
            }
        }
    }
    var tensorsLeadToY = {};
    tensorsLeadToY[y.id] = true;
    var nodesToY = {};
    for (var i = tape.length - 1; i >= 0; i--) {
        var node = tape[i];
        var nodeInputs = node.inputs;
        var outputs = [];
        outputs.push(node.output);
        for (var j = 0; j < outputs.length; j++) {
            if (tensorsLeadToY[outputs[j].id]) {
                for (var inputName in nodeInputs) {
                    tensorsLeadToY[nodeInputs[inputName].id] = true;
                    nodesToY[node.id] = true;
                }
                break;
            }
        }
    }
    var filteredTape = [];
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
            var prunedInputs = {};
            for (var inputName in node.inputs) {
                var nodeInput = node.inputs[inputName];
                if (tensorsFromX[nodeInput.id]) {
                    prunedInputs[inputName] = nodeInput;
                }
            }
            var prunedNode = Object.assign({}, node);
            prunedNode.inputs = prunedInputs;
            prunedNode.output = node.output;
            filteredTape.push(prunedNode);
        }
    }
    return filteredTape;
}
exports.getFilteredNodesXToY = getFilteredNodesXToY;
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape) {
    for (var i = filteredTape.length - 1; i >= 0; i--) {
        var node = filteredTape[i];
        var dy = tensorAccumulatedGradientMap[node.output.id];
        if (node.gradient == null) {
            throw new Error("Cannot compute gradient: gradient function not found " +
                ("for " + node.name + "."));
        }
        var inputGradients = node.gradient(dy);
        for (var inputName in node.inputs) {
            if (!(inputName in inputGradients)) {
                throw new Error("Cannot backprop through input " + inputName + ". " +
                    ("Available gradients found: " + Object.keys(inputGradients) + "."));
            }
            var dx = inputGradients[inputName]();
            var x = node.inputs[inputName];
            if (!util.arraysEqual(dx.shape, x.shape)) {
                throw new Error("Error in gradient for op " + node.name + ". The gradient of input " +
                    ("'" + inputName + "' has shape '" + dx.shape + "', which does not match ") +
                    ("the shape of the input '" + x.shape + "'"));
            }
            if (tensorAccumulatedGradientMap[x.id] == null) {
                tensorAccumulatedGradientMap[x.id] = dx;
            }
            else {
                var curGradient = tensorAccumulatedGradientMap[x.id];
                tensorAccumulatedGradientMap[x.id] = curGradient.add(dx);
                curGradient.dispose();
            }
        }
    }
}
exports.backpropagateGradients = backpropagateGradients;

},{"./util":155}],149:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var ops = require("./ops/ops");
var tensor_util = require("./tensor_util");
var util = require("./util");
var TensorBuffer = (function () {
    function TensorBuffer(shape, dtype, values) {
        this.dtype = dtype;
        if (values != null) {
            var n = values.length;
            var size = util.sizeFromShape(shape);
            util.assert(n === size, "Length of values '" + n + "' does not match the size " +
                ("inferred by the shape '" + size + "'"));
        }
        this.shape = shape.slice();
        this.values =
            values || util.getTypedArrayFromDType(dtype, util.sizeFromShape(shape));
        this.strides = computeStrides(shape);
        this.size = util.sizeFromShape(shape);
    }
    TensorBuffer.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        util.assert(locs.length === this.rank, "The number of provided coordinates (" + locs.length + ") must " +
            ("match the rank (" + this.rank + ")"));
        var index = this.locToIndex(locs);
        this.values[index] = value;
    };
    TensorBuffer.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.values[index];
    };
    TensorBuffer.prototype.locToIndex = function (locs) {
        if (this.rank === 0) {
            return 0;
        }
        else if (this.rank === 1) {
            return locs[0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    TensorBuffer.prototype.indexToLoc = function (index) {
        if (this.rank === 0) {
            return [];
        }
        else if (this.rank === 1) {
            return [index];
        }
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    Object.defineProperty(TensorBuffer.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    TensorBuffer.prototype.toTensor = function () {
        return Tensor.make(this.shape, { values: this.values }, this.dtype);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "set", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "get", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "toTensor", null);
    TensorBuffer = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], TensorBuffer);
    return TensorBuffer;
}());
exports.TensorBuffer = TensorBuffer;
var Tensor = (function () {
    function Tensor(shape, dtype, values, dataId) {
        this.isDisposedInternal = false;
        this.size = util.sizeFromShape(shape);
        if (values != null) {
            util.assert(this.size === values.length, "Constructing tensor of shape (" + this.size + ") should match the " +
                ("length of values (" + values.length + ")"));
        }
        this.shape = shape.slice();
        this.dtype = dtype || 'float32';
        this.strides = computeStrides(shape);
        this.dataId = dataId != null ? dataId : {};
        this.id = Tensor_1.nextId++;
        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');
        environment_1.ENV.engine.registerTensor(this);
        if (values != null) {
            environment_1.ENV.engine.write(this.dataId, values);
        }
    }
    Tensor_1 = Tensor;
    Tensor.make = function (shape, data, dtype) {
        return new Tensor_1(shape, dtype, data.values, data.dataId);
    };
    Tensor.prototype.flatten = function () {
        this.throwIfDisposed();
        return this.as1D();
    };
    Tensor.prototype.asScalar = function () {
        this.throwIfDisposed();
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    Tensor.prototype.as1D = function () {
        this.throwIfDisposed();
        return this.reshape([this.size]);
    };
    Tensor.prototype.as2D = function (rows, columns) {
        this.throwIfDisposed();
        return this.reshape([rows, columns]);
    };
    Tensor.prototype.as3D = function (rows, columns, depth) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth]);
    };
    Tensor.prototype.as4D = function (rows, columns, depth, depth2) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth, depth2]);
    };
    Tensor.prototype.asType = function (dtype) {
        this.throwIfDisposed();
        return ops.cast(this, dtype);
    };
    Object.defineProperty(Tensor.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        util.assert(locs.length === this.rank, 'Number of coordinates in get() must match the rank of the tensor');
        this.throwIfDisposed();
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.dataSync()[index];
    };
    Tensor.prototype.buffer = function () {
        return ops.buffer(this.shape, this.dtype, this.dataSync());
    };
    Tensor.prototype.data = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.throwIfDisposed();
                return [2, environment_1.ENV.engine.read(this.dataId)];
            });
        });
    };
    Tensor.prototype.dataSync = function () {
        this.throwIfDisposed();
        return environment_1.ENV.engine.readSync(this.dataId);
    };
    Tensor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        environment_1.ENV.engine.disposeTensor(this);
        this.isDisposedInternal = true;
    };
    Object.defineProperty(Tensor.prototype, "isDisposed", {
        get: function () {
            return this.isDisposedInternal;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.throwIfDisposed = function () {
        if (this.isDisposed) {
            throw new Error("Tensor is disposed.");
        }
    };
    Tensor.prototype.toFloat = function () {
        return this.asType('float32');
    };
    Tensor.prototype.toInt = function () {
        return this.asType('int32');
    };
    Tensor.prototype.toBool = function () {
        return this.asType('bool');
    };
    Tensor.prototype.print = function (verbose) {
        if (verbose === void 0) { verbose = false; }
        return ops.print(this, verbose);
    };
    Tensor.prototype.reshape = function (newShape) {
        this.throwIfDisposed();
        return ops.reshape(this, newShape);
    };
    Tensor.prototype.reshapeAs = function (x) {
        this.throwIfDisposed();
        return this.reshape(x.shape);
    };
    Tensor.prototype.expandDims = function (axis) {
        if (axis === void 0) { axis = 0; }
        return ops.expandDims(this, axis);
    };
    Tensor.prototype.cumsum = function (axis, exclusive, reverse) {
        if (axis === void 0) { axis = 0; }
        if (exclusive === void 0) { exclusive = false; }
        if (reverse === void 0) { reverse = false; }
        return ops.cumsum(this, axis, exclusive, reverse);
    };
    Tensor.prototype.squeeze = function (axis) {
        this.throwIfDisposed();
        return ops.squeeze(this, axis);
    };
    Tensor.prototype.clone = function () {
        this.throwIfDisposed();
        return ops.clone(this);
    };
    Tensor.prototype.toString = function (verbose) {
        if (verbose === void 0) { verbose = false; }
        return tensor_util.tensorToString(this, verbose);
    };
    Tensor.prototype.tile = function (reps) {
        this.throwIfDisposed();
        return ops.tile(this, reps);
    };
    Tensor.prototype.gather = function (indices, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.gather(this, indices, axis);
    };
    Tensor.prototype.matMul = function (b, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.throwIfDisposed();
        return ops.matMul(this, b, transposeA, transposeB);
    };
    Tensor.prototype.dot = function (b) {
        this.throwIfDisposed();
        return ops.dot(this, b);
    };
    Tensor.prototype.norm = function (ord, axis, keepDims) {
        if (ord === void 0) { ord = 'euclidean'; }
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.norm(this, ord, axis, keepDims);
    };
    Tensor.prototype.slice = function (begin, size) {
        this.throwIfDisposed();
        return ops.slice(this, begin, size);
    };
    Tensor.prototype.reverse = function (axis) {
        this.throwIfDisposed();
        return ops.reverse(this, axis);
    };
    Tensor.prototype.concat = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.concat([this, x], axis);
    };
    Tensor.prototype.stack = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        return ops.stack([this, x], axis);
    };
    Tensor.prototype.unstack = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        return ops.unstack(this, axis);
    };
    Tensor.prototype.pad = function (paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        return ops.pad(this, paddings, constantValue);
    };
    Tensor.prototype.batchNormalization = function (mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        this.throwIfDisposed();
        return ops.batchNormalization(this, mean, variance, varianceEpsilon, scale, offset);
    };
    Tensor.prototype.logSumExp = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.logSumExp(this, axis, keepDims);
    };
    Tensor.prototype.sum = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.sum(this, axis, keepDims);
    };
    Tensor.prototype.mean = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.mean(this, axis, keepDims);
    };
    Tensor.prototype.min = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.min(this, axis, keepDims);
    };
    Tensor.prototype.max = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.max(this, axis, keepDims);
    };
    Tensor.prototype.argMin = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return ops.argMin(this, axis);
    };
    Tensor.prototype.argMax = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return ops.argMax(this, axis);
    };
    Tensor.prototype.cast = function (dtype) {
        this.throwIfDisposed();
        return ops.cast(this, dtype);
    };
    Tensor.prototype.add = function (x) {
        this.throwIfDisposed();
        return ops.add(this, x);
    };
    Tensor.prototype.addStrict = function (x) {
        this.throwIfDisposed();
        return ops.addStrict(this, x);
    };
    Tensor.prototype.sub = function (x) {
        this.throwIfDisposed();
        return ops.sub(this, x);
    };
    Tensor.prototype.subStrict = function (x) {
        this.throwIfDisposed();
        return ops.subStrict(this, x);
    };
    Tensor.prototype.pow = function (exp) {
        this.throwIfDisposed();
        return ops.pow(this, exp);
    };
    Tensor.prototype.powStrict = function (exp) {
        this.throwIfDisposed();
        return ops.powStrict(this, exp);
    };
    Tensor.prototype.mul = function (x) {
        this.throwIfDisposed();
        return ops.mul(this, x);
    };
    Tensor.prototype.mulStrict = function (x) {
        this.throwIfDisposed();
        return ops.mulStrict(this, x);
    };
    Tensor.prototype.div = function (x) {
        this.throwIfDisposed();
        return ops.div(this, x);
    };
    Tensor.prototype.floorDiv = function (x) {
        this.throwIfDisposed();
        return ops.floorDiv(this, x);
    };
    Tensor.prototype.divStrict = function (x) {
        this.throwIfDisposed();
        return ops.divStrict(this, x);
    };
    Tensor.prototype.minimum = function (x) {
        this.throwIfDisposed();
        return ops.minimum(this, x);
    };
    Tensor.prototype.minimumStrict = function (x) {
        this.throwIfDisposed();
        return ops.minimumStrict(this, x);
    };
    Tensor.prototype.maximum = function (x) {
        this.throwIfDisposed();
        return ops.maximum(this, x);
    };
    Tensor.prototype.maximumStrict = function (x) {
        this.throwIfDisposed();
        return ops.maximumStrict(this, x);
    };
    Tensor.prototype.mod = function (x) {
        this.throwIfDisposed();
        return ops.mod(this, x);
    };
    Tensor.prototype.modStrict = function (x) {
        this.throwIfDisposed();
        return ops.modStrict(this, x);
    };
    Tensor.prototype.squaredDifference = function (x) {
        this.throwIfDisposed();
        return ops.squaredDifference(this, x);
    };
    Tensor.prototype.squaredDifferenceStrict = function (x) {
        this.throwIfDisposed();
        return ops.squaredDifferenceStrict(this, x);
    };
    Tensor.prototype.transpose = function (perm) {
        this.throwIfDisposed();
        return ops.transpose(this, perm);
    };
    Tensor.prototype.notEqual = function (x) {
        this.throwIfDisposed();
        return ops.notEqual(this, x);
    };
    Tensor.prototype.notEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.notEqualStrict(this, x);
    };
    Tensor.prototype.less = function (x) {
        this.throwIfDisposed();
        return ops.less(this, x);
    };
    Tensor.prototype.lessStrict = function (x) {
        this.throwIfDisposed();
        return ops.lessStrict(this, x);
    };
    Tensor.prototype.equal = function (x) {
        this.throwIfDisposed();
        return ops.equal(this, x);
    };
    Tensor.prototype.equalStrict = function (x) {
        this.throwIfDisposed();
        return ops.equalStrict(this, x);
    };
    Tensor.prototype.lessEqual = function (x) {
        this.throwIfDisposed();
        return ops.lessEqual(this, x);
    };
    Tensor.prototype.lessEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.lessEqualStrict(this, x);
    };
    Tensor.prototype.greater = function (x) {
        this.throwIfDisposed();
        return ops.greater(this, x);
    };
    Tensor.prototype.greaterStrict = function (x) {
        this.throwIfDisposed();
        return ops.greaterStrict(this, x);
    };
    Tensor.prototype.greaterEqual = function (x) {
        this.throwIfDisposed();
        return ops.greaterEqual(this, x);
    };
    Tensor.prototype.greaterEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.greaterEqualStrict(this, x);
    };
    Tensor.prototype.logicalAnd = function (x) {
        this.throwIfDisposed();
        return ops.logicalAnd(this, x);
    };
    Tensor.prototype.logicalOr = function (x) {
        this.throwIfDisposed();
        return ops.logicalOr(this, x);
    };
    Tensor.prototype.logicalNot = function () {
        this.throwIfDisposed();
        return ops.logicalNot(this);
    };
    Tensor.prototype.logicalXor = function (x) {
        this.throwIfDisposed();
        return ops.logicalXor(this, x);
    };
    Tensor.prototype.where = function (condition, x) {
        this.throwIfDisposed();
        return ops.where(condition, this, x);
    };
    Tensor.prototype.neg = function () {
        this.throwIfDisposed();
        return ops.neg(this);
    };
    Tensor.prototype.ceil = function () {
        this.throwIfDisposed();
        return ops.ceil(this);
    };
    Tensor.prototype.floor = function () {
        this.throwIfDisposed();
        return ops.floor(this);
    };
    Tensor.prototype.sign = function () {
        this.throwIfDisposed();
        return ops.sign(this);
    };
    Tensor.prototype.exp = function () {
        this.throwIfDisposed();
        return ops.exp(this);
    };
    Tensor.prototype.expm1 = function () {
        this.throwIfDisposed();
        return ops.expm1(this);
    };
    Tensor.prototype.log = function () {
        this.throwIfDisposed();
        return ops.log(this);
    };
    Tensor.prototype.log1p = function () {
        this.throwIfDisposed();
        return ops.log1p(this);
    };
    Tensor.prototype.sqrt = function () {
        this.throwIfDisposed();
        return ops.sqrt(this);
    };
    Tensor.prototype.rsqrt = function () {
        this.throwIfDisposed();
        return ops.rsqrt(this);
    };
    Tensor.prototype.square = function () {
        this.throwIfDisposed();
        return ops.square(this);
    };
    Tensor.prototype.reciprocal = function () {
        this.throwIfDisposed();
        return ops.reciprocal(this);
    };
    Tensor.prototype.abs = function () {
        this.throwIfDisposed();
        return ops.abs(this);
    };
    Tensor.prototype.clipByValue = function (min, max) {
        this.throwIfDisposed();
        return ops.clipByValue(this, min, max);
    };
    Tensor.prototype.relu = function () {
        this.throwIfDisposed();
        return ops.relu(this);
    };
    Tensor.prototype.elu = function () {
        this.throwIfDisposed();
        return ops.elu(this);
    };
    Tensor.prototype.selu = function () {
        this.throwIfDisposed();
        return ops.selu(this);
    };
    Tensor.prototype.leakyRelu = function (alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        this.throwIfDisposed();
        return ops.leakyRelu(this, alpha);
    };
    Tensor.prototype.prelu = function (alpha) {
        this.throwIfDisposed();
        return ops.prelu(this, alpha);
    };
    Tensor.prototype.sigmoid = function () {
        this.throwIfDisposed();
        return ops.sigmoid(this);
    };
    Tensor.prototype.logSigmoid = function () {
        this.throwIfDisposed();
        return ops.logSigmoid(this);
    };
    Tensor.prototype.softplus = function () {
        this.throwIfDisposed();
        return ops.softplus(this);
    };
    Tensor.prototype.sin = function () {
        this.throwIfDisposed();
        return ops.sin(this);
    };
    Tensor.prototype.cos = function () {
        this.throwIfDisposed();
        return ops.cos(this);
    };
    Tensor.prototype.tan = function () {
        this.throwIfDisposed();
        return ops.tan(this);
    };
    Tensor.prototype.asin = function () {
        this.throwIfDisposed();
        return ops.asin(this);
    };
    Tensor.prototype.acos = function () {
        this.throwIfDisposed();
        return ops.acos(this);
    };
    Tensor.prototype.atan = function () {
        this.throwIfDisposed();
        return ops.atan(this);
    };
    Tensor.prototype.sinh = function () {
        this.throwIfDisposed();
        return ops.sinh(this);
    };
    Tensor.prototype.cosh = function () {
        this.throwIfDisposed();
        return ops.cosh(this);
    };
    Tensor.prototype.tanh = function () {
        this.throwIfDisposed();
        return ops.tanh(this);
    };
    Tensor.prototype.asinh = function () {
        this.throwIfDisposed();
        return ops.asinh(this);
    };
    Tensor.prototype.acosh = function () {
        this.throwIfDisposed();
        return ops.acosh(this);
    };
    Tensor.prototype.atanh = function () {
        this.throwIfDisposed();
        return ops.atanh(this);
    };
    Tensor.prototype.erf = function () {
        this.throwIfDisposed();
        return ops.erf(this);
    };
    Tensor.prototype.round = function () {
        this.throwIfDisposed();
        return ops.round(this);
    };
    Tensor.prototype.step = function (alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        this.throwIfDisposed();
        return ops.step(this, alpha);
    };
    Tensor.prototype.softmax = function (dim) {
        if (dim === void 0) { dim = -1; }
        this.throwIfDisposed();
        return ops.softmax(this, dim);
    };
    Tensor.prototype.resizeBilinear = function (newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        this.throwIfDisposed();
        return ops.image.resizeBilinear(this, newShape2D, alignCorners);
    };
    Tensor.prototype.resizeNearestNeighbor = function (newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        this.throwIfDisposed();
        return ops.image.resizeNearestNeighbor(this, newShape2D, alignCorners);
    };
    Tensor.prototype.conv1d = function (filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NWC'; }
        if (dilation === void 0) { dilation = 1; }
        this.throwIfDisposed();
        return ops.conv1d(this, filter, stride, pad, dataFormat, dilation, dimRoundingMode);
    };
    Tensor.prototype.conv2d = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        this.throwIfDisposed();
        return ops.conv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
    };
    Tensor.prototype.conv2dTranspose = function (filter, outputShape, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.conv2dTranspose(this, filter, outputShape, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.depthwiseConv2D = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
        if (dataFormat === void 0) { dataFormat = 'NHWC'; }
        if (dilations === void 0) { dilations = [1, 1]; }
        this.throwIfDisposed();
        return ops.depthwiseConv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
    };
    Tensor.prototype.avgPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.avgPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.maxPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.maxPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.localResponseNormalization = function (radius, bias, alpha, beta) {
        if (radius === void 0) { radius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        return ops.localResponseNormalization(this, radius, bias, alpha, beta);
    };
    Tensor.prototype.variable = function (trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        this.throwIfDisposed();
        return Variable.variable(this, trainable, name, dtype);
    };
    Tensor.prototype.unsortedSegmentSum = function (segmentIds, numSegments, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.unsortedSegmentSum(this, segmentIds, numSegments, axis);
    };
    Tensor.nextId = 0;
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "flatten", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "asScalar", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as1D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as2D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as3D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as4D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "asType", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "buffer", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "data", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "dataSync", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "dispose", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toFloat", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toInt", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toBool", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "print", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "reshape", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "reshapeAs", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "expandDims", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "cumsum", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "squeeze", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "clone", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toString", null);
    Tensor = Tensor_1 = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor);
    return Tensor;
    var Tensor_1;
}());
exports.Tensor = Tensor;
var Variable = (function (_super) {
    __extends(Variable, _super);
    function Variable(initialValue, trainable, name) {
        if (trainable === void 0) { trainable = true; }
        var _this = _super.call(this, initialValue.shape, initialValue.dtype, null, initialValue.dataId) || this;
        _this.trainable = trainable;
        _this.name = name;
        if (_this.name == null) {
            _this.name = Variable_1.nextVarId.toString();
            Variable_1.nextVarId++;
        }
        environment_1.ENV.engine.registerVariable(_this);
        return _this;
    }
    Variable_1 = Variable;
    Variable.variable = function (initialValue, trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        if (dtype != null && dtype !== initialValue.dtype) {
            initialValue = initialValue.asType(dtype);
        }
        return new Variable_1(initialValue, trainable, name);
    };
    Variable.prototype.assign = function (newValue) {
        if (newValue.dtype !== this.dtype) {
            throw new Error("dtype of the new value (" + newValue.dtype + ") and " +
                ("previous value (" + this.dtype + ") must match"));
        }
        if (!util.arraysEqual(newValue.shape, this.shape)) {
            throw new Error("shape of the new value (" + newValue.shape + ") and " +
                ("previous value (" + this.shape + ") must match"));
        }
        environment_1.ENV.engine.disposeTensor(this);
        this.dataId = newValue.dataId;
        environment_1.ENV.engine.registerTensor(this);
    };
    Variable.nextVarId = 0;
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Variable.prototype, "assign", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], Variable, "variable", null);
    Variable = Variable_1 = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Variable);
    return Variable;
    var Variable_1;
}(Tensor));
exports.Variable = Variable;
var variable = Variable.variable;
exports.variable = variable;
function computeStrides(shape) {
    var rank = shape.length;
    if (rank < 2) {
        return [];
    }
    var strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for (var i = rank - 3; i >= 0; --i) {
        strides[i] = strides[i + 1] * shape[i + 1];
    }
    return strides;
}

},{"./doc":46,"./environment":48,"./ops/ops":124,"./tensor_util":150,"./util":155}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var FORMAT_LIMIT_NUM_VALS = 20;
var FORMAT_NUM_FIRST_LAST_VALS = 3;
var FORMAT_NUM_SIG_DIGITS = 7;
function tensorToString(t, verbose) {
    var vals = t.dataSync();
    var padPerCol = computeMaxSizePerColumn(t);
    var valsLines = subTensorToString(vals, t.shape, t.strides, padPerCol);
    var lines = ['Tensor'];
    if (verbose) {
        lines.push("  dtype: " + t.dtype);
        lines.push("  rank: " + t.rank);
        lines.push("  shape: [" + t.shape + "]");
        lines.push("  values:");
    }
    lines.push(valsLines.map(function (l) { return '    ' + l; }).join('\n'));
    return lines.join('\n');
}
exports.tensorToString = tensorToString;
function computeMaxSizePerColumn(t) {
    var vals = t.dataSync();
    var n = t.size;
    var numCols = t.strides[t.strides.length - 1];
    var padPerCol = new Array(numCols).fill(0);
    if (t.rank > 1) {
        for (var row = 0; row < n / numCols; row++) {
            var offset = row * numCols;
            for (var j = 0; j < numCols; j++) {
                padPerCol[j] =
                    Math.max(padPerCol[j], valToString(vals[offset + j], 0).length);
            }
        }
    }
    return padPerCol;
}
function valToString(val, pad) {
    return util.rightPad(parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(), pad);
}
function subTensorToString(vals, shape, strides, padPerCol, isLast) {
    if (isLast === void 0) { isLast = true; }
    var size = shape[0];
    var rank = shape.length;
    if (rank === 0) {
        return [vals[0].toString()];
    }
    if (rank === 1) {
        if (size > FORMAT_LIMIT_NUM_VALS) {
            var firstVals = Array.from(vals.subarray(0, FORMAT_NUM_FIRST_LAST_VALS));
            var lastVals = Array.from(vals.subarray(size - FORMAT_NUM_FIRST_LAST_VALS, size));
            return [
                '[' + firstVals.map(function (x, i) { return valToString(x, padPerCol[i]); }).join(', ') +
                    ', ..., ' +
                    lastVals
                        .map(function (x, i) { return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i]); })
                        .join(', ') +
                    ']'
            ];
        }
        return [
            '[' +
                Array.from(vals).map(function (x, i) { return valToString(x, padPerCol[i]); }).join(', ') +
                ']'
        ];
    }
    var subshape = shape.slice(1);
    var substrides = strides.slice(1);
    var stride = strides[0];
    var lines = [];
    if (size > FORMAT_LIMIT_NUM_VALS) {
        for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, false));
        }
        lines.push('...');
        for (var i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1));
        }
    }
    else {
        for (var i = 0; i < size; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1));
        }
    }
    var sep = rank === 2 ? ',' : '';
    lines[0] = '[' + lines[0] + sep;
    for (var i = 1; i < lines.length - 1; i++) {
        lines[i] = ' ' + lines[i] + sep;
    }
    var newLineSep = ',\n';
    for (var i = 2; i < rank; i++) {
        newLineSep += '\n';
    }
    lines[lines.length - 1] =
        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);
    return lines;
}

},{"./util":155}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
var util = require("./util");
exports.WEBGL_ENVS = {
    'BACKEND': 'test-webgl'
};
exports.CPU_ENVS = {
    'BACKEND': 'test-cpu'
};
exports.ALL_ENVS = {};
exports.TEST_EPSILON = 1e-3;
function expectArraysClose(actual, expected, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!(actual instanceof tensor_1.Tensor) && !(expected instanceof tensor_1.Tensor)) {
        var aType = actual.constructor.name;
        var bType = expected.constructor.name;
        if (aType !== bType) {
            throw new Error("Arrays are of different type actual: " + aType + " " +
                ("vs expected: " + bType));
        }
    }
    else if (actual instanceof tensor_1.Tensor && expected instanceof tensor_1.Tensor) {
        if (actual.dtype !== expected.dtype) {
            throw new Error("Arrays are of different type actual: " + actual.dtype + " " +
                ("vs expected: " + expected.dtype + "."));
        }
        if (!util.arraysEqual(actual.shape, expected.shape)) {
            throw new Error("Arrays are of different shape actual: " + actual.shape + " " +
                ("vs expected: " + expected.shape + "."));
        }
    }
    var actualValues;
    var expectedValues;
    if (actual instanceof tensor_1.Tensor) {
        actualValues = actual.dataSync();
    }
    else {
        actualValues = actual;
    }
    if (expected instanceof tensor_1.Tensor) {
        expectedValues = expected.dataSync();
    }
    else {
        expectedValues = expected;
    }
    if (actualValues.length !== expectedValues.length) {
        throw new Error("Arrays have different lengths actual: " + actualValues.length + " vs " +
            ("expected: " + expectedValues.length + ".\n") +
            ("Actual:   " + actualValues + ".\n") +
            ("Expected: " + expectedValues + "."));
    }
    for (var i = 0; i < expectedValues.length; ++i) {
        var a = actualValues[i];
        var e = expectedValues[i];
        if (!areClose(a, Number(e), epsilon)) {
            throw new Error("Arrays differ: actual[" + i + "] = " + a + ", expected[" + i + "] = " + e + ".\n" +
                ("Actual:   " + actualValues + ".\n") +
                ("Expected: " + expectedValues + "."));
        }
    }
}
exports.expectArraysClose = expectArraysClose;
function expectPromiseToFail(fn, done) {
    fn().then(function () { return done.fail(); }, function () { return done(); });
}
exports.expectPromiseToFail = expectPromiseToFail;
function expectArraysEqual(actual, expected) {
    return expectArraysClose(actual, expected, 0);
}
exports.expectArraysEqual = expectArraysEqual;
function expectNumbersClose(a, e, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!areClose(a, e, epsilon)) {
        throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
    }
}
exports.expectNumbersClose = expectNumbersClose;
function areClose(a, e, epsilon) {
    if (isNaN(a) && isNaN(e)) {
        return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
        return false;
    }
    return true;
}
function expectValuesInRange(actual, low, high) {
    var actualVals;
    if (actual instanceof tensor_1.Tensor) {
        actualVals = actual.dataSync();
    }
    else {
        actualVals = actual;
    }
    for (var i = 0; i < actualVals.length; i++) {
        if (actualVals[i] < low || actualVals[i] > high) {
            throw new Error("Value out of range:" + actualVals[i] + " low: " + low + ", high: " + high);
        }
    }
}
exports.expectValuesInRange = expectValuesInRange;

},{"./tensor":149,"./util":155}],152:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var util_1 = require("./util");
var Tracking = (function () {
    function Tracking() {
    }
    Tracking.tidy = function (nameOrFn, fn, gradMode) {
        if (gradMode === void 0) { gradMode = false; }
        var name = null;
        if (fn == null) {
            if (typeof nameOrFn !== 'function') {
                throw new Error('Please provide a function to tidy()');
            }
            fn = nameOrFn;
        }
        else {
            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {
                throw new Error('When calling with two arguments, the first argument ' +
                    'to tidy() must be a string');
            }
            if (typeof fn !== 'function') {
                throw new Error('When calling with two arguments, the 2nd argument ' +
                    'to tidy() must be a function');
            }
            name = nameOrFn;
        }
        environment_1.ENV.engine.startScope(name, gradMode);
        var result = fn();
        if (result instanceof Promise) {
            console.error('Cannot return a Promise inside of tidy.');
        }
        environment_1.ENV.engine.endScope(result, gradMode);
        return result;
    };
    Tracking.dispose = function (container) {
        var tensors = util_1.getTensorsInContainer(container);
        tensors.forEach(function (tensor) { return tensor.dispose(); });
    };
    Tracking.keep = function (result) {
        return environment_1.ENV.engine.keep(result);
    };
    Tracking.time = function (f) {
        return environment_1.ENV.engine.time(f);
    };
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Tracking, "tidy", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Tracking, "dispose", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Tracking, "keep", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Timing' })
    ], Tracking, "time", null);
    return Tracking;
}());
exports.Tracking = Tracking;

},{"./doc":46,"./environment":48,"./util":155}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
var adam_optimizer_1 = require("./optimizers/adam_optimizer");
var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
var optimizer_constructors_1 = require("./optimizers/optimizer_constructors");
var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
[momentum_optimizer_1.MomentumOptimizer, sgd_optimizer_1.SGDOptimizer, adadelta_optimizer_1.AdadeltaOptimizer, adagrad_optimizer_1.AdagradOptimizer,
    rmsprop_optimizer_1.RMSPropOptimizer, adamax_optimizer_1.AdamaxOptimizer, adam_optimizer_1.AdamOptimizer];
exports.train = {
    sgd: optimizer_constructors_1.OptimizerConstructors.sgd,
    momentum: optimizer_constructors_1.OptimizerConstructors.momentum,
    adadelta: optimizer_constructors_1.OptimizerConstructors.adadelta,
    adagrad: optimizer_constructors_1.OptimizerConstructors.adagrad,
    rmsprop: optimizer_constructors_1.OptimizerConstructors.rmsprop,
    adamax: optimizer_constructors_1.OptimizerConstructors.adamax,
    adam: optimizer_constructors_1.OptimizerConstructors.adam
};

},{"./optimizers/adadelta_optimizer":137,"./optimizers/adagrad_optimizer":138,"./optimizers/adam_optimizer":139,"./optimizers/adamax_optimizer":140,"./optimizers/momentum_optimizer":141,"./optimizers/optimizer_constructors":143,"./optimizers/rmsprop_optimizer":144,"./optimizers/sgd_optimizer":145}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DType;
(function (DType) {
    DType["float32"] = "float32";
    DType["int32"] = "int32";
    DType["bool"] = "bool";
})(DType = exports.DType || (exports.DType = {}));
var Rank;
(function (Rank) {
    Rank["R0"] = "R0";
    Rank["R1"] = "R1";
    Rank["R2"] = "R2";
    Rank["R3"] = "R3";
    Rank["R4"] = "R4";
    Rank["R5"] = "R5";
})(Rank = exports.Rank || (exports.Rank = {}));
var UpcastInt32AndMap;
(function (UpcastInt32AndMap) {
    UpcastInt32AndMap["float32"] = "float32";
    UpcastInt32AndMap["int32"] = "int32";
    UpcastInt32AndMap["bool"] = "int32";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function (UpcastBoolAndMap) {
    UpcastBoolAndMap["float32"] = "float32";
    UpcastBoolAndMap["int32"] = "int32";
    UpcastBoolAndMap["bool"] = "bool";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function (UpcastFloat32AndMap) {
    UpcastFloat32AndMap["float32"] = "float32";
    UpcastFloat32AndMap["int32"] = "float32";
    UpcastFloat32AndMap["bool"] = "float32";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var upcastTypeMap = {
    float32: UpcastFloat32AndMap,
    int32: UpcastInt32AndMap,
    bool: UpcastBoolAndMap
};
function upcastType(typeA, typeB) {
    return upcastTypeMap[typeA][typeB];
}
exports.upcastType = upcastType;
function sumOutType(type) {
    return upcastType(type, 'int32');
}
exports.sumOutType = sumOutType;

},{}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
function assertArgumentIsTensor(x, argName, functionName) {
    assert(x instanceof tensor_1.Tensor, "Argument '" + argName + "' passed to '" + functionName + "' must be a Tensor, " +
        ("but got " + typeof x + "."));
}
function assertArgumentsAreTensors(args, functionName) {
    var _loop_1 = function (argName) {
        var arg = args[argName];
        if (Array.isArray(arg)) {
            arg.forEach(function (t, i) {
                assertArgumentIsTensor(t, argName + "[" + i + "]", functionName);
            });
        }
        else {
            assertArgumentIsTensor(arg, argName, functionName);
        }
    };
    for (var argName in args) {
        _loop_1(argName);
    }
}
exports.assertArgumentsAreTensors = assertArgumentsAreTensors;
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function assertTypesMatch(a, b) {
    assert(a.dtype === b.dtype, " The dtypes of the first(" + a.dtype + ") and" +
        (" second(" + b.dtype + ") input must match"));
}
exports.assertTypesMatch = assertTypesMatch;
function flatten(arr, ret) {
    if (ret === void 0) { ret = []; }
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; ++i) {
            flatten(arr[i], ret);
        }
    }
    else {
        ret.push(arr);
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(val) {
    if (isTypedArray(val)) {
        return [val.length];
    }
    if (!Array.isArray(val)) {
        return [];
    }
    var shape = [];
    while (val instanceof Array) {
        shape.push(val.length);
        val = val[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
exports.rightPad = rightPad;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
    return new Promise(function (resolve, reject) {
        var tryCount = 0;
        var tryFn = function () {
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            var nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        tryFn();
    });
}
exports.repeatedTry = repeatedTry;
function getQueryParams(queryString) {
    var params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
        var t = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            t[_i - 1] = arguments[_i];
        }
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
exports.getQueryParams = getQueryParams;
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function inferFromImplicitShape(shape, size) {
    var shapeProd = 1;
    var implicitIdx = -1;
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 0) {
            shapeProd *= shape[i];
        }
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " +
                    ("Found - 1 at dim " + implicitIdx + " and dim " + i));
            }
            implicitIdx = i;
        }
        else if (shape[i] <= 0) {
            throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i);
        }
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
            throw Error("Size(" + size + ") must match the product of shape " + shape);
        }
        return shape;
    }
    if (size % shapeProd !== 0) {
        throw Error("The implicit shape can't be a fractional number. " +
            ("Got " + size + " / " + shapeProd));
    }
    var newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
exports.inferFromImplicitShape = inferFromImplicitShape;
function squeezeShape(shape, axis) {
    var newShape = [];
    var keptDims = [];
    var j = 0;
    for (var i = 0; i < shape.length; ++i) {
        if (axis != null) {
            if (axis[j] === i && shape[i] > 1) {
                throw new Error("Can't squeeze axis " + i + " since its dim '" + shape[i] + "' is not 1");
            }
            if ((axis[j] == null || axis[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axis[j] <= i) {
                j++;
            }
        }
        if (shape[i] > 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;
function getTypedArrayFromDType(dtype, size) {
    var values = null;
    if (dtype == null || dtype === 'float32') {
        values = new Float32Array(size);
    }
    else if (dtype === 'int32') {
        values = new Int32Array(size);
    }
    else if (dtype === 'bool') {
        values = new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
    return values;
}
exports.getTypedArrayFromDType = getTypedArrayFromDType;
function isTensorInList(tensor, tensorList) {
    for (var i = 0; i < tensorList.length; i++) {
        if (tensorList[i].id === tensor.id) {
            return true;
        }
    }
    return false;
}
exports.isTensorInList = isTensorInList;
function checkForNaN(vals, dtype, name) {
    if (dtype !== 'float32') {
        return;
    }
    for (var i = 0; i < vals.length; i++) {
        if (isNaN(vals[i])) {
            throw Error("The result of the '" + name + "' has NaNs.");
        }
    }
}
exports.checkForNaN = checkForNaN;
function flattenNameArrayMap(nameArrayMap, keys) {
    var xs = [];
    if (nameArrayMap instanceof tensor_1.Tensor) {
        xs.push(nameArrayMap);
    }
    else {
        var xMap = nameArrayMap;
        for (var i = 0; i < keys.length; i++) {
            xs.push(xMap[keys[i]]);
        }
    }
    return xs;
}
exports.flattenNameArrayMap = flattenNameArrayMap;
function unflattenToNameArrayMap(keys, flatArrays) {
    if (keys.length !== flatArrays.length) {
        throw new Error("Cannot unflatten Tensor[], keys and arrays are not of same length.");
    }
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = flatArrays[i];
    }
    return result;
}
exports.unflattenToNameArrayMap = unflattenToNameArrayMap;
function hasEncodingLoss(oldType, newType) {
    if (newType === 'float32') {
        return false;
    }
    if (newType === 'int32' && oldType !== 'float32') {
        return false;
    }
    if (newType === 'bool' && oldType === 'bool') {
        return false;
    }
    return true;
}
exports.hasEncodingLoss = hasEncodingLoss;
function copyTypedArray(array, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(array);
    }
    else if (dtype === 'int32') {
        return new Int32Array(array);
    }
    else if (dtype === 'bool') {
        var bool = new Uint8Array(array.length);
        for (var i = 0; i < bool.length; ++i) {
            if (Math.round(array[i]) !== 0) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
exports.copyTypedArray = copyTypedArray;
function isTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array;
}
exports.isTypedArray = isTypedArray;
function bytesPerElement(dtype) {
    if (dtype === 'float32' || dtype === 'int32') {
        return 4;
    }
    else if (dtype === 'bool') {
        return 1;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.bytesPerElement = bytesPerElement;
function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
}
exports.isFunction = isFunction;
function getTensorsInContainer(result) {
    var list = [];
    var seen = new Set();
    walkTensorContainer(result, list, seen);
    return list;
}
exports.getTensorsInContainer = getTensorsInContainer;
function walkTensorContainer(container, list, seen) {
    if (container == null) {
        return;
    }
    if (container instanceof tensor_1.Tensor) {
        list.push(container);
        return;
    }
    if (!isIterable(container)) {
        return;
    }
    var iterable = container;
    for (var k in iterable) {
        var val = iterable[k];
        if (!seen.has(val)) {
            seen.add(val);
            walkTensorContainer(val, list, seen);
        }
    }
}
function isIterable(obj) {
    return Array.isArray(obj) || typeof obj === 'object';
}

},{"./tensor":149}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.11.6';
exports.version = version;

},{}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gpgpu_util = require("./kernels/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var webgl_util = require("./kernels/webgl/webgl_util");
exports.webgl_util = webgl_util;
var backend_webgl_1 = require("./kernels/backend_webgl");
exports.MathBackendWebGL = backend_webgl_1.MathBackendWebGL;
var gpgpu_context_1 = require("./kernels/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;

},{"./kernels/backend_webgl":64,"./kernels/webgl/gpgpu_context":78,"./kernels/webgl/gpgpu_util":80,"./kernels/webgl/webgl_util":102}],158:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var generic_utils_1 = require("./utils/generic_utils");
var Activation = (function (_super) {
    __extends(Activation, _super);
    function Activation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Activation.prototype.getConfig = function () {
        return {};
    };
    return Activation;
}(tfjs_core_1.serialization.Serializable));
exports.Activation = Activation;
var Elu = (function (_super) {
    __extends(Elu, _super);
    function Elu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Elu.prototype.apply = function (x, alpha) {
        if (alpha === void 0) { alpha = 1; }
        return K.elu(x, alpha);
    };
    Elu.className = 'elu';
    return Elu;
}(Activation));
exports.Elu = Elu;
tfjs_core_1.serialization.SerializationMap.register(Elu);
var Selu = (function (_super) {
    __extends(Selu, _super);
    function Selu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Selu.prototype.apply = function (x) {
        return tfc.selu(x);
    };
    Selu.className = 'selu';
    return Selu;
}(Activation));
exports.Selu = Selu;
tfjs_core_1.serialization.SerializationMap.register(Selu);
var Relu = (function (_super) {
    __extends(Relu, _super);
    function Relu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Relu.prototype.apply = function (x) {
        return tfc.relu(x);
    };
    Relu.className = 'relu';
    return Relu;
}(Activation));
exports.Relu = Relu;
tfjs_core_1.serialization.SerializationMap.register(Relu);
var Relu6 = (function (_super) {
    __extends(Relu6, _super);
    function Relu6() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Relu6.prototype.apply = function (x) {
        return tfjs_core_1.tidy(function () { return tfc.minimum(K.getScalar(6.0), tfc.relu(x)); });
    };
    Relu6.className = 'relu6';
    return Relu6;
}(Activation));
exports.Relu6 = Relu6;
tfjs_core_1.serialization.SerializationMap.register(Relu6);
var Linear = (function (_super) {
    __extends(Linear, _super);
    function Linear() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Linear.prototype.apply = function (x) {
        return x;
    };
    Linear.className = 'linear';
    return Linear;
}(Activation));
exports.Linear = Linear;
tfjs_core_1.serialization.SerializationMap.register(Linear);
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Sigmoid.prototype.apply = function (x) {
        return tfc.sigmoid(x);
    };
    Sigmoid.className = 'sigmoid';
    return Sigmoid;
}(Activation));
exports.Sigmoid = Sigmoid;
tfjs_core_1.serialization.SerializationMap.register(Sigmoid);
var HardSigmoid = (function (_super) {
    __extends(HardSigmoid, _super);
    function HardSigmoid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HardSigmoid.prototype.apply = function (x) {
        return K.hardSigmoid(x);
    };
    HardSigmoid.className = 'hardSigmoid';
    return HardSigmoid;
}(Activation));
exports.HardSigmoid = HardSigmoid;
tfjs_core_1.serialization.SerializationMap.register(HardSigmoid);
var Softplus = (function (_super) {
    __extends(Softplus, _super);
    function Softplus() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softplus.prototype.apply = function (x) {
        return tfc.softplus(x);
    };
    Softplus.className = 'softplus';
    return Softplus;
}(Activation));
exports.Softplus = Softplus;
tfjs_core_1.serialization.SerializationMap.register(Softplus);
var Softsign = (function (_super) {
    __extends(Softsign, _super);
    function Softsign() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softsign.prototype.apply = function (x) {
        return K.softsign(x);
    };
    Softsign.className = 'softsign';
    return Softsign;
}(Activation));
exports.Softsign = Softsign;
tfjs_core_1.serialization.SerializationMap.register(Softsign);
var Tanh = (function (_super) {
    __extends(Tanh, _super);
    function Tanh() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tanh.prototype.apply = function (x) {
        return tfc.tanh(x);
    };
    Tanh.className = 'tanh';
    return Tanh;
}(Activation));
exports.Tanh = Tanh;
tfjs_core_1.serialization.SerializationMap.register(Tanh);
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Softmax.prototype.apply = function (x, axis) {
        if (axis === void 0) { axis = (-1); }
        return tfc.softmax(x, axis);
    };
    Softmax.className = 'softmax';
    return Softmax;
}(Activation));
exports.Softmax = Softmax;
tfjs_core_1.serialization.SerializationMap.register(Softmax);
function serializeActivation(activation) {
    return activation.getClassName();
}
exports.serializeActivation = serializeActivation;
function deserializeActivation(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'activation');
}
exports.deserializeActivation = deserializeActivation;
function getActivation(identifier) {
    if (identifier == null) {
        var config = { className: 'linear', config: {} };
        return deserializeActivation(config);
    }
    if (typeof identifier === 'string') {
        var config = { className: identifier, config: {} };
        return deserializeActivation(config);
    }
    else if (identifier instanceof Activation) {
        return identifier;
    }
    else {
        return deserializeActivation(identifier);
    }
}
exports.getActivation = getActivation;

},{"./backend/tfjs_backend":160,"./utils/generic_utils":190,"@tensorflow/tfjs-core":51}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _epsilon = 1e-7;
function epsilon() {
    return _epsilon;
}
exports.epsilon = epsilon;
function setEpsilon(e) {
    _epsilon = e;
}
exports.setEpsilon = setEpsilon;
function imageDataFormat() {
    return 'channelsLast';
}
exports.imageDataFormat = imageDataFormat;

},{}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../common");
var errors_1 = require("../errors");
var math_utils = require("../utils/math_utils");
var variables_1 = require("../variables");
var common_2 = require("./common");
var common_3 = require("./common");
var backend = 'webgl';
var DEFAULT_DTYPE = 'float32';
function disposeScalarCache() {
    for (var typeKey in scalarCache) {
        for (var key in scalarCache[typeKey]) {
            scalarCache[typeKey][key].dispose();
            delete scalarCache[typeKey][key];
        }
    }
}
exports.disposeScalarCache = disposeScalarCache;
function setBackend(requestedBackend) {
    tfc.setBackend(requestedBackend);
    backend = requestedBackend;
    disposeScalarCache();
}
exports.setBackend = setBackend;
function getBackend() {
    return backend;
}
exports.getBackend = getBackend;
var scalarCache = {
    float32: {},
    int32: {}
};
function getScalar(value, dtype) {
    if (dtype === undefined) {
        dtype = DEFAULT_DTYPE;
    }
    if (scalarCache[dtype][value] == null) {
        scalarCache[dtype][value] = tfjs_core_1.scalar(value, dtype);
        tfc.keep(scalarCache[dtype][value]);
    }
    return scalarCache[dtype][value];
}
exports.getScalar = getScalar;
exports.epsilon = common_2.epsilon;
function isBackendSymbolic() {
    return false;
}
exports.isBackendSymbolic = isBackendSymbolic;
function shape(x) {
    return x.shape;
}
exports.shape = shape;
function intShape(x) {
    return x.shape;
}
exports.intShape = intShape;
function dtype(x) {
    return (x instanceof tfjs_core_1.Tensor) ? DEFAULT_DTYPE : x.dtype;
}
exports.dtype = dtype;
function countParams(x) {
    var shape = x.shape;
    if (shape.length > 0) {
        return shape.reduce(function (a, b) { return a * b; });
    }
    else {
        return 1;
    }
}
exports.countParams = countParams;
function cast(x, dtype) {
    return x.asType(dtype);
}
exports.cast = cast;
function expandDims(x, axis) {
    if (axis === void 0) { axis = -1; }
    var outShape = shape(x).slice();
    if (axis < 0) {
        axis = outShape.length + axis + 1;
    }
    outShape.splice(axis, 0, 1);
    return x.reshape(outShape);
}
exports.expandDims = expandDims;
function repeat(x, n) {
    return tfjs_core_1.tidy(function () {
        if (x.shape.length !== 2) {
            throw new errors_1.ValueError("repeat() expects a rank-2 tensor, but received a " +
                ("rank-" + x.shape.length + " tensor."));
        }
        var y = expandDims(x, 1);
        return tile(y, [1, n, 1]);
    });
}
exports.repeat = repeat;
function flatten(x) {
    var newShape = [math_utils.arrayProd(x.shape)];
    return x.reshape(newShape);
}
exports.flatten = flatten;
function batchFlatten(x) {
    if (x.rank <= 1) {
        throw new errors_1.ValueError("batchFlatten requires a minimum rank of 2. Got rank: " + x.rank + ".");
    }
    var newShape = [x.shape[0], math_utils.arrayProd(x.shape, 1)];
    return x.reshape(newShape);
}
exports.batchFlatten = batchFlatten;
function sliceAlongFirstAxis(array, start, size) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                return tfc.slice2d(array, [start, 0], [size, array.shape[1]]);
            case 3:
                return tfc.slice3d(array, [start, 0, 0], [size, array.shape[1], array.shape[2]]);
            case 4:
                return tfc.slice4d(array, [start, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3]]);
            default:
                throw new errors_1.ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongFirstAxis = sliceAlongFirstAxis;
function sliceAlongLastAxis(array, start, size) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                return tfc.slice2d(array, [0, start], [array.shape[0], size]);
            case 3:
                return tfc.slice3d(array, [0, 0, start], [array.shape[0], array.shape[1], size]);
            case 4:
                return tfc.slice4d(array, [0, 0, 0, start], [array.shape[0], array.shape[1], array.shape[2], size]);
            default:
                throw new errors_1.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongLastAxis = sliceAlongLastAxis;
function sliceAlongAxis(array, start, size, axis) {
    return tfjs_core_1.tidy(function () {
        switch (array.rank) {
            case 1:
                return tfc.slice1d(array, start, size);
            case 2:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            case 3:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return tfc.slice3d(array, [0, start, 0], [array.shape[0], size, array.shape[2]]);
                    case 3:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            case 4:
                switch (axis) {
                    case 1:
                        return sliceAlongFirstAxis(array, start, size);
                    case 2:
                        return tfc.slice4d(array, [0, start, 0, 0], [array.shape[0], size, array.shape[2], array.shape[3]]);
                    case 3:
                        return tfc.slice4d(array, [0, 0, start, 0], [array.shape[0], array.shape[1], size, array.shape[3]]);
                    case 4:
                        return sliceAlongLastAxis(array, start, size);
                    default:
                        throw new errors_1.ValueError("The axis is not within the rank of the tensor " +
                            ("" + axis));
                }
            default:
                throw new errors_1.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " +
                    ("" + array.rank));
        }
    });
}
exports.sliceAlongAxis = sliceAlongAxis;
function concatenate(tensors, axis) {
    if (axis === void 0) { axis = -1; }
    var rank;
    if (axis < 0) {
        rank = tensors[0].rank;
        if (rank !== 0) {
            axis = rank;
        }
        else {
            axis = 0;
        }
    }
    if (axis === tensors[0].rank) {
        axis = -1;
    }
    return tfc.concat(tensors, axis);
}
exports.concatenate = concatenate;
function concatAlongFirstAxis(a, b) {
    switch (a.rank) {
        case 1:
            return tfc.concat1d([a, b]);
        case 2:
            return tfc.concat2d([a, b], 0);
        case 3:
            return tfc.concat3d([a, b], 0);
        case 4:
            return tfc.concat4d([a, b], 0);
        default:
            throw new errors_1.ValueError('concatAlongFirstAxis() received an unsupported tensor rank: ' +
                a.rank);
    }
}
exports.concatAlongFirstAxis = concatAlongFirstAxis;
function tile(x, n) {
    if (!Array.isArray(n)) {
        n = [n];
    }
    if (x.rank !== n.length) {
        throw new errors_1.ValueError("The length of input n (" + n.length + ") does not match " +
            ("the number of dimensions in input x (" + x.rank + ")"));
    }
    return tfc.tile(x, n);
}
exports.tile = tile;
function identity(x) {
    return x.clone();
}
exports.identity = identity;
function eyeVariable(size, dtype, name) {
    return new variables_1.LayerVariable(tfc.eye(size, size, null, dtype), dtype, name);
}
exports.eyeVariable = eyeVariable;
function scalarTimesArray(c, x) {
    return tfc.mul(c, x);
}
exports.scalarTimesArray = scalarTimesArray;
function scalarPlusArray(c, x) {
    return tfc.add(c, x);
}
exports.scalarPlusArray = scalarPlusArray;
function randomNormal(shape, mean, stddev, dtype, seed) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    return tfc.randomNormal(shape, mean, stddev, dtype, seed);
}
exports.randomNormal = randomNormal;
function dot(x, y) {
    if (y.rank !== 2) {
        throw new errors_1.NotImplementedError("dot support for y other than rank 2 is not yet implemented: " +
            ("y shape = " + shape));
    }
    else {
        if (x.rank === 2) {
            return tfc.matMul(x, y);
        }
        else if (x.rank === 3) {
            var xShape0 = x.shape[0];
            var xShape1 = x.shape[1];
            var xShape2 = x.shape[2];
            x = x.reshape([xShape0 * xShape1, xShape2]);
            return tfc.matMul(x, y).reshape([
                xShape0, xShape1, y.shape[1]
            ]);
        }
        else {
            throw new errors_1.NotImplementedError("dot support for x of rank " + x.rank + " is not yet implemented: " +
                ("x shape = " + shape));
        }
    }
}
exports.dot = dot;
function sign(x) {
    return tfjs_core_1.tidy(function () {
        var zerosLikeX = tfjs_core_1.zerosLike(x);
        var onesLikeX = tfjs_core_1.onesLike(x);
        return tfjs_core_1.where(tfc.equal(x, zerosLikeX), zerosLikeX, tfjs_core_1.where(tfc.greater(x, tfjs_core_1.zerosLike(x)), onesLikeX, scalarTimesArray(getScalar(-1), onesLikeX)));
    });
}
exports.sign = sign;
function qr(x) {
    var _a = tfjs_core_1.tidy(function () {
        if (x.shape.length !== 2) {
            throw new errors_1.ValueError("qr() requires a 2D Tensor, but got a " + x.shape.length + "D Tensor.");
        }
        if (x.shape[0] < x.shape[1]) {
            throw new errors_1.ValueError("qr() requires x.shape[0] >= x.shape[1], but got shape: [" + x.shape + "]");
        }
        var m = x.shape[0];
        var n = x.shape[1];
        var q = tfc.eye(m);
        var r = x.clone();
        var one2D = tfjs_core_1.tensor2d([[1]], [1, 1]);
        var w = one2D.clone();
        var _loop_1 = function (j) {
            var rTemp = r;
            var wTemp = w;
            var qTemp = q;
            _a = tfjs_core_1.tidy(function () {
                var rjEnd1 = r.slice([j, j], [m - j, 1]);
                var normX = tfc.norm(rjEnd1);
                var rjj = r.slice([j, j], [1, 1]);
                var s = tfc.neg(sign(rjj));
                var u1 = rjj.sub(tfc.mul(s, normX));
                var wPre = tfc.div(rjEnd1, u1);
                if (wPre.shape[0] === 1) {
                    w = one2D.clone();
                }
                else {
                    w = one2D.concat(wPre.slice([1, 0], [wPre.shape[0] - 1, wPre.shape[1]]), 0);
                }
                var tau = tfc.neg(tfc.div(tfc.matMul(s, u1), normX));
                var rjEndAll = r.slice([j, 0], [m - j, n]);
                var tauTimesW = tau.mul(w);
                if (j === 0) {
                    r = rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll)));
                }
                else {
                    r = r.slice([0, 0], [j, n])
                        .concat(rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll))), 0);
                }
                var qAllJEnd = q.slice([0, j], [m, q.shape[1] - j]);
                if (j === 0) {
                    q = qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose()));
                }
                else {
                    q = q.slice([0, 0], [m, j])
                        .concat(qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose())), 1);
                }
                return [w, r, q];
            }), w = _a[0], r = _a[1], q = _a[2];
            tfjs_core_1.dispose([rTemp, wTemp, qTemp]);
            var _a;
        };
        for (var j = 0; j < n; ++j) {
            _loop_1(j);
        }
        return [q, r];
    }), qOuter = _a[0], rOuter = _a[1];
    return [qOuter, rOuter];
}
exports.qr = qr;
function oneHot(indices, numClasses) {
    return tfjs_core_1.tidy(function () {
        if (indices.rank !== 1) {
            throw new Error('Only 1D one-hot tensors are supported in the ' +
                'deeplearn backend, at present.');
        }
        indices = indices.toInt();
        return tfc.oneHot(indices, numClasses).toFloat();
    });
}
exports.oneHot = oneHot;
function gather(reference, indices, axis) {
    return tfjs_core_1.tidy(function () {
        if (Array.isArray(indices)) {
            indices = tfjs_core_1.tensor1d(indices, 'int32');
        }
        else {
            indices = indices.toInt();
        }
        return tfc.gather(reference, indices, axis);
    });
}
exports.gather = gather;
function square(x) {
    return tfc.mulStrict(x, x);
}
exports.square = square;
function pow(x, a) {
    return tfjs_core_1.tidy(function () {
        if (typeof (a) === 'number') {
            a = tfjs_core_1.scalar(Math.round(a), 'int32');
        }
        if (a.dtype !== 'int32') {
            throw new errors_1.NotImplementedError("Non-int32 dtype (" + a.dtype + ") is not supported by pow() yet");
        }
        return tfc.pow(x, a);
    });
}
exports.pow = pow;
function biasAdd(x, bias, dataFormat) {
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_3.imageDataFormat();
        }
        common_1.checkDataFormat(dataFormat);
        if (bias.rank !== 1 && bias.rank !== x.rank) {
            throw new errors_1.ValueError('Unexpected bias dimensions: ' + bias.rank +
                '; expected it to be 1 or ' + x.rank);
        }
        var biasShape = bias.shape;
        var y;
        if (x.rank === 5) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1, 1, 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, 1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank === 4) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1, 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[2], biasShape[0], biasShape[1]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank === 3) {
            if (dataFormat === 'channelsFirst') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, biasShape[0], 1]));
                }
                else {
                    y = x.add(bias.reshape([1, biasShape[1], biasShape[0]]));
                }
            }
            else if (dataFormat === 'channelsLast') {
                if (biasShape.length === 1) {
                    y = x.add(bias.reshape([1, 1, biasShape[0]]));
                }
                else {
                    y = x.add(bias.reshape([1].concat(biasShape)));
                }
            }
        }
        else if (x.rank < 3) {
            y = x.add(bias);
        }
        else {
            throw new errors_1.ValueError("Unsupported input rank by biasAdd: " + x.rank);
        }
        return y;
    });
}
exports.biasAdd = biasAdd;
function elu(x, alpha) {
    if (alpha === void 0) { alpha = 1; }
    if (alpha !== 1) {
        throw new errors_1.NotImplementedError("Support for alpha values other than 1 (" + alpha + ") is not implemented " +
            "yet.");
    }
    return tfc.elu(x);
}
exports.elu = elu;
function softsign(x) {
    return tfjs_core_1.tidy(function () { return tfc.div(x, tfc.add(getScalar(1), tfc.abs(x))); });
}
exports.softsign = softsign;
function dropout(x, level, noiseShape, seed) {
    return tfjs_core_1.tidy(function () {
        if (noiseShape != null && !tfjs_core_1.util.arraysEqual(x.shape, noiseShape)) {
            throw new errors_1.NotImplementedError('Non-default noise shape is not implemented yet: ' +
                JSON.stringify(noiseShape));
        }
        if (seed != null) {
            throw new errors_1.NotImplementedError('seed is not implemented for dropout yet.');
        }
        var multiplier = tfc.step(tfc.add(tfc.neg(level), tfc.randomUniform(x.shape, 0, 1, 'float32')));
        multiplier = tfc.mul(tfc.div(getScalar(1), tfc.sub(getScalar(1), level)), multiplier);
        return tfc.mul(x, multiplier);
    });
}
exports.dropout = dropout;
function nameScope(name, fn) {
    return common_1.nameScope(name, fn);
}
exports.nameScope = nameScope;
function floatx() {
    return 'float32';
}
exports.floatx = floatx;
var _uidPrefixes = {};
function getUid(prefix) {
    if (prefix === void 0) { prefix = ''; }
    if (!(prefix in _uidPrefixes)) {
        _uidPrefixes[prefix] = 0;
    }
    _uidPrefixes[prefix] += 1;
    return prefix + _uidPrefixes[prefix].toString();
}
exports.getUid = getUid;
function hardSigmoid(x) {
    return tfjs_core_1.tidy(function () {
        var y = scalarPlusArray(getScalar(0.5), scalarTimesArray(getScalar(0.2), x));
        return tfc.clipByValue(y, 0, 1);
    });
}
exports.hardSigmoid = hardSigmoid;
function inTrainPhase(x, alt, training) {
    if (training === void 0) { training = false; }
    return training ? x() : alt();
}
exports.inTrainPhase = inTrainPhase;
function gradients(lossFn, variables) {
    var variableList = variables.map(function (variable) { return variable.read(); });
    var valudAndGrads = tfjs_core_1.variableGrads(lossFn, variableList);
    return variables.map(function (variable) { return valudAndGrads.grads[variable.name]; });
}
exports.gradients = gradients;

},{"../common":162,"../errors":167,"../utils/math_utils":191,"../variables":193,"./common":159,"@tensorflow/tfjs-core":51}],161:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var generic_utils = require("./utils/generic_utils");
var Callback = (function () {
    function Callback() {
        this.validationData = null;
        this.model = null;
    }
    Callback.prototype.setParams = function (params) {
        this.params = params;
    };
    Callback.prototype.setModel = function (model) {
        this.model = model;
    };
    Callback.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    Callback.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2];
        }); });
    };
    return Callback;
}());
exports.Callback = Callback;
var CallbackList = (function () {
    function CallbackList(callbacks, queueLength) {
        if (queueLength === void 0) { queueLength = 10; }
        if (callbacks == null) {
            callbacks = [];
        }
        this.callbacks = callbacks;
        this.queueLength = queueLength;
    }
    CallbackList.prototype.append = function (callback) {
        this.callbacks.push(callback);
    };
    CallbackList.prototype.setParams = function (params) {
        for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback.setParams(params);
        }
    };
    CallbackList.prototype.setModel = function (model) {
        for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback.setModel(model);
        }
    };
    CallbackList.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onEpochBegin(epoch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onEpochEnd(epoch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onBatchBegin(batch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onBatchEnd(batch, logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onTrainBegin(logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    CallbackList.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, callback;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (logs == null) {
                            logs = {};
                        }
                        _i = 0, _a = this.callbacks;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3, 4];
                        callback = _a[_i];
                        return [4, callback.onTrainEnd(logs)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3, 1];
                    case 4: return [2];
                }
            });
        });
    };
    return CallbackList;
}());
exports.CallbackList = CallbackList;
var BaseLogger = (function (_super) {
    __extends(BaseLogger, _super);
    function BaseLogger() {
        return _super.call(this) || this;
    }
    BaseLogger.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.seen = 0;
                this.totals = {};
                return [2];
            });
        });
    };
    BaseLogger.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var batchSize, _loop_1, this_1, key;
            return __generator(this, function (_a) {
                if (logs == null) {
                    logs = {};
                }
                batchSize = logs['size'] == null ? 0 : logs['size'];
                this.seen += batchSize;
                _loop_1 = function (key) {
                    var value = logs[key];
                    if (typeof value === 'number') {
                        if (!this_1.totals.hasOwnProperty(key)) {
                            this_1.totals[key] = 0;
                        }
                        this_1.totals[key] = this_1.totals[key] + value * batchSize;
                    }
                    else {
                        var oldTotalsToDispose = void 0;
                        if (key in this_1.totals) {
                            oldTotalsToDispose = this_1.totals[key];
                        }
                        else {
                            this_1.totals[key] = K.getScalar(0);
                        }
                        this_1.totals[key] = tfjs_core_1.tidy(function () { return K.scalarPlusArray(_this.totals[key], tfjs_core_1.mul(value, K.getScalar(batchSize))); });
                        if (oldTotalsToDispose != null) {
                            oldTotalsToDispose.dispose();
                        }
                    }
                };
                this_1 = this;
                for (key in logs) {
                    _loop_1(key);
                }
                return [2];
            });
        });
    };
    BaseLogger.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var _loop_2, this_2, _i, _a, key;
            return __generator(this, function (_b) {
                if (logs != null) {
                    _loop_2 = function (key) {
                        if (this_2.totals[key] == null) {
                            return "continue";
                        }
                        if (typeof this_2.totals[key] === 'number') {
                            logs[key] = this_2.totals[key] / this_2.seen;
                        }
                        else {
                            tfjs_core_1.tidy(function () {
                                logs[key] =
                                    K.scalarTimesArray(tfjs_core_1.div(K.getScalar(1), K.getScalar(_this.seen)), _this.totals[key]);
                                _this.totals[key].dispose();
                                tfjs_core_1.keep(logs[key]);
                            });
                        }
                    };
                    this_2 = this;
                    for (_i = 0, _a = this.params['metrics']; _i < _a.length; _i++) {
                        key = _a[_i];
                        _loop_2(key);
                    }
                }
                return [2];
            });
        });
    };
    return BaseLogger;
}(Callback));
exports.BaseLogger = BaseLogger;
function resolveScalarsInLogs(logs) {
    return __awaiter(this, void 0, void 0, function () {
        var promises, keys, key, value, valueScalar, values, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (logs == null) {
                        return [2];
                    }
                    promises = [];
                    keys = [];
                    for (key in logs) {
                        value = logs[key];
                        if (typeof value !== 'number') {
                            valueScalar = value;
                            promises.push(valueScalar.data());
                            keys.push(key);
                        }
                    }
                    return [4, Promise.all(promises)];
                case 1:
                    values = _a.sent();
                    for (i = 0; i < values.length; ++i) {
                        logs[keys[i]] = values[i][0];
                    }
                    return [2];
            }
        });
    });
}
exports.resolveScalarsInLogs = resolveScalarsInLogs;
function disposeTensorsInLogs(logs) {
    if (logs == null) {
        return;
    }
    for (var key in logs) {
        var value = logs[key];
        if (typeof value !== 'number') {
            value.dispose();
        }
    }
}
exports.disposeTensorsInLogs = disposeTensorsInLogs;
var History = (function (_super) {
    __extends(History, _super);
    function History() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    History.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.epoch = [];
                this.history = {};
                return [2];
            });
        });
    };
    History.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            var key;
            return __generator(this, function (_a) {
                if (logs == null) {
                    logs = {};
                }
                this.epoch.push(epoch);
                for (key in logs) {
                    if (this.history[key] == null) {
                        this.history[key] = [];
                    }
                    this.history[key].push(logs[key]);
                }
                return [2];
            });
        });
    };
    History.prototype.syncData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises, keys, indices, key, valueArray, i, valueScalar, values, n;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = [];
                        keys = [];
                        indices = [];
                        for (key in this.history) {
                            valueArray = this.history[key];
                            for (i = 0; i < valueArray.length; ++i) {
                                if (typeof valueArray[i] !== 'number') {
                                    valueScalar = valueArray[i];
                                    promises.push(valueScalar.data());
                                    keys.push(key);
                                    indices.push(i);
                                }
                            }
                        }
                        return [4, Promise.all(promises)];
                    case 1:
                        values = _a.sent();
                        for (n = 0; n < values.length; ++n) {
                            this.history[keys[n]][indices[n]].dispose();
                            this.history[keys[n]][indices[n]] = values[n][0];
                        }
                        return [2];
                }
            });
        });
    };
    return History;
}(Callback));
exports.History = History;
var CustomCallback = (function (_super) {
    __extends(CustomCallback, _super);
    function CustomCallback(config) {
        var _this = _super.call(this) || this;
        _this.trainBegin = config.onTrainBegin;
        _this.trainEnd = config.onTrainEnd;
        _this.epochBegin = config.onEpochBegin;
        _this.epochEnd = config.onEpochEnd;
        _this.batchBegin = config.onBatchBegin;
        _this.batchEnd = config.onBatchEnd;
        return _this;
    }
    CustomCallback.prototype.onEpochBegin = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.epochBegin != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.epochBegin(epoch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onEpochEnd = function (epoch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.epochEnd != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.epochEnd(epoch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onBatchBegin = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.batchBegin != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.batchBegin(batch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onBatchEnd = function (batch, logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.batchEnd != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.batchEnd(batch, logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onTrainBegin = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.trainBegin != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.trainBegin(logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    CustomCallback.prototype.onTrainEnd = function (logs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.trainEnd != null)) return [3, 3];
                        return [4, resolveScalarsInLogs(logs)];
                    case 1:
                        _a.sent();
                        return [4, this.trainEnd(logs)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2];
                }
            });
        });
    };
    return CustomCallback;
}(Callback));
exports.CustomCallback = CustomCallback;
function standardizeCallbacks(callbacks) {
    if (callbacks == null) {
        return null;
    }
    if (callbacks instanceof Callback) {
        return [callbacks];
    }
    if (Array.isArray(callbacks) && callbacks[0] instanceof Callback) {
        return callbacks;
    }
    var callbackConfigs = generic_utils.toList(callbacks);
    return callbackConfigs.map(function (callbackConfig) { return new CustomCallback(callbackConfig); });
}
exports.standardizeCallbacks = standardizeCallbacks;

},{"./backend/tfjs_backend":160,"./utils/generic_utils":190,"@tensorflow/tfjs-core":51}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generic_utils_1 = require("./utils/generic_utils");
var nameMap = new Map();
exports.VALID_DATA_FORMAT_VALUES = ['channelsFirst', 'channelsLast'];
function checkDataFormat(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_DATA_FORMAT_VALUES, 'DataFormat', value);
}
exports.checkDataFormat = checkDataFormat;
exports.VALID_PADDING_MODE_VALUES = ['valid', 'same', 'causal'];
function checkPaddingMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_PADDING_MODE_VALUES, 'PaddingMode', value);
}
exports.checkPaddingMode = checkPaddingMode;
exports.VALID_POOL_MODE_VALUES = ['max', 'avg'];
function checkPoolMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_POOL_MODE_VALUES, 'PoolMode', value);
}
exports.checkPoolMode = checkPoolMode;
var _nameScopeStack = [];
var _nameScopeDivider = '/';
function nameScope(name, fn) {
    _nameScopeStack.push(name);
    try {
        var val = fn();
        _nameScopeStack.pop();
        return val;
    }
    catch (e) {
        _nameScopeStack.pop();
        throw e;
    }
}
exports.nameScope = nameScope;
function currentNameScopePrefix() {
    if (_nameScopeStack.length === 0) {
        return '';
    }
    else {
        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
    }
}
function getScopedTensorName(tensorName) {
    if (!isValidTensorName(tensorName)) {
        throw new Error('Not a valid tensor name: \'' + tensorName + '\'');
    }
    return currentNameScopePrefix() + tensorName;
}
exports.getScopedTensorName = getScopedTensorName;
function getUniqueTensorName(scopedName) {
    if (!isValidTensorName(scopedName)) {
        throw new Error('Not a valid tensor name: \'' + scopedName + '\'');
    }
    if (!nameMap.has(scopedName)) {
        nameMap.set(scopedName, 0);
    }
    var index = nameMap.get(scopedName);
    nameMap.set(scopedName, nameMap.get(scopedName) + 1);
    if (index > 0) {
        var result = scopedName + '_' + index;
        nameMap.set(result, 1);
        return result;
    }
    else {
        return scopedName;
    }
}
exports.getUniqueTensorName = getUniqueTensorName;
var tensorNameRegex = new RegExp(/^[A-Za-z][A-Za-z0-9\._\/]*$/);
function isValidTensorName(name) {
    return name.match(tensorNameRegex) ? true : false;
}
exports.isValidTensorName = isValidTensorName;

},{"./utils/generic_utils":190}],163:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var generic_utils_1 = require("./utils/generic_utils");
function calcL2Norms(w, axis) {
    return tfjs_core_1.tidy(function () { return tfc.sqrt(tfc.sum(K.square(w), axis, true)); });
}
var Constraint = (function (_super) {
    __extends(Constraint, _super);
    function Constraint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Constraint.prototype.getConfig = function () {
        return {};
    };
    Constraint = __decorate([
        tfjs_core_1.doc({ heading: 'Constraints', subheading: 'Classes', namespace: 'constraints' })
    ], Constraint);
    return Constraint;
}(tfjs_core_1.serialization.Serializable));
exports.Constraint = Constraint;
var MaxNorm = (function (_super) {
    __extends(MaxNorm, _super);
    function MaxNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultMaxValue = 2;
        _this.defaultAxis = 0;
        _this.maxValue =
            config.maxValue != null ? config.maxValue : _this.defaultMaxValue;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    MaxNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var norms = calcL2Norms(w, _this.axis);
            var desired = tfc.clipByValue(norms, 0, _this.maxValue);
            return tfc.mul(w, tfc.div(desired, K.scalarPlusArray(K.getScalar(K.epsilon()), norms)));
        });
    };
    MaxNorm.prototype.getConfig = function () {
        return { maxValue: this.maxValue, axis: this.axis };
    };
    MaxNorm.className = 'MaxNorm';
    return MaxNorm;
}(Constraint));
exports.MaxNorm = MaxNorm;
tfjs_core_1.serialization.SerializationMap.register(MaxNorm);
var UnitNorm = (function (_super) {
    __extends(UnitNorm, _super);
    function UnitNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultAxis = 0;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    UnitNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return tfc.div(w, K.scalarPlusArray(K.getScalar(K.epsilon()), calcL2Norms(w, _this.axis))); });
    };
    UnitNorm.prototype.getConfig = function () {
        return { axis: this.axis };
    };
    UnitNorm.className = 'UnitNorm';
    return UnitNorm;
}(Constraint));
exports.UnitNorm = UnitNorm;
tfjs_core_1.serialization.SerializationMap.register(UnitNorm);
var NonNeg = (function (_super) {
    __extends(NonNeg, _super);
    function NonNeg() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NonNeg.prototype.apply = function (w) {
        return tfc.relu(w);
    };
    NonNeg.className = 'NonNeg';
    return NonNeg;
}(Constraint));
exports.NonNeg = NonNeg;
tfjs_core_1.serialization.SerializationMap.register(NonNeg);
var MinMaxNorm = (function (_super) {
    __extends(MinMaxNorm, _super);
    function MinMaxNorm(config) {
        var _this = _super.call(this) || this;
        _this.defaultMinValue = 0.0;
        _this.defaultMaxValue = 1.0;
        _this.defaultRate = 1.0;
        _this.defaultAxis = 0;
        _this.minValue =
            config.minValue != null ? config.minValue : _this.defaultMinValue;
        _this.maxValue =
            config.maxValue != null ? config.maxValue : _this.defaultMaxValue;
        _this.rate = config.rate != null ? config.rate : _this.defaultRate;
        _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
        return _this;
    }
    MinMaxNorm.prototype.apply = function (w) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var norms = calcL2Norms(w, _this.axis);
            var desired = tfc.add(K.scalarTimesArray(K.getScalar(_this.rate), tfc.clipByValue(norms, _this.minValue, _this.maxValue)), K.scalarTimesArray(K.getScalar(1.0 - _this.rate), norms));
            return tfc.mul(w, tfc.div(desired, K.scalarPlusArray(K.getScalar(K.epsilon()), norms)));
        });
    };
    MinMaxNorm.prototype.getConfig = function () {
        return {
            minValue: this.minValue,
            maxValue: this.maxValue,
            rate: this.rate,
            axis: this.axis
        };
    };
    MinMaxNorm.className = 'MinMaxNorm';
    return MinMaxNorm;
}(Constraint));
exports.MinMaxNorm = MinMaxNorm;
tfjs_core_1.serialization.SerializationMap.register(MinMaxNorm);
exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'maxNorm': 'MaxNorm',
    'minMaxNorm': 'MinMaxNorm',
    'nonNeg': 'NonNeg',
    'unitNorm': 'UnitNorm'
};
function serializeConstraint(constraint) {
    return generic_utils_1.serializeKerasObject(constraint);
}
exports.serializeConstraint = serializeConstraint;
function deserializeConstraint(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'constraint');
}
exports.deserializeConstraint = deserializeConstraint;
function getConstraint(identifier) {
    if (identifier == null) {
        return null;
    }
    if (typeof identifier === 'string') {
        var className = identifier in exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        var config = { className: className, config: {} };
        return deserializeConstraint(config);
    }
    else if (identifier instanceof Constraint) {
        return identifier;
    }
    else {
        return deserializeConstraint(identifier);
    }
}
exports.getConstraint = getConstraint;

},{"./backend/tfjs_backend":160,"./utils/generic_utils":190,"@tensorflow/tfjs-core":51}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
var topology_1 = require("./topology");
function assertFeedCompatibility(key, val) {
    if (key.dtype != null && key.dtype !== val.dtype) {
        throw new errors_1.ValueError("The dtype of the feed (" + val.dtype + ") is incompatible with that of " +
            ("the key '" + key.name + "' (" + key.dtype + ")."));
    }
    if (key.shape != null) {
        if (key.shape.length !== val.shape.length) {
            throw new errors_1.ValueError("The rank of feed (" + val.shape.length + ") does not match the rank of " +
                ("the key (" + key.shape.length + ")."));
        }
        for (var i = 0; i < key.shape.length; ++i) {
            if (key.shape[i] != null && key.shape[i] !== val.shape[i]) {
                throw new errors_1.ValueError("The " + i + "-th dimension of the feed (" + val.shape[i] + ") is " +
                    ("incompatible with that of the key (" + key.shape[i] + ")."));
            }
        }
    }
}
var FeedDict = (function () {
    function FeedDict(feeds) {
        this.id2Value = {};
        if (feeds instanceof FeedDict) {
            for (var id in feeds.id2Value) {
                this.id2Value[id] = feeds.id2Value[id];
            }
        }
        else {
            if (feeds == null) {
                return;
            }
            for (var _i = 0, feeds_1 = feeds; _i < feeds_1.length; _i++) {
                var feed = feeds_1[_i];
                this.add(feed.key, feed.value);
            }
        }
    }
    FeedDict.prototype.add = function (key, value) {
        assertFeedCompatibility(key, value);
        if (this.id2Value[key.id] == null) {
            this.id2Value[key.id] = value;
        }
        else {
            throw new errors_1.ValueError("Duplicate key: name=" + key.name + ", id=" + key.id);
        }
        return this;
    };
    FeedDict.prototype.addFeed = function (feed) {
        this.add(feed.key, feed.value);
    };
    FeedDict.prototype.hasKey = function (key) {
        return this.id2Value[key.id] != null;
    };
    FeedDict.prototype.getValue = function (key) {
        if (this.id2Value[key.id] == null) {
            throw new errors_1.ValueError("Nonexistent key: " + JSON.stringify(key));
        }
        else {
            return this.id2Value[key.id];
        }
    };
    return FeedDict;
}());
exports.FeedDict = FeedDict;
function execute(fetches, feedDict, kwargs) {
    var arrayFetches = Array.isArray(fetches);
    var fetchArray = arrayFetches ? fetches : [fetches];
    var outputs = [];
    var internalFeedDict = new FeedDict(feedDict);
    for (var _i = 0, fetchArray_1 = fetchArray; _i < fetchArray_1.length; _i++) {
        var fetch_1 = fetchArray_1[_i];
        outputs.push(executeInternal(fetch_1, internalFeedDict, kwargs));
    }
    return arrayFetches ? outputs : outputs[0];
}
exports.execute = execute;
function executeInternal(fetch, internalFeedDict, kwargs) {
    if (internalFeedDict.hasKey(fetch)) {
        return internalFeedDict.getValue(fetch);
    }
    if (fetch.sourceLayer instanceof topology_1.InputLayer) {
        throw new errors_1.ValueError("Missing a feed value for SymbolicTensor from InputLayer " +
            ("'" + topology_1.InputLayer.name + "'"));
    }
    var inputs = fetch.inputs;
    var inputValues = [];
    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
        var input = inputs_1[_i];
        var inputVal = executeInternal(input, internalFeedDict, kwargs);
        inputValues.push(inputVal);
    }
    var output = fetch.sourceLayer.apply(inputValues, kwargs);
    if (!Array.isArray(output)) {
        output = [output];
    }
    var layerOutputs = getNodeOutputs(fetch);
    var outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];
    for (var i = 0; i < outputSymbolicTensors.length; ++i) {
        internalFeedDict.add(outputSymbolicTensors[i], output[i]);
    }
    return output.length === 1 ? output[0] : output[fetch.outputTensorIndex];
}
function getNodeOutputs(fetch) {
    var layerOutputs;
    if (fetch.sourceLayer.inboundNodes.length === 1) {
        layerOutputs = fetch.sourceLayer.output;
    }
    else {
        var nodeIndex = null;
        for (var i = 0; i < fetch.sourceLayer.inboundNodes.length; ++i) {
            for (var _i = 0, _a = fetch.sourceLayer.inboundNodes[i]
                .outputTensors; _i < _a.length; _i++) {
                var outputTensor = _a[_i];
                if (outputTensor.id === fetch.id) {
                    nodeIndex = i;
                    break;
                }
            }
        }
        layerOutputs = fetch.sourceLayer.getOutputAt(nodeIndex);
    }
    return layerOutputs;
}

},{"../errors":167,"./topology":165}],165:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var errors_1 = require("../errors");
var serialization_1 = require("../layers/serialization");
var types_1 = require("../types");
var generic_utils = require("../utils/generic_utils");
var serialization_utils_1 = require("../utils/serialization_utils");
var variables_1 = require("../variables");
var version_1 = require("../version");
var InputSpec = (function () {
    function InputSpec(config) {
        this.dtype = config.dtype;
        this.shape = config.shape;
        if (config.shape != null) {
            this.ndim = config.shape.length;
        }
        else {
            this.ndim = config.ndim;
        }
        this.maxNDim = config.maxNDim;
        this.minNDim = config.minNDim;
        this.axes = config.axes || {};
    }
    return InputSpec;
}());
exports.InputSpec = InputSpec;
var _nextNodeID = 0;
var Node = (function () {
    function Node(config, callArgs) {
        this.callArgs = callArgs;
        this.id = _nextNodeID++;
        this.outboundLayer = config.outboundLayer;
        this.inboundLayers = config.inboundLayers;
        this.nodeIndices = config.nodeIndices;
        this.tensorIndices = config.tensorIndices;
        this.inputTensors = config.inputTensors;
        this.outputTensors = config.outputTensors;
        this.inputMasks = config.inputMasks;
        this.outputMasks = config.outputMasks;
        this.inputShapes = config.inputShapes;
        this.outputShapes = config.outputShapes;
        for (var _i = 0, _a = config.inboundLayers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer != null) {
                layer.outboundNodes.push(this);
            }
        }
        config.outboundLayer.inboundNodes.push(this);
    }
    Node.prototype.getConfig = function () {
        var inboundNames = [];
        for (var _i = 0, _a = this.inboundLayers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer != null) {
                inboundNames.push(layer.name);
            }
            else {
                inboundNames.push(null);
            }
        }
        return {
            outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
            inboundLayers: inboundNames,
            nodeIndices: this.nodeIndices,
            tensorIndices: this.tensorIndices
        };
    };
    return Node;
}());
exports.Node = Node;
var _nextLayerID = 0;
var Layer = (function (_super) {
    __extends(Layer, _super);
    function Layer(config) {
        var _this = _super.call(this) || this;
        _this._callHook = null;
        _this._addedWeightNames = [];
        _this._stateful = false;
        _this.id = _nextLayerID++;
        _this.activityRegularizer = null;
        _this.inputSpec = null;
        _this.supportsMasking = false;
        _this._trainableWeights = [];
        _this._nonTrainableWeights = [];
        _this._losses = [];
        _this._updates = [];
        _this._built = false;
        _this.inboundNodes = [];
        _this.outboundNodes = [];
        var name = config.name;
        if (!name) {
            var prefix = _this.getClassName();
            name = generic_utils.toSnakeCase(prefix) + '_' + K.getUid(prefix);
        }
        _this.name = name;
        _this.trainable = config.trainable == null ? true : config.trainable;
        _this.updatable = config.updatable == null ? true : config.updatable;
        if (config.inputShape != null || config.batchInputShape != null) {
            var batchInputShape = void 0;
            if (config.batchInputShape != null) {
                batchInputShape = config.batchInputShape;
            }
            else if (config.inputShape != null) {
                var batchSize = null;
                if (config.batchSize != null) {
                    batchSize = config.batchSize;
                }
                batchInputShape = [batchSize].concat(config.inputShape);
            }
            _this.batchInputShape = batchInputShape;
            var dtype = config.dtype;
            if (dtype == null) {
                dtype = config.inputDType;
            }
            if (dtype == null) {
                dtype = K.floatx();
            }
            _this.dtype = dtype;
        }
        if (config.weights != null) {
            _this.initialWeights = config.weights;
        }
        else {
            _this.initialWeights = null;
        }
        return _this;
    }
    Layer.nodeKey = function (layer, nodeIndex) {
        return layer.name + '_ib-' + nodeIndex.toString();
    };
    Layer.prototype.getNodeAtIndex = function (nodeIndex, attrName) {
        if (this.inboundNodes.length === 0) {
            throw new errors_1.RuntimeError('The layer has never been called ' +
                ("and thus has no defined " + attrName + "."));
        }
        if (this.inboundNodes.length <= nodeIndex) {
            throw new errors_1.ValueError("Asked to get " + attrName + " at node " + nodeIndex + ", " +
                ("but the layer has only " + this.inboundNodes.length + " inbound nodes."));
        }
        return this.inboundNodes[nodeIndex];
    };
    Layer.prototype.getInputAt = function (nodeIndex) {
        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'input').inputTensors);
    };
    Layer.prototype.getOutputAt = function (nodeIndex) {
        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'output').outputTensors);
    };
    Object.defineProperty(Layer.prototype, "input", {
        get: function () {
            if (this.inboundNodes.length > 1) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has multiple inbound nodes, ' +
                    'hence the notion of "layer input" ' +
                    'is ill-defined. ' +
                    'Use `getInputAt(nodeIndex)` instead.');
            }
            else if (this.inboundNodes.length === 0) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' is not connected, no input to return.');
            }
            return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'input').inputTensors);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "output", {
        get: function () {
            if (this.inboundNodes.length === 0) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has no inbound nodes.');
            }
            if (this.inboundNodes.length > 1) {
                throw new errors_1.AttributeError("Layer " + this.name +
                    ' has multiple inbound nodes, ' +
                    'hence the notion of "layer output" ' +
                    'is ill-defined. ' +
                    'Use `getOutputAt(nodeIndex)` instead.');
            }
            return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'output').outputTensors);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "losses", {
        get: function () {
            return this._losses;
        },
        enumerable: true,
        configurable: true
    });
    Layer.prototype.calculateLosses = function () {
        return this.losses.map(function (lossFn) { return lossFn(); });
    };
    Object.defineProperty(Layer.prototype, "updates", {
        get: function () {
            return this._updates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "built", {
        get: function () {
            return this._built;
        },
        set: function (built) {
            this._built = built;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "trainableWeights", {
        get: function () {
            if (this.trainable) {
                return this._trainableWeights;
            }
            else {
                return [];
            }
        },
        set: function (weights) {
            this._trainableWeights = weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "nonTrainableWeights", {
        get: function () {
            if (!this.trainable) {
                return this._trainableWeights.concat(this._nonTrainableWeights);
            }
            else {
                return this._nonTrainableWeights;
            }
        },
        set: function (weights) {
            this._nonTrainableWeights = weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "weights", {
        get: function () {
            return this.trainableWeights.concat(this.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layer.prototype, "stateful", {
        get: function () {
            return this._stateful;
        },
        enumerable: true,
        configurable: true
    });
    Layer.prototype.assertInputCompatibility = function (inputs) {
        inputs = generic_utils.toList(inputs);
        if (this.inputSpec == null || this.inputSpec.length === 0) {
            return;
        }
        var inputSpec = generic_utils.toList(this.inputSpec);
        if (inputs.length !== inputSpec.length) {
            throw new errors_1.ValueError("Layer " + this.name + " expects " + inputSpec.length + " inputs, " +
                ("but it received " + inputs.length + " input tensors. ") +
                ("Input received: " + inputs));
        }
        for (var inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
            var x = inputs[inputIndex];
            var spec = inputSpec[inputIndex];
            if (spec == null) {
                continue;
            }
            var ndim = x.rank;
            if (spec.ndim != null) {
                if (ndim !== spec.ndim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + ": " +
                        ("expected ndim=" + spec.ndim + ", found ndim=" + ndim));
                }
            }
            if (spec.maxNDim != null) {
                if (ndim > spec.maxNDim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name +
                        (": expected max_ndim=" + spec.maxNDim + ", found ndim=" + ndim));
                }
            }
            if (spec.minNDim != null) {
                if (ndim < spec.minNDim) {
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name +
                        (": expected min_ndim=" + spec.minNDim + ", found ndim=" + ndim + "."));
                }
            }
            if (spec.dtype != null) {
                if (K.dtype(x) !== spec.dtype) {
                    var xDType = K.dtype(x);
                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + " " +
                        (": expected dtype=" + spec.dtype + ", found dtype=" + xDType + "."));
                }
            }
            if (spec.axes) {
                var xShape = K.intShape(x);
                for (var key in spec.axes) {
                    var axis = Number(key);
                    var value = spec.axes[key];
                    var xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];
                    if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {
                        throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " +
                            (this.name + ": expected axis " + axis + " of input shape to ") +
                            ("have value " + value + " but got shape " + xShape + "."));
                    }
                }
            }
            if (spec.shape != null) {
                var xShape = K.intShape(x);
                for (var i = 0; i < spec.shape.length; ++i) {
                    var specDim = spec.shape[i];
                    var dim = xShape[i];
                    if (specDim != null && dim != null) {
                        if (specDim !== dim) {
                            throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " +
                                (this.name + ": expected shape=" + spec.shape + ", ") +
                                'found shape=${xShape}.');
                        }
                    }
                }
            }
        }
    };
    Layer.prototype.call = function (inputs, kwargs) {
        return inputs;
    };
    Layer.prototype.invokeCallHook = function (inputs, kwargs) {
        if (this._callHook != null) {
            this._callHook(inputs, kwargs);
        }
    };
    Layer.prototype.setCallHook = function (callHook) {
        this._callHook = callHook;
    };
    Layer.prototype.clearCallHook = function () {
        this._callHook = null;
    };
    Layer.prototype.apply = function (inputs, kwargs) {
        var _this = this;
        kwargs = kwargs || {};
        var inputsList = generic_utils.toList(inputs);
        var allAreSymbolic = true;
        for (var _i = 0, inputsList_1 = inputsList; _i < inputsList_1.length; _i++) {
            var input = inputsList_1[_i];
            if (!(input instanceof types_1.SymbolicTensor)) {
                allAreSymbolic = false;
                break;
            }
        }
        var noneAreSymbolic = true;
        for (var _a = 0, inputsList_2 = inputsList; _a < inputsList_2.length; _a++) {
            var input = inputsList_2[_a];
            if (input instanceof types_1.SymbolicTensor) {
                noneAreSymbolic = false;
                break;
            }
        }
        if (allAreSymbolic === noneAreSymbolic) {
            throw new errors_1.ValueError('Arguments to apply() must be all ' +
                'SymbolicTensors or all Tensors');
        }
        return K.nameScope(this.name, function () {
            if (!_this.built) {
                _this.assertInputCompatibility(inputs);
                var inputShapes = [];
                for (var _i = 0, _a = generic_utils.toList(inputs); _i < _a.length; _i++) {
                    var xElem = _a[_i];
                    inputShapes.push(K.intShape(xElem));
                }
                _this.build(generic_utils.singletonOrArray(inputShapes));
                _this.built = true;
                if (_this.initialWeights) {
                    _this.setWeights(_this.initialWeights);
                }
            }
            _this.assertInputCompatibility(inputs);
            if (noneAreSymbolic) {
                var output = _this.call(inputs, kwargs);
                var outputList = generic_utils.toList(output);
                var outputListCopy = [];
                for (var _b = 0, outputList_1 = outputList; _b < outputList_1.length; _b++) {
                    var x = outputList_1[_b];
                    if (inputsList.indexOf(x) !== -1) {
                        x = K.identity(x);
                    }
                    outputListCopy.push(x);
                }
                output = generic_utils.singletonOrArray(outputListCopy);
                if (_this.activityRegularizer != null) {
                    throw new errors_1.NotImplementedError('Layer invocation in the presence of activity ' +
                        'regularizer(s) is not supported yet.');
                }
                return output;
            }
            else {
                var inputShape = collectInputShape(inputs);
                var outputShape = _this.computeOutputShape(inputShape);
                var output = void 0;
                var outputDType_1 = guessOutputDType(inputs);
                if (outputShape != null && outputShape.length > 0 &&
                    Array.isArray(outputShape[0])) {
                    output = outputShape
                        .map(function (shape, index) { return new types_1.SymbolicTensor(outputDType_1, shape, _this, generic_utils.toList(inputs), kwargs, _this.name, index); });
                }
                else {
                    output = new types_1.SymbolicTensor(outputDType_1, outputShape, _this, generic_utils.toList(inputs), kwargs, _this.name);
                }
                _this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);
                if (_this.activityRegularizer != null) {
                    throw new errors_1.NotImplementedError('Layer invocation in the presence of activity ' +
                        'regularizer(s) is not supported yet.');
                }
                return output;
            }
        });
    };
    Layer.prototype.build = function (inputShape) {
        this.built = true;
    };
    Layer.prototype.getWeights = function (trainableOnly) {
        if (trainableOnly === void 0) { trainableOnly = false; }
        return variables_1.batchGetValue(trainableOnly ? this.trainableWeights : this.weights);
    };
    Layer.prototype.setWeights = function (weights) {
        var _this = this;
        tfjs_core_1.tidy(function () {
            var params = _this.weights;
            if (params.length !== weights.length) {
                throw new errors_1.ValueError("You called setWeights(weights) on layer \"" + _this.name + "\" " +
                    ("with a weight list of length " + weights.length + ", ") +
                    ("but the layer was expecting " + params.length + " weights. ") +
                    ("Provided weights: " + weights + "..."));
            }
            if (params.length === 0) {
                return;
            }
            var weightValueTuples = [];
            var paramValues = variables_1.batchGetValue(params);
            for (var i = 0; i < paramValues.length; ++i) {
                var pv = paramValues[i];
                var p = params[i];
                var w = weights[i];
                if (!tfjs_core_1.util.arraysEqual(pv.shape, w.shape)) {
                    throw new errors_1.ValueError("Layer weight shape " + pv.shape + " " +
                        ("not compatible with provided weight shape " + w.shape));
                }
                weightValueTuples.push([p, w]);
            }
            variables_1.batchSetValue(weightValueTuples);
        });
    };
    Layer.prototype.addWeight = function (name, shape, dtype, initializer, regularizer, trainable, constraint) {
        if (this._addedWeightNames.indexOf(name) !== -1) {
            throw new errors_1.ValueError("Duplicate weight name " + name + " for layer " + this.name);
        }
        this._addedWeightNames.push(name);
        if (dtype == null) {
            dtype = K.floatx();
        }
        var weight = new variables_1.LayerVariable(initializer.apply(shape, dtype), dtype, name, trainable, constraint);
        if (regularizer != null) {
            this.addLoss(function () { return regularizer.apply(weight.read()); });
        }
        if (trainable == null) {
            trainable = true;
        }
        if (trainable) {
            this._trainableWeights.push(weight);
        }
        else {
            this._nonTrainableWeights.push(weight);
        }
        return weight;
    };
    Layer.prototype.addLoss = function (losses) {
        if (losses == null || Array.isArray(losses) && losses.length === 0) {
            return;
        }
        losses = generic_utils.toList(losses);
        if (this._losses !== undefined && this._losses !== null) {
            (_a = this.losses).push.apply(_a, losses);
        }
        var _a;
    };
    Layer.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    Layer.prototype.computeMask = function (inputs, mask) {
        var _this = this;
        if (!this.supportsMasking) {
            if (mask != null) {
                if (Array.isArray(mask)) {
                    mask.forEach(function (maskElement) {
                        if (maskElement != null) {
                            throw new TypeError("Layer " + _this.name + " does not support masking," +
                                'but was passed an inputMask.');
                        }
                    });
                }
                else {
                    throw new TypeError("Layer " + this.name + " does not support masking," +
                        'but was passed an inputMask.');
                }
            }
            return null;
        }
        return mask;
    };
    Layer.prototype.addInboundNode = function (inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs) {
        if (kwargs === void 0) { kwargs = null; }
        var inputTensorList = generic_utils.toList(inputTensors);
        outputTensors = generic_utils.toList(outputTensors);
        inputMasks = generic_utils.toList(inputMasks);
        outputMasks = generic_utils.toList(outputMasks);
        inputShapes = generic_utils.normalizeShapeList(inputShapes);
        outputShapes = generic_utils.normalizeShapeList(outputShapes);
        var inboundLayers = [];
        var nodeIndices = [];
        var tensorIndices = [];
        for (var _i = 0, inputTensorList_1 = inputTensorList; _i < inputTensorList_1.length; _i++) {
            var x = inputTensorList_1[_i];
            inboundLayers.push(x.sourceLayer);
            nodeIndices.push(x.nodeIndex);
            tensorIndices.push(x.tensorIndex);
        }
        new Node({
            outboundLayer: this,
            inboundLayers: inboundLayers,
            nodeIndices: nodeIndices,
            tensorIndices: tensorIndices,
            inputTensors: inputTensorList,
            outputTensors: outputTensors,
            inputMasks: inputMasks,
            outputMasks: outputMasks,
            inputShapes: inputShapes,
            outputShapes: outputShapes
        }, kwargs);
        for (var i = 0; i < outputTensors.length; i++) {
            outputTensors[i].sourceLayer = this;
            outputTensors[i].nodeIndex = this.inboundNodes.length - 1;
            outputTensors[i].tensorIndex = i;
        }
    };
    Layer.prototype.getConfig = function () {
        var config = { name: this.name, trainable: this.trainable };
        if (this.batchInputShape != null) {
            config['batchInputShape'] = this.batchInputShape;
        }
        if (this.dtype != null) {
            config['dtype'] = this.dtype;
        }
        return config;
    };
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', 'subheading': 'Classes' })
    ], Layer.prototype, "apply", null);
    Layer = __decorate([
        tfjs_core_1.doc({ heading: 'Layers', subheading: 'Classes', namespace: 'layers' })
    ], Layer);
    return Layer;
}(tfjs_core_1.serialization.Serializable));
exports.Layer = Layer;
function collectInputShape(inputTensors) {
    inputTensors =
        generic_utils.toList(inputTensors);
    var shapes = [];
    for (var _i = 0, inputTensors_1 = inputTensors; _i < inputTensors_1.length; _i++) {
        var x = inputTensors_1[_i];
        shapes.push(K.intShape(x));
    }
    return generic_utils.singletonOrArray(shapes);
}
function guessOutputDType(inputTensors) {
    return 'float32';
}
var InputLayer = (function (_super) {
    __extends(InputLayer, _super);
    function InputLayer(config) {
        var _this = _super.call(this, {
            dtype: config.dtype,
            name: config.name != null ? config.name : K.getUid('input').toString()
        }) || this;
        if (config.batchSize == null) {
            config.batchSize = null;
        }
        if (config.sparse == null) {
            config.sparse = false;
        }
        _this.trainable = false;
        _this.built = true;
        _this.sparse = config.sparse;
        if (config.inputShape != null && config.batchInputShape != null) {
            throw new errors_1.ValueError('Only provide the inputShape OR ' +
                'batchInputShape argument to inputLayer, not both at the same time.');
        }
        var batchInputShape = config.batchInputShape;
        if (batchInputShape == null) {
            if (config.inputShape == null) {
                throw new errors_1.ValueError('An InputLayer should be passed either a ' +
                    '`batchInputShape` or an `inputShape`.');
            }
            else {
                batchInputShape = [config.batchSize].concat(config.inputShape);
            }
        }
        else {
            if (config.batchSize != null) {
                throw new errors_1.ValueError('Cannot specify batchSize if batchInputShape is' +
                    'specified when creating an InputLayer.');
            }
        }
        var dtype = config.dtype || K.floatx();
        _this.batchInputShape = batchInputShape;
        _this.dtype = dtype;
        _this.inputSpec = [{ shape: batchInputShape }];
        var inputTensor = new types_1.SymbolicTensor(_this.dtype, _this.batchInputShape, _this, [], {}, _this.name);
        inputTensor.nodeIndex = 0;
        inputTensor.tensorIndex = 0;
        new Node({
            outboundLayer: _this,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: [inputTensor],
            outputTensors: [inputTensor],
            inputMasks: [null],
            outputMasks: [null],
            inputShapes: [batchInputShape],
            outputShapes: [batchInputShape]
        });
        return _this;
    }
    InputLayer.prototype.apply = function (inputs, kwargs) {
        throw new errors_1.ValueError('Cannot pass any input to an ' +
            ("InputLayer's apply() method. InputLayer name: " + this.name));
    };
    InputLayer.prototype.getConfig = function () {
        return {
            batchInputShape: this.batchInputShape,
            dtype: this.dtype,
            sparse: this.sparse,
            name: this.name
        };
    };
    InputLayer.className = 'InputLayer';
    return InputLayer;
}(Layer));
exports.InputLayer = InputLayer;
tfjs_core_1.serialization.SerializationMap.register(InputLayer);
function Input(config) {
    if (config.batchShape == null && config.shape == null) {
        throw new Error('Please provide to Input either a `shape`' +
            ' or a `batchShape` argument. Note that ' +
            '`shape` does not include the batch ' +
            'dimension.');
    }
    if (config.batchShape != null && config.shape != null) {
        throw new errors_1.ValueError('Please provide either a `shape` or `batchShape` ' +
            'argument to Input, but not both.');
    }
    var batchShape = config.batchShape;
    if (config.shape != null && batchShape == null) {
        batchShape = [null].concat(config.shape);
    }
    var dtype = config.dtype;
    if (dtype == null) {
        dtype = K.floatx();
    }
    var inputLayer = new InputLayer({
        batchInputShape: batchShape,
        name: config.name,
        dtype: dtype,
        sparse: config.sparse
    });
    var outputs = inputLayer.inboundNodes[0].outputTensors;
    return outputs[0];
}
exports.Input = Input;
var Container = (function (_super) {
    __extends(Container, _super);
    function Container(config) {
        var _this = _super.call(this, {}) || this;
        _this.containerNodes = new Set();
        _this.name = config.name;
        if (_this.name == null) {
            var prefix = _this.getClassName().toLowerCase();
            _this.name = K.getUid(prefix);
        }
        _this.supportsMasking = false;
        _this.trainable = true;
        _this.updatable = true;
        if (Array.isArray(config.inputs)) {
            _this.inputs = config.inputs.slice();
        }
        else {
            _this.inputs = [config.inputs];
        }
        if (Array.isArray(config.outputs)) {
            _this.outputs = config.outputs.slice();
        }
        else {
            _this.outputs = [config.outputs];
        }
        if (generic_utils.unique(_this.inputs).length !== _this.inputs.length) {
            throw new errors_1.ValueError('The list of inputs passed to the model is ' +
                'redundant. All inputs should only appear once. Found: ' +
                _this.inputs.map(function (x) { return x.name; }));
        }
        if (generic_utils.unique(_this.outputs).length !== _this.outputs.length) {
            console.warn('The list of outputs passed to the model is redundant. ' +
                'All outputs should only appear once. Found: ' +
                _this.outputs.map(function (x) { return x.name; }));
        }
        _this.inputLayers = [];
        _this.inputLayersNodeIndices = [];
        _this.inputLayersTensorIndices = [];
        _this.outputLayers = [];
        _this.outputLayersNodeIndices = [];
        _this.outputLayersTensorIndices = [];
        _this.layers = [];
        for (var _i = 0, _a = _this.outputs; _i < _a.length; _i++) {
            var x = _a[_i];
            var layer = x.sourceLayer;
            var nodeIndex = x.nodeIndex;
            var tensorIndex = x.tensorIndex;
            _this.outputLayers.push(layer);
            _this.outputLayersNodeIndices.push(nodeIndex);
            _this.outputLayersTensorIndices.push(tensorIndex);
        }
        for (var _b = 0, _c = _this.inputs; _b < _c.length; _b++) {
            var x = _c[_b];
            var layer = x.sourceLayer;
            var nodeIndex = x.nodeIndex;
            var tensorIndex = x.tensorIndex;
            generic_utils.assert(nodeIndex === 0, 'input layer has >1 nodes');
            generic_utils.assert(tensorIndex === 0, 'input layer has >1 tensors');
            _this.inputLayers.push(layer);
            _this.inputLayersNodeIndices.push(nodeIndex);
            _this.inputLayersTensorIndices.push(tensorIndex);
        }
        _this.inputNames = [];
        _this.outputNames = [];
        _this.feedInputShapes = [];
        _this.feedInputNames = [];
        _this.feedOutputNames = [];
        for (var i = 0; i < _this.inputLayers.length; i++) {
            var layer = _this.inputLayers[i];
            if (!(layer instanceof InputLayer)) {
                throw new TypeError('Input layers to a Model must be InputLayer objects. ' +
                    ("Received inputs: " + config.inputs + ". ") +
                    ("Input " + i + " (0-based) originates ") +
                    ("from layer type " + layer.getClassName() + "."));
            }
            _this.inputNames.push(layer.name);
            _this.feedInputShapes.push(layer.batchInputShape);
            _this.feedInputNames.push(layer.name);
        }
        for (var _d = 0, _e = _this.outputLayers; _d < _e.length; _d++) {
            var layer = _e[_d];
            _this.outputNames.push(layer.name);
        }
        _this.internalInputShapes = _this.inputs.map(function (x) { return x.shape; });
        _this.internalOutputShapes = _this.outputs.map(function (x) { return x.shape; });
        var nodesDepths = {};
        var nodeIDToNode = {};
        var layersDepths = {};
        var layerIDToLayer = {};
        var layerIndices = {};
        var nodesInDecreasingDepth = [];
        var buildMapOfGraph = function (tensor, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex) {
            if (layer == null || nodeIndex == null || tensorIndex == null) {
                layer = tensor.sourceLayer;
                nodeIndex = tensor.nodeIndex;
                tensorIndex = tensor.tensorIndex;
            }
            var node = layer.inboundNodes[nodeIndex];
            if (nodesInProgress.indexOf(node) !== -1) {
                throw new errors_1.RuntimeError("The tensor " + tensor.name + " at layer \"" + layer.name + "\" " +
                    'is part of a cycle.');
            }
            if (finishedNodes.indexOf(node) !== -1) {
                return;
            }
            _this.containerNodes.add(Container.nodeKey(layer, nodeIndex));
            if (!(layer.id in layerIndices)) {
                layerIndices[layer.id] = Object.keys(layerIndices).length;
            }
            if (nodesInProgress.indexOf(node) === -1) {
                nodesInProgress.push(node);
            }
            var numInboundLayers = node.inboundLayers.length;
            for (var i = 0; i < numInboundLayers; i++) {
                var x = node.inputTensors[i];
                var layer_1 = node.inboundLayers[i];
                var nodeIndex_1 = node.nodeIndices[i];
                var tensorIndex_1 = node.tensorIndices[i];
                buildMapOfGraph(x, finishedNodes, nodesInProgress, layer_1, nodeIndex_1, tensorIndex_1);
            }
            finishedNodes.push(node);
            while (nodesInProgress.indexOf(node) >= 0) {
                nodesInProgress.splice(nodesInProgress.indexOf(node), 1);
            }
            nodesInDecreasingDepth.push(node);
        };
        var finishedNodes = [];
        var nodesInProgress = [];
        for (var _f = 0, _g = _this.outputs; _f < _g.length; _f++) {
            var x = _g[_f];
            buildMapOfGraph(x, finishedNodes, nodesInProgress);
        }
        var reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();
        for (var _h = 0, reversedNodesInDecreasingDepth_1 = reversedNodesInDecreasingDepth; _h < reversedNodesInDecreasingDepth_1.length; _h++) {
            var node = reversedNodesInDecreasingDepth_1[_h];
            nodeIDToNode[node.id] = node;
            if (!(node.id in nodesDepths)) {
                nodesDepths[node.id] = 0;
            }
            var depth = nodesDepths[node.id];
            var previousDepth = (layersDepths[node.outboundLayer.id] == null ?
                0 :
                layersDepths[node.outboundLayer.id]);
            depth = Math.max(depth, previousDepth);
            layersDepths[node.outboundLayer.id] = depth;
            layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;
            nodesDepths[node.id] = depth;
            for (var i = 0; i < node.inboundLayers.length; i++) {
                var inboundLayer = node.inboundLayers[i];
                var nodeIndex = node.nodeIndices[i];
                var inboundNode = inboundLayer.inboundNodes[nodeIndex];
                var previousDepth_1 = (nodesDepths[inboundNode.id] == null ? 0 :
                    nodesDepths[inboundNode.id]);
                nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth_1);
                nodeIDToNode[inboundNode.id] = inboundNode;
            }
        }
        var nodesByDepth = {};
        for (var nodeID in nodesDepths) {
            var depth = nodesDepths[nodeID];
            if (!(depth in nodesByDepth)) {
                nodesByDepth[depth] = [];
            }
            nodesByDepth[depth].push(nodeIDToNode[nodeID]);
        }
        var layersByDepth = {};
        for (var layerID in layersDepths) {
            var depth = layersDepths[layerID];
            if (!(depth in layersByDepth)) {
                layersByDepth[depth] = [];
            }
            layersByDepth[depth].push(layerIDToLayer[layerID]);
        }
        var depthKeys = Object.keys(layersByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        _this.layers = [];
        for (var _j = 0, depthKeys_1 = depthKeys; _j < depthKeys_1.length; _j++) {
            var depth = depthKeys_1[_j];
            var layersForDepth = layersByDepth[depth];
            layersForDepth.sort(function (a, b) {
                var aIndex = layerIndices[a.id];
                var bIndex = layerIndices[b.id];
                if (aIndex < bIndex) {
                    return -1;
                }
                if (aIndex > bIndex) {
                    return 1;
                }
                return 0;
            });
            for (var _k = 0, layersForDepth_1 = layersForDepth; _k < layersForDepth_1.length; _k++) {
                var layer = layersForDepth_1[_k];
                _this.layers.push(layer);
            }
        }
        _this.layersByDepth = layersByDepth;
        depthKeys = Object.keys(nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        var computableTensors = _this.inputs.slice();
        var layersWithCompleteInput = [];
        for (var _l = 0, depthKeys_2 = depthKeys; _l < depthKeys_2.length; _l++) {
            var depth = depthKeys_2[_l];
            for (var _m = 0, _o = nodesByDepth[depth]; _m < _o.length; _m++) {
                var node = _o[_m];
                var layer = node.outboundLayer;
                if (layer != null) {
                    for (var _p = 0, _q = node.inputTensors; _p < _q.length; _p++) {
                        var x = _q[_p];
                        if (computableTensors.indexOf(x) === -1) {
                            throw new errors_1.RuntimeError("Graph disconnected: cannot obtain value for tensor " + x +
                                (" at layer \"" + layer.name + "\". ") +
                                'The following previous layers were accessed without ' +
                                ("issue: " + layersWithCompleteInput));
                        }
                    }
                    for (var _r = 0, _s = node.outputTensors; _r < _s.length; _r++) {
                        var x = _s[_r];
                        computableTensors.push(x);
                    }
                    layersWithCompleteInput.push(layer.name);
                }
            }
        }
        _this.nodesByDepth = nodesByDepth;
        var allNames = _this.layers.map(function (x) { return x.name; });
        var _loop_1 = function (name_1) {
            var numOccurrences = allNames.filter(function (x) { return x === name_1; }).length;
            if (numOccurrences !== 1) {
                throw new errors_1.RuntimeError("The name \"" + name_1 + "\" is used " + numOccurrences + " times " +
                    'in the model. All layer names should be unique. Layer names: ' +
                    JSON.stringify(allNames));
            }
        };
        for (var _t = 0, allNames_1 = allNames; _t < allNames_1.length; _t++) {
            var name_1 = allNames_1[_t];
            _loop_1(name_1);
        }
        _this.outboundNodes = [];
        _this.inboundNodes = [];
        new Node({
            outboundLayer: _this,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: _this.inputs,
            outputTensors: _this.outputs,
            inputMasks: _this.inputs.map(function (x) { return null; }),
            outputMasks: _this.outputs.map(function (x) { return null; }),
            inputShapes: _this.inputs.map(function (x) { return x.shape; }),
            outputShapes: _this.outputs.map(function (x) { return x.shape; })
        });
        _this.built = true;
        return _this;
    }
    Object.defineProperty(Container.prototype, "trainableWeights", {
        get: function () {
            if (this._trainableWeights.length > 0) {
                throw new errors_1.ValueError('Container instance unexpectedly contains _trainableWeights.' +
                    'The trainable weights of a Container are a union of the ' +
                    'trainable weights of its consituent Layers. Its own ' +
                    '_trainableWeights must remain an empty Array.');
            }
            if (!this.trainable) {
                return [];
            }
            var weights = [];
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                weights = weights.concat(layer.trainableWeights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "nonTrainableWeights", {
        get: function () {
            var weights = [];
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                weights.push.apply(weights, layer.nonTrainableWeights);
            }
            if (!this.trainable) {
                var trainableWeights = [];
                for (var _b = 0, _c = this.layers; _b < _c.length; _b++) {
                    var layer = _c[_b];
                    trainableWeights.push.apply(trainableWeights, layer.trainableWeights);
                }
                return trainableWeights.concat(weights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "weights", {
        get: function () {
            return this.trainableWeights.concat(this.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Container.prototype.loadWeights = function (weightsJSON, skipMismatch, isNamedTensorMap) {
        if (skipMismatch === void 0) { skipMismatch = false; }
        if (isNamedTensorMap === void 0) { isNamedTensorMap = false; }
        if (isNamedTensorMap) {
            loadWeightsFromNamedTensorMap(weightsJSON, this.layers);
        }
        else {
            loadWeightsFromJson(weightsJSON, this.layers, skipMismatch);
        }
    };
    Container.prototype.updatedConfig = function () {
        var theConfig = this.getConfig();
        var modelConfig = {
            className: this.getClassName(),
            config: theConfig,
            kerasVersion: "tfjs-layers " + version_1.version,
            backend: 'TensorFlow.js'
        };
        return modelConfig;
    };
    Container.prototype.toJSON = function (unused, returnString) {
        if (returnString === void 0) { returnString = true; }
        var modelConfig = serialization_utils_1.convertTsToPythonic(this.updatedConfig());
        return returnString ? JSON.stringify(modelConfig) : modelConfig;
    };
    Container.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.toList(inputs);
            var masks;
            if ('mask' in kwargs) {
                masks = generic_utils.toList(kwargs['mask']);
            }
            else {
                masks = generic_utils.pyListRepeat(null, inputs.length);
            }
            return _this.runInternalGraph(inputs, masks)[0];
        });
    };
    Container.prototype.computeMask = function (inputs, mask) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.toList(inputs);
            var masks;
            if (mask == null) {
                masks = generic_utils.pyListRepeat(null, inputs.length);
            }
            else {
                masks = generic_utils.toList(mask);
            }
            return _this.runInternalGraph(inputs, masks)[1];
        });
    };
    Container.prototype.computeOutputShape = function (inputShape) {
        var inputShapes = generic_utils.normalizeShapeList(inputShape);
        if (inputShapes.length !== this.inputLayers.length) {
            throw new errors_1.ValueError("Invalid inputShape argument " + inputShape + ": " +
                ("model has " + this.inputLayers.length + " tensor inputs."));
        }
        var layersToOutputShapes = {};
        for (var i = 0; i < inputShapes.length; i++) {
            var layer = this.inputLayers[i];
            var inputShape_1 = inputShapes[i];
            var shapeKey = layer.name + '_0_0';
            layersToOutputShapes[shapeKey] = inputShape_1;
        }
        var depthKeys = Object.keys(this.nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        if (depthKeys.length > 1) {
            for (var _i = 0, depthKeys_3 = depthKeys; _i < depthKeys_3.length; _i++) {
                var depth = depthKeys_3[_i];
                var nodes = this.nodesByDepth[depth];
                for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
                    var node = nodes_1[_a];
                    var layer = node.outboundLayer;
                    if (this.inputLayers.map(function (x) { return x.id; }).indexOf(layer.id) !== -1) {
                        continue;
                    }
                    var inputShapes_1 = [];
                    for (var j = 0; j < node.inboundLayers.length; j++) {
                        var inboundLayer = node.inboundLayers[j];
                        var nodeIndex_2 = node.nodeIndices[j];
                        var tensorIndex = node.tensorIndices[j];
                        var shapeKey = inboundLayer.name + "_" + nodeIndex_2 + "_" + tensorIndex;
                        var inputShape_2 = layersToOutputShapes[shapeKey];
                        inputShapes_1.push(inputShape_2);
                    }
                    var outputShape = layer.computeOutputShape(generic_utils.singletonOrArray(inputShapes_1));
                    var outputShapes_1 = generic_utils.normalizeShapeList(outputShape);
                    var nodeIndex = layer.inboundNodes.indexOf(node);
                    for (var j = 0; j < outputShapes_1.length; j++) {
                        var shapeKey = layer.name + "_" + nodeIndex + "_" + j;
                        layersToOutputShapes[shapeKey] = outputShapes_1[j];
                    }
                }
            }
        }
        var outputShapes = [];
        var outputShapeKeys = [];
        for (var i = 0; i < this.outputLayers.length; i++) {
            var layer = this.outputLayers[i];
            var nodeIndex = this.outputLayersNodeIndices[i];
            var tensorIndex = this.outputLayersTensorIndices[i];
            var shapeKey = layer.name + "_" + nodeIndex + "_" + tensorIndex;
            outputShapeKeys.push(shapeKey);
        }
        for (var i = 0; i < outputShapeKeys.length; i++) {
            var key = outputShapeKeys[i];
            generic_utils.assert(key in layersToOutputShapes);
            outputShapes.push(layersToOutputShapes[key]);
        }
        return generic_utils.singletonOrArray(outputShapes);
    };
    Container.prototype.runInternalGraph = function (inputs, masks) {
        if (masks == null) {
            masks = generic_utils.pyListRepeat(null, inputs.length);
        }
        var tensorMap = {};
        for (var i = 0; i < this.inputs.length; ++i) {
            var x = this.inputs[i];
            var y = inputs[i];
            var mask = masks[i];
            tensorMap[x.id] = [y, mask];
        }
        var depthKeys = Object.keys(this.nodesByDepth)
            .map(function (x) { return parseInt(x, 10); })
            .sort(generic_utils.reverseNumberCompare);
        for (var _i = 0, depthKeys_4 = depthKeys; _i < depthKeys_4.length; _i++) {
            var depth = depthKeys_4[_i];
            var nodes = this.nodesByDepth[depth];
            for (var _a = 0, nodes_2 = nodes; _a < nodes_2.length; _a++) {
                var node = nodes_2[_a];
                var layer = node.outboundLayer;
                var referenceInputTensors = node.inputTensors;
                var referenceOutputTensors = node.outputTensors;
                var computedData = new Array();
                for (var _b = 0, referenceInputTensors_1 = referenceInputTensors; _b < referenceInputTensors_1.length; _b++) {
                    var x = referenceInputTensors_1[_b];
                    if (x.id in tensorMap) {
                        computedData.push(tensorMap[x.id]);
                    }
                }
                if (computedData.length === referenceInputTensors.length) {
                    var kwargs = {};
                    var computedTensors = void 0;
                    var computedMasks = void 0;
                    var outputTensors_1 = void 0;
                    var outputMasks_1 = void 0;
                    if (node.callArgs != null) {
                        kwargs = node.callArgs;
                    }
                    if (computedData.length === 1) {
                        var _c = computedData[0], computedTensor = _c[0], computedMask = _c[1];
                        if (kwargs.mask == null) {
                            kwargs['mask'] = computedMask;
                        }
                        outputTensors_1 =
                            generic_utils.toList(layer.call(computedTensor, kwargs));
                        outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensor, computedMask));
                        computedTensors = [computedTensor];
                        computedMasks = [computedMask];
                    }
                    else {
                        computedTensors = computedData.map(function (x) { return x[0]; });
                        computedMasks = computedData.map(function (x) { return x[1]; });
                        if (kwargs.mask == null) {
                            kwargs['mask'] = computedMasks;
                        }
                        outputTensors_1 =
                            generic_utils.toList(layer.call(computedTensors, kwargs));
                        outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensors, computedMasks));
                    }
                    if (layer.activityRegularizer) {
                        throw new errors_1.NotImplementedError('Model invocation with concrete Tensor value(s) in the ' +
                            'presence of activity regularizer(s) is not supported yet.');
                    }
                    for (var i = 0; i < referenceOutputTensors.length; ++i) {
                        var x = referenceOutputTensors[i];
                        var y = outputTensors_1[i];
                        var mask = outputMasks_1[i];
                        tensorMap[x.id] = [y, mask];
                    }
                }
            }
        }
        var outputTensors = [];
        var outputMasks = [];
        var outputShapes = [];
        for (var _d = 0, _e = this.outputs; _d < _e.length; _d++) {
            var x = _e[_d];
            generic_utils.assert(x.id in tensorMap, "Could not compute output " + x.name + " : " + x.id);
            var _f = tensorMap[x.id], tensor = _f[0], mask = _f[1];
            outputShapes.push(tensor.shape);
            outputTensors.push(tensor);
            outputMasks.push(mask);
        }
        return [outputTensors, outputMasks, outputShapes];
    };
    Container.prototype.buildNodeConversionMap = function (layers) {
        var nodeConversionMap = {};
        var keptNodes;
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            keptNodes = layer instanceof Container ? 1 : 0;
            for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
                var nodeKey = Container.nodeKey(layer, originalNodeIndex);
                if (nodeKey in this.containerNodes) {
                    nodeConversionMap[nodeKey] = keptNodes;
                    keptNodes += 1;
                }
            }
        }
        return nodeConversionMap;
    };
    Container.prototype.getLayer = function (name, index) {
        if (index != null) {
            if (this.layers.length <= index) {
                throw new errors_1.ValueError("Was asked to retrieve layer at index " + index + ", but model only " +
                    ("has " + this.layers.length + " layer(s)."));
            }
            else {
                return this.layers[index];
            }
        }
        else {
            if (name == null) {
                throw new errors_1.ValueError('Provide either a layer name or layer index');
            }
        }
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            if (layer.name === name) {
                return layer;
            }
        }
        throw new errors_1.ValueError("No such layer: " + name);
    };
    Container.prototype.calculateLosses = function () {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var losses = [];
            for (var _i = 0, _a = _this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                for (var nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {
                    var nodeKey = Container.nodeKey(layer, nodeIndex);
                    if (_this.containerNodes.has(nodeKey)) {
                        losses.push.apply(losses, layer.calculateLosses());
                    }
                }
            }
            return losses;
        });
    };
    Container.prototype.getConfig = function () {
        var config = { name: this.name };
        var nodeConversionMap = this.buildNodeConversionMap(this.layers);
        var layerConfigs = [];
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            var layerClassName = layer.getClassName();
            var layerConfig = layer.getConfig();
            var filteredInboundNodes = [];
            for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
                var node = layer.inboundNodes[originalNodeIndex];
                var nodeKey = Container.nodeKey(layer, originalNodeIndex);
                var kwargs = {};
                if (this.containerNodes.has(nodeKey)) {
                    if (node.callArgs) {
                        var testString = JSON.stringify(node.callArgs);
                        if (testString.indexOf('undefined') === -1) {
                            kwargs = node.callArgs;
                        }
                        else {
                            console.warn("Layer " + layer.name + " was passed " +
                                "non-serializable keyword arguments: " +
                                (node.callArgs + ". They will not be included ") +
                                "in the serialized model (and thus will be " +
                                "missing at deserialization time).");
                            kwargs = {};
                        }
                    }
                    if (node.inboundLayers.length > 0) {
                        var nodeData = [];
                        for (var i = 0; i < node.inboundLayers.length; i++) {
                            var inboundLayer = node.inboundLayers[i];
                            var nodeIndex = node.nodeIndices[i];
                            var tensorIndex = node.tensorIndices[i];
                            var nodeKey_1 = Container.nodeKey(inboundLayer, nodeIndex);
                            var newNodeIndex = nodeConversionMap[nodeKey_1];
                            if (newNodeIndex === null || newNodeIndex === undefined) {
                                newNodeIndex = 0;
                            }
                            nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);
                        }
                        filteredInboundNodes.push(nodeData);
                    }
                }
            }
            layerConfigs.push({
                name: layer.name,
                className: layerClassName,
                config: layerConfig,
                inboundNodes: filteredInboundNodes
            });
        }
        config['layers'] = layerConfigs;
        var modelInputs = [];
        for (var i = 0; i < this.inputLayers.length; i++) {
            var layer = this.inputLayers[i];
            var nodeIndex = this.inputLayersNodeIndices[i];
            var nodeKey = Container.nodeKey(layer, nodeIndex);
            if (!this.containerNodes.has(nodeKey)) {
                continue;
            }
            var newNodeIndex = nodeConversionMap[nodeKey];
            if (newNodeIndex === null || newNodeIndex === undefined) {
                newNodeIndex = 0;
            }
            var tensorIndex = this.inputLayersTensorIndices[i];
            modelInputs.push([layer.name, newNodeIndex, tensorIndex]);
        }
        config['inputLayers'] = modelInputs;
        var modelOutputs = [];
        for (var i = 0; i < this.outputLayers.length; i++) {
            var layer = this.outputLayers[i];
            var nodeIndex = this.outputLayersNodeIndices[i];
            var nodeKey = Container.nodeKey(layer, nodeIndex);
            if (!this.containerNodes.has(nodeKey)) {
                continue;
            }
            var newNodeIndex = nodeConversionMap[nodeKey];
            if (newNodeIndex === null || newNodeIndex === undefined) {
                newNodeIndex = 0;
            }
            var tensorIndex = this.outputLayersTensorIndices[i];
            modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);
        }
        config['outputLayers'] = modelOutputs;
        return config;
    };
    Container.fromConfig = function (cls, config) {
        var createdLayers = {};
        var unprocessedNodes = {};
        function addUnprocessedNode(layer, nodeData) {
            if (!(layer.name in unprocessedNodes)) {
                unprocessedNodes[layer.name] = [nodeData];
            }
            else {
                unprocessedNodes[layer.name].push(nodeData);
            }
        }
        function processNode(layer, nodeData) {
            var inputTensors = [];
            var kwargs;
            for (var _i = 0, nodeData_1 = nodeData; _i < nodeData_1.length; _i++) {
                var inputData = nodeData_1[_i];
                var inboundLayerName = inputData[0];
                var inboundNodeIndex = inputData[1];
                var inboundTensorIndex = inputData[2];
                if (inputData.length === 3) {
                    kwargs = {};
                }
                else if (inputData.length === 4) {
                    kwargs = inputData[3];
                }
                else {
                    throw new errors_1.ValueError("Improperly formatted model config for layer " + JSON.stringify(layer) + ": " + JSON.stringify(inputData));
                }
                if (!(inboundLayerName in createdLayers)) {
                    addUnprocessedNode(layer, nodeData);
                    return;
                }
                var inboundLayer = createdLayers[inboundLayerName];
                if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {
                    addUnprocessedNode(layer, nodeData);
                    return;
                }
                var inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];
                inputTensors.push(inboundNode.outputTensors[inboundTensorIndex]);
            }
            if (inputTensors.length > 0) {
                layer.apply(generic_utils.singletonOrArray(inputTensors), kwargs);
            }
        }
        function processLayer(layerData) {
            var layerName = layerData.name;
            var layer = serialization_1.deserialize(layerData, config.customObjects != null ?
                config.customObjects :
                {});
            createdLayers[layerName] = layer;
            var inboundNodesData = layerData.inboundNodes;
            for (var _i = 0, inboundNodesData_1 = inboundNodesData; _i < inboundNodesData_1.length; _i++) {
                var nodeData = inboundNodesData_1[_i];
                if (!(nodeData instanceof Array)) {
                    throw new errors_1.ValueError("Corrupted configuration, expected array for nodeData: " + nodeData);
                }
                addUnprocessedNode(layer, nodeData);
            }
        }
        var name = config.name;
        var layersFromConfig = config.layers;
        for (var _i = 0, layersFromConfig_1 = layersFromConfig; _i < layersFromConfig_1.length; _i++) {
            var layerData = layersFromConfig_1[_i];
            processLayer(layerData);
        }
        while (!generic_utils.isObjectEmpty(unprocessedNodes)) {
            for (var _a = 0, layersFromConfig_2 = layersFromConfig; _a < layersFromConfig_2.length; _a++) {
                var layerData = layersFromConfig_2[_a];
                var layer = createdLayers[layerData.name];
                if (layer.name in unprocessedNodes) {
                    for (var _b = 0, _c = unprocessedNodes[layer.name]; _b < _c.length; _b++) {
                        var nodeData = _c[_b];
                        processNode(layer, nodeData);
                    }
                    delete unprocessedNodes[layer.name];
                }
            }
        }
        var inputTensors = [];
        var outputTensors = [];
        var inputLayersFromConfig = config.inputLayers;
        for (var _d = 0, inputLayersFromConfig_1 = inputLayersFromConfig; _d < inputLayersFromConfig_1.length; _d++) {
            var layerData = inputLayersFromConfig_1[_d];
            var layerName = layerData[0];
            var nodeIndex = layerData[1];
            var tensorIndex = layerData[2];
            generic_utils.assert(layerName in createdLayers);
            var layer = createdLayers[layerName];
            var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
            inputTensors.push(layerOutputTensors[tensorIndex]);
        }
        var outputLayersFromConfig = config.outputLayers;
        for (var _e = 0, outputLayersFromConfig_1 = outputLayersFromConfig; _e < outputLayersFromConfig_1.length; _e++) {
            var layerData = outputLayersFromConfig_1[_e];
            var layerName = layerData[0];
            var nodeIndex = layerData[1];
            var tensorIndex = layerData[2];
            generic_utils.assert(layerName in createdLayers);
            var layer = createdLayers[layerName];
            var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
            outputTensors.push(layerOutputTensors[tensorIndex]);
        }
        return new cls({ inputs: inputTensors, outputs: outputTensors, name: name });
    };
    Object.defineProperty(Container.prototype, "stateful", {
        get: function () {
            if (this._stateful) {
                throw new errors_1.ValueError('Container instance unexpectedly has _stateful = true. The ' +
                    'statefulness of a Container is determined by the Layers it ' +
                    'contains. Its _stateful property must remain the default false.');
            }
            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                if (layer.stateful) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Classes',
            namespace: 'layers',
            subclasses: ['Model']
        })
    ], Container.prototype, "getLayer", null);
    return Container;
}(Layer));
exports.Container = Container;
function getSourceInputs(tensor, layer, nodeIndex) {
    if (layer == null || (nodeIndex != null && nodeIndex > 0)) {
        layer = tensor.sourceLayer;
        nodeIndex = tensor.nodeIndex;
    }
    if (layer.inboundNodes.length === 0) {
        return [tensor];
    }
    else {
        var node = layer.inboundNodes[nodeIndex];
        if (node.inboundLayers.length === 0) {
            return node.inputTensors;
        }
        else {
            var sourceTensors = [];
            for (var i = 0; i < node.inboundLayers.length; i++) {
                var x = node.inputTensors[i];
                var layer_2 = node.inboundLayers[i];
                var nodeIndex_3 = node.nodeIndices[i];
                var previousSources = getSourceInputs(x, layer_2, nodeIndex_3);
                for (var _i = 0, previousSources_1 = previousSources; _i < previousSources_1.length; _i++) {
                    var x_1 = previousSources_1[_i];
                    if (sourceTensors.indexOf(x_1) === -1) {
                        sourceTensors.push(x_1);
                    }
                }
            }
            return sourceTensors;
        }
    }
}
exports.getSourceInputs = getSourceInputs;
function loadTensor(dtype, shape, value) {
    var dataType = generic_utils.stringToDType(dtype);
    return tfjs_core_1.Tensor.make(shape, { values: shape.length === 0 ? value : tfjs_core_1.util.flatten(value) }, dataType);
}
function preprocessWeightsForLoading(layer, weights, originalKerasVersion, originalBackend) {
    if (!originalKerasVersion.startsWith('2.')) {
        throw new errors_1.ValueError('Unsupported Keras version in weights being loaded: ' +
            originalKerasVersion);
    }
    return weights;
}
function loadWeightsFromNamedTensorMap(weights, layers) {
    var nameToWeight = {};
    var totalWeightsCount = 0;
    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
        var layer = layers_1[_i];
        for (var _a = 0, _b = layer.weights; _a < _b.length; _a++) {
            var weight = _b[_a];
            if (nameToWeight[weight.originalName] != null) {
                throw new errors_1.ValueError("Duplicate weight name: " + weight.originalName);
            }
            nameToWeight[weight.originalName] = weight;
            totalWeightsCount++;
        }
    }
    var weightValueTuples = [];
    for (var name_2 in weights) {
        weightValueTuples.push([nameToWeight[name_2], weights[name_2]]);
        delete nameToWeight[name_2];
    }
    var unsetNames = [];
    for (var name_3 in nameToWeight) {
        unsetNames.push(name_3);
    }
    if (unsetNames.length > 0) {
        throw new errors_1.ValueError(unsetNames.length + " of " + totalWeightsCount + " weights are not set: " +
            ("" + unsetNames));
    }
    variables_1.batchSetValue(weightValueTuples);
}
exports.loadWeightsFromNamedTensorMap = loadWeightsFromNamedTensorMap;
function loadWeightsFromJson(weightsJSON, layers, skipMismatch) {
    if (skipMismatch === void 0) { skipMismatch = false; }
    var originalKerasVersion = weightsJSON['keras_version'];
    var originalBackend = weightsJSON['backend'];
    var layerNames = layers.map(function (layer) { return layer.name; });
    var index = {};
    for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {
        var layer = layers_2[_i];
        if (layer.name != null) {
            if (index[layer.name] == null) {
                index[layer.name] = [];
            }
            index[layer.name].push(layer);
        }
    }
    var nameToWeights = weightsJSON['weights'];
    var weightValueTuples = [];
    for (var k = 0; k < layerNames.length; ++k) {
        var name_4 = layerNames[k];
        var layerWeights = nameToWeights[name_4];
        if (layerWeights == null) {
            layerWeights = [];
        }
        var weightValues = [];
        for (var n = 0; n < layerWeights.length; ++n) {
            var weightEntry = layerWeights[n];
            weightValues.push(new variables_1.LayerVariable(loadTensor(weightEntry['dtype'], weightEntry['shape'], weightEntry['value'])));
        }
        for (var _a = 0, _b = index[name_4]; _a < _b.length; _a++) {
            var layer = _b[_a];
            var symbolicWeights = layer.weights;
            weightValues = preprocessWeightsForLoading(layer, weightValues, originalKerasVersion, originalBackend);
            if (weightValues.length !== symbolicWeights.length) {
                if (skipMismatch) {
                    console.warn("Skipping loading of weights of layer " + layer.name + " " +
                        ("due to mismatch in number of weights: (" + weightValues.length + " ") +
                        ("vs " + symbolicWeights.length + ")."));
                }
                else {
                    throw new errors_1.ValueError("Layer #" + k + " (named \"" + layer.name + "\") expects " +
                        (symbolicWeights.length + " weight(s), but the saved weights ") +
                        ("have " + weightValues.length + " element(s)."));
                }
            }
            for (var i = 0; i < weightValues.length; ++i) {
                if (skipMismatch) {
                    if (!tfjs_core_1.util.arraysEqual(symbolicWeights[i].shape, weightValues[i].shape)) {
                        console.warn("Skipping loading of weights for layer " + layer.name + " due " +
                            ("to mismatch in shape (" + symbolicWeights[i].shape + " vs ") +
                            (weightValues[i].shape + ")"));
                        continue;
                    }
                }
                weightValueTuples.push([symbolicWeights[i], weightValues[i].read()]);
            }
        }
    }
    variables_1.batchSetValue(weightValueTuples);
}
exports.loadWeightsFromJson = loadWeightsFromJson;

},{"../backend/tfjs_backend":160,"../errors":167,"../layers/serialization":181,"../types":188,"../utils/generic_utils":190,"../utils/serialization_utils":192,"../variables":193,"../version":194,"@tensorflow/tfjs-core":51}],166:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var callbacks_1 = require("../callbacks");
var errors_1 = require("../errors");
var losses = require("../losses");
var Metrics = require("../metrics");
var optimizers = require("../optimizers");
var generic_utils_1 = require("../utils/generic_utils");
var math_utils_1 = require("../utils/math_utils");
var executor_1 = require("./executor");
var topology_1 = require("./topology");
function isDataTensor(x) {
    return x instanceof tfjs_core_1.Tensor;
}
exports.isDataTensor = isDataTensor;
function isDataArray(x) {
    return Array.isArray(x);
}
exports.isDataArray = isDataArray;
function isDataDict(x) {
    return !isDataTensor(x) && !isDataArray(x);
}
exports.isDataDict = isDataDict;
function standardizeInputData(data, names, shapes, checkBatchAxis, exceptionPrefix) {
    if (checkBatchAxis === void 0) { checkBatchAxis = true; }
    if (exceptionPrefix === void 0) { exceptionPrefix = ''; }
    if (names == null || names.length === 0) {
        if (data != null) {
            var gotUnexpectedData = false;
            if (isDataArray(data) && data.length > 0) {
                gotUnexpectedData = true;
            }
            else if (isDataDict(data)) {
                for (var key in data) {
                    if (data.hasOwnProperty(key)) {
                        gotUnexpectedData = true;
                        break;
                    }
                }
            }
            else {
                gotUnexpectedData = true;
            }
            if (gotUnexpectedData) {
                throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + " expected no data, " +
                    ("but got " + data));
            }
        }
        return [];
    }
    if (data == null) {
        return names.map(function (name) { return null; });
    }
    var arrays;
    if (isDataDict(data)) {
        data = data;
        arrays = [];
        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
            var name_1 = names_1[_i];
            if (data[name_1] == null) {
                throw new errors_1.ValueError("No data provided for \"" + name_1 + "\". Need data for each key in: " +
                    ("" + names));
            }
            arrays.push(data[name_1]);
        }
    }
    else if (isDataArray(data)) {
        data = data;
        if (data.length !== names.length) {
            throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + ": the Array of " +
                "Tensors that you are passing to your model is not the size the " +
                ("model expected. Expected to see " + names.length + " Tensor(s), but ") +
                ("instead got the following list of Tensor(s): " + data));
        }
        arrays = data;
    }
    else {
        data = data;
        if (names.length > 1) {
            throw new errors_1.ValueError("The model " + exceptionPrefix + " expects " + names.length + " Tensor(s), " +
                ("but only received one Tensor. Found: Tensor with shape " + data.shape));
        }
        arrays = [data];
    }
    for (var i = 0; i < names.length; ++i) {
        var array = arrays[i];
        if (array.shape.length === 1) {
            arrays[i] = K.expandDims(array, 1);
        }
    }
    if (shapes != null) {
        for (var i = 0; i < names.length; ++i) {
            if (shapes[i] == null) {
                continue;
            }
            var array = arrays[i];
            if (array.shape.length !== shapes[i].length) {
                throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                    ("to have " + shapes[i].length + " dimension(s). but got array with ") +
                    ("shape " + array.shape));
            }
            for (var j = 0; j < shapes[i].length; ++j) {
                if (j === 0 && !checkBatchAxis) {
                    continue;
                }
                var dim = array.shape[j];
                var refDim = shapes[i][j];
                if (refDim != null && refDim >= 0 && dim !== refDim) {
                    throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                        ("to have shape [" + shapes[i] + "], but got array with shape ") +
                        ("[" + array.shape + "]."));
                }
            }
        }
    }
    return arrays;
}
exports.standardizeInputData = standardizeInputData;
function checkArrayLengths(inputs, targets, weights) {
    var setX = generic_utils_1.unique(inputs.map(function (input) { return input.shape[0]; }));
    setX.sort();
    var setY = generic_utils_1.unique(targets.map(function (target) { return target.shape[0]; }));
    setY.sort();
    if (setX.length > 1) {
        throw new errors_1.ValueError("All input Tensors (x) should have the same number of samples. " +
            "Got array shapes: " +
            ("" + JSON.stringify(inputs.map(function (input) { return input.shape; }))));
    }
    if (setY.length > 1) {
        throw new errors_1.ValueError("All target Tensors (y) should have the same number of samples. " +
            "Got array shapes: " +
            ("" + JSON.stringify(targets.map(function (target) { return target.shape; }))));
    }
    if (setX.length > 0 && setY.length > 0 && !tfjs_core_1.util.arraysEqual(setX, setY)) {
        throw new errors_1.ValueError("Input Tensors should have the same number of samples as target " +
            ("Tensors. Found " + setX[0] + " input sample(s) and " + setY[0] + " target ") +
            "sample(s).");
    }
}
exports.checkArrayLengths = checkArrayLengths;
function checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {
    var keyLosses = [
        losses.meanSquaredError, losses.binaryCrossentropy,
        losses.categoricalCrossentropy
    ];
    for (var i = 0; i < targets.length; ++i) {
        var y = targets[i];
        var loss = lossFns[i];
        var shape = outputShapes[i];
        if (loss == null) {
            continue;
        }
        if (loss === losses.categoricalCrossentropy) {
            if (y.shape[y.shape.length - 1] === 1) {
                throw new errors_1.ValueError("You are passing a target array of shape " + y.shape + " while using " +
                    "a loss 'categorical_crossentropy'. 'categorical_crossentropy'" +
                    "expects targets to be binary matrices (1s and 0s) of shape " +
                    "[samples, classes].");
            }
        }
        if (keyLosses.indexOf(loss) !== -1) {
            var slicedYShape = y.shape.slice(1);
            var slicedShape = shape.slice(1);
            for (var j = 0; j < slicedYShape.length; ++j) {
                var targetDim = slicedYShape[j];
                var outDim = slicedShape[j];
                if (outDim != null && targetDim !== outDim) {
                    throw new errors_1.ValueError("A target Tensor with shape " + y.shape + " was passed for an " +
                        ("output of shape " + shape + ", while using a loss function that ") +
                        "expects targets to have the same shape as the output.");
                }
            }
        }
    }
}
function makeBatches(size, batchSize) {
    var output = [];
    var batchStart = 0;
    var batchEnd = null;
    while (batchStart < size) {
        batchEnd = batchStart + batchSize;
        if (batchEnd >= size) {
            batchEnd = size;
        }
        output.push([batchStart, batchEnd]);
        batchStart = batchEnd;
    }
    return output;
}
exports.makeBatches = makeBatches;
function sliceArrays(arrays, start, stop) {
    if (arrays == null) {
        return [null];
    }
    else if (Array.isArray(arrays)) {
        return arrays.map(function (array) { return K.sliceAlongFirstAxis(array, start, stop - start); });
    }
    else {
        return K.sliceAlongFirstAxis(arrays, start, stop - start);
    }
}
function sliceArraysByIndices(arrays, indices) {
    return tfc.tidy(function () {
        if (arrays == null) {
            return null;
        }
        else if (Array.isArray(arrays)) {
            return arrays.map(function (array) { return sliceArraysByIndices(array, indices); });
        }
        else {
            return K.gather(arrays, indices.dtype === 'int32' ? indices : indices.toInt());
        }
    });
}
exports.sliceArraysByIndices = sliceArraysByIndices;
function checkInputData(data, names, shapes, checkBatchAxis, exceptionPrefix) {
    if (checkBatchAxis === void 0) { checkBatchAxis = true; }
    if (exceptionPrefix === void 0) { exceptionPrefix = ''; }
    var arrays;
    if (Array.isArray(data)) {
        if (data.length !== names.length) {
            throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + ": the Array of " +
                "Tensors that you are passing to your model is not the size the " +
                ("the model expected. Expected to see " + names.length + " Tensor(s),") +
                (" but instead got " + data.length + " Tensors(s)."));
        }
        arrays = data;
    }
    else {
        if (names.length > 1) {
            throw new errors_1.ValueError("The model expects " + names.length + " " + exceptionPrefix + " Tensors, " +
                "but only received one Tensor. Found: array with shape " +
                (JSON.stringify(data.shape) + "."));
        }
        arrays = [data];
    }
    if (shapes != null) {
        for (var i = 0; i < names.length; ++i) {
            if (shapes[i] == null) {
                continue;
            }
            var array = arrays[i];
            if (array.shape.length !== shapes[i].length) {
                throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " +
                    ("to have " + shapes[i].length + " dimension(s), but got array with ") +
                    ("shape " + JSON.stringify(array.shape)));
            }
            for (var j = 0; j < shapes[i].length; ++j) {
                if (j === 0 && !checkBatchAxis) {
                    continue;
                }
                var dim = array.shape[j];
                var refDim = shapes[i][j];
                if (refDim != null) {
                    if (refDim !== dim) {
                        throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " +
                            (names[i] + " to have shape " + JSON.stringify(shapes[i]) + " but ") +
                            ("got array with shape " + JSON.stringify(array.shape) + "."));
                    }
                }
            }
        }
    }
}
function collectMetrics(metrics, outputNames) {
    if (metrics == null || Array.isArray(metrics) && metrics.length === 0) {
        return outputNames.map(function (name) { return []; });
    }
    if (Array.isArray(metrics)) {
        return outputNames.map(function (name) { return metrics; });
    }
    else if (metrics != null) {
        var nestedMetrics = [];
        for (var _i = 0, outputNames_1 = outputNames; _i < outputNames_1.length; _i++) {
            var name_2 = outputNames_1[_i];
            var outputMetrics = metrics.hasOwnProperty(name_2) ? metrics[name_2] : [];
            if (!Array.isArray(outputMetrics)) {
                outputMetrics = [outputMetrics];
            }
            nestedMetrics.push(outputMetrics);
        }
        return nestedMetrics;
    }
    else {
        throw new TypeError('Type of metrics argument not understood. Expected an Array or ' +
            'Object, found: ' + metrics);
    }
}
var ModelLoggingVerbosity;
(function (ModelLoggingVerbosity) {
    ModelLoggingVerbosity[ModelLoggingVerbosity["SILENT"] = 0] = "SILENT";
    ModelLoggingVerbosity[ModelLoggingVerbosity["VERBOSE"] = 1] = "VERBOSE";
})(ModelLoggingVerbosity = exports.ModelLoggingVerbosity || (exports.ModelLoggingVerbosity = {}));
var Model = (function (_super) {
    __extends(Model, _super);
    function Model(config) {
        return _super.call(this, config) || this;
    }
    Model.prototype.compile = function (config) {
        var _this = this;
        if (config.loss == null) {
            config.loss = [];
        }
        this.loss = config.loss;
        if (typeof config.optimizer === 'string') {
            this.optimizer = optimizers.getOptimizer(config.optimizer);
        }
        else {
            if (!(config.optimizer instanceof tfjs_core_1.Optimizer)) {
                throw new errors_1.ValueError("User-defined optimizer must be an instance of tf.Optimizer.");
            }
            this.optimizer = config.optimizer;
        }
        var lossFunctions = [];
        if (!Array.isArray(config.loss) && typeof config.loss !== 'string' &&
            typeof config.loss !== 'function') {
            config.loss = config.loss;
            for (var name_3 in config.loss) {
                if (this.outputNames.indexOf(name_3) === -1) {
                    throw new errors_1.ValueError("Unknown entry in loss dictionary: \"" + name_3 + "\". Only expect the " +
                        ("following keys: " + this.outputNames));
                }
            }
            for (var name_4 in this.outputNames) {
                if (config.loss[name_4] == null) {
                    console.warn("Output \"" + name_4 + "\" is missing from loss dictionary. We assume " +
                        "this was done on purpose, and we will not be expecting data " +
                        ("to be passed to " + name_4 + " during training"));
                }
                lossFunctions.push(losses.get(config.loss[name_4]));
            }
        }
        else if (Array.isArray(config.loss)) {
            if (config.loss.length !== this.outputs.length) {
                throw new errors_1.ValueError("When passing an Array as loss, it should have one entry per " +
                    ("model output. The model has " + this.outputs.length + " output(s), ") +
                    ("but you passed loss=" + config.loss + "."));
            }
            var theLosses = config.loss;
            lossFunctions = theLosses.map(function (l) { return losses.get(l); });
        }
        else {
            var lossFunction_1 = losses.get(config.loss);
            this.outputs.map(function (layer) {
                lossFunctions.push(lossFunction_1);
            });
        }
        this.lossFunctions = lossFunctions;
        this.feedOutputNames = [];
        this.feedOutputShapes = [];
        this.feedLossFns = [];
        for (var i = 0; i < this.outputs.length; ++i) {
            var shape = this.internalOutputShapes[i];
            var name_5 = this.outputNames[i];
            this.feedOutputNames.push(name_5);
            this.feedOutputShapes.push(shape);
            this.feedLossFns.push(this.lossFunctions[i]);
        }
        var skipTargetIndices = [];
        this.metrics = config.metrics;
        this.metricsNames = ['loss'];
        this.metricsTensors = [];
        K.nameScope('loss', function () {
            for (var i = 0; i < _this.outputs.length; ++i) {
                if (skipTargetIndices.indexOf(i) !== -1) {
                    continue;
                }
                var weightedLoss = _this.lossFunctions[i];
                if (_this.outputs.length > 1) {
                    _this.metricsTensors.push([weightedLoss, i]);
                    _this.metricsNames.push(_this.outputNames[i] + '_loss');
                }
            }
        });
        var nestedMetrics = collectMetrics(config.metrics, this.outputNames);
        var appendMetric = function (outputIndex, metricName, metricTensor) {
            if (_this.outputNames.length > 1) {
                metricName = _this.outputNames[outputIndex] + '_' + metricName;
            }
            _this.metricsNames.push(metricName);
            _this.metricsTensors.push([metricTensor, outputIndex]);
        };
        K.nameScope('metric', function () {
            var _loop_1 = function (i) {
                if (skipTargetIndices.indexOf(i) !== -1) {
                    return "continue";
                }
                var outputMetrics = nestedMetrics[i];
                var handleMetrics = function (metrics) {
                    var metricNamePrefix = '';
                    var metricName;
                    var accFn;
                    var weightedMetricFn;
                    var _loop_2 = function (metric) {
                        if (['accuracy', 'acc', 'crossentropy', 'ce'].indexOf(metric) !==
                            -1) {
                            var outputShape = _this.internalOutputShapes[i];
                            if (outputShape[outputShape.length - 1] === 1 ||
                                _this.lossFunctions[i] === losses.binaryCrossentropy) {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.binaryAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.binaryCrossentropy;
                                }
                            }
                            else if (_this.lossFunctions[i] ===
                                losses.sparseCategoricalCrossentropy) {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.sparseCategoricalAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.sparseCategoricalCrossentropy;
                                }
                            }
                            else {
                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                    accFn = Metrics.categoricalAccuracy;
                                }
                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                    accFn = Metrics.categoricalCrossentropy;
                                }
                            }
                            var suffix = void 0;
                            if (['accuracy', 'acc'].indexOf(metric) !== -1) {
                                suffix = 'acc';
                            }
                            else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {
                                suffix = 'ce';
                            }
                            weightedMetricFn = accFn;
                            metricName = metricNamePrefix + suffix;
                        }
                        else {
                            var metricFn = Metrics.get(metric);
                            weightedMetricFn = metricFn;
                            metricName = metricNamePrefix + metric;
                        }
                        var metricResult;
                        K.nameScope(metricName, function () {
                            metricResult = weightedMetricFn;
                        });
                        appendMetric(i, metricName, metricResult);
                    };
                    for (var _i = 0, metrics_1 = metrics; _i < metrics_1.length; _i++) {
                        var metric = metrics_1[_i];
                        _loop_2(metric);
                    }
                };
                handleMetrics(outputMetrics);
            };
            for (var i = 0; i < _this.outputs.length; ++i) {
                _loop_1(i);
            }
        });
        this.collectedTrainableWeights = this.trainableWeights;
    };
    Model.prototype.checkTrainableWeightsConsistency = function () {
        if (this.collectedTrainableWeights == null) {
            return;
        }
        if (this.trainableWeights.length !==
            this.collectedTrainableWeights.length) {
            console.warn('Discrepancy between trainableweights and collected trainable ' +
                'weights. Did you set `model.trainable` without calling ' +
                '`model.compile()` afterwards?');
        }
    };
    Model.prototype.evaluate = function (x, y, config) {
        if (config === void 0) { config = {}; }
        var batchSize = config.batchSize == null ? 32 : config.batchSize;
        var standardizedOuts = this.standardizeUserData(x, y, true, batchSize);
        var ins = standardizedOuts[0].concat(standardizedOuts[1]);
        this.makeTestFunction();
        var f = this.testFunction;
        var testOuts = this.testLoop(f, ins, batchSize, config.verbose, config.steps);
        return generic_utils_1.singletonOrArray(testOuts);
    };
    Model.prototype.checkNumSamples = function (ins, batchSize, steps, stepsName) {
        if (stepsName === void 0) { stepsName = 'steps'; }
        var numSamples;
        if (steps != null) {
            numSamples = null;
            if (batchSize != null) {
                throw new errors_1.ValueError("If " + stepsName + " is set, batchSize must be null or undefined." +
                    ("Got batchSize = " + batchSize));
            }
        }
        else if (ins != null) {
            if (Array.isArray(ins)) {
                numSamples = ins[0].shape[0];
            }
            else {
                numSamples = ins.shape[0];
            }
        }
        else {
            throw new errors_1.ValueError("Either the input data should have a defined shape, or " +
                (stepsName + " shoud be specified."));
        }
        return numSamples;
    };
    Model.prototype.predictLoop = function (ins, batchSize, verbose) {
        var _this = this;
        if (batchSize === void 0) { batchSize = 32; }
        if (verbose === void 0) { verbose = false; }
        var numSamples = this.checkNumSamples(ins);
        if (verbose) {
            throw new errors_1.NotImplementedError('Verbose predictLoop() is not implemented yet.');
        }
        var batches = makeBatches(numSamples, batchSize);
        var outs = [];
        var _loop_3 = function (batchIndex) {
            var batchOuts = tfc.tidy(function () {
                var batchStart = batches[batchIndex][0];
                var batchEnd = batches[batchIndex][1];
                var insBatch = sliceArrays(ins, batchStart, batchEnd);
                var feeds = [];
                if (Array.isArray(insBatch)) {
                    for (var i = 0; i < insBatch.length; ++i) {
                        feeds.push({ key: _this.inputs[i], value: insBatch[i] });
                    }
                }
                else {
                    feeds.push({ key: _this.inputs[0], value: insBatch });
                }
                var feedDict = new executor_1.FeedDict(feeds);
                return executor_1.execute(_this.outputs, feedDict);
            });
            if (batchIndex === 0) {
                for (var _i = 0, batchOuts_1 = batchOuts; _i < batchOuts_1.length; _i++) {
                    var batchOut = batchOuts_1[_i];
                    outs.push(batchOut);
                }
            }
            else {
                for (var i = 0; i < batchOuts.length; ++i) {
                    outs[i] = K.concatAlongFirstAxis(outs[i], batchOuts[i]);
                }
            }
        };
        for (var batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
            _loop_3(batchIndex);
        }
        return generic_utils_1.singletonOrArray(outs);
    };
    Model.prototype.predict = function (x, config) {
        if (config === void 0) { config = {}; }
        checkInputData(x, this.inputNames, this.feedInputShapes, false);
        var batchSize = config.batchSize == null ? 32 : config.batchSize;
        return this.predictLoop(x, batchSize);
    };
    Model.prototype.predictOnBatch = function (x) {
        checkInputData(x, this.inputNames, this.feedInputShapes, true);
        return this.predictLoop(x, x.shape[0]);
    };
    Model.prototype.standardizeUserData = function (x, y, checkBatchAxis, batchSize) {
        if (checkBatchAxis === void 0) { checkBatchAxis = true; }
        if (this.optimizer == null) {
            throw new errors_1.RuntimeError('You must compile a model before training/testing. Use ' +
                'Model.compile(modelCompileConfig).');
        }
        var outputShapes = [];
        for (var i = 0; i < this.feedOutputShapes.length; ++i) {
            var outputShape = this.feedOutputShapes[i];
            var lossFn = this.feedLossFns[i];
            if (lossFn === losses.sparseCategoricalCrossentropy) {
                outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]));
            }
            else {
                outputShapes.push(outputShape);
            }
        }
        x = standardizeInputData(x, this.feedInputNames, this.feedInputShapes, false, 'input');
        y = standardizeInputData(y, this.feedOutputNames, outputShapes, false, 'target');
        checkArrayLengths(x, y, null);
        checkLossAndTargetCompatibility(y, this.feedLossFns, this.feedOutputShapes);
        if (this.stateful && batchSize != null && batchSize > 0) {
            if (x[0].shape[0] % batchSize !== 0) {
                throw new errors_1.ValueError("In a stateful network, you should only pass inputs with a " +
                    "number of samples that is divisible by the batch size " +
                    (batchSize + ". Found: " + x[0].shape[0] + " sample(s)."));
            }
        }
        return [x, y, null];
    };
    Model.prototype.fitLoop = function (f, ins, outLabels, batchSize, epochs, verbose, callbacks, valF, valIns, shuffle, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {
        if (initialEpoch === void 0) { initialEpoch = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var doValidation, numTrainSamples, indexArray, callbackList, _loop_4, this_1, epoch, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (batchSize == null) {
                            batchSize = 32;
                        }
                        if (epochs == null) {
                            epochs = 1;
                        }
                        if (shuffle == null) {
                            shuffle = true;
                        }
                        if (initialEpoch == null) {
                            initialEpoch = 0;
                        }
                        doValidation = false;
                        if (valF != null && valIns != null) {
                            doValidation = true;
                        }
                        if (validationSteps != null) {
                            doValidation = true;
                            if (stepsPerEpoch == null) {
                                throw new errors_1.ValueError('Can only use `validationSteps` when doing step-wise training, ' +
                                    'i.e., `stepsPerEpoch` must be set.');
                            }
                        }
                        numTrainSamples = this.checkNumSamples(ins, batchSize, stepsPerEpoch, 'steps_per_epoch');
                        if (numTrainSamples != null) {
                            indexArray = math_utils_1.range(0, numTrainSamples);
                        }
                        this.history = new callbacks_1.History();
                        if (callbacks == null) {
                            callbacks = [new callbacks_1.BaseLogger()];
                        }
                        else {
                            callbacks = [new callbacks_1.BaseLogger()].concat(callbacks);
                        }
                        callbacks = callbacks.concat([this.history]);
                        if (verbose > 0) {
                            throw new errors_1.NotImplementedError('Verbose mode is not implemented yet.');
                        }
                        callbackList = new callbacks_1.CallbackList(callbacks);
                        callbackList.setModel(this);
                        callbackList.setParams({
                            epochs: epochs,
                            steps: stepsPerEpoch,
                            verbose: verbose,
                            doValidation: doValidation,
                            metrics: callbackMetrics,
                        });
                        return [4, callbackList.onTrainBegin()];
                    case 1:
                        _a.sent();
                        this.stopTraining = false;
                        _loop_4 = function (epoch) {
                            var epochLogs, epochIndexArray1D_1, batches_1, _loop_5, batchIndex, state_2;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4, callbackList.onEpochBegin(epoch)];
                                    case 1:
                                        _a.sent();
                                        epochLogs = {};
                                        if (!(stepsPerEpoch != null)) return [3, 2];
                                        throw new errors_1.NotImplementedError('stepsPerEpoch mode is not implemented yet.');
                                    case 2:
                                        if (shuffle === 'batch') {
                                            throw new errors_1.NotImplementedError('batch shuffling is not implemneted yet');
                                        }
                                        else if (shuffle) {
                                            tfjs_core_1.util.shuffle(indexArray);
                                        }
                                        epochIndexArray1D_1 = tfjs_core_1.tensor1d(indexArray);
                                        batches_1 = makeBatches(numTrainSamples, batchSize);
                                        _loop_5 = function (batchIndex) {
                                            var batchLogs;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        batchLogs = {};
                                                        return [4, callbackList.onBatchBegin(batchIndex, batchLogs)];
                                                    case 1:
                                                        _a.sent();
                                                        tfc.tidy(function () {
                                                            var batchStart = batches_1[batchIndex][0];
                                                            var batchEnd = batches_1[batchIndex][1];
                                                            var batchIds = K.sliceAlongFirstAxis(epochIndexArray1D_1, batchStart, batchEnd - batchStart);
                                                            batchLogs['batch'] = batchIndex;
                                                            batchLogs['size'] = batchEnd - batchStart;
                                                            var insBatch = sliceArraysByIndices(ins, batchIds);
                                                            var outs = f(insBatch);
                                                            for (var i = 0; i < outLabels.length; ++i) {
                                                                var label = outLabels[i];
                                                                var out = outs[i];
                                                                batchLogs[label] = out;
                                                                tfc.keep(out);
                                                            }
                                                            if (batchIndex === batches_1.length - 1) {
                                                                if (doValidation) {
                                                                    var valOuts = _this.testLoop(valF, valIns, batchSize);
                                                                    for (var i = 0; i < outLabels.length; ++i) {
                                                                        var label = outLabels[i];
                                                                        var out = valOuts[i];
                                                                        tfc.keep(out);
                                                                        epochLogs['val_' + label] = out;
                                                                    }
                                                                }
                                                            }
                                                        });
                                                        return [4, callbackList.onBatchEnd(batchIndex, batchLogs)];
                                                    case 2:
                                                        _a.sent();
                                                        callbacks_1.disposeTensorsInLogs(batchLogs);
                                                        if (this_1.stopTraining) {
                                                            return [2, "break"];
                                                        }
                                                        return [2];
                                                }
                                            });
                                        };
                                        batchIndex = 0;
                                        _a.label = 3;
                                    case 3:
                                        if (!(batchIndex < batches_1.length)) return [3, 6];
                                        return [5, _loop_5(batchIndex)];
                                    case 4:
                                        state_2 = _a.sent();
                                        if (state_2 === "break")
                                            return [3, 6];
                                        _a.label = 5;
                                    case 5:
                                        ++batchIndex;
                                        return [3, 3];
                                    case 6:
                                        epochIndexArray1D_1.dispose();
                                        _a.label = 7;
                                    case 7: return [4, callbackList.onEpochEnd(epoch, epochLogs)];
                                    case 8:
                                        _a.sent();
                                        if (this_1.stopTraining) {
                                            return [2, "break"];
                                        }
                                        return [2];
                                }
                            });
                        };
                        this_1 = this;
                        epoch = initialEpoch;
                        _a.label = 2;
                    case 2:
                        if (!(epoch < epochs)) return [3, 5];
                        return [5, _loop_4(epoch)];
                    case 3:
                        state_1 = _a.sent();
                        if (state_1 === "break")
                            return [3, 5];
                        _a.label = 4;
                    case 4:
                        ++epoch;
                        return [3, 2];
                    case 5: return [4, callbackList.onTrainEnd()];
                    case 6:
                        _a.sent();
                        return [4, this.history.syncData()];
                    case 7:
                        _a.sent();
                        return [2, this.history];
                }
            });
        });
    };
    Model.prototype.testLoop = function (f, ins, batchSize, verbose, steps) {
        if (verbose === void 0) { verbose = 0; }
        var numSamples = this.checkNumSamples(ins, batchSize, steps, 'steps');
        var outs = [];
        if (verbose === 1) {
            throw new errors_1.NotImplementedError('Verbose mode is not implemented yet.');
        }
        if (steps != null) {
            throw new errors_1.NotImplementedError('steps mode in testLoop() is not implemented yet');
        }
        else {
            var batches = makeBatches(numSamples, batchSize);
            var indexArray = tfjs_core_1.tensor1d(math_utils_1.range(0, numSamples));
            for (var batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
                var batchStart = batches[batchIndex][0];
                var batchEnd = batches[batchIndex][1];
                var batchIds = K.sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);
                var insBatch = sliceArraysByIndices(ins, batchIds);
                var batchOuts = f(insBatch);
                if (batchIndex === 0) {
                    for (var i = 0; i < batchOuts.length; ++i) {
                        outs.push(K.getScalar(0));
                    }
                }
                for (var i = 0; i < batchOuts.length; ++i) {
                    var batchOut = batchOuts[i];
                    outs[i] =
                        tfc.add(outs[i], K.scalarTimesArray(K.getScalar(batchEnd - batchStart), batchOut));
                }
            }
            for (var i = 0; i < outs.length; ++i) {
                outs[i] = tfc.div(outs[i], K.getScalar(numSamples));
            }
        }
        return outs;
    };
    Model.prototype.getDedupedMetricsNames = function () {
        var outLabels = this.metricsNames;
        var dedupedOutLabels = [];
        for (var i = 0; i < outLabels.length; ++i) {
            var label = outLabels[i];
            var newLabel = label;
            if (generic_utils_1.count(outLabels, label) > 1) {
                var dupIndex = generic_utils_1.count(outLabels.slice(0, i), label);
                newLabel += "_" + dupIndex;
            }
            dedupedOutLabels.push(newLabel);
        }
        return dedupedOutLabels;
    };
    Model.prototype.makeTestFunction = function () {
        var _this = this;
        this.testFunction = function (data) {
            return tfc.tidy(function () {
                var valOutputs = [];
                var totalLoss;
                var inputs = data.slice(0, _this.inputs.length);
                var targets = data.slice(_this.inputs.length, _this.inputs.length + _this.outputs.length);
                var feeds = [];
                for (var i = 0; i < _this.inputs.length; ++i) {
                    feeds.push({ key: _this.inputs[i], value: inputs[i] });
                }
                var feedDict = new executor_1.FeedDict(feeds);
                var outputs = executor_1.execute(_this.outputs, feedDict);
                for (var i = 0; i < _this.lossFunctions.length; ++i) {
                    var lossFunction = _this.lossFunctions[i];
                    var loss = tfc.mean(lossFunction(targets[i], outputs[i]));
                    if (i === 0) {
                        totalLoss = loss;
                    }
                    else {
                        totalLoss = tfc.add(totalLoss, loss);
                    }
                    valOutputs.push(totalLoss);
                }
                for (var i = 0; i < _this.metricsTensors.length; ++i) {
                    var metric = _this.metricsTensors[i][0];
                    var outputIndex = _this.metricsTensors[i][1];
                    var meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));
                    valOutputs.push(meanMetric);
                }
                return valOutputs;
            });
        };
    };
    Model.prototype.fit = function (x, y, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var batchSize, standardizedOuts, inputs, targets, doValidation, valX, valY, valIns, needValidationDisposal, valStandardized, splitAt, originalBatchSize, ins, trainFunction, outLabels, valFunction, callbackMetrics, callbacks, out;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        batchSize = config.batchSize == null ? 32 : config.batchSize;
                        standardizedOuts = this.standardizeUserData(x, y, false, batchSize);
                        inputs = standardizedOuts[0];
                        targets = standardizedOuts[1];
                        doValidation = false;
                        needValidationDisposal = false;
                        if (config.validationData != null && config.validationData.length > 0) {
                            doValidation = true;
                            if (config.validationData.length === 2) {
                                valX = config.validationData[0];
                                valY = config.validationData[1];
                            }
                            else if (config.validationData.length === 3) {
                                throw new errors_1.NotImplementedError('validationData including sample weights is not supported yet.');
                            }
                            else {
                                throw new errors_1.ValueError("When passing validation data, it must contain 2 (valX, valY) " +
                                    "or 3 (valX, valY, valSampleWeight) items; " +
                                    (config.validationData + " is invalid."));
                            }
                            valStandardized = this.standardizeUserData(valX, valY, true, batchSize);
                            valX = valStandardized[0];
                            valY = valStandardized[1];
                            valIns = valX.concat(valY);
                        }
                        else if (config.validationSplit != null && config.validationSplit > 0 &&
                            config.validationSplit < 1) {
                            doValidation = true;
                            splitAt = Math.floor(inputs[0].shape[0] * (1 - config.validationSplit));
                            originalBatchSize = inputs[0].shape[0];
                            valX = sliceArrays(inputs, splitAt, originalBatchSize);
                            inputs = sliceArrays(inputs, 0, splitAt);
                            valY = sliceArrays(targets, splitAt, originalBatchSize);
                            targets = sliceArrays(targets, 0, splitAt);
                            needValidationDisposal = true;
                            valIns = valX.concat(valY);
                        }
                        else if (config.validationSteps != null) {
                            doValidation = true;
                        }
                        ins = inputs.concat(targets);
                        this.checkTrainableWeightsConsistency();
                        trainFunction = function (data) {
                            var losses = [];
                            var lossValues = [];
                            var inputs = data.slice(0, _this.inputs.length);
                            var targets = data.slice(_this.inputs.length, _this.inputs.length + _this.outputs.length);
                            var metricsValues = [];
                            var totalLossFunction = function () {
                                var feeds = [];
                                for (var i = 0; i < _this.inputs.length; ++i) {
                                    feeds.push({ key: _this.inputs[i], value: inputs[i] });
                                }
                                var feedDict = new executor_1.FeedDict(feeds);
                                var outputs = executor_1.execute(_this.outputs, feedDict, { 'training': true });
                                var totalLoss;
                                for (var i = 0; i < _this.lossFunctions.length; ++i) {
                                    var lossFunction = _this.lossFunctions[i];
                                    var loss = lossFunction(targets[i], outputs[i]);
                                    losses.push(loss);
                                    var meanLoss = tfc.mean(loss);
                                    lossValues.push(meanLoss);
                                    if (i === 0) {
                                        totalLoss = loss;
                                    }
                                    else {
                                        totalLoss = tfc.add(totalLoss, loss);
                                    }
                                }
                                for (var i = 0; i < _this.metricsTensors.length; ++i) {
                                    var metric = _this.metricsTensors[i][0];
                                    var outputIndex = _this.metricsTensors[i][1];
                                    var meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));
                                    tfc.keep(meanMetric);
                                    metricsValues.push(meanMetric);
                                }
                                totalLoss = tfc.mean(totalLoss);
                                _this.calculateLosses().forEach(function (regularizerLoss) {
                                    totalLoss = tfc.add(totalLoss, regularizerLoss);
                                });
                                return totalLoss;
                            };
                            var variables = _this.collectedTrainableWeights.map(function (param) { return param.read(); });
                            var returnCost = true;
                            var totalLossValue = _this.optimizer.minimize(totalLossFunction, returnCost, variables);
                            return [totalLossValue].concat(metricsValues);
                        };
                        outLabels = this.getDedupedMetricsNames();
                        if (doValidation) {
                            this.makeTestFunction();
                            valFunction = this.testFunction;
                            callbackMetrics =
                                outLabels.slice().concat(outLabels.map(function (n) { return 'val_' + n; }));
                        }
                        else {
                            valFunction = null;
                            valIns = [];
                            callbackMetrics = outLabels.slice();
                        }
                        callbacks = callbacks_1.standardizeCallbacks(config.callbacks);
                        return [4, this.fitLoop(trainFunction, ins, outLabels, batchSize, config.epochs, config.verbose, callbacks, valFunction, valIns, config.shuffle, callbackMetrics, null, null, null)];
                    case 1:
                        out = _a.sent();
                        if (needValidationDisposal) {
                            valIns.forEach(function (tensor) { return tensor.dispose(); });
                            inputs.forEach(function (tensor) { return tensor.dispose(); });
                            targets.forEach(function (tensor) { return tensor.dispose(); });
                        }
                        return [2, out];
                }
            });
        });
    };
    Model.prototype.getNamedWeights = function (config) {
        var namedWeights = {};
        var trainableOnly = config != null && config.trainableOnly;
        var weights = trainableOnly ? this.trainableWeights : this.weights;
        var weightValues = this.getWeights(trainableOnly);
        for (var i = 0; i < weights.length; ++i) {
            if (trainableOnly && !weights[i].trainable) {
                continue;
            }
            namedWeights[weights[i].originalName] = weightValues[i];
        }
        return namedWeights;
    };
    Model.prototype.save = function (handlerOrURL, config) {
        return __awaiter(this, void 0, void 0, function () {
            var handlers, weightDataAndSpecs, returnString, unusedArg, modelConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof handlerOrURL === 'string') {
                            handlers = tfjs_core_1.io.getSaveHandlers(handlerOrURL);
                            if (handlers.length === 0) {
                                throw new errors_1.ValueError("Cannot find any save handlers for URL '" + handlerOrURL + "'");
                            }
                            else if (handlers.length > 1) {
                                throw new errors_1.ValueError("Found more than one (" + handlers.length + ") save handlers for " +
                                    ("URL '" + handlerOrURL + "'"));
                            }
                            handlerOrURL = handlers[0];
                        }
                        if (handlerOrURL.save == null) {
                            throw new errors_1.ValueError('Model.save() cannot proceed because the IOHandler provided does ' +
                                'not have the `save` attribute defined.');
                        }
                        return [4, tfjs_core_1.io.encodeWeights(this.getNamedWeights(config))];
                    case 1:
                        weightDataAndSpecs = _a.sent();
                        returnString = false;
                        unusedArg = null;
                        modelConfig = this.toJSON(unusedArg, returnString);
                        return [2, handlerOrURL.save({
                                modelTopology: modelConfig,
                                weightData: weightDataAndSpecs.data,
                                weightSpecs: weightDataAndSpecs.specs
                            })];
                }
            });
        });
    };
    Model.className = 'Model';
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [0] })
    ], Model.prototype, "compile", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })
    ], Model.prototype, "evaluate", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [1] })
    ], Model.prototype, "predict", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes' })
    ], Model.prototype, "predictOnBatch", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })
    ], Model.prototype, "fit", null);
    Model = __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes' })
    ], Model);
    return Model;
}(topology_1.Container));
exports.Model = Model;
tfjs_core_1.serialization.SerializationMap.register(Model);

},{"../backend/tfjs_backend":160,"../callbacks":161,"../errors":167,"../losses":183,"../metrics":184,"../optimizers":186,"../utils/generic_utils":190,"../utils/math_utils":191,"./executor":164,"./topology":165,"@tensorflow/tfjs-core":51}],167:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AttributeError = (function (_super) {
    __extends(AttributeError, _super);
    function AttributeError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, AttributeError.prototype);
        return _this;
    }
    return AttributeError;
}(Error));
exports.AttributeError = AttributeError;
var RuntimeError = (function (_super) {
    __extends(RuntimeError, _super);
    function RuntimeError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, RuntimeError.prototype);
        return _this;
    }
    return RuntimeError;
}(Error));
exports.RuntimeError = RuntimeError;
var ValueError = (function (_super) {
    __extends(ValueError, _super);
    function ValueError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ValueError.prototype);
        return _this;
    }
    return ValueError;
}(Error));
exports.ValueError = ValueError;
var NotImplementedError = (function (_super) {
    __extends(NotImplementedError, _super);
    function NotImplementedError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, NotImplementedError.prototype);
        return _this;
    }
    return NotImplementedError;
}(Error));
exports.NotImplementedError = NotImplementedError;
var AssertionError = (function (_super) {
    __extends(AssertionError, _super);
    function AssertionError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, AssertionError.prototype);
        return _this;
    }
    return AssertionError;
}(Error));
exports.AssertionError = AssertionError;
var IndexError = (function (_super) {
    __extends(IndexError, _super);
    function IndexError(message) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, IndexError.prototype);
        return _this;
    }
    return IndexError;
}(Error));
exports.IndexError = IndexError;

},{}],168:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var constraints_1 = require("./constraints");
var topology_1 = require("./engine/topology");
var training_1 = require("./engine/training");
var initializers_1 = require("./initializers");
var advanced_activations_1 = require("./layers/advanced_activations");
var convolutional_1 = require("./layers/convolutional");
var convolutional_depthwise_1 = require("./layers/convolutional_depthwise");
var core_1 = require("./layers/core");
var embeddings_1 = require("./layers/embeddings");
var merge_1 = require("./layers/merge");
var normalization_1 = require("./layers/normalization");
var padding_1 = require("./layers/padding");
var pooling_1 = require("./layers/pooling");
var recurrent_1 = require("./layers/recurrent");
var wrappers_1 = require("./layers/wrappers");
var losses_1 = require("./losses");
var metrics_1 = require("./metrics");
var models_1 = require("./models");
var regularizers_1 = require("./regularizers");
var ModelExports = (function () {
    function ModelExports() {
    }
    ModelExports.model = function (config) {
        return new training_1.Model(config);
    };
    ModelExports.sequential = function (config) {
        return new models_1.Sequential(config);
    };
    ModelExports.loadModel = function (pathOrIOHandler) {
        return models_1.loadModelInternal(pathOrIOHandler);
    };
    ModelExports.input = function (config) {
        return topology_1.Input(config);
    };
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Creation', configParamIndices: [0] })
    ], ModelExports, "model", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Creation', configParamIndices: [0] })
    ], ModelExports, "sequential", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Models',
            subheading: 'Loading',
            useDocsFrom: 'loadModelInternal'
        })
    ], ModelExports, "loadModel", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Models',
            subheading: 'Inputs',
            useDocsFrom: 'Input',
            configParamIndices: [0]
        })
    ], ModelExports, "input", null);
    return ModelExports;
}());
exports.ModelExports = ModelExports;
var LayerExports = (function () {
    function LayerExports() {
    }
    LayerExports.inputLayer = function (config) {
        return new topology_1.InputLayer(config);
    };
    LayerExports.elu = function (config) {
        return new advanced_activations_1.ELU(config);
    };
    LayerExports.leakyReLU = function (config) {
        return new advanced_activations_1.LeakyReLU(config);
    };
    LayerExports.softmax = function (config) {
        return new advanced_activations_1.Softmax(config);
    };
    LayerExports.thresholdedReLU = function (config) {
        return new advanced_activations_1.ThresholdedReLU(config);
    };
    LayerExports.conv1d = function (config) {
        return new convolutional_1.Conv1D(config);
    };
    LayerExports.conv2d = function (config) {
        return new convolutional_1.Conv2D(config);
    };
    LayerExports.conv2dTranspose = function (config) {
        return new convolutional_1.Conv2DTranspose(config);
    };
    LayerExports.separableConv2d = function (config) {
        return new convolutional_1.SeparableConv2D(config);
    };
    LayerExports.cropping2D = function (config) {
        return new convolutional_1.Cropping2D(config);
    };
    LayerExports.upSampling2d = function (config) {
        return new convolutional_1.UpSampling2D(config);
    };
    LayerExports.depthwiseConv2d = function (config) {
        return new convolutional_depthwise_1.DepthwiseConv2D(config);
    };
    LayerExports.activation = function (config) {
        return new core_1.Activation(config);
    };
    LayerExports.dense = function (config) {
        return new core_1.Dense(config);
    };
    LayerExports.dropout = function (config) {
        return new core_1.Dropout(config);
    };
    LayerExports.flatten = function (config) {
        return new core_1.Flatten(config);
    };
    LayerExports.repeatVector = function (config) {
        return new core_1.RepeatVector(config);
    };
    LayerExports.reshape = function (config) {
        return new core_1.Reshape(config);
    };
    LayerExports.embedding = function (config) {
        return new embeddings_1.Embedding(config);
    };
    LayerExports.add = function (config) {
        return new merge_1.Add(config);
    };
    LayerExports.average = function (config) {
        return new merge_1.Average(config);
    };
    LayerExports.concatenate = function (config) {
        return new merge_1.Concatenate(config);
    };
    LayerExports.maximum = function (config) {
        return new merge_1.Maximum(config);
    };
    LayerExports.minimum = function (config) {
        return new merge_1.Minimum(config);
    };
    LayerExports.multiply = function (config) {
        return new merge_1.Multiply(config);
    };
    LayerExports.batchNormalization = function (config) {
        return new normalization_1.BatchNormalization(config);
    };
    LayerExports.zeroPadding2d = function (config) {
        return new padding_1.ZeroPadding2D(config);
    };
    LayerExports.averagePooling1d = function (config) {
        return new pooling_1.AveragePooling1D(config);
    };
    LayerExports.avgPool1d = function (config) {
        return LayerExports.averagePooling1d(config);
    };
    LayerExports.avgPooling1d = function (config) {
        return LayerExports.averagePooling1d(config);
    };
    LayerExports.averagePooling2d = function (config) {
        return new pooling_1.AveragePooling2D(config);
    };
    LayerExports.avgPool2d = function (config) {
        return LayerExports.averagePooling2d(config);
    };
    LayerExports.avgPooling2d = function (config) {
        return LayerExports.averagePooling2d(config);
    };
    LayerExports.globalAveragePooling1d = function (config) {
        return new pooling_1.GlobalAveragePooling1D(config);
    };
    LayerExports.globalAveragePooling2d = function (config) {
        return new pooling_1.GlobalAveragePooling2D(config);
    };
    LayerExports.globalMaxPooling1d = function (config) {
        return new pooling_1.GlobalMaxPooling1D(config);
    };
    LayerExports.globalMaxPooling2d = function (config) {
        return new pooling_1.GlobalMaxPooling2D(config);
    };
    LayerExports.maxPooling1d = function (config) {
        return new pooling_1.MaxPooling1D(config);
    };
    LayerExports.maxPooling2d = function (config) {
        return new pooling_1.MaxPooling2D(config);
    };
    LayerExports.gru = function (config) {
        return new recurrent_1.GRU(config);
    };
    LayerExports.gruCell = function (config) {
        return new recurrent_1.GRUCell(config);
    };
    LayerExports.lstm = function (config) {
        return new recurrent_1.LSTM(config);
    };
    LayerExports.lstmCell = function (config) {
        return new recurrent_1.LSTMCell(config);
    };
    LayerExports.simpleRNN = function (config) {
        return new recurrent_1.SimpleRNN(config);
    };
    LayerExports.simpleRNNCell = function (config) {
        return new recurrent_1.SimpleRNNCell(config);
    };
    LayerExports.rnn = function (config) {
        return new recurrent_1.RNN(config);
    };
    LayerExports.stackedRNNCells = function (config) {
        return new recurrent_1.StackedRNNCells(config);
    };
    LayerExports.bidirectional = function (config) {
        return new wrappers_1.Bidirectional(config);
    };
    LayerExports.timeDistributed = function (config) {
        return new wrappers_1.TimeDistributed(config);
    };
    LayerExports.Layer = topology_1.Layer;
    LayerExports.RNN = recurrent_1.RNN;
    LayerExports.RNNCell = recurrent_1.RNNCell;
    LayerExports.input = ModelExports.input;
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Inputs',
            namespace: 'layers',
            useDocsFrom: 'InputLayer',
            configParamIndices: [0]
        })
    ], LayerExports, "inputLayer", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Advanced Activation',
            namespace: 'layers',
            useDocsFrom: 'ELU',
            configParamIndices: [0]
        })
    ], LayerExports, "elu", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Advanced Activation',
            namespace: 'layers',
            useDocsFrom: 'LeakyReLU',
            configParamIndices: [0]
        })
    ], LayerExports, "leakyReLU", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Advanced Activation',
            namespace: 'layers',
            useDocsFrom: 'Softmax',
            configParamIndices: [0]
        })
    ], LayerExports, "softmax", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Advanced Activation',
            namespace: 'layers',
            useDocsFrom: 'ThresholdedReLU',
            configParamIndices: [0]
        })
    ], LayerExports, "thresholdedReLU", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'Conv1D',
            configParamIndices: [0]
        })
    ], LayerExports, "conv1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'Conv2D',
            configParamIndices: [0]
        })
    ], LayerExports, "conv2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'Conv2DTranspose',
            configParamIndices: [0]
        })
    ], LayerExports, "conv2dTranspose", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'SeparableConv2D',
            configParamIndices: [0]
        })
    ], LayerExports, "separableConv2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'Cropping2D',
            configParamIndices: [0]
        })
    ], LayerExports, "cropping2D", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'UpSampling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "upSampling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Convolutional',
            namespace: 'layers',
            useDocsFrom: 'DepthwiseConv2D',
            configParamIndices: [0]
        })
    ], LayerExports, "depthwiseConv2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Activation',
            configParamIndices: [0]
        })
    ], LayerExports, "activation", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Dense',
            configParamIndices: [0]
        })
    ], LayerExports, "dense", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Dropout',
            configParamIndices: [0]
        })
    ], LayerExports, "dropout", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Flatten',
            configParamIndices: [0]
        })
    ], LayerExports, "flatten", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'RepeatVector',
            configParamIndices: [0]
        })
    ], LayerExports, "repeatVector", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Reshape',
            configParamIndices: [0]
        })
    ], LayerExports, "reshape", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Basic',
            namespace: 'layers',
            useDocsFrom: 'Embedding',
            configParamIndices: [0]
        })
    ], LayerExports, "embedding", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Add',
            configParamIndices: [0]
        })
    ], LayerExports, "add", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Average',
            configParamIndices: [0]
        })
    ], LayerExports, "average", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Concatenate',
            configParamIndices: [0]
        })
    ], LayerExports, "concatenate", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Maximum',
            configParamIndices: [0]
        })
    ], LayerExports, "maximum", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Minimum',
            configParamIndices: [0]
        })
    ], LayerExports, "minimum", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Merge',
            namespace: 'layers',
            useDocsFrom: 'Multiply',
            configParamIndices: [0]
        })
    ], LayerExports, "multiply", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Normalization',
            namespace: 'layers',
            useDocsFrom: 'BatchNormalization',
            configParamIndices: [0]
        })
    ], LayerExports, "batchNormalization", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Padding',
            namespace: 'layers',
            useDocsFrom: 'ZeroPadding2D',
            configParamIndices: [0]
        })
    ], LayerExports, "zeroPadding2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'AveragePooling1D',
            configParamIndices: [0]
        })
    ], LayerExports, "averagePooling1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'AveragePooling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "averagePooling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'GlobalAveragePooling1D',
            configParamIndices: [0]
        })
    ], LayerExports, "globalAveragePooling1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'GlobalAveragePooling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "globalAveragePooling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'GlobalMaxPooling1D',
            configParamIndices: [0]
        })
    ], LayerExports, "globalMaxPooling1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'GlobalMaxPooling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "globalMaxPooling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'MaxPooling1D',
            configParamIndices: [0]
        })
    ], LayerExports, "maxPooling1d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Pooling',
            namespace: 'layers',
            useDocsFrom: 'MaxPooling2D',
            configParamIndices: [0]
        })
    ], LayerExports, "maxPooling2d", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'GRU',
            configParamIndices: [0]
        })
    ], LayerExports, "gru", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'GRUCell',
            configParamIndices: [0]
        })
    ], LayerExports, "gruCell", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'LSTM',
            configParamIndices: [0]
        })
    ], LayerExports, "lstm", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'LSTMCell',
            configParamIndices: [0]
        })
    ], LayerExports, "lstmCell", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'SimpleRNN',
            configParamIndices: [0]
        })
    ], LayerExports, "simpleRNN", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'SimpleRNNCell',
            configParamIndices: [0]
        })
    ], LayerExports, "simpleRNNCell", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'RNN',
            configParamIndices: [0]
        })
    ], LayerExports, "rnn", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Recurrent',
            namespace: 'layers',
            useDocsFrom: 'RNN',
            configParamIndices: [0]
        })
    ], LayerExports, "stackedRNNCells", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Wrapper',
            namespace: 'layers',
            useDocsFrom: 'Bidirectional',
            configParamIndices: [0]
        })
    ], LayerExports, "bidirectional", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Layers',
            subheading: 'Wrapper',
            namespace: 'layers',
            useDocsFrom: 'TimeDistributed',
            configParamIndices: [0]
        })
    ], LayerExports, "timeDistributed", null);
    return LayerExports;
}());
exports.LayerExports = LayerExports;
var ConstraintExports = (function () {
    function ConstraintExports() {
    }
    ConstraintExports.maxNorm = function (config) {
        return new constraints_1.MaxNorm(config);
    };
    ConstraintExports.unitNorm = function (config) {
        return new constraints_1.UnitNorm(config);
    };
    ConstraintExports.nonNeg = function () {
        return new constraints_1.NonNeg();
    };
    ConstraintExports.minMaxNorm = function (config) {
        return new constraints_1.MinMaxNorm(config);
    };
    __decorate([
        tfjs_core_1.doc({
            heading: 'Constraints',
            namespace: 'constraints',
            useDocsFrom: 'MaxNorm',
            configParamIndices: [0]
        })
    ], ConstraintExports, "maxNorm", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Constraints',
            namespace: 'constraints',
            useDocsFrom: 'UnitNorm',
            configParamIndices: [0]
        })
    ], ConstraintExports, "unitNorm", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Constraints', namespace: 'constraints', useDocsFrom: 'NonNeg' })
    ], ConstraintExports, "nonNeg", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Constraints',
            namespace: 'constraints',
            useDocsFrom: 'MinMaxNormConfig',
            configParamIndices: [0]
        })
    ], ConstraintExports, "minMaxNorm", null);
    return ConstraintExports;
}());
exports.ConstraintExports = ConstraintExports;
var InitializerExports = (function () {
    function InitializerExports() {
    }
    InitializerExports.zeros = function () {
        return new initializers_1.Zeros();
    };
    InitializerExports.ones = function () {
        return new initializers_1.Ones();
    };
    InitializerExports.constant = function (config) {
        return new initializers_1.Constant(config);
    };
    InitializerExports.randomUniform = function (config) {
        return new initializers_1.RandomUniform(config);
    };
    InitializerExports.randomNormal = function (config) {
        return new initializers_1.RandomNormal(config);
    };
    InitializerExports.truncatedNormal = function (config) {
        return new initializers_1.TruncatedNormal(config);
    };
    InitializerExports.identity = function (config) {
        return new initializers_1.Identity(config);
    };
    InitializerExports.varianceScaling = function (config) {
        return new initializers_1.VarianceScaling(config);
    };
    InitializerExports.glorotUniform = function (config) {
        return new initializers_1.GlorotUniform(config);
    };
    InitializerExports.glorotNormal = function (config) {
        return new initializers_1.GlorotNormal(config);
    };
    InitializerExports.heNormal = function (config) {
        return new initializers_1.HeNormal(config);
    };
    InitializerExports.leCunNormal = function (config) {
        return new initializers_1.LeCunNormal(config);
    };
    InitializerExports.orthogonal = function (config) {
        return new initializers_1.Orthogonal(config);
    };
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'Zeros'
        })
    ], InitializerExports, "zeros", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Initializers', namespace: 'initializers', useDocsFrom: 'Ones' })
    ], InitializerExports, "ones", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'Constant',
            configParamIndices: [0]
        })
    ], InitializerExports, "constant", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'RandomUniform',
            configParamIndices: [0]
        })
    ], InitializerExports, "randomUniform", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'RandomNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "randomNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'TruncatedNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "truncatedNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'Identity',
            configParamIndices: [0]
        })
    ], InitializerExports, "identity", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'VarianceScaling',
            configParamIndices: [0]
        })
    ], InitializerExports, "varianceScaling", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'GlorotUniform',
            configParamIndices: [0]
        })
    ], InitializerExports, "glorotUniform", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'GlorotNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "glorotNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'HeNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "heNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'LeCunNormal',
            configParamIndices: [0]
        })
    ], InitializerExports, "leCunNormal", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Initializers',
            namespace: 'initializers',
            useDocsFrom: 'Orthogonal',
            configParamIndices: [0]
        })
    ], InitializerExports, "orthogonal", null);
    return InitializerExports;
}());
exports.InitializerExports = InitializerExports;
var MetricExports = (function () {
    function MetricExports() {
    }
    MetricExports.binaryAccuracy = function (yTrue, yPred) {
        return metrics_1.binaryAccuracy(yTrue, yPred);
    };
    MetricExports.binaryCrossentropy = function (yTrue, yPred) {
        return metrics_1.binaryCrossentropy(yTrue, yPred);
    };
    MetricExports.categoricalAccuracy = function (yTrue, yPred) {
        return metrics_1.categoricalAccuracy(yTrue, yPred);
    };
    MetricExports.categoricalCrossentropy = function (yTrue, yPred) {
        return losses_1.categoricalCrossentropy(yTrue, yPred);
    };
    MetricExports.cosineProximity = function (yTrue, yPred) {
        return losses_1.cosineProximity(yTrue, yPred);
    };
    MetricExports.prototype.meanAbsoluteError = function (yTrue, yPred) {
        return losses_1.meanAbsoluteError(yTrue, yPred);
    };
    MetricExports.prototype.meanAbsolutePercentageError = function (yTrue, yPred) {
        return losses_1.meanAbsolutePercentageError(yTrue, yPred);
    };
    MetricExports.prototype.MAPE = function (yTrue, yPred) {
        return losses_1.meanAbsolutePercentageError(yTrue, yPred);
    };
    MetricExports.prototype.mape = function (yTrue, yPred) {
        return losses_1.meanAbsolutePercentageError(yTrue, yPred);
    };
    MetricExports.meanSquaredError = function (yTrue, yPred) {
        return losses_1.meanSquaredError(yTrue, yPred);
    };
    MetricExports.MSE = function (yTrue, yPred) {
        return losses_1.meanSquaredError(yTrue, yPred);
    };
    MetricExports.mse = function (yTrue, yPred) {
        return losses_1.meanSquaredError(yTrue, yPred);
    };
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'meanAbsoluteError'
        })
    ], MetricExports.prototype, "meanAbsoluteError", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'meanAbsolutePercentageError'
        })
    ], MetricExports.prototype, "meanAbsolutePercentageError", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Metrics', namespace: 'metrics', useDocsFrom: 'binaryAccuracy' })
    ], MetricExports, "binaryAccuracy", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'binaryCrossentropy'
        })
    ], MetricExports, "binaryCrossentropy", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'categoricalAccuracy'
        })
    ], MetricExports, "categoricalAccuracy", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'categoricalCrossentropy'
        })
    ], MetricExports, "categoricalCrossentropy", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'cosineProximity'
        })
    ], MetricExports, "cosineProximity", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Metrics',
            namespace: 'metrics',
            useDocsFrom: 'meanSquaredError'
        })
    ], MetricExports, "meanSquaredError", null);
    return MetricExports;
}());
exports.MetricExports = MetricExports;
var RegularizerExports = (function () {
    function RegularizerExports() {
    }
    RegularizerExports.l1l2 = function (config) {
        return new regularizers_1.L1L2(config);
    };
    RegularizerExports.l1 = function (config) {
        return regularizers_1.l1(config);
    };
    RegularizerExports.l2 = function (config) {
        return regularizers_1.l2(config);
    };
    __decorate([
        tfjs_core_1.doc({
            heading: 'Regularizers',
            namespace: 'regularizers',
            useDocsFrom: 'L1L2',
            configParamIndices: [0]
        })
    ], RegularizerExports, "l1l2", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Regularizers',
            namespace: 'regularizers',
            useDocsFrom: 'L1L2',
            configParamIndices: [0]
        })
    ], RegularizerExports, "l1", null);
    __decorate([
        tfjs_core_1.doc({
            heading: 'Regularizers',
            namespace: 'regularizers',
            useDocsFrom: 'L1L2',
            configParamIndices: [0]
        })
    ], RegularizerExports, "l2", null);
    return RegularizerExports;
}());
exports.RegularizerExports = RegularizerExports;

},{"./constraints":163,"./engine/topology":165,"./engine/training":166,"./initializers":170,"./layers/advanced_activations":171,"./layers/convolutional":172,"./layers/convolutional_depthwise":173,"./layers/core":174,"./layers/embeddings":175,"./layers/merge":176,"./layers/normalization":177,"./layers/padding":178,"./layers/pooling":179,"./layers/recurrent":180,"./layers/wrappers":182,"./losses":183,"./metrics":184,"./models":185,"./regularizers":187,"@tensorflow/tfjs-core":51}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var exports_1 = require("./exports");
var callbacks_1 = require("./callbacks");
exports.Callback = callbacks_1.Callback;
exports.CallbackList = callbacks_1.CallbackList;
exports.CustomCallback = callbacks_1.CustomCallback;
var training_1 = require("./engine/training");
exports.Model = training_1.Model;
var recurrent_1 = require("./layers/recurrent");
exports.RNN = recurrent_1.RNN;
var models_1 = require("./models");
exports.Sequential = models_1.Sequential;
var types_1 = require("./types");
exports.SymbolicTensor = types_1.SymbolicTensor;
var version_1 = require("./version");
exports.version_layers = version_1.version;
exports.model = exports_1.ModelExports.model;
exports.sequential = exports_1.ModelExports.sequential;
exports.loadModel = exports_1.ModelExports.loadModel;
exports.input = exports_1.ModelExports.input;
exports.layers = exports_1.LayerExports;
exports.constraints = exports_1.ConstraintExports;
exports.initializers = exports_1.InitializerExports;
exports.metrics = exports_1.MetricExports;
exports.regularizers = exports_1.RegularizerExports;

},{"./callbacks":161,"./engine/training":166,"./exports":168,"./layers/recurrent":180,"./models":185,"./types":188,"./version":194}],170:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var common_1 = require("./common");
var errors_1 = require("./errors");
var generic_utils_1 = require("./utils/generic_utils");
var math_utils_1 = require("./utils/math_utils");
exports.VALID_FAN_MODE_VALUES = ['fanIn', 'fanOut', 'fanAvg'];
function checkFanMode(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_FAN_MODE_VALUES, 'FanMode', value);
}
exports.checkFanMode = checkFanMode;
exports.VALID_DISTRIBUTION_VALUES = ['normal', 'uniform'];
function checkDistribution(value) {
    generic_utils_1.checkStringTypeUnionValue(exports.VALID_DISTRIBUTION_VALUES, 'Distribution', value);
}
exports.checkDistribution = checkDistribution;
var Initializer = (function (_super) {
    __extends(Initializer, _super);
    function Initializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Initializer.prototype.fromConfigUsesCustomObjects = function () {
        return false;
    };
    Initializer.prototype.getConfig = function () {
        return {};
    };
    Initializer = __decorate([
        tfjs_core_1.doc({ heading: 'Initializers', subheading: 'Classes', namespace: 'initializers' })
    ], Initializer);
    return Initializer;
}(tfjs_core_1.serialization.Serializable));
exports.Initializer = Initializer;
var Zeros = (function (_super) {
    __extends(Zeros, _super);
    function Zeros() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Zeros.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.zeros(shape, dtype);
    };
    Zeros.className = 'Zeros';
    return Zeros;
}(Initializer));
exports.Zeros = Zeros;
tfjs_core_1.serialization.SerializationMap.register(Zeros);
var Ones = (function (_super) {
    __extends(Ones, _super);
    function Ones() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Ones.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.ones(shape, dtype);
    };
    Ones.className = 'Ones';
    return Ones;
}(Initializer));
exports.Ones = Ones;
tfjs_core_1.serialization.SerializationMap.register(Ones);
var Constant = (function (_super) {
    __extends(Constant, _super);
    function Constant(config) {
        var _this = _super.call(this) || this;
        _this.value = config.value;
        return _this;
    }
    Constant.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return K.scalarTimesArray(tfjs_core_1.scalar(_this.value), tfjs_core_1.ones(shape, dtype)); });
    };
    Constant.prototype.getConfig = function () {
        return {
            value: this.value,
        };
    };
    Constant.className = 'Constant';
    return Constant;
}(Initializer));
exports.Constant = Constant;
tfjs_core_1.serialization.SerializationMap.register(Constant);
var RandomUniform = (function (_super) {
    __extends(RandomUniform, _super);
    function RandomUniform(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MINVAL = -0.05;
        _this.DEFAULT_MAXVAL = 0.05;
        _this.minval = config.minval || _this.DEFAULT_MINVAL;
        _this.maxval = config.maxval || _this.DEFAULT_MAXVAL;
        _this.seed = config.seed;
        return _this;
    }
    RandomUniform.prototype.apply = function (shape, dtype) {
        return tfjs_core_1.randomUniform(shape, this.minval, this.maxval, dtype);
    };
    RandomUniform.prototype.getConfig = function () {
        return { minval: this.minval, maxval: this.maxval, seed: this.seed };
    };
    RandomUniform.className = 'RandomUniform';
    return RandomUniform;
}(Initializer));
exports.RandomUniform = RandomUniform;
tfjs_core_1.serialization.SerializationMap.register(RandomUniform);
var RandomNormal = (function (_super) {
    __extends(RandomNormal, _super);
    function RandomNormal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MEAN = 0.;
        _this.DEFAULT_STDDEV = 0.05;
        _this.mean = config.mean || _this.DEFAULT_MEAN;
        _this.stddev = config.stddev || _this.DEFAULT_STDDEV;
        _this.seed = config.seed;
        return _this;
    }
    RandomNormal.prototype.apply = function (shape, dtype) {
        if (dtype === 'bool') {
            throw new errors_1.NotImplementedError("randomNormal does not support dType bool.");
        }
        return K.randomNormal(shape, this.mean, this.stddev, dtype, this.seed);
    };
    RandomNormal.prototype.getConfig = function () {
        return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    };
    RandomNormal.className = 'RandomNormal';
    return RandomNormal;
}(Initializer));
exports.RandomNormal = RandomNormal;
tfjs_core_1.serialization.SerializationMap.register(RandomNormal);
var TruncatedNormal = (function (_super) {
    __extends(TruncatedNormal, _super);
    function TruncatedNormal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_MEAN = 0.;
        _this.DEFAULT_STDDEV = 0.05;
        _this.mean = config.mean || _this.DEFAULT_MEAN;
        _this.stddev = config.stddev || _this.DEFAULT_STDDEV;
        _this.seed = config.seed;
        return _this;
    }
    TruncatedNormal.prototype.apply = function (shape, dtype) {
        if (dtype === 'bool') {
            throw new errors_1.NotImplementedError("truncatedNormal does not support dType bool.");
        }
        return tfjs_core_1.truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed);
    };
    TruncatedNormal.prototype.getConfig = function () {
        return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    };
    TruncatedNormal.className = 'TruncatedNormal';
    return TruncatedNormal;
}(Initializer));
exports.TruncatedNormal = TruncatedNormal;
tfjs_core_1.serialization.SerializationMap.register(TruncatedNormal);
var Identity = (function (_super) {
    __extends(Identity, _super);
    function Identity(config) {
        var _this = _super.call(this) || this;
        _this.gain = config.gain != null ? tfjs_core_1.scalar(config.gain) : K.getScalar(1.0);
        return _this;
    }
    Identity.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (shape.length !== 2 || shape[0] !== shape[1]) {
                throw new errors_1.ValueError('Identity matrix initializer can only be used for' +
                    ' 2D square matrices.');
            }
            else {
                return K.scalarTimesArray(_this.gain, tfjs_core_1.eye(shape[0]));
            }
        });
    };
    Identity.prototype.getConfig = function () {
        return { gain: this.gain.get() };
    };
    Identity.className = 'Identity';
    return Identity;
}(Initializer));
exports.Identity = Identity;
tfjs_core_1.serialization.SerializationMap.register(Identity);
function computeFans(shape, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var fanIn;
    var fanOut;
    common_1.checkDataFormat(dataFormat);
    if (shape.length === 2) {
        fanIn = shape[0];
        fanOut = shape[1];
    }
    else if ([3, 4, 5].indexOf(shape.length) !== -1) {
        if (dataFormat === 'channelsFirst') {
            var receptiveFieldSize = math_utils_1.arrayProd(shape, 2);
            fanIn = shape[1] * receptiveFieldSize;
            fanOut = shape[0] * receptiveFieldSize;
        }
        else if (dataFormat === 'channelsLast') {
            var receptiveFieldSize = math_utils_1.arrayProd(shape, 0, shape.length - 2);
            fanIn = shape[shape.length - 2] * receptiveFieldSize;
            fanOut = shape[shape.length - 1] * receptiveFieldSize;
        }
    }
    else {
        var shapeProd = math_utils_1.arrayProd(shape);
        fanIn = Math.sqrt(shapeProd);
        fanOut = Math.sqrt(shapeProd);
    }
    return [fanIn, fanOut];
}
var VarianceScaling = (function (_super) {
    __extends(VarianceScaling, _super);
    function VarianceScaling(config) {
        var _this = _super.call(this) || this;
        if (config.scale < 0.0) {
            throw new errors_1.ValueError("scale must be a positive float. Got: " + config.scale);
        }
        _this.scale = config.scale == null ? 1.0 : config.scale;
        _this.mode = config.mode;
        checkFanMode(_this.mode);
        _this.distribution = config.distribution;
        checkDistribution(_this.distribution);
        _this.seed = config.seed;
        return _this;
    }
    VarianceScaling.prototype.apply = function (shape, dtype) {
        var fans = computeFans(shape);
        var fanIn = fans[0];
        var fanOut = fans[1];
        var scale = this.scale;
        if (this.mode === 'fanIn') {
            scale /= Math.max(1, fanIn);
        }
        else if (this.mode === 'fanOut') {
            scale /= Math.max(1, fanOut);
        }
        else {
            scale /= Math.max(1, (fanIn + fanOut) / 2);
        }
        if (this.distribution === 'normal') {
            var stddev = Math.sqrt(scale);
            if (dtype === 'bool') {
                throw new errors_1.NotImplementedError(this.getClassName() + " does not support dType bool.");
            }
            return tfjs_core_1.truncatedNormal(shape, 0, stddev, dtype, this.seed);
        }
        else {
            var limit = Math.sqrt(3 * scale);
            return tfjs_core_1.randomUniform(shape, -limit, limit, dtype);
        }
    };
    VarianceScaling.prototype.getConfig = function () {
        return {
            scale: this.scale,
            mode: this.mode,
            distribution: this.distribution,
            seed: this.seed
        };
    };
    VarianceScaling.className = 'VarianceScaling';
    return VarianceScaling;
}(Initializer));
exports.VarianceScaling = VarianceScaling;
tfjs_core_1.serialization.SerializationMap.register(VarianceScaling);
var GlorotUniform = (function (_super) {
    __extends(GlorotUniform, _super);
    function GlorotUniform(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanAvg',
            distribution: 'uniform',
            seed: config == null ? null : config.seed
        }) || this;
    }
    GlorotUniform.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return GlorotUniform;
}(VarianceScaling));
exports.GlorotUniform = GlorotUniform;
var GlorotNormal = (function (_super) {
    __extends(GlorotNormal, _super);
    function GlorotNormal(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanAvg',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    GlorotNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return GlorotNormal;
}(VarianceScaling));
exports.GlorotNormal = GlorotNormal;
var HeNormal = (function (_super) {
    __extends(HeNormal, _super);
    function HeNormal(config) {
        return _super.call(this, {
            scale: 2.0,
            mode: 'fanIn',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    HeNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return HeNormal;
}(VarianceScaling));
exports.HeNormal = HeNormal;
var LeCunNormal = (function (_super) {
    __extends(LeCunNormal, _super);
    function LeCunNormal(config) {
        return _super.call(this, {
            scale: 1.0,
            mode: 'fanIn',
            distribution: 'normal',
            seed: config == null ? null : config.seed
        }) || this;
    }
    LeCunNormal.prototype.getClassName = function () {
        return VarianceScaling.className;
    };
    return LeCunNormal;
}(VarianceScaling));
exports.LeCunNormal = LeCunNormal;
var Orthogonal = (function (_super) {
    __extends(Orthogonal, _super);
    function Orthogonal(config) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_GAIN = 1;
        _this.gain = config.gain == null ? _this.DEFAULT_GAIN : config.gain;
        _this.seed = config.seed;
        if (_this.seed != null) {
            throw new errors_1.NotImplementedError('Random seed is not implemented for Orthogonal Initializer yet.');
        }
        return _this;
    }
    Orthogonal.prototype.apply = function (shape, dtype) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (shape.length !== 2) {
                throw new errors_1.NotImplementedError('The Orthogonal Initializer does not support non-2D shapes yet.');
            }
            if (shape[0] * shape[1] > 2000) {
                console.warn("Orthogonal initializer is being called on a matrix with more " +
                    ("than 2000 (" + shape[0] * shape[1] + ") elements: ") +
                    "Slowness may result.");
            }
            var normalizedShape = shape[0] > shape[1] ? [shape[1], shape[0]] : shape;
            var a = K.randomNormal(normalizedShape, 0, 1, 'float32');
            var q = tfjs_core_1.linalg.gramSchmidt(a);
            if (shape[0] > shape[1]) {
                q = q.transpose();
            }
            return K.scalarTimesArray(K.getScalar(_this.gain), q);
        });
    };
    Orthogonal.prototype.getConfig = function () {
        return {
            gain: this.gain,
            seed: this.seed,
        };
    };
    Orthogonal.className = 'Orthogonal';
    return Orthogonal;
}(Initializer));
exports.Orthogonal = Orthogonal;
tfjs_core_1.serialization.SerializationMap.register(Orthogonal);
exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'constant': 'Constant',
    'glorotNormal': 'GlorotNormal',
    'glorotUniform': 'GlorotUniform',
    'heNormal': 'HeNormal',
    'identity': 'Identity',
    'leCunNormal': 'LeCunNormal',
    'ones': 'Ones',
    'orthogonal': 'Orthogonal',
    'randomNormal': 'RandomNormal',
    'randomUniform': 'RandomUniform',
    'truncatedNormal': 'TruncatedNormal',
    'varianceScaling': 'VarianceScaling',
    'zeros': 'Zeros'
};
function deserializeInitializer(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'initializer');
}
function serializeInitializer(initializer) {
    return generic_utils_1.serializeKerasObject(initializer);
}
exports.serializeInitializer = serializeInitializer;
function getInitializer(identifier) {
    if (typeof identifier === 'string') {
        var className = identifier in exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        if (className === 'GlorotUniform') {
            return new GlorotUniform();
        }
        else if (className === 'GlorotNormal') {
            return new GlorotNormal();
        }
        else if (className === 'HeNormal') {
            return new HeNormal();
        }
        else if (className === 'LeCunNormal') {
            return new LeCunNormal();
        }
        else {
            var config = { className: className, config: {} };
            return deserializeInitializer(config);
        }
    }
    else if (identifier instanceof Initializer) {
        return identifier;
    }
    else {
        return deserializeInitializer(identifier);
    }
}
exports.getInitializer = getInitializer;

},{"./backend/tfjs_backend":160,"./common":162,"./errors":167,"./utils/generic_utils":190,"./utils/math_utils":191,"@tensorflow/tfjs-core":51}],171:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var tfjs_backend_1 = require("../backend/tfjs_backend");
var tfjs_backend_2 = require("../backend/tfjs_backend");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils = require("../utils/generic_utils");
var LeakyReLU = (function (_super) {
    __extends(LeakyReLU, _super);
    function LeakyReLU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_ALPHA = 0.3;
        if (config == null) {
            config = {};
        }
        _this.alpha = config.alpha == null ? _this.DEFAULT_ALPHA : config.alpha;
        return _this;
    }
    LeakyReLU.prototype.call = function (inputs, kwargs) {
        var x = generic_utils.getExactlyOneTensor(inputs);
        return tfjs_core_1.leakyRelu(x, this.alpha);
    };
    LeakyReLU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    LeakyReLU.prototype.getConfig = function () {
        var config = { alpha: this.alpha };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    LeakyReLU.className = 'LeakyReLU';
    return LeakyReLU;
}(topology_1.Layer));
exports.LeakyReLU = LeakyReLU;
tfjs_core_1.serialization.SerializationMap.register(LeakyReLU);
var ELU = (function (_super) {
    __extends(ELU, _super);
    function ELU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_ALPHA = 1.0;
        if (config == null) {
            config = {};
        }
        if (config.alpha != null && config.alpha !== _this.DEFAULT_ALPHA) {
            throw new errors_1.NotImplementedError("Non-default alpha value (" + config.alpha + ") is not supported by the " +
                "ELU layer yet.");
        }
        _this.alpha = config.alpha == null ? _this.DEFAULT_ALPHA : config.alpha;
        return _this;
    }
    ELU.prototype.call = function (inputs, kwargs) {
        var x = generic_utils.getExactlyOneTensor(inputs);
        return tfjs_core_1.elu(x);
    };
    ELU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    ELU.prototype.getConfig = function () {
        var config = { alpha: this.alpha };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ELU.className = 'ELU';
    return ELU;
}(topology_1.Layer));
exports.ELU = ELU;
tfjs_core_1.serialization.SerializationMap.register(ELU);
var ThresholdedReLU = (function (_super) {
    __extends(ThresholdedReLU, _super);
    function ThresholdedReLU(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_THETA = 1.0;
        if (config == null) {
            config = {};
        }
        _this.theta = config.theta == null ? _this.DEFAULT_THETA : config.theta;
        _this.thetaTensor = tfjs_backend_2.getScalar(_this.theta);
        return _this;
    }
    ThresholdedReLU.prototype.call = function (inputs, kwargs) {
        var x = generic_utils.getExactlyOneTensor(inputs);
        return x.mul(tfjs_backend_1.cast(x.greater(this.thetaTensor), 'float32'));
    };
    ThresholdedReLU.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    ThresholdedReLU.prototype.getConfig = function () {
        var config = { theta: this.theta };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ThresholdedReLU.className = 'ThresholdedReLU';
    return ThresholdedReLU;
}(topology_1.Layer));
exports.ThresholdedReLU = ThresholdedReLU;
tfjs_core_1.serialization.SerializationMap.register(ThresholdedReLU);
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(config) {
        var _this = _super.call(this, config == null ? {} : config) || this;
        _this.DEFAULT_AXIS = 1.0;
        if (config == null) {
            config = {};
        }
        _this.softmax = new activations_1.Softmax().apply;
        _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;
        return _this;
    }
    Softmax.prototype.call = function (inputs, kwargs) {
        var x = generic_utils.getExactlyOneTensor(inputs);
        return this.softmax(x, this.axis);
    };
    Softmax.prototype.computeOutputShape = function (inputShape) {
        return inputShape;
    };
    Softmax.prototype.getConfig = function () {
        var config = { axis: this.axis };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Softmax.className = 'Softmax';
    return Softmax;
}(topology_1.Layer));
exports.Softmax = Softmax;
tfjs_core_1.serialization.SerializationMap.register(Softmax);

},{"../activations":158,"../backend/tfjs_backend":160,"../engine/topology":165,"../errors":167,"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],172:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var conv_utils_1 = require("../utils/conv_utils");
var generic_utils = require("../utils/generic_utils");
function preprocessConv2DInput(x, dataFormat) {
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        if (dataFormat === 'channelsFirst') {
            return tfc.transpose(x, [0, 2, 3, 1]);
        }
        else {
            return x;
        }
    });
}
exports.preprocessConv2DInput = preprocessConv2DInput;
function conv1dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = 1; }
    if (padding === void 0) { padding = 'valid'; }
    if (dilationRate === void 0) { dilationRate = 1; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        if (x.shape.length !== 3) {
            throw new errors_1.ValueError("The input of a conv1dWithBias operation should be 3, but is " +
                (x.shape.length + " instead."));
        }
        if (kernel.shape.length !== 3) {
            throw new errors_1.ValueError("The kernel for a conv1dWithBias operation should be 3, but is " +
                (kernel.shape.length + " instead"));
        }
        if (bias != null && bias.shape.length !== 1) {
            throw new errors_1.ValueError("The bias for a conv1dWithBias operation should be 1, but is " +
                (kernel.shape.length + " instead"));
        }
        if (dataFormat === 'channelsFirst') {
            x = tfc.transpose(x, [0, 2, 1]);
        }
        if (padding === 'causal') {
            throw new errors_1.NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' +
                'implemented yet.');
        }
        var y = tfc.conv1d(x, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NWC', dilationRate);
        if (bias != null) {
            y = K.biasAdd(y, bias);
        }
        return y;
    });
}
exports.conv1dWithBias = conv1dWithBias;
function conv1d(x, kernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = 1; }
    if (padding === void 0) { padding = 'valid'; }
    if (dilationRate === void 0) { dilationRate = 1; }
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        return conv1dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);
    });
}
exports.conv1d = conv1d;
function conv2d(x, kernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        return conv2dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);
    });
}
exports.conv2d = conv2d;
function conv2dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        if (x.rank !== 3 && x.rank !== 4) {
            throw new errors_1.ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received " +
                (x.rank + "."));
        }
        if (kernel.rank !== 3 && kernel.rank !== 4) {
            throw new errors_1.ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received " +
                (x.rank + "."));
        }
        var y = preprocessConv2DInput(x, dataFormat);
        if (padding === 'causal') {
            throw new errors_1.NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' +
                'implemented yet.');
        }
        y = tfc.conv2d(y, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NHWC', dilationRate);
        if (bias != null) {
            y = K.biasAdd(y, bias);
        }
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.conv2dWithBias = conv2dWithBias;
var Conv = (function (_super) {
    __extends(Conv, _super);
    function Conv(rank, config) {
        var _this = _super.call(this, config) || this;
        _this.kernel = null;
        _this.bias = null;
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.rank = rank;
        if (_this.rank !== 1 && _this.rank !== 2) {
            throw new errors_1.NotImplementedError("Convolution layer for rank other than 1 or 2 (" + _this.rank + ") is " +
                "not implemented yet.");
        }
        _this.filters = config.filters;
        _this.kernelSize = conv_utils_1.normalizeArray(config.kernelSize, rank, 'kernelSize');
        _this.strides = conv_utils_1.normalizeArray(config.strides == null ? 1 : config.strides, rank, 'strides');
        _this.padding = config.padding == null ? 'valid' : config.padding;
        common_2.checkPaddingMode(_this.padding);
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        _this.dilationRate = config.dilationRate == null ? 1 : config.dilationRate;
        if (_this.rank === 1 &&
            (Array.isArray(_this.dilationRate) &&
                _this.dilationRate.length !== 1)) {
            throw new errors_1.ValueError("dilationRate must be a number or an array of a single number " +
                "for 1D convolution, but received " +
                ("" + JSON.stringify(_this.dilationRate)));
        }
        if (_this.rank === 2) {
            if (typeof _this.dilationRate === 'number') {
                _this.dilationRate = [_this.dilationRate, _this.dilationRate];
            }
            else if (_this.dilationRate.length !== 2) {
                throw new errors_1.ValueError("dilationRate must be a number or array of two numbers for 2D " +
                    ("convolution, but received " + JSON.stringify(_this.dilationRate)));
            }
        }
        _this.activation = activations_1.getActivation(config.activation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        return _this;
    }
    Conv.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
            throw new errors_1.ValueError("The channel dimension of the input should be defined. " +
                ("Found " + inputShape[channelAxis]));
        }
        var inputDim = inputShape[channelAxis];
        var kernelShape = this.kernelSize.concat([inputDim, this.filters]);
        this.kernel = this.addWeight('kernel', kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec = [{ ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a) }];
        this.built = true;
        var _a;
    };
    Conv.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.getExactlyOneTensor(inputs);
            var outputs;
            var biasValue = _this.bias == null ? null : _this.bias.read();
            if (_this.rank === 1) {
                outputs = conv1dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides[0], _this.padding, _this.dataFormat, _this.dilationRate);
            }
            else if (_this.rank === 2) {
                outputs = conv2dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides, _this.padding, _this.dataFormat, _this.dilationRate);
            }
            else if (_this.rank === 3) {
                throw new errors_1.NotImplementedError('3D convolution is not implemented yet.');
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    Conv.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var newSpace = [];
        var space = (this.dataFormat === 'channelsLast') ?
            inputShape.slice(1, inputShape.length - 1) :
            inputShape.slice(2);
        for (var i = 0; i < space.length; ++i) {
            var newDim = conv_utils_1.convOutputLength(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === 'number' ? this.dilationRate :
                this.dilationRate[i]);
            newSpace.push(newDim);
        }
        var outputShape = [inputShape[0]];
        if (this.dataFormat === 'channelsLast') {
            outputShape = outputShape.concat(newSpace);
            outputShape.push(this.filters);
        }
        else {
            outputShape.push(this.filters);
            outputShape = outputShape.concat(newSpace);
        }
        return outputShape;
    };
    Conv.prototype.getConfig = function () {
        var config = {
            rank: this.rank,
            filters: this.filters,
            kernelSize: this.kernelSize,
            strides: this.strides,
            padding: this.padding,
            dataFormat: this.dataFormat,
            dilationRate: this.dilationRate,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return Conv;
}(topology_1.Layer));
exports.Conv = Conv;
var Conv2D = (function (_super) {
    __extends(Conv2D, _super);
    function Conv2D(config) {
        return _super.call(this, 2, config) || this;
    }
    Conv2D.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        return config;
    };
    Conv2D.className = 'Conv2D';
    return Conv2D;
}(Conv));
exports.Conv2D = Conv2D;
tfjs_core_1.serialization.SerializationMap.register(Conv2D);
var Conv2DTranspose = (function (_super) {
    __extends(Conv2DTranspose, _super);
    function Conv2DTranspose(config) {
        var _this = _super.call(this, config) || this;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        if (_this.padding !== 'same' && _this.padding !== 'valid') {
            throw new errors_1.ValueError("Conv2DTranspose currently supports only padding modes 'same' " +
                ("and 'valid', but received padding mode " + _this.padding));
        }
        return _this;
    }
    Conv2DTranspose.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        if (inputShape.length !== 4) {
            throw new errors_1.ValueError('Input should have rank 4; Received input shape: ' +
                JSON.stringify(inputShape));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
            throw new errors_1.ValueError('The channel dimension of the inputs should be defined. ' +
                'Found `None`.');
        }
        var inputDim = inputShape[channelAxis];
        var kernelShape = this.kernelSize.concat([this.filters, inputDim]);
        this.kernel = this.addWeight('kernel', kernelShape, 'float32', this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: 4, axes: (_a = {}, _a[channelAxis] = inputDim, _a) })];
        this.built = true;
        var _a;
    };
    Conv2DTranspose.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfc.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (input.shape.length !== 4) {
                throw new errors_1.ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but " +
                    ("received a tensor of rank-" + input.shape.length));
            }
            var inputShape = input.shape;
            var batchSize = inputShape[0];
            var hAxis;
            var wAxis;
            if (_this.dataFormat === 'channelsFirst') {
                hAxis = 2;
                wAxis = 3;
            }
            else {
                hAxis = 1;
                wAxis = 2;
            }
            var height = inputShape[hAxis];
            var width = inputShape[wAxis];
            var kernelH = _this.kernelSize[0];
            var kernelW = _this.kernelSize[1];
            var strideH = _this.strides[0];
            var strideW = _this.strides[1];
            var outHeight = conv_utils_1.deconvLength(height, strideH, kernelH, _this.padding);
            var outWidth = conv_utils_1.deconvLength(width, strideW, kernelW, _this.padding);
            var outputShape = [batchSize, outHeight, outWidth, _this.filters];
            if (_this.dataFormat !== 'channelsLast') {
                input = tfc.transpose(input, [0, 2, 3, 1]);
            }
            var outputs = tfc.conv2dTranspose(input, _this.kernel.read(), outputShape, _this.strides, _this.padding);
            if (_this.dataFormat !== 'channelsLast') {
                outputs = tfc.transpose(outputs, [0, 3, 1, 2]);
            }
            if (_this.bias != null) {
                outputs =
                    K.biasAdd(outputs, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    Conv2DTranspose.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var outputShape = inputShape.slice();
        var channelAxis;
        var heightAxis;
        var widthAxis;
        if (this.dataFormat === 'channelsFirst') {
            channelAxis = 1;
            heightAxis = 2;
            widthAxis = 3;
        }
        else {
            channelAxis = 3;
            heightAxis = 1;
            widthAxis = 2;
        }
        var kernelH = this.kernelSize[0];
        var kernelW = this.kernelSize[1];
        var strideH = this.strides[0];
        var strideW = this.strides[1];
        outputShape[channelAxis] = this.filters;
        outputShape[heightAxis] =
            conv_utils_1.deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
        outputShape[widthAxis] =
            conv_utils_1.deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
        return outputShape;
    };
    Conv2DTranspose.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['dilationRate'];
        return config;
    };
    Conv2DTranspose.className = 'Conv2DTranspose';
    return Conv2DTranspose;
}(Conv2D));
exports.Conv2DTranspose = Conv2DTranspose;
tfjs_core_1.serialization.SerializationMap.register(Conv2DTranspose);
var SeparableConv = (function (_super) {
    __extends(SeparableConv, _super);
    function SeparableConv(rank, config) {
        var _this = _super.call(this, rank, config) || this;
        _this.DEFAULT_DEPTHWISE_INITIALIZER = 'glorotUniform';
        _this.DEFAULT_POINTWISE_INITIALIZER = 'glorotUniform';
        _this.depthwiseKernel = null;
        _this.pointwiseKernel = null;
        if (config.filters == null) {
            throw new errors_1.ValueError('The `filters` configuration field is required by SeparableConv, ' +
                'but is unspecified.');
        }
        if (config.kernelInitializer != null || config.kernelRegularizer != null ||
            config.kernelConstraint != null) {
            throw new errors_1.ValueError('Fields kernelInitializer, kernelRegularizer and kernelConstraint ' +
                'are invalid for SeparableConv2D. Use depthwiseInitializer, ' +
                'depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, ' +
                'pointwiseRegularizer and pointwiseConstraint instead.');
        }
        if (config.padding != null && config.padding !== 'same' &&
            config.padding !== 'valid') {
            throw new errors_1.ValueError("SeparableConv" + _this.rank + "D supports only padding modes: " +
                ("'same' and 'valid', but received " + JSON.stringify(config.padding)));
        }
        _this.depthMultiplier =
            config.depthMultiplier == null ? 1 : config.depthMultiplier;
        _this.depthwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_DEPTHWISE_INITIALIZER);
        _this.depthwiseRegularizer = regularizers_1.getRegularizer(config.depthwiseRegularizer);
        _this.depthwiseConstraint = constraints_1.getConstraint(config.depthwiseConstraint);
        _this.pointwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_POINTWISE_INITIALIZER);
        _this.pointwiseRegularizer = regularizers_1.getRegularizer(config.pointwiseRegularizer);
        _this.pointwiseConstraint = constraints_1.getConstraint(config.pointwiseConstraint);
        return _this;
    }
    SeparableConv.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        if (inputShape.length < this.rank + 2) {
            throw new errors_1.ValueError("Inputs to SeparableConv" + this.rank + "D should have rank " +
                (this.rank + 2 + ", but received input shape: ") +
                ("" + JSON.stringify(inputShape)));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
            throw new errors_1.ValueError("The channel dimension of the inputs should be defined, " +
                ("but found " + JSON.stringify(inputShape[channelAxis])));
        }
        var inputDim = inputShape[channelAxis];
        var depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);
        var pointwiseKernelShape = [];
        for (var i = 0; i < this.rank; ++i) {
            pointwiseKernelShape.push(1);
        }
        pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);
        var trainable = true;
        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, 'float32', this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);
        this.pointwiseKernel = this.addWeight('pointwise_kernel', pointwiseKernelShape, 'float32', this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a) })];
        this.built = true;
        var _a;
    };
    SeparableConv.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.getExactlyOneTensor(inputs);
            var output;
            if (_this.rank === 1) {
                throw new errors_1.NotImplementedError('1D separable convolution is not implemented yet.');
            }
            else if (_this.rank === 2) {
                if (_this.dataFormat === 'channelsFirst') {
                    inputs = tfc.transpose(inputs, [0, 2, 3, 1]);
                }
                output = tfc.separableConv2d(inputs, _this.depthwiseKernel.read(), _this.pointwiseKernel.read(), _this.strides, _this.padding, _this.dilationRate, 'NHWC');
            }
            if (_this.useBias) {
                output = K.biasAdd(output, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            if (_this.dataFormat === 'channelsFirst') {
                output = tfc.transpose(output, [0, 3, 1, 2]);
            }
            return output;
        });
    };
    SeparableConv.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        delete config['kernelInitializer'];
        delete config['kernelRegularizer'];
        delete config['kernelConstraint'];
        config['depthwiseInitializer'] =
            initializers_1.serializeInitializer(this.depthwiseInitializer);
        config['pointwiseInitializer'] =
            initializers_1.serializeInitializer(this.pointwiseInitializer);
        config['depthwiseRegularizer'] =
            regularizers_1.serializeRegularizer(this.depthwiseRegularizer);
        config['pointwiseRegularizer'] =
            regularizers_1.serializeRegularizer(this.pointwiseRegularizer);
        config['depthwiseConstraint'] =
            constraints_1.serializeConstraint(this.depthwiseConstraint);
        config['pointwiseConstraint'] =
            constraints_1.serializeConstraint(this.pointwiseConstraint);
        return config;
    };
    SeparableConv.className = 'SeparableConv';
    return SeparableConv;
}(Conv));
exports.SeparableConv = SeparableConv;
var SeparableConv2D = (function (_super) {
    __extends(SeparableConv2D, _super);
    function SeparableConv2D(config) {
        return _super.call(this, 2, config) || this;
    }
    SeparableConv2D.className = 'SeparableConv2D';
    return SeparableConv2D;
}(SeparableConv));
exports.SeparableConv2D = SeparableConv2D;
tfjs_core_1.serialization.SerializationMap.register(SeparableConv2D);
var Conv1D = (function (_super) {
    __extends(Conv1D, _super);
    function Conv1D(config) {
        var _this = _super.call(this, 1, config) || this;
        _this.inputSpec = [{ ndim: 3 }];
        return _this;
    }
    Conv1D.prototype.getConfig = function () {
        var config = _super.prototype.getConfig.call(this);
        delete config['rank'];
        delete config['dataFormat'];
        return config;
    };
    Conv1D.className = 'Conv1D';
    return Conv1D;
}(Conv));
exports.Conv1D = Conv1D;
tfjs_core_1.serialization.SerializationMap.register(Conv1D);
var Cropping2D = (function (_super) {
    __extends(Cropping2D, _super);
    function Cropping2D(config) {
        var _this = _super.call(this, config) || this;
        if (typeof config.cropping === 'number')
            _this.cropping = [
                [config.cropping, config.cropping], [config.cropping, config.cropping]
            ];
        else if (typeof config.cropping[0] === 'number')
            _this.cropping = [
                [config.cropping[0], config.cropping[0]],
                [config.cropping[1], config.cropping[1]]
            ];
        else
            _this.cropping = config.cropping;
        _this.dataFormat =
            config.dataFormat === undefined ? 'channelsLast' : config.dataFormat;
        _this.inputSpec = [{ ndim: 4 }];
        return _this;
    }
    Cropping2D.prototype.computeOutputShape = function (inputShape) {
        if (this.dataFormat === 'channelsFirst')
            return [
                inputShape[0], inputShape[1],
                inputShape[2] - this.cropping[0][0] - this.cropping[0][1],
                inputShape[2] - this.cropping[1][0] - this.cropping[1][1]
            ];
        else
            return [
                inputShape[0],
                inputShape[1] - this.cropping[0][0] - this.cropping[0][1],
                inputShape[2] - this.cropping[1][0] - this.cropping[1][1], inputShape[3]
            ];
    };
    Cropping2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[1] - _this.cropping[0][0] - _this.cropping[0][1], 2);
                return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[2] - _this.cropping[1][1] - _this.cropping[1][0], 3);
            }
            else {
                var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[2] - _this.cropping[0][0] - _this.cropping[0][1], 3);
                return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[3] - _this.cropping[1][1] - _this.cropping[1][0], 4);
            }
        });
    };
    Cropping2D.prototype.getConfig = function () {
        var config = { cropping: this.cropping, dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Cropping2D.className = 'Cropping2D';
    return Cropping2D;
}(topology_1.Layer));
exports.Cropping2D = Cropping2D;
tfjs_core_1.serialization.SerializationMap.register(Cropping2D);
var UpSampling2D = (function (_super) {
    __extends(UpSampling2D, _super);
    function UpSampling2D(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_SIZE = [2, 2];
        _this.inputSpec = [{ ndim: 4 }];
        _this.size = config.size === undefined ? _this.DEFAULT_SIZE : config.size;
        _this.dataFormat =
            config.dataFormat === undefined ? 'channelsLast' : config.dataFormat;
        return _this;
    }
    UpSampling2D.prototype.computeOutputShape = function (inputShape) {
        if (this.dataFormat === 'channelsFirst') {
            var height = this.size[0] * inputShape[2];
            var width = this.size[1] * inputShape[3];
            return [inputShape[0], inputShape[1], height, width];
        }
        else {
            var height = this.size[0] * inputShape[1];
            var width = this.size[1] * inputShape[2];
            return [inputShape[0], height, width, inputShape[3]];
        }
    };
    UpSampling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfc.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            var inputShape = input.shape;
            if (_this.dataFormat === 'channelsFirst') {
                input = tfc.transpose(input, [0, 2, 3, 1]);
                var height = _this.size[0] * inputShape[2];
                var width = _this.size[1] * inputShape[3];
                var resized = input.resizeNearestNeighbor([height, width]);
                return tfc.transpose(resized, [0, 3, 1, 2]);
            }
            else {
                var height = _this.size[0] * inputShape[1];
                var width = _this.size[1] * inputShape[2];
                return input.resizeNearestNeighbor([height, width]);
            }
        });
    };
    UpSampling2D.prototype.getConfig = function () {
        var config = { size: this.size, dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    UpSampling2D.className = 'UpSampling2D';
    return UpSampling2D;
}(topology_1.Layer));
exports.UpSampling2D = UpSampling2D;
tfjs_core_1.serialization.SerializationMap.register(UpSampling2D);

},{"../activations":158,"../backend/common":159,"../backend/tfjs_backend":160,"../common":162,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/conv_utils":189,"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],173:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var constraints_1 = require("../constraints");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var conv_utils_1 = require("../utils/conv_utils");
var generic_utils_1 = require("../utils/generic_utils");
var convolutional_1 = require("./convolutional");
function depthwiseConv2d(x, depthwiseKernel, strides, padding, dataFormat, dilationRate) {
    if (strides === void 0) { strides = [1, 1]; }
    if (padding === void 0) { padding = 'valid'; }
    return tfjs_core_1.tidy(function () {
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        common_2.checkDataFormat(dataFormat);
        var y = convolutional_1.preprocessConv2DInput(x, dataFormat);
        if (x.rank !== 4) {
            throw new errors_1.ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead " +
                (x.rank + "-D"));
        }
        if (depthwiseKernel.rank !== 4) {
            throw new errors_1.ValueError("depthwiseKernel is required to be 4-D, but is instead " +
                (depthwiseKernel.rank + "-D"));
        }
        y = tfc.depthwiseConv2d(y, depthwiseKernel, strides, padding === 'same' ? 'same' : 'valid', 'NHWC', dilationRate);
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.depthwiseConv2d = depthwiseConv2d;
var DepthwiseConv2D = (function (_super) {
    __extends(DepthwiseConv2D, _super);
    function DepthwiseConv2D(config) {
        var _this = _super.call(this, config) || this;
        _this.depthwiseKernel = null;
        _this.depthMultiplier =
            config.depthMultiplier == null ? 1 : config.depthMultiplier;
        _this.depthwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.depthwiseConstraint = constraints_1.getConstraint(config.depthwiseConstraint);
        _this.depthwiseRegularizer = regularizers_1.getRegularizer(config.depthwiseRegularizer);
        return _this;
    }
    DepthwiseConv2D.prototype.build = function (inputShape) {
        inputShape = generic_utils_1.getExactlyOneShape(inputShape);
        if (inputShape.length < 4) {
            throw new errors_1.ValueError("Inputs to DepthwiseConv2D should have rank 4. " +
                ("Received input shape: " + JSON.stringify(inputShape) + "."));
        }
        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : 3;
        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
            throw new errors_1.ValueError('The channel dimension of the inputs to DepthwiseConv2D should ' +
                ("be defined, but is not (" + inputShape[channelAxis] + ")."));
        }
        var inputDim = inputShape[channelAxis];
        var depthwiseKernelShape = [
            this.kernelSize[0], this.kernelSize[1], inputDim, this.depthMultiplier
        ];
        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    DepthwiseConv2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils_1.getExactlyOneTensor(inputs);
            var outputs = depthwiseConv2d(inputs, _this.depthwiseKernel.read(), _this.strides, _this.padding, _this.dataFormat, null);
            if (_this.useBias) {
                outputs = K.biasAdd(outputs, _this.bias.read(), _this.dataFormat);
            }
            if (_this.activation != null) {
                outputs = _this.activation.apply(outputs);
            }
            return outputs;
        });
    };
    DepthwiseConv2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils_1.getExactlyOneShape(inputShape);
        var rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];
        var cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];
        var outFilters = this.dataFormat === 'channelsFirst' ?
            inputShape[1] * this.depthMultiplier :
            inputShape[3] * this.depthMultiplier;
        var outRows = conv_utils_1.convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);
        var outCols = conv_utils_1.convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === 'channelsFirst') {
            return [inputShape[0], outFilters, outRows, outCols];
        }
        else {
            return [inputShape[0], outRows, outCols, outFilters];
        }
    };
    DepthwiseConv2D.className = 'DepthwiseConv2D';
    return DepthwiseConv2D;
}(convolutional_1.Conv2D));
exports.DepthwiseConv2D = DepthwiseConv2D;
tfjs_core_1.serialization.SerializationMap.register(DepthwiseConv2D);

},{"../backend/common":159,"../backend/tfjs_backend":160,"../common":162,"../constraints":163,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/conv_utils":189,"../utils/generic_utils":190,"./convolutional":172,"@tensorflow/tfjs-core":51}],174:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var generic_utils = require("../utils/generic_utils");
var generic_utils_1 = require("../utils/generic_utils");
var math_utils = require("../utils/math_utils");
var Dropout = (function (_super) {
    __extends(Dropout, _super);
    function Dropout(config) {
        var _this = _super.call(this, config) || this;
        _this.rate = Math.max(Math.min(config.rate, 1), 0);
        _this.rateScalar = K.getScalar(_this.rate);
        _this.noiseShape = config.noiseShape;
        _this.seed = config.seed;
        if (_this.seed != null) {
            throw new errors_1.NotImplementedError('Non-default seed is not implemented in Dropout layer yet: ' +
                _this.seed);
        }
        _this.supportsMasking = true;
        return _this;
    }
    Dropout.prototype.getNoiseShape = function (input) {
        if (this.noiseShape == null) {
            return this.noiseShape;
        }
        var inputShape = input.shape;
        var noiseShape = [];
        for (var i = 0; i < this.noiseShape.length; ++i) {
            noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);
        }
        return noiseShape;
    };
    Dropout.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (_this.noiseShape != null &&
                !tfjs_core_1.util.arraysEqual(input.shape, _this.noiseShape)) {
                throw new errors_1.NotImplementedError('Non-default noise shape is not implemented in Dropout ' +
                    'layer yet: ' + JSON.stringify(_this.noiseShape));
            }
            if (0 < _this.rate && _this.rate < 1) {
                var training = kwargs['training'] == null ? false : kwargs['training'];
                var noiseShape_1 = _this.getNoiseShape(input);
                var output = K.inTrainPhase(function () { return K.dropout(input, _this.rateScalar, noiseShape_1, _this.seed); }, function () { return input; }, training);
                return output;
            }
            return inputs;
        });
    };
    Dropout.prototype.getConfig = function () {
        var config = {
            rate: this.rate,
            noiseShape: this.noiseShape,
            seed: this.seed,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Dropout.className = 'Dropout';
    return Dropout;
}(topology_1.Layer));
exports.Dropout = Dropout;
tfjs_core_1.serialization.SerializationMap.register(Dropout);
var Dense = (function (_super) {
    __extends(Dense, _super);
    function Dense(config) {
        var _this = _super.call(this, config) || this;
        _this.activation = null;
        _this.useBias = true;
        _this.kernel = null;
        _this.bias = null;
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        if (config.batchInputShape == null && config.inputShape == null &&
            config.inputDim != null) {
            var batchSize = null;
            if (config.batchSize != null) {
                batchSize = config.batchSize;
            }
            _this.batchInputShape = [batchSize, config.inputDim];
        }
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation);
        if (config.useBias != null) {
            _this.useBias = config.useBias;
        }
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        _this.inputSpec = [{ minNDim: 2 }];
        return _this;
    }
    Dense.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var inputLastDim = inputShape[inputShape.length - 1];
        if (this.kernel == null) {
            this.kernel = this.addWeight('kernel', [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
            if (this.useBias) {
                this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
            }
        }
        this.inputSpec = [{ minNDim: 2, axes: (_a = {}, _a[-1] = inputLastDim, _a) }];
        this.built = true;
        var _a;
    };
    Dense.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var outputShape = inputShape.slice();
        outputShape[outputShape.length - 1] = this.units;
        return outputShape;
    };
    Dense.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            var output = K.dot(input, _this.kernel.read());
            if (_this.bias != null) {
                output = K.biasAdd(output, _this.bias.read());
            }
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            return output;
        });
    };
    Dense.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Dense.className = 'Dense';
    return Dense;
}(topology_1.Layer));
exports.Dense = Dense;
tfjs_core_1.serialization.SerializationMap.register(Dense);
var Flatten = (function (_super) {
    __extends(Flatten, _super);
    function Flatten(config) {
        var _this = _super.call(this, config || {}) || this;
        _this.inputSpec = [{ minNDim: 3 }];
        return _this;
    }
    Flatten.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        for (var _i = 0, _a = inputShape.slice(1); _i < _a.length; _i++) {
            var dim = _a[_i];
            if (dim == null) {
                throw new errors_1.ValueError("The shape of the input to \"Flatten\" is not fully defined " +
                    ("(got " + inputShape.slice(1) + "). Make sure to pass a complete ") +
                    "\"input_shape\" or \"batch_input_shape\" argument to the first " +
                    "layer in your model.");
            }
        }
        return [inputShape[0], math_utils.arrayProd(inputShape, 1)];
    };
    Flatten.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            return K.batchFlatten(generic_utils.getExactlyOneTensor(inputs));
        });
    };
    Flatten.className = 'Flatten';
    return Flatten;
}(topology_1.Layer));
exports.Flatten = Flatten;
tfjs_core_1.serialization.SerializationMap.register(Flatten);
var Activation = (function (_super) {
    __extends(Activation, _super);
    function Activation(config) {
        var _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        _this.activation = activations_1.getActivation(config.activation);
        return _this;
    }
    Activation.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            return _this.activation.apply(input);
        });
    };
    Activation.prototype.getConfig = function () {
        var config = { activation: activations_1.serializeActivation(this.activation) };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Activation.className = 'Activation';
    return Activation;
}(topology_1.Layer));
exports.Activation = Activation;
tfjs_core_1.serialization.SerializationMap.register(Activation);
var RepeatVector = (function (_super) {
    __extends(RepeatVector, _super);
    function RepeatVector(config) {
        var _this = _super.call(this, config) || this;
        _this.n = config.n;
        _this.inputSpec = [{ ndim: 2 }];
        return _this;
    }
    RepeatVector.prototype.computeOutputShape = function (inputShape) {
        return [inputShape[0], this.n, inputShape[1]];
    };
    RepeatVector.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils_1.getExactlyOneTensor(inputs);
            return K.repeat(inputs, _this.n);
        });
    };
    RepeatVector.prototype.getConfig = function () {
        var config = {
            n: this.n,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    RepeatVector.className = 'RepeatVector';
    return RepeatVector;
}(topology_1.Layer));
exports.RepeatVector = RepeatVector;
tfjs_core_1.serialization.SerializationMap.register(RepeatVector);
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(config) {
        var _this = _super.call(this, config) || this;
        _this.targetShape = config.targetShape;
        for (var i = 0; i < _this.targetShape.length; ++i) {
            if (_this.isUnknown(_this.targetShape[i])) {
                _this.targetShape[i] = null;
            }
        }
        return _this;
    }
    Reshape.prototype.isUnknown = function (dim) {
        return dim < 0 || dim == null;
    };
    Reshape.prototype.fixUnknownDimension = function (inputShape, outputShape) {
        var errorMsg = 'Total size of new array must be unchanged.';
        var finalShape = outputShape.slice();
        var known = 1;
        var unknown = null;
        for (var i = 0; i < finalShape.length; ++i) {
            var dim = finalShape[i];
            if (this.isUnknown(dim)) {
                if (unknown === null) {
                    unknown = i;
                }
                else {
                    throw new errors_1.ValueError('Can only specifiy one unknown dimension.');
                }
            }
            else {
                known *= dim;
            }
        }
        var originalSize = math_utils.arrayProd(inputShape);
        if (unknown !== null) {
            if (known === 0 || originalSize % known !== 0) {
                throw new errors_1.ValueError(errorMsg);
            }
            finalShape[unknown] = originalSize / known;
        }
        else if (originalSize !== known) {
            throw new errors_1.ValueError(errorMsg);
        }
        return finalShape;
    };
    Reshape.prototype.computeOutputShape = function (inputShape) {
        var anyUnknownDims = false;
        for (var i = 0; i < inputShape.length; ++i) {
            if (this.isUnknown(inputShape[i])) {
                anyUnknownDims = true;
                break;
            }
        }
        if (anyUnknownDims) {
            return inputShape.slice(0, 1).concat(this.targetShape);
        }
        else {
            return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
        }
    };
    Reshape.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            var inputShape = K.shape(input);
            var outputShape = inputShape.slice(0, 1).concat(_this.fixUnknownDimension(inputShape.slice(1), _this.targetShape));
            return input.reshape(outputShape);
        });
    };
    Reshape.prototype.getConfig = function () {
        var config = {
            targetShape: this.targetShape,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Reshape.className = 'Reshape';
    return Reshape;
}(topology_1.Layer));
exports.Reshape = Reshape;
tfjs_core_1.serialization.SerializationMap.register(Reshape);

},{"../activations":158,"../backend/tfjs_backend":160,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/generic_utils":190,"../utils/math_utils":191,"@tensorflow/tfjs-core":51}],175:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var generic_utils = require("../utils/generic_utils");
var generic_utils_1 = require("../utils/generic_utils");
var Embedding = (function (_super) {
    __extends(Embedding, _super);
    function Embedding(config) {
        var _this = _super.call(this, config) || this;
        _this.embeddings = null;
        _this.DEFAULT_EMBEDDINGS_INITIALIZER = 'randomUniform';
        if (config.batchInputShape == null && config.inputShape == null) {
            var batchSize = null;
            if (config.batchSize != null) {
                batchSize = config.batchSize;
            }
            if (config.inputLength == null) {
                _this.batchInputShape = [batchSize, null];
            }
            else {
                _this.batchInputShape =
                    [batchSize].concat(generic_utils.toList(config.inputLength));
            }
        }
        _this.inputDim = config.inputDim;
        _this.outputDim = config.outputDim;
        _this.embeddingsInitializer = initializers_1.getInitializer(config.embeddingsInitializer || _this.DEFAULT_EMBEDDINGS_INITIALIZER);
        _this.embeddingsRegularizer = regularizers_1.getRegularizer(config.embeddingsRegularizer);
        _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
        _this.embeddingsConstraint = constraints_1.getConstraint(config.embeddingsConstraint);
        _this.maskZero = config.maskZero;
        _this.inputLength = config.inputLength;
        return _this;
    }
    Embedding.prototype.build = function (inputShape) {
        this.embeddings = this.addWeight('embeddings', [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
        this.built = true;
    };
    Embedding.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for Embedding yet');
    };
    Embedding.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        if (this.inputLength == null) {
            return inputShape.concat([this.outputDim]);
        }
        var inLens = generic_utils.toList(this.inputLength);
        if (inLens.length !== inputShape.length - 1) {
            throw new errors_1.ValueError("\"inputLength\" is " + this.inputLength + ", but received " +
                ("input shape has shape " + inputShape));
        }
        else {
            var i = 0;
            for (var k = 0; k < inLens.length; ++k) {
                var s1 = inLens[k];
                var s2 = inputShape[k + 1];
                if ((s1 != null) && (s2 != null) && (s1 !== s2)) {
                    throw new errors_1.ValueError("\"inputLength\" is " + this.inputLength + ", but received " +
                        ("input shape has shape " + inputShape));
                }
                else if (s1 == null) {
                    inLens[i] = s2;
                }
                i++;
            }
        }
        return [inputShape[0]].concat(inLens, [this.outputDim]);
    };
    Embedding.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (K.dtype(input) !== 'int32') {
                input = K.cast(input, 'int32');
            }
            var output = K.gather(_this.embeddings.read(), input.as1D());
            return output.reshape(generic_utils_1.getExactlyOneShape(_this.computeOutputShape(input.shape)));
        });
    };
    Embedding.prototype.getConfig = function () {
        var config = {
            inputDim: this.inputDim,
            outputDim: this.outputDim,
            embeddingsInitializer: initializers_1.serializeInitializer(this.embeddingsInitializer),
            embeddingsRegularizer: regularizers_1.serializeRegularizer(this.embeddingsRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            embeddingsConstraint: constraints_1.serializeConstraint(this.embeddingsConstraint),
            maskZero: this.maskZero,
            inputLength: this.inputLength
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Embedding.className = 'Embedding';
    return Embedding;
}(topology_1.Layer));
exports.Embedding = Embedding;
tfjs_core_1.serialization.SerializationMap.register(Embedding);

},{"../backend/tfjs_backend":160,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],176:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils = require("../utils/generic_utils");
var mathUtils = require("../utils/math_utils");
var Merge = (function (_super) {
    __extends(Merge, _super);
    function Merge(config) {
        var _this = _super.call(this, config || {}) || this;
        _this.supportsMasking = true;
        return _this;
    }
    Merge.prototype.mergeFunction = function (inputs) {
        throw new errors_1.NotImplementedError();
    };
    Merge.prototype.computeElementwiseOpOutputShape = function (shape1, shape2) {
        if (shape1 == null || shape2 == null) {
            return null;
        }
        else if (shape1.length < shape2.length) {
            return this.computeElementwiseOpOutputShape(shape2, shape1);
        }
        else if (shape2.length === 0) {
            return shape1;
        }
        var outputShape = shape1.slice(0, shape1.length - shape2.length);
        for (var k = 0; k < shape2.length; ++k) {
            var i = shape1[shape1.length - shape2.length + k];
            var j = shape2[k];
            if (i == null || j == null || i < 0 || j < 0) {
                outputShape.push(null);
            }
            else if (i === 1) {
                outputShape.push(j);
            }
            else if (j === 1) {
                outputShape.push(i);
            }
            else {
                if (i !== j) {
                    throw new errors_1.ValueError('Operands could not be broadcast together with shapes ' +
                        JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));
                }
                outputShape.push(i);
            }
        }
        return outputShape;
    };
    Merge.prototype.build = function (inputShape) {
        if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {
            inputShape = [generic_utils.getExactlyOneShape(inputShape)];
        }
        inputShape = inputShape;
        if (inputShape.length < 2) {
            throw new errors_1.ValueError('A merge layer should be called on an Array of at least 2 inputs.' +
                (" Got " + inputShape.length + " input(s)."));
        }
        var batchSizes = [];
        for (var _i = 0, inputShape_1 = inputShape; _i < inputShape_1.length; _i++) {
            var shape = inputShape_1[_i];
            if (shape != null && shape[0] !== null) {
                batchSizes.push(shape[0]);
            }
        }
        batchSizes = generic_utils.unique(batchSizes);
        if (batchSizes.length > 1) {
            throw new errors_1.ValueError("Can not merge tensors with different batch sizes. " +
                ("Got tensors with shapes: " + JSON.stringify(inputShape) + "."));
        }
        var outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);
        for (var i = 1; i < inputShape.length; ++i) {
            var shape = inputShape[i] == null ? null : inputShape[i].slice(1);
            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
        }
        var allRanks = inputShape.map(function (shape) { return shape.length; });
        if (inputShape.indexOf(null) === -1 &&
            generic_utils.unique(allRanks).length === 1) {
            this.reshapeRequired = false;
        }
        else {
            this.reshapeRequired = true;
        }
    };
    Merge.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            if (_this.reshapeRequired) {
                var reshapedInputs = [];
                var inputDims = inputs.map(function (input) { return input.rank; });
                if (inputDims.indexOf(null) === -1) {
                    var maxNDim = mathUtils.max(inputDims);
                    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                        var x = inputs_1[_i];
                        var xNDim = x.rank;
                        for (var k = 0; k < maxNDim - xNDim; ++k) {
                            x = K.expandDims(x, 1);
                        }
                        reshapedInputs.push(x);
                    }
                    return _this.mergeFunction(reshapedInputs);
                }
                else {
                    var transposed = false;
                    for (var _a = 0, inputs_2 = inputs; _a < inputs_2.length; _a++) {
                        var x = inputs_2[_a];
                        var xNDim = x.rank;
                        if (xNDim == null) {
                            var xShape = K.shape(x);
                            var batchSize = xShape[0];
                            var newShape = xShape.slice(1).concat([batchSize]);
                            var xTransposed = x.reshape([batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));
                            xTransposed = tfc.transpose(xTransposed, [1, 0]);
                            xTransposed = xTransposed.reshape(newShape);
                            reshapedInputs.push(xTransposed);
                            transposed = true;
                        }
                        else if (xNDim > 1) {
                            var dims = mathUtils.range(1, xNDim).concat([0]);
                            reshapedInputs.push(tfc.transpose(x, dims));
                            transposed = true;
                        }
                        else {
                            reshapedInputs.push(x);
                        }
                    }
                    var y = _this.mergeFunction(reshapedInputs);
                    var yNDim = y.rank;
                    if (transposed) {
                        if (yNDim == null) {
                            var yShape = K.shape(y);
                            var yNDim_1 = yShape.length;
                            var batchSize = yShape[yNDim_1 - 1];
                            var newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));
                            y = tfc.transpose(y.reshape([-1, batchSize]), [1, 0])
                                .reshape(newShape);
                        }
                        else if (yNDim > 1) {
                            var dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));
                            y = tfc.transpose(y, dims);
                        }
                    }
                    return y;
                }
            }
            else {
                return _this.mergeFunction(inputs);
            }
        });
    };
    Merge.prototype.computeOutputShape = function (inputShape) {
        inputShape = inputShape;
        var outputShape;
        if (inputShape[0] == null) {
            outputShape = null;
        }
        else {
            outputShape = inputShape[0].slice(1);
        }
        for (var i = 1; i < inputShape.length; ++i) {
            var shape = inputShape[i] == null ? null : inputShape[i].slice(1);
            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
        }
        var batchSizes = [];
        for (var _i = 0, inputShape_2 = inputShape; _i < inputShape_2.length; _i++) {
            var shape = inputShape_2[_i];
            if (shape != null && shape[0] !== null) {
                batchSizes.push(shape[0]);
            }
        }
        batchSizes = generic_utils.unique(batchSizes);
        if (batchSizes.length === 1) {
            outputShape = batchSizes.concat(outputShape);
        }
        else {
            outputShape = [null].concat(outputShape);
        }
        return outputShape;
    };
    return Merge;
}(topology_1.Layer));
exports.Merge = Merge;
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(config) {
        return _super.call(this, config) || this;
    }
    Add.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = tfc.zeros(inputs[0].shape);
            for (var _i = 0, inputs_3 = inputs; _i < inputs_3.length; _i++) {
                var input = inputs_3[_i];
                output = tfc.add(output, input);
            }
            return output;
        });
    };
    Add.className = 'Add';
    return Add;
}(Merge));
exports.Add = Add;
tfjs_core_1.serialization.SerializationMap.register(Add);
function add(config) {
    if (Array.isArray(config)) {
        var layer = new Add({});
        return layer.apply(config);
    }
    else {
        return new Add(config);
    }
}
exports.add = add;
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(config) {
        return _super.call(this, config) || this;
    }
    Multiply.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = tfc.ones(inputs[0].shape);
            for (var _i = 0, inputs_4 = inputs; _i < inputs_4.length; _i++) {
                var input = inputs_4[_i];
                output = tfc.mul(output, input);
            }
            return output;
        });
    };
    Multiply.className = 'Multiply';
    return Multiply;
}(Merge));
exports.Multiply = Multiply;
tfjs_core_1.serialization.SerializationMap.register(Multiply);
function multiply(config) {
    if (Array.isArray(config)) {
        var layer = new Multiply({});
        return layer.apply(config);
    }
    else {
        return new Multiply(config);
    }
}
exports.multiply = multiply;
var Average = (function (_super) {
    __extends(Average, _super);
    function Average(config) {
        return _super.call(this, config) || this;
    }
    Average.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = tfc.zeros(inputs[0].shape);
            for (var _i = 0, inputs_5 = inputs; _i < inputs_5.length; _i++) {
                var input = inputs_5[_i];
                output = tfc.add(output, input);
            }
            return K.scalarTimesArray(K.getScalar(1 / inputs.length), output);
        });
    };
    Average.className = 'Average';
    return Average;
}(Merge));
exports.Average = Average;
tfjs_core_1.serialization.SerializationMap.register(Average);
function average(config) {
    if (Array.isArray(config)) {
        var layer = new Average({});
        return layer.apply(config);
    }
    else {
        return new Average(config);
    }
}
exports.average = average;
var Maximum = (function (_super) {
    __extends(Maximum, _super);
    function Maximum(config) {
        return _super.call(this, config) || this;
    }
    Maximum.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0];
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.maximum(output, inputs[i]);
            }
            return output;
        });
    };
    Maximum.className = 'Maximum';
    return Maximum;
}(Merge));
exports.Maximum = Maximum;
tfjs_core_1.serialization.SerializationMap.register(Maximum);
function maximum(config) {
    if (Array.isArray(config)) {
        var layer = new Maximum({});
        return layer.apply(config);
    }
    else {
        return new Maximum(config);
    }
}
exports.maximum = maximum;
var Minimum = (function (_super) {
    __extends(Minimum, _super);
    function Minimum(config) {
        return _super.call(this, config) || this;
    }
    Minimum.prototype.mergeFunction = function (inputs) {
        return tfjs_core_1.tidy(function () {
            var output = inputs[0];
            for (var i = 1; i < inputs.length; ++i) {
                output = tfc.minimum(output, inputs[i]);
            }
            return output;
        });
    };
    Minimum.className = 'Minimum';
    return Minimum;
}(Merge));
exports.Minimum = Minimum;
tfjs_core_1.serialization.SerializationMap.register(Minimum);
function minimum(config) {
    if (Array.isArray(config)) {
        var layer = new Minimum({});
        return layer.apply(config);
    }
    else {
        return new Minimum(config);
    }
}
exports.minimum = minimum;
var Concatenate = (function (_super) {
    __extends(Concatenate, _super);
    function Concatenate(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_AXIS = -1;
        if (config == null) {
            config = {};
        }
        _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;
        _this.supportsMasking = true;
        _this.reshapeRequired = false;
        return _this;
    }
    Concatenate.prototype.build = function (inputShape) {
        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) ||
            inputShape.length === 1) {
            throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of at least 2 ' +
                'inputs');
        }
        inputShape = inputShape;
        var allNoneShape = true;
        for (var _i = 0, inputShape_3 = inputShape; _i < inputShape_3.length; _i++) {
            var shape = inputShape_3[_i];
            if (shape != null) {
                allNoneShape = false;
                break;
            }
        }
        if (allNoneShape) {
            return;
        }
        var shapeSet = [];
        for (var i = 0; i < inputShape.length; ++i) {
            var shapeWithoutConcatAxis = inputShape[i].slice();
            shapeWithoutConcatAxis.splice(this.axis, 1);
            var exists = false;
            for (var _a = 0, shapeSet_1 = shapeSet; _a < shapeSet_1.length; _a++) {
                var shape = shapeSet_1[_a];
                if (tfjs_core_1.util.arraysEqual(shape, shapeWithoutConcatAxis)) {
                    exists = true;
                    break;
                }
            }
            if (!exists) {
                shapeSet.push(shapeWithoutConcatAxis);
            }
        }
        if (shapeSet.length > 1) {
            throw new errors_1.ValueError('A `Concatenate` layer requires inputs with matching shapes ' +
                'except for the concat axis. Got input shapes: ' +
                JSON.stringify(inputShape));
        }
    };
    Concatenate.prototype.mergeFunction = function (inputs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            return K.concatenate(inputs, _this.axis);
        });
    };
    Concatenate.prototype.computeOutputShape = function (inputShape) {
        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {
            throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of inputs.');
        }
        var inputShapes = inputShape;
        var outputShape = inputShapes[0].slice();
        var axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;
        for (var _i = 0, _a = inputShapes.slice(1); _i < _a.length; _i++) {
            var shape = _a[_i];
            if (outputShape[axis] == null || shape[axis] == null) {
                outputShape[axis] = null;
                break;
            }
            outputShape[axis] += shape[axis];
        }
        return outputShape;
    };
    Concatenate.prototype.getConfig = function () {
        var config = {
            'axis': this.axis,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Concatenate.className = 'Concatenate';
    return Concatenate;
}(Merge));
exports.Concatenate = Concatenate;
tfjs_core_1.serialization.SerializationMap.register(Concatenate);
function concatenate(config) {
    if (Array.isArray(config)) {
        var layer = new Concatenate({});
        return layer.apply(config);
    }
    else {
        return new Concatenate(config);
    }
}
exports.concatenate = concatenate;

},{"../backend/tfjs_backend":160,"../engine/topology":165,"../errors":167,"../utils/generic_utils":190,"../utils/math_utils":191,"@tensorflow/tfjs-core":51}],177:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var generic_utils = require("../utils/generic_utils");
var math_utils = require("../utils/math_utils");
function batchNormalization(x, mean, variance, beta, gamma, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    var out;
    if (x.rank === 2) {
        out = tfc.batchNormalization2d(x, mean, variance, epsilon, gamma, beta);
    }
    else if (x.rank === 3) {
        out = tfc.batchNormalization3d(x, mean, variance, epsilon, gamma, beta);
    }
    else if (x.rank === 4) {
        out = tfc.batchNormalization4d(x, mean, variance, epsilon, gamma, beta);
    }
    else {
        throw new errors_1.NotImplementedError("batchNormalization is not implememnted for array of rank " + x.rank + " " +
            "yet");
    }
    return out;
}
exports.batchNormalization = batchNormalization;
function regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    return tfjs_core_1.tidy(function () {
        var meanAndVariance = tfc.moments(x, reductionAxes);
        var mean = meanAndVariance.mean;
        var variance = meanAndVariance.variance;
        var normed = batchNormalization(x, mean, variance, beta, gamma, epsilon);
        return [normed, mean, variance];
    });
}
function broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    return tfjs_core_1.tidy(function () {
        var meanAndVariance = tfc.moments(x, reductionAxes);
        var mean = meanAndVariance.mean;
        var variance = meanAndVariance.variance;
        var targetShape = [];
        for (var _i = 0, _a = math_utils.range(0, x.rank); _i < _a.length; _i++) {
            var axis = _a[_i];
            if (reductionAxes.indexOf(axis) !== -1) {
                targetShape.push(1);
            }
            else {
                targetShape.push(x.shape[axis]);
            }
        }
        var broadcastMean = mean.reshape(targetShape);
        var broadcastVariance = variance.reshape(targetShape);
        var broadcastGamma = gamma == null ? null : gamma.reshape(targetShape);
        var broadcastBeta = beta == null ? null : beta.reshape(targetShape);
        var normed = batchNormalization(x, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon);
        return [normed, mean, variance];
    });
}
function normalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
    if (epsilon === void 0) { epsilon = 1e-3; }
    if (tfjs_core_1.util.arraysEqual(reductionAxes.slice().sort(), math_utils.range(0, x.rank - 1))) {
        return regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon);
    }
    else {
        return broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon);
    }
}
exports.normalizeBatchInTraining = normalizeBatchInTraining;
var BatchNormalization = (function (_super) {
    __extends(BatchNormalization, _super);
    function BatchNormalization(config) {
        var _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        _this.axis = config.axis == null ? -1 : config.axis;
        _this.momentum = config.momentum == null ? 0.99 : config.momentum;
        _this.epsilon = config.epsilon == null ? 1e-3 : config.epsilon;
        _this.center = config.center == null ? true : config.center;
        _this.scale = config.scale == null ? true : config.scale;
        _this.betaInitializer = initializers_1.getInitializer(config.betaInitializer || 'zeros');
        _this.gammaInitializer = initializers_1.getInitializer(config.gammaInitializer || 'ones');
        _this.movingMeanInitializer =
            initializers_1.getInitializer(config.movingMeanInitializer || 'zeros');
        _this.movingVarianceInitializer =
            initializers_1.getInitializer(config.movingVarianceInitializer || 'ones');
        _this.betaConstraint = constraints_1.getConstraint(config.betaConstraint);
        _this.gammaConstraint = constraints_1.getConstraint(config.gammaConstraint);
        _this.betaRegularizer = regularizers_1.getRegularizer(config.betaRegularizer);
        _this.gammaRegularizer = regularizers_1.getRegularizer(config.gammaRegularizer);
        _this.stepCount = 0;
        return _this;
    }
    BatchNormalization.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var axis = this.axis >= 0 ? this.axis : (this.axis + inputShape.length);
        var dim = inputShape[axis];
        if (dim == null) {
            throw new errors_1.ValueError("Axis " + axis + " of input tensor should have a defined dimension but " +
                "the layer received an input with shape " +
                (JSON.stringify(inputShape) + "."));
        }
        this.inputSpec =
            [new topology_1.InputSpec({ ndim: inputShape.length, axes: (_a = {}, _a[axis] = dim, _a) })];
        var shape = [dim];
        if (this.scale) {
            this.gamma = this.addWeight('gamma', shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);
        }
        if (this.center) {
            this.beta = this.addWeight('beta', shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);
        }
        this.movingMean = this.addWeight('moving_mean', shape, null, this.movingMeanInitializer, null, false);
        this.movingVariance = this.addWeight('moving_variance', shape, null, this.movingVarianceInitializer, null, false);
        this.built = true;
        var _a;
    };
    BatchNormalization.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var training = kwargs['training'] == null ? false : kwargs['training'];
            var input = generic_utils.getExactlyOneTensor(inputs);
            var inputShape = K.shape(input);
            var ndim = inputShape.length;
            var reductionAxes = math_utils.range(0, ndim);
            var axis = _this.axis >= 0 ? _this.axis : (_this.axis + ndim);
            reductionAxes.splice(axis, 1);
            var broadcastShape = generic_utils.pyListRepeat(1, ndim);
            broadcastShape[axis] = inputShape[axis];
            var sortedReductionAxes = reductionAxes.slice();
            sortedReductionAxes.sort();
            var needsBroadcasting = !tfjs_core_1.util.arraysEqual(sortedReductionAxes, math_utils.range(0, ndim).slice(0, ndim - 1));
            var normalizeInference = function () {
                if (needsBroadcasting) {
                    var broadcastMovingMean = _this.movingMean.read().reshape(broadcastShape);
                    var broadcastMovingVariance = _this.movingVariance.read().reshape(broadcastShape);
                    var broadcastBeta = _this.center ? _this.beta.read().reshape(broadcastShape) : null;
                    var broadcastGamma = _this.scale ? _this.gamma.read().reshape(broadcastShape) : null;
                    return batchNormalization(input, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, _this.epsilon);
                }
                else {
                    return batchNormalization(input, _this.movingMean.read(), _this.movingVariance.read(), _this.beta == null ? null : _this.beta.read(), _this.gamma == null ? null : _this.gamma.read(), _this.epsilon);
                }
            };
            if (!training) {
                return normalizeInference();
            }
            var _a = normalizeBatchInTraining(input, _this.gamma.read(), _this.beta.read(), reductionAxes, _this.epsilon), normedTraining = _a[0], mean = _a[1], variance = _a[2];
            var sampleSize = math_utils.arrayProd(reductionAxes.map(function (axis) { return input.shape[axis]; }));
            var varianceDebiased = variance.mul(K.getScalar(sampleSize / (sampleSize - (1 + _this.epsilon))));
            var updateMovingMeanAndVariance = function () {
                _this.stepCount++;
                var newMovingMean = tfc.movingAverage(_this.movingMean.read(), mean, _this.momentum, _this.stepCount);
                _this.movingMean.write(newMovingMean);
                var newMovingVariance = tfc.movingAverage(_this.movingVariance.read(), varianceDebiased, _this.momentum, _this.stepCount);
                _this.movingVariance.write(newMovingVariance);
            };
            updateMovingMeanAndVariance();
            return normedTraining;
        });
    };
    BatchNormalization.prototype.getConfig = function () {
        var config = {
            axis: this.axis,
            momentum: this.momentum,
            epsilon: this.epsilon,
            center: this.center,
            scale: this.scale,
            betaInitializer: initializers_1.serializeInitializer(this.betaInitializer),
            gammaInitializer: initializers_1.serializeInitializer(this.gammaInitializer),
            movingMeanInitializer: initializers_1.serializeInitializer(this.movingMeanInitializer),
            movingVarianceInitializer: initializers_1.serializeInitializer(this.movingVarianceInitializer),
            betaRegularizer: regularizers_1.serializeRegularizer(this.betaRegularizer),
            gammaRegularizer: regularizers_1.serializeRegularizer(this.gammaRegularizer),
            betaConstraint: constraints_1.serializeConstraint(this.betaConstraint),
            gammaConstraint: constraints_1.serializeConstraint(this.gammaConstraint)
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    BatchNormalization.className = 'BatchNormalization';
    return BatchNormalization;
}(topology_1.Layer));
exports.BatchNormalization = BatchNormalization;
tfjs_core_1.serialization.SerializationMap.register(BatchNormalization);

},{"../backend/tfjs_backend":160,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../utils/generic_utils":190,"../utils/math_utils":191,"@tensorflow/tfjs-core":51}],178:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils_1 = require("../utils/generic_utils");
function temporalPadding(x, padding) {
    return tfjs_core_1.tidy(function () {
        if (x.rank !== 3) {
            throw new errors_1.ValueError("temporalPadding expects input tensor to be 3-D, but received a " +
                (x.rank + "-D tensor."));
        }
        if (padding == null) {
            padding = [1, 1];
        }
        if (padding.length !== 2) {
            throw new errors_1.ValueError("temporalPadding expects input padding pattern to be a length-2 " +
                ("array, but received a length-" + padding.length + " array."));
        }
        var pattern = [[0, 0], padding, [0, 0]];
        return tfc.pad(x, pattern);
    });
}
exports.temporalPadding = temporalPadding;
function spatial2dPadding(x, padding, dataFormat) {
    return tfjs_core_1.tidy(function () {
        if (x.rank !== 4) {
            throw new errors_1.ValueError("temporalPadding expects input tensor to be 4-D, but received a " +
                (x.rank + "-D tensor."));
        }
        if (padding == null) {
            padding = [[1, 1], [1, 1]];
        }
        if (padding.length !== 2 || padding[0].length !== 2 ||
            padding[1].length !== 2) {
            throw new errors_1.ValueError('spatial2dPadding expects `padding` to be an Array of two Arrays, ' +
                'each of which is an Array of two integers.');
        }
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {
            throw new errors_1.ValueError("Unknown data format: " + dataFormat + ". " +
                "Supported data formats are 'channelsLast' and 'channelsFirst.");
        }
        var pattern;
        if (dataFormat === 'channelsFirst') {
            pattern = [[0, 0], [0, 0], padding[0], padding[1]];
        }
        else {
            pattern = [[0, 0], padding[0], padding[1], [0, 0]];
        }
        return tfc.pad(x, pattern);
    });
}
exports.spatial2dPadding = spatial2dPadding;
var ZeroPadding2D = (function (_super) {
    __extends(ZeroPadding2D, _super);
    function ZeroPadding2D(config) {
        var _this = this;
        if (config == null) {
            config = {};
        }
        _this = _super.call(this, config) || this;
        _this.dataFormat =
            config.dataFormat == null ? common_1.imageDataFormat() : config.dataFormat;
        if (config.padding == null) {
            _this.padding = [[1, 1], [1, 1]];
        }
        else if (typeof config.padding === 'number') {
            _this.padding =
                [[config.padding, config.padding], [config.padding, config.padding]];
        }
        else {
            config.padding = config.padding;
            if (config.padding.length !== 2) {
                throw new errors_1.ValueError("ZeroPadding2D expects padding to be a length-2 array, but " +
                    ("received a length-" + config.padding.length + " array."));
            }
            var heightPadding = void 0;
            var widthPadding = void 0;
            if (typeof config.padding[0] === 'number') {
                heightPadding =
                    [config.padding[0], config.padding[0]];
                widthPadding =
                    [config.padding[1], config.padding[1]];
            }
            else {
                config.padding = config.padding;
                if (config.padding[0].length !== 2) {
                    throw new errors_1.ValueError("ZeroPadding2D expects height padding to be a length-2 array, " +
                        ("but received a length-" + config.padding[0].length + " array."));
                }
                heightPadding = config.padding[0];
                if (config.padding[1].length !== 2) {
                    throw new errors_1.ValueError("ZeroPadding2D expects width padding to be a length-2 array, " +
                        ("but received a length-" + config.padding[1].length + " array."));
                }
                widthPadding = config.padding[1];
            }
            _this.padding = [heightPadding, widthPadding];
        }
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    ZeroPadding2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils_1.getExactlyOneShape(inputShape);
        var rows;
        var cols;
        if (this.dataFormat === 'channelsFirst') {
            if (inputShape[2] != null && inputShape[2] >= 0) {
                rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];
            }
            else {
                rows = null;
            }
            if (inputShape[3] != null && inputShape[3] >= 0) {
                cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];
            }
            else {
                cols = null;
            }
            return [inputShape[0], inputShape[1], rows, cols];
        }
        else {
            if (inputShape[1] != null && inputShape[1] >= 0) {
                rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];
            }
            else {
                rows = null;
            }
            if (inputShape[2] != null && inputShape[2] >= 0) {
                cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];
            }
            else {
                cols = null;
            }
            return [inputShape[0], rows, cols, inputShape[3]];
        }
    };
    ZeroPadding2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () { return spatial2dPadding(generic_utils_1.getExactlyOneTensor(inputs), _this.padding, _this.dataFormat); });
    };
    ZeroPadding2D.prototype.getConfig = function () {
        var config = {
            padding: this.padding,
            dataFormat: this.dataFormat,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    ZeroPadding2D.className = 'ZeroPadding2D';
    return ZeroPadding2D;
}(topology_1.Layer));
exports.ZeroPadding2D = ZeroPadding2D;
tfjs_core_1.serialization.SerializationMap.register(ZeroPadding2D);

},{"../backend/common":159,"../engine/topology":165,"../errors":167,"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],179:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("../backend/common");
var K = require("../backend/tfjs_backend");
var common_2 = require("../common");
var topology_1 = require("../engine/topology");
var topology_2 = require("../engine/topology");
var errors_1 = require("../errors");
var conv_utils_1 = require("../utils/conv_utils");
var generic_utils = require("../utils/generic_utils");
var convolutional_1 = require("./convolutional");
function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {
    return tfjs_core_1.tidy(function () {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPoolMode(poolMode);
        common_2.checkPaddingMode(padding);
        if (strides == null) {
            strides = [1, 1];
        }
        if (padding == null) {
            padding = 'valid';
        }
        if (dataFormat == null) {
            dataFormat = common_1.imageDataFormat();
        }
        if (poolMode == null) {
            poolMode = 'max';
        }
        x = convolutional_1.preprocessConv2DInput(x, dataFormat);
        var y;
        var paddingString = (padding === 'same') ? 'same' : 'valid';
        if (poolMode === 'max') {
            y = tfc.maxPool(x, poolSize, strides, paddingString);
        }
        else {
            y = tfc.avgPool(x, poolSize, strides, paddingString);
        }
        if (dataFormat === 'channelsFirst') {
            y = tfc.transpose(y, [0, 3, 1, 2]);
        }
        return y;
    });
}
exports.pool2d = pool2d;
var Pooling1D = (function (_super) {
    __extends(Pooling1D, _super);
    function Pooling1D(config) {
        var _this = this;
        if (config.poolSize == null) {
            config.poolSize = 2;
        }
        _this = _super.call(this, config) || this;
        if (typeof config.poolSize === 'number') {
            _this.poolSize = [config.poolSize];
        }
        else if (Array.isArray(config.poolSize) &&
            config.poolSize.length === 1 &&
            typeof config.poolSize[0] === 'number') {
            _this.poolSize = config.poolSize;
        }
        else {
            throw new errors_1.ValueError("poolSize for 1D convolutional layer must be a number or an " +
                "Array of a single number, but received " +
                ("" + JSON.stringify(config.poolSize)));
        }
        if (config.strides == null) {
            _this.strides = _this.poolSize;
        }
        else {
            if (typeof config.strides === 'number') {
                _this.strides = [config.strides];
            }
            else if (Array.isArray(config.strides) &&
                config.strides.length === 1 &&
                typeof config.strides[0] === 'number') {
                _this.strides = config.strides;
            }
            else {
                throw new errors_1.ValueError("strides for 1D convolutional layer must be a number or an " +
                    "Array of a single number, but received " +
                    ("" + JSON.stringify(config.strides)));
            }
        }
        _this.padding = config.padding == null ? 'valid' : config.padding;
        common_2.checkPaddingMode(_this.padding);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        return _this;
    }
    Pooling1D.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var length = conv_utils_1.convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);
        return [inputShape[0], length, inputShape[2]];
    };
    Pooling1D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            inputs = K.expandDims(generic_utils.getExactlyOneTensor(inputs), 2);
            var output = _this.poolingFunction(generic_utils.getExactlyOneTensor(inputs), [_this.poolSize[0], 1], [_this.strides[0], 1], _this.padding, 'channelsLast');
            return tfc.squeeze(output, [2]);
        });
    };
    Pooling1D.prototype.getConfig = function () {
        var config = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return Pooling1D;
}(topology_2.Layer));
exports.Pooling1D = Pooling1D;
var MaxPooling1D = (function (_super) {
    __extends(MaxPooling1D, _super);
    function MaxPooling1D(config) {
        return _super.call(this, config) || this;
    }
    MaxPooling1D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');
    };
    MaxPooling1D.className = 'MaxPooling1D';
    return MaxPooling1D;
}(Pooling1D));
exports.MaxPooling1D = MaxPooling1D;
tfjs_core_1.serialization.SerializationMap.register(MaxPooling1D);
var AveragePooling1D = (function (_super) {
    __extends(AveragePooling1D, _super);
    function AveragePooling1D(config) {
        return _super.call(this, config) || this;
    }
    AveragePooling1D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');
    };
    AveragePooling1D.className = 'AveragePooling1D';
    return AveragePooling1D;
}(Pooling1D));
exports.AveragePooling1D = AveragePooling1D;
tfjs_core_1.serialization.SerializationMap.register(AveragePooling1D);
var Pooling2D = (function (_super) {
    __extends(Pooling2D, _super);
    function Pooling2D(config) {
        var _this = this;
        if (config.poolSize == null) {
            config.poolSize = [2, 2];
        }
        _this = _super.call(this, config) || this;
        _this.poolSize = Array.isArray(config.poolSize) ?
            config.poolSize :
            [config.poolSize, config.poolSize];
        _this.strides = config.strides == null ? _this.poolSize : config.strides;
        _this.padding = config.padding == null ? 'valid' : config.padding;
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        common_2.checkPaddingMode(_this.padding);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    Pooling2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];
        var cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];
        rows =
            conv_utils_1.convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);
        cols =
            conv_utils_1.convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === 'channelsFirst') {
            return [inputShape[0], inputShape[1], rows, cols];
        }
        else {
            return [inputShape[0], rows, cols, inputShape[3]];
        }
    };
    Pooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            _this.invokeCallHook(inputs, kwargs);
            return _this.poolingFunction(generic_utils.getExactlyOneTensor(inputs), _this.poolSize, _this.strides, _this.padding, _this.dataFormat);
        });
    };
    Pooling2D.prototype.getConfig = function () {
        var config = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
            dataFormat: this.dataFormat
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return Pooling2D;
}(topology_2.Layer));
exports.Pooling2D = Pooling2D;
var MaxPooling2D = (function (_super) {
    __extends(MaxPooling2D, _super);
    function MaxPooling2D(config) {
        return _super.call(this, config) || this;
    }
    MaxPooling2D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');
    };
    MaxPooling2D.className = 'MaxPooling2D';
    return MaxPooling2D;
}(Pooling2D));
exports.MaxPooling2D = MaxPooling2D;
tfjs_core_1.serialization.SerializationMap.register(MaxPooling2D);
var AveragePooling2D = (function (_super) {
    __extends(AveragePooling2D, _super);
    function AveragePooling2D(config) {
        return _super.call(this, config) || this;
    }
    AveragePooling2D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
        common_2.checkDataFormat(dataFormat);
        common_2.checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');
    };
    AveragePooling2D.className = 'AveragePooling2D';
    return AveragePooling2D;
}(Pooling2D));
exports.AveragePooling2D = AveragePooling2D;
tfjs_core_1.serialization.SerializationMap.register(AveragePooling2D);
var GlobalPooling1D = (function (_super) {
    __extends(GlobalPooling1D, _super);
    function GlobalPooling1D(config) {
        var _this = _super.call(this, config) || this;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        return _this;
    }
    GlobalPooling1D.prototype.computeOutputShape = function (inputShape) {
        return [inputShape[0], inputShape[2]];
    };
    GlobalPooling1D.prototype.call = function (inputs, kwargs) {
        throw new errors_1.NotImplementedError();
    };
    return GlobalPooling1D;
}(topology_2.Layer));
exports.GlobalPooling1D = GlobalPooling1D;
var GlobalAveragePooling1D = (function (_super) {
    __extends(GlobalAveragePooling1D, _super);
    function GlobalAveragePooling1D(config) {
        return _super.call(this, config) || this;
    }
    GlobalAveragePooling1D.prototype.call = function (inputs, kwargs) {
        return tfjs_core_1.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            return tfc.mean(input, 1);
        });
    };
    GlobalAveragePooling1D.className = 'GlobalAveragePooling1D';
    return GlobalAveragePooling1D;
}(GlobalPooling1D));
exports.GlobalAveragePooling1D = GlobalAveragePooling1D;
tfjs_core_1.serialization.SerializationMap.register(GlobalAveragePooling1D);
var GlobalMaxPooling1D = (function (_super) {
    __extends(GlobalMaxPooling1D, _super);
    function GlobalMaxPooling1D(config) {
        return _super.call(this, config) || this;
    }
    GlobalMaxPooling1D.prototype.call = function (inputs, kwargs) {
        return tfjs_core_1.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            return tfc.max(input, 1);
        });
    };
    GlobalMaxPooling1D.className = 'GlobalMaxPooling1D';
    return GlobalMaxPooling1D;
}(GlobalPooling1D));
exports.GlobalMaxPooling1D = GlobalMaxPooling1D;
tfjs_core_1.serialization.SerializationMap.register(GlobalMaxPooling1D);
var GlobalPooling2D = (function (_super) {
    __extends(GlobalPooling2D, _super);
    function GlobalPooling2D(config) {
        var _this = _super.call(this, config) || this;
        _this.dataFormat =
            config.dataFormat == null ? 'channelsLast' : config.dataFormat;
        common_2.checkDataFormat(_this.dataFormat);
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 4 })];
        return _this;
    }
    GlobalPooling2D.prototype.computeOutputShape = function (inputShape) {
        inputShape = inputShape;
        if (this.dataFormat === 'channelsLast') {
            return [inputShape[0], inputShape[3]];
        }
        else {
            return [inputShape[0], inputShape[1]];
        }
    };
    GlobalPooling2D.prototype.call = function (inputs, kwargs) {
        throw new errors_1.NotImplementedError();
    };
    GlobalPooling2D.prototype.getConfig = function () {
        var config = { dataFormat: this.dataFormat };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    return GlobalPooling2D;
}(topology_2.Layer));
exports.GlobalPooling2D = GlobalPooling2D;
var GlobalAveragePooling2D = (function (_super) {
    __extends(GlobalAveragePooling2D, _super);
    function GlobalAveragePooling2D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalAveragePooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                return tfc.mean(input, [1, 2]);
            }
            else {
                return tfc.mean(input, [2, 3]);
            }
        });
    };
    GlobalAveragePooling2D.className = 'GlobalAveragePooling2D';
    return GlobalAveragePooling2D;
}(GlobalPooling2D));
exports.GlobalAveragePooling2D = GlobalAveragePooling2D;
tfjs_core_1.serialization.SerializationMap.register(GlobalAveragePooling2D);
var GlobalMaxPooling2D = (function (_super) {
    __extends(GlobalMaxPooling2D, _super);
    function GlobalMaxPooling2D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalMaxPooling2D.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var input = generic_utils.getExactlyOneTensor(inputs);
            if (_this.dataFormat === 'channelsLast') {
                return tfc.max(input, [1, 2]);
            }
            else {
                return tfc.max(input, [2, 3]);
            }
        });
    };
    GlobalMaxPooling2D.className = 'GlobalMaxPooling2D';
    return GlobalMaxPooling2D;
}(GlobalPooling2D));
exports.GlobalMaxPooling2D = GlobalMaxPooling2D;
tfjs_core_1.serialization.SerializationMap.register(GlobalMaxPooling2D);

},{"../backend/common":159,"../backend/tfjs_backend":160,"../common":162,"../engine/topology":165,"../errors":167,"../utils/conv_utils":189,"../utils/generic_utils":190,"./convolutional":172,"@tensorflow/tfjs-core":51}],180:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var activations_1 = require("../activations");
var K = require("../backend/tfjs_backend");
var constraints_1 = require("../constraints");
var topology_1 = require("../engine/topology");
var topology_2 = require("../engine/topology");
var errors_1 = require("../errors");
var initializers_1 = require("../initializers");
var regularizers_1 = require("../regularizers");
var types_1 = require("../types");
var generic_utils = require("../utils/generic_utils");
var math_utils = require("../utils/math_utils");
var variables_1 = require("../variables");
var serialization_1 = require("./serialization");
function rnn(stepFunction, inputs, initialStates, goBackwards, mask, constants, unroll, inputLength) {
    if (goBackwards === void 0) { goBackwards = false; }
    if (unroll === void 0) { unroll = false; }
    var ndim = inputs.shape.length;
    if (ndim < 3) {
        throw new errors_1.ValueError("Input should be at least 3D, but is " + ndim + "D.");
    }
    var axes = [1, 0].concat(math_utils.range(2, ndim));
    inputs = tfc.transpose(inputs, axes);
    if (mask != null) {
        throw new errors_1.NotImplementedError('The rnn() function of the deeplearn.js backend does not support ' +
            'masking yet.');
    }
    if (constants != null) {
        throw new errors_1.NotImplementedError('The rnn() functoin of the deeplearn.js backend does not support ' +
            'constants yet.');
    }
    if (unroll) {
        console.warn('Backend rnn(): the unroll = true option is not applicable to the ' +
            'imperative deeplearn.js backend.');
    }
    if (goBackwards) {
        inputs = tfc.reverse(inputs, 0);
    }
    var outputs;
    var lastOutput;
    var states = initialStates;
    var timeSteps = inputs.shape[0];
    for (var t = 0; t < timeSteps; ++t) {
        var currentInput = K.sliceAlongFirstAxis(inputs, t, 1);
        currentInput = currentInput.reshape(currentInput.shape.slice(1));
        var stepOutputs = stepFunction(currentInput, states);
        lastOutput = stepOutputs[0];
        if (t === 0) {
            outputs = lastOutput.reshape([1].concat(lastOutput.shape));
        }
        else {
            outputs = K.concatAlongFirstAxis(outputs, lastOutput.reshape([1].concat(lastOutput.shape)));
        }
        states = stepOutputs[1];
    }
    return [
        lastOutput,
        tfc.transpose(outputs, [1, 0].concat(math_utils.range(2, outputs.shape.length))),
        states
    ];
}
exports.rnn = rnn;
var RNN = (function (_super) {
    __extends(RNN, _super);
    function RNN(config) {
        var _this = _super.call(this, config) || this;
        var cell;
        if (config.cell == null) {
            throw new errors_1.ValueError('cell property is missing for the constructor of RNN.');
        }
        else if (Array.isArray(config.cell)) {
            cell = new StackedRNNCells({ cells: config.cell });
        }
        else {
            cell = config.cell;
        }
        if (cell.stateSize == null) {
            throw new errors_1.ValueError('The RNN cell should have an attribute `stateSize` (tuple of ' +
                'integers, one integer per RNN state).');
        }
        _this.cell = cell;
        _this.returnSequences =
            config.returnSequences == null ? false : config.returnSequences;
        _this.returnState = config.returnState == null ? false : config.returnState;
        _this.goBackwards = config.goBackwards == null ? false : config.goBackwards;
        _this._stateful = config.stateful == null ? false : config.stateful;
        _this.unroll = config.unroll == null ? false : config.unroll;
        _this.supportsMasking = true;
        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];
        _this.stateSpec = null;
        _this.states = null;
        _this.numConstants = null;
        return _this;
    }
    RNN.prototype.getStates = function () {
        if (this.states == null) {
            var numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
            return math_utils.range(0, numStates).map(function (x) { return null; });
        }
        else {
            return this.states;
        }
    };
    RNN.prototype.setStates = function (states) {
        this.states = states;
    };
    RNN.prototype.computeOutputShape = function (inputShape) {
        if (generic_utils.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var stateSize = this.cell.stateSize;
        if (!Array.isArray(stateSize)) {
            stateSize = [stateSize];
        }
        var outputDim = stateSize[0];
        var outputShape;
        if (this.returnSequences) {
            outputShape = [inputShape[0], inputShape[1], outputDim];
        }
        else {
            outputShape = [inputShape[0], outputDim];
        }
        if (this.returnState) {
            var stateShape = [];
            for (var _i = 0, stateSize_1 = stateSize; _i < stateSize_1.length; _i++) {
                var dim = stateSize_1[_i];
                stateShape.push([inputShape[0], dim]);
            }
            return [outputShape].concat(stateShape);
        }
        else {
            return outputShape;
        }
    };
    RNN.prototype.computeMask = function (inputs, mask) {
        throw new errors_1.NotImplementedError('computeMask has not been implemented for RNN yet');
    };
    RNN.prototype.build = function (inputShape) {
        var constantShape = null;
        if (this.numConstants != null) {
            throw new errors_1.NotImplementedError('Constants support is not implemented in RNN yet.');
        }
        if (generic_utils.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var batchSize = this.stateful ? inputShape[0] : null;
        var inputDim = inputShape[inputShape.length - 1];
        this.inputSpec[0] = new topology_1.InputSpec({ shape: [batchSize, null, inputDim] });
        var stepInputShape = [inputShape[0]].concat(inputShape.slice(2));
        if (constantShape != null) {
            throw new errors_1.NotImplementedError('Constants support is not implemented in RNN yet.');
        }
        else {
            this.cell.build(stepInputShape);
        }
        var stateSize;
        if (Array.isArray(this.cell.stateSize)) {
            stateSize = this.cell.stateSize;
        }
        else {
            stateSize = [this.cell.stateSize];
        }
        if (this.stateSpec != null) {
            if (!tfjs_core_1.util.arraysEqual(this.stateSpec.map(function (spec) { return spec.shape[spec.shape.length - 1]; }), stateSize)) {
                throw new errors_1.ValueError("An initialState was passed that is not compatible with " +
                    ("cell.stateSize. Received stateSpec=" + this.stateSpec + "; ") +
                    ("However cell.stateSize is " + this.cell.stateSize));
            }
        }
        else {
            this.stateSpec =
                stateSize.map(function (dim) { return new topology_1.InputSpec({ shape: [null, dim] }); });
        }
        if (this.stateful) {
            throw new errors_1.NotImplementedError('stateful RNN layer is not implemented yet');
        }
    };
    RNN.prototype.resetStates = function (states) {
        var _this = this;
        tfjs_core_1.tidy(function () {
            if (!_this.stateful) {
                throw new errors_1.AttributeError('Cannot call resetState() on an RNN Layer that is not stateful.');
            }
            var batchSize = _this.inputSpec[0].shape[0];
            if (batchSize == null) {
                throw new errors_1.ValueError('If an RNN is stateful, it needs to know its batch size. Specify ' +
                    'the batch size of your input tensors: \n' +
                    '- If using a Sequential model, specify the batch size by ' +
                    'passing a `batchInputShape` option to your first layer.\n' +
                    '- If using the functional API, specify the batch size by ' +
                    'passing a `batchShape` option to your Input layer.');
            }
            if (_this.states == null) {
                if (Array.isArray(_this.cell.stateSize)) {
                    _this.states =
                        _this.cell.stateSize.map(function (dim) { return tfc.zeros([batchSize, dim]); });
                }
                else {
                    _this.states = [tfc.zeros([batchSize, _this.cell.stateSize])];
                }
            }
            else if (states == null) {
                if (Array.isArray(_this.cell.stateSize)) {
                    _this.states =
                        _this.cell.stateSize.map(function (dim) { return tfc.zeros([batchSize, dim]); });
                }
                else {
                    _this.states[0] = tfc.zeros([batchSize, _this.cell.stateSize]);
                }
            }
            else {
                if (!Array.isArray(states)) {
                    states = [states];
                }
                if (states.length !== _this.states.length) {
                    throw new errors_1.ValueError("Layer " + _this.name + " expects " + _this.states.length + " state(s), " +
                        ("but it received " + states.length + " state value(s). Input ") +
                        ("received: " + states));
                }
                for (var index = 0; index < _this.states.length; ++index) {
                    var value = states[index];
                    var dim = Array.isArray(_this.cell.stateSize) ?
                        _this.cell.stateSize[index] :
                        _this.cell.stateSize;
                    var expectedShape = [batchSize, dim];
                    if (!tfjs_core_1.util.arraysEqual(value.shape, expectedShape)) {
                        throw new errors_1.ValueError("State " + index + " is incompatible with layer " + _this.name + ": " +
                            ("expected shape=" + expectedShape + ", received shape=" + value.shape));
                    }
                    _this.states[index] = value;
                }
            }
        });
    };
    RNN.prototype.standardizeArgs = function (inputs, initialState, constants) {
        if (Array.isArray(inputs)) {
            if (initialState != null || constants != null) {
                throw new errors_1.ValueError('When inputs is an array, neither initialState or constants ' +
                    'should be provided');
            }
            if (this.numConstants != null) {
                constants =
                    inputs.slice(inputs.length - this.numConstants, inputs.length);
                inputs = inputs.slice(0, inputs.length - this.numConstants);
            }
            if (inputs.length > 1) {
                initialState = inputs.slice(1, inputs.length);
            }
            inputs = inputs[0];
        }
        function toListOrNull(x) {
            if (x == null || Array.isArray(x)) {
                return x;
            }
            else {
                return [x];
            }
        }
        initialState = toListOrNull(initialState);
        constants = toListOrNull(constants);
        return { inputs: inputs, initialState: initialState, constants: constants };
    };
    RNN.prototype.apply = function (inputs, kwargs) {
        var initialState = kwargs == null ? null : kwargs['initialState'];
        var constants = kwargs == null ? null : kwargs['constants'];
        if (kwargs == null) {
            kwargs = {};
        }
        var standardized = this.standardizeArgs(inputs, initialState, constants);
        inputs = standardized.inputs;
        initialState = standardized.initialState;
        constants = standardized.constants;
        var additionalInputs = [];
        var additionalSpecs = [];
        if (initialState != null) {
            kwargs['initialState'] = initialState;
            additionalInputs = additionalInputs.concat(initialState);
            this.stateSpec = [];
            for (var _i = 0, initialState_1 = initialState; _i < initialState_1.length; _i++) {
                var state = initialState_1[_i];
                this.stateSpec.push(new topology_1.InputSpec({ shape: state.shape }));
            }
            additionalSpecs = additionalSpecs.concat(this.stateSpec);
        }
        if (constants != null) {
            kwargs['constants'] = constants;
            additionalInputs = additionalInputs.concat(constants);
            this.numConstants = constants.length;
        }
        var isTensor = additionalInputs[0] instanceof types_1.SymbolicTensor;
        if (isTensor) {
            var fullInput = [inputs].concat(additionalInputs);
            var fullInputSpec = this.inputSpec.concat(additionalSpecs);
            var originalInputSpec = this.inputSpec;
            this.inputSpec = fullInputSpec;
            var output = _super.prototype.apply.call(this, fullInput, kwargs);
            this.inputSpec = originalInputSpec;
            return output;
        }
        else {
            return _super.prototype.apply.call(this, inputs, kwargs);
        }
    };
    RNN.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            inputs = generic_utils.getExactlyOneTensor(inputs);
            if (initialState == null) {
                if (_this.stateful) {
                    throw new errors_1.NotImplementedError('stateful RNN layer is not implemented yet.');
                }
                else {
                    initialState = _this.getInitialState(inputs);
                }
            }
            if (mask != null) {
                throw new errors_1.NotImplementedError('Masking is not implemented for RNN yet');
            }
            var numStates = Array.isArray(_this.cell.stateSize) ? _this.cell.stateSize.length : 1;
            if (initialState.length !== numStates) {
                throw new errors_1.ValueError("RNN Layer has " + numStates + " state(s) but was passed " +
                    (initialState.length + " initial state(s)."));
            }
            var inputShape = inputs.shape;
            var timesteps = inputShape[1];
            if (_this.unroll) {
                console.warn('Ignoring unroll = true for RNN layer, due to imperative backend.');
            }
            var cellCallKwargs = { training: training };
            var step = function (inputs, states) {
                var outputs = _this.cell.call([inputs].concat(states), cellCallKwargs);
                return [outputs[0], outputs.slice(1)];
            };
            var rnnOutputs = rnn(step, inputs, initialState, _this.goBackwards, null, null, _this.unroll, timesteps);
            var lastOutput = rnnOutputs[0];
            var outputs = rnnOutputs[1];
            var states = rnnOutputs[2];
            if (_this.stateful) {
                throw new errors_1.NotImplementedError('stateful RNN layer is not implemented yet');
            }
            var output = _this.returnSequences ? outputs : lastOutput;
            if (_this.returnState) {
                return [output].concat(states);
            }
            else {
                return output;
            }
        });
    };
    RNN.prototype.getInitialState = function (inputs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var initialState = tfc.zeros(inputs.shape);
            initialState = tfc.sum(initialState, [1, 2]);
            initialState = K.expandDims(initialState);
            if (Array.isArray(_this.cell.stateSize)) {
                return _this.cell.stateSize.map(function (dim) { return dim > 1 ? K.tile(initialState, [1, dim]) : initialState; });
            }
            else {
                return _this.cell.stateSize > 1 ?
                    [K.tile(initialState, [1, _this.cell.stateSize])] :
                    [initialState];
            }
        });
    };
    Object.defineProperty(RNN.prototype, "trainableWeights", {
        get: function () {
            if (!this.trainable) {
                return [];
            }
            return this.cell.trainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RNN.prototype, "nonTrainableWeights", {
        get: function () {
            if (!this.trainable) {
                return this.cell.weights;
            }
            return this.cell.nonTrainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    RNN.prototype.getConfig = function () {
        var config = {
            returnSequences: this.returnSequences,
            returnState: this.returnState,
            goBackwards: this.goBackwards,
            stateful: this.stateful,
            unroll: this.unroll,
        };
        if (this.numConstants != null) {
            config.numConstants = this.numConstants;
        }
        var cellConfig = this.cell.getConfig();
        config.cell = {
            className: this.cell.getClassName(),
            config: cellConfig,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    RNN.className = 'RNN';
    return RNN;
}(topology_2.Layer));
exports.RNN = RNN;
tfjs_core_1.serialization.SerializationMap.register(RNN);
var RNNCell = (function (_super) {
    __extends(RNNCell, _super);
    function RNNCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RNNCell = __decorate([
        tfjs_core_1.doc({ heading: 'Layers', subheading: 'Classes' })
    ], RNNCell);
    return RNNCell;
}(topology_2.Layer));
exports.RNNCell = RNNCell;
var SimpleRNNCell = (function (_super) {
    __extends(SimpleRNNCell, _super);
    function SimpleRNNCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation == null ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.stateSize = _this.units;
        return _this;
    }
    SimpleRNNCell.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        this.kernel = this.addWeight('kernel', [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    SimpleRNNCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            if (inputs.length !== 2) {
                throw new errors_1.ValueError("SimpleRNNCell expects 2 input Tensors, got " + inputs.length + ".");
            }
            var prevOutput = inputs[1];
            inputs = inputs[0];
            if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                throw new errors_1.NotImplementedError('Dropout is not implemented for SimpleRNNCell yet');
            }
            var h = K.dot(inputs, _this.kernel.read());
            if (_this.bias != null) {
                h = K.biasAdd(h, _this.bias.read());
            }
            var output = tfc.add(h, K.dot(prevOutput, _this.recurrentKernel.read()));
            if (_this.activation != null) {
                output = _this.activation.apply(output);
            }
            return [output, output];
        });
    };
    SimpleRNNCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    SimpleRNNCell.className = 'SimpleRNNCell';
    return SimpleRNNCell;
}(RNNCell));
exports.SimpleRNNCell = SimpleRNNCell;
tfjs_core_1.serialization.SerializationMap.register(SimpleRNNCell);
var SimpleRNN = (function (_super) {
    __extends(SimpleRNN, _super);
    function SimpleRNN(config) {
        var _this = this;
        config.cell = new SimpleRNNCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    SimpleRNN.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(SimpleRNN.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimpleRNN.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    SimpleRNN.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    SimpleRNN.className = 'SimpleRNN';
    return SimpleRNN;
}(RNN));
exports.SimpleRNN = SimpleRNN;
tfjs_core_1.serialization.SerializationMap.register(SimpleRNN);
var GRUCell = (function (_super) {
    __extends(GRUCell, _super);
    function GRUCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.recurrentActivation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_RECURRENT_ACTIVATION :
            config.recurrentActivation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.implementation = config.implementation;
        _this.stateSize = _this.units;
        return _this;
    }
    GRUCell.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var inputDim = inputShape[inputShape.length - 1];
        this.kernel = this.addWeight('kernel', [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
            this.bias = this.addWeight('bias', [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
    };
    GRUCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                throw new errors_1.NotImplementedError('Dropout is not implemented for GRUCell yet');
            }
            inputs = inputs;
            if (inputs.length !== 2) {
                throw new errors_1.ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got " +
                    (inputs.length + "."));
            }
            var hTMinus1 = inputs[1];
            inputs = inputs[0];
            var z;
            var r;
            var hh;
            if (_this.implementation === 1) {
                var kernelZ = K.sliceAlongLastAxis(_this.kernel.read(), 0, _this.units);
                var kernelR = K.sliceAlongLastAxis(_this.kernel.read(), _this.units, _this.units);
                var kernelH = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 2, _this.units);
                var recurrentKernelZ = K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, _this.units);
                var recurrentKernelR = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units, _this.units);
                var recurrentKernelH = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 2, _this.units);
                var inputsZ = inputs;
                var inputsR = inputs;
                var inputsH = inputs;
                var xZ = K.dot(inputsZ, kernelZ);
                var xR = K.dot(inputsR, kernelR);
                var xH = K.dot(inputsH, kernelH);
                if (_this.useBias) {
                    var biasZ = K.sliceAlongFirstAxis(_this.bias.read(), 0, _this.units);
                    var biasR = K.sliceAlongFirstAxis(_this.bias.read(), _this.units, _this.units);
                    var biasH = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 2, _this.units);
                    xZ = K.biasAdd(xZ, biasZ);
                    xR = K.biasAdd(xR, biasR);
                    xH = K.biasAdd(xH, biasH);
                }
                var hTMinus1Z = hTMinus1;
                var hTMinus1R = hTMinus1;
                var hTMinus1H = hTMinus1;
                z = _this.recurrentActivation.apply(tfc.add(xZ, K.dot(hTMinus1Z, recurrentKernelZ)));
                r = _this.recurrentActivation.apply(tfc.add(xR, K.dot(hTMinus1R, recurrentKernelR)));
                hh = _this.activation.apply(tfc.add(xH, K.dot(tfc.mul(r, hTMinus1H), recurrentKernelH)));
            }
            else {
                var matrixX = K.dot(inputs, _this.kernel.read());
                if (_this.useBias) {
                    matrixX = K.biasAdd(matrixX, _this.bias.read());
                }
                var matrixInner = K.dot(hTMinus1, K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, 2 * _this.units));
                var xZ = K.sliceAlongLastAxis(matrixX, 0, _this.units);
                var xR = K.sliceAlongLastAxis(matrixX, _this.units, _this.units);
                var recurrentZ = K.sliceAlongLastAxis(matrixInner, 0, _this.units);
                var recurrentR = K.sliceAlongLastAxis(matrixInner, _this.units, _this.units);
                z = _this.recurrentActivation.apply(tfc.add(xZ, recurrentZ));
                r = _this.recurrentActivation.apply(tfc.add(xR, recurrentR));
                var xH = K.sliceAlongLastAxis(matrixX, 2 * _this.units, _this.units);
                var recurrentH = K.dot(tfc.mul(r, hTMinus1), K.sliceAlongLastAxis(_this.recurrentKernel.read(), 2 * _this.units, _this.units));
                hh = _this.activation.apply(tfc.add(xH, recurrentH));
            }
            var h = tfc.add(tfc.mul(z, hTMinus1), tfc.mul(K.scalarPlusArray(K.getScalar(1), tfc.neg(z)), hh));
            return [h, h];
        });
    };
    GRUCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    GRUCell.className = 'GRUCell';
    return GRUCell;
}(RNNCell));
exports.GRUCell = GRUCell;
tfjs_core_1.serialization.SerializationMap.register(GRUCell);
var GRU = (function (_super) {
    __extends(GRU, _super);
    function GRU(config) {
        var _this = this;
        if (config.implementation === 0) {
            console.warn('`implementation=0` has been deprecated, and now defaults to ' +
                '`implementation=1`. Please update your layer call.');
        }
        config.cell = new GRUCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    GRU.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(GRU.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GRU.prototype, "implementation", {
        get: function () {
            return this.cell.implementation;
        },
        enumerable: true,
        configurable: true
    });
    GRU.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    GRU.fromConfig = function (cls, config) {
        if (config['implmentation'] === 0) {
            config['implementation'] = 1;
        }
        return new cls(config);
    };
    GRU.className = 'GRU';
    return GRU;
}(RNN));
exports.GRU = GRU;
tfjs_core_1.serialization.SerializationMap.register(GRU);
var LSTMCell = (function (_super) {
    __extends(LSTMCell, _super);
    function LSTMCell(config) {
        var _this = _super.call(this, config) || this;
        _this.DEFAULT_ACTIVATION = 'tanh';
        _this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';
        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';
        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';
        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';
        _this.units = config.units;
        _this.activation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_ACTIVATION :
            config.activation);
        _this.recurrentActivation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_RECURRENT_ACTIVATION :
            config.recurrentActivation);
        _this.useBias = config.useBias == null ? true : config.useBias;
        _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
        _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
        _this.biasInitializer =
            initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
        _this.unitForgetBias = config.unitForgetBias;
        _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
        _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
        _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
        _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
        _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
        _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
        _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
        _this.recurrentDropout = math_utils.min([
            1,
            math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])
        ]);
        _this.implementation = config.implementation;
        _this.stateSize = [_this.units, _this.units];
        return _this;
    }
    LSTMCell.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var inputDim = inputShape[inputShape.length - 1];
        this.kernel = this.addWeight('kernel', [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        var biasInitializer;
        if (this.useBias) {
            if (this.unitForgetBias) {
                var capturedBiasInit_1 = this.biasInitializer;
                var capturedUnits_1 = this.units;
                biasInitializer = new (_a = (function (_super) {
                        __extends(CustomInit, _super);
                        function CustomInit() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        CustomInit.prototype.apply = function (shape, dtype) {
                            var bI = capturedBiasInit_1.apply([capturedUnits_1]);
                            var bF = (new initializers_1.Ones()).apply([capturedUnits_1]);
                            var bCAndH = capturedBiasInit_1.apply([capturedUnits_1 * 2]);
                            return K.concatAlongFirstAxis(K.concatAlongFirstAxis(bI, bF), bCAndH);
                        };
                        return CustomInit;
                    }(initializers_1.Initializer)),
                    _a.className = 'CustomInit',
                    _a)();
            }
            else {
                biasInitializer = this.biasInitializer;
            }
            this.bias = this.addWeight('bias', [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        else {
            this.bias = null;
        }
        this.built = true;
        var _a;
    };
    LSTMCell.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                throw new errors_1.NotImplementedError('Dropout is not implemented for LSTMCell yet');
            }
            inputs = inputs;
            if (inputs.length !== 3) {
                throw new errors_1.ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got " +
                    (inputs.length + "."));
            }
            var hTMinus1 = inputs[1];
            var cTMinus1 = inputs[2];
            inputs = inputs[0];
            var i;
            var f;
            var c;
            var o;
            if (_this.implementation === 1) {
                var kernelI = K.sliceAlongLastAxis(_this.kernel.read(), 0, _this.units);
                var kernelF = K.sliceAlongLastAxis(_this.kernel.read(), _this.units, _this.units);
                var kernelC = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 2, _this.units);
                var kernelO = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 3, _this.units);
                var recurrentKernelI = K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, _this.units);
                var recurrentKernelF = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units, _this.units);
                var recurrentKernelC = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 2, _this.units);
                var recurrentKernelO = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 3, _this.units);
                var inputsI = inputs;
                var inputsF = inputs;
                var inputsC = inputs;
                var inputsO = inputs;
                var xI = K.dot(inputsI, kernelI);
                var xF = K.dot(inputsF, kernelF);
                var xC = K.dot(inputsC, kernelC);
                var xO = K.dot(inputsO, kernelO);
                if (_this.useBias) {
                    var biasI = K.sliceAlongFirstAxis(_this.bias.read(), 0, _this.units);
                    var biasF = K.sliceAlongFirstAxis(_this.bias.read(), _this.units, _this.units);
                    var biasC = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 2, _this.units);
                    var biasO = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 3, _this.units);
                    xI = K.biasAdd(xI, biasI);
                    xF = K.biasAdd(xF, biasF);
                    xC = K.biasAdd(xC, biasC);
                    xO = K.biasAdd(xO, biasO);
                }
                var hTMinus1I = hTMinus1;
                var hTMinus1F = hTMinus1;
                var hTMinus1C = hTMinus1;
                var hTMinus1O = hTMinus1;
                i = _this.recurrentActivation.apply(tfc.add(xI, K.dot(hTMinus1I, recurrentKernelI)));
                f = _this.recurrentActivation.apply(tfc.add(xF, K.dot(hTMinus1F, recurrentKernelF)));
                c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(tfc.add(xC, K.dot(hTMinus1C, recurrentKernelC)))));
                o = _this.recurrentActivation.apply(tfc.add(xO, K.dot(hTMinus1O, recurrentKernelO)));
            }
            else {
                var z = K.dot(inputs, _this.kernel.read());
                z = tfc.add(z, K.dot(hTMinus1, _this.recurrentKernel.read()));
                if (_this.useBias) {
                    z = K.biasAdd(z, _this.bias.read());
                }
                var z0 = K.sliceAlongLastAxis(z, 0, _this.units);
                var z1 = K.sliceAlongLastAxis(z, _this.units, _this.units);
                var z2 = K.sliceAlongLastAxis(z, _this.units * 2, _this.units);
                var z3 = K.sliceAlongLastAxis(z, _this.units * 3, _this.units);
                i = _this.recurrentActivation.apply(z0);
                f = _this.recurrentActivation.apply(z1);
                c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(z2)));
                o = _this.recurrentActivation.apply(z3);
            }
            var h = tfc.mul(o, _this.activation.apply(c));
            return [h, h, c];
        });
    };
    LSTMCell.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            unitForgetBias: this.unitForgetBias,
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    LSTMCell.className = 'LSTMCell';
    return LSTMCell;
}(RNNCell));
exports.LSTMCell = LSTMCell;
tfjs_core_1.serialization.SerializationMap.register(LSTMCell);
var LSTM = (function (_super) {
    __extends(LSTM, _super);
    function LSTM(config) {
        var _this = this;
        if (config.implementation === 0) {
            console.warn('`implementation=0` has been deprecated, and now defaults to ' +
                '`implementation=1`. Please update your layer call.');
        }
        config.cell = new LSTMCell(config);
        _this = _super.call(this, config) || this;
        return _this;
    }
    LSTM.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var mask = kwargs == null ? null : kwargs['mask'];
            var training = kwargs == null ? null : kwargs['training'];
            var initialState = kwargs == null ? null : kwargs['initialState'];
            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });
        });
    };
    Object.defineProperty(LSTM.prototype, "units", {
        get: function () {
            return this.cell.units;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "activation", {
        get: function () {
            return this.cell.activation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "useBias", {
        get: function () {
            return this.cell.useBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelInitializer", {
        get: function () {
            return this.cell.kernelInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentInitializer", {
        get: function () {
            return this.cell.recurrentInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasInitializer", {
        get: function () {
            return this.cell.biasInitializer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "unitForgetBias", {
        get: function () {
            return this.cell.unitForgetBias;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelRegularizer", {
        get: function () {
            return this.cell.kernelRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentRegularizer", {
        get: function () {
            return this.cell.recurrentRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasRegularizer", {
        get: function () {
            return this.cell.biasRegularizer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "kernelConstraint", {
        get: function () {
            return this.cell.kernelConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentConstraint", {
        get: function () {
            return this.cell.recurrentConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "biasConstraint", {
        get: function () {
            return this.cell.biasConstraint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "dropout", {
        get: function () {
            return this.cell.dropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "recurrentDropout", {
        get: function () {
            return this.cell.recurrentDropout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LSTM.prototype, "implementation", {
        get: function () {
            return this.cell.implementation;
        },
        enumerable: true,
        configurable: true
    });
    LSTM.prototype.getConfig = function () {
        var config = {
            units: this.units,
            activation: activations_1.serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
            unitForgetBias: this.unitForgetBias,
            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        delete baseConfig['cell'];
        Object.assign(config, baseConfig);
        return config;
    };
    LSTM.fromConfig = function (cls, config) {
        if (config['implmentation'] === 0) {
            config['implementation'] = 1;
        }
        return new cls(config);
    };
    LSTM.className = 'LSTM';
    return LSTM;
}(RNN));
exports.LSTM = LSTM;
tfjs_core_1.serialization.SerializationMap.register(LSTM);
var StackedRNNCells = (function (_super) {
    __extends(StackedRNNCells, _super);
    function StackedRNNCells(config) {
        var _this = _super.call(this, config) || this;
        _this.cells = config.cells;
        return _this;
    }
    Object.defineProperty(StackedRNNCells.prototype, "stateSize", {
        get: function () {
            var stateSize = [];
            for (var _i = 0, _a = this.cells.slice().reverse(); _i < _a.length; _i++) {
                var cell = _a[_i];
                if (Array.isArray(cell.stateSize)) {
                    stateSize.push.apply(stateSize, cell.stateSize);
                }
                else {
                    stateSize.push(cell.stateSize);
                }
            }
            return stateSize;
        },
        enumerable: true,
        configurable: true
    });
    StackedRNNCells.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = inputs;
            var states = inputs.slice(1);
            var nestedStates = [];
            for (var _i = 0, _a = _this.cells.slice().reverse(); _i < _a.length; _i++) {
                var cell = _a[_i];
                if (Array.isArray(cell.stateSize)) {
                    nestedStates.push(states.splice(0, cell.stateSize.length));
                }
                else {
                    nestedStates.push(states.splice(0, 1));
                }
            }
            nestedStates.reverse();
            var newNestedStates = [];
            var callInputs;
            for (var i = 0; i < _this.cells.length; ++i) {
                var cell = _this.cells[i];
                states = nestedStates[i];
                if (i === 0) {
                    callInputs = [inputs[0]].concat(states);
                }
                else {
                    callInputs = [callInputs[0]].concat(states);
                }
                callInputs = cell.call(callInputs, kwargs);
                newNestedStates.push(callInputs.slice(1));
            }
            states = [];
            for (var _b = 0, _c = newNestedStates.slice().reverse(); _b < _c.length; _b++) {
                var cellStates = _c[_b];
                states.push.apply(states, cellStates);
            }
            return [callInputs[0]].concat(states);
        });
    };
    StackedRNNCells.prototype.build = function (inputShape) {
        if (generic_utils.isArrayOfShapes(inputShape)) {
            inputShape = inputShape[0];
        }
        inputShape = inputShape;
        var outputDim;
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            cell.build(inputShape);
            if (Array.isArray(cell.stateSize)) {
                outputDim = cell.stateSize[0];
            }
            else {
                outputDim = cell.stateSize;
            }
            inputShape = [inputShape[0], outputDim];
        }
        this.built = true;
    };
    StackedRNNCells.prototype.getConfig = function () {
        var cellConfigs = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            cellConfigs.push({
                'className': this.getClassName(),
                'config': cell.getConfig(),
            });
        }
        var config = { 'cells': cellConfigs };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    StackedRNNCells.fromConfig = function (cls, config, customObjects) {
        if (customObjects === void 0) { customObjects = {}; }
        var cells = [];
        for (var _i = 0, _a = config['cells']; _i < _a.length; _i++) {
            var cellConfig = _a[_i];
            cells.push(serialization_1.deserialize(cellConfig, customObjects));
        }
        return new cls({ cells: cells });
    };
    Object.defineProperty(StackedRNNCells.prototype, "trainableWeights", {
        get: function () {
            if (!this.trainable) {
                return [];
            }
            var weights = [];
            for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                var cell = _a[_i];
                weights.push.apply(weights, cell.trainableWeights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackedRNNCells.prototype, "nonTrainableWeights", {
        get: function () {
            var weights = [];
            for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                var cell = _a[_i];
                weights.push.apply(weights, cell.nonTrainableWeights);
            }
            if (!this.trainable) {
                var trainableWeights = [];
                for (var _b = 0, _c = this.cells; _b < _c.length; _b++) {
                    var cell = _c[_b];
                    trainableWeights.push.apply(trainableWeights, cell.trainableWeights);
                }
                return trainableWeights.concat(weights);
            }
            return weights;
        },
        enumerable: true,
        configurable: true
    });
    StackedRNNCells.prototype.getWeights = function () {
        var weights = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            weights.push.apply(weights, cell.weights);
        }
        return variables_1.batchGetValue(weights);
    };
    StackedRNNCells.prototype.setWeights = function (weights) {
        var tuples = [];
        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
            var cell = _a[_i];
            var numParams = cell.weights.length;
            var inputWeights = weights.splice(numParams);
            for (var i = 0; i < cell.weights.length; ++i) {
                tuples.push([cell.weights[i], inputWeights[i]]);
            }
        }
        variables_1.batchSetValue(tuples);
    };
    StackedRNNCells.className = 'StackedRNNCells';
    return StackedRNNCells;
}(RNNCell));
exports.StackedRNNCells = StackedRNNCells;
tfjs_core_1.serialization.SerializationMap.register(StackedRNNCells);

},{"../activations":158,"../backend/tfjs_backend":160,"../constraints":163,"../engine/topology":165,"../errors":167,"../initializers":170,"../regularizers":187,"../types":188,"../utils/generic_utils":190,"../utils/math_utils":191,"../variables":193,"./serialization":181,"@tensorflow/tfjs-core":51}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var generic_utils_1 = require("../utils/generic_utils");
function deserialize(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'layer');
}
exports.deserialize = deserialize;

},{"../utils/generic_utils":190,"@tensorflow/tfjs-core":51}],182:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("../backend/tfjs_backend");
var topology_1 = require("../engine/topology");
var errors_1 = require("../errors");
var generic_utils = require("../utils/generic_utils");
var recurrent_1 = require("./recurrent");
var serialization_1 = require("./serialization");
var Wrapper = (function (_super) {
    __extends(Wrapper, _super);
    function Wrapper(config) {
        var _this = _super.call(this, config) || this;
        _this.layer = config.layer;
        return _this;
    }
    Wrapper.prototype.build = function (inputShape) {
        this.built = true;
    };
    Object.defineProperty(Wrapper.prototype, "trainable", {
        get: function () {
            if (this.layer != null) {
                return this.layer.trainable;
            }
            else {
                return false;
            }
        },
        set: function (value) {
            if (this.layer != null) {
                this.layer.trainable = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "trainableWeights", {
        get: function () {
            return this.layer.trainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "nonTrainableWeights", {
        get: function () {
            return this.layer.nonTrainableWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "updates", {
        get: function () {
            return this.layer._updates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wrapper.prototype, "losses", {
        get: function () {
            return this.layer.losses;
        },
        enumerable: true,
        configurable: true
    });
    Wrapper.prototype.getWeights = function () {
        return this.layer.getWeights();
    };
    Wrapper.prototype.setWeights = function (weights) {
        this.layer.setWeights(weights);
    };
    Wrapper.prototype.getConfig = function () {
        var config = {
            'layer': {
                'className': this.layer.getClassName(),
                'config': this.layer.getConfig(),
            }
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Wrapper.fromConfig = function (cls, config, customObjects) {
        if (customObjects === void 0) { customObjects = {}; }
        var layerConfig = config['layer'];
        var layer = serialization_1.deserialize(layerConfig, customObjects);
        delete config['layer'];
        var newConfig = { layer: layer };
        Object.assign(newConfig, config);
        return new cls(newConfig);
    };
    return Wrapper;
}(topology_1.Layer));
exports.Wrapper = Wrapper;
var TimeDistributed = (function (_super) {
    __extends(TimeDistributed, _super);
    function TimeDistributed(config) {
        var _this = _super.call(this, config) || this;
        _this.supportsMasking = true;
        return _this;
    }
    TimeDistributed.prototype.build = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        if (inputShape.length < 3) {
            throw new errors_1.ValueError("TimeDistributed layer expects an input shape >= 3D, but received " +
                ("input shape " + JSON.stringify(inputShape)));
        }
        this.inputSpec = [{ shape: inputShape }];
        var childInputShape = [inputShape[0]].concat(inputShape.slice(2));
        if (!this.layer.built) {
            this.layer.build(childInputShape);
            this.layer.built = true;
        }
        _super.prototype.build.call(this, inputShape);
    };
    TimeDistributed.prototype.computeOutputShape = function (inputShape) {
        inputShape = generic_utils.getExactlyOneShape(inputShape);
        var childInputShape = [inputShape[0]].concat(inputShape.slice(2));
        var childOutputShape = this.layer.computeOutputShape(childInputShape);
        var timesteps = inputShape[1];
        return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));
    };
    TimeDistributed.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            inputs = generic_utils.getExactlyOneTensor(inputs);
            var step = function (inputs, states) {
                var output = _this.layer.call(inputs, kwargs);
                return [output, []];
            };
            var rnnOutputs = recurrent_1.rnn(step, inputs, [], false, null, null, false, inputs.shape[1]);
            var y = rnnOutputs[1];
            return y;
        });
    };
    TimeDistributed.className = 'TimeDistributed';
    return TimeDistributed;
}(Wrapper));
exports.TimeDistributed = TimeDistributed;
tfjs_core_1.serialization.SerializationMap.register(TimeDistributed);
exports.VALID_BIDIRECTIONAL_MERGE_MODES = ['sum', 'mul', 'concat', 'ave'];
function checkBidirectionalMergeMode(value) {
    generic_utils.checkStringTypeUnionValue(exports.VALID_BIDIRECTIONAL_MERGE_MODES, 'BidirectionalMergeMode', value);
}
exports.checkBidirectionalMergeMode = checkBidirectionalMergeMode;
var Bidirectional = (function (_super) {
    __extends(Bidirectional, _super);
    function Bidirectional(config) {
        var _this = _super.call(this, config) || this;
        var layerConfig = config.layer.getConfig();
        _this.forwardLayer =
            serialization_1.deserialize({ className: config.layer.getClassName(), config: layerConfig });
        layerConfig['goBackwards'] =
            layerConfig['goBackwards'] === true ? false : true;
        _this.backwardLayer =
            serialization_1.deserialize({ className: config.layer.getClassName(), config: layerConfig });
        _this.forwardLayer.name = 'forward_' + _this.forwardLayer.name;
        _this.backwardLayer.name = 'backward_' + _this.backwardLayer.name;
        checkBidirectionalMergeMode(config.mergeMode);
        _this.mergeMode = config.mergeMode;
        if (config.weights) {
            throw new errors_1.NotImplementedError('weights support is not implemented for Bidirectional layer yet.');
        }
        _this._stateful = config.layer.stateful;
        _this.returnSequences = config.layer.returnSequences;
        _this.returnState = config.layer.returnState;
        _this.supportsMasking = true;
        _this._trainable = true;
        _this.inputSpec = config.layer.inputSpec;
        return _this;
    }
    Object.defineProperty(Bidirectional.prototype, "trainable", {
        get: function () {
            return this._trainable;
        },
        set: function (value) {
            this._trainable = value;
            if (this.forwardLayer != null) {
                this.forwardLayer.trainable = value;
            }
            if (this.backwardLayer != null) {
                this.backwardLayer.trainable = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Bidirectional.prototype.getWeights = function () {
        return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    };
    Bidirectional.prototype.setWeights = function (weights) {
        var numWeights = weights.length;
        var numeightsOver2 = Math.floor(numWeights / 2);
        this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));
        this.backwardLayer.setWeights(weights.slice(numeightsOver2));
    };
    Bidirectional.prototype.computeOutputShape = function (inputShape) {
        var layerShapes = this.forwardLayer.computeOutputShape(inputShape);
        if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {
            layerShapes = [layerShapes];
        }
        layerShapes = layerShapes;
        var outputShape;
        var outputShapes;
        var stateShape;
        if (this.returnState) {
            stateShape = layerShapes.slice(1);
            outputShape = layerShapes[0];
        }
        else {
            outputShape = layerShapes[0];
        }
        outputShape = outputShape;
        if (this.mergeMode === 'concat') {
            outputShape[outputShape.length - 1] *= 2;
            outputShapes = [outputShape];
        }
        else if (this.mergeMode == null) {
            outputShapes = [outputShape, outputShape.slice()];
        }
        else {
            outputShapes = [outputShape];
        }
        if (this.returnState) {
            if (this.mergeMode == null) {
                return outputShapes.concat(stateShape).concat(stateShape.slice());
            }
            return [outputShape].concat(stateShape).concat(stateShape.slice());
        }
        return generic_utils.singletonOrArray(outputShapes);
    };
    Bidirectional.prototype.apply = function (inputs, kwargs) {
        var initialState = null;
        if (kwargs != null) {
            initialState = kwargs['initialState'];
        }
        if (Array.isArray(inputs)) {
            initialState = inputs.slice(1);
            inputs = inputs[0];
        }
        if (initialState == null || initialState.length === 0) {
            var applyOutputs = _super.prototype.apply.call(this, inputs, kwargs);
            return applyOutputs;
        }
        else {
            throw new errors_1.NotImplementedError('The support for initial states is not implemented for ' +
                'Bidirectional layers yet.');
        }
    };
    Bidirectional.prototype.call = function (inputs, kwargs) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            if (kwargs['mask'] != null) {
                throw new errors_1.NotImplementedError('The support for masking is not implemented for ' +
                    'Bidirectional layers yet.');
            }
            if (kwargs['initialState'] != null) {
                throw new errors_1.NotImplementedError('The support for initial states is not implemented for ' +
                    'Bidirectional layers yet.');
            }
            var y = _this.forwardLayer.call(inputs, kwargs);
            var yRev = _this.backwardLayer.call(inputs, kwargs);
            var states;
            if (_this.returnState) {
                if (Array.isArray(y)) {
                    states = y.slice(1).concat(yRev.slice(1));
                }
                else {
                }
                y = y[0];
                yRev = yRev[0];
            }
            if (_this.returnSequences) {
                yRev = tfc.reverse(yRev, 1);
            }
            var output;
            if (_this.mergeMode === 'concat') {
                output = K.concatenate([y, yRev]);
            }
            else if (_this.mergeMode === 'sum') {
                output = tfc.add(y, yRev);
            }
            else if (_this.mergeMode === 'ave') {
                output = K.scalarTimesArray(K.getScalar(0.5), tfc.add(y, yRev));
            }
            else if (_this.mergeMode === 'mul') {
                output = tfc.mul(y, yRev);
            }
            else if (_this.mergeMode == null) {
                output = [y, yRev];
            }
            if (_this.returnState) {
                if (_this.mergeMode == null) {
                    return output.concat(states);
                }
                return [output].concat(states);
            }
            return output;
        });
    };
    Bidirectional.prototype.resetStates = function (states) {
        this.forwardLayer.resetStates();
        this.backwardLayer.resetStates();
    };
    Bidirectional.prototype.build = function (inputShape) {
        var _this = this;
        K.nameScope(this.forwardLayer.name, function () {
            _this.forwardLayer.build(inputShape);
        });
        K.nameScope(this.backwardLayer.name, function () {
            _this.backwardLayer.build(inputShape);
        });
        this.built = true;
    };
    Object.defineProperty(Bidirectional.prototype, "trainableWeights", {
        get: function () {
            return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bidirectional.prototype, "nonTrainableWeights", {
        get: function () {
            return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
        },
        enumerable: true,
        configurable: true
    });
    Bidirectional.prototype.getConfig = function () {
        var config = {
            'mergeMode': this.mergeMode,
        };
        var baseConfig = _super.prototype.getConfig.call(this);
        Object.assign(config, baseConfig);
        return config;
    };
    Bidirectional.fromConfig = function (cls, config) {
        var rnnLayer = serialization_1.deserialize(config['layer']);
        delete config['layer'];
        if (config['numConstants'] != null) {
            throw new errors_1.NotImplementedError("Deserialization of a Bidirectional layer with numConstants " +
                "present is not supported yet.");
        }
        var newConfig = config;
        newConfig['layer'] = rnnLayer;
        return new cls(newConfig);
    };
    Bidirectional.className = 'Bidirectional';
    return Bidirectional;
}(Wrapper));
exports.Bidirectional = Bidirectional;
tfjs_core_1.serialization.SerializationMap.register(Bidirectional);

},{"../backend/tfjs_backend":160,"../engine/topology":165,"../errors":167,"../utils/generic_utils":190,"./recurrent":180,"./serialization":181,"@tensorflow/tfjs-core":51}],183:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var errors_1 = require("./errors");
function l2Normalize(x, axis) {
    return tfjs_core_1.tidy(function () {
        var squareSum = tfc.sum(K.square(x), axis, true);
        var epsilonTensor = K.scalarTimesArray(tfjs_core_1.scalar(K.epsilon()), tfc.onesLike(x));
        var norm = tfc.sqrt(tfc.maximum(squareSum, epsilonTensor));
        return tfc.div(x, norm);
    });
}
exports.l2Normalize = l2Normalize;
function meanSquaredError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return tfc.mean(K.square(tfc.sub(yPred, yTrue)), -1); });
}
exports.meanSquaredError = meanSquaredError;
function meanAbsoluteError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return tfc.mean(tfc.abs(tfc.sub(yPred, yTrue)), -1); });
}
exports.meanAbsoluteError = meanAbsoluteError;
function meanAbsolutePercentageError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var diff = tfc.sub(yTrue, yPred);
        var clippedTrue = tfc.clipByValue(tfc.abs(yTrue), K.epsilon(), Number.MAX_VALUE);
        var absResult = tfc.abs(tfc.div(diff, clippedTrue));
        return K.scalarTimesArray(K.getScalar(100.0), tfc.mean(absResult, -1));
    });
}
exports.meanAbsolutePercentageError = meanAbsolutePercentageError;
function meanSquaredLogarithmicError(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var one = K.getScalar(1.0);
        var clippedPred = tfc.clipByValue(yPred, K.epsilon(), Number.MAX_VALUE);
        var firstLog = tfc.log(K.scalarPlusArray(one, clippedPred));
        var clippedTrue = tfc.clipByValue(yTrue, K.epsilon(), Number.MAX_VALUE);
        var secondLog = tfc.log(K.scalarPlusArray(one, clippedTrue));
        return tfc.mean(K.square(tfc.sub(firstLog, secondLog)), -1);
    });
}
exports.meanSquaredLogarithmicError = meanSquaredLogarithmicError;
function squaredHinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = K.getScalar(0.0);
        var one = K.getScalar(1.0);
        var maxResult = tfc.maximum(zeroTensor, tfc.sub(one, tfc.mul(yTrue, yPred)));
        return tfc.mean(K.square(maxResult), -1);
    });
}
exports.squaredHinge = squaredHinge;
function hinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = K.getScalar(0.0);
        var one = K.getScalar(1.0);
        var maxResult = tfc.maximum(zeroTensor, tfc.sub(one, tfc.mul(yTrue, yPred)));
        return tfc.mean(maxResult, -1);
    });
}
exports.hinge = hinge;
function categoricalHinge(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var zeroTensor = K.getScalar(0.0);
        var one = K.getScalar(1.0);
        var pos = tfc.sum(tfc.mul(yTrue, yPred), -1);
        var neg = tfc.max(tfc.mul(tfc.sub(one, yTrue), yPred), -1);
        return tfc.maximum(zeroTensor, K.scalarPlusArray(one, tfc.sub(neg, pos)));
    });
}
exports.categoricalHinge = categoricalHinge;
function logcosh(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var log2 = K.getScalar(Math.log(2.0));
        var predictionDiff = tfc.sub(yPred, yTrue);
        var logcoshResult = tfc.sub(tfc.add(predictionDiff, tfc.softplus(K.scalarTimesArray(K.getScalar(-2.0), predictionDiff))), log2);
        return tfc.mean(logcoshResult, -1);
    });
}
exports.logcosh = logcosh;
function categoricalCrossentropy(target, output, fromLogits) {
    if (fromLogits === void 0) { fromLogits = false; }
    return tfjs_core_1.tidy(function () {
        if (fromLogits) {
            output = tfc.softmax(output);
        }
        else {
            var outputSum = tfc.sum(output, K.shape(output).length - 1, true);
            output = tfc.div(output, outputSum);
        }
        output = tfc.clipByValue(output, K.epsilon(), 1 - K.epsilon());
        return tfc.neg(tfc.sum(tfc.mul(target.toFloat(), tfc.log(output)), K.shape(output).length - 1));
    });
}
exports.categoricalCrossentropy = categoricalCrossentropy;
function sparseCategoricalCrossentropy(target, output, fromLogits) {
    if (fromLogits === void 0) { fromLogits = false; }
    return tfjs_core_1.tidy(function () {
        var flatTarget = tfc.floor(K.flatten(target)).toInt();
        var outputShape = K.shape(output);
        var oneHotTarget = tfc.oneHot(flatTarget, outputShape[outputShape.length - 1])
            .reshape(outputShape);
        return categoricalCrossentropy(oneHotTarget, output, fromLogits);
    });
}
exports.sparseCategoricalCrossentropy = sparseCategoricalCrossentropy;
function sigmoidCrossEntropyWithLogits(target, output) {
    return tfjs_core_1.tidy(function () {
        var maxOutput = tfc.maximum(output, tfc.zerosLike(output));
        var outputXTarget = tfc.mul(output, target);
        var sigmoidOutput = tfc.log(tfc.add(K.getScalar(1), tfc.exp(tfc.neg(tfc.abs(output)))));
        var result = tfc.add(tfc.sub(maxOutput, outputXTarget), sigmoidOutput);
        return result;
    });
}
exports.sigmoidCrossEntropyWithLogits = sigmoidCrossEntropyWithLogits;
function binaryCrossentropy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var y;
        y = tfc.clipByValue(yPred, K.epsilon(), 1 - K.epsilon());
        y = tfc.log(tfc.div(y, tfc.sub(tfc.onesLike(y), y)));
        return tfc.mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1);
    });
}
exports.binaryCrossentropy = binaryCrossentropy;
function kullbackLeiblerDivergence(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var clippedTrue = tfc.clipByValue(yTrue, K.epsilon(), 1);
        var clippedPred = tfc.clipByValue(yPred, K.epsilon(), 1);
        return tfc.sum(tfc.mul(yTrue, tfc.log(tfc.div(clippedTrue, clippedPred))), -1);
    });
}
exports.kullbackLeiblerDivergence = kullbackLeiblerDivergence;
function poisson(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var logPred = tfc.log(K.scalarPlusArray(K.getScalar(K.epsilon()), yPred));
        return tfc.mean(tfc.sub(yPred, tfc.mul(yTrue, logPred)), -1);
    });
}
exports.poisson = poisson;
function cosineProximity(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var trueNormalized = l2Normalize(yTrue, -1);
        var predNormalized = l2Normalize(yPred, -1);
        var trueXPred = tfc.mul(trueNormalized, predNormalized);
        return tfc.neg(tfc.sum(trueXPred, -1));
    });
}
exports.cosineProximity = cosineProximity;
exports.mse = meanSquaredError;
exports.MSE = meanSquaredError;
exports.mae = meanAbsoluteError;
exports.MAE = meanAbsoluteError;
exports.mape = meanAbsolutePercentageError;
exports.MAPE = meanAbsolutePercentageError;
exports.msle = meanSquaredLogarithmicError;
exports.MSLE = meanSquaredLogarithmicError;
exports.kld = kullbackLeiblerDivergence;
exports.KLD = kullbackLeiblerDivergence;
exports.cosine = cosineProximity;
function get(identifierOrFn) {
    var lossesMap = {
        meanSquaredError: meanSquaredError,
        meanAbsoluteError: meanAbsoluteError,
        meanAbsolutePercentageError: meanAbsolutePercentageError,
        meanSquaredLogarithmicError: meanSquaredLogarithmicError,
        squaredHinge: squaredHinge,
        hinge: hinge,
        categoricalHinge: categoricalHinge,
        logcosh: logcosh,
        categoricalCrossentropy: categoricalCrossentropy,
        sparseCategoricalCrossentropy: sparseCategoricalCrossentropy,
        binaryCrossentropy: binaryCrossentropy,
        kullbackLeiblerDivergence: kullbackLeiblerDivergence,
        poisson: poisson,
        cosineProximity: cosineProximity
    };
    if (typeof identifierOrFn === 'string') {
        if (identifierOrFn in lossesMap) {
            return lossesMap[identifierOrFn];
        }
        throw new errors_1.ValueError("Unknown loss " + identifierOrFn);
    }
    else {
        return identifierOrFn;
    }
}
exports.get = get;

},{"./backend/tfjs_backend":160,"./errors":167,"@tensorflow/tfjs-core":51}],184:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var errors_1 = require("./errors");
var losses_1 = require("./losses");
var losses_2 = require("./losses");
function binaryAccuracy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () {
        var threshold = K.scalarTimesArray(K.getScalar(0.5), tfc.onesLike(yPred));
        var yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);
        return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);
    });
}
exports.binaryAccuracy = binaryAccuracy;
function categoricalAccuracy(yTrue, yPred) {
    return tfjs_core_1.tidy(function () { return K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'); });
}
exports.categoricalAccuracy = categoricalAccuracy;
function binaryCrossentropy(yTrue, yPred) {
    return losses_2.binaryCrossentropy(yTrue, yPred);
}
exports.binaryCrossentropy = binaryCrossentropy;
function sparseCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.sparseCategoricalAccuracy = sparseCategoricalAccuracy;
function topKCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.topKCategoricalAccuracy = topKCategoricalAccuracy;
function sparseTopKCategoricalAccuracy(yTrue, yPred) {
    throw new errors_1.NotImplementedError();
}
exports.sparseTopKCategoricalAccuracy = sparseTopKCategoricalAccuracy;
exports.mse = losses_1.meanSquaredError;
exports.MSE = losses_1.meanSquaredError;
exports.mae = losses_1.meanAbsoluteError;
exports.MAE = losses_1.meanAbsoluteError;
exports.mape = losses_1.meanAbsolutePercentageError;
exports.MAPE = losses_1.meanAbsolutePercentageError;
exports.categoricalCrossentropy = losses_1.categoricalCrossentropy;
exports.cosine = losses_1.cosineProximity;
exports.sparseCategoricalCrossentropy = losses_1.sparseCategoricalCrossentropy;
function get(identifier) {
    var metricsMap = {
        binaryAccuracy: binaryAccuracy,
        categoricalAccuracy: categoricalAccuracy,
        categoricalCrossentropy: exports.categoricalCrossentropy,
        sparseCategoricalCrossentropy: exports.sparseCategoricalCrossentropy,
        mse: exports.mse,
        MSE: exports.MSE,
        mae: exports.mae,
        MAE: exports.MAE,
        mape: exports.mape,
        MAPE: exports.MAPE,
        cosine: exports.cosine,
    };
    if (typeof identifier === 'string' && identifier in metricsMap) {
        return metricsMap[identifier];
    }
    else if (typeof identifier !== 'string' && identifier != null) {
        return identifier;
    }
    else {
        throw new errors_1.ValueError("Unknown metric " + identifier);
    }
}
exports.get = get;

},{"./backend/tfjs_backend":160,"./errors":167,"./losses":183,"@tensorflow/tfjs-core":51}],185:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var topology_1 = require("./engine/topology");
var training_1 = require("./engine/training");
var errors_1 = require("./errors");
var serialization_1 = require("./layers/serialization");
var generic_utils = require("./utils/generic_utils");
var serialization_utils_1 = require("./utils/serialization_utils");
function modelFromJSON(modelAndWeightsConfig, customObjects) {
    return __awaiter(this, void 0, void 0, function () {
        var modelTopology, tsConfig, model, weightValues, uniqueWeightValues, _i, _a, weight, skipMismatches, isNamedTensorMap;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    modelTopology = modelAndWeightsConfig.modelTopology;
                    if (modelTopology['model_config'] != null) {
                        modelTopology = modelTopology['model_config'];
                    }
                    tsConfig = serialization_utils_1.convertPythonicToTs(modelTopology);
                    model = serialization_1.deserialize(tsConfig, customObjects);
                    if (!(modelAndWeightsConfig.weightsManifest != null)) return [3, 2];
                    return [4, tfjs_core_1.io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(function (weight) { return weight.originalName; }))];
                case 1:
                    weightValues = _b.sent();
                    uniqueWeightValues = {};
                    for (_i = 0, _a = model.weights; _i < _a.length; _i++) {
                        weight = _a[_i];
                        uniqueWeightValues[weight.originalName] =
                            weightValues[weight.originalName];
                    }
                    skipMismatches = null;
                    isNamedTensorMap = true;
                    model.loadWeights(uniqueWeightValues, skipMismatches, isNamedTensorMap);
                    _b.label = 2;
                case 2: return [2, model];
            }
        });
    });
}
exports.modelFromJSON = modelFromJSON;
function loadModelInternal(pathOrIOHandler) {
    return __awaiter(this, void 0, void 0, function () {
        var handlers;
        return __generator(this, function (_a) {
            if (typeof pathOrIOHandler === 'string') {
                handlers = tfjs_core_1.io.getLoadHandlers(pathOrIOHandler);
                if (handlers.length === 0) {
                    handlers.push(tfjs_core_1.io.browserHTTPRequest(pathOrIOHandler));
                }
                else if (handlers.length > 1) {
                    throw new errors_1.ValueError("Found more than one (" + handlers.length + ") load handlers for " +
                        ("URL '" + pathOrIOHandler + "'"));
                }
                pathOrIOHandler = handlers[0];
            }
            return [2, loadModelFromIOHandler(pathOrIOHandler)];
        });
    });
}
exports.loadModelInternal = loadModelInternal;
function loadModelFromIOHandler(handler, customObjects) {
    return __awaiter(this, void 0, void 0, function () {
        var artifacts, modelTopology, model, skipMismatch, isNamedTensorMap;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (handler.load == null) {
                        throw new errors_1.ValueError('Cannot proceed with model loading because the IOHandler provided ' +
                            'does not have the `load` method implemented.');
                    }
                    return [4, handler.load()];
                case 1:
                    artifacts = _a.sent();
                    modelTopology = artifacts.modelTopology;
                    if (modelTopology['model_config'] != null) {
                        modelTopology = modelTopology['model_config'];
                    }
                    model = serialization_1.deserialize(serialization_utils_1.convertPythonicToTs(modelTopology), customObjects);
                    if (artifacts.weightData != null) {
                        if (artifacts.weightSpecs == null) {
                            throw new errors_1.ValueError('Model artifacts contains weight data, but not weight specs. ' +
                                'Therefore loading of weights cannot proceed.');
                        }
                        skipMismatch = false;
                        isNamedTensorMap = true;
                        model.loadWeights(tfjs_core_1.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs), skipMismatch, isNamedTensorMap);
                    }
                    return [2, model];
            }
        });
    });
}
exports.loadModelFromIOHandler = loadModelFromIOHandler;
var Sequential = (function (_super) {
    __extends(Sequential, _super);
    function Sequential(config) {
        var _this = _super.call(this, { inputs: [], outputs: [] }) || this;
        config = config || {};
        _this.trainable = true;
        _this._updatable = true;
        _this.built = false;
        _this.name = (config.name != null) ? config.name : K.getUid('sequential_');
        if (config.layers != null) {
            for (var _i = 0, _a = config.layers; _i < _a.length; _i++) {
                var layer = _a[_i];
                _this.add(layer);
            }
        }
        return _this;
    }
    Sequential_1 = Sequential;
    Sequential.prototype.add = function (layer) {
        var isLayerModelInstance = layer instanceof Sequential_1 || layer instanceof training_1.Model;
        var modelLayer;
        if (isLayerModelInstance) {
            modelLayer = layer;
            if (modelLayer.outputs.length !== 1) {
                throw new errors_1.ValueError('All layers in a Sequential model ' +
                    'should have a single output tensor. ' +
                    'For multi-output layers, ' +
                    'use the functional API.');
            }
            if (modelLayer.inputs.length !== 1) {
                throw new errors_1.ValueError('All layers in a Sequential model ' +
                    'should have a single input tensor. ' +
                    'For multi-input layers, ' +
                    'use the functional API.');
            }
        }
        if (this.outputs.length === 0) {
            if (layer.inboundNodes.length === 0) {
                if (layer.batchInputShape == null) {
                    throw new errors_1.ValueError('The first layer in a Sequential model must ' +
                        'get an `inputShape` or `batchInputShape` argument.');
                }
                var x = topology_1.Input({
                    batchShape: layer.batchInputShape,
                    dtype: layer.dtype,
                    name: layer.name + '_input'
                });
                layer.apply(x);
            }
            if (isLayerModelInstance) {
                this.outputs = modelLayer.outputs;
                this.inputs = modelLayer.inputs;
            }
            else {
                if (layer.inboundNodes.length !== 1) {
                    throw new errors_1.ValueError('A layer added to a Sequential model must not already be ' +
                        ("connected somewhere else. Model received layer " + layer.name + " ") +
                        ("which has " + layer.inboundNodes.length + " pre-existing inbound ") +
                        'connections.');
                }
                if (layer.inboundNodes[0].outputTensors.length !== 1) {
                    throw new errors_1.ValueError('All layers in a Sequential model ' +
                        'should have a single output tensor. ' +
                        'For multi-output layers, ' +
                        'use the functional API.');
                }
                this.outputs = [layer.inboundNodes[0].outputTensors[0]];
                this.inputs = topology_1.getSourceInputs(this.outputs[0]);
            }
            new topology_1.Node({
                outboundLayer: this,
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: this.inputs,
                outputTensors: this.outputs,
                inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),
                outputMasks: [null],
                inputShapes: this.inputs.map(function (x) { return x.shape; }),
                outputShapes: this.outputs[0].shape
            });
        }
        else {
            var outputTensor = layer.apply(this.outputs[0]);
            if (Array.isArray(outputTensor)) {
                throw new TypeError('All layers in a Sequential model ' +
                    'should have a single output tensor. ' +
                    'For multi-output layers, ' +
                    'use the functional API.');
            }
            this.outputs = [outputTensor];
            this.inboundNodes[0].outputTensors = this.outputs;
            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
        this.layers.push(layer);
        this.built = false;
    };
    Sequential.prototype.pop = function () {
        if (this.layers.length === 0) {
            throw new TypeError('There are no layers in the model.');
        }
        this.layers.pop();
        if (this.layers.length === 0) {
            this.outputs = [];
            this.inboundNodes = [];
            this.outboundNodes = [];
        }
        else {
            var lastLayerIndex = this.layers.length - 1;
            this.layers[lastLayerIndex].outboundNodes = [];
            this.outputs = [this.layers[lastLayerIndex].output];
            this.inboundNodes[0].outputTensors = this.outputs;
            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
    };
    Sequential.prototype.call = function (inputs, kwargs) {
        if (this.model == null) {
            this.build();
        }
        return this.model.call(inputs, kwargs);
    };
    Sequential.prototype.build = function (inputShape) {
        generic_utils.getExactlyOneShape(inputShape);
        if (this.inputs.length === 0 || this.outputs.length === 0) {
            throw new TypeError('Sequential model cannot be built: model is empty.' +
                ' Add some layers first.');
        }
        this.model = new training_1.Model({
            inputs: this.inputs,
            outputs: this.outputs[0],
            name: this.name + '_model'
        });
        this.model.trainable = this.trainable;
        this.model.updatable = this.updatable;
        this.supportsMasking = this.model.supportsMasking;
        this.inputLayers = this.model.inputLayers;
        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
        this.outputLayers = this.model.outputLayers;
        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
        this.nodesByDepth = this.model.nodesByDepth;
        this.containerNodes = this.model.containerNodes;
        this.outputNames = this.model.outputNames;
        this.inputNames = this.model.inputNames;
        this.built = true;
    };
    Sequential.prototype.setWeights = function (weights) {
        if (this.model == null) {
            this.build();
        }
        this.model.setWeights(weights);
    };
    Object.defineProperty(Sequential.prototype, "updatable", {
        get: function () {
            return this._updatable;
        },
        set: function (value) {
            if (this.built) {
                this.model.updatable = value;
            }
            this._updatable = value;
        },
        enumerable: true,
        configurable: true
    });
    Sequential.prototype.evaluate = function (x, y, config) {
        if (config === void 0) { config = {}; }
        if (!this.built) {
            throw new errors_1.RuntimeError('The model needs to be compiled before being used.');
        }
        return this.model.evaluate(x, y, config);
    };
    Sequential.prototype.predict = function (x, config) {
        if (config === void 0) { config = {}; }
        if (this.model == null) {
            this.build();
        }
        return this.model.predict(x, config);
    };
    Sequential.prototype.predictOnBatch = function (x) {
        if (this.model == null) {
            this.build();
        }
        return this.model.predictOnBatch(x);
    };
    Sequential.prototype.compile = function (config) {
        this.build();
        this.model.compile(config);
        this.optimizer = this.model.optimizer;
        this.loss = this.model.loss;
        this.metrics = this.model.metrics;
        this.metricsTensors = this.model.metricsTensors;
        this.metricsNames = this.model.metricsNames;
    };
    Sequential.prototype.fit = function (x, y, config) {
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.built) {
                    throw new errors_1.RuntimeError('The model needs to be compiled before ' +
                        'being used.');
                }
                return [2, this.model.fit(x, y, config)];
            });
        });
    };
    Sequential.fromConfig = function (cls, config) {
        var model = new cls({});
        if (!(model instanceof Sequential_1)) {
            throw new errors_1.ValueError("Sequential.fromConfig called on non-Sequential input: " + model);
        }
        if (!(config instanceof Array)) {
            throw new errors_1.ValueError("Sequential.fromConfig called without an array of configs");
        }
        if (!(config[0].className != null) || config[0]['className'] === 'Merge') {
            throw new errors_1.ValueError('Legacy serialization format not supported yet.');
        }
        for (var _i = 0, _a = config; _i < _a.length; _i++) {
            var conf = _a[_i];
            var layer = serialization_1.deserialize(conf);
            model.add(layer);
        }
        return model;
    };
    Sequential.prototype.getConfig = function () {
        var config = [];
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            config.push({
                className: layer.getClassName(),
                config: layer.getConfig(),
            });
        }
        return config;
    };
    Sequential.className = 'Sequential';
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes' })
    ], Sequential.prototype, "add", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })
    ], Sequential.prototype, "evaluate", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [1] })
    ], Sequential.prototype, "predict", null);
    __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })
    ], Sequential.prototype, "fit", null);
    Sequential = Sequential_1 = __decorate([
        tfjs_core_1.doc({ heading: 'Models', subheading: 'Classes' })
    ], Sequential);
    return Sequential;
    var Sequential_1;
}(training_1.Model));
exports.Sequential = Sequential;
tfjs_core_1.serialization.SerializationMap.register(Sequential);

},{"./backend/tfjs_backend":160,"./engine/topology":165,"./engine/training":166,"./errors":167,"./layers/serialization":181,"./utils/generic_utils":190,"./utils/serialization_utils":192,"@tensorflow/tfjs-core":51}],186:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var errors_1 = require("./errors");
function getOptimizer(identifier) {
    var optimizerMap = {
        'Adagrad': function () { return tfjs_core_1.train.adagrad(.01); },
        'Adam': function () { return tfjs_core_1.train.adam(.001, .9, .999, K.epsilon()); },
        'RMSProp': function () { return tfjs_core_1.train.rmsprop(.001, .9, null, K.epsilon()); },
        'SGD': function () { return tfjs_core_1.train.sgd(.01); }
    };
    optimizerMap['adagrad'] = optimizerMap['Adagrad'];
    optimizerMap['adam'] = optimizerMap['Adam'];
    optimizerMap['rmsprop'] = optimizerMap['RMSProp'];
    optimizerMap['sgd'] = optimizerMap['SGD'];
    if (identifier in optimizerMap) {
        return optimizerMap[identifier]();
    }
    throw new errors_1.ValueError("Unknown Optimizer " + identifier);
}
exports.getOptimizer = getOptimizer;

},{"./backend/tfjs_backend":160,"./errors":167,"@tensorflow/tfjs-core":51}],187:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var K = require("./backend/tfjs_backend");
var generic_utils_1 = require("./utils/generic_utils");
var Regularizer = (function (_super) {
    __extends(Regularizer, _super);
    function Regularizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Regularizer;
}(tfjs_core_1.serialization.Serializable));
exports.Regularizer = Regularizer;
var L1L2 = (function (_super) {
    __extends(L1L2, _super);
    function L1L2(config) {
        var _this = _super.call(this) || this;
        var l1 = config == null || config.l1 == null ? 0.01 : config.l1;
        var l2 = config == null || config.l2 == null ? 0.01 : config.l2;
        _this.hasL1 = l1 !== 0;
        _this.hasL2 = l2 !== 0;
        _this.l1 = K.getScalar(l1);
        _this.l2 = K.getScalar(l2);
        return _this;
    }
    L1L2.prototype.apply = function (x) {
        var _this = this;
        return tfjs_core_1.tidy(function () {
            var regularization = tfjs_core_1.zeros([1]);
            if (_this.hasL1) {
                regularization =
                    tfjs_core_1.add(regularization, tfjs_core_1.sum(K.scalarTimesArray(_this.l1, tfjs_core_1.abs(x))));
            }
            if (_this.hasL2) {
                regularization =
                    tfjs_core_1.add(regularization, tfjs_core_1.sum(K.scalarTimesArray(_this.l2, K.square(x))));
            }
            return regularization.asScalar();
        });
    };
    L1L2.prototype.getConfig = function () {
        return { 'l1': this.l1.dataSync()[0], 'l2': this.l2.dataSync()[0] };
    };
    L1L2.fromConfig = function (cls, config) {
        return new cls({ l1: config.l1, l2: config.l2 });
    };
    L1L2.className = 'L1L2';
    L1L2 = __decorate([
        tfjs_core_1.doc({ heading: 'Regularizers', namespace: 'regularizers' })
    ], L1L2);
    return L1L2;
}(Regularizer));
exports.L1L2 = L1L2;
tfjs_core_1.serialization.SerializationMap.register(L1L2);
function l1(config) {
    return new L1L2({ l1: config != null ? config.l1 : null, l2: 0 });
}
exports.l1 = l1;
function l2(config) {
    return new L1L2({ l2: config != null ? config.l2 : null, l1: 0 });
}
exports.l2 = l2;
exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    'l1l2': 'L1L2'
};
function serializeRegularizer(constraint) {
    return generic_utils_1.serializeKerasObject(constraint);
}
exports.serializeRegularizer = serializeRegularizer;
function deserializeRegularizer(config, customObjects) {
    if (customObjects === void 0) { customObjects = {}; }
    return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, 'regularizer');
}
exports.deserializeRegularizer = deserializeRegularizer;
function getRegularizer(identifier) {
    if (identifier == null) {
        return null;
    }
    if (typeof identifier === 'string') {
        var className = identifier in exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?
            exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :
            identifier;
        var config = { className: className, config: {} };
        return deserializeRegularizer(config);
    }
    else if (identifier instanceof Regularizer) {
        return identifier;
    }
    else {
        return deserializeRegularizer(identifier);
    }
}
exports.getRegularizer = getRegularizer;

},{"./backend/tfjs_backend":160,"./utils/generic_utils":190,"@tensorflow/tfjs-core":51}],188:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var common_1 = require("./common");
var _nextUniqueTensorId = 0;
function getNextUniqueTensorId() {
    return _nextUniqueTensorId++;
}
exports.getNextUniqueTensorId = getNextUniqueTensorId;
var SymbolicTensor = (function () {
    function SymbolicTensor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {
        this.dtype = dtype;
        this.shape = shape;
        this.sourceLayer = sourceLayer;
        this.inputs = inputs;
        this.callArgs = callArgs;
        this.outputTensorIndex = outputTensorIndex;
        this.id = getNextUniqueTensorId();
        if (name != null) {
            this.originalName = common_1.getScopedTensorName(name);
            this.name = common_1.getUniqueTensorName(this.originalName);
        }
        this.rank = shape.length;
    }
    SymbolicTensor = __decorate([
        tfjs_core_1.doc({ heading: 'Models', 'subheading': 'Classes' })
    ], SymbolicTensor);
    return SymbolicTensor;
}());
exports.SymbolicTensor = SymbolicTensor;

},{"./common":162,"@tensorflow/tfjs-core":51}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
var generic_utils_1 = require("./generic_utils");
var math_utils_1 = require("./math_utils");
function normalizeArray(value, n, name) {
    if (typeof value === 'number') {
        return generic_utils_1.pyListRepeat(value, n);
    }
    else {
        if (value.length !== n) {
            throw new errors_1.ValueError("The " + name + " argument must be a tuple of " + n + " integers. Received: " +
                (value.length + " elements."));
        }
        for (var i = 0; i < n; ++i) {
            var singleValue = value[i];
            if (!math_utils_1.isInteger(singleValue)) {
                throw new errors_1.ValueError("The " + name + " argument must be a tuple of " + n + " integers. Received: " +
                    (JSON.stringify(value) + " including a non-integer number ") +
                    ("" + singleValue));
            }
        }
        return value;
    }
}
exports.normalizeArray = normalizeArray;
function convOutputLength(inputLength, filterSize, padding, stride, dilation) {
    if (dilation === void 0) { dilation = 1; }
    if (inputLength == null) {
        return inputLength;
    }
    var dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);
    var outputLength;
    if (padding === 'same') {
        outputLength = inputLength;
    }
    else {
        outputLength = inputLength - dilatedFilterSize + 1;
    }
    return Math.floor((outputLength + stride - 1) / stride);
}
exports.convOutputLength = convOutputLength;
function deconvLength(dimSize, strideSize, kernelSize, padding) {
    if (dimSize == null) {
        return null;
    }
    if (padding === 'valid') {
        dimSize = dimSize * strideSize + math_utils_1.max([kernelSize - strideSize, 0]);
    }
    else if (padding === 'same') {
        dimSize = dimSize * strideSize;
    }
    else {
        throw new errors_1.ValueError("Unsupport padding mode: " + padding + ".");
    }
    return dimSize;
}
exports.deconvLength = deconvLength;

},{"../errors":167,"./generic_utils":190,"./math_utils":191}],190:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../errors");
function pyListRepeat(value, numValues) {
    if (Array.isArray(value)) {
        var newArray = [];
        for (var i = 0; i < numValues; i++) {
            newArray = newArray.concat(value);
        }
        return newArray;
    }
    else {
        var newArray = new Array(numValues);
        newArray.fill(value);
        return newArray;
    }
}
exports.pyListRepeat = pyListRepeat;
function assert(val, message) {
    if (!val) {
        throw new errors_1.AssertionError(message);
    }
}
exports.assert = assert;
function count(array, refernce) {
    var counter = 0;
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var item = array_1[_i];
        if (item === refernce) {
            counter++;
        }
    }
    return counter;
}
exports.count = count;
function singletonOrArray(xs) {
    if (xs.length === 1) {
        return xs[0];
    }
    return xs;
}
exports.singletonOrArray = singletonOrArray;
function toList(x) {
    if (Array.isArray(x)) {
        return x;
    }
    return [x];
}
exports.toList = toList;
function objectListUid(objs) {
    var objectList = toList(objs);
    var retVal = '';
    for (var _i = 0, objectList_1 = objectList; _i < objectList_1.length; _i++) {
        var obj = objectList_1[_i];
        if (obj.id == null) {
            throw new errors_1.ValueError("Object " + obj + " passed to objectListUid without an id");
        }
        if (retVal !== '') {
            retVal = retVal + ', ';
        }
        retVal = retVal + Math.abs(obj.id);
    }
    return retVal;
}
exports.objectListUid = objectListUid;
function isArrayOfShapes(x) {
    return Array.isArray(x) && Array.isArray(x[0]);
}
exports.isArrayOfShapes = isArrayOfShapes;
function normalizeShapeList(x) {
    if (x.length === 0) {
        return [];
    }
    if (!Array.isArray(x[0])) {
        return [x];
    }
    return x;
}
exports.normalizeShapeList = normalizeShapeList;
function toSnakeCase(name) {
    var intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, '$1_$2');
    var insecure = intermediate.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
    if (insecure[0] !== '_') {
        return insecure;
    }
    return 'private' + insecure;
}
exports.toSnakeCase = toSnakeCase;
function toCamelCase(identifier) {
    if (identifier.length <= 1) {
        return identifier;
    }
    if (identifier.indexOf('_') === -1) {
        return identifier;
    }
    return identifier.replace(/[_]+(\w|$)/g, function (m, p1) { return p1.toUpperCase(); });
}
exports.toCamelCase = toCamelCase;
var _GLOBAL_CUSTOM_OBJECTS = {};
function serializeKerasObject(instance) {
    if (instance === null || instance === undefined) {
        return null;
    }
    return { className: instance.getClassName(), config: instance.getConfig() };
}
exports.serializeKerasObject = serializeKerasObject;
function deserializeKerasObject(identifier, moduleObjects, customObjects, printableModuleName) {
    if (moduleObjects === void 0) { moduleObjects = {}; }
    if (customObjects === void 0) { customObjects = {}; }
    if (printableModuleName === void 0) { printableModuleName = 'object'; }
    if (typeof identifier === 'string') {
        var functionName = identifier;
        var fn = void 0;
        if (functionName in customObjects) {
            fn = customObjects[functionName];
        }
        else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {
            fn = _GLOBAL_CUSTOM_OBJECTS[functionName];
        }
        else {
            fn = moduleObjects[functionName];
            if (fn == null) {
                throw new errors_1.ValueError("Unknown " + printableModuleName + ": " + identifier);
            }
        }
        return fn;
    }
    else {
        var config = identifier;
        if (config.className == null || config.config == null) {
            throw new errors_1.ValueError(printableModuleName + ": Improper config format: " +
                (JSON.stringify(config) + ".\n") +
                "'className' and 'config' must set.");
        }
        var className = config.className;
        var cls = void 0, fromConfig = void 0;
        if (className in customObjects) {
            _a = customObjects.get(className), cls = _a[0], fromConfig = _a[1];
        }
        else if (className in _GLOBAL_CUSTOM_OBJECTS) {
            _b = _GLOBAL_CUSTOM_OBJECTS.className, cls = _b[0], fromConfig = _b[1];
        }
        else if (className in moduleObjects) {
            _c = moduleObjects[className], cls = _c[0], fromConfig = _c[1];
        }
        if (cls == null) {
            throw new errors_1.ValueError("Unknown " + printableModuleName + ": " + className);
        }
        if (fromConfig != null) {
            var customObjectsCombined = {};
            for (var _i = 0, _d = Object.keys(_GLOBAL_CUSTOM_OBJECTS); _i < _d.length; _i++) {
                var key = _d[_i];
                customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];
            }
            for (var _e = 0, _f = Object.keys(customObjects); _e < _f.length; _e++) {
                var key = _f[_e];
                customObjectsCombined[key] = customObjects[key];
            }
            var nestedConfig = config.config;
            nestedConfig.customObjects = customObjectsCombined;
            var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
            for (var _g = 0, _h = Object.keys(customObjects); _g < _h.length; _g++) {
                var key = _h[_g];
                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
            }
            var returnObj = fromConfig(cls, config.config);
            _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);
            return returnObj;
        }
        else {
            var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
            for (var _j = 0, _k = Object.keys(customObjects); _j < _k.length; _j++) {
                var key = _k[_j];
                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
            }
            var returnObj = new cls(config.config);
            _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);
            return returnObj;
        }
    }
    var _a, _b, _c;
}
exports.deserializeKerasObject = deserializeKerasObject;
function getExactlyOneTensor(xs) {
    var x;
    if (Array.isArray(xs)) {
        if (xs.length !== 1) {
            throw new errors_1.ValueError("Expected Tensor length to be 1; got " + xs.length);
        }
        x = xs[0];
    }
    else {
        x = xs;
    }
    return x;
}
exports.getExactlyOneTensor = getExactlyOneTensor;
function getExactlyOneShape(shapes) {
    if (Array.isArray(shapes) && Array.isArray(shapes[0])) {
        if (shapes.length === 1) {
            shapes = shapes;
            return shapes[0];
        }
        else {
            throw new errors_1.ValueError("Expected exactly 1 Shape; got " + shapes.length);
        }
    }
    else {
        return shapes;
    }
}
exports.getExactlyOneShape = getExactlyOneShape;
function numberCompare(a, b) {
    return (a < b) ? -1 : ((a > b) ? 1 : 0);
}
exports.numberCompare = numberCompare;
function reverseNumberCompare(a, b) {
    return -1 * numberCompare(a, b);
}
exports.reverseNumberCompare = reverseNumberCompare;
function stringToDType(dtype) {
    switch (dtype) {
        case 'float32':
            return 'float32';
        default:
            throw new errors_1.ValueError("Invalid dtype: " + dtype);
    }
}
exports.stringToDType = stringToDType;
function stringsEqual(xs, ys) {
    if (xs == null || ys == null) {
        return xs === ys;
    }
    if (xs.length !== ys.length) {
        return false;
    }
    for (var i = 0; i < xs.length; ++i) {
        if (xs[i] !== ys[i]) {
            return false;
        }
    }
    return true;
}
exports.stringsEqual = stringsEqual;
function unique(xs) {
    if (xs == null) {
        return xs;
    }
    var out = [];
    for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {
        var x = xs_1[_i];
        if (out.indexOf(x) === -1) {
            out.push(x);
        }
    }
    return out;
}
exports.unique = unique;
function isObjectEmpty(obj) {
    if (obj == null) {
        throw new errors_1.ValueError("Invalid value in obj: " + JSON.stringify(obj));
    }
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
exports.isObjectEmpty = isObjectEmpty;
function checkStringTypeUnionValue(values, label, value) {
    if (value == null) {
        return;
    }
    if (values.indexOf(value) < 0) {
        throw new errors_1.ValueError(value + " is not a valid " + label + ".  Valid values are " + values + " or null/undefined.");
    }
}
exports.checkStringTypeUnionValue = checkStringTypeUnionValue;

},{"../errors":167}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var errors_1 = require("../errors");
function isInteger(x) {
    return x === parseInt(x.toString(), 10);
}
exports.isInteger = isInteger;
function arrayProd(array, begin, end) {
    if (begin == null) {
        begin = 0;
    }
    if (end == null) {
        end = array.length;
    }
    var prod = 1;
    for (var i = begin; i < end; ++i) {
        prod *= array[i];
    }
    return prod;
}
exports.arrayProd = arrayProd;
function toArray1D(array) {
    array = Array.isArray(array) ? new Float32Array(array) : array;
    return tfjs_core_1.tensor1d(array);
}
function min(array) {
    return tfc.min(toArray1D(array)).dataSync()[0];
}
exports.min = min;
function max(array) {
    return tfc.max(toArray1D(array)).dataSync()[0];
}
exports.max = max;
function sum(array) {
    return tfc.sum(toArray1D(array)).dataSync()[0];
}
exports.sum = sum;
function mean(array) {
    return sum(array) / array.length;
}
exports.mean = mean;
function variance(array) {
    var demeaned = tfc.sub(toArray1D(array), tfjs_core_1.scalar(mean(array)));
    var sumSquare = tfc.sum(tfc.mulStrict(demeaned, demeaned)).dataSync()[0];
    return sumSquare / array.length;
}
exports.variance = variance;
function median(array) {
    var arraySorted = array.slice().sort(function (a, b) { return a - b; });
    var lowIdx = Math.floor((arraySorted.length - 1) / 2);
    var highIdx = Math.ceil((arraySorted.length - 1) / 2);
    if (lowIdx === highIdx) {
        return arraySorted[lowIdx];
    }
    return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;
}
exports.median = median;
function range(begin, end) {
    if (end < begin) {
        throw new errors_1.ValueError("end (" + end + ") < begin (" + begin + ") is forbidden.");
    }
    var out = [];
    for (var i = begin; i < end; ++i) {
        out.push(i);
    }
    return out;
}
exports.range = range;

},{"../errors":167,"@tensorflow/tfjs-core":51}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var generic_utils = require("../utils/generic_utils");
function isArrayItemInputOrOutputName(key, index, value) {
    return (key === 'inboundNodes' || key === 'outputLayers' ||
        key === 'inputLayers') &&
        index === 0 && typeof value === 'string';
}
function convertPythonicToTs(pythonicConfig, key) {
    if (pythonicConfig === null) {
        return null;
    }
    else if (typeof pythonicConfig === 'string') {
        return generic_utils.toCamelCase(pythonicConfig);
    }
    else if ((typeof pythonicConfig === 'number') ||
        (typeof pythonicConfig === 'boolean')) {
        return pythonicConfig;
    }
    else if (pythonicConfig instanceof Array) {
        var tsArray = [];
        var arrayLength = pythonicConfig.length;
        for (var i = 0; i < arrayLength; ++i) {
            var item = pythonicConfig[i];
            if (isArrayItemInputOrOutputName(key, i, item)) {
                tsArray.push(item);
            }
            else {
                tsArray.push(convertPythonicToTs(item, key));
            }
        }
        return tsArray;
    }
    else {
        var tsDict = {};
        for (var _i = 0, _a = Object.keys(pythonicConfig); _i < _a.length; _i++) {
            var pythonicKey = _a[_i];
            var pythonicValue = pythonicConfig[pythonicKey];
            if (pythonicKey === 'name' && typeof pythonicValue === 'string') {
                tsDict[pythonicKey] = pythonicValue;
            }
            else {
                var tsKey = generic_utils.toCamelCase(pythonicKey);
                tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);
            }
        }
        return tsDict;
    }
}
exports.convertPythonicToTs = convertPythonicToTs;
function convertTsToPythonic(tsConfig, key) {
    if (tsConfig === null || tsConfig === undefined) {
        return null;
    }
    else if (typeof tsConfig === 'string') {
        return generic_utils.toSnakeCase(tsConfig);
    }
    else if ((typeof tsConfig === 'number') || (typeof tsConfig === 'boolean')) {
        return tsConfig;
    }
    else if (tsConfig instanceof Array) {
        var pyArray = [];
        var arrayLength = tsConfig.length;
        for (var i = 0; i < arrayLength; ++i) {
            var item = tsConfig[i];
            if (isArrayItemInputOrOutputName(key, i, item)) {
                pyArray.push(item);
            }
            else {
                pyArray.push(convertTsToPythonic(item, key));
            }
        }
        return pyArray;
    }
    else {
        var pyDict = {};
        for (var _i = 0, _a = Object.keys(tsConfig); _i < _a.length; _i++) {
            var tsKey = _a[_i];
            var tsValue = tsConfig[tsKey];
            var pyKey = generic_utils.toSnakeCase(tsKey);
            if ((tsKey === 'name' || tsKey === 'className') &&
                typeof tsValue === 'string') {
                pyDict[pyKey] = tsValue;
            }
            else {
                pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);
            }
        }
        return pyDict;
    }
}
exports.convertTsToPythonic = convertTsToPythonic;

},{"../utils/generic_utils":190}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tfc = require("@tensorflow/tfjs-core");
var tfjs_backend_1 = require("./backend/tfjs_backend");
var common_1 = require("./common");
var errors_1 = require("./errors");
var types_1 = require("./types");
var DEFAULT_VARIABLE_NAME_PREFIX = 'Variable';
var LayerVariable = (function () {
    function LayerVariable(val, dtype, name, trainable, constraint) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (name === void 0) { name = DEFAULT_VARIABLE_NAME_PREFIX; }
        if (trainable === void 0) { trainable = true; }
        if (constraint === void 0) { constraint = null; }
        this.dtype = dtype == null ? 'float32' : dtype;
        this.shape = val.shape;
        this.id = types_1.getNextUniqueTensorId();
        name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;
        this.originalName = common_1.getScopedTensorName(name);
        this.name = common_1.getUniqueTensorName(this.originalName);
        this.trainable = trainable;
        this.constraint = constraint;
        this.val = tfc.variable(val, this.trainable, this.name, this.dtype);
    }
    LayerVariable.prototype.read = function () {
        return this.val;
    };
    LayerVariable.prototype.write = function (newVal) {
        checkShapesMatch(this.val, newVal);
        this.val.assign(newVal);
        if (this.constraint != null) {
            this.val.assign(this.constraint.apply(this.val));
        }
        return this;
    };
    return LayerVariable;
}());
exports.LayerVariable = LayerVariable;
function checkShapesMatch(x, y) {
    if (x.shape.toString() !== y.shape.toString()) {
        throw new Error('Shape mismatch: ' + JSON.stringify(x.shape) + ' vs. ' +
            JSON.stringify(y.shape));
    }
}
function variable(x, dtype, name, constraint) {
    return new LayerVariable(x, dtype, name, true, constraint);
}
exports.variable = variable;
function zerosVariable(shape, dtype, name) {
    return new LayerVariable(tfc.zeros(shape), dtype, name);
}
exports.zerosVariable = zerosVariable;
function zerosLike(x, dtype, name) {
    return new LayerVariable(tfc.zerosLike(x), dtype, name);
}
exports.zerosLike = zerosLike;
function onesVariable(shape, dtype, name) {
    var allocated = tfc.ones(shape);
    return new LayerVariable(allocated, dtype, name);
}
exports.onesVariable = onesVariable;
function onesLike(x, dtype, name) {
    var allocated = tfc.onesLike(x);
    return new LayerVariable(allocated, dtype, name);
}
exports.onesLike = onesLike;
function eyeVariable(size, dtype, name) {
    return new LayerVariable(tfc.eye(size), dtype, name);
}
exports.eyeVariable = eyeVariable;
function randomUniformVariable(shape, minval, maxval, dtype, seed, name) {
    if (name === void 0) { name = 'randomUniform'; }
    return new LayerVariable(tfc.randomUniform(shape, minval, maxval, dtype), dtype, name);
}
exports.randomUniformVariable = randomUniformVariable;
function truncatedNormalVariable(shape, mean, stddev, dtype, seed, name) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    if (name === void 0) { name = 'truncatedNormal'; }
    if (dtype === 'bool') {
        throw new errors_1.NotImplementedError("randomNormal does not support dType bool.");
    }
    return new LayerVariable(tfc.truncatedNormal(shape, mean, stddev, dtype, seed), dtype, name);
}
exports.truncatedNormalVariable = truncatedNormalVariable;
function randomNormalVariable(shape, mean, stddev, dtype, seed, name) {
    if (mean === void 0) { mean = 0.0; }
    if (stddev === void 0) { stddev = 1.0; }
    if (name === void 0) { name = 'randomNormal'; }
    if (dtype === 'bool') {
        throw new errors_1.NotImplementedError("randomNormalVariable does not support dType bool.");
    }
    return new LayerVariable(tfjs_backend_1.randomNormal(shape, mean, stddev, dtype, seed), dtype, name);
}
exports.randomNormalVariable = randomNormalVariable;
function update(x, xNew) {
    return x.write(xNew);
}
exports.update = update;
function updateAdd(x, increment) {
    return x.write(tfc.add(x.read(), increment));
}
exports.updateAdd = updateAdd;
function updateSub(x, decrement) {
    return x.write(tfc.sub(x.read(), decrement));
}
exports.updateSub = updateSub;
function batchGetValue(xs) {
    return xs.map(function (x) { return x.read(); });
}
exports.batchGetValue = batchGetValue;
function batchSetValue(variablesAndValues) {
    variablesAndValues.map(function (variableAndValue) {
        var variable = variableAndValue[0];
        variable.write(variableAndValue[1]);
    });
}
exports.batchSetValue = batchSetValue;

},{"./backend/tfjs_backend":160,"./common":162,"./errors":167,"./types":188,"@tensorflow/tfjs-core":51}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.6.6';
exports.version = version;

},{}],195:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("@tensorflow/tfjs-core"));
__export(require("@tensorflow/tfjs-layers"));
__export(require("@tensorflow/tfjs-converter"));
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var tfjs_layers_1 = require("@tensorflow/tfjs-layers");
var tfjs_converter_1 = require("@tensorflow/tfjs-converter");
var version_1 = require("./version");
exports.version = {
    'tfjs-core': tfjs_core_1.version_core,
    'tfjs-layers': tfjs_layers_1.version_layers,
    'tfjs-converter': tfjs_converter_1.version_converter,
    'tfjs': version_1.version
};

},{"./version":196,"@tensorflow/tfjs-converter":13,"@tensorflow/tfjs-core":51,"@tensorflow/tfjs-layers":169}],196:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"dup":156}],197:[function(require,module,exports){
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");

},{"./src/index-minimal":198}],198:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Configure serialization
protobuf.Writer._configure(protobuf.BufferWriter);
configure();

},{"./reader":199,"./reader_buffer":200,"./roots":201,"./rpc":202,"./util/minimal":205,"./writer":206,"./writer_buffer":207}],199:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            do { // eslint-disable-line no-constant-condition
                if ((wireType = this.uint32() & 7) === 4)
                    break;
                this.skipType(wireType);
            } while (true);
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":205}],200:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

},{"./reader":199,"./util/minimal":205}],201:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],202:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":203}],203:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":205}],204:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":205}],205:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ global.dcodeIO && /* istanbul ignore next */ global.dcodeIO.Long || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./longbits":204,"@protobufjs/aspromise":2,"@protobufjs/base64":3,"@protobufjs/eventemitter":4,"@protobufjs/float":5,"@protobufjs/inquire":6,"@protobufjs/pool":7,"@protobufjs/utf8":8}],206:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};

},{"./util/minimal":205}],207:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

},{"./util/minimal":205,"./writer":206}],208:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes BaagÃ¸e.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by FranÃ§ois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":209,"./lib/tychei":210,"./lib/xor128":211,"./lib/xor4096":212,"./lib/xorshift7":213,"./lib/xorwow":214,"./seedrandom":215}],209:[function(require,module,exports){
// A port of an algorithm by Johannes BaagÃ¸e <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes BaagÃ¸e <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],210:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],211:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],212:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],213:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// FranÃ§ois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],214:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],215:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":216}],216:[function(require,module,exports){

},{}],217:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],218:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],219:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],220:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],221:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":219,"./encode":220}],222:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":223,"punycode":218,"querystring":221}],223:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImZ1bmN0aW9uYWxfYXV0b2VuY29kZXIuanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Jhc2U2NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvaW5xdWlyZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9kYXRhL2NvbXBpbGVkX2FwaS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L2V4ZWN1dG9yL2V4ZWN1dGlvbl9jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3QvZXhlY3V0b3IvZnJvemVuX21vZGVsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3QvZXhlY3V0b3IvZ3JhcGhfZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL2FyaXRobWV0aWNfZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL2V4ZWN1dG9ycy9iYXNpY19tYXRoX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9leGVjdXRvcnMvY29udHJvbF9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL2NvbnZvbHV0aW9uX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9leGVjdXRvcnMvY3JlYXRpb25fZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL2V4ZWN1dG9ycy9ncmFwaF9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL2ltYWdlX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9leGVjdXRvcnMvbG9naWNhbF9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL21hdHJpY2VzX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9leGVjdXRvcnMvbm9ybWFsaXphdGlvbl9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL3JlZHVjdGlvbl9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL3NsaWNlX2pvaW5fZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL2V4ZWN1dG9ycy90cmFuc2Zvcm1hdGlvbl9leGVjdXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvZXhlY3V0b3JzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L2FyaXRobWV0aWMuanNvbiIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvb3BfbGlzdC9iYXNpY19tYXRoLmpzb24iLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wX2xpc3QvY29udHJvbC5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L2NvbnZvbHV0aW9uLmpzb24iLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wX2xpc3QvY3JlYXRpb24uanNvbiIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvb3BfbGlzdC9ncmFwaC5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L2ltYWdlLmpzb24iLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wX2xpc3QvbG9naWNhbC5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L21hdHJpY2VzLmpzb24iLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wX2xpc3Qvbm9ybWFsaXphdGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L3JlZHVjdGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcF9saXN0L3NsaWNlX2pvaW4uanNvbiIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L29wZXJhdGlvbnMvb3BfbGlzdC90cmFuc2Zvcm1hdGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3Qvb3BlcmF0aW9ucy9vcGVyYXRpb25fZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC9vcGVyYXRpb25zL29wZXJhdGlvbl9tYXBwZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2Jyb3dzZXJfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9kZXZpY2VfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9kb2MuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2Vudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvZ3JhZGllbnRzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2lvL2Jyb3dzZXJfZmlsZXMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvaW8vYnJvd3Nlcl9odHRwLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2lvL2luZGV4ZWRfZGIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvaW8vaW8uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvaW8vaW9fdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvaW8vbG9jYWxfc3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9pby9tb2RlbF9tYW5hZ2VtZW50LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2lvL3JvdXRlcl9yZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9pby90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9pby93ZWlnaHRzX2xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL2JhY2tlbmRfY3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvYmFja2VuZF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvYmFja2VuZF93ZWJnbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL2FyZ21pbm1heF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9hdmdfcG9vbF9iYWNrcHJvcF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9iYXRjaG5vcm1fZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvYmluYXJ5b3BfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvY2xpcF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9jb25jYXRfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvY29udl9iYWNrcHJvcF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9jb252X2JhY2twcm9wX2dwdV9kZXB0aHdpc2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9jb252X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL2N1bXN1bV9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9mcm9tX3BpeGVsc19ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9nYXRoZXJfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvZ3BncHVfY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL2dwZ3B1X21hdGguanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9ncGdwdV91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvbG9naWNhbF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9scm5fZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvbWF4X3Bvb2xfYmFja3Byb3BfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvbXVsbWF0X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL211bHRpbm9taWFsX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL29uZWhvdF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9wYWRfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvcG9vbF9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9yZWR1Y2VfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvcmVzaXplX2JpbGluZWFyX2JhY2twcm9wX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9yZXNpemVfbmVhcmVzdF9uZWlnaGJvcl9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC9yZXZlcnNlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3NoYWRlcl9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3NsaWNlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3N0cmlkZWRfc2xpY2VfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L2tlcm5lbHMvd2ViZ2wvdGV4X3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC90ZXh0dXJlX21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC90aWxlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3RyYW5zcG9zZV9ncHUuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qva2VybmVscy93ZWJnbC91bmFyeW9wX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9rZXJuZWxzL3dlYmdsL3dlYmdsX3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2FycmF5X29wcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvYXhpc191dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9iYXRjaG5vcm0uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2JpbmFyeV9vcHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2Jyb2FkY2FzdF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9jb21wYXJlLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9jb25jYXQuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2NvbmNhdF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9jb252LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9jb252X3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2VyZl91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9pbWFnZV9vcHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2xpbmFsZ19vcHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL2xvZ2ljYWxfb3BzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9sb3NzX29wcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvbHJuLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9sc3RtLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9tYXRtdWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL21vdmluZ19hdmVyYWdlLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9ub3JtLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wcy9vcGVyYXRpb24uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL29wcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvcmFuZC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvcmVkdWNlX3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3JlZHVjdGlvbl9vcHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3JldmVyc2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3NlbHVfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvc2xpY2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3NsaWNlX3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3NvZnRtYXguanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3N0cmlkZWRfc2xpY2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3BzL3RyYW5zcG9zZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHMvdW5hcnlfb3BzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wdGltaXplcnMvYWRhZGVsdGFfb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9hZGFtX29wdGltaXplci5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC9vcHRpbWl6ZXJzL2FkYW1heF9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9tb21lbnR1bV9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9vcHRpbWl6ZXJfY29uc3RydWN0b3JzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3Qvb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3Byb2ZpbGVyLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3NlcmlhbGl6YXRpb24uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGFwZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC90ZW5zb3IuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGVuc29yX3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGVzdF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3RyYWNraW5nLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3RyYWluLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3V0aWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC93ZWJnbC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2FjdGl2YXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvYmFja2VuZC9jb21tb24uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9iYWNrZW5kL3RmanNfYmFja2VuZC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2NhbGxiYWNrcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2NvbnN0cmFpbnRzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZW5naW5lL2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZW5naW5lL3RvcG9sb2d5LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZW5naW5lL3RyYWluaW5nLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvZXhwb3J0cy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvaW5pdGlhbGl6ZXJzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL2FkdmFuY2VkX2FjdGl2YXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL2NvbnZvbHV0aW9uYWwuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9sYXllcnMvY29udm9sdXRpb25hbF9kZXB0aHdpc2UuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9sYXllcnMvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2xheWVycy9lbWJlZGRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL21lcmdlLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL25vcm1hbGl6YXRpb24uanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9sYXllcnMvcGFkZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2xheWVycy9wb29saW5nLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL3JlY3VycmVudC5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L2xheWVycy9zZXJpYWxpemF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbGF5ZXJzL3dyYXBwZXJzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbG9zc2VzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvbWV0cmljcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L21vZGVscy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L29wdGltaXplcnMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC9yZWd1bGFyaXplcnMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L3V0aWxzL2NvbnZfdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC91dGlscy9nZW5lcmljX3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvdXRpbHMvbWF0aF91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWxheWVycy9kaXN0L3V0aWxzL3NlcmlhbGl6YXRpb25fdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC92YXJpYWJsZXMuanMiLCJub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3IxMjguanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3JzaGlmdDcuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2akRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Q0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFrREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNya0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImNvbnN0IHRmID0gcmVxdWlyZSgnQHRlbnNvcmZsb3cvdGZqcycpXG5cblxudGVzdGluZyA9IHRydWVcblxuaWYodGVzdGluZyl7XG4gIHdpbmRvdy50ZiA9IHRmXG4gIC8qXG4gIHZhciBzID0gMTAgXG4gIHZhciBleWUgPSB0Zi5leWUocykubXVsKHRmLnNjYWxhcigxKSlcbiAgZXllID0gZXllLm1hdE11bChjcmVhdGVSb2xsTWF0cml4KHMsIC0xKSlcbiAgZXllLnByaW50KClcbiAgZXllID0gdGYuYmF0Y2hOb3JtYWxpemF0aW9uKGV5ZSx0Zi56ZXJvc0xpa2UoZXllKSwgdGYub25lc0xpa2UoZXllKS5tdWwodGYudGVuc29yKFsxXSkpKS8vLnByaW50KClcbiAgZXllLnByaW50KClcbiAgdmFyIGJiID0gb3J0aG9Ob3JtYWwoe3NoYXBlOlsxMiwxMl0sIG1lYW46MSwgZGV2OjJ9KSBcbiAgdmFyIGJiYiA9IG9ydGhvVW5pZm9ybSh7c2hhcGU6IFs2LCAxMl0sIG1pbjotMSwgbWF4OjF9KVxuICBjb25zb2xlLmxvZyhiKVxuICBiLnByaW50KClcbiAgYmIucHJpbnQoKVxuICBiYmIucHJpbnQoKVxuICBsZXQgYyA9IGIuc2xpY2UoWzAsMF0sMSlcbiAgbGV0IGQgPSBiYi5zbGljZShbMSwwXSwgMSlcbiAgbGV0IGUgPSBiYmIuc2xpY2UoWzIsMF0sIDEpXG4gIGQucHJpbnQoKVxuICBjLnByaW50KClcbiAgYy5kb3QoZC50cmFuc3Bvc2UoKSkucHJpbnQoKVxuICBlLm1hdE11bChjLnRyYW5zcG9zZSgpKS5wcmludCgpXG4gIGQubWF0TXVsKGUudHJhbnNwb3NlKCkpLnByaW50KClcbiAgKi9cbiAgdmFyIGIgPSBvcnRob1RydW5jYXRlZCh7c2hhcGU6IFsyLDEyXSwgbWVhbjoxLCBkZXY6Mn0pIFxuICBiLnByaW50KClcbiAgYi50cmFuc3Bvc2UoKS5wcmludCgpXG4gIGxldCBpID0gMSwgaiA9IDQsIGsgPSAyLCBsID0gOCBcbiAgdmFyIHQgPSB0Zi5zdGFjayhbdGYub25lcyhbaSxqXSwnZmxvYXQzMicpLCB0Zi5yZXNoYXBlKHRmLmxpbnNwYWNlKDAsIDEsIDQpLCBbaSxqXSldLDApLnNxdWVlemUoKVxuICBjb25zb2xlLmxvZyh0KVxuICB2YXIgeCA9IG9ydGhvTm9ybWFsKHtzaGFwZTogW2osbF19KS8vLnByaW50KClcbiAgdmFyIHkgPSBvcnRob05vcm1hbCh7c2hhcGU6IFtqLGxdfSkvLy5wcmludCgpXG4gIHgucHJpbnQoKVxuICB5LnByaW50KClcbiAgdC5wcmludCgpXG4gIC8veCA9IHRmLmNvbmNhdChbeSwgeF0sIDEpXG4gIHgucHJpbnQoKVxuICB0Zi5tYXRNdWwodCAseCApLnByaW50KClcbn1cblxuXG5cbi8vIGV4OiBpbnB1dCB3aWxsIGJlIDI1NiBzYW1wbGVzICsgdGltZSwgdG9wb2xvZ3kgd2lsbCBiZSBkZWZhdWx0IHdpdGggYXJyYXkgb2YgZGVuc2UgdW5pdCBsYXllcnNcbi8vIGFuZCBmb3IgZXhwZXJpbWVudHMsIHRoZSBsYXRlbnRfc3BhY2V0aW1lIGlzIGtub3duLCBzaGFyZWQgYWNyb3NzIGRpc3RyaWJ1dGVkIGFuZCBkaXNwYXJhdGUgdHJhaW5pbmcgc2Vzc2lvbnNcbi8vIG5vdGluZyB0aGF0IGFuIGV2b2x1dGlvbmFyeSBhbGdvcml0aG0gZm9yIHBvc3NpYmx5IGZpbmRpbmcgbGF0ZW50X3NwYWNldGltZSB0aGF0IGlzIHNvbWVob3cgYmV0dGVyIGFkb2FwdGVkIHRvIHRoZSB3aG9sZVxuLy8gYW5kIHRoZW4gdGhlcmUgaXMgdGhlIHN0dWR5IG9mIGNvbXBhcmF0aXZlIHNwYWNldGltZXMsIHRvIHNlZSB3aGF0J3Mgb3V0IHRoZXJlXG5cbnZhciBvcnRob2xpemVycyA9IHtvcnRob1VuaWZvcm0sIG9ydGhvVHJ1bmNhdGVkLCBvcnRob05vcm1hbH1cblxubGV0IGlucHV0X3NoYXBlID0gWzIsIDI1Nl0gLy8gZmlyc3Qgcm93IGlzIHNpZ25hbCwgc2Vjb25kIGlzIHRpbWUsIHRoaXMgaXMgYSAyZCBmbGF0dGVuZWQgWzEsMjU2LDJdXG5sZXQgdG9wb2xvZ3kgPSAgWzEwMjQsIDUxMiwgMjU2LCAxMjgsIDY0LCAzMiwgMTZdXG4vLyBpdCBzZWVtcyBsaWtlIHRoZSBmaXJzdCBzaG91bGQgYmUgYmlnZ2VyIHRoYW4gaW5wdXRfc2hhcGVbMV1cbi8vIG9yIG1heWJlIGRvbid0IHVzZSBvcnRob3MgYWxsIHRoZSB3YXk/ICBvbmx5IGJlZ2lubmluZyBhbmQgZW5kPyBvciBvbmx5IGVuZD9cblxuLy8gdHJ5IGZpcnN0IG9uZSBmaWx0ZXIgZm9yIGJvdGggdGhlIHNpZ25hbCBhbmQgdGltZSAodG8gY29ycmVsYXRlIHRoZW0pLCBlcmdvIG9uZSBkaW1lbnNpb24gb2YgMmQgb3V0cHV0IGluc3RlYWQgb2YgWzE2LDE2LCAyXVxubGV0IGxhdGVudF9zcGFjZXRpbWUgPSBvcnRob05vcm1hbCh7c2hhcGU6IFsxNiwgMTZdfSlcblxubGV0IGVsVG9wbyA9IHZhZWpzKHtpbnB1dF9zaGFwZSwgdG9wb2xvZ3ksIGxhdGVudF9zcGFjZXRpbWV9KVxudmFyIHh0ID0gdGYub25lcyhpbnB1dF9zaGFwZSlcbnZhciB7b3V0LCBwcmV9ID0gZWxUb3BvKHh0KVxucHJlLnByaW50KClcbm91dC5wcmludCgpXG5cbmZ1bmN0aW9uIHZhZWpzKHtpbnB1dF9zaGFwZSwgdG9wb2xvZ3ksIGxhdGVudF9zcGFjZXRpbWV9KXtcbiAgLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zLCBvciBhIHJlZHVjZSBpbnRvIGEgZmFuY3kgZnVjdGlvbj9cbiAgdmFyIGxhc3RPdXRwdXQgPSBpbnB1dF9zaGFwZVsxXSBcbiAgdmFyIHRvcG8gPSB0b3BvbG9neS5yZWR1Y2UoKGEsZSxpLG8pID0+IHtcbiAgICBsZXQgdW5pdHMgPSBlXG4gICAgbGV0IHNoYXBlID0gW2xhc3RPdXRwdXQsIGVdIFxuXG4gICAgLy8gaWYgdGhlIHRoZSB1bml0IHNpemUgaXMgbGFyZ2VyIHRoYW4gdGhlIGxhc3Qgb3V0cHV0XG4gICAgLy8gZXhwYW5kIHRoZSBkaW1lbnNpb25hbGl0eSB0aHJvdWdoIG9ydGhvZ29uYWwgc3BhY2VcbiAgICAvLyBlbHNlIHVzZSBhIHJlZ3VsYXIgcmFuZG9tIHdlaWdodC4uLiB3aHkgbm90P1xuICAgIHZhciB0ZW5zb3JcbiAgICBpZihsYXN0T3V0cHV0IDwgZSkgdGVuc29yID0gb3J0aG9Ob3JtYWwoe3NoYXBlfSlcbiAgICBlbHNlIHRlbnNvciA9IHJhbmRvbU5vcm1hbCh7c2hhcGV9KSAvLyBjcmVhdGVEZW5zZU9ydGhvZ29uKHtzaGFwZX0pXG4gICAgbGFzdE91dHB1dCA9IGVcbiAgICBsZXQgZm4gPSBhXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0KXtcbiAgICAgIHZhciBvdXRwdXQgPSBmbihpbnB1dClcbiAgICAgIHJldHVybiBvdXRwdXQubWF0TXVsKHRlbnNvcilcbiAgICB9fSwgZnVuY3Rpb24oaW5wdXQpe1xuICAgICAgcmV0dXJuIGlucHV0XG4gIH0pICAgIFxuXG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCl7XG4gICAgbGV0IHByZSA9IHRvcG8oaW5wdXQpXG4gICAgbGV0IG91dCA9IHByZS5tYXRNdWwobGF0ZW50X3NwYWNldGltZSlcbiAgICByZXR1cm4ge291dCwgcHJlfVxuICB9XG5cbn1cblxuXG5hc3luYyBmdW5jdGlvbiBuZXh0VGljayhmbil7IGF3YWl0IHRmLm5leHRGcmFtZSgpOyBmbigpfVxuXG5cblxuXG4vL8K/IGNydWVsIGFuZCB1bm5lY2Vzc2FyeSBhYnN0cmFjdGlvbiA/XG5mdW5jdGlvbiBjcmVhdGVEZW5zZU9ydGhvZ29uKHtzaGFwZSwgaW5pdD0nb3J0aG9Ob3JtYWwnLCBtaW49LTEsIG1heD0xLCBtZWFuPTAsIGRldj0xLCBkdHlwZT0nZmxvYXQzMid9KXtcbiAgcmV0dXJuIG9ydGhvbGl6ZXJzW2luaXRdKGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gb3J0aG9Vbmlmb3JtKHtzaGFwZSwgbWluPS0xLCBtYXg9MSwgdHlwZT0nZmxvYXQzMid9KXtcbiAgcmV0dXJuIHRmLmxpbmFsZy5ncmFtU2NobWlkdCh0Zi5yYW5kb21Vbmlmb3JtKHNoYXBlLCBtaW4sIG1heCwgdHlwZSkpXG59XG5cbmZ1bmN0aW9uIG9ydGhvVHJ1bmNhdGVkKHtzaGFwZSwgbWVhbj0wLCBkZXY9MSwgdHlwZT0nZmxvYXQzMid9KXtcbiAgcmV0dXJuIHRmLmxpbmFsZy5ncmFtU2NobWlkdCh0Zi50cnVuY2F0ZWROb3JtYWwoc2hhcGUsIG1lYW4sIGRldiwgdHlwZSkpXG59XG5cbmZ1bmN0aW9uIHJhbmRvbU5vcm1hbCh7c2hhcGUsIG1lYW49MCwgZGV2PTEsIHR5cGU9J2Zsb2F0MzInfSl7XG4gIHJldHVybiB0Zi5yYW5kb21Ob3JtYWwoc2hhcGUsIG1lYW4sIGRldiwgdHlwZSlcbn1cblxuZnVuY3Rpb24gb3J0aG9Ob3JtYWwoe3NoYXBlLCBtZWFuPTAsIGRldj0xLCB0eXBlPSdmbG9hdDMyJ30pe1xuICByZXR1cm4gdGYubGluYWxnLmdyYW1TY2htaWR0KHRmLnJhbmRvbU5vcm1hbChzaGFwZSwgbWVhbiwgZGV2LCB0eXBlKSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9sbE1hdHJpeChzLCB0KXtcblxuICByZXR1cm4gcm9sbChzLCB0KVxuXG4gIGZ1bmN0aW9uIHJvbGwocywgdCl7IFxuICAgIGwgPSBzICogc1xuICAgIHZhciBvbmUgPSB0ID4gMCA/IHJvbGxSaWdodE9uZShsKSA6IHJvbGxMZWZ0T25lKE1hdGguYWJzKGwpKVxuICAgIHZhciBybSA9IHRmLmV5ZShNYXRoLnNxcnQobCkpXG4gICAgZm9yKHZhciB4ID0gMDsgeCA8IE1hdGguYWJzKHQpOyB4Kyspe1xuICAgICAgIHJtID0gdGYubWF0TXVsKHJtLCBvbmUpXG4gICAgfVxuICAgIHJldHVybiBybVxuICB9XG5cbiAgZnVuY3Rpb24gcm9sbExlZnRPbmUobCl7XG4gICAgdmFyIGEgPSBuZXcgRmxvYXQzMkFycmF5KGwpXG4gICAgdmFyIG4gPSBNYXRoLnNxcnQobClcbiAgICBhLmZpbGwoMClcbiAgICBhLmZvckVhY2goKGUsaSxhKSA9PiAoaSAtIG4pICUgKG4gKyAxKSA9PT0gMCA/IGFbaV0gPSAxIDogYVtpXSA9IDApXG4gICAgYVtuIC0gMV0gPSAxXG4gICAgcmV0dXJuIHRmLnRlbnNvcihhLCBbbixuXSwgJ2Zsb2F0MzInKVxuICB9XG5cbiAgZnVuY3Rpb24gcm9sbFJpZ2h0T25lKGwpe1xuICAgIHZhciBhID0gbmV3IEZsb2F0MzJBcnJheShsKVxuICAgIHZhciBuID0gTWF0aC5zcXJ0KGwpXG4gICAgYS5maWxsKDApXG4gICAgYS5mb3JFYWNoKChlLGksYSkgPT4gKGkgLSAxKSAlIChuICsgMSkgPT09IDAgPyBhW2ldID0gMSA6IGFbaV0gPSAwKVxuICAgIGFbbCAtIG5dID0gMVxuICAgIHJldHVybiB0Zi50ZW5zb3IoYSwgW24sbl0sICdmbG9hdDMyJylcbiAgfVxuXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBhc1Byb21pc2U7XHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5hc1Byb21pc2V9LlxyXG4gKiBAdHlwZWRlZiBhc1Byb21pc2VDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBBZGRpdGlvbmFsIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmcm9tIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHthc1Byb21pc2VDYWxsYmFja30gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IGN0eCBGdW5jdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gUHJvbWlzaWZpZWQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4LyosIHZhcmFyZ3MgKi8pIHtcclxuICAgIHZhciBwYXJhbXMgID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICBvZmZzZXQgID0gMCxcclxuICAgICAgICBpbmRleCAgID0gMixcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVyci8qLCB2YXJhcmdzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGV2ZW50IGVtaXR0ZXIgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgQSBtaW5pbWFsIGV2ZW50IGVtaXR0ZXIuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIExpc3RlbmVyXHJcbiAqIEBwYXJhbSB7Kn0gW2N0eF0gTGlzdGVuZXIgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2dCwgZm4sIGN0eCkge1xyXG4gICAgKHRoaXMuX2xpc3RlbmVyc1tldnRdIHx8ICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdKSkucHVzaCh7XHJcbiAgICAgICAgZm4gIDogZm4sXHJcbiAgICAgICAgY3R4IDogY3R4IHx8IHRoaXNcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBvciBhbnkgbWF0Y2hpbmcgbGlzdGVuZXJzIGlmIGFyZ3VtZW50cyBhcmUgb21pdHRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtldnRdIEV2ZW50IG5hbWUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBpZiBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIExpc3RlbmVyIHRvIHJlbW92ZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIG9mIGBldnRgIGlmIG9taXR0ZWQuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldnQsIGZuKSB7XHJcbiAgICBpZiAoZXZ0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZm4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4pXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdHMgYW4gZXZlbnQgYnkgY2FsbGluZyBpdHMgbGlzdGVuZXJzIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgIHZhciBhcmdzID0gW10sXHJcbiAgICAgICAgICAgIGkgPSAxO1xyXG4gICAgICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2krK10uY3R4LCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyAvIHdyaXRlcyBmbG9hdHMgLyBkb3VibGVzIGZyb20gLyB0byBidWZmZXJzLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0XHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2Ygbm9kZS1iYXNlZCB0ZXN0aW5nIGluIG1vZGlmaWVkIGdsb2JhbCBlbnZpcm9ubWVudHNcclxuZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzKSB7XHJcblxyXG4gICAgLy8gZmxvYXQ6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbIC0wIF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzNdID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgIC8vIGZsb2F0OiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gMy40MDI4MjM0NjYzODUyODg2ZSszOCkgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMS4xNzU0OTQzNTA4MjIyODc1ZS0zOCkgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZG91YmxlOiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbN10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbN107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgLy8gZG91YmxlOiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpIHsgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgeyAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLFxyXG4gICAgICAgICAgICAgICAgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NyxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0N1xyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbi8vIHVpbnQgaGVscGVyc1xyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgPj4+IDI0O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXVxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF0gPDwgMjRcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1aXJlcyBhIG1vZHVsZSBvbmx5IGlmIGF2YWlsYWJsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTW9kdWxlIHRvIHJlcXVpcmVcclxuICogQHJldHVybnMgez9PYmplY3R9IFJlcXVpcmVkIG1vZHVsZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKi9cclxuZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgVVRGOCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHV0ZjggPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFVURjggYnl0ZSBsZW5ndGggb2YgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG51dGY4Lmxlbmd0aCA9IGZ1bmN0aW9uIHV0ZjhfbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIGxlbiA9IDAsXHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOClcclxuICAgICAgICAgICAgbGVuICs9IDE7XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXHJcbiAgICAgICAgICAgIGxlbiArPSAyO1xyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhGQzAwKSA9PT0gMHhEODAwICYmIChzdHJpbmcuY2hhckNvZGVBdChpICsgMSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBsZW4gKz0gNDtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgbGVuICs9IDM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIFVURjggYnl0ZXMgYXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcclxuICovXHJcbnV0ZjgucmVhZCA9IGZ1bmN0aW9uIHV0ZjhfcmVhZChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcclxuICAgIGlmIChsZW4gPCAxKVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdLFxyXG4gICAgICAgIGkgPSAwLCAvLyBjaGFyIG9mZnNldFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHQgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgaWYgKHQgPCAxMjgpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSB0O1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAxOTEgJiYgdCA8IDIyNClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMzEpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBlbHNlIGlmICh0ID4gMjM5ICYmIHQgPCAzNjUpIHtcclxuICAgICAgICAgICAgdCA9ICgodCAmIDcpIDw8IDE4IHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzKSAtIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweEQ4MDAgKyAodCA+PiAxMCk7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweERDMDAgKyAodCAmIDEwMjMpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAxNSkgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzdHJpbmcgYXMgVVRGOCBieXRlcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlcyB3cml0dGVuXHJcbiAqL1xyXG51dGY4LndyaXRlID0gZnVuY3Rpb24gdXRmOF93cml0ZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgYzEsIC8vIGNoYXJhY3RlciAxXHJcbiAgICAgICAgYzI7IC8vIGNoYXJhY3RlciAyXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGMxIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgICAgICB8IDE5MjtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKChjMiA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgYzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNGRikgPDwgMTApICsgKGMyICYgMHgwM0ZGKTtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTggICAgICB8IDI0MDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgICAgICB8IDIyNDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuIiwiLyplc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUsIG5vLWNvbnRyb2wtcmVnZXgsIG5vLXByb3RvdHlwZS1idWlsdGlucyovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRwcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIik7XG5cbnZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlciwgJHV0aWwgPSAkcHJvdG9idWYudXRpbDtcblxudmFyICRyb290ID0gJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSB8fCAoJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSA9IHt9KTtcblxuJHJvb3QudGVuc29yZmxvdyA9IChmdW5jdGlvbigpIHtcblxuICAgIHZhciB0ZW5zb3JmbG93ID0ge307XG5cbiAgICB0ZW5zb3JmbG93LkFueSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBBbnkocCkge1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgQW55LnByb3RvdHlwZS50eXBlVXJsID0gXCJcIjtcbiAgICAgICAgQW55LnByb3RvdHlwZS52YWx1ZSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgQW55LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LkFueSgpO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZVVybCA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbS52YWx1ZSA9IHIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBBbnk7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuRGF0YVR5cGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJEVF9JTlZBTElEXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIkRUX0ZMT0FUXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIkRUX0RPVUJMRVwiXSA9IDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJEVF9JTlQzMlwiXSA9IDM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJEVF9VSU5UOFwiXSA9IDQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJEVF9JTlQxNlwiXSA9IDU7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzZdID0gXCJEVF9JTlQ4XCJdID0gNjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIkRUX1NUUklOR1wiXSA9IDc7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzhdID0gXCJEVF9DT01QTEVYNjRcIl0gPSA4O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs5XSA9IFwiRFRfSU5UNjRcIl0gPSA5O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMF0gPSBcIkRUX0JPT0xcIl0gPSAxMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTFdID0gXCJEVF9RSU5UOFwiXSA9IDExO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMl0gPSBcIkRUX1FVSU5UOFwiXSA9IDEyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxM10gPSBcIkRUX1FJTlQzMlwiXSA9IDEzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxNF0gPSBcIkRUX0JGTE9BVDE2XCJdID0gMTQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwMV0gPSBcIkRUX0ZMT0FUX1JFRlwiXSA9IDEwMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTAyXSA9IFwiRFRfRE9VQkxFX1JFRlwiXSA9IDEwMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTAzXSA9IFwiRFRfSU5UMzJfUkVGXCJdID0gMTAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMDRdID0gXCJEVF9VSU5UOF9SRUZcIl0gPSAxMDQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwNV0gPSBcIkRUX0lOVDE2X1JFRlwiXSA9IDEwNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTA2XSA9IFwiRFRfSU5UOF9SRUZcIl0gPSAxMDY7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwN10gPSBcIkRUX1NUUklOR19SRUZcIl0gPSAxMDc7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwOF0gPSBcIkRUX0NPTVBMRVg2NF9SRUZcIl0gPSAxMDg7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwOV0gPSBcIkRUX0lOVDY0X1JFRlwiXSA9IDEwOTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTEwXSA9IFwiRFRfQk9PTF9SRUZcIl0gPSAxMTA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExMV0gPSBcIkRUX1FJTlQ4X1JFRlwiXSA9IDExMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTEyXSA9IFwiRFRfUVVJTlQ4X1JFRlwiXSA9IDExMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTEzXSA9IFwiRFRfUUlOVDMyX1JFRlwiXSA9IDExMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTE0XSA9IFwiRFRfQkZMT0FUMTZfUkVGXCJdID0gMTE0O1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LlRlbnNvclNoYXBlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvclNoYXBlKHApIHtcbiAgICAgICAgICAgIHRoaXMuZGltID0gW107XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBUZW5zb3JTaGFwZS5wcm90b3R5cGUuZGltID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGVuc29yU2hhcGUucHJvdG90eXBlLnVua25vd25SYW5rID0gZmFsc2U7XG5cbiAgICAgICAgVGVuc29yU2hhcGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuVGVuc29yU2hhcGUoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLmRpbSAmJiBtLmRpbS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5kaW0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbS5kaW0ucHVzaCgkcm9vdC50ZW5zb3JmbG93LlRlbnNvclNoYXBlLkRpbS5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG0udW5rbm93blJhbmsgPSByLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRlbnNvclNoYXBlLkRpbSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRGltKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIERpbS5wcm90b3R5cGUuc2l6ZSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuICAgICAgICAgICAgRGltLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAgICAgRGltLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LlRlbnNvclNoYXBlLkRpbSgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zaXplID0gci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gRGltO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBUZW5zb3JTaGFwZTtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5UZW5zb3IgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gVGVuc29yKHApIHtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRWYWwgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZG91YmxlVmFsID0gW107XG4gICAgICAgICAgICB0aGlzLmludFZhbCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdWYWwgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2NvbXBsZXhWYWwgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50NjRWYWwgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYm9vbFZhbCA9IFtdO1xuICAgICAgICAgICAgdGhpcy51aW50MzJWYWwgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudWludDY0VmFsID0gW107XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBUZW5zb3IucHJvdG90eXBlLmR0eXBlID0gMDtcbiAgICAgICAgVGVuc29yLnByb3RvdHlwZS50ZW5zb3JTaGFwZSA9IG51bGw7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUudmVyc2lvbk51bWJlciA9IDA7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUudGVuc29yQ29udGVudCA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUuZmxvYXRWYWwgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBUZW5zb3IucHJvdG90eXBlLmRvdWJsZVZhbCA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUuaW50VmFsID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGVuc29yLnByb3RvdHlwZS5zdHJpbmdWYWwgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBUZW5zb3IucHJvdG90eXBlLnNjb21wbGV4VmFsID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGVuc29yLnByb3RvdHlwZS5pbnQ2NFZhbCA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUuYm9vbFZhbCA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRlbnNvci5wcm90b3R5cGUudWludDMyVmFsID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGVuc29yLnByb3RvdHlwZS51aW50NjRWYWwgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIFRlbnNvci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5UZW5zb3IoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLmR0eXBlID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG0udGVuc29yU2hhcGUgPSAkcm9vdC50ZW5zb3JmbG93LlRlbnNvclNoYXBlLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtLnZlcnNpb25OdW1iZXIgPSByLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbS50ZW5zb3JDb250ZW50ID0gci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uZmxvYXRWYWwgJiYgbS5mbG9hdFZhbC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5mbG9hdFZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5mbG9hdFZhbC5wdXNoKHIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5mbG9hdFZhbC5wdXNoKHIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5kb3VibGVWYWwgJiYgbS5kb3VibGVWYWwubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZG91YmxlVmFsID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmRvdWJsZVZhbC5wdXNoKHIuZG91YmxlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZG91YmxlVmFsLnB1c2goci5kb3VibGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5pbnRWYWwgJiYgbS5pbnRWYWwubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uaW50VmFsID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmludFZhbC5wdXNoKHIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5pbnRWYWwucHVzaChyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uc3RyaW5nVmFsICYmIG0uc3RyaW5nVmFsLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnN0cmluZ1ZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLnN0cmluZ1ZhbC5wdXNoKHIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5zY29tcGxleFZhbCAmJiBtLnNjb21wbGV4VmFsLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjb21wbGV4VmFsID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNjb21wbGV4VmFsLnB1c2goci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjb21wbGV4VmFsLnB1c2goci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5pbnQ2NFZhbCAmJiBtLmludDY0VmFsLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmludDY0VmFsID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmludDY0VmFsLnB1c2goci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmludDY0VmFsLnB1c2goci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5ib29sVmFsICYmIG0uYm9vbFZhbC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5ib29sVmFsID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmJvb2xWYWwucHVzaChyLmJvb2woKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5ib29sVmFsLnB1c2goci5ib29sKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnVpbnQzMlZhbCAmJiBtLnVpbnQzMlZhbC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS51aW50MzJWYWwgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0ICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udWludDMyVmFsLnB1c2goci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbS51aW50MzJWYWwucHVzaChyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS51aW50NjRWYWwgJiYgbS51aW50NjRWYWwubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udWludDY0VmFsID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnVpbnQ2NFZhbC5wdXNoKHIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udWludDY0VmFsLnB1c2goci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVGVuc29yO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LkF0dHJWYWx1ZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBBdHRyVmFsdWUocCkge1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgQXR0clZhbHVlLnByb3RvdHlwZS5saXN0ID0gbnVsbDtcbiAgICAgICAgQXR0clZhbHVlLnByb3RvdHlwZS5zID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcbiAgICAgICAgQXR0clZhbHVlLnByb3RvdHlwZS5pID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG4gICAgICAgIEF0dHJWYWx1ZS5wcm90b3R5cGUuZiA9IDA7XG4gICAgICAgIEF0dHJWYWx1ZS5wcm90b3R5cGUuYiA9IGZhbHNlO1xuICAgICAgICBBdHRyVmFsdWUucHJvdG90eXBlLnR5cGUgPSAwO1xuICAgICAgICBBdHRyVmFsdWUucHJvdG90eXBlLnNoYXBlID0gbnVsbDtcbiAgICAgICAgQXR0clZhbHVlLnByb3RvdHlwZS50ZW5zb3IgPSBudWxsO1xuICAgICAgICBBdHRyVmFsdWUucHJvdG90eXBlLnBsYWNlaG9sZGVyID0gXCJcIjtcbiAgICAgICAgQXR0clZhbHVlLnByb3RvdHlwZS5mdW5jID0gbnVsbDtcblxuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdHRyVmFsdWUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wibGlzdFwiLCBcInNcIiwgXCJpXCIsIFwiZlwiLCBcImJcIiwgXCJ0eXBlXCIsIFwic2hhcGVcIiwgXCJ0ZW5zb3JcIiwgXCJwbGFjZWhvbGRlclwiLCBcImZ1bmNcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIEF0dHJWYWx1ZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLmxpc3QgPSAkcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5MaXN0VmFsdWUuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG0ucyA9IHIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtLmkgPSByLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbS5mID0gci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG0uYiA9IHIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9IHIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtLnNoYXBlID0gJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbS50ZW5zb3IgPSAkcm9vdC50ZW5zb3JmbG93LlRlbnNvci5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgbS5wbGFjZWhvbGRlciA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIG0uZnVuYyA9ICRyb290LnRlbnNvcmZsb3cuTmFtZUF0dHJMaXN0LmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIEF0dHJWYWx1ZS5MaXN0VmFsdWUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIExpc3RWYWx1ZShwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5pID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5mID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5iID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMudGVuc29yID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5mdW5jID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBMaXN0VmFsdWUucHJvdG90eXBlLnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICAgICAgTGlzdFZhbHVlLnByb3RvdHlwZS5pID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUuZiA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgICAgICBMaXN0VmFsdWUucHJvdG90eXBlLmIgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICAgICAgTGlzdFZhbHVlLnByb3RvdHlwZS50eXBlID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUuc2hhcGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICAgICAgTGlzdFZhbHVlLnByb3RvdHlwZS50ZW5zb3IgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICAgICAgTGlzdFZhbHVlLnByb3RvdHlwZS5mdW5jID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgTGlzdFZhbHVlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5MaXN0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG0ucyAmJiBtLnMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucy5wdXNoKHIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5pICYmIG0uaS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uaSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0ICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uaS5wdXNoKHIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmkucHVzaChyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG0uZiAmJiBtLmYubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmYgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLmYucHVzaChyLmZsb2F0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5mLnB1c2goci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLmIgJiYgbS5iLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5iID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5iLnB1c2goci5ib29sKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5iLnB1c2goci5ib29sKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG0udHlwZSAmJiBtLnR5cGUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnR5cGUucHVzaChyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlLnB1c2goci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnNoYXBlICYmIG0uc2hhcGUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNoYXBlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNoYXBlLnB1c2goJHJvb3QudGVuc29yZmxvdy5UZW5zb3JTaGFwZS5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG0udGVuc29yICYmIG0udGVuc29yLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS50ZW5zb3IgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udGVuc29yLnB1c2goJHJvb3QudGVuc29yZmxvdy5UZW5zb3IuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLmZ1bmMgJiYgbS5mdW5jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5mdW5jID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmZ1bmMucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk5hbWVBdHRyTGlzdC5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIExpc3RWYWx1ZTtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gQXR0clZhbHVlO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93Lk5hbWVBdHRyTGlzdCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBOYW1lQXR0ckxpc3QocCkge1xuICAgICAgICAgICAgdGhpcy5hdHRyID0ge307XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBOYW1lQXR0ckxpc3QucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuICAgICAgICBOYW1lQXR0ckxpc3QucHJvdG90eXBlLmF0dHIgPSAkdXRpbC5lbXB0eU9iamVjdDtcblxuICAgICAgICBOYW1lQXR0ckxpc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuTmFtZUF0dHJMaXN0KCksIGs7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbS5uYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByLnNraXAoKS5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uYXR0ciA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmF0dHIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgayA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHIucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIG0uYXR0cltrXSA9ICRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBOYW1lQXR0ckxpc3Q7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuTm9kZURlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBOb2RlRGVmKHApIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYXR0ciA9IHt9O1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgTm9kZURlZi5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG4gICAgICAgIE5vZGVEZWYucHJvdG90eXBlLm9wID0gXCJcIjtcbiAgICAgICAgTm9kZURlZi5wcm90b3R5cGUuaW5wdXQgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBOb2RlRGVmLnByb3RvdHlwZS5kZXZpY2UgPSBcIlwiO1xuICAgICAgICBOb2RlRGVmLnByb3RvdHlwZS5hdHRyID0gJHV0aWwuZW1wdHlPYmplY3Q7XG5cbiAgICAgICAgTm9kZURlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5Ob2RlRGVmKCksIGs7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbS5uYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtLm9wID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLmlucHV0ICYmIG0uaW5wdXQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbS5pbnB1dC5wdXNoKHIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG0uZGV2aWNlID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByLnNraXAoKS5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uYXR0ciA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmF0dHIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgayA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHIucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIG0uYXR0cltrXSA9ICRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBOb2RlRGVmO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LlZlcnNpb25EZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gVmVyc2lvbkRlZihwKSB7XG4gICAgICAgICAgICB0aGlzLmJhZENvbnN1bWVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgVmVyc2lvbkRlZi5wcm90b3R5cGUucHJvZHVjZXIgPSAwO1xuICAgICAgICBWZXJzaW9uRGVmLnByb3RvdHlwZS5taW5Db25zdW1lciA9IDA7XG4gICAgICAgIFZlcnNpb25EZWYucHJvdG90eXBlLmJhZENvbnN1bWVycyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgVmVyc2lvbkRlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5WZXJzaW9uRGVmKCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbS5wcm9kdWNlciA9IHIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtLm1pbkNvbnN1bWVyID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uYmFkQ29uc3VtZXJzICYmIG0uYmFkQ29uc3VtZXJzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmJhZENvbnN1bWVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5iYWRDb25zdW1lcnMucHVzaChyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYmFkQ29uc3VtZXJzLnB1c2goci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBWZXJzaW9uRGVmO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LkdyYXBoRGVmID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIEdyYXBoRGVmKHApIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IFtdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgR3JhcGhEZWYucHJvdG90eXBlLm5vZGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBHcmFwaERlZi5wcm90b3R5cGUudmVyc2lvbnMgPSBudWxsO1xuICAgICAgICBHcmFwaERlZi5wcm90b3R5cGUubGlicmFyeSA9IG51bGw7XG5cbiAgICAgICAgR3JhcGhEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuR3JhcGhEZWYoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtLm5vZGUgJiYgbS5ub2RlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbS5ub2RlLnB1c2goJHJvb3QudGVuc29yZmxvdy5Ob2RlRGVmLmRlY29kZShyLCByLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbS52ZXJzaW9ucyA9ICRyb290LnRlbnNvcmZsb3cuVmVyc2lvbkRlZi5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbS5saWJyYXJ5ID0gJHJvb3QudGVuc29yZmxvdy5GdW5jdGlvbkRlZkxpYnJhcnkuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEdyYXBoRGVmO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbkRlZihwKSB7XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBDb2xsZWN0aW9uRGVmLnByb3RvdHlwZS5ub2RlTGlzdCA9IG51bGw7XG4gICAgICAgIENvbGxlY3Rpb25EZWYucHJvdG90eXBlLmJ5dGVzTGlzdCA9IG51bGw7XG4gICAgICAgIENvbGxlY3Rpb25EZWYucHJvdG90eXBlLmludDY0TGlzdCA9IG51bGw7XG4gICAgICAgIENvbGxlY3Rpb25EZWYucHJvdG90eXBlLmZsb2F0TGlzdCA9IG51bGw7XG4gICAgICAgIENvbGxlY3Rpb25EZWYucHJvdG90eXBlLmFueUxpc3QgPSBudWxsO1xuXG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbGxlY3Rpb25EZWYucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJub2RlTGlzdFwiLCBcImJ5dGVzTGlzdFwiLCBcImludDY0TGlzdFwiLCBcImZsb2F0TGlzdFwiLCBcImFueUxpc3RcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIENvbGxlY3Rpb25EZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZigpO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0ubm9kZUxpc3QgPSAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuTm9kZUxpc3QuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG0uYnl0ZXNMaXN0ID0gJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLkJ5dGVzTGlzdC5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbS5pbnQ2NExpc3QgPSAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuSW50NjRMaXN0LmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtLmZsb2F0TGlzdCA9ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5GbG9hdExpc3QuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG0uYW55TGlzdCA9ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5BbnlMaXN0LmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIENvbGxlY3Rpb25EZWYuTm9kZUxpc3QgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE5vZGVMaXN0KHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOb2RlTGlzdC5wcm90b3R5cGUudmFsdWUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICBOb2RlTGlzdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLk5vZGVMaXN0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnZhbHVlICYmIG0udmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlLnB1c2goci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gTm9kZUxpc3Q7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgQ29sbGVjdGlvbkRlZi5CeXRlc0xpc3QgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJ5dGVzTGlzdChwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQnl0ZXNMaXN0LnByb3RvdHlwZS52YWx1ZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgIEJ5dGVzTGlzdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5Db2xsZWN0aW9uRGVmLkJ5dGVzTGlzdCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS52YWx1ZSAmJiBtLnZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZS5wdXNoKHIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gQnl0ZXNMaXN0O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIENvbGxlY3Rpb25EZWYuSW50NjRMaXN0ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbnQ2NExpc3QocCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEludDY0TGlzdC5wcm90b3R5cGUudmFsdWUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICBJbnQ2NExpc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5JbnQ2NExpc3QoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG0udmFsdWUgJiYgbS52YWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodCAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMyID0gci51aW50MzIoKSArIHIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlLnB1c2goci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udmFsdWUucHVzaChyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIEludDY0TGlzdDtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBDb2xsZWN0aW9uRGVmLkZsb2F0TGlzdCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRmxvYXRMaXN0KHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBGbG9hdExpc3QucHJvdG90eXBlLnZhbHVlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgRmxvYXRMaXN0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LkNvbGxlY3Rpb25EZWYuRmxvYXRMaXN0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnZhbHVlICYmIG0udmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMiA9IHIudWludDMyKCkgKyByLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZS5wdXNoKHIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlLnB1c2goci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBGbG9hdExpc3Q7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgQ29sbGVjdGlvbkRlZi5BbnlMaXN0ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBBbnlMaXN0KHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBbnlMaXN0LnByb3RvdHlwZS52YWx1ZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgIEFueUxpc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5BbnlMaXN0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtLnZhbHVlICYmIG0udmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnZhbHVlLnB1c2goJHJvb3QudGVuc29yZmxvdy5BbnkuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBBbnlMaXN0O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBDb2xsZWN0aW9uRGVmO1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93LlNhdmVyRGVmID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIFNhdmVyRGVmKHApIHtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIFNhdmVyRGVmLnByb3RvdHlwZS5maWxlbmFtZVRlbnNvck5hbWUgPSBcIlwiO1xuICAgICAgICBTYXZlckRlZi5wcm90b3R5cGUuc2F2ZVRlbnNvck5hbWUgPSBcIlwiO1xuICAgICAgICBTYXZlckRlZi5wcm90b3R5cGUucmVzdG9yZU9wTmFtZSA9IFwiXCI7XG4gICAgICAgIFNhdmVyRGVmLnByb3RvdHlwZS5tYXhUb0tlZXAgPSAwO1xuICAgICAgICBTYXZlckRlZi5wcm90b3R5cGUuc2hhcmRlZCA9IGZhbHNlO1xuICAgICAgICBTYXZlckRlZi5wcm90b3R5cGUua2VlcENoZWNrcG9pbnRFdmVyeU5Ib3VycyA9IDA7XG4gICAgICAgIFNhdmVyRGVmLnByb3RvdHlwZS52ZXJzaW9uID0gMDtcblxuICAgICAgICBTYXZlckRlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5TYXZlckRlZigpO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0uZmlsZW5hbWVUZW5zb3JOYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtLnNhdmVUZW5zb3JOYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtLnJlc3RvcmVPcE5hbWUgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG0ubWF4VG9LZWVwID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG0uc2hhcmRlZCA9IHIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG0ua2VlcENoZWNrcG9pbnRFdmVyeU5Ib3VycyA9IHIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtLnZlcnNpb24gPSByLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICBTYXZlckRlZi5DaGVja3BvaW50Rm9ybWF0VmVyc2lvbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiTEVHQUNZXCJdID0gMDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJWMVwiXSA9IDE7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiVjJcIl0gPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gU2F2ZXJEZWY7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuVGVuc29ySW5mbyA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBUZW5zb3JJbmZvKHApIHtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIFRlbnNvckluZm8ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuICAgICAgICBUZW5zb3JJbmZvLnByb3RvdHlwZS5jb29TcGFyc2UgPSBudWxsO1xuICAgICAgICBUZW5zb3JJbmZvLnByb3RvdHlwZS5kdHlwZSA9IDA7XG4gICAgICAgIFRlbnNvckluZm8ucHJvdG90eXBlLnRlbnNvclNoYXBlID0gbnVsbDtcblxuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW5zb3JJbmZvLnByb3RvdHlwZSwgXCJlbmNvZGluZ1wiLCB7XG4gICAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcIm5hbWVcIiwgXCJjb29TcGFyc2VcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIFRlbnNvckluZm8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuVGVuc29ySW5mbygpO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0ubmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbS5jb29TcGFyc2UgPSAkcm9vdC50ZW5zb3JmbG93LlRlbnNvckluZm8uQ29vU3BhcnNlLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtLmR0eXBlID0gci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG0udGVuc29yU2hhcGUgPSAkcm9vdC50ZW5zb3JmbG93LlRlbnNvclNoYXBlLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRlbnNvckluZm8uQ29vU3BhcnNlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBDb29TcGFyc2UocCkge1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQ29vU3BhcnNlLnByb3RvdHlwZS52YWx1ZXNUZW5zb3JOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIENvb1NwYXJzZS5wcm90b3R5cGUuaW5kaWNlc1RlbnNvck5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgQ29vU3BhcnNlLnByb3RvdHlwZS5kZW5zZVNoYXBlVGVuc29yTmFtZSA9IFwiXCI7XG5cbiAgICAgICAgICAgIENvb1NwYXJzZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLkNvb1NwYXJzZSgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZXNUZW5zb3JOYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmluZGljZXNUZW5zb3JOYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmRlbnNlU2hhcGVUZW5zb3JOYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBDb29TcGFyc2U7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvckluZm87XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuU2lnbmF0dXJlRGVmID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIFNpZ25hdHVyZURlZihwKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRzID0ge307XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBTaWduYXR1cmVEZWYucHJvdG90eXBlLmlucHV0cyA9ICR1dGlsLmVtcHR5T2JqZWN0O1xuICAgICAgICBTaWduYXR1cmVEZWYucHJvdG90eXBlLm91dHB1dHMgPSAkdXRpbC5lbXB0eU9iamVjdDtcbiAgICAgICAgU2lnbmF0dXJlRGVmLnByb3RvdHlwZS5tZXRob2ROYW1lID0gXCJcIjtcblxuICAgICAgICBTaWduYXR1cmVEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuU2lnbmF0dXJlRGVmKCksIGs7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwKCkucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLmlucHV0cyA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmlucHV0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBrID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgci5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgbS5pbnB1dHNba10gPSAkcm9vdC50ZW5zb3JmbG93LlRlbnNvckluZm8uZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcCgpLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5vdXRwdXRzID09PSAkdXRpbC5lbXB0eU9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ub3V0cHV0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBrID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgci5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgbS5vdXRwdXRzW2tdID0gJHJvb3QudGVuc29yZmxvdy5UZW5zb3JJbmZvLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtLm1ldGhvZE5hbWUgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZURlZjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5Bc3NldEZpbGVEZWYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gQXNzZXRGaWxlRGVmKHApIHtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2V0RmlsZURlZi5wcm90b3R5cGUudGVuc29ySW5mbyA9IG51bGw7XG4gICAgICAgIEFzc2V0RmlsZURlZi5wcm90b3R5cGUuZmlsZW5hbWUgPSBcIlwiO1xuXG4gICAgICAgIEFzc2V0RmlsZURlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5Bc3NldEZpbGVEZWYoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLnRlbnNvckluZm8gPSAkcm9vdC50ZW5zb3JmbG93LlRlbnNvckluZm8uZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG0uZmlsZW5hbWUgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEFzc2V0RmlsZURlZjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5PcERlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBPcERlZihwKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0QXJnID0gW107XG4gICAgICAgICAgICB0aGlzLm91dHB1dEFyZyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hdHRyID0gW107XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBPcERlZi5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5pbnB1dEFyZyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5vdXRwdXRBcmcgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBPcERlZi5wcm90b3R5cGUuYXR0ciA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5kZXByZWNhdGlvbiA9IG51bGw7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5zdW1tYXJ5ID0gXCJcIjtcbiAgICAgICAgT3BEZWYucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICAgICAgT3BEZWYucHJvdG90eXBlLmlzQ29tbXV0YXRpdmUgPSBmYWxzZTtcbiAgICAgICAgT3BEZWYucHJvdG90eXBlLmlzQWdncmVnYXRlID0gZmFsc2U7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5pc1N0YXRlZnVsID0gZmFsc2U7XG4gICAgICAgIE9wRGVmLnByb3RvdHlwZS5hbGxvd3NVbmluaXRpYWxpemVkSW5wdXQgPSBmYWxzZTtcblxuICAgICAgICBPcERlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5PcERlZigpO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0ubmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5pbnB1dEFyZyAmJiBtLmlucHV0QXJnLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmlucHV0QXJnID0gW107XG4gICAgICAgICAgICAgICAgICAgIG0uaW5wdXRBcmcucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLkFyZ0RlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0ub3V0cHV0QXJnICYmIG0ub3V0cHV0QXJnLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm91dHB1dEFyZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLm91dHB1dEFyZy5wdXNoKCRyb290LnRlbnNvcmZsb3cuT3BEZWYuQXJnRGVmLmRlY29kZShyLCByLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5hdHRyICYmIG0uYXR0ci5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hdHRyID0gW107XG4gICAgICAgICAgICAgICAgICAgIG0uYXR0ci5wdXNoKCRyb290LnRlbnNvcmZsb3cuT3BEZWYuQXR0ckRlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG0uZGVwcmVjYXRpb24gPSAkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLk9wRGVwcmVjYXRpb24uZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG0uc3VtbWFyeSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbS5kZXNjcmlwdGlvbiA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgIG0uaXNDb21tdXRhdGl2ZSA9IHIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICBtLmlzQWdncmVnYXRlID0gci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgIG0uaXNTdGF0ZWZ1bCA9IHIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICBtLmFsbG93c1VuaW5pdGlhbGl6ZWRJbnB1dCA9IHIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgT3BEZWYuQXJnRGVmID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBBcmdEZWYocCkge1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXJnRGVmLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgIEFyZ0RlZi5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBcIlwiO1xuICAgICAgICAgICAgQXJnRGVmLnByb3RvdHlwZS50eXBlID0gMDtcbiAgICAgICAgICAgIEFyZ0RlZi5wcm90b3R5cGUudHlwZUF0dHIgPSBcIlwiO1xuICAgICAgICAgICAgQXJnRGVmLnByb3RvdHlwZS5udW1iZXJBdHRyID0gXCJcIjtcbiAgICAgICAgICAgIEFyZ0RlZi5wcm90b3R5cGUudHlwZUxpc3RBdHRyID0gXCJcIjtcbiAgICAgICAgICAgIEFyZ0RlZi5wcm90b3R5cGUuaXNSZWYgPSBmYWxzZTtcblxuICAgICAgICAgICAgQXJnRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLkFyZ0RlZigpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5uYW1lID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmRlc2NyaXB0aW9uID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPSByLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlQXR0ciA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5udW1iZXJBdHRyID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnR5cGVMaXN0QXR0ciA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uaXNSZWYgPSByLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBBcmdEZWY7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgT3BEZWYuQXR0ckRlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQXR0ckRlZihwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBdHRyRGVmLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgIEF0dHJEZWYucHJvdG90eXBlLnR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgQXR0ckRlZi5wcm90b3R5cGUuZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIEF0dHJEZWYucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICAgICAgICAgIEF0dHJEZWYucHJvdG90eXBlLmhhc01pbmltdW0gPSBmYWxzZTtcbiAgICAgICAgICAgIEF0dHJEZWYucHJvdG90eXBlLm1pbmltdW0gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcbiAgICAgICAgICAgIEF0dHJEZWYucHJvdG90eXBlLmFsbG93ZWRWYWx1ZXMgPSBudWxsO1xuXG4gICAgICAgICAgICBBdHRyRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLkF0dHJEZWYoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS50eXBlID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmRlZmF1bHRWYWx1ZSA9ICRyb290LnRlbnNvcmZsb3cuQXR0clZhbHVlLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmRlc2NyaXB0aW9uID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmhhc01pbmltdW0gPSByLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLm1pbmltdW0gPSByLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hbGxvd2VkVmFsdWVzID0gJHJvb3QudGVuc29yZmxvdy5BdHRyVmFsdWUuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIEF0dHJEZWY7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgT3BEZWYuT3BEZXByZWNhdGlvbiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gT3BEZXByZWNhdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPcERlcHJlY2F0aW9uLnByb3RvdHlwZS52ZXJzaW9uID0gMDtcbiAgICAgICAgICAgIE9wRGVwcmVjYXRpb24ucHJvdG90eXBlLmV4cGxhbmF0aW9uID0gXCJcIjtcblxuICAgICAgICAgICAgT3BEZXByZWNhdGlvbi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5PcERlZi5PcERlcHJlY2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnZlcnNpb24gPSByLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5leHBsYW5hdGlvbiA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gT3BEZXByZWNhdGlvbjtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gT3BEZWY7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuT3BMaXN0ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIE9wTGlzdChwKSB7XG4gICAgICAgICAgICB0aGlzLm9wID0gW107XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBPcExpc3QucHJvdG90eXBlLm9wID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICBPcExpc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuT3BMaXN0KCk7XG4gICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5vcCAmJiBtLm9wLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm9wID0gW107XG4gICAgICAgICAgICAgICAgICAgIG0ub3AucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk9wRGVmLmRlY29kZShyLCByLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gT3BMaXN0O1xuICAgIH0pKCk7XG5cbiAgICB0ZW5zb3JmbG93Lk1ldGFHcmFwaERlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBNZXRhR3JhcGhEZWYocCkge1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uRGVmID0ge307XG4gICAgICAgICAgICB0aGlzLnNpZ25hdHVyZURlZiA9IHt9O1xuICAgICAgICAgICAgdGhpcy5hc3NldEZpbGVEZWYgPSBbXTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIE1ldGFHcmFwaERlZi5wcm90b3R5cGUubWV0YUluZm9EZWYgPSBudWxsO1xuICAgICAgICBNZXRhR3JhcGhEZWYucHJvdG90eXBlLmdyYXBoRGVmID0gbnVsbDtcbiAgICAgICAgTWV0YUdyYXBoRGVmLnByb3RvdHlwZS5zYXZlckRlZiA9IG51bGw7XG4gICAgICAgIE1ldGFHcmFwaERlZi5wcm90b3R5cGUuY29sbGVjdGlvbkRlZiA9ICR1dGlsLmVtcHR5T2JqZWN0O1xuICAgICAgICBNZXRhR3JhcGhEZWYucHJvdG90eXBlLnNpZ25hdHVyZURlZiA9ICR1dGlsLmVtcHR5T2JqZWN0O1xuICAgICAgICBNZXRhR3JhcGhEZWYucHJvdG90eXBlLmFzc2V0RmlsZURlZiA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgTWV0YUdyYXBoRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93Lk1ldGFHcmFwaERlZigpLCBrO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0ubWV0YUluZm9EZWYgPSAkcm9vdC50ZW5zb3JmbG93Lk1ldGFHcmFwaERlZi5NZXRhSW5mb0RlZi5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbS5ncmFwaERlZiA9ICRyb290LnRlbnNvcmZsb3cuR3JhcGhEZWYuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG0uc2F2ZXJEZWYgPSAkcm9vdC50ZW5zb3JmbG93LlNhdmVyRGVmLmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXAoKS5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uY29sbGVjdGlvbkRlZiA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmNvbGxlY3Rpb25EZWYgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgayA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHIucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIG0uY29sbGVjdGlvbkRlZltrXSA9ICRyb290LnRlbnNvcmZsb3cuQ29sbGVjdGlvbkRlZi5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwKCkucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLnNpZ25hdHVyZURlZiA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNpZ25hdHVyZURlZiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBrID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgci5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgbS5zaWduYXR1cmVEZWZba10gPSAkcm9vdC50ZW5zb3JmbG93LlNpZ25hdHVyZURlZi5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5hc3NldEZpbGVEZWYgJiYgbS5hc3NldEZpbGVEZWYubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYXNzZXRGaWxlRGVmID0gW107XG4gICAgICAgICAgICAgICAgICAgIG0uYXNzZXRGaWxlRGVmLnB1c2goJHJvb3QudGVuc29yZmxvdy5Bc3NldEZpbGVEZWYuZGVjb2RlKHIsIHIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIE1ldGFHcmFwaERlZi5NZXRhSW5mb0RlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gTWV0YUluZm9EZWYocCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTWV0YUluZm9EZWYucHJvdG90eXBlLm1ldGFHcmFwaFZlcnNpb24gPSBcIlwiO1xuICAgICAgICAgICAgTWV0YUluZm9EZWYucHJvdG90eXBlLnN0cmlwcGVkT3BMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIE1ldGFJbmZvRGVmLnByb3RvdHlwZS5hbnlJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIE1ldGFJbmZvRGVmLnByb3RvdHlwZS50YWdzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICAgIE1ldGFJbmZvRGVmLnByb3RvdHlwZS50ZW5zb3JmbG93VmVyc2lvbiA9IFwiXCI7XG4gICAgICAgICAgICBNZXRhSW5mb0RlZi5wcm90b3R5cGUudGVuc29yZmxvd0dpdFZlcnNpb24gPSBcIlwiO1xuXG4gICAgICAgICAgICBNZXRhSW5mb0RlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5NZXRhR3JhcGhEZWYuTWV0YUluZm9EZWYoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5wb3MgPCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubWV0YUdyYXBoVmVyc2lvbiA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zdHJpcHBlZE9wTGlzdCA9ICRyb290LnRlbnNvcmZsb3cuT3BMaXN0LmRlY29kZShyLCByLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmFueUluZm8gPSAkcm9vdC50ZW5zb3JmbG93LkFueS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobS50YWdzICYmIG0udGFncy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0udGFncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS50YWdzLnB1c2goci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS50ZW5zb3JmbG93VmVyc2lvbiA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgbS50ZW5zb3JmbG93R2l0VmVyc2lvbiA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gTWV0YUluZm9EZWY7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIE1ldGFHcmFwaERlZjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5TYXZlZE1vZGVsID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIFNhdmVkTW9kZWwocCkge1xuICAgICAgICAgICAgdGhpcy5tZXRhR3JhcGhzID0gW107XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBTYXZlZE1vZGVsLnByb3RvdHlwZS5zYXZlZE1vZGVsU2NoZW1hVmVyc2lvbiA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuICAgICAgICBTYXZlZE1vZGVsLnByb3RvdHlwZS5tZXRhR3JhcGhzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICBTYXZlZE1vZGVsLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgICAgICAgICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC50ZW5zb3JmbG93LlNhdmVkTW9kZWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLnNhdmVkTW9kZWxTY2hlbWFWZXJzaW9uID0gci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0ubWV0YUdyYXBocyAmJiBtLm1ldGFHcmFwaHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubWV0YUdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLm1ldGFHcmFwaHMucHVzaCgkcm9vdC50ZW5zb3JmbG93Lk1ldGFHcmFwaERlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFNhdmVkTW9kZWw7XG4gICAgfSkoKTtcblxuICAgIHRlbnNvcmZsb3cuRnVuY3Rpb25EZWZMaWJyYXJ5ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGVmTGlicmFyeShwKSB7XG4gICAgICAgICAgICB0aGlzW1wiZnVuY3Rpb25cIl0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnQgPSBbXTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIEZ1bmN0aW9uRGVmTGlicmFyeS5wcm90b3R5cGVbXCJmdW5jdGlvblwiXSA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIEZ1bmN0aW9uRGVmTGlicmFyeS5wcm90b3R5cGUuZ3JhZGllbnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIEZ1bmN0aW9uRGVmTGlicmFyeS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5GdW5jdGlvbkRlZkxpYnJhcnkoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtW1wiZnVuY3Rpb25cIl0gJiYgbVtcImZ1bmN0aW9uXCJdLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtW1wiZnVuY3Rpb25cIl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbVtcImZ1bmN0aW9uXCJdLnB1c2goJHJvb3QudGVuc29yZmxvdy5GdW5jdGlvbkRlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG0uZ3JhZGllbnQgJiYgbS5ncmFkaWVudC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5ncmFkaWVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtLmdyYWRpZW50LnB1c2goJHJvb3QudGVuc29yZmxvdy5HcmFkaWVudERlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRGVmTGlicmFyeTtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5GdW5jdGlvbkRlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBGdW5jdGlvbkRlZihwKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHIgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubm9kZURlZiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5yZXQgPSB7fTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtzID0gT2JqZWN0LmtleXMocCksIGkgPSAwOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwW2tzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIEZ1bmN0aW9uRGVmLnByb3RvdHlwZS5zaWduYXR1cmUgPSBudWxsO1xuICAgICAgICBGdW5jdGlvbkRlZi5wcm90b3R5cGUuYXR0ciA9ICR1dGlsLmVtcHR5T2JqZWN0O1xuICAgICAgICBGdW5jdGlvbkRlZi5wcm90b3R5cGUubm9kZURlZiA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIEZ1bmN0aW9uRGVmLnByb3RvdHlwZS5yZXQgPSAkdXRpbC5lbXB0eU9iamVjdDtcblxuICAgICAgICBGdW5jdGlvbkRlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgICAgICAgICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICAgICAgICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QudGVuc29yZmxvdy5GdW5jdGlvbkRlZigpLCBrO1xuICAgICAgICAgICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHQgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG0uc2lnbmF0dXJlID0gJHJvb3QudGVuc29yZmxvdy5PcERlZi5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwKCkucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLmF0dHIgPT09ICR1dGlsLmVtcHR5T2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hdHRyID0ge307XG4gICAgICAgICAgICAgICAgICAgIGsgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICByLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBtLmF0dHJba10gPSAkcm9vdC50ZW5zb3JmbG93LkF0dHJWYWx1ZS5kZWNvZGUociwgci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobS5ub2RlRGVmICYmIG0ubm9kZURlZi5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5ub2RlRGVmID0gW107XG4gICAgICAgICAgICAgICAgICAgIG0ubm9kZURlZi5wdXNoKCRyb290LnRlbnNvcmZsb3cuTm9kZURlZi5kZWNvZGUociwgci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHIuc2tpcCgpLnBvcysrO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5yZXQgPT09ICR1dGlsLmVtcHR5T2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5yZXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgayA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHIucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIG0ucmV0W2tdID0gci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBGdW5jdGlvbkRlZjtcbiAgICB9KSgpO1xuXG4gICAgdGVuc29yZmxvdy5HcmFkaWVudERlZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICBmdW5jdGlvbiBHcmFkaWVudERlZihwKSB7XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba3NbaV1dID0gcFtrc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICBHcmFkaWVudERlZi5wcm90b3R5cGUuZnVuY3Rpb25OYW1lID0gXCJcIjtcbiAgICAgICAgR3JhZGllbnREZWYucHJvdG90eXBlLmdyYWRpZW50RnVuYyA9IFwiXCI7XG5cbiAgICAgICAgR3JhZGllbnREZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICAgICAgICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgICAgICAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LnRlbnNvcmZsb3cuR3JhZGllbnREZWYoKTtcbiAgICAgICAgICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtLmZ1bmN0aW9uTmFtZSA9IHIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbS5ncmFkaWVudEZ1bmMgPSByLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEdyYWRpZW50RGVmO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gdGVuc29yZmxvdztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gJHJvb3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFeGVjdXRpb25Db250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeGVjdXRpb25Db250ZXh0KHdlaWdodE1hcCkge1xuICAgICAgICB0aGlzLndlaWdodE1hcCA9IHdlaWdodE1hcDtcbiAgICAgICAgdGhpcy5yb290Q29udGV4dCA9IHsgaWQ6IDAsIGZyYW1lTmFtZTogJycsIGl0ZXJhdGlvbklkOiAwIH07XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBbdGhpcy5yb290Q29udGV4dF07XG4gICAgICAgIHRoaXMubGFzdElkID0gMDtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCk7XG4gICAgfVxuICAgIEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLm5ld0ZyYW1lID0gZnVuY3Rpb24gKGlkLCBmcmFtZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHsgaWQ6IGlkLCBmcmFtZU5hbWU6IGZyYW1lTmFtZSwgaXRlcmF0aW9uSWQ6IDAgfTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZSwgXCJjdXJyZW50Q29udGV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNvbnRleHRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0cyAhPT0gY29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gY29udGV4dHM7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZSwgXCJjdXJyZW50Q29udGV4dElkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudENvbnRleHRJZHNbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZSwgXCJjdXJyZW50Q29udGV4dElkc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cy5zbGljZSgwLCB0aGlzLmNvbnRleHRzLmxlbmd0aCAtIGkpO1xuICAgICAgICAgICAgbmFtZXMucHVzaCh0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKGNvbnRleHRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXMucHVzaCgnJyk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzID0gbmFtZXM7XG4gICAgfTtcbiAgICBFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5jb250ZXh0SWRmb3JDb250ZXh0cyA9IGZ1bmN0aW9uIChjb250ZXh0cykge1xuICAgICAgICByZXR1cm4gY29udGV4dHMgP1xuICAgICAgICAgICAgY29udGV4dHNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiAoY29udGV4dC5pZCA9PT0gMCAmJiBjb250ZXh0Lml0ZXJhdGlvbklkID09PSAwKSA/XG4gICAgICAgICAgICAgICAgJycgOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuZnJhbWVOYW1lICsgXCItXCIgKyBjb250ZXh0Lml0ZXJhdGlvbklkOyB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcvJykgOlxuICAgICAgICAgICAgJyc7XG4gICAgfTtcbiAgICBFeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5lbnRlckZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dHMpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdElkKys7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gdGhpcy5jb250ZXh0cy5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5wdXNoKHRoaXMubmV3RnJhbWUodGhpcy5sYXN0SWQsIGZyYW1lSWQpKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnVuc2hpZnQodGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmV4aXRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dHMgJiYgdGhpcy5jb250ZXh0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gdGhpcy5jb250ZXh0cy5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5zcGxpY2UoLTEpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dElkcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXhpdCBmcmFtZSwgdGhlIGNvbnRleHQgaXMgZW1wdHknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUubmV4dEl0ZXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dHMgJiYgdGhpcy5jb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzID0gdGhpcy5jb250ZXh0cy5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0SWQrKztcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuaXRlcmF0aW9uSWQgKz0gMTtcbiAgICAgICAgICAgIGNvbnRleHQuaWQgPSB0aGlzLmxhc3RJZDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMuc3BsaWNlKC0xLCAxLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnNwbGljZSgwLCAxLCB0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKHRoaXMuY29udGV4dHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGluY3JlYXNlIGZyYW1lIGl0ZXJhdGlvbiwgdGhlIGNvbnRleHQgaXMgZW1wdHknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2V0V2VpZ2h0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0TWFwW25hbWVdO1xuICAgIH07XG4gICAgcmV0dXJuIEV4ZWN1dGlvbkNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5FeGVjdXRpb25Db250ZXh0ID0gRXhlY3V0aW9uQ29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4ZWN1dGlvbl9jb250ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBVcmwgPSByZXF1aXJlKFwidXJsXCIpO1xudmFyIGNvbXBpbGVkX2FwaV8xID0gcmVxdWlyZShcIi4uL2RhdGEvY29tcGlsZWRfYXBpXCIpO1xudmFyIG9wZXJhdGlvbl9tYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9vcGVyYXRpb25zL29wZXJhdGlvbl9tYXBwZXJcIik7XG52YXIgZ3JhcGhfZXhlY3V0b3JfMSA9IHJlcXVpcmUoXCIuL2dyYXBoX2V4ZWN1dG9yXCIpO1xudmFyIEZyb3plbk1vZGVsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcm96ZW5Nb2RlbChtb2RlbFVybCwgd2VpZ2h0TWFuaWZlc3RVcmwsIHJlcXVlc3RPcHRpb24pIHtcbiAgICAgICAgdGhpcy5tb2RlbFVybCA9IG1vZGVsVXJsO1xuICAgICAgICB0aGlzLndlaWdodE1hbmlmZXN0VXJsID0gd2VpZ2h0TWFuaWZlc3RVcmw7XG4gICAgICAgIHRoaXMucmVxdWVzdE9wdGlvbiA9IHJlcXVlc3RPcHRpb247XG4gICAgICAgIHRoaXMudmVyc2lvbiA9ICduL2EnO1xuICAgICAgICB0aGlzLnBhdGhQcmVmaXggPSB0aGlzLmdldFBhdGhQcmVmaXgoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyb3plbk1vZGVsLnByb3RvdHlwZSwgXCJtb2RlbFZlcnNpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcm96ZW5Nb2RlbC5wcm90b3R5cGUsIFwiaW5wdXROb2Rlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0b3IuaW5wdXROb2RlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyb3plbk1vZGVsLnByb3RvdHlwZSwgXCJvdXRwdXROb2Rlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0b3Iub3V0cHV0Tm9kZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZyb3plbk1vZGVsLnByb3RvdHlwZS5nZXRQYXRoUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHRoaXMud2VpZ2h0TWFuaWZlc3RVcmwpO1xuICAgICAgICB2YXIgc2VnbWVudHMgPSB1cmwucGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgc2VnbWVudHMuc3BsaWNlKC0xKTtcbiAgICAgICAgdXJsLnBhdGhuYW1lID0gc2VnbWVudHMuam9pbignLycpO1xuICAgICAgICByZXR1cm4gVXJsLmZvcm1hdCh1cmwpICsgJy8nO1xuICAgIH07XG4gICAgRnJvemVuTW9kZWwucHJvdG90eXBlLmxvYWRSZW1vdGVQcm90b0ZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwgX2EsIF9iLCBfYywgZXJyb3JfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLnRyeXMucHVzaChbMCwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGZldGNoKHRoaXMubW9kZWxVcmwsIHRoaXMucmVxdWVzdE9wdGlvbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gY29tcGlsZWRfYXBpXzEudGVuc29yZmxvdy5HcmFwaERlZikuZGVjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBVaW50OEFycmF5LmJpbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc3BvbnNlLmFycmF5QnVmZmVyKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiwgX2IuYXBwbHkoX2EsIFtuZXcgKF9jLmFwcGx5KFVpbnQ4QXJyYXksIFt2b2lkIDAsIF9kLnNlbnQoKV0pKSgpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMubW9kZWxVcmwgKyBcIiBub3QgZm91bmQuIFwiICsgZXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGcm96ZW5Nb2RlbC5wcm90b3R5cGUubG9hZFdlaWdodE1hbmlmZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFuaWZlc3QsIF9hLCBlcnJvcl8yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZmV0Y2godGhpcy53ZWlnaHRNYW5pZmVzdFVybCwgdGhpcy5yZXF1ZXN0T3B0aW9uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtYW5pZmVzdC5jbG9uZSgpLmpzb24oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLndlaWdodE1hbmlmZXN0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLndlaWdodE1hbmlmZXN0VXJsICsgXCIgbm90IGZvdW5kLiBcIiArIGVycm9yXzIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRnJvemVuTW9kZWwucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBncmFwaFByb21pc2UsIG1hbmlmZXN0UHJvbWlzZSwgZ3JhcGgsIHdlaWdodE1hcDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUHJvbWlzZSA9IHRoaXMubG9hZFJlbW90ZVByb3RvRmlsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3RQcm9taXNlID0gdGhpcy5sb2FkV2VpZ2h0TWFuaWZlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgUHJvbWlzZS5hbGwoW2dyYXBoUHJvbWlzZSwgbWFuaWZlc3RQcm9taXNlXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaCA9IChfYS5zZW50KCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gZ3JhcGgudmVyc2lvbnMucHJvZHVjZXIgKyBcIi5cIiArIGdyYXBoLnZlcnNpb25zLm1pbkNvbnN1bWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0ZmMuaW8ubG9hZFdlaWdodHModGhpcy53ZWlnaHRNYW5pZmVzdCwgdGhpcy5wYXRoUHJlZml4LCB1bmRlZmluZWQsIHRoaXMucmVxdWVzdE9wdGlvbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRNYXAgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dG9yID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgZ3JhcGhfZXhlY3V0b3JfMS5HcmFwaEV4ZWN1dG9yKG9wZXJhdGlvbl9tYXBwZXJfMS5PcGVyYXRpb25NYXBwZXIuSW5zdGFuY2UudHJhbnNmb3JtR3JhcGgoZ3JhcGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0b3Iud2VpZ2h0TWFwID0gdGhpcy5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwKHdlaWdodE1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRydWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZyb3plbk1vZGVsLnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24gKGlucHV0cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoaW5wdXRzLCB0aGlzLm91dHB1dE5vZGVzKTtcbiAgICB9O1xuICAgIEZyb3plbk1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3RUZW5zb3JNYXAgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHZhciBpbnB1dEFycmF5ID0gaW5wdXRzIGluc3RhbmNlb2YgdGZjLlRlbnNvciA/IFtpbnB1dHNdIDogaW5wdXRzO1xuICAgICAgICBpZiAoaW5wdXRBcnJheS5sZW5ndGggIT09IHRoaXMuaW5wdXROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdGVuc29yIGNvdW50IG1pc21hdGNoLCcgK1xuICAgICAgICAgICAgICAgIChcInRoZSBmcm96ZW4gbW9kZWwgaGFzIFwiICsgdGhpcy5pbnB1dE5vZGVzLmxlbmd0aCArIFwiIHBsYWNlaG9sZGVycywgXCIpICtcbiAgICAgICAgICAgICAgICAoXCJ3aGlsZSB0aGVyZSBhcmUgXCIgKyBpbnB1dEFycmF5Lmxlbmd0aCArIFwiIGlucHV0IHRlbnNvcnMuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dE5vZGVzLnJlZHVjZShmdW5jdGlvbiAobWFwLCBpbnB1dE5hbWUsIGkpIHtcbiAgICAgICAgICAgIG1hcFtpbnB1dE5hbWVdID0gaW5wdXRBcnJheVtpXTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIEZyb3plbk1vZGVsLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICBvdXRwdXRzID0gb3V0cHV0cyB8fCB0aGlzLm91dHB1dE5vZGVzO1xuICAgICAgICBpZiAoaW5wdXRzIGluc3RhbmNlb2YgdGZjLlRlbnNvciB8fCBBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IHRoaXMuY29uc3RydWN0VGVuc29yTWFwKGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhlY3V0b3IuaXNDb250cm9sRmxvd01vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtb2RlbCBjb250YWlucyBjb250cm9sIGZsb3cgb3BzLCAnICtcbiAgICAgICAgICAgICAgICAncGxlYXNlIHVzZSBleGVjdXRlQXN5bmMgbWV0aG9kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZXhlY3V0b3IuZXhlY3V0ZSh0aGlzLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAoaW5wdXRzKSwgb3V0cHV0cyk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KG91dHB1dHMpICYmIG91dHB1dHMubGVuZ3RoID4gMSkgP1xuICAgICAgICAgICAgb3V0cHV0cy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHJlc3VsdFtub2RlXTsgfSkgOlxuICAgICAgICAgICAgcmVzdWx0W2tleXNbMF1dO1xuICAgIH07XG4gICAgRnJvemVuTW9kZWwucHJvdG90eXBlLmV4ZWN1dGVBc3luYyA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwga2V5cztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5leGVjdXRvci5pc0NvbnRyb2xGbG93TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtb2RlbCBkb2VzIG5vdCBjb250YWluIGNvbnRyb2wgZmxvdyBvcHMsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxlYXNlIHVzZSBleGVjdXRlIG1ldGhvZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cyA9IG91dHB1dHMgfHwgdGhpcy5vdXRwdXROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgaW5zdGFuY2VvZiB0ZmMuVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoaW5wdXRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cyA9IHRoaXMuY29uc3RydWN0VGVuc29yTWFwKGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZXhlY3V0b3IuZXhlY3V0ZUFzeW5jKHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChpbnB1dHMpLCBvdXRwdXRzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBBcnJheS5pc0FycmF5KG91dHB1dHMpICYmIG91dHB1dHMubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiByZXN1bHRbbm9kZV07IH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleXNbMF1dXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGcm96ZW5Nb2RlbC5wcm90b3R5cGUuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkucmVkdWNlKGZ1bmN0aW9uIChuZXdNYXAsIGtleSkge1xuICAgICAgICAgICAgbmV3TWFwW2tleV0gPSBbbWFwW2tleV1dO1xuICAgICAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgRnJvemVuTW9kZWwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0b3IuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEZyb3plbk1vZGVsO1xufSgpKTtcbmV4cG9ydHMuRnJvemVuTW9kZWwgPSBGcm96ZW5Nb2RlbDtcbmZ1bmN0aW9uIGxvYWRGcm96ZW5Nb2RlbChtb2RlbFVybCwgd2VpZ2h0c01hbmlmZXN0VXJsLCByZXF1ZXN0T3B0aW9uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbW9kZWw7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gbmV3IEZyb3plbk1vZGVsKG1vZGVsVXJsLCB3ZWlnaHRzTWFuaWZlc3RVcmwsIHJlcXVlc3RPcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmxvYWQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbW9kZWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZEZyb3plbk1vZGVsID0gbG9hZEZyb3plbk1vZGVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvemVuX21vZGVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9vcGVyYXRpb25zL2V4ZWN1dG9ycy91dGlsc1wiKTtcbnZhciBvcGVyYXRpb25fZXhlY3V0b3JfMSA9IHJlcXVpcmUoXCIuLi9vcGVyYXRpb25zL29wZXJhdGlvbl9leGVjdXRvclwiKTtcbnZhciBleGVjdXRpb25fY29udGV4dF8xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uX2NvbnRleHRcIik7XG52YXIgR3JhcGhFeGVjdXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhFeGVjdXRvcihncmFwaCkge1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMuY29tcGlsZWRPcmRlciA9IFtdO1xuICAgICAgICB0aGlzLl93ZWlnaHRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBncmFwaC5wbGFjZWhvbGRlcnMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5hbWU7IH0pO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBncmFwaC5vdXRwdXRzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5uYW1lOyB9KTtcbiAgICAgICAgdGhpcy5jb21waWxlKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZSwgXCJ3ZWlnaHRNYXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWlnaHRNYXA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHdlaWdodE1hcCkge1xuICAgICAgICAgICAgdmFyIHdlaWdodElkcyA9IE9iamVjdC5rZXlzKHdlaWdodE1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHdlaWdodE1hcFtrZXldLm1hcChmdW5jdGlvbiAodGVuc29yKSB7IHJldHVybiB0ZW5zb3IuaWQ7IH0pOyB9KTtcbiAgICAgICAgICAgIHRoaXMud2VpZ2h0SWRzID0gW10uY29uY2F0LmFwcGx5KFtdLCB3ZWlnaHRJZHMpO1xuICAgICAgICAgICAgdGhpcy5fd2VpZ2h0TWFwID0gd2VpZ2h0TWFwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhFeGVjdXRvci5wcm90b3R5cGUsIFwiaW5wdXROb2Rlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXJzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhFeGVjdXRvci5wcm90b3R5cGUsIFwib3V0cHV0Tm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dHB1dHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZSwgXCJpc0NvbnRyb2xGbG93TW9kZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyYXBoLndpdGhDb250cm9sRmxvdztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgud2l0aENvbnRyb2xGbG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5ncmFwaC5pbnB1dHMuc2xpY2UoKTtcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB2aXNpdGVkW25vZGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb21waWxlZE9yZGVyLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtjaGlsZE5vZGUubmFtZV0gJiYgY2hpbGROb2RlLmlucHV0TmFtZXMuZXZlcnkoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gdXRpbHNfMS5nZXROb2RlTmFtZUFuZEluZGV4KG5hbWUpWzBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRlZFtub2RlTmFtZV07XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNoZWNrSW5wdXQoaW5wdXRzKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgZXhlY3V0aW9uX2NvbnRleHRfMS5FeGVjdXRpb25Db250ZXh0KF90aGlzLl93ZWlnaHRNYXApO1xuICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSBfdGhpcy5jb21waWxlZE9yZGVyLnJlZHVjZShmdW5jdGlvbiAobWFwLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgbWFwW25vZGUubmFtZV0gPSBvcGVyYXRpb25fZXhlY3V0b3JfMS5leGVjdXRlT3Aobm9kZSwgbWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgfSwgX19hc3NpZ24oe30sIF90aGlzLndlaWdodE1hcCwgaW5wdXRzKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmluZE91dHB1dHModGVuc29ycywgY29udGV4dCwgb3V0cHV0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQsIHRlbnNvcnMsIHJlc3VsdHMsIG91dHB1dElkcywgaW5wdXRJZEFycmF5LCBpbnB1dElkcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgZXhlY3V0aW9uX2NvbnRleHRfMS5FeGVjdXRpb25Db250ZXh0KHRoaXMuX3dlaWdodE1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZXhlY3V0ZVdpdGhDb250cm9sRmxvdyhpbnB1dHMsIGNvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29ycyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLmZpbmRPdXRwdXRzKHRlbnNvcnMsIGNvbnRleHQsIG91dHB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0SWRzID0gT2JqZWN0LmtleXMocmVzdWx0cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHJlc3VsdHNba2V5XS5pZDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dElkQXJyYXkgPSBPYmplY3Qua2V5cyhpbnB1dHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBpbnB1dHNba2V5XS5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5pZDsgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRJZHMgPSBbXS5jb25jYXQuYXBwbHkoW10sIGlucHV0SWRBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0ZW5zb3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVuc29yQXJyYXkgPSB0ZW5zb3JzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW5zb3IgJiYgb3V0cHV0SWRzLmluZGV4T2YodGVuc29yLmlkKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0SWRzLmluZGV4T2YodGVuc29yLmlkKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLndlaWdodElkcy5pbmRleE9mKHRlbnNvci5pZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzdWx0c107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuZXhlY3V0ZVdpdGhDb250cm9sRmxvdyA9IGZ1bmN0aW9uIChpbnB1dHMsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrLCB0ZW5zb3JNYXAsIGFkZGVkLCBpdGVtLCB0ZW5zb3JzLCBub2RlTmFtZSwgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSB0aGlzLmdyYXBoLmlucHV0cy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBjb250ZXh0czogY29udGV4dC5jdXJyZW50Q29udGV4dCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JNYXAgPSBfX2Fzc2lnbih7fSwgdGhpcy53ZWlnaHRNYXAsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGFjay5sZW5ndGggPiAwKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudENvbnRleHQgPSBpdGVtLmNvbnRleHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29ycyA9IG9wZXJhdGlvbl9leGVjdXRvcl8xLmV4ZWN1dGVPcChpdGVtLm5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZSA9IHV0aWxzXzEuZ2V0Tm9kZU5hbWVBbmRJbmRleChpdGVtLm5vZGUubmFtZSwgY29udGV4dClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRlbnNvck1hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gbm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRlbnNvcnNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYVtfYl0gPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gdXRpbHNfMS5nZXROb2RlTmFtZUFuZEluZGV4KGNoaWxkTm9kZS5uYW1lLCBjb250ZXh0KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFkZGVkW25vZGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm9wID09PSAnbWVyZ2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlucHV0TmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXV0aWxzXzEuZ2V0VGVuc29yKG5hbWUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkW25vZGVOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7IGNvbnRleHRzOiBjb250ZXh0LmN1cnJlbnRDb250ZXh0LCBub2RlOiBjaGlsZE5vZGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGROb2RlLmlucHV0TmFtZXMuZXZlcnkoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXV0aWxzXzEuZ2V0VGVuc29yKG5hbWUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZFtub2RlTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7IGNvbnRleHRzOiBjb250ZXh0LmN1cnJlbnRDb250ZXh0LCBub2RlOiBjaGlsZE5vZGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyLCB0ZW5zb3JNYXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyYXBoRXhlY3V0b3IucHJvdG90eXBlLmZpbmRPdXRwdXRzID0gZnVuY3Rpb24gKHRlbnNvck1hcCwgY29udGV4dCwgb3V0cHV0cykge1xuICAgICAgICBpZiAob3V0cHV0cyAmJiAhKG91dHB1dHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIG91dHB1dHMgPSBbb3V0cHV0c107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3RlZE91dHB1dHMgPSAob3V0cHV0cyB8fCB0aGlzLmdyYXBoLm91dHB1dHMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5hbWU7IH0pKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RlZE91dHB1dHMucmVkdWNlKGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgICAgICAgICAgIG1hcFtuYW1lXSA9IHV0aWxzXzEuZ2V0VGVuc29yKG5hbWUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBHcmFwaEV4ZWN1dG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLndlaWdodE1hcClcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLndlaWdodE1hcFtrZXldLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmRpc3Bvc2UoKTsgfSk7IH0pO1xuICAgIH07XG4gICAgR3JhcGhFeGVjdXRvci5wcm90b3R5cGUuY2hlY2tJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlucHV0S2V5cyA9IE9iamVjdC5rZXlzKGlucHV0cyk7XG4gICAgICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgICAgIHZhciBleHRyYSA9IFtdO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXRLZXlzLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucGxhY2Vob2xkZXJzLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIGV4dHJhLnB1c2gobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGljdCBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIGhhcyB0aGUga2V5cyBcIiArXG4gICAgICAgICAgICAgICAgKFwiW1wiICsgaW5wdXRLZXlzICsgXCJdLCBidXQgaXMgbWlzc2luZyB0aGUgcmVxdWlyZWQga2V5czogW1wiICsgbWlzc2luZyArIFwiXS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGljdCBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIGhhcyBcIiArXG4gICAgICAgICAgICAgICAgKFwidW51c2VkIGtleXM6IFtcIiArIGV4dHJhICsgXCJdLiBQbGVhc2UgcHJvdmlkZSBvbmx5IHRoZSBmb2xsb3dpbmcga2V5czogXCIpICtcbiAgICAgICAgICAgICAgICAoXCJbXCIgKyB0aGlzLnBsYWNlaG9sZGVycyArIFwiXS5cIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGhFeGVjdXRvcjtcbn0oKSk7XG5leHBvcnRzLkdyYXBoRXhlY3V0b3IgPSBHcmFwaEV4ZWN1dG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGhfZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZnJvemVuX21vZGVsXzEgPSByZXF1aXJlKFwiLi9leGVjdXRvci9mcm96ZW5fbW9kZWxcIik7XG5leHBvcnRzLkZyb3plbk1vZGVsID0gZnJvemVuX21vZGVsXzEuRnJvemVuTW9kZWw7XG5leHBvcnRzLmxvYWRGcm96ZW5Nb2RlbCA9IGZyb3plbl9tb2RlbF8xLmxvYWRGcm96ZW5Nb2RlbDtcbnZhciB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuZXhwb3J0cy52ZXJzaW9uX2NvbnZlcnRlciA9IHZlcnNpb25fMS52ZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmV4ZWN1dGVPcCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnYWRkJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuYWRkKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtb2QnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubW9kKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnbXVsJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm11bCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2Rpdic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmRpdih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3ViJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc3ViKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtaW5pbXVtJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubWluaW11bSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWF4aW11bSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm1heGltdW0odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Bvdyc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnBvdyh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3F1YXJlZERpZmZlcmVuY2UnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zcXVhcmVkRGlmZmVyZW5jZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2InLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuQ0FURUdPUlkgPSAnYXJpdGhtZXRpYyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcml0aG1ldGljX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ2Ficyc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5hYnModXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdhY29zJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmFjb3ModXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdhY29zaCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5hY29zaCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2FzaW4nOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuYXNpbih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2FzaW5oJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmFzaW5oKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnYXRhbic6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5hdGFuKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnYXRhbmgnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuYXRhbmgodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmNlaWwodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdjb3MnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuY29zKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnY29zaCc6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5jb3NoKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnZWx1JzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmVsdSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2VyZic6XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5lcmYodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdleHAnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZXhwKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnZXhwbTEnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5leHBtMSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZmxvb3IodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdsb2cnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubG9nKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnbG9nMXAnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5sb2cxcCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbmVnJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLm5lZyh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ3JlY2lwcm9jYWwnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5yZWNpcHJvY2FsKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWx1JzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnJlbHUodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdyb3VuZCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnJvdW5kKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzZWx1JzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNlbHUodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdzaWdtb2lkJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNpZ21vaWQodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICBjYXNlICdzaW4nOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc2luKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAnc2lnbic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNpZ24odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NpbmgnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zaW5oKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzb2Z0cGx1cyc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNvZnRwbHVzKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzcXJ0Jzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc3FydCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3F1YXJlJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc3F1YXJlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0YW5oJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMudGFuaCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFuJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnRhbih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ2NsaXBCeVZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmNsaXBCeVZhbHVlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnY2xpcFZhbHVlTWluJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdjbGlwVmFsdWVNYXgnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGNhc2UgJ3JzcXJ0JzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmRpdih0ZmMuc2NhbGFyKDEuMCwgJ2Zsb2F0MzInKSwgdGZjLnNxcnQodXRpbHNfMS5nZXRUZW5zb3Iobm9kZS5pbnB1dE5hbWVzWzBdLCB0ZW5zb3JNYXAsIGNvbnRleHQpKSldO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdiYXNpY19tYXRoJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2ljX21hdGhfZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5mdW5jdGlvbiBleGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIHByZWQsIGRhdGFfMSwgaW5wdXROYW1lLCBmcmFtZUlkLCBkYXRhLCB0ZW5zb3IsIGlucHV0O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYSA9IG5vZGUub3A7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xvb3BDb25kJzogcmV0dXJuIFszLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N3aXRjaCc6IHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtZXJnZSc6IHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbnRlcic6IHJldHVybiBbMywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdleGl0JzogcmV0dXJuIFszLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25leHRJdGVyYXRpb24nOiByZXR1cm4gWzMsIDddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIFt1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3ByZWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpXV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBwcmVkID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdwcmVkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YV8xID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkYXRhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBwcmVkLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIsIChfYi5zZW50KCkpWzBdID8gW3VuZGVmaW5lZCwgZGF0YV8xXSA6IFtkYXRhXzEsIHVuZGVmaW5lZF1dO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXROYW1lID0gbm9kZS5pbnB1dE5hbWVzLmZpbmQoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHV0aWxzXzEuZ2V0VGVuc29yKG5hbWUsIHRlbnNvck1hcCwgY29udGV4dCkgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgaW5wdXROYW1lID8gW3V0aWxzXzEuZ2V0VGVuc29yKGlucHV0TmFtZSwgdGVuc29yTWFwLCBjb250ZXh0KV0gOiB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJZCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZnJhbWVOYW1lJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgndGVuc29yJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbnRlckZyYW1lKGZyYW1lSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFtkYXRhXV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICB0ZW5zb3IgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3RlbnNvcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXhpdEZyYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgW3RlbnNvcl1dO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3RlbnNvcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubmV4dEl0ZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFtpbnB1dF1dO1xuICAgICAgICAgICAgICAgIGNhc2UgODogdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmV4ZWN1dGVPcCA9IGV4ZWN1dGVPcDtcbmV4cG9ydHMuQ0FURUdPUlkgPSAnY29udHJvbCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ2NvbnYxZCc6IHtcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0cmlkZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdwYWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGRhdGFGb3JtYXQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2RhdGFGb3JtYXQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpXG4gICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgZGlsYXRpb24gPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2RpbGF0aW9uJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmNvbnYxZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2ZpbHRlcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHN0cmlkZSwgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbildO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvbnYyZCc6IHtcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0cmlkZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkYXRhRm9ybWF0ID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkYXRhRm9ybWF0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGRpbGF0aW9ucyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZGlsYXRpb25zJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmNvbnYyZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2ZpbHRlcicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIFtzdHJpZGVbMV0sIHN0cmlkZVsyXV0sIHBhZCwgZGF0YUZvcm1hdCwgW2RpbGF0aW9uc1swXSwgZGlsYXRpb25zWzFdXSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvbnYyZFRyYW5zcG9zZSc6IHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnb3V0cHV0U2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdwYWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuY29udjJkVHJhbnNwb3NlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZmlsdGVyJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgc2hhcGUsIFtzdHJpZGVbMV0sIHN0cmlkZVsyXV0sIHBhZCldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlcHRod2lzZUNvbnYyZCc6IHtcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3N0cmlkZXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBhZCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgncGFkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBkaWxhdGlvbnMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2RpbGF0aW9ucycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgZGF0YUZvcm1hdCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZGF0YUZvcm1hdCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmRlcHRod2lzZUNvbnYyZCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2lucHV0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdmaWx0ZXInLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBbc3RyaWRlWzFdLCBzdHJpZGVbMl1dLCBwYWQsIGRhdGFGb3JtYXQsIFtkaWxhdGlvbnNbMF0sIGRpbGF0aW9uc1sxXV0pXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhdmdQb29sJzoge1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgcGFkID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdwYWQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlcm5lbFNpemUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2tlcm5lbFNpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuYXZnUG9vbCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBba2VybmVsU2l6ZVsxXSwga2VybmVsU2l6ZVsyXV0sIFtzdHJpZGVbMV0sIHN0cmlkZVsyXV0sIHBhZCldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21heFBvb2wnOiB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzdHJpZGVzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBwYWQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3BhZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIga2VybmVsU2l6ZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgna2VybmVsU2l6ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5tYXhQb29sKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIFtrZXJuZWxTaXplWzFdLCBrZXJuZWxTaXplWzJdXSwgW3N0cmlkZVsxXSwgc3RyaWRlWzJdXSwgcGFkKV07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIiArIG5vZGUub3AgKyBcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuQ0FURUdPUlkgPSAnY29udm9sdXRpb24nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udm9sdXRpb25fZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmV4ZWN1dGVPcCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnZmlsbCc6IHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd2YWx1ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5maWxsKHNoYXBlLCB2YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2xpbnNwYWNlJzoge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzdGFydCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc3RvcF8xID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzdG9wJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBudW0gPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ251bScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5saW5zcGFjZShzdGFydCwgc3RvcF8xLCBudW0pXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdvbmVIb3QnOiB7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnaW5kaWNlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2RlcHRoJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBvblZhbHVlID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdvblZhbHVlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBvZmZWYWx1ZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnb2ZmVmFsdWUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMub25lSG90KGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ29uZXMnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5vbmVzKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2R0eXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ29uZXNMaWtlJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMub25lc0xpa2UodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JhbmRvbVVuaWZvcm0nOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5yYW5kb21Vbmlmb3JtKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ21pbnZhbCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnbWF4dmFsJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyYW5nZSc6IHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RhcnQnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0b3BfMiA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RvcCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RlcCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5yYW5nZShzdGFydCwgc3RvcF8yLCBzdGVwLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2R0eXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RydW5jYXRlZE5vcm1hbCc6IHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIG1lYW4gPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ21lYW4nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHN0ZERldiA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RkRGV2Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzZWVkID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzZWVkJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnRydW5jYXRlZE5vcm1hbChzaGFwZSwgbWVhbiwgc3RkRGV2LCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2R0eXBlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgc2VlZCldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3plcm9zJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuemVyb3ModXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzaGFwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZHR5cGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnemVyb3NMaWtlJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuemVyb3NMaWtlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdjcmVhdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGlvbl9leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdjb25zdCc6IHtcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JNYXBbbm9kZS5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwbGFjZWhvbGRlcic6XG4gICAgICAgICAgICB2YXIgZGVmID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkZWZhdWx0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdXRpbHNfMS5nZXRUZW5zb3Iobm9kZS5uYW1lLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHx8IGRlZl07XG4gICAgICAgIGNhc2UgJ2lkZW50aXR5JzpcbiAgICAgICAgY2FzZSAnc3RvcEdyYWRpZW50JzpcbiAgICAgICAgY2FzZSAnZmFrZVF1YW50V2l0aE1pbk1heFZhcnMnOlxuICAgICAgICAgICAgcmV0dXJuIFt1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpXTtcbiAgICAgICAgY2FzZSAnc25hcHNob3QnOlxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbc25hcHNob3QuY2xvbmUoKV07XG4gICAgICAgIGNhc2UgJ3NoYXBlJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnRlbnNvcjFkKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkuc2hhcGUsICdpbnQzMicpXTtcbiAgICAgICAgY2FzZSAnbm9vcCc6XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNhc2UgJ3ByaW50JzpcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnZGF0YScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnbWVzc2FnZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc3VtbWFyaXplID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzdW1tYXJpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZ3JhcGggaGFzIGEgdGYucHJpbnQoKSBvcGVyYXRpb24sJyArXG4gICAgICAgICAgICAgICAgJ3VzdWFsbHkgdXNlZCBmb3IgZGVidWdnaW5nLCB3aGljaCBzbG93cyBkb3duIHBlcmZvcm1hbmNlLicpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhWzBdLmRhdGFTeW5jKCkpLnNsaWNlKDAsIHN1bW1hcml6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dF07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkNBVEVHT1JZID0gJ2dyYXBoJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ3Jlc2l6ZUJpbGluZWFyJzoge1xuICAgICAgICAgICAgdmFyIGltYWdlcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnaW1hZ2VzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzaXplID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBhbGlnbkNvcm5lcnMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2FsaWduQ29ybmVycycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5pbWFnZS5yZXNpemVCaWxpbmVhcihpbWFnZXMsIFtzaXplWzBdLCBzaXplWzFdXSwgYWxpZ25Db3JuZXJzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVzaXplTmVhcmVzdE5laWdoYm9yJzoge1xuICAgICAgICAgICAgdmFyIGltYWdlcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnaW1hZ2VzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBzaXplID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzaXplJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBhbGlnbkNvcm5lcnMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2FsaWduQ29ybmVycycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5pbWFnZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IoaW1hZ2VzLCBbc2l6ZVswXSwgc2l6ZVsxXV0sIGFsaWduQ29ybmVycyldO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkNBVEVHT1JZID0gJ2ltYWdlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ2VxdWFsJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZXF1YWwodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdEVxdWFsJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubm90RXF1YWwodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2dyZWF0ZXInOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5ncmVhdGVyKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdncmVhdGVyRXF1YWwnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5ncmVhdGVyRXF1YWwodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2xlc3MnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5sZXNzKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsZXNzRXF1YWwnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5sZXNzRXF1YWwodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2xvZ2ljYWxBbmQnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5sb2dpY2FsQW5kKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsb2dpY2FsTm90Jzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubG9naWNhbE5vdCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2EnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbG9naWNhbE9yJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubG9naWNhbE9yKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd3aGVyZSc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLndoZXJlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnY29uZGl0aW9uJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkNBVEVHT1JZID0gJ2xvZ2ljYWwnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9naWNhbF9leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlICdtYXRNdWwnOlxuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubWF0TXVsKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgndHJhbnNwb3NlQScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgndHJhbnNwb3NlQicsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgY2FzZSAndHJhbnNwb3NlJzpcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnRyYW5zcG9zZSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3Blcm0nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkNBVEVHT1JZID0gJ21hdHJpY2VzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdHJpY2VzX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ2JhdGNoTm9ybWFsaXphdGlvbic6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmJhdGNoTm9ybWFsaXphdGlvbih1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ21lYW4nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3ZhcmlhbmNlJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdlcHNpbG9uJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdzY2FsZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnb2Zmc2V0Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2xvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdyYWRpdXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2JpYXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2FscGhhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiZXRhJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NvZnRtYXgnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5zb2Z0bWF4KHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdub3JtYWxpemF0aW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6YXRpb25fZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmV4ZWN1dGVPcCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnbWF4Jzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdrZWVwRGltcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5tYXgodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcywga2VlcERpbXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtZWFuJzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdrZWVwRGltcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5tZWFuKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMsIGtlZXBEaW1zKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWluJzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdrZWVwRGltcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5taW4odXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcywga2VlcERpbXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzdW0nOiB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIga2VlcERpbXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2tlZXBEaW1zJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnN1bSh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzLCBrZWVwRGltcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FyZ01heCc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmFyZ01heCh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXJnTWluJzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuYXJnTWluKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdyZWR1Y3Rpb24nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWN0aW9uX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5leGVjdXRlT3AgPSBmdW5jdGlvbiAobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgJ2NvbmNhdCc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3RlbnNvcnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuY29uY2F0KGlucHV0cywgYXhpcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2dhdGhlcic6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdheGlzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnaW5kaWNlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5nYXRoZXIoaW5wdXQsIGluZGljZXMsIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZXZlcnNlJzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnJldmVyc2UoaW5wdXQsIGF4aXMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzbGljZSc6IHtcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYmVnaW4nLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3NpemUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc2xpY2UodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYmVnaW4sIHNpemUpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzdHJpZGVkU2xpY2UnOiB7XG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2JlZ2luJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2VuZCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc3RyaWRlcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc3RyaWRlcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgYmVnaW5NYXNrID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdiZWdpbk1hc2snLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGVuZE1hc2sgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2VuZE1hc2snLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuc3RyaWRlZFNsaWNlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIGJlZ2luLCBlbmQsIHN0cmlkZXMsIGJlZ2luTWFzaywgZW5kTWFzayldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0YWNrJzoge1xuICAgICAgICAgICAgcmV0dXJuIHRmYy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnYXhpcycsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIHRlbnNvcnMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3RlbnNvcnMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHRlbnNvcnNbMF0uc2hhcGU7XG4gICAgICAgICAgICAgICAgdmFyIHNxdWVlemVkU2hhcGUgPSB0ZW5zb3JzWzBdLnNxdWVlemUoKS5zaGFwZTtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGVkID0gdGVuc29ycy5tYXAoZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FtZVNoYXBlID0gdGZjLnV0aWwuYXJyYXlzRXF1YWwodGVuc29yLnNoYXBlLCBzaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2FtZVNoYXBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGZjLnV0aWwuYXJyYXlzRXF1YWwodGVuc29yLnNxdWVlemUoKS5zaGFwZSwgc3F1ZWV6ZWRTaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGlucHV0IHRlbnNvcnMgc2hhcGUgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FtZVNoYXBlID8gdGVuc29yIDogdGVuc29yLnJlc2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGZjLnN0YWNrKG1hcHBlZCwgYXhpcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGlsZSc6IHtcbiAgICAgICAgICAgIHZhciByZXBzID0gdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdyZXBzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnRpbGUodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgcmVwcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NwbGl0Jzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB1dGlsc18xLmdldFBhcmFtVmFsdWUoJ2F4aXMnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIG51bU9yU2l6ZVNwbGl0cyA9IHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnbnVtT3JTaXplU3BsaXRzJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB0ZmMuc3BsaXQodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgbnVtT3JTaXplU3BsaXRzLCBheGlzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICdzbGljZV9qb2luJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWNlX2pvaW5fZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmV4ZWN1dGVPcCA9IGZ1bmN0aW9uIChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSAnY2FzdCc6IHtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLmNhc3QodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgdXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdkdHlwZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdleHBhbmREaW1zJzoge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBub2RlLnBhcmFtc1snYXhpcyddLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMuZXhwYW5kRGltcyh1dGlsc18xLmdldFBhcmFtVmFsdWUoJ3gnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpLCBheGlzKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3F1ZWV6ZSc6IHtcbiAgICAgICAgICAgIHZhciBheGlzID0gbm9kZS5wYXJhbXNbJ2F4aXMnXS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBbdGZjLnNxdWVlemUodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCd4Jywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgYXhpcyldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Jlc2hhcGUnOiB7XG4gICAgICAgICAgICByZXR1cm4gW3RmYy5yZXNoYXBlKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnc2hhcGUnLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpKV07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncGFkJzoge1xuICAgICAgICAgICAgcmV0dXJuIFt0ZmMucGFkKHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgneCcsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCksIHV0aWxzXzEuc3BsaXQodXRpbHNfMS5nZXRQYXJhbVZhbHVlKCdwYWRkaW5nJywgbm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KSwgMiksIHV0aWxzXzEuZ2V0UGFyYW1WYWx1ZSgnY29uc3RhbnRWYWx1ZScsIG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkpXTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiICsgbm9kZS5vcCArIFwiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5DQVRFR09SWSA9ICd0cmFuc2Zvcm1hdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1hdGlvbl9leGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldFBhcmFtVmFsdWUocGFyYW1OYW1lLCBub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpIHtcbiAgICB2YXIgcGFyYW0gPSBub2RlLnBhcmFtc1twYXJhbU5hbWVdO1xuICAgIGlmIChwYXJhbSAmJiBwYXJhbS5pbnB1dEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09ICd0ZW5zb3InKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGVuc29yKG5vZGUuaW5wdXROYW1lc1twYXJhbS5pbnB1dEluZGV4XSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3RlbnNvcnMnKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gcGFyYW0uaW5wdXRJbmRleCA9PT0gMCA/XG4gICAgICAgICAgICAgICAgKHBhcmFtLmlucHV0UGFyYW1MZW5ndGggPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICBub2RlLmlucHV0TmFtZXMgOlxuICAgICAgICAgICAgICAgICAgICBub2RlLmlucHV0TmFtZXMuc2xpY2UocGFyYW0uaW5wdXRJbmRleCwgLXBhcmFtLmlucHV0UGFyYW1MZW5ndGgpKSA6XG4gICAgICAgICAgICAgICAgbm9kZS5pbnB1dE5hbWVzLnNwbGljZShwYXJhbS5pbnB1dEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dHMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBnZXRUZW5zb3IobmFtZSwgdGVuc29yTWFwLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnZXRUZW5zb3Iobm9kZS5pbnB1dE5hbWVzLnNsaWNlKHBhcmFtLmlucHV0SW5kZXgpWzBdLCB0ZW5zb3JNYXAsIGNvbnRleHQpXG4gICAgICAgICAgICAuZGF0YVN5bmMoKSk7XG4gICAgICAgIHJldHVybiBwYXJhbS50eXBlID09PSAnbnVtYmVyJyA/IGRhdGFbMF0gOiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW0gJiYgcGFyYW0udmFsdWU7XG59XG5leHBvcnRzLmdldFBhcmFtVmFsdWUgPSBnZXRQYXJhbVZhbHVlO1xuZnVuY3Rpb24gZ2V0VGVuc29yKG5hbWUsIHRlbnNvcnNNYXAsIGNvbnRleHQpIHtcbiAgICB2YXIgX2EgPSBwYXJzZU5vZGVOYW1lKG5hbWUpLCBub2RlTmFtZSA9IF9hWzBdLCBpbmRleCA9IF9hWzFdO1xuICAgIHZhciBjb250ZXh0SWQgPSBjb250ZXh0LmN1cnJlbnRDb250ZXh0SWRzLmZpbmQoZnVuY3Rpb24gKGNvbnRleHRJZCkge1xuICAgICAgICByZXR1cm4gISF0ZW5zb3JzTWFwW2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChub2RlTmFtZSwgY29udGV4dElkKV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRleHRJZCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgdGVuc29yc01hcFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobm9kZU5hbWUsIGNvbnRleHRJZCldW2luZGV4XSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZ2V0VGVuc29yID0gZ2V0VGVuc29yO1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWVBbmRJbmRleChpbnB1dE5hbWUsIGNvbnRleHQpIHtcbiAgICB2YXIgX2EgPSBwYXJzZU5vZGVOYW1lKGlucHV0TmFtZSksIG5vZGVOYW1lID0gX2FbMF0sIGluZGV4ID0gX2FbMV07XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKG5vZGVOYW1lLCBjb250ZXh0ICYmIGNvbnRleHQuY3VycmVudENvbnRleHRJZCksXG4gICAgICAgIGluZGV4XG4gICAgXTtcbn1cbmV4cG9ydHMuZ2V0Tm9kZU5hbWVBbmRJbmRleCA9IGdldE5vZGVOYW1lQW5kSW5kZXg7XG5mdW5jdGlvbiBnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobmFtZSwgY29udGV4dElkKSB7XG4gICAgcmV0dXJuICEhY29udGV4dElkID8gbmFtZSArIFwiLVwiICsgY29udGV4dElkIDogbmFtZTtcbn1cbmZ1bmN0aW9uIHBhcnNlTm9kZU5hbWUobmFtZSkge1xuICAgIHZhciBpbmRleCA9IG5hbWUubGFzdEluZGV4T2YoJzonKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm4gW25hbWUsIDBdO1xuICAgIHZhciBub2RlTmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICByZXR1cm4gW25vZGVOYW1lLCBOdW1iZXIobmFtZS5zdWJzdHJpbmcoaW5kZXggKyAxKSldO1xufVxuZXhwb3J0cy5wYXJzZU5vZGVOYW1lID0gcGFyc2VOb2RlTmFtZTtcbmZ1bmN0aW9uIHNwbGl0KGFyciwgc2l6ZSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gc2l6ZSkge1xuICAgICAgICByZXMucHVzaChhcnIuc2xpY2UoaSwgaSArIHNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBZGRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYWRkXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQmlhc0FkZFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJhZGRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYXJpdGhtZXRpY1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTdWJcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3ViXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmVhbERpdlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJkaXZcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYXJpdGhtZXRpY1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJEaXZcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZGl2XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTXVsXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm11bFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJhcml0aG1ldGljXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk1heGltdW1cIixcbiAgICBcImRsT3BOYW1lXCI6IFwibWF4aW11bVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJhcml0aG1ldGljXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTWluaW11bVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJtaW5pbXVtXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJQb3dcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicG93XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU3F1YXJlZERpZmZlcmVuY2VcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3F1YXJlZERpZmZlcmVuY2VcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYXJpdGhtZXRpY1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJNb2RcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibW9kXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImFyaXRobWV0aWNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBYnNcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYWJzXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBY29zXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImFjb3NcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkFzaW5cIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYXNpblwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiYXRhblwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJhdGFuXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJDZWlsXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImNlaWxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNsaXBCeVZhbHVlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImNsaXBCeVZhbHVlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiY2xpcF92YWx1ZV9taW5cIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImNsaXBWYWx1ZU1pblwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImNsaXBfdmFsdWVfbWF4XCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJjbGlwVmFsdWVNYXhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQ29zXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImNvc1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQ29zaFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjb3NoXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJFbHVcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZWx1XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJFeHBcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZXhwXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJGbG9vclwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJmbG9vclwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTG9nXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImxvZ1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTmVnXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm5lZ1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmVsdVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyZWx1XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJSZWx1NlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjbGlwQnlWYWx1ZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJjbGlwVmFsdWVNaW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJjbGlwVmFsdWVNYXhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDZcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU2VsdVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzZWx1XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTaWdtb2lkXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInNpZ21vaWRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNpblwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzaW5cIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNpbmhcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic2luaFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU3FydFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzcXJ0XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJSc3FydFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyc3FydFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU3F1YXJlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInNxdWFyZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiVGFuXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInRhblwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiVGFuaFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJ0YW5oXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTaWduXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInNpZ25cIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJvdW5kXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInJvdW5kXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJFeHBtMVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJleHBtMVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTG9nMXBcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibG9nMXBcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJlY2lwcm9jYWxcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicmVjaXByb2NhbFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmVjaXByb2NhbFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyZWNpcHJvY2FsXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTb2Z0cGx1c1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzb2Z0cGx1c1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQXNpbmhcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYXNpbmhcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiYmFzaWNfbWF0aFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkFjb3NoXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImFjb3NoXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImJhc2ljX21hdGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBdGFuaFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJhdGFuaFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRXJmXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImVyZlwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJiYXNpY19tYXRoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJMb29wQ29uZFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJsb29wQ29uZFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb250cm9sXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicHJlZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTd2l0Y2hcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3dpdGNoXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNvbnRyb2xcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkYXRhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicHJlZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJNZXJnZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJtZXJnZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb250cm9sXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcInRmSW5wdXRQYXJhbUxlbmd0aFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidGVuc29yc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JzXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRW50ZXJcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZW50ZXJcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udHJvbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInRlbnNvclwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJmcmFtZV9uYW1lXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJmcmFtZU5hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJpc19jb25zdGFudFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiaXNDb25zdGFudFwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRXhpdFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJleGl0XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNvbnRyb2xcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ0ZW5zb3JcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk5leHRJdGVyYXRpb25cIixcbiAgICBcImRsT3BOYW1lXCI6IFwibmV4dEl0ZXJhdGlvblwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb250cm9sXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidGVuc29yXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkF2Z1Bvb2xcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYXZnUG9vbFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb252b2x1dGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJwYWRkaW5nXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJwYWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkYXRhX2Zvcm1hdFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGF0YUZvcm1hdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImtzaXplXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJrZXJuZWxTaXplXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk1heFBvb2xcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibWF4UG9vbFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb252b2x1dGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJwYWRkaW5nXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJwYWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkYXRhX2Zvcm1hdFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGF0YUZvcm1hdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImtzaXplXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJrZXJuZWxTaXplXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNvbnYxRFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjb252MWRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udm9sdXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZmlsdGVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic3RyaWRlXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdHJpZGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJwYWRkaW5nXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJwYWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkYXRhX2Zvcm1hdFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGF0YUZvcm1hdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogXCJOV0NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkaWxhdGlvblwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGlsYXRpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDFcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQ29udjJEXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImNvbnYyZFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjb252b2x1dGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJmaWx0ZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwicGFkZGluZ1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicGFkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwidXNlQ3Vkbm5PbkdwdVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidXNlQ3Vkbm5PbkdwdVwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkYXRhX2Zvcm1hdFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGF0YUZvcm1hdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogXCJOSFdDXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkaWxhdGlvbnNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRpbGF0aW9uc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNvbnYyREJhY2twcm9wSW5wdXRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiY29udjJkVHJhbnNwb3NlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNvbnZvbHV0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAyLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImZpbHRlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm91dHB1dFNoYXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJwYWRkaW5nXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJwYWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkYXRhX2Zvcm1hdFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGF0YUZvcm1hdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJEZXB0aHdpc2VDb252MmRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiZGVwdGh3aXNlQ29udjJkXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNvbnZvbHV0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiaW5wdXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJmaWx0ZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdHJpZGVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJwYWRkaW5nXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJwYWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkYXRhX2Zvcm1hdFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGF0YUZvcm1hdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogXCJOSFdDXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkaWxhdGlvbnNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRpbGF0aW9uc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJkZXB0aHdpc2VDb252MmRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY29udm9sdXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJpbnB1dFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImZpbHRlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInN0cmlkZXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInN0cmlkZXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInBhZGRpbmdcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInBhZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImRhdGFfZm9ybWF0XCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkYXRhRm9ybWF0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiBcIk5IV0NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImRpbGF0aW9uc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGlsYXRpb25zXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJGaWxsXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImZpbGxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY3JlYXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzaGFwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidmFsdWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkxpblNwYWNlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImxpbnNwYWNlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RhcnRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdG9wXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAyLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwibnVtXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJPbmVIb3RcIixcbiAgICBcImRsT3BOYW1lXCI6IFwib25lSG90XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiaW5kaWNlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRlcHRoXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAyLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwib25WYWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMyxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm9mZlZhbHVlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiT25lc1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJvbmVzXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2hhcGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiT25lc0xpa2VcIixcbiAgICBcImRsT3BOYW1lXCI6IFwib25lc0xpa2VcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY3JlYXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmFuZG9tVW5pZm9ybVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyYW5kb21Vbmlmb3JtXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2hhcGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIm1pbnZhbFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwibWludmFsXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwibWF4dmFsXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJtYXh2YWxcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDFcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInNlZWRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNlZWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzZWVkMlwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2VlZDJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDAsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlJhbmdlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInJhbmdlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RhcnRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdG9wXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAyLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RlcFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRpZHhcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwidHJ1bmNhdGVkTm9ybWFsXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInRydW5jYXRlZE5vcm1hbFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJjcmVhdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNoYXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJtZWFuc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwibWVhblwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMC4wXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic3RkZGV2XCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdGREZXZcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDEuMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInNlZWRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNlZWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJzZWVkMlwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2VlZDJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDAsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiWmVyb3NcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiemVyb3NcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiY3JlYXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzaGFwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJaZXJvc0xpa2VcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiemVyb3NMaWtlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImNyZWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCJcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJQbGFjZWhvbGRlcldpdGhEZWZhdWx0XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImdyYXBoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZGVmYXVsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJQbGFjZWhvbGRlclwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJwbGFjZWhvbGRlclwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJncmFwaFwiXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQ29uc3RcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiY29uc3RcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiZ3JhcGhcIlxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIklkZW50aXR5XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImlkZW50aXR5XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImdyYXBoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTbmFwc2hvdFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzbmFwc2hvdFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJncmFwaFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU2hhcGVcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic2hhcGVcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiZ3JhcGhcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlByaW50XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInByaW50XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImdyYXBoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJ0ZklucHV0UGFyYW1MZW5ndGhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwibWVzc2FnZVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwibWVzc2FnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImZpcnN0X25cIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImZpcnN0TlwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJub3RTdXBwcnRlZFwiOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwic3VtbWFyaXplXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzdW1tYXJpemVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDNcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTm9PcFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJub29wXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImdyYXBoXCIsXG4gICAgXCJwYXJhbXNcIjogW11cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTdG9wR3JhZGllbnRcIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3RvcEdyYWRpZW50XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImdyYXBoXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJGYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJmYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJncmFwaFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJtaW5cIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm1pblwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIm1heFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwibWF4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmVzaXplQmlsaW5lYXJcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicmVzaXplQmlsaW5lYXJcIixcbiAgICBcImNhdGVnb3J5XCI6IFwiaW1hZ2VcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJpbWFnZXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzaXplXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJhbGlnbl9jb3JuZXJzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhbGlnbkNvcm5lcnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJSZXNpemVOZWFyZXN0TmVpZ2hib3JcIixcbiAgICBcImRsT3BOYW1lXCI6IFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImltYWdlXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiaW1hZ2VzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2l6ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYWxpZ25fY29ybmVyc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYWxpZ25Db3JuZXJzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJFcXVhbFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJlcXVhbFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJsb2dpY2FsXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk5vdEVxdWFsXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm5vdEVxdWFsXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImxvZ2ljYWxcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiR3JlYXRlclwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJncmVhdGVyXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcImxvZ2ljYWxcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiR3JlYXRlckVxdWFsXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImdyZWF0ZXJFcXVhbFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJsb2dpY2FsXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkxlc3NcIixcbiAgICBcImRsT3BOYW1lXCI6IFwibGVzc1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJsb2dpY2FsXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkxlc3NFcXVhbFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJsZXNzRXF1YWxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibG9naWNhbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJMb2dpY2FsQW5kXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImxvZ2ljYWxBbmRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibG9naWNhbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJMb2dpY2FsTm90XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImxvZ2ljYWxOb3RcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibG9naWNhbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJkdHlwZVwiLFxuICAgICAgICBcIm5vdFN1cHBvcnRlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkxvZ2ljYWxPclwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJsb2dpY2FsT3JcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibG9naWNhbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTZWxlY3RcIixcbiAgICBcImRsT3BOYW1lXCI6IFwid2hlcmVcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibG9naWNhbFwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImNvbmRpdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIk1hdE11bFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJtYXRNdWxcIixcbiAgICBcImNhdGVnb3J5XCI6IFwibWF0cmljZXNcIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJhXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYlwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInRyYW5zcG9zZV9hXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ0cmFuc3Bvc2VBXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogZmFsc2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJ0cmFuc3Bvc2VfYlwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidHJhbnNwb3NlQlwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IGZhbHNlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiVFwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJUcmFuc3Bvc2VcIixcbiAgICBcImRsT3BOYW1lXCI6IFwidHJhbnNwb3NlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcIm1hdHJpY2VzXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInBlcm1cIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInBlcm1cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIlRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJGdXNlZEJhdGNoTm9ybVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJiYXRjaE5vcm1hbGl6YXRpb25cIixcbiAgICBcImNhdGVnb3J5XCI6IFwibm9ybWFsaXphdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzY2FsZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm9mZnNldFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMyxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm1lYW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDQsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ2YXJpYW5jZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImVwc2lsb25cIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImVwc2lsb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDAuMDAxXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGF0YV9mb3JtYXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFGb3JtYXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRnVzZWRCYXRjaE5vcm1WMlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJiYXRjaE5vcm1hbGl6YXRpb25cIixcbiAgICBcImNhdGVnb3J5XCI6IFwibm9ybWFsaXphdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzY2FsZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm9mZnNldFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMyxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm1lYW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDQsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ2YXJpYW5jZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImVwc2lsb25cIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImVwc2lsb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDAuMDAxXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGF0YV9mb3JtYXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImRhdGFGb3JtYXRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTFJOXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcIm5vcm1hbGl6YXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZGVwdGhfcmFkaXVzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJyYWRpdXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJiaWFzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiaWFzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAxLjBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJhbHBoYVwiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYWxwaGFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDEuMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImJldGFcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImJldGFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDAuNVxuICAgICAgfVxuICAgIF1cbiAgfSwgIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU29mdG1heFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzb2Z0bWF4XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcIm5vcm1hbGl6YXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTWF4XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcIm1heFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJyZWR1Y3Rpb25cIixcbiAgICBcInBhcmFtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwia2VlcF9kaW1zXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJrZWVwRGltc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiTWVhblwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJtZWFuXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInJlZHVjdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJrZWVwX2RpbXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImtlZXBEaW1zXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJNaW5cIixcbiAgICBcImRsT3BOYW1lXCI6IFwibWluXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInJlZHVjdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJrZWVwX2RpbXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImtlZXBEaW1zXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTdW1cIixcbiAgICBcImRsT3BOYW1lXCI6IFwic3VtXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInJlZHVjdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJrZWVwX2RpbXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImtlZXBEaW1zXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJBcmdNYXhcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiYXJnTWF4XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInJlZHVjdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkFyZ01pblwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJhcmdNaW5cIixcbiAgICBcImNhdGVnb3J5XCI6IFwicmVkdWN0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJDb25jYXRWMlwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJjb25jYXRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJ0ZklucHV0UGFyYW1MZW5ndGhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInRlbnNvcnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAtMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiQ29uY2F0XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImNvbmNhdFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJzbGljZV9qb2luXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcInRmSW5wdXRQYXJhbUxlbmd0aFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwidGVuc29yc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkdhdGhlclYyXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcImdhdGhlclwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJzbGljZV9qb2luXCIsXG4gICAgXCJwYXJhbXNcIjogW1xuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImluZGljZXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkdhdGhlclwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJnYXRoZXJcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJpbmRpY2VzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcInZhbGlkYXRlX2luZGljZXNcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInZhbGlkYXRlSW5kaWNlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwibm90U3VwcG9ydGVkXCI6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmV2ZXJzZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJyZXZlcnNlXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInNsaWNlX2pvaW5cIixcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImF4aXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUmV2ZXJzZVYyXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInJldmVyc2VcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJTbGljZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzbGljZVwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJzbGljZV9qb2luXCIsXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJiZWdpblwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAyLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic2l6ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlN0cmlkZWRTbGljZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzdHJpZGVkU2xpY2VcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYmVnaW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImVuZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAzLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwic3RyaWRlc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYmVnaW5fbWFza1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYmVnaW5NYXNrXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiZW5kX21hc2tcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImVuZE1hc2tcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IDBcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiUGFja1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzdGFja1wiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJzbGljZV9qb2luXCIsXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJ0ZklucHV0UGFyYW1MZW5ndGhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInRlbnNvcnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJUaWxlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInRpbGVcIixcbiAgICBcImNhdGVnb3J5XCI6IFwic2xpY2Vfam9pblwiLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicmVwc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlNwbGl0XCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInNwbGl0XCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInNsaWNlX2pvaW5cIixcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiYXhpc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJudW1fc3BsaXRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcIm51bU9yU2l6ZVNwbGl0c1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMVxuICAgICAgfVxuICAgIF1cbiAgfVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIkNhc3RcIixcbiAgICBcImRsT3BOYW1lXCI6IFwiY2FzdFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJTcmNUXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJzZHR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZHR5cGVcIixcbiAgICAgICAgXCJub3RTdXBwb3J0ZWRcIjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcIkRzdFRcIixcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcImR0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImR0eXBlXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiRXhwYW5kRGltc1wiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJleHBhbmREaW1zXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDEsXG4gICAgICAgIFwidGZQYXJhbU5hbWVEZXByZWNhdGVkXCI6IFwiZGltXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlBhZFwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJwYWRcIixcbiAgICBcImNhdGVnb3J5XCI6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInBhZGRpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyW11cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZlBhcmFtTmFtZVwiOiBcImNvbnN0YW50X3ZhbHVlXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJjb25zdGFudFZhbHVlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiAwXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0Zk9wTmFtZVwiOiBcIlBhZFYyXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInBhZFwiLFxuICAgIFwiY2F0ZWdvcnlcIjogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIFwicGFyYW1zXCI6IFt7XG4gICAgICAgIFwidGZJbnB1dEluZGV4XCI6IDAsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJ4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRlbnNvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAxLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwicGFkZGluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJbXVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAyLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwiY29uc3RhbnRWYWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogMFxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGZPcE5hbWVcIjogXCJSZXNoYXBlXCIsXG4gICAgXCJkbE9wTmFtZVwiOiBcInJlc2hhcGVcIixcbiAgICBcImNhdGVnb3J5XCI6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICBcInBhcmFtc1wiOiBbe1xuICAgICAgICBcInRmSW5wdXRJbmRleFwiOiAwLFxuICAgICAgICBcImRsUGFyYW1OYW1lXCI6IFwieFwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMSxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInNoYXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBcInRmT3BOYW1lXCI6IFwiU3F1ZWV6ZVwiLFxuICAgIFwiZGxPcE5hbWVcIjogXCJzcXVlZXplXCIsXG4gICAgXCJjYXRlZ29yeVwiOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgXCJwYXJhbXNcIjogW3tcbiAgICAgICAgXCJ0ZklucHV0SW5kZXhcIjogMCxcbiAgICAgICAgXCJkbFBhcmFtTmFtZVwiOiBcInhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGVuc29yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwidGZQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidGZQYXJhbU5hbWVEZXByZWNhdGVkXCI6IFwic3F1ZWV6ZV9kaW1zXCIsXG4gICAgICAgIFwiZGxQYXJhbU5hbWVcIjogXCJheGlzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlcltdXCJcbiAgICAgIH1cbiAgICBdXG4gIH1cbl1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFyaXRobWV0aWMgPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvYXJpdGhtZXRpY19leGVjdXRvclwiKTtcbnZhciBiYXNpY01hdGggPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvYmFzaWNfbWF0aF9leGVjdXRvclwiKTtcbnZhciBjb250cm9sID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL2NvbnRyb2xfZXhlY3V0b3JcIik7XG52YXIgY29udm9sdXRpb24gPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvY29udm9sdXRpb25fZXhlY3V0b3JcIik7XG52YXIgY3JlYXRpb24gPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvY3JlYXRpb25fZXhlY3V0b3JcIik7XG52YXIgZ3JhcGggPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvZ3JhcGhfZXhlY3V0b3JcIik7XG52YXIgaW1hZ2UgPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvaW1hZ2VfZXhlY3V0b3JcIik7XG52YXIgbG9naWNhbCA9IHJlcXVpcmUoXCIuL2V4ZWN1dG9ycy9sb2dpY2FsX2V4ZWN1dG9yXCIpO1xudmFyIG1hdHJpY2VzID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL21hdHJpY2VzX2V4ZWN1dG9yXCIpO1xudmFyIG5vcm1hbGl6YXRpb24gPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvbm9ybWFsaXphdGlvbl9leGVjdXRvclwiKTtcbnZhciByZWR1Y3Rpb24gPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvcmVkdWN0aW9uX2V4ZWN1dG9yXCIpO1xudmFyIHNsaWNlSm9pbiA9IHJlcXVpcmUoXCIuL2V4ZWN1dG9ycy9zbGljZV9qb2luX2V4ZWN1dG9yXCIpO1xudmFyIHRyYW5zZm9ybWF0aW9uID0gcmVxdWlyZShcIi4vZXhlY3V0b3JzL3RyYW5zZm9ybWF0aW9uX2V4ZWN1dG9yXCIpO1xuZnVuY3Rpb24gZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS5jYXRlZ29yeSkge1xuICAgICAgICBjYXNlICdhcml0aG1ldGljJzpcbiAgICAgICAgICAgIHJldHVybiBhcml0aG1ldGljLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdiYXNpY19tYXRoJzpcbiAgICAgICAgICAgIHJldHVybiBiYXNpY01hdGguZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2NvbnRyb2wnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wuZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2NvbnZvbHV0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBjb252b2x1dGlvbi5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnY3JlYXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0aW9uLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2UuZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2dyYXBoJzpcbiAgICAgICAgICAgIHJldHVybiBncmFwaC5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnbG9naWNhbCc6XG4gICAgICAgICAgICByZXR1cm4gbG9naWNhbC5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnbWF0cmljZXMnOlxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpY2VzLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdub3JtYWxpemF0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemF0aW9uLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdyZWR1Y3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIHJlZHVjdGlvbi5leGVjdXRlT3Aobm9kZSwgdGVuc29yTWFwLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnc2xpY2Vfam9pbic6XG4gICAgICAgICAgICByZXR1cm4gc2xpY2VKb2luLmV4ZWN1dGVPcChub2RlLCB0ZW5zb3JNYXAsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICd0cmFuc2Zvcm1hdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb24uZXhlY3V0ZU9wKG5vZGUsIHRlbnNvck1hcCwgY29udGV4dCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIgKyBub2RlLm9wICsgXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZXhlY3V0ZU9wID0gZXhlY3V0ZU9wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlcmF0aW9uX2V4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbXBpbGVkX2FwaV8xID0gcmVxdWlyZShcIi4uL2RhdGEvY29tcGlsZWRfYXBpXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi9leGVjdXRvcnMvdXRpbHNcIik7XG52YXIgYXJpdGhtZXRpYyA9IHJlcXVpcmUoXCIuL29wX2xpc3QvYXJpdGhtZXRpYy5qc29uXCIpO1xudmFyIGJhc2ljTWF0aCA9IHJlcXVpcmUoXCIuL29wX2xpc3QvYmFzaWNfbWF0aC5qc29uXCIpO1xudmFyIGNvbnRyb2wgPSByZXF1aXJlKFwiLi9vcF9saXN0L2NvbnRyb2wuanNvblwiKTtcbnZhciBjb252b2x1dGlvbiA9IHJlcXVpcmUoXCIuL29wX2xpc3QvY29udm9sdXRpb24uanNvblwiKTtcbnZhciBjcmVhdGlvbiA9IHJlcXVpcmUoXCIuL29wX2xpc3QvY3JlYXRpb24uanNvblwiKTtcbnZhciBncmFwaCA9IHJlcXVpcmUoXCIuL29wX2xpc3QvZ3JhcGguanNvblwiKTtcbnZhciBpbWFnZSA9IHJlcXVpcmUoXCIuL29wX2xpc3QvaW1hZ2UuanNvblwiKTtcbnZhciBsb2dpY2FsID0gcmVxdWlyZShcIi4vb3BfbGlzdC9sb2dpY2FsLmpzb25cIik7XG52YXIgbWF0cmljZXMgPSByZXF1aXJlKFwiLi9vcF9saXN0L21hdHJpY2VzLmpzb25cIik7XG52YXIgbm9ybWFsaXphdGlvbiA9IHJlcXVpcmUoXCIuL29wX2xpc3Qvbm9ybWFsaXphdGlvbi5qc29uXCIpO1xudmFyIHJlZHVjdGlvbiA9IHJlcXVpcmUoXCIuL29wX2xpc3QvcmVkdWN0aW9uLmpzb25cIik7XG52YXIgc2xpY2VKb2luID0gcmVxdWlyZShcIi4vb3BfbGlzdC9zbGljZV9qb2luLmpzb25cIik7XG52YXIgdHJhbnNmb3JtYXRpb24gPSByZXF1aXJlKFwiLi9vcF9saXN0L3RyYW5zZm9ybWF0aW9uLmpzb25cIik7XG52YXIgQ09OVFJPTF9GTE9XX09QUyA9IFsnU3dpdGNoJywgJ01lcmdlJywgJ0VudGVyJywgJ0V4aXQnLCAnTmV4dEl0ZXJhdGlvbiddO1xudmFyIE9wZXJhdGlvbk1hcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uTWFwcGVyKCkge1xuICAgICAgICB2YXIgb3BzID0gW1xuICAgICAgICAgICAgYXJpdGhtZXRpYywgYmFzaWNNYXRoLCBjb250cm9sLCBjb252b2x1dGlvbiwgY3JlYXRpb24sIGxvZ2ljYWwsIGltYWdlLFxuICAgICAgICAgICAgZ3JhcGgsIG1hdHJpY2VzLCBub3JtYWxpemF0aW9uLCByZWR1Y3Rpb24sIHNsaWNlSm9pbiwgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgXTtcbiAgICAgICAgdmFyIG1hcHBlcnNKc29uID0gW10uY29uY2F0LmFwcGx5KFtdLCBvcHMubWFwKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZGVmYXVsdCA/IG9wLmRlZmF1bHQgOiBvcDsgfSkpO1xuICAgICAgICB0aGlzLm9wTWFwcGVycyA9IG1hcHBlcnNKc29uLnJlZHVjZShmdW5jdGlvbiAobWFwLCBtYXBwZXIpIHtcbiAgICAgICAgICAgIG1hcFttYXBwZXIudGZPcE5hbWVdID0gbWFwcGVyO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3BlcmF0aW9uTWFwcGVyLCBcIkluc3RhbmNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgfHwgKHRoaXMuX2luc3RhbmNlID0gbmV3IHRoaXMoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9wZXJhdGlvbk1hcHBlci5wcm90b3R5cGUuaXNDb250cm9sRmxvdyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBDT05UUk9MX0ZMT1dfT1BTLnNvbWUoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcCA9PT0gbm9kZS5vcDsgfSk7XG4gICAgfTtcbiAgICBPcGVyYXRpb25NYXBwZXIucHJvdG90eXBlLnRyYW5zZm9ybUdyYXBoID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0Zk5vZGVzID0gZ3JhcGgubm9kZTtcbiAgICAgICAgdmFyIHdpdGhDb250cm9sRmxvdyA9IGZhbHNlO1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXJzID0gW107XG4gICAgICAgIHZhciBub2RlcyA9IHRmTm9kZXMucmVkdWNlKGZ1bmN0aW9uIChtYXAsIG5vZGUpIHtcbiAgICAgICAgICAgIG1hcFtub2RlLm5hbWVdID0gX3RoaXMubWFwTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0NvbnRyb2xGbG93KG5vZGUpKVxuICAgICAgICAgICAgICAgIHdpdGhDb250cm9sRmxvdyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobm9kZS5vcCA9PT0gJ1BsYWNlaG9sZGVyJylcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcnMucHVzaChtYXBbbm9kZS5uYW1lXSk7XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dHMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMobm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1trZXldO1xuICAgICAgICAgICAgbm9kZS5pbnB1dE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSB1dGlsc18xLmdldE5vZGVOYW1lQW5kSW5kZXgobmFtZSlbMF07XG4gICAgICAgICAgICAgICAgbm9kZS5pbnB1dHMucHVzaChub2Rlc1tub2RlTmFtZV0pO1xuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVOYW1lXS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobm9kZS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXMobm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1trZXldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IG5vZGVzOiBub2RlcywgaW5wdXRzOiBpbnB1dHMsIG91dHB1dHM6IG91dHB1dHMsIHBsYWNlaG9sZGVyczogcGxhY2Vob2xkZXJzLCB3aXRoQ29udHJvbEZsb3c6IHdpdGhDb250cm9sRmxvdyB9O1xuICAgIH07XG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS5tYXBOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1hcHBlciA9IHRoaXMub3BNYXBwZXJzW25vZGUub3BdO1xuICAgICAgICBpZiAobWFwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yZmxvdyBPcCBpcyBub3Qgc3VwcG9ydGVkOiAnICsgbm9kZS5vcCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld05vZGUgPSB7XG4gICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICBvcDogbWFwcGVyLmRsT3BOYW1lLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IG1hcHBlci5jYXRlZ29yeSxcbiAgICAgICAgICAgIGlucHV0TmFtZXM6IChub2RlLmlucHV0IHx8XG4gICAgICAgICAgICAgICAgW10pLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0LnN0YXJ0c1dpdGgoJ14nKSA/IGlucHV0LnN1YnN0cigxKSA6IGlucHV0OyB9KSxcbiAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBwYXJhbXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghIW1hcHBlci5wYXJhbXMpIHtcbiAgICAgICAgICAgIG5ld05vZGUucGFyYW1zID0gbWFwcGVyLnBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRleCA9IHBhcmFtLnRmSW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRQYXJhbUxlbmd0aCA9IHBhcmFtLnRmSW5wdXRQYXJhbUxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHBhcmFtLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0U3RyaW5nUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZlBhcmFtTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmdldFN0cmluZ1BhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5nZXROdW1iZXJQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmUGFyYW1OYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEhcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0TnVtYmVyUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyW10nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0TnVtZXJpY0FycmF5UGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZlBhcmFtTmFtZSwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhIXBhcmFtLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmdldE51bWVyaWNBcnJheVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0Qm9vbFBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWUsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgISFwYXJhbS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5nZXRCb29sUGFyYW0obm9kZS5hdHRyLCBwYXJhbS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2hhcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0VGVuc29yU2hhcGVQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmUGFyYW1OYW1lLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEhcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZ2V0VGVuc29yU2hhcGVQYXJhbShub2RlLmF0dHIsIHBhcmFtLnRmUGFyYW1OYW1lRGVwcmVjYXRlZCwgcGFyYW0uZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkdHlwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5nZXREdHlwZVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWUsIHBhcmFtLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgISFwYXJhbS50ZlBhcmFtTmFtZURlcHJlY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5nZXREdHlwZVBhcmFtKG5vZGUuYXR0ciwgcGFyYW0udGZQYXJhbU5hbWVEZXByZWNhdGVkLCBwYXJhbS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RlbnNvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZW5zb3JzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcGFyYW0gdHlwZTogXCIgKyBwYXJhbS50eXBlICsgXCIgZm9yIG9wOiBcIiArIG5vZGUub3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcFtwYXJhbS5kbFBhcmFtTmFtZV0gPSB7IHZhbHVlOiB2YWx1ZSwgaW5wdXRJbmRleDogaW5wdXRJbmRleCwgdHlwZTogdHlwZSwgaW5wdXRQYXJhbUxlbmd0aDogaW5wdXRQYXJhbUxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfTtcbiAgICBPcGVyYXRpb25NYXBwZXIucHJvdG90eXBlLmdldFN0cmluZ1BhcmFtID0gZnVuY3Rpb24gKGF0dHJzLCBuYW1lLCBkZWYsIGtlZXBDYXNlKSB7XG4gICAgICAgIGlmIChrZWVwQ2FzZSA9PT0gdm9pZCAwKSB7IGtlZXBDYXNlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHBhcmFtID0gYXR0cnNbbmFtZV07XG4gICAgICAgIGlmIChwYXJhbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHBhcmFtLnMpO1xuICAgICAgICAgICAgcmV0dXJuIGtlZXBDYXNlID8gdmFsdWUgOiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfTtcbiAgICBPcGVyYXRpb25NYXBwZXIucHJvdG90eXBlLmdldEJvb2xQYXJhbSA9IGZ1bmN0aW9uIChhdHRycywgbmFtZSwgZGVmKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IGF0dHJzW25hbWVdO1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBwYXJhbS5iIDogZGVmO1xuICAgIH07XG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS5nZXROdW1iZXJQYXJhbSA9IGZ1bmN0aW9uIChhdHRycywgbmFtZSwgZGVmKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IGF0dHJzW25hbWVdO1xuICAgICAgICB2YXIgdmFsdWUgPSAocGFyYW0gPyAoKHBhcmFtLmYgIT09IHVuZGVmaW5lZCkgPyBwYXJhbS5mIDogcGFyYW0uaSkgOiBkZWYpO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpID8gdmFsdWUgOiB2YWx1ZVsndG9JbnQnXSgpO1xuICAgIH07XG4gICAgT3BlcmF0aW9uTWFwcGVyLnByb3RvdHlwZS5nZXREdHlwZVBhcmFtID0gZnVuY3Rpb24gKGF0dHJzLCBuYW1lLCBkZWYpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gYXR0cnNbbmFtZV07XG4gICAgICAgIGlmIChwYXJhbSAmJiBwYXJhbS50eXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGNvbXBpbGVkX2FwaV8xLnRlbnNvcmZsb3cuRGF0YVR5cGUuRFRfRkxPQVQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmxvYXQzMic7XG4gICAgICAgICAgICAgICAgY2FzZSBjb21waWxlZF9hcGlfMS50ZW5zb3JmbG93LkRhdGFUeXBlLkRUX0lOVDMyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2ludDMyJztcbiAgICAgICAgICAgICAgICBjYXNlIGNvbXBpbGVkX2FwaV8xLnRlbnNvcmZsb3cuRGF0YVR5cGUuRFRfQk9PTDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdib29sJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfTtcbiAgICBPcGVyYXRpb25NYXBwZXIucHJvdG90eXBlLmdldFRlbnNvclNoYXBlUGFyYW0gPSBmdW5jdGlvbiAoYXR0cnMsIG5hbWUsIGRlZikge1xuICAgICAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgaWYgKHBhcmFtICYmIHBhcmFtLnNoYXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW0uc2hhcGUuZGltLm1hcChmdW5jdGlvbiAoZGltKSB7IHJldHVybiBkaW0uc2l6ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9O1xuICAgIE9wZXJhdGlvbk1hcHBlci5wcm90b3R5cGUuZ2V0TnVtZXJpY0FycmF5UGFyYW0gPSBmdW5jdGlvbiAoYXR0cnMsIG5hbWUsIGRlZikge1xuICAgICAgICB2YXIgcGFyYW0gPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4gKChwYXJhbS5saXN0LmYgJiYgcGFyYW0ubGlzdC5mLmxlbmd0aCA/IHBhcmFtLmxpc3QuZiA6XG4gICAgICAgICAgICAgICAgcGFyYW0ubGlzdC5pKSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodHlwZW9mIHYgPT09ICdudW1iZXInKSA/IHYgOiB2Wyd0b0ludCddKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfTtcbiAgICByZXR1cm4gT3BlcmF0aW9uTWFwcGVyO1xufSgpKTtcbmV4cG9ydHMuT3BlcmF0aW9uTWFwcGVyID0gT3BlcmF0aW9uTWFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlcmF0aW9uX21hcHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2ZXJzaW9uID0gJzAuNC4xJztcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4vZG9jXCIpO1xudmFyIEJyb3dzZXJVdGlsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyVXRpbCgpIHtcbiAgICB9XG4gICAgQnJvd3NlclV0aWwubmV4dEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pOyB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnUGVyZm9ybWFuY2UnLCBzdWJoZWFkaW5nOiAnVGltaW5nJyB9KVxuICAgIF0sIEJyb3dzZXJVdGlsLCBcIm5leHRGcmFtZVwiLCBudWxsKTtcbiAgICByZXR1cm4gQnJvd3NlclV0aWw7XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VyVXRpbCA9IEJyb3dzZXJVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gICAgdmFyIGEgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhO1xuICAgIHJldHVybiAvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2lcbiAgICAgICAgLnRlc3QoYSkgfHxcbiAgICAgICAgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2lcbiAgICAgICAgICAgIC50ZXN0KGEuc3Vic3RyKDAsIDQpKTtcbn1cbmV4cG9ydHMuaXNNb2JpbGUgPSBpc01vYmlsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldmljZV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZG9jKGluZm8pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuZG9jID0gZG9jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4vb3BzL29wc1wiKTtcbnZhciBwcm9maWxlcl8xID0gcmVxdWlyZShcIi4vcHJvZmlsZXJcIik7XG52YXIgdGFwZV8xID0gcmVxdWlyZShcIi4vdGFwZVwiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBFbmdpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVuZ2luZShiYWNrZW5kLCBzYWZlTW9kZSkge1xuICAgICAgICB0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuICAgICAgICB0aGlzLnNhZmVNb2RlID0gc2FmZU1vZGU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZkNvdW50ZXIgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLm5leHRUYXBlTm9kZUlkID0gMDtcbiAgICAgICAgdGhpcy5udW1CeXRlcyA9IDA7XG4gICAgICAgIHRoaXMubnVtVGVuc29ycyA9IDA7XG4gICAgICAgIHRoaXMubnVtRGF0YUJ1ZmZlcnMgPSAwO1xuICAgICAgICB0aGlzLmdyYWRpZW50U2NvcGVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY3VzdG9tR3JhZGllbnREZXB0aCA9IDA7XG4gICAgICAgIHRoaXMua2VlcFRlbnNvcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGUgPSB7IHRyYWNrOiBbXSB9O1xuICAgICAgICB0aGlzLnNjb3BlU3RhY2sgPSBbdGhpcy5hY3RpdmVTY29wZV07XG4gICAgICAgIHRoaXMucHJvZmlsZXIgPSBuZXcgcHJvZmlsZXJfMS5Qcm9maWxlcihiYWNrZW5kKTtcbiAgICB9XG4gICAgRW5naW5lLnByb3RvdHlwZS5ydW5LZXJuZWwgPSBmdW5jdGlvbiAoZm9yd2FyZEZ1bmMsIGlucHV0cywgYmFja3dhcmRzRnVuYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgc2F2ZWQgPSBbXTtcbiAgICAgICAgdmFyIHNhdmVGdW5jID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHNhdmVkLnB1c2goeCk7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNjb3BlTmFtZSA9IHRoaXMuYWN0aXZlU2NvcGUubmFtZTtcbiAgICAgICAgdGhpcy5jdXN0b21HcmFkaWVudERlcHRoKys7XG4gICAgICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdERUJVRycpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmb3J3YXJkRnVuYyh0aGlzLmJhY2tlbmQsIHNhdmVGdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvZmlsZXIucHJvZmlsZUtlcm5lbChzY29wZU5hbWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcndhcmRGdW5jKF90aGlzLmJhY2tlbmQsIHNhdmVGdW5jKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXN0b21HcmFkaWVudERlcHRoLS07XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29yZCgpKSB7XG4gICAgICAgICAgICB2YXIgdGFwZU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMubmV4dFRhcGVOb2RlSWQrKyxcbiAgICAgICAgICAgICAgICBuYW1lOiBzY29wZU5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiByZXN1bHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGJhY2t3YXJkc0Z1bmMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcGVOb2RlLmdyYWRpZW50ID0gZnVuY3Rpb24gKGR5KSB7IHJldHVybiBiYWNrd2FyZHNGdW5jKGR5LCBzYXZlZCk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRhcGUucHVzaCh0YXBlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXJUZW5zb3IgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcmVmQ291bnQgPSB0aGlzLnJlZkNvdW50ZXIuaGFzKGEuZGF0YUlkKSA/IHRoaXMucmVmQ291bnRlci5nZXQoYS5kYXRhSWQpIDogMDtcbiAgICAgICAgdGhpcy5udW1UZW5zb3JzKys7XG4gICAgICAgIGlmIChyZWZDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5udW1EYXRhQnVmZmVycysrO1xuICAgICAgICAgICAgdGhpcy5udW1CeXRlcyArPVxuICAgICAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSAqIHV0aWwuYnl0ZXNQZXJFbGVtZW50KGEuZHR5cGUpO1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kLnJlZ2lzdGVyKGEuZGF0YUlkLCBhLnNoYXBlLCBhLmR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZkNvdW50ZXIuc2V0KGEuZGF0YUlkLCByZWZDb3VudCArIDEpO1xuICAgICAgICBpZiAoIShhIGluc3RhbmNlb2YgdGVuc29yXzEuVmFyaWFibGUpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrKGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyVmFyaWFibGUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3YubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgd2l0aCBuYW1lIFwiICsgdi5uYW1lICsgXCIgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdi5uYW1lXSA9IHY7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLmRpc3Bvc2VUZW5zb3IgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoIXRoaXMucmVmQ291bnRlci5oYXMoYS5kYXRhSWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5udW1UZW5zb3JzLS07XG4gICAgICAgIHZhciByZWZDb3VudCA9IHRoaXMucmVmQ291bnRlci5nZXQoYS5kYXRhSWQpO1xuICAgICAgICBpZiAocmVmQ291bnQgPD0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWZDb3VudGVyLmRlbGV0ZShhLmRhdGFJZCk7XG4gICAgICAgICAgICB0aGlzLmJhY2tlbmQuZGlzcG9zZURhdGEoYS5kYXRhSWQpO1xuICAgICAgICAgICAgdGhpcy5udW1EYXRhQnVmZmVycy0tO1xuICAgICAgICAgICAgdGhpcy5udW1CeXRlcyAtPVxuICAgICAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSAqIHV0aWwuYnl0ZXNQZXJFbGVtZW50KGEuZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWZDb3VudGVyLnNldChhLmRhdGFJZCwgcmVmQ291bnQgLSAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5kaXNwb3NlVmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB2YXJOYW1lIGluIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyTmFtZV07XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VUZW5zb3Iodik7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3Zhck5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLm1lbW9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZm8gPSB0aGlzLmJhY2tlbmQubWVtb3J5KCk7XG4gICAgICAgIGluZm8ubnVtVGVuc29ycyA9IHRoaXMubnVtVGVuc29ycztcbiAgICAgICAgaW5mby5udW1EYXRhQnVmZmVycyA9IHRoaXMubnVtRGF0YUJ1ZmZlcnM7XG4gICAgICAgIGluZm8ubnVtQnl0ZXMgPSB0aGlzLm51bUJ5dGVzO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuc2hvdWxkUmVjb3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVUYXBlICE9IG51bGwgJiYgdGhpcy5jdXN0b21HcmFkaWVudERlcHRoID09PSAwO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5hZGRUYXBlTm9kZSA9IGZ1bmN0aW9uIChpbnB1dHMsIHJlc3VsdCwgZ3JhZGllbnRzRnVuYykge1xuICAgICAgICB2YXIgaW5wdXRzTWFwID0ge307XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCwgaWR4KSB7XG4gICAgICAgICAgICBpbnB1dHNNYXBbaWR4XSA9IGlucHV0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGdyYWRpZW50ID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gZ3JhZGllbnRzRnVuYyhkeSk7XG4gICAgICAgICAgICB2YXIgcmVzTWFwID0ge307XG4gICAgICAgICAgICByZXMuZm9yRWFjaChmdW5jdGlvbiAociwgaWR4KSB7XG4gICAgICAgICAgICAgICAgcmVzTWFwW2lkeF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByOyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzTWFwO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFwZU5vZGUgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5uZXh0VGFwZU5vZGVJZCsrLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5hY3RpdmVTY29wZS5uYW1lLFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNNYXAsXG4gICAgICAgICAgICBvdXRwdXQ6IHJlc3VsdCxcbiAgICAgICAgICAgIGdyYWRpZW50OiBncmFkaWVudFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcGUucHVzaCh0YXBlTm9kZSk7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLmtlZXAgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlU3RhY2subGVuZ3RoID09PSAxICYmIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5zYWZlTW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYWZlIG1vZGUgaXMgT04uIEVuY2xvc2UgYWxsIHRlbnNvciBvcGVyYXRpb25zIGluc2lkZSB0Zi50aWR5KCk6ICcgK1xuICAgICAgICAgICAgICAgICd0Zi50aWR5KCgpID0+IHsuLi59KSB0byBhdm9pZCBtZW1vcnkgbGVha3MuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZWVwVGVuc29ycy5hZGQocmVzdWx0LmlkKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuc3RhcnRTY29wZSA9IGZ1bmN0aW9uIChuYW1lLCBncmFkaWVudHNNb2RlKSB7XG4gICAgICAgIGlmIChncmFkaWVudHNNb2RlID09PSB2b2lkIDApIHsgZ3JhZGllbnRzTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChncmFkaWVudHNNb2RlICYmIHRoaXMuZ3JhZGllbnRTY29wZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRhcGUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JhZGllbnRzTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFNjb3BlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcGVJbmZvID0geyB0cmFjazogW10gfTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHNjb3BlSW5mby5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjb3BlU3RhY2sucHVzaChzY29wZUluZm8pO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlID0gc2NvcGVJbmZvO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5lbmRTY29wZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGdyYWRpZW50c01vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGdyYWRpZW50c01vZGUgPT09IHZvaWQgMCkgeyBncmFkaWVudHNNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGdyYWRpZW50c01vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTY29wZUNvdW50LS07XG4gICAgICAgICAgICBpZiAodGhpcy5ncmFkaWVudFNjb3BlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhcGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW5zb3JzVG9LZWVwID0gbmV3IFNldCh0aGlzLmtlZXBUZW5zb3JzKTtcbiAgICAgICAgdmFyIHRlbnNvcnNUb1RyYWNrSW5QYXJlbnQgPSB1dGlsLmdldFRlbnNvcnNJbkNvbnRhaW5lcihyZXN1bHQpO1xuICAgICAgICB0ZW5zb3JzVG9UcmFja0luUGFyZW50LmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yc1RvS2VlcC5hZGQodGVuc29yLmlkKTsgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVTY29wZS50cmFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlbnNvciA9IHRoaXMuYWN0aXZlU2NvcGUudHJhY2tbaV07XG4gICAgICAgICAgICBpZiAodGVuc29yc1RvS2VlcC5oYXModGVuc29yLmlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVuc29yc1RvVHJhY2tJblBhcmVudC5wdXNoKHRlbnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRTY29wZSA9IHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggPT09IDAgP1xuICAgICAgICAgICAgeyB0cmFjazogW10gfSA6XG4gICAgICAgICAgICB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB0ZW5zb3JzVG9UcmFja0luUGFyZW50LmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5rZWVwVGVuc29ycy5oYXModGVuc29yLmlkKSAmJlxuICAgICAgICAgICAgICAgIHV0aWwuaXNUZW5zb3JJbkxpc3QodGVuc29yLCBvbGRTY29wZS50cmFjaykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFjayh0ZW5zb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuZ3JhZGllbnRzID0gZnVuY3Rpb24gKGYsIHhzLCBkeSwgYWxsb3dOb0dyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYWxsb3dOb0dyYWRpZW50cyA9PT0gdm9pZCAwKSB7IGFsbG93Tm9HcmFkaWVudHMgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4cy5sZW5ndGggPiAwLCAnZ3JhZGllbnRzKCkgcmVjZWl2ZWQgYW4gZW1wdHkgbGlzdCBvZiB4cy4nKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbHNfMS50aWR5KCdncmFkaWVudHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeSA9IGYoKTtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHkgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgcmVzdWx0IHkgcmV0dXJuZWQgYnkgZigpIG11c3QgYmUgYSB0ZW5zb3IuJyk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRUYXBlID0gdGFwZV8xLmdldEZpbHRlcmVkTm9kZXNYVG9ZKF90aGlzLmFjdGl2ZVRhcGUsIHhzLCB5KTtcbiAgICAgICAgICAgIGlmICghYWxsb3dOb0dyYWRpZW50cyAmJiBmaWx0ZXJlZFRhcGUubGVuZ3RoID09PSAwICYmIHhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhhdCB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggJyArXG4gICAgICAgICAgICAgICAgICAgICd0byB5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGVkR3JhZGllbnRNYXAgPSB7fTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeS5pZF0gPSAoZHkgPT0gbnVsbCkgPyBvcHMub25lcyh5LnNoYXBlKSA6IGR5O1xuICAgICAgICAgICAgdGFwZV8xLmJhY2twcm9wYWdhdGVHcmFkaWVudHMoYWNjdW11bGF0ZWRHcmFkaWVudE1hcCwgZmlsdGVyZWRUYXBlKTtcbiAgICAgICAgICAgIHZhciBncmFkcyA9IHhzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gYWNjdW11bGF0ZWRHcmFkaWVudE1hcFt4LmlkXTsgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogeSwgZ3JhZHM6IGdyYWRzIH07XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5jdXN0b21HcmFkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0Z1bmN0aW9uKGYpLCAnVGhlIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBpbnB1dHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0cy5ldmVyeShmdW5jdGlvbiAodCkgeyByZXR1cm4gdCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcjsgfSksICdUaGUgYXJncyBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSh4MSwgeDIsLi4uKSBtdXN0IGFsbCBiZSB0ZW5zb3JzJyk7XG4gICAgICAgICAgICBfdGhpcy5jdXN0b21HcmFkaWVudERlcHRoKys7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnRzRnVuYztcbiAgICAgICAgICAgIHZhciBncmFkaWVudHNNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBnbG9iYWxzXzEudGlkeShmLm5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBmLmFwcGx5KHZvaWQgMCwgaW5wdXRzKSwgdmFsdWUgPSBfYS52YWx1ZSwgZ3JhZEZ1bmMgPSBfYS5ncmFkRnVuYztcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3doZXJlIGBvYmoudmFsdWVgIGlzIGEgdGVuc29yJyk7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0Z1bmN0aW9uKGdyYWRGdW5jKSwgJ1RoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3doZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRzRnVuYyA9IGdyYWRGdW5jO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sIGdyYWRpZW50c01vZGUpO1xuICAgICAgICAgICAgX3RoaXMuY3VzdG9tR3JhZGllbnREZXB0aC0tO1xuICAgICAgICAgICAgaWYgKF90aGlzLnNob3VsZFJlY29yZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRGdW5jID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBncmFkaWVudHNGdW5jKGR5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyYWRzID0gQXJyYXkuaXNBcnJheShyZXMpID8gcmVzIDogW3Jlc107XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGdyYWRzLmxlbmd0aCA9PT0gaW5wdXRzLmxlbmd0aCwgJ1RoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc2FtZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdudW1iZXIgb2YgdGVuc29ycyBhcyBpbnB1dHMgcGFzc2VkIHRvIGYoLi4uKS4nKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnQoZ3JhZHMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3I7IH0pLCAnVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3doZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbGlzdCBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmx5IHRlbnNvcnMuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBncmFkcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZFRhcGVOb2RlKGlucHV0cywgcmVzdWx0LCBncmFkRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhSWQsIHZhbHVlcykge1xuICAgICAgICB0aGlzLmJhY2tlbmQud3JpdGUoZGF0YUlkLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5yZWFkU3luYyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5yZWFkU3luYyhkYXRhSWQpO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLnJlYWQoZGF0YUlkKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuZnJvbVBpeGVscyA9IGZ1bmN0aW9uIChwaXhlbHMsIG51bUNoYW5uZWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZnJvbVBpeGVscyhwaXhlbHMsIG51bUNoYW5uZWxzKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUudGltZSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIHRpbWluZ0luZm87XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmJhY2tlbmQudGltZShxdWVyeSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1pbmdJbmZvID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltaW5nSW5mby53YWxsTXMgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aW1pbmdJbmZvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5zY29wZVN0YWNrLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnNhZmVNb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhZmUgbW9kZSBpcyBPTi4gRW5jbG9zZSBhbGwgdGVuc29yIG9wZXJhdGlvbnMgaW5zaWRlIHRmLnRpZHkoKTogJyArXG4gICAgICAgICAgICAgICAgJ3RmLnRpZHkoKCkgPT4ge29wKCk7Li4ufSk7IHRvIGF2b2lkIG1lbW9yeSBsZWFrcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlLnRyYWNrLnB1c2gocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBFbmdpbmU7XG59KCkpO1xuZXhwb3J0cy5FbmdpbmUgPSBFbmdpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmdpbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGV2aWNlX3V0aWwgPSByZXF1aXJlKFwiLi9kZXZpY2VfdXRpbFwiKTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuL2RvY1wiKTtcbnZhciBlbmdpbmVfMSA9IHJlcXVpcmUoXCIuL2VuZ2luZVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTlVNQkVSXCJdID0gMF0gPSBcIk5VTUJFUlwiO1xuICAgIFR5cGVbVHlwZVtcIkJPT0xFQU5cIl0gPSAxXSA9IFwiQk9PTEVBTlwiO1xuICAgIFR5cGVbVHlwZVtcIlNUUklOR1wiXSA9IDJdID0gXCJTVFJJTkdcIjtcbn0pKFR5cGUgPSBleHBvcnRzLlR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IHt9KSk7XG5leHBvcnRzLlVSTF9QUk9QRVJUSUVTID0gW1xuICAgIHsgbmFtZTogJ0RFQlVHJywgdHlwZTogVHlwZS5CT09MRUFOIH0sIHsgbmFtZTogJ0lTX0JST1dTRVInLCB0eXBlOiBUeXBlLkJPT0xFQU4gfSxcbiAgICB7IG5hbWU6ICdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicsIHR5cGU6IFR5cGUuTlVNQkVSIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfVkVSU0lPTicsIHR5cGU6IFR5cGUuTlVNQkVSIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJywgdHlwZTogVHlwZS5CT09MRUFOIH0sIHtcbiAgICAgICAgbmFtZTogJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnLFxuICAgICAgICB0eXBlOiBUeXBlLkJPT0xFQU5cbiAgICB9LFxuICAgIHsgbmFtZTogJ0JBQ0tFTkQnLCB0eXBlOiBUeXBlLlNUUklORyB9XG5dO1xuZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKGdsLCBleHRlbnNpb25OYW1lKSB7XG4gICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcbiAgICByZXR1cm4gZXh0ICE9IG51bGw7XG59XG5mdW5jdGlvbiBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCB8fCAhZXhwb3J0cy5FTlYuZ2V0KCdJU19CUk9XU0VSJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LCBXZWJHTCBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gICAgdmFyIHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiAodGVtcENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8XG4gICAgICAgICAgICB0ZW1wQ2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XG59XG5mdW5jdGlvbiBsb3NlQ29udGV4dChnbCkge1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsb3NlQ29udGV4dEV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgICAgIGlmIChsb3NlQ29udGV4dEV4dGVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBXRUJHTF9sb3NlX2NvbnRleHQgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1dlYkdMVmVyc2lvbkVuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgbG9zZUNvbnRleHQoZ2wpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uKHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBxdWVyeVRpbWVyVmVyc2lvbjtcbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICBpZiAoaGFzRXh0ZW5zaW9uKGdsLCAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMicpICYmXG4gICAgICAgIHdlYkdMVmVyc2lvbiA9PT0gMikge1xuICAgICAgICBxdWVyeVRpbWVyVmVyc2lvbiA9IDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhc0V4dGVuc2lvbihnbCwgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeScpKSB7XG4gICAgICAgIHF1ZXJ5VGltZXJWZXJzaW9uID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHF1ZXJ5VGltZXJWZXJzaW9uID0gMDtcbiAgICB9XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgbG9zZUNvbnRleHQoZ2wpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlUaW1lclZlcnNpb247XG59XG5mdW5jdGlvbiBpc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGlmICghaGFzRXh0ZW5zaW9uKGdsLCAnT0VTX3RleHR1cmVfZmxvYXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWhhc0V4dGVuc2lvbihnbCwgJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdmFyIGludGVybmFsRm9ybWF0ID0gd2ViR0xWZXJzaW9uID09PSAyID8gZ2wuUkdCQTMyRiA6IGdsLlJHQkE7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgdmFyIGZyYW1lQnVmZmVyQ29tcGxldGUgPSAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIDEsIDEsIGdsLlJHQkEsIGdsLkZMT0FULCBuZXcgRmxvYXQzMkFycmF5KDQpKTtcbiAgICB2YXIgcmVhZFBpeGVsc05vRXJyb3IgPSBnbC5nZXRFcnJvcigpID09PSBnbC5OT19FUlJPUjtcbiAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgcmV0dXJuIGZyYW1lQnVmZmVyQ29tcGxldGUgJiYgcmVhZFBpeGVsc05vRXJyb3I7XG59XG5mdW5jdGlvbiBpc1dlYkdMR2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uID4gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh3ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICB2YXIgaXNFbmFibGVkID0gaGFzRXh0ZW5zaW9uKGdsLCAnV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYycpO1xuICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICByZXR1cm4gaXNFbmFibGVkO1xufVxudmFyIEVudmlyb25tZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbnZpcm9ubWVudChmZWF0dXJlcykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgICAgICAgaWYgKGZlYXR1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXQoJ0RFQlVHJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVidWdnaW5nIG1vZGUgaXMgT04uIFRoZSBvdXRwdXQgb2YgZXZlcnkgbWF0aCBjYWxsIHdpbGwgJyArXG4gICAgICAgICAgICAgICAgJ2JlIGRvd25sb2FkZWQgdG8gQ1BVIGFuZCBjaGVja2VkIGZvciBOYU5zLiAnICtcbiAgICAgICAgICAgICAgICAnVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRW52aXJvbm1lbnQuc2V0QmFja2VuZCA9IGZ1bmN0aW9uIChiYWNrZW5kVHlwZSwgc2FmZU1vZGUpIHtcbiAgICAgICAgaWYgKHNhZmVNb2RlID09PSB2b2lkIDApIHsgc2FmZU1vZGUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoIShiYWNrZW5kVHlwZSBpbiBleHBvcnRzLkVOVi5yZWdpc3RyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tlbmQgdHlwZSAnXCIgKyBiYWNrZW5kVHlwZSArIFwiJyBub3QgZm91bmQgaW4gcmVnaXN0cnlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5FTlYuaW5pdEJhY2tlbmQoYmFja2VuZFR5cGUsIHNhZmVNb2RlKTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LmdldEJhY2tlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV4cG9ydHMuRU5WLmluaXREZWZhdWx0QmFja2VuZCgpO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5FTlYuY3VycmVudEJhY2tlbmQ7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5kaXNwb3NlVmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBleHBvcnRzLkVOVi5lbmdpbmUuZGlzcG9zZVZhcmlhYmxlcygpO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQubWVtb3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5FTlYuZW5naW5lLm1lbW9yeSgpO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlIGluIHRoaXMuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzW2ZlYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV0gPSB0aGlzLmV2YWx1YXRlRmVhdHVyZShmZWF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV07XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGZlYXR1cmUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5nZXRCZXN0QmFja2VuZFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYmFja2VuZCBmb3VuZCBpbiByZWdpc3RyeS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc29ydGVkQmFja2VuZHMgPSBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgZW50cnk6IF90aGlzLnJlZ2lzdHJ5W25hbWVdIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIuZW50cnkucHJpb3JpdHkgLSBhLmVudHJ5LnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZEJhY2tlbmRzWzBdLm5hbWU7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZXZhbHVhdGVGZWF0dXJlID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgPT09ICdERUJVRycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnSVNfQlJPV1NFUicpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnSVNfTk9ERScpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ0JBQ0tFTkQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCZXN0QmFja2VuZFR5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSB7XG4gICAgICAgICAgICB2YXIgd2ViR0xWZXJzaW9uID0gdGhpcy5nZXQoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICAgICAgICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRXZWJHTERpc2pvaW50UXVlcnlUaW1lclZlcnNpb24od2ViR0xWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpID4gMCAmJlxuICAgICAgICAgICAgICAgICFkZXZpY2VfdXRpbC5pc01vYmlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9WRVJTSU9OJykge1xuICAgICAgICAgICAgaWYgKGlzV2ViR0xWZXJzaW9uRW5hYmxlZCgyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNXZWJHTFZlcnNpb25FbmFibGVkKDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQodGhpcy5nZXQoJ1dFQkdMX1ZFUlNJT04nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNXZWJHTEdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbkVuYWJsZWQodGhpcy5nZXQoJ1dFQkdMX1ZFUlNJT04nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmZWF0dXJlIFwiICsgZmVhdHVyZSArIFwiLlwiKTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5zZXRGZWF0dXJlcyA9IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBnZXRGZWF0dXJlc0Zyb21VUkwoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsRW5naW5lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRW5naW5lID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmluaXRCYWNrZW5kID0gZnVuY3Rpb24gKGJhY2tlbmRUeXBlLCBzYWZlTW9kZSkge1xuICAgICAgICBpZiAoc2FmZU1vZGUgPT09IHZvaWQgMCkgeyBzYWZlTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kVHlwZTtcbiAgICAgICAgdmFyIGJhY2tlbmQgPSBleHBvcnRzLkVOVi5maW5kQmFja2VuZChiYWNrZW5kVHlwZSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsRW5naW5lID0gbmV3IGVuZ2luZV8xLkVuZ2luZShiYWNrZW5kLCBzYWZlTW9kZSk7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZmluZEJhY2tlbmQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoIShuYW1lIGluIHRoaXMucmVnaXN0cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVtuYW1lXS5iYWNrZW5kO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLnJlZ2lzdGVyQmFja2VuZCA9IGZ1bmN0aW9uIChuYW1lLCBmYWN0b3J5LCBwcmlvcml0eSkge1xuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkgeyBwcmlvcml0eSA9IDE7IH1cbiAgICAgICAgaWYgKG5hbWUgaW4gdGhpcy5yZWdpc3RyeSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBiYWNrZW5kIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBiYWNrZW5kID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyeVtuYW1lXSA9IHsgYmFja2VuZDogYmFja2VuZCwgcHJpb3JpdHk6IHByaW9yaXR5IH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJSZWdpc3RyYXRpb24gb2YgYmFja2VuZCBcIiArIG5hbWUgKyBcIiBmYWlsZWRcIik7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLnJlbW92ZUJhY2tlbmQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoIShuYW1lIGluIHRoaXMucmVnaXN0cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIGJhY2tlbmQgbm90IGZvdW5kIGluIHJlZ2lzdHJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0cnlbbmFtZV0uYmFja2VuZC5kaXNwb3NlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5W25hbWVdO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVudmlyb25tZW50LnByb3RvdHlwZSwgXCJlbmdpbmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERlZmF1bHRCYWNrZW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxFbmdpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5pbml0RGVmYXVsdEJhY2tlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdsb2JhbEVuZ2luZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRCYWNrZW5kKGV4cG9ydHMuRU5WLmdldCgnQkFDS0VORCcpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnRW52aXJvbm1lbnQnIH0pXG4gICAgXSwgRW52aXJvbm1lbnQsIFwic2V0QmFja2VuZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ0Vudmlyb25tZW50JyB9KVxuICAgIF0sIEVudmlyb25tZW50LCBcImdldEJhY2tlbmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdFbnZpcm9ubWVudCcgfSlcbiAgICBdLCBFbnZpcm9ubWVudCwgXCJkaXNwb3NlVmFyaWFibGVzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnUGVyZm9ybWFuY2UnLCBzdWJoZWFkaW5nOiAnTWVtb3J5JyB9KVxuICAgIF0sIEVudmlyb25tZW50LCBcIm1lbW9yeVwiLCBudWxsKTtcbiAgICByZXR1cm4gRW52aXJvbm1lbnQ7XG59KCkpO1xuZXhwb3J0cy5FbnZpcm9ubWVudCA9IEVudmlyb25tZW50O1xudmFyIFRFTlNPUkZMT1dKU19GTEFHU19QUkVGSVggPSAndGZqc2ZsYWdzJztcbmZ1bmN0aW9uIGdldEZlYXR1cmVzRnJvbVVSTCgpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5sb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICB2YXIgdXJsUGFyYW1zID0gdXRpbC5nZXRRdWVyeVBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICBpZiAoVEVOU09SRkxPV0pTX0ZMQUdTX1BSRUZJWCBpbiB1cmxQYXJhbXMpIHtcbiAgICAgICAgdmFyIHVybEZsYWdzXzEgPSB7fTtcbiAgICAgICAgdmFyIGtleVZhbHVlcyA9IHVybFBhcmFtc1tURU5TT1JGTE9XSlNfRkxBR1NfUFJFRklYXS5zcGxpdCgnLCcpO1xuICAgICAgICBrZXlWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGtleVZhbHVlLnNwbGl0KCc6JyksIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgdXJsRmxhZ3NfMVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBleHBvcnRzLlVSTF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHVybFByb3BlcnR5KSB7XG4gICAgICAgICAgICBpZiAodXJsUHJvcGVydHkubmFtZSBpbiB1cmxGbGFnc18xKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZXR0aW5nIGZlYXR1cmUgb3ZlcnJpZGUgZnJvbSBVUkwgXCIgKyB1cmxQcm9wZXJ0eS5uYW1lICsgXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyB1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdKSk7XG4gICAgICAgICAgICAgICAgaWYgKHVybFByb3BlcnR5LnR5cGUgPT09IFR5cGUuTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzW3VybFByb3BlcnR5Lm5hbWVdID0gK3VybEZsYWdzXzFbdXJsUHJvcGVydHkubmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVybFByb3BlcnR5LnR5cGUgPT09IFR5cGUuQk9PTEVBTikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1t1cmxQcm9wZXJ0eS5uYW1lXSA9IHVybEZsYWdzXzFbdXJsUHJvcGVydHkubmFtZV0gPT09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXJsUHJvcGVydHkudHlwZSA9PT0gVHlwZS5TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXNbdXJsUHJvcGVydHkubmFtZV0gPSB1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBVUkwgcGFyYW06IFwiICsgdXJsUHJvcGVydHkubmFtZSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxOYW1lc3BhY2UoKSB7XG4gICAgdmFyIG5zO1xuICAgIGlmICh0eXBlb2YgKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5zID0gd2luZG93O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5zID0gZ2xvYmFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5zO1xufVxuZnVuY3Rpb24gZ2V0T3JNYWtlRW52aXJvbm1lbnQoKSB7XG4gICAgdmFyIG5zID0gZ2V0R2xvYmFsTmFtZXNwYWNlKCk7XG4gICAgbnMuRU5WID0gbnMuRU5WIHx8IG5ldyBFbnZpcm9ubWVudChnZXRGZWF0dXJlc0Zyb21VUkwoKSk7XG4gICAgcmV0dXJuIG5zLkVOVjtcbn1cbmV4cG9ydHMuRU5WID0gZ2V0T3JNYWtlRW52aXJvbm1lbnQoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudmlyb25tZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYWRpZW50c18xID0gcmVxdWlyZShcIi4vZ3JhZGllbnRzXCIpO1xudmFyIHRyYWNraW5nXzEgPSByZXF1aXJlKFwiLi90cmFja2luZ1wiKTtcbmV4cG9ydHMudGlkeSA9IHRyYWNraW5nXzEuVHJhY2tpbmcudGlkeTtcbmV4cG9ydHMua2VlcCA9IHRyYWNraW5nXzEuVHJhY2tpbmcua2VlcDtcbmV4cG9ydHMuZGlzcG9zZSA9IHRyYWNraW5nXzEuVHJhY2tpbmcuZGlzcG9zZTtcbmV4cG9ydHMudGltZSA9IHRyYWNraW5nXzEuVHJhY2tpbmcudGltZTtcbmV4cG9ydHMuZ3JhZCA9IGdyYWRpZW50c18xLkdyYWRpZW50cy5ncmFkO1xuZXhwb3J0cy52YWx1ZUFuZEdyYWQgPSBncmFkaWVudHNfMS5HcmFkaWVudHMudmFsdWVBbmRHcmFkO1xuZXhwb3J0cy5ncmFkcyA9IGdyYWRpZW50c18xLkdyYWRpZW50cy5ncmFkcztcbmV4cG9ydHMudmFsdWVBbmRHcmFkcyA9IGdyYWRpZW50c18xLkdyYWRpZW50cy52YWx1ZUFuZEdyYWRzO1xuZXhwb3J0cy52YXJpYWJsZUdyYWRzID0gZ3JhZGllbnRzXzEuR3JhZGllbnRzLnZhcmlhYmxlR3JhZHM7XG5leHBvcnRzLmN1c3RvbUdyYWQgPSBncmFkaWVudHNfMS5HcmFkaWVudHMuY3VzdG9tR3JhZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi90ZW5zb3JcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgR3JhZGllbnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFkaWVudHMoKSB7XG4gICAgfVxuICAgIEdyYWRpZW50cy5ncmFkU2NvcGUgPSBmdW5jdGlvbiAobmFtZU9yU2NvcGVGbiwgc2NvcGVGbikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsc18xLnRpZHkobmFtZU9yU2NvcGVGbiwgc2NvcGVGbiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBHcmFkaWVudHMuZ3JhZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiBncmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIGR5KSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh4IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yLCAnVGhlIHggcGFzc2VkIGluIGdyYWQoZikoeCkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoZHkgPT0gbnVsbCB8fCBkeSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSBkeSBwYXNzZWQgaW4gZ3JhZChmKSh4LCBkeSkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZ3JhZGllbnRzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoeCk7IH0sIFt4XSwgZHkpLCB2YWx1ZSA9IF9hLnZhbHVlLCBncmFkcyA9IF9hLmdyYWRzO1xuICAgICAgICAgICAgICAgIGlmIChkeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2godmFsdWUuc2hhcGUsIGR5LnNoYXBlLCAnVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkKGYpKHgsIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5lZCBieSBmKHgpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrR3JhZHMoZ3JhZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBncmFkc1swXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgR3JhZGllbnRzLmdyYWRzID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0Z1bmN0aW9uKGYpLCAnVGhlIGYgcGFzc2VkIGluIGdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MsIGR5KSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yOyB9KSwgJ1RoZSBhcmdzIHBhc3NlZCBpbiBncmFkcyhmKShhcmdzKSBtdXN0IGJlIGFuIGFycmF5IG9mIHRlbnNvcnMnKTtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGR5ID09IG51bGwgfHwgZHkgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgZHkgcGFzc2VkIGluIGdyYWRzKGYpKGFyZ3MsIGR5KSBtdXN0IGJlIGEgdGVuc29yJyk7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ncmFkaWVudHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gZi5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9LCBhcmdzLCBkeSksIHZhbHVlID0gX2EudmFsdWUsIGdyYWRzID0gX2EuZ3JhZHM7XG4gICAgICAgICAgICAgICAgaWYgKGR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCh2YWx1ZS5zaGFwZSwgZHkuc2hhcGUsICdUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIGdyYWRzKGYpKFt4MSwuLi5dLCBkeSkgbXVzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZihbeDEsLi4uXSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hlY2tHcmFkcyhncmFkcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYWRzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBHcmFkaWVudHMudmFsdWVBbmRHcmFkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0Z1bmN0aW9uKGYpLCAnVGhlIGYgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBkeSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoeCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSB4IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoZHkgPT0gbnVsbCB8fCBkeSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgsIGR5KSBtdXN0IGJlIGEgdGVuc29yJyk7XG4gICAgICAgICAgICB2YXIgX2EgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZ3JhZGllbnRzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoeCk7IH0sIFt4XSwgZHkpLCBncmFkcyA9IF9hLmdyYWRzLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgY2hlY2tHcmFkcyhncmFkcyk7XG4gICAgICAgICAgICByZXR1cm4geyBncmFkOiBncmFkc1swXSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBHcmFkaWVudHMudmFsdWVBbmRHcmFkcyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MsIGR5KSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yOyB9KSwgJ1RoZSBhcmdzIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKGFyZ3MpIG11c3QgYmUgYXJyYXkgb2YgdGVuc29ycycpO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoZHkgPT0gbnVsbCB8fCBkeSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzLCBkeSkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ncmFkaWVudHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gZi5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9LCBhcmdzLCBkeSk7XG4gICAgICAgICAgICBpZiAoZHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gocmVzLnZhbHVlLnNoYXBlLCBkeS5zaGFwZSwgJ1RoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZihbeDEsLi4uXSknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrR3JhZHMocmVzLmdyYWRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBHcmFkaWVudHMudmFyaWFibGVHcmFkcyA9IGZ1bmN0aW9uIChmLCB2YXJMaXN0KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJMaXN0ID09IG51bGwgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFyTGlzdCkgJiYgdmFyTGlzdC5ldmVyeShmdW5jdGlvbiAodikgeyByZXR1cm4gdiBpbnN0YW5jZW9mIHRlbnNvcl8xLlZhcmlhYmxlOyB9KSwgJ1RoZSB2YXJMaXN0IHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYsIHZhckxpc3QpIG11c3QgYmUgYW4gYXJyYXkgJyArXG4gICAgICAgICAgICAnb2YgdmFyaWFibGVzJyk7XG4gICAgICAgIGlmICh2YXJMaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhckxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHZhck5hbWUgaW4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXJMaXN0LnB1c2goZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbFZhckNvdW50ID0gdmFyTGlzdC5sZW5ndGg7XG4gICAgICAgIHZhckxpc3QgPSB2YXJMaXN0LmZpbHRlcihmdW5jdGlvbiAodmFyaWFibGUpIHsgcmV0dXJuIHZhcmlhYmxlLnRyYWluYWJsZTsgfSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhckxpc3QubGVuZ3RoID4gMCwgXCJ2YXJpYWJsZUdyYWRzKCkgZXhwZWN0cyBhdCBsZWFzdCBvbmUgb2YgdGhlIGlucHV0IHZhcmlhYmxlcyB0byBiZSBcIiArXG4gICAgICAgICAgICAoXCJ0cmFpbmFibGUsIGJ1dCBub25lIG9mIHRoZSBcIiArIG9yaWdpbmFsVmFyQ291bnQgKyBcIiB2YXJpYWJsZXMgaXMgXCIpICtcbiAgICAgICAgICAgIFwidHJhaW5hYmxlLlwiKTtcbiAgICAgICAgdmFyIGFsbG93Tm9HcmFkaWVudHMgPSB0cnVlO1xuICAgICAgICB2YXIgX2EgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZ3JhZGllbnRzKGYsIHZhckxpc3QsIG51bGwsIGFsbG93Tm9HcmFkaWVudHMpLCB2YWx1ZSA9IF9hLnZhbHVlLCBncmFkcyA9IF9hLmdyYWRzO1xuICAgICAgICB1dGlsLmFzc2VydChncmFkcy5zb21lKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnICE9IG51bGw7IH0pLCAnQ2Fubm90IGZpbmQgYSBjb25uZWN0aW9uIGJldHdlZW4gYW55IHZhcmlhYmxlIGFuZCB0aGUgcmVzdWx0IG9mIHRoZSAnICtcbiAgICAgICAgICAgICdsb3NzIGZ1bmN0aW9uIHk9Zih4KS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3BlcmF0aW9ucyB0aGF0IHVzZSAnICtcbiAgICAgICAgICAgICd2YXJpYWJsZXMgYXJlIGluc2lkZSB0aGUgZnVuY3Rpb24gZiBwYXNzZWQgdG8gbWluaW1pemUoKS4nKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodmFsdWUucmFuayA9PT0gMCwgXCJUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IHJldHVybiBhIHNjYWxhciwgYnV0IGl0IFwiICtcbiAgICAgICAgICAgIChcInJldHVybmVkIGEgcmFuay1cIiArIHZhbHVlLnJhbmsgKyBcIiB0ZW5zb3JcIikpO1xuICAgICAgICB2YXIgbmFtZWRHcmFkcyA9IHt9O1xuICAgICAgICB2YXJMaXN0LmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgIGlmIChncmFkc1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmFtZWRHcmFkc1t2Lm5hbWVdID0gZ3JhZHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGdyYWRzOiBuYW1lZEdyYWRzIH07XG4gICAgfTtcbiAgICBHcmFkaWVudHMuY3VzdG9tR3JhZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuY3VzdG9tR3JhZChmKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJncmFkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJncmFkc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0dyYWRpZW50cycgfSlcbiAgICBdLCBHcmFkaWVudHMsIFwidmFsdWVBbmRHcmFkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJ2YWx1ZUFuZEdyYWRzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJ2YXJpYWJsZUdyYWRzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJjdXN0b21HcmFkXCIsIG51bGwpO1xuICAgIHJldHVybiBHcmFkaWVudHM7XG59KCkpO1xuZXhwb3J0cy5HcmFkaWVudHMgPSBHcmFkaWVudHM7XG5mdW5jdGlvbiBjaGVja0dyYWRzKGdyYWRzKSB7XG4gICAgdmFyIG51bU51bGxHcmFkaWVudHMgPSBncmFkcy5maWx0ZXIoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIGcgPT0gbnVsbDsgfSkubGVuZ3RoO1xuICAgIGlmIChudW1OdWxsR3JhZGllbnRzID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0XFxuICAgIHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFkaWVudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucmVxdWlyZShcIi4va2VybmVscy9iYWNrZW5kX3dlYmdsXCIpO1xucmVxdWlyZShcIi4va2VybmVscy9iYWNrZW5kX2NwdVwiKTtcbnZhciBicm93c2VyX3V0aWxfMSA9IHJlcXVpcmUoXCIuL2Jyb3dzZXJfdXRpbFwiKTtcbnZhciBlbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciBpbyA9IHJlcXVpcmUoXCIuL2lvL2lvXCIpO1xuZXhwb3J0cy5pbyA9IGlvO1xudmFyIHNlcmlhbGl6YXRpb24gPSByZXF1aXJlKFwiLi9zZXJpYWxpemF0aW9uXCIpO1xuZXhwb3J0cy5zZXJpYWxpemF0aW9uID0gc2VyaWFsaXphdGlvbjtcbnZhciB0ZXN0X3V0aWwgPSByZXF1aXJlKFwiLi90ZXN0X3V0aWxcIik7XG5leHBvcnRzLnRlc3RfdXRpbCA9IHRlc3RfdXRpbDtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMudXRpbCA9IHV0aWw7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMudmVyc2lvbl9jb3JlID0gdmVyc2lvbl8xLnZlcnNpb247XG52YXIgd2ViZ2wgPSByZXF1aXJlKFwiLi93ZWJnbFwiKTtcbmV4cG9ydHMud2ViZ2wgPSB3ZWJnbDtcbnZhciBhZGFkZWx0YV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvYWRhZGVsdGFfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFkZWx0YU9wdGltaXplciA9IGFkYWRlbHRhX29wdGltaXplcl8xLkFkYWRlbHRhT3B0aW1pemVyO1xudmFyIGFkYWdyYWRfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYWdyYWRfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFncmFkT3B0aW1pemVyID0gYWRhZ3JhZF9vcHRpbWl6ZXJfMS5BZGFncmFkT3B0aW1pemVyO1xudmFyIGFkYW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYW1fb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFtT3B0aW1pemVyID0gYWRhbV9vcHRpbWl6ZXJfMS5BZGFtT3B0aW1pemVyO1xudmFyIGFkYW1heF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvYWRhbWF4X29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhbWF4T3B0aW1pemVyID0gYWRhbWF4X29wdGltaXplcl8xLkFkYW1heE9wdGltaXplcjtcbnZhciBtb21lbnR1bV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvbW9tZW50dW1fb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5Nb21lbnR1bU9wdGltaXplciA9IG1vbWVudHVtX29wdGltaXplcl8xLk1vbWVudHVtT3B0aW1pemVyO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLk9wdGltaXplciA9IG9wdGltaXplcl8xLk9wdGltaXplcjtcbnZhciBybXNwcm9wX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9ybXNwcm9wX29wdGltaXplclwiKTtcbmV4cG9ydHMuUk1TUHJvcE9wdGltaXplciA9IHJtc3Byb3Bfb3B0aW1pemVyXzEuUk1TUHJvcE9wdGltaXplcjtcbnZhciBzZ2Rfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL3NnZF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLlNHRE9wdGltaXplciA9IHNnZF9vcHRpbWl6ZXJfMS5TR0RPcHRpbWl6ZXI7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi90ZW5zb3JcIik7XG5leHBvcnRzLlRlbnNvciA9IHRlbnNvcl8xLlRlbnNvcjtcbmV4cG9ydHMuVGVuc29yQnVmZmVyID0gdGVuc29yXzEuVGVuc29yQnVmZmVyO1xuZXhwb3J0cy52YXJpYWJsZSA9IHRlbnNvcl8xLnZhcmlhYmxlO1xuZXhwb3J0cy5WYXJpYWJsZSA9IHRlbnNvcl8xLlZhcmlhYmxlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmV4cG9ydHMuUmFuayA9IHR5cGVzXzEuUmFuaztcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL29wcy9vcHNcIikpO1xudmFyIGxvc3Nfb3BzXzEgPSByZXF1aXJlKFwiLi9vcHMvbG9zc19vcHNcIik7XG5leHBvcnRzLlJlZHVjdGlvbiA9IGxvc3Nfb3BzXzEuUmVkdWN0aW9uO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhaW5cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vZ2xvYmFsc1wiKSk7XG52YXIgZW52aXJvbm1lbnRfMiA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5FTlYgPSBlbnZpcm9ubWVudF8yLkVOVjtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudF8yLkVudmlyb25tZW50O1xuZXhwb3J0cy5zZXRCYWNrZW5kID0gZW52aXJvbm1lbnRfMS5FbnZpcm9ubWVudC5zZXRCYWNrZW5kO1xuZXhwb3J0cy5nZXRCYWNrZW5kID0gZW52aXJvbm1lbnRfMS5FbnZpcm9ubWVudC5nZXRCYWNrZW5kO1xuZXhwb3J0cy5kaXNwb3NlVmFyaWFibGVzID0gZW52aXJvbm1lbnRfMS5FbnZpcm9ubWVudC5kaXNwb3NlVmFyaWFibGVzO1xuZXhwb3J0cy5tZW1vcnkgPSBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50Lm1lbW9yeTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuL2RvY1wiKTtcbmV4cG9ydHMuZG9jID0gZG9jXzEuZG9jO1xuZXhwb3J0cy5uZXh0RnJhbWUgPSBicm93c2VyX3V0aWxfMS5Ccm93c2VyVXRpbC5uZXh0RnJhbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgaW9fdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2lvX3V0aWxzXCIpO1xudmFyIHJvdXRlcl9yZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vcm91dGVyX3JlZ2lzdHJ5XCIpO1xudmFyIERFRkFVTFRfRklMRV9OQU1FX1BSRUZJWCA9ICdtb2RlbCc7XG52YXIgREVGQVVMVF9KU09OX0VYVEVOU0lPTl9OQU1FID0gJy5qc29uJztcbnZhciBERUZBVUxUX1dFSUdIVF9EQVRBX0VYVEVOU0lPTl9OQU1FID0gJy53ZWlnaHRzLmJpbic7XG52YXIgQnJvd3NlckRvd25sb2FkcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckRvd25sb2FkcyhmaWxlTmFtZVByZWZpeCkge1xuICAgICAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyaWdnZXJEb3dubG9hZHMoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50ICcgK1xuICAgICAgICAgICAgICAgICdpcyBub3QgYSBicm93c2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlTmFtZVByZWZpeC5zdGFydHNXaXRoKEJyb3dzZXJEb3dubG9hZHMuVVJMX1NDSEVNRSkpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lUHJlZml4ID0gZmlsZU5hbWVQcmVmaXguc2xpY2UoQnJvd3NlckRvd25sb2Fkcy5VUkxfU0NIRU1FLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVOYW1lUHJlZml4ID09IG51bGwgfHwgZmlsZU5hbWVQcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaWxlTmFtZVByZWZpeCA9IERFRkFVTFRfRklMRV9OQU1FX1BSRUZJWDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZSA9IGZpbGVOYW1lUHJlZml4ICsgREVGQVVMVF9KU09OX0VYVEVOU0lPTl9OQU1FO1xuICAgICAgICB0aGlzLndlaWdodERhdGFGaWxlTmFtZSA9XG4gICAgICAgICAgICBmaWxlTmFtZVByZWZpeCArIERFRkFVTFRfV0VJR0hUX0RBVEFfRVhURU5TSU9OX05BTUU7XG4gICAgfVxuICAgIEJyb3dzZXJEb3dubG9hZHMucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAobW9kZWxBcnRpZmFjdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdlaWdodHNVUkwsIHdlaWdodHNNYW5pZmVzdCwgbW9kZWxUb3BvbG9neUFuZFdlaWdodE1hbmlmZXN0LCBtb2RlbFRvcG9sb2d5QW5kV2VpZ2h0TWFuaWZlc3RVUkwsIGpzb25BbmNob3IsIHdlaWdodERhdGFBbmNob3I7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0c1VSTCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFttb2RlbEFydGlmYWN0cy53ZWlnaHREYXRhXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsQXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rvd25sb2FkVHJpZ2dlci5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW4gYmluYXJ5IGZvcm1hdHMgeWV0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c01hbmlmZXN0ID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoczogWycuLycgKyB0aGlzLndlaWdodERhdGFGaWxlTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0czogbW9kZWxBcnRpZmFjdHMud2VpZ2h0U3BlY3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5QW5kV2VpZ2h0TWFuaWZlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5OiBtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c01hbmlmZXN0OiB3ZWlnaHRzTWFuaWZlc3RcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb3BvbG9neUFuZFdlaWdodE1hbmlmZXN0VVJMID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KG1vZGVsVG9wb2xvZ3lBbmRXZWlnaHRNYW5pZmVzdCldLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGpzb25BbmNob3IgPSB0aGlzLmpzb25BbmNob3IgPT0gbnVsbCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmpzb25BbmNob3I7XG4gICAgICAgICAgICAgICAgICAgIGpzb25BbmNob3IuZG93bmxvYWQgPSB0aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAganNvbkFuY2hvci5ocmVmID0gbW9kZWxUb3BvbG9neUFuZFdlaWdodE1hbmlmZXN0VVJMO1xuICAgICAgICAgICAgICAgICAgICBqc29uQW5jaG9yLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbEFydGlmYWN0cy53ZWlnaHREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodERhdGFBbmNob3IgPSB0aGlzLndlaWdodERhdGFBbmNob3IgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndlaWdodERhdGFBbmNob3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHREYXRhQW5jaG9yLmRvd25sb2FkID0gdGhpcy53ZWlnaHREYXRhRmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHREYXRhQW5jaG9yLmhyZWYgPSB3ZWlnaHRzVVJMO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RGF0YUFuY2hvci5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBtb2RlbEFydGlmYWN0c0luZm86IGlvX3V0aWxzXzEuZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTihtb2RlbEFydGlmYWN0cykgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VyRG93bmxvYWRzLlVSTF9TQ0hFTUUgPSAnZG93bmxvYWRzOi8vJztcbiAgICByZXR1cm4gQnJvd3NlckRvd25sb2Fkcztcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJEb3dubG9hZHMgPSBCcm93c2VyRG93bmxvYWRzO1xudmFyIEJyb3dzZXJGaWxlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckZpbGVzKGZpbGVzKSB7XG4gICAgICAgIGlmIChmaWxlcyA9PSBudWxsIHx8IGZpbGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyBicm93c2VyRmlsZXMsIGF0IGxlYXN0IDEgZmlsZSBpcyByZXF1aXJlZCwgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCByZWNlaXZlZCBcIiArIGZpbGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWxlcyA9IGZpbGVzO1xuICAgIH1cbiAgICBCcm93c2VyRmlsZXMucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIganNvbkZpbGUsIHdlaWdodEZpbGVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGpzb25GaWxlID0gdGhpcy5maWxlc1swXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRGaWxlcyA9IHRoaXMuZmlsZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIganNvblJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbEpTT04gPSBKU09OLnBhcnNlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbFRvcG9sb2d5ID0gbW9kZWxKU09OLm1vZGVsVG9wb2xvZ3k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsVG9wb2xvZ3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwibW9kZWxUb3BvbG9neSBmaWVsZCBpcyBtaXNzaW5nIGZyb20gZmlsZSBcIiArIGpzb25GaWxlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0RmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBtb2RlbFRvcG9sb2d5OiBtb2RlbFRvcG9sb2d5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0c01hbmlmZXN0ID0gbW9kZWxKU09OLndlaWdodHNNYW5pZmVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0c01hbmlmZXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIndlaWdodE1hbmlmZXN0IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlIFwiICsganNvbkZpbGUubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoVG9GaWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhUb0ZpbGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzKHdlaWdodHNNYW5pZmVzdCwgd2VpZ2h0RmlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRTcGVjcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJGaWxlQnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdC5mb3JFYWNoKGZ1bmN0aW9uICh3ZWlnaHRzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c0dyb3VwLnBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJGaWxlQnVmZmVycy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0U3BlY3MucHVzaC5hcHBseSh3ZWlnaHRTcGVjcywgd2VpZ2h0c0dyb3VwLndlaWdodHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdC5mb3JFYWNoKGZ1bmN0aW9uICh3ZWlnaHRzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c0dyb3VwLnBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRGaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodEZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodERhdGEgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhzLmluZGV4T2YocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyRmlsZUJ1ZmZlcnNbaW5kZXhdID0gd2VpZ2h0RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVyRmlsZUJ1ZmZlcnMuaW5kZXhPZihudWxsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5OiBtb2RlbFRvcG9sb2d5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0U3BlY3M6IHdlaWdodFNwZWNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RGF0YTogaW9fdXRpbHNfMS5jb25jYXRlbmF0ZUFycmF5QnVmZmVycyhwZXJGaWxlQnVmZmVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRGaWxlUmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgdG8gd2VpZ2h0cyBkYXRhIGZyb20gZmlsZSBvZiBwYXRoICdcIiArIHBhdGggKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRGaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHBhdGhUb0ZpbGVbcGF0aF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uUmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgdG8gcmVhZCBtb2RlbCB0b3BvbG9neSBhbmQgd2VpZ2h0cyBtYW5pZmVzdCBKU09OIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiZnJvbSBmaWxlICdcIiArIGpzb25GaWxlLm5hbWUgKyBcIicuIEJyb3dzZXJGaWxlcyBzdXBwb3J0cyBsb2FkaW5nIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiS2VyYXMtc3R5bGUgdGYuTW9kZWwgYXJ0aWZhY3RzIG9ubHkuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uUmVhZGVyLnJlYWRBc1RleHQoanNvbkZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VyRmlsZXMucHJvdG90eXBlLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcyA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgZmlsZXMpIHtcbiAgICAgICAgdmFyIGJhc2VuYW1lcyA9IFtdO1xuICAgICAgICB2YXIgZmlsZU5hbWVzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiBpb191dGlsc18xLmJhc2VuYW1lKGZpbGUubmFtZSk7IH0pO1xuICAgICAgICB2YXIgcGF0aFRvRmlsZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1hbmlmZXN0XzEgPSBtYW5pZmVzdDsgX2kgPCBtYW5pZmVzdF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gbWFuaWZlc3RfMVtfaV07XG4gICAgICAgICAgICBncm91cC5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhCYXNlbmFtZSA9IGlvX3V0aWxzXzEuYmFzZW5hbWUocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VuYW1lcy5pbmRleE9mKHBhdGhCYXNlbmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBmaWxlIGJhc2VuYW1lIGZvdW5kIGluIHdlaWdodHMgbWFuaWZlc3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIidcIiArIHBhdGhCYXNlbmFtZSArIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhc2VuYW1lcy5wdXNoKHBhdGhCYXNlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lcy5pbmRleE9mKHBhdGhCYXNlbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlaWdodCBmaWxlIHdpdGggYmFzZW5hbWUgJ1wiICsgcGF0aEJhc2VuYW1lICsgXCInIGlzIG5vdCBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRoVG9GaWxlW3BhdGhdID0gZmlsZXNbZmlsZU5hbWVzLmluZGV4T2YocGF0aEJhc2VuYW1lKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VuYW1lcy5sZW5ndGggIT09IGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBmaWxlcyBpbiB3ZWlnaHRzIG1hbmlmZXN0IFwiICtcbiAgICAgICAgICAgICAgICAoXCIoXCIgKyBiYXNlbmFtZXMubGVuZ3RoICsgXCIpIGFuZCB0aGUgbnVtYmVyIG9mIHdlaWdodCBmaWxlcyBwcm92aWRlZCBcIikgK1xuICAgICAgICAgICAgICAgIChcIihcIiArIGZpbGVzLmxlbmd0aCArIFwiKS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoVG9GaWxlO1xuICAgIH07XG4gICAgcmV0dXJuIEJyb3dzZXJGaWxlcztcbn0oKSk7XG5leHBvcnRzLmJyb3dzZXJEb3dubG9hZHNSb3V0ZXIgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChCcm93c2VyRG93bmxvYWRzLlVSTF9TQ0hFTUUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJvd3NlckRvd25sb2Fkcyh1cmwuc2xpY2UoQnJvd3NlckRvd25sb2Fkcy5VUkxfU0NIRU1FLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xucm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlclNhdmVSb3V0ZXIoZXhwb3J0cy5icm93c2VyRG93bmxvYWRzUm91dGVyKTtcbmZ1bmN0aW9uIGJyb3dzZXJEb3dubG9hZHMoZmlsZU5hbWVQcmVmaXgpIHtcbiAgICBpZiAoZmlsZU5hbWVQcmVmaXggPT09IHZvaWQgMCkgeyBmaWxlTmFtZVByZWZpeCA9ICdtb2RlbCc7IH1cbiAgICByZXR1cm4gbmV3IEJyb3dzZXJEb3dubG9hZHMoZmlsZU5hbWVQcmVmaXgpO1xufVxuZXhwb3J0cy5icm93c2VyRG93bmxvYWRzID0gYnJvd3NlckRvd25sb2FkcztcbmZ1bmN0aW9uIGJyb3dzZXJGaWxlcyhmaWxlcykge1xuICAgIHJldHVybiBuZXcgQnJvd3NlckZpbGVzKGZpbGVzKTtcbn1cbmV4cG9ydHMuYnJvd3NlckZpbGVzID0gYnJvd3NlckZpbGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl9maWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgaW9fdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2lvX3V0aWxzXCIpO1xudmFyIHJvdXRlcl9yZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vcm91dGVyX3JlZ2lzdHJ5XCIpO1xudmFyIHdlaWdodHNfbG9hZGVyXzEgPSByZXF1aXJlKFwiLi93ZWlnaHRzX2xvYWRlclwiKTtcbnZhciBCcm93c2VySFRUUFJlcXVlc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJIVFRQUmVxdWVzdChwYXRoLCByZXF1ZXN0SW5pdCkge1xuICAgICAgICB0aGlzLkRFRkFVTFRfTUVUSE9EID0gJ1BPU1QnO1xuICAgICAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jyb3dzZXJIVFRQUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkIG91dHNpZGUgdGhlIHdlYiBicm93c2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxfMS5hc3NlcnQocGF0aCAhPSBudWxsICYmIHBhdGgubGVuZ3RoID4gMCwgJ1VSTCBwYXRoIGZvciBicm93c2VySFRUUFJlcXVlc3QgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yICcgK1xuICAgICAgICAgICAgJ2VtcHR5LicpO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICBpZiAocmVxdWVzdEluaXQgIT0gbnVsbCAmJiByZXF1ZXN0SW5pdC5ib2R5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWVzdEluaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBubyBwcmUtZXhpc3RpbmcgYm9keSwgYnV0IGhhcyBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0SW5pdCA9IHJlcXVlc3RJbml0IHx8IHt9O1xuICAgIH1cbiAgICBCcm93c2VySFRUUFJlcXVlc3QucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAobW9kZWxBcnRpZmFjdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluaXQsIHdlaWdodHNNYW5pZmVzdCwgbW9kZWxUb3BvbG9neUFuZFdlaWdodE1hbmlmZXN0LCByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXJIVFRQUmVxdWVzdC5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogdGhpcy5ERUZBVUxUX01FVEhPRCB9LCB0aGlzLnJlcXVlc3RJbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQuYm9keSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c01hbmlmZXN0ID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsnLi9tb2RlbC53ZWlnaHRzLmJpbiddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzOiBtb2RlbEFydGlmYWN0cy53ZWlnaHRTcGVjcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVG9wb2xvZ3lBbmRXZWlnaHRNYW5pZmVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5OiBtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNNYW5pZmVzdDogd2VpZ2h0c01hbmlmZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdC5ib2R5LmFwcGVuZCgnbW9kZWwuanNvbicsIG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShtb2RlbFRvcG9sb2d5QW5kV2VpZ2h0TWFuaWZlc3QpXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSksICdtb2RlbC5qc29uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxBcnRpZmFjdHMud2VpZ2h0RGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdC5ib2R5LmFwcGVuZCgnbW9kZWwud2VpZ2h0cy5iaW4nLCBuZXcgQmxvYihbbW9kZWxBcnRpZmFjdHMud2VpZ2h0RGF0YV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfSksICdtb2RlbC53ZWlnaHRzLmJpbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBmZXRjaCh0aGlzLnBhdGgsIGluaXQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsQXJ0aWZhY3RzSW5mbzogaW9fdXRpbHNfMS5nZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OKG1vZGVsQXJ0aWZhY3RzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlczogW3Jlc3BvbnNlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3Quc2F2ZSgpIGZhaWxlZCBkdWUgdG8gSFRUUCByZXNwb25zZSBzdGF0dXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2Uuc3RhdHVzICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnJvd3NlckhUVFBSZXF1ZXN0LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWxDb25maWdSZXF1ZXN0LCBtb2RlbENvbmZpZywgbW9kZWxUb3BvbG9neSwgd2VpZ2h0c01hbmlmZXN0LCB3ZWlnaHRTcGVjcywgd2VpZ2h0RGF0YSwgd2VpZ2h0c01hbmlmZXN0XzEsIF9pLCB3ZWlnaHRzTWFuaWZlc3RfMiwgZW50cnksIHBhdGhQcmVmaXhfMSwgZmV0Y2hVUkxzXzEsIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIGZldGNoKHRoaXMucGF0aCwgdGhpcy5yZXF1ZXN0SW5pdCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbENvbmZpZ1JlcXVlc3QgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsQ29uZmlnUmVxdWVzdC5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbENvbmZpZyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVG9wb2xvZ3kgPSBtb2RlbENvbmZpZ1snbW9kZWxUb3BvbG9neSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c01hbmlmZXN0ID0gbW9kZWxDb25maWdbJ3dlaWdodHNNYW5pZmVzdCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsVG9wb2xvZ3kgPT0gbnVsbCAmJiB3ZWlnaHRzTWFuaWZlc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBKU09OIGZyb20gSFRUUCBwYXRoIFwiICsgdGhpcy5wYXRoICsgXCIgY29udGFpbnMgbmVpdGhlciBtb2RlbCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wb2xvZ3kgb3IgbWFuaWZlc3QgZm9yIHdlaWdodHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEod2VpZ2h0c01hbmlmZXN0ICE9IG51bGwpKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c01hbmlmZXN0XzEgPSBtb2RlbENvbmZpZ1snd2VpZ2h0c01hbmlmZXN0J107XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRTcGVjcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIHdlaWdodHNNYW5pZmVzdF8yID0gd2VpZ2h0c01hbmlmZXN0XzE7IF9pIDwgd2VpZ2h0c01hbmlmZXN0XzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSB3ZWlnaHRzTWFuaWZlc3RfMltfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0U3BlY3MucHVzaC5hcHBseSh3ZWlnaHRTcGVjcywgZW50cnkud2VpZ2h0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoUHJlZml4XzEgPSB0aGlzLnBhdGguc3Vic3RyaW5nKDAsIHRoaXMucGF0aC5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGF0aFByZWZpeF8xLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoUHJlZml4XzEgPSBwYXRoUHJlZml4XzEgKyAnLyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFVSTHNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c01hbmlmZXN0XzEuZm9yRWFjaChmdW5jdGlvbiAod2VpZ2h0c0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c0dyb3VwLnBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hVUkxzXzEucHVzaChwYXRoUHJlZml4XzEgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBpb191dGlsc18xLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB3ZWlnaHRzX2xvYWRlcl8xLmxvYWRXZWlnaHRzQXNBcnJheUJ1ZmZlcihmZXRjaFVSTHNfMSwgdGhpcy5yZXF1ZXN0SW5pdCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHREYXRhID0gX2EuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyLCB7IG1vZGVsVG9wb2xvZ3k6IG1vZGVsVG9wb2xvZ3ksIHdlaWdodFNwZWNzOiB3ZWlnaHRTcGVjcywgd2VpZ2h0RGF0YTogd2VpZ2h0RGF0YSB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VySFRUUFJlcXVlc3QuVVJMX1NDSEVNRVMgPSBbJ2h0dHA6Ly8nLCAnaHR0cHM6Ly8nXTtcbiAgICByZXR1cm4gQnJvd3NlckhUVFBSZXF1ZXN0O1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlckhUVFBSZXF1ZXN0ID0gQnJvd3NlckhUVFBSZXF1ZXN0O1xuZXhwb3J0cy5odHRwUmVxdWVzdFJvdXRlciA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IEJyb3dzZXJIVFRQUmVxdWVzdC5VUkxfU0NIRU1FUzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoc2NoZW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VySFRUUFJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xucm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlclNhdmVSb3V0ZXIoZXhwb3J0cy5odHRwUmVxdWVzdFJvdXRlcik7XG5yb3V0ZXJfcmVnaXN0cnlfMS5JT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyTG9hZFJvdXRlcihleHBvcnRzLmh0dHBSZXF1ZXN0Um91dGVyKTtcbmZ1bmN0aW9uIGJyb3dzZXJIVFRQUmVxdWVzdChwYXRoLCByZXF1ZXN0SW5pdCkge1xuICAgIHJldHVybiBuZXcgQnJvd3NlckhUVFBSZXF1ZXN0KHBhdGgsIHJlcXVlc3RJbml0KTtcbn1cbmV4cG9ydHMuYnJvd3NlckhUVFBSZXF1ZXN0ID0gYnJvd3NlckhUVFBSZXF1ZXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl9odHRwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBpb191dGlsc18xID0gcmVxdWlyZShcIi4vaW9fdXRpbHNcIik7XG52YXIgbW9kZWxfbWFuYWdlbWVudF8xID0gcmVxdWlyZShcIi4vbW9kZWxfbWFuYWdlbWVudFwiKTtcbnZhciByb3V0ZXJfcmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3JvdXRlcl9yZWdpc3RyeVwiKTtcbnZhciBEQVRBQkFTRV9OQU1FID0gJ3RlbnNvcmZsb3dqcyc7XG52YXIgREFUQUJBU0VfVkVSU0lPTiA9IDE7XG52YXIgTU9ERUxfU1RPUkVfTkFNRSA9ICdtb2RlbHNfc3RvcmUnO1xudmFyIElORk9fU1RPUkVfTkFNRSA9ICdtb2RlbF9pbmZvX3N0b3JlJztcbmZ1bmN0aW9uIGRlbGV0ZURhdGFiYXNlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkYkZhY3Rvcnk7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGlkYkZhY3RvcnkgPSBnZXRJbmRleGVkREJGYWN0b3J5KCk7XG4gICAgICAgICAgICByZXR1cm4gWzIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZVJlcXVlc3QgPSBpZGJGYWN0b3J5LmRlbGV0ZURhdGFiYXNlKERBVEFCQVNFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiByZWplY3QoZXJyb3IpOyB9O1xuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlbGV0ZURhdGFiYXNlID0gZGVsZXRlRGF0YWJhc2U7XG5mdW5jdGlvbiBnZXRJbmRleGVkREJGYWN0b3J5KCkge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdJU19CUk9XU0VSJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gb2J0YWluIEluZGV4ZWREQiBmYWN0b3J5IGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQnICtcbiAgICAgICAgICAgICdpcyBub3QgYSB3ZWIgYnJvd3Nlci4nKTtcbiAgICB9XG4gICAgdmFyIHRoZVdpbmRvdyA9IHdpbmRvdztcbiAgICB2YXIgZmFjdG9yeSA9IHRoZVdpbmRvdy5pbmRleGVkREIgfHwgdGhlV2luZG93Lm1vekluZGV4ZWREQiB8fFxuICAgICAgICB0aGVXaW5kb3cud2Via2l0SW5kZXhlZERCIHx8IHRoZVdpbmRvdy5tc0luZGV4ZWREQiB8fFxuICAgICAgICB0aGVXaW5kb3cuc2hpbUluZGV4ZWREQjtcbiAgICBpZiAoZmFjdG9yeSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBJbmRleGVkREIuJyk7XG4gICAgfVxuICAgIHJldHVybiBmYWN0b3J5O1xufVxuZnVuY3Rpb24gc2V0VXBEYXRhYmFzZShvcGVuUmVxdWVzdCkge1xuICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShNT0RFTF9TVE9SRV9OQU1FLCB7IGtleVBhdGg6ICdtb2RlbFBhdGgnIH0pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKElORk9fU1RPUkVfTkFNRSwgeyBrZXlQYXRoOiAnbW9kZWxQYXRoJyB9KTtcbn1cbnZhciBCcm93c2VySW5kZXhlZERCID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VySW5kZXhlZERCKG1vZGVsUGF0aCkge1xuICAgICAgICB0aGlzLmluZGV4ZWREQiA9IGdldEluZGV4ZWREQkZhY3RvcnkoKTtcbiAgICAgICAgaWYgKG1vZGVsUGF0aCA9PSBudWxsIHx8ICFtb2RlbFBhdGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIEluZGV4ZWREQiwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsUGF0aCA9IG1vZGVsUGF0aDtcbiAgICB9XG4gICAgQnJvd3NlckluZGV4ZWREQi5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChtb2RlbEFydGlmYWN0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsQXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luIGJpbmFyeSBmb3JtYXRzIHlldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmRhdGFiYXNlQWN0aW9uKHRoaXMubW9kZWxQYXRoLCBtb2RlbEFydGlmYWN0cyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnJvd3NlckluZGV4ZWREQi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnJvd3NlckluZGV4ZWREQi5wcm90b3R5cGUuZGF0YWJhc2VBY3Rpb24gPSBmdW5jdGlvbiAobW9kZWxQYXRoLCBtb2RlbEFydGlmYWN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gX3RoaXMuaW5kZXhlZERCLm9wZW4oREFUQUJBU0VfTkFNRSwgREFUQUJBU0VfVkVSU0lPTik7XG4gICAgICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRVcERhdGFiYXNlKG9wZW5SZXF1ZXN0KTsgfTtcbiAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsQXJ0aWZhY3RzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsVHggPSBkYi50cmFuc2FjdGlvbihNT0RFTF9TVE9SRV9OQU1FLCAncmVhZG9ubHknKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsU3RvcmUgPSBtb2RlbFR4Lm9iamVjdFN0b3JlKE1PREVMX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdF8xID0gbW9kZWxTdG9yZS5nZXQoX3RoaXMubW9kZWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UmVxdWVzdF8xLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRSZXF1ZXN0XzEucmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgd2l0aCBwYXRoICdcIiArIF90aGlzLm1vZGVsUGF0aCArIFwiJyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW4gSW5kZXhlZERCLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGdldFJlcXVlc3RfMS5yZXN1bHQubW9kZWxBcnRpZmFjdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBnZXRSZXF1ZXN0XzEub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZ2V0UmVxdWVzdF8xLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUeC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIuY2xvc2UoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbEFydGlmYWN0c0luZm9fMSA9IGlvX3V0aWxzXzEuZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTihtb2RlbEFydGlmYWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZvVHhfMSA9IGRiLnRyYW5zYWN0aW9uKElORk9fU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mb1N0b3JlXzEgPSBpbmZvVHhfMS5vYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHV0SW5mb1JlcXVlc3RfMSA9IGluZm9TdG9yZV8xLnB1dCh7IG1vZGVsUGF0aDogX3RoaXMubW9kZWxQYXRoLCBtb2RlbEFydGlmYWN0c0luZm86IG1vZGVsQXJ0aWZhY3RzSW5mb18xIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxUeF8xO1xuICAgICAgICAgICAgICAgICAgICBwdXRJbmZvUmVxdWVzdF8xLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVHhfMSA9IGRiLnRyYW5zYWN0aW9uKE1PREVMX1NUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbFN0b3JlID0gbW9kZWxUeF8xLm9iamVjdFN0b3JlKE1PREVMX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1dE1vZGVsUmVxdWVzdCA9IG1vZGVsU3RvcmUucHV0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFBhdGg6IF90aGlzLm1vZGVsUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbEFydGlmYWN0czogbW9kZWxBcnRpZmFjdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxBcnRpZmFjdHNJbmZvOiBtb2RlbEFydGlmYWN0c0luZm9fMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRNb2RlbFJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh7IG1vZGVsQXJ0aWZhY3RzSW5mbzogbW9kZWxBcnRpZmFjdHNJbmZvXzEgfSk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRNb2RlbFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9TdG9yZV8xID0gaW5mb1R4XzEub2JqZWN0U3RvcmUoSU5GT19TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlSW5mb1JlcXVlc3QgPSBpbmZvU3RvcmVfMS5kZWxldGUoX3RoaXMubW9kZWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJbmZvUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QocHV0TW9kZWxSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUluZm9SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChwdXRNb2RlbFJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwdXRJbmZvUmVxdWVzdF8xLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHB1dEluZm9SZXF1ZXN0XzEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbmZvVHhfMS5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsVHhfMSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVHhfMS5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGIuY2xvc2UoKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gcmVqZWN0KG9wZW5SZXF1ZXN0LmVycm9yKTsgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUgPSAnaW5kZXhlZGRiOi8vJztcbiAgICByZXR1cm4gQnJvd3NlckluZGV4ZWREQjtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJJbmRleGVkREIgPSBCcm93c2VySW5kZXhlZERCO1xuZXhwb3J0cy5pbmRleGVkREJSb3V0ZXIgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJvd3NlckluZGV4ZWREQih1cmwuc2xpY2UoQnJvd3NlckluZGV4ZWREQi5VUkxfU0NIRU1FLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xucm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlclNhdmVSb3V0ZXIoZXhwb3J0cy5pbmRleGVkREJSb3V0ZXIpO1xucm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXIoZXhwb3J0cy5pbmRleGVkREJSb3V0ZXIpO1xuZnVuY3Rpb24gYnJvd3NlckluZGV4ZWREQihtb2RlbFBhdGgpIHtcbiAgICByZXR1cm4gbmV3IEJyb3dzZXJJbmRleGVkREIobW9kZWxQYXRoKTtcbn1cbmV4cG9ydHMuYnJvd3NlckluZGV4ZWREQiA9IGJyb3dzZXJJbmRleGVkREI7XG5mdW5jdGlvbiBtYXliZVN0cmlwU2NoZW1lKGtleSkge1xuICAgIHJldHVybiBrZXkuc3RhcnRzV2l0aChCcm93c2VySW5kZXhlZERCLlVSTF9TQ0hFTUUpID9cbiAgICAgICAga2V5LnNsaWNlKEJyb3dzZXJJbmRleGVkREIuVVJMX1NDSEVNRS5sZW5ndGgpIDpcbiAgICAgICAga2V5O1xufVxudmFyIEJyb3dzZXJJbmRleGVkREJNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VySW5kZXhlZERCTWFuYWdlcigpIHtcbiAgICAgICAgdGhpcy5pbmRleGVkREIgPSBnZXRJbmRleGVkREJGYWN0b3J5KCk7XG4gICAgfVxuICAgIEJyb3dzZXJJbmRleGVkREJNYW5hZ2VyLnByb3RvdHlwZS5saXN0TW9kZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gX3RoaXMuaW5kZXhlZERCLm9wZW4oREFUQUJBU0VfTkFNRSwgREFUQUJBU0VfVkVSU0lPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRVcERhdGFiYXNlKG9wZW5SZXF1ZXN0KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gZGIudHJhbnNhY3Rpb24oSU5GT19TVE9SRV9OQU1FLCAncmVhZG9ubHknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0eC5vYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRBbGxJbmZvUmVxdWVzdCA9IHN0b3JlLmdldEFsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbEluZm9SZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZ2V0QWxsSW5mb1JlcXVlc3QucmVzdWx0OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRbaXRlbS5tb2RlbFBhdGhdID0gaXRlbS5tb2RlbEFydGlmYWN0c0luZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWxsSW5mb1JlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGdldEFsbEluZm9SZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkYi5jbG9zZSgpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIHJlamVjdChvcGVuUmVxdWVzdC5lcnJvcik7IH07XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJyb3dzZXJJbmRleGVkREJNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVNb2RlbCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IG1heWJlU3RyaXBTY2hlbWUocGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBfdGhpcy5pbmRleGVkREIub3BlbihEQVRBQkFTRV9OQU1FLCBEQVRBQkFTRV9WRVJTSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFVwRGF0YWJhc2Uob3BlblJlcXVlc3QpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mb1R4ID0gZGIudHJhbnNhY3Rpb24oSU5GT19TVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm9TdG9yZSA9IGluZm9UeC5vYmplY3RTdG9yZShJTkZPX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRJbmZvUmVxdWVzdCA9IGluZm9TdG9yZS5nZXQocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsVHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5mb1JlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0SW5mb1JlcXVlc3QucmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIgKyBwYXRoICsgXCInIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImluIEluZGV4ZWREQi5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZUluZm9SZXF1ZXN0ID0gaW5mb1N0b3JlLmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVNb2RlbERhdGFfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFR4ID0gZGIudHJhbnNhY3Rpb24oTU9ERUxfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbFN0b3JlID0gbW9kZWxUeC5vYmplY3RTdG9yZShNT0RFTF9TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlTW9kZWxSZXF1ZXN0ID0gbW9kZWxTdG9yZS5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTW9kZWxSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZ2V0SW5mb1JlcXVlc3QucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVNb2RlbFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGdldEluZm9SZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUluZm9SZXF1ZXN0Lm9uc3VjY2VzcyA9IGRlbGV0ZU1vZGVsRGF0YV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlSW5mb1JlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZU1vZGVsRGF0YV8xKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGdldEluZm9SZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEluZm9SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChnZXRJbmZvUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvVHgub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsVHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVHgub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRiLmNsb3NlKCk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIHJlamVjdChvcGVuUmVxdWVzdC5lcnJvcik7IH07XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCcm93c2VySW5kZXhlZERCTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJJbmRleGVkREJNYW5hZ2VyID0gQnJvd3NlckluZGV4ZWREQk1hbmFnZXI7XG5pZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdJU19CUk9XU0VSJykpIHtcbiAgICB0cnkge1xuICAgICAgICBtb2RlbF9tYW5hZ2VtZW50XzEuTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5yZWdpc3Rlck1hbmFnZXIoQnJvd3NlckluZGV4ZWREQi5VUkxfU0NIRU1FLCBuZXcgQnJvd3NlckluZGV4ZWREQk1hbmFnZXIoKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleGVkX2RiLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucmVxdWlyZShcIi4vaW5kZXhlZF9kYlwiKTtcbnJlcXVpcmUoXCIuL2xvY2FsX3N0b3JhZ2VcIik7XG52YXIgYnJvd3Nlcl9maWxlc18xID0gcmVxdWlyZShcIi4vYnJvd3Nlcl9maWxlc1wiKTtcbmV4cG9ydHMuYnJvd3NlckZpbGVzID0gYnJvd3Nlcl9maWxlc18xLmJyb3dzZXJGaWxlcztcbnZhciBicm93c2VyX2h0dHBfMSA9IHJlcXVpcmUoXCIuL2Jyb3dzZXJfaHR0cFwiKTtcbmV4cG9ydHMuYnJvd3NlckhUVFBSZXF1ZXN0ID0gYnJvd3Nlcl9odHRwXzEuYnJvd3NlckhUVFBSZXF1ZXN0O1xudmFyIGlvX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9pb191dGlsc1wiKTtcbmV4cG9ydHMuZGVjb2RlV2VpZ2h0cyA9IGlvX3V0aWxzXzEuZGVjb2RlV2VpZ2h0cztcbmV4cG9ydHMuZW5jb2RlV2VpZ2h0cyA9IGlvX3V0aWxzXzEuZW5jb2RlV2VpZ2h0cztcbmV4cG9ydHMuZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTiA9IGlvX3V0aWxzXzEuZ2V0TW9kZWxBcnRpZmFjdHNJbmZvRm9ySlNPTjtcbnZhciBtb2RlbF9tYW5hZ2VtZW50XzEgPSByZXF1aXJlKFwiLi9tb2RlbF9tYW5hZ2VtZW50XCIpO1xudmFyIHJvdXRlcl9yZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vcm91dGVyX3JlZ2lzdHJ5XCIpO1xudmFyIHdlaWdodHNfbG9hZGVyXzEgPSByZXF1aXJlKFwiLi93ZWlnaHRzX2xvYWRlclwiKTtcbmV4cG9ydHMubG9hZFdlaWdodHMgPSB3ZWlnaHRzX2xvYWRlcl8xLmxvYWRXZWlnaHRzO1xudmFyIHJlZ2lzdGVyU2F2ZVJvdXRlciA9IHJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyO1xuZXhwb3J0cy5yZWdpc3RlclNhdmVSb3V0ZXIgPSByZWdpc3RlclNhdmVSb3V0ZXI7XG52YXIgcmVnaXN0ZXJMb2FkUm91dGVyID0gcm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5yZWdpc3RlckxvYWRSb3V0ZXI7XG5leHBvcnRzLnJlZ2lzdGVyTG9hZFJvdXRlciA9IHJlZ2lzdGVyTG9hZFJvdXRlcjtcbnZhciBnZXRTYXZlSGFuZGxlcnMgPSByb3V0ZXJfcmVnaXN0cnlfMS5JT1JvdXRlclJlZ2lzdHJ5LmdldFNhdmVIYW5kbGVycztcbmV4cG9ydHMuZ2V0U2F2ZUhhbmRsZXJzID0gZ2V0U2F2ZUhhbmRsZXJzO1xudmFyIGdldExvYWRIYW5kbGVycyA9IHJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkuZ2V0TG9hZEhhbmRsZXJzO1xuZXhwb3J0cy5nZXRMb2FkSGFuZGxlcnMgPSBnZXRMb2FkSGFuZGxlcnM7XG52YXIgY29weU1vZGVsID0gbW9kZWxfbWFuYWdlbWVudF8xLk1vZGVsTWFuYWdlbWVudC5jb3B5TW9kZWw7XG5leHBvcnRzLmNvcHlNb2RlbCA9IGNvcHlNb2RlbDtcbnZhciBsaXN0TW9kZWxzID0gbW9kZWxfbWFuYWdlbWVudF8xLk1vZGVsTWFuYWdlbWVudC5saXN0TW9kZWxzO1xuZXhwb3J0cy5saXN0TW9kZWxzID0gbGlzdE1vZGVscztcbnZhciBtb3ZlTW9kZWwgPSBtb2RlbF9tYW5hZ2VtZW50XzEuTW9kZWxNYW5hZ2VtZW50Lm1vdmVNb2RlbDtcbmV4cG9ydHMubW92ZU1vZGVsID0gbW92ZU1vZGVsO1xudmFyIHJlbW92ZU1vZGVsID0gbW9kZWxfbWFuYWdlbWVudF8xLk1vZGVsTWFuYWdlbWVudC5yZW1vdmVNb2RlbDtcbmV4cG9ydHMucmVtb3ZlTW9kZWwgPSByZW1vdmVNb2RlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXJyYXlfb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL2FycmF5X29wc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5mdW5jdGlvbiBlbmNvZGVXZWlnaHRzKHRlbnNvcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzcGVjcywgZGF0YVByb21pc2VzLCBuYW1lXzEsIHQsIHRlbnNvclZhbHVlcztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgc3BlY3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobmFtZV8xIGluIHRlbnNvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB0ZW5zb3JzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5kdHlwZSAhPT0gJ2Zsb2F0MzInICYmIHQuZHR5cGUgIT09ICdpbnQzMicgJiYgdC5kdHlwZSAhPT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIiArIG5hbWVfMSArIFwiJzogXCIgKyB0LmR0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNzLnB1c2goeyBuYW1lOiBuYW1lXzEsIHNoYXBlOiB0LnNoYXBlLCBkdHlwZTogdC5kdHlwZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9taXNlcy5wdXNoKHQuZGF0YSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIFByb21pc2UuYWxsKGRhdGFQcm9taXNlcyldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yVmFsdWVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgZGF0YTogY29uY2F0ZW5hdGVUeXBlZEFycmF5cyh0ZW5zb3JWYWx1ZXMpLCBzcGVjczogc3BlY3MgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5lbmNvZGVXZWlnaHRzID0gZW5jb2RlV2VpZ2h0cztcbmZ1bmN0aW9uIGRlY29kZVdlaWdodHMoYnVmZmVyLCBzcGVjcykge1xuICAgIHZhciBvdXQgPSB7fTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNwZWNzXzEgPSBzcGVjczsgX2kgPCBzcGVjc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc3BlYyA9IHNwZWNzXzFbX2ldO1xuICAgICAgICB2YXIgbmFtZV8yID0gc3BlYy5uYW1lO1xuICAgICAgICB2YXIgZHR5cGUgPSBzcGVjLmR0eXBlO1xuICAgICAgICB2YXIgc2hhcGUgPSBzcGVjLnNoYXBlO1xuICAgICAgICBpZiAoc3BlYy5xdWFudGl6YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVjb2RlV2VpZ2h0cyBkb2VzIG5vdCBzdXBwb3J0IHF1YW50aXphdGlvbiB5ZXQsIGJ1dCBlbmNvdW50ZXJlZCBcIiArXG4gICAgICAgICAgICAgICAgKFwid2VpZ2h0ICdcIiArIG5hbWVfMiArIFwiIHdpdGggcXVhbnRpemF0aW9uLidcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplID0gdXRpbF8xLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5X29wc18xLkFycmF5T3BzLnRlbnNvcihuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBzaXplKSwgc2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICBhcnJheV9vcHNfMS5BcnJheU9wcy50ZW5zb3IobmV3IEludDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIHNpemUpLCBzaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICAgIGFycmF5X29wc18xLkFycmF5T3BzLnRlbnNvcihuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgc2l6ZSksIHNoYXBlLCAnYm9vbCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIiArIG5hbWVfMiArIFwiJzogXCIgKyBkdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0W25hbWVfMl0gPSB2YWx1ZTtcbiAgICAgICAgb2Zmc2V0ICs9IHNpemUgKiB0eXBlc18xLkRUWVBFX1ZBTFVFX1NJWkVfTUFQW2R0eXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMuZGVjb2RlV2VpZ2h0cyA9IGRlY29kZVdlaWdodHM7XG5mdW5jdGlvbiBjb25jYXRlbmF0ZVR5cGVkQXJyYXlzKHhzKSB7XG4gICAgaWYgKHhzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdmFsdWU6IFwiICsgSlNPTi5zdHJpbmdpZnkoeHMpKTtcbiAgICB9XG4gICAgdmFyIHRvdGFsQnl0ZUxlbmd0aCA9IDA7XG4gICAgeHMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB4IGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICAgICAgdG90YWxCeXRlTGVuZ3RoICs9IHgubGVuZ3RoICogNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdG90YWxCeXRlTGVuZ3RoICs9IHgubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgVHlwZWRBcnJheSBzdWJ0eXBlOiBcIiArIHguY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgeSA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZUxlbmd0aCk7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgeHMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICB5LnNldChuZXcgVWludDhBcnJheSh4LmJ1ZmZlciksIG9mZnNldCk7XG4gICAgICAgIGlmICh4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHggaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0geC5sZW5ndGggKiA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHgubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHkuYnVmZmVyO1xufVxuZXhwb3J0cy5jb25jYXRlbmF0ZVR5cGVkQXJyYXlzID0gY29uY2F0ZW5hdGVUeXBlZEFycmF5cztcbmZ1bmN0aW9uIHN0cmluZ0J5dGVMZW5ndGgoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtzdHJdKS5zaXplO1xufVxuZXhwb3J0cy5zdHJpbmdCeXRlTGVuZ3RoID0gc3RyaW5nQnl0ZUxlbmd0aDtcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShidWZmZXIpKSk7XG59XG5leHBvcnRzLmFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcgPSBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nO1xuZnVuY3Rpb24gYmFzZTY0U3RyaW5nVG9BcnJheUJ1ZmZlcihzdHIpIHtcbiAgICB2YXIgcyA9IGF0b2Ioc3RyKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBidWZmZXIuc2V0KFtzLmNoYXJDb2RlQXQoaSldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XG59XG5leHBvcnRzLmJhc2U2NFN0cmluZ1RvQXJyYXlCdWZmZXIgPSBiYXNlNjRTdHJpbmdUb0FycmF5QnVmZmVyO1xuZnVuY3Rpb24gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMoYnVmZmVycykge1xuICAgIHZhciB0b3RhbEJ5dGVMZW5ndGggPSAwO1xuICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHRvdGFsQnl0ZUxlbmd0aCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9KTtcbiAgICB2YXIgdGVtcCA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZUxlbmd0aCk7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgdGVtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZW1wLmJ1ZmZlcjtcbn1cbmV4cG9ydHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVycztcbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgICB2YXIgU0VQQVJBVE9SID0gJy8nO1xuICAgIHBhdGggPSBwYXRoLnRyaW0oKTtcbiAgICB3aGlsZSAocGF0aC5lbmRzV2l0aChTRVBBUkFUT1IpKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHZhciBpdGVtcyA9IHBhdGguc3BsaXQoU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG59XG5leHBvcnRzLmJhc2VuYW1lID0gYmFzZW5hbWU7XG5mdW5jdGlvbiBnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OKG1vZGVsQXJ0aWZhY3RzKSB7XG4gICAgaWYgKG1vZGVsQXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEpTT04gbW9kZWwgdG9wb2xvZ3ksIHJlY2VpdmVkIEFycmF5QnVmZmVyLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlU2F2ZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgIG1vZGVsVG9wb2xvZ3lUeXBlOiAnSlNPTicsXG4gICAgICAgIG1vZGVsVG9wb2xvZ3lCeXRlczogbW9kZWxBcnRpZmFjdHMubW9kZWxUb3BvbG9neSA9PSBudWxsID9cbiAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgc3RyaW5nQnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5KSksXG4gICAgICAgIHdlaWdodFNwZWNzQnl0ZXM6IG1vZGVsQXJ0aWZhY3RzLndlaWdodFNwZWNzID09IG51bGwgP1xuICAgICAgICAgICAgMCA6XG4gICAgICAgICAgICBzdHJpbmdCeXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KG1vZGVsQXJ0aWZhY3RzLndlaWdodFNwZWNzKSksXG4gICAgICAgIHdlaWdodERhdGFCeXRlczogbW9kZWxBcnRpZmFjdHMud2VpZ2h0RGF0YSA9PSBudWxsID9cbiAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgbW9kZWxBcnRpZmFjdHMud2VpZ2h0RGF0YS5ieXRlTGVuZ3RoLFxuICAgIH07XG59XG5leHBvcnRzLmdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04gPSBnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW9fdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGlvX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9pb191dGlsc1wiKTtcbnZhciBtb2RlbF9tYW5hZ2VtZW50XzEgPSByZXF1aXJlKFwiLi9tb2RlbF9tYW5hZ2VtZW50XCIpO1xudmFyIHJvdXRlcl9yZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vcm91dGVyX3JlZ2lzdHJ5XCIpO1xudmFyIFBBVEhfU0VQQVJBVE9SID0gJy8nO1xudmFyIFBBVEhfUFJFRklYID0gJ3RlbnNvcmZsb3dqc19tb2RlbHMnO1xudmFyIElORk9fU1VGRklYID0gJ2luZm8nO1xudmFyIE1PREVMX1RPUE9MT0dZX1NVRkZJWCA9ICdtb2RlbF90b3BvbG9neSc7XG52YXIgV0VJR0hUX1NQRUNTX1NVRkZJWCA9ICd3ZWlnaHRfc3BlY3MnO1xudmFyIFdFSUdIVF9EQVRBX1NVRkZJWCA9ICd3ZWlnaHRfZGF0YSc7XG5mdW5jdGlvbiBwdXJnZUxvY2FsU3RvcmFnZUFydGlmYWN0cygpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpIHx8IHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1cmdlTG9jYWxTdG9yYWdlTW9kZWxzKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSBsb2NhbCBzdG9yYWdlIGlzICcgK1xuICAgICAgICAgICAgJ3VuYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LicpO1xuICAgIH1cbiAgICB2YXIgTFMgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgIHZhciBwdXJnZWRNb2RlbFBhdGhzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBMUy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gTFMua2V5KGkpO1xuICAgICAgICB2YXIgcHJlZml4ID0gUEFUSF9QUkVGSVggKyBQQVRIX1NFUEFSQVRPUjtcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKHByZWZpeCkgJiYga2V5Lmxlbmd0aCA+IHByZWZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgIExTLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgIHZhciBtb2RlbE5hbWUgPSBnZXRNb2RlbFBhdGhGcm9tS2V5KGtleSk7XG4gICAgICAgICAgICBpZiAocHVyZ2VkTW9kZWxQYXRocy5pbmRleE9mKG1vZGVsTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHVyZ2VkTW9kZWxQYXRocy5wdXNoKG1vZGVsTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHB1cmdlZE1vZGVsUGF0aHM7XG59XG5leHBvcnRzLnB1cmdlTG9jYWxTdG9yYWdlQXJ0aWZhY3RzID0gcHVyZ2VMb2NhbFN0b3JhZ2VBcnRpZmFjdHM7XG5mdW5jdGlvbiBnZXRNb2RlbEtleXMocGF0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluZm86IFtQQVRIX1BSRUZJWCwgcGF0aCwgSU5GT19TVUZGSVhdLmpvaW4oUEFUSF9TRVBBUkFUT1IpLFxuICAgICAgICB0b3BvbG9neTogW1BBVEhfUFJFRklYLCBwYXRoLCBNT0RFTF9UT1BPTE9HWV9TVUZGSVhdLmpvaW4oUEFUSF9TRVBBUkFUT1IpLFxuICAgICAgICB3ZWlnaHRTcGVjczogW1BBVEhfUFJFRklYLCBwYXRoLCBXRUlHSFRfU1BFQ1NfU1VGRklYXS5qb2luKFBBVEhfU0VQQVJBVE9SKSxcbiAgICAgICAgd2VpZ2h0RGF0YTogW1BBVEhfUFJFRklYLCBwYXRoLCBXRUlHSFRfREFUQV9TVUZGSVhdLmpvaW4oUEFUSF9TRVBBUkFUT1IpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE1vZGVsUGF0aEZyb21LZXkoa2V5KSB7XG4gICAgdmFyIGl0ZW1zID0ga2V5LnNwbGl0KFBBVEhfU0VQQVJBVE9SKTtcbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSBmb3JtYXQ6IFwiICsga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zLnNsaWNlKDEsIGl0ZW1zLmxlbmd0aCAtIDEpLmpvaW4oUEFUSF9TRVBBUkFUT1IpO1xufVxuZnVuY3Rpb24gbWF5YmVTdHJpcFNjaGVtZShrZXkpIHtcbiAgICByZXR1cm4ga2V5LnN0YXJ0c1dpdGgoQnJvd3NlckxvY2FsU3RvcmFnZS5VUkxfU0NIRU1FKSA/XG4gICAgICAgIGtleS5zbGljZShCcm93c2VyTG9jYWxTdG9yYWdlLlVSTF9TQ0hFTUUubGVuZ3RoKSA6XG4gICAgICAgIGtleTtcbn1cbnZhciBCcm93c2VyTG9jYWxTdG9yYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyTG9jYWxTdG9yYWdlKG1vZGVsUGF0aCkge1xuICAgICAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpIHx8IHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGxvY2FsIHN0b3JhZ2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5MUyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIGlmIChtb2RlbFBhdGggPT0gbnVsbCB8fCAhbW9kZWxQYXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciBsb2NhbCBzdG9yYWdlLCBtb2RlbFBhdGggbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWxQYXRoID0gbW9kZWxQYXRoO1xuICAgICAgICB0aGlzLmtleXMgPSBnZXRNb2RlbEtleXModGhpcy5tb2RlbFBhdGgpO1xuICAgIH1cbiAgICBCcm93c2VyTG9jYWxTdG9yYWdlLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKG1vZGVsQXJ0aWZhY3RzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b3BvbG9neSwgd2VpZ2h0U3BlY3MsIG1vZGVsQXJ0aWZhY3RzSW5mbywga2V5O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbEFydGlmYWN0cy5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BvbG9neSA9IEpTT04uc3RyaW5naWZ5KG1vZGVsQXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3kpO1xuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRTcGVjcyA9IEpTT04uc3RyaW5naWZ5KG1vZGVsQXJ0aWZhY3RzLndlaWdodFNwZWNzKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxBcnRpZmFjdHNJbmZvID0gaW9fdXRpbHNfMS5nZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OKG1vZGVsQXJ0aWZhY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMuaW5mbywgSlNPTi5zdHJpbmdpZnkobW9kZWxBcnRpZmFjdHNJbmZvKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5LCB0b3BvbG9neSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzLCB3ZWlnaHRTcGVjcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEsIGlvX3V0aWxzXzEuYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhtb2RlbEFydGlmYWN0cy53ZWlnaHREYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgbW9kZWxBcnRpZmFjdHNJbmZvOiBtb2RlbEFydGlmYWN0c0luZm8gfV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdGhpcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5c1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzYXZlIG1vZGVsICdcIiArIHRoaXMubW9kZWxQYXRoICsgXCInIHRvIGxvY2FsIHN0b3JhZ2U6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNpemUgcXVvdGEgYmVpbmcgZXhjZWVkZWQgaXMgYSBwb3NzaWJsZSBjYXVzZSBvZiB0aGlzIGZhaWx1cmU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJtb2RlbFRvcG9sb2d5Qnl0ZXM9XCIgKyBtb2RlbEFydGlmYWN0c0luZm8ubW9kZWxUb3BvbG9neUJ5dGVzICsgXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwid2VpZ2h0U3BlY3NCeXRlcz1cIiArIG1vZGVsQXJ0aWZhY3RzSW5mby53ZWlnaHRTcGVjc0J5dGVzICsgXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwid2VpZ2h0RGF0YUJ5dGVzPVwiICsgbW9kZWxBcnRpZmFjdHNJbmZvLndlaWdodERhdGFCeXRlcyArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhbFN0b3JhZ2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmZvLCBvdXQsIHRvcG9sb2d5LCB3ZWlnaHRTcGVjcywgd2VpZ2h0RGF0YUJhc2U2NDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpbmZvID0gSlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLmluZm8pKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZXJlIGlzIG5vIG1vZGVsIHdpdGggbmFtZSAnXCIgKyB0aGlzLm1vZGVsUGF0aCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ubW9kZWxUb3BvbG9neVR5cGUgIT09ICdKU09OJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXJMb2NhbFN0b3JhZ2UgZG9lcyBub3Qgc3VwcG9ydCBsb2FkaW5nIG5vbi1KU09OIG1vZGVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RvcG9sb2d5IHlldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICAgICAgICAgICAgdG9wb2xvZ3kgPSBKU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpKTtcbiAgICAgICAgICAgICAgICBpZiAodG9wb2xvZ3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgdG9wb2xvZ3kgb2YgbW9kZWwgJ1wiICsgdGhpcy5tb2RlbFBhdGggKyBcIicgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJpcyBtaXNzaW5nLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0Lm1vZGVsVG9wb2xvZ3kgPSB0b3BvbG9neTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRTcGVjcyA9IEpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcykpO1xuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHRTcGVjcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSB3ZWlnaHQgc3BlY3Mgb2YgbW9kZWwgJ1wiICsgdGhpcy5tb2RlbFBhdGggKyBcIicgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmUgbWlzc2luZy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC53ZWlnaHRTcGVjcyA9IHdlaWdodFNwZWNzO1xuICAgICAgICAgICAgICAgIHdlaWdodERhdGFCYXNlNjQgPSB0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHREYXRhQmFzZTY0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIGJpbmFyeSB3ZWlnaHQgdmFsdWVzIG9mIG1vZGVsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIidcIiArIHRoaXMubW9kZWxQYXRoICsgXCInIGFyZSBtaXNzaW5nLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC53ZWlnaHREYXRhID0gaW9fdXRpbHNfMS5iYXNlNjRTdHJpbmdUb0FycmF5QnVmZmVyKHdlaWdodERhdGFCYXNlNjQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgb3V0XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhbFN0b3JhZ2UuVVJMX1NDSEVNRSA9ICdsb2NhbHN0b3JhZ2U6Ly8nO1xuICAgIHJldHVybiBCcm93c2VyTG9jYWxTdG9yYWdlO1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlckxvY2FsU3RvcmFnZSA9IEJyb3dzZXJMb2NhbFN0b3JhZ2U7XG5leHBvcnRzLmxvY2FsU3RvcmFnZVJvdXRlciA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKEJyb3dzZXJMb2NhbFN0b3JhZ2UuVVJMX1NDSEVNRSkpIHtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyTG9jYWxTdG9yYWdlKHVybC5zbGljZShCcm93c2VyTG9jYWxTdG9yYWdlLlVSTF9TQ0hFTUUubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5yb3V0ZXJfcmVnaXN0cnlfMS5JT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyU2F2ZVJvdXRlcihleHBvcnRzLmxvY2FsU3RvcmFnZVJvdXRlcik7XG5yb3V0ZXJfcmVnaXN0cnlfMS5JT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyTG9hZFJvdXRlcihleHBvcnRzLmxvY2FsU3RvcmFnZVJvdXRlcik7XG5mdW5jdGlvbiBicm93c2VyTG9jYWxTdG9yYWdlKG1vZGVsUGF0aCkge1xuICAgIHJldHVybiBuZXcgQnJvd3NlckxvY2FsU3RvcmFnZShtb2RlbFBhdGgpO1xufVxuZXhwb3J0cy5icm93c2VyTG9jYWxTdG9yYWdlID0gYnJvd3NlckxvY2FsU3RvcmFnZTtcbnZhciBCcm93c2VyTG9jYWxTdG9yYWdlTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXIoKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdJU19CUk9XU0VSJyksICdDdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIHdlYiBicm93c2VyJyk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnLCAnQ3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IGxvY2FsU3RvcmFnZScpO1xuICAgICAgICB0aGlzLkxTID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXIucHJvdG90eXBlLmxpc3RNb2RlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdXQsIHByZWZpeCwgc3VmZml4LCBpLCBrZXksIG1vZGVsUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBvdXQgPSB7fTtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBQQVRIX1BSRUZJWCArIFBBVEhfU0VQQVJBVE9SO1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IFBBVEhfU0VQQVJBVE9SICsgSU5GT19TVUZGSVg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuTFMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5MUy5rZXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChwcmVmaXgpICYmIGtleS5lbmRzV2l0aChzdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFBhdGggPSBnZXRNb2RlbFBhdGhGcm9tS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbbW9kZWxQYXRoXSA9IEpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKGtleSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgb3V0XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhbFN0b3JhZ2VNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVNb2RlbCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXlzLCBpbmZvO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBtYXliZVN0cmlwU2NoZW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIGtleXMgPSBnZXRNb2RlbEtleXMocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuTFMuZ2V0SXRlbShrZXlzLmluZm8pID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgYXQgcGF0aCAnXCIgKyBwYXRoICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmZvID0gSlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0oa2V5cy5pbmZvKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5MUy5yZW1vdmVJdGVtKGtleXMuaW5mbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5MUy5yZW1vdmVJdGVtKGtleXMudG9wb2xvZ3kpO1xuICAgICAgICAgICAgICAgIHRoaXMuTFMucmVtb3ZlSXRlbShrZXlzLndlaWdodFNwZWNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLkxTLnJlbW92ZUl0ZW0oa2V5cy53ZWlnaHREYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGluZm9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEJyb3dzZXJMb2NhbFN0b3JhZ2VNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlckxvY2FsU3RvcmFnZU1hbmFnZXIgPSBCcm93c2VyTG9jYWxTdG9yYWdlTWFuYWdlcjtcbmlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgIHRyeSB7XG4gICAgICAgIG1vZGVsX21hbmFnZW1lbnRfMS5Nb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LnJlZ2lzdGVyTWFuYWdlcihCcm93c2VyTG9jYWxTdG9yYWdlLlVSTF9TQ0hFTUUsIG5ldyBCcm93c2VyTG9jYWxTdG9yYWdlTWFuYWdlcigpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsX3N0b3JhZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgcm91dGVyX3JlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9yb3V0ZXJfcmVnaXN0cnlcIik7XG52YXIgVVJMX1NDSEVNRV9TVUZGSVggPSAnOi8vJztcbnZhciBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5KCkge1xuICAgICAgICB0aGlzLm1hbmFnZXJzID0ge307XG4gICAgfVxuICAgIE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5Lmluc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuaW5zdGFuY2UgPSBuZXcgTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5Lmluc3RhbmNlO1xuICAgIH07XG4gICAgTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5yZWdpc3Rlck1hbmFnZXIgPSBmdW5jdGlvbiAoc2NoZW1lLCBtYW5hZ2VyKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQoc2NoZW1lICE9IG51bGwsICdzY2hlbWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkIG9yIG51bGwuJyk7XG4gICAgICAgIGlmIChzY2hlbWUuZW5kc1dpdGgoVVJMX1NDSEVNRV9TVUZGSVgpKSB7XG4gICAgICAgICAgICBzY2hlbWUgPSBzY2hlbWUuc2xpY2UoMCwgc2NoZW1lLmluZGV4T2YoVVJMX1NDSEVNRV9TVUZGSVgpKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsXzEuYXNzZXJ0KHNjaGVtZS5sZW5ndGggPiAwLCAnc2NoZW1lIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZy4nKTtcbiAgICAgICAgdmFyIHJlZ2lzdHJ5ID0gTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHJlZ2lzdHJ5Lm1hbmFnZXJzW3NjaGVtZV0gPT0gbnVsbCwgXCJBIG1vZGVsIHN0b3JlIG1hbmFnZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBzY2hlbWUgJ1wiICsgc2NoZW1lICsgXCInLlwiKTtcbiAgICAgICAgcmVnaXN0cnkubWFuYWdlcnNbc2NoZW1lXSA9IG1hbmFnZXI7XG4gICAgfTtcbiAgICBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldE1hbmFnZXIgPSBmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgICAgIHZhciBtYW5hZ2VyID0gdGhpcy5nZXRJbnN0YW5jZSgpLm1hbmFnZXJzW3NjaGVtZV07XG4gICAgICAgIGlmIChtYW5hZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIG1hbmFnZXIgZm9yIHNjaGVtZSAnXCIgKyBzY2hlbWUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfTtcbiAgICBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldFNjaGVtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEluc3RhbmNlKCkubWFuYWdlcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnk7XG59KCkpO1xuZXhwb3J0cy5Nb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5ID0gTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeTtcbmZ1bmN0aW9uIHBhcnNlVVJMKHVybCkge1xuICAgIGlmICh1cmwuaW5kZXhPZihVUkxfU0NIRU1FX1NVRkZJWCkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB1cmwgc3RyaW5nIHByb3ZpZGVkIGRvZXMgbm90IGNvbnRhaW4gYSBzY2hlbWUuIFwiICtcbiAgICAgICAgICAgIFwiU3VwcG9ydGVkIHNjaGVtZXMgYXJlOiBcIiArXG4gICAgICAgICAgICAoXCJcIiArIE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0U2NoZW1lcygpLmpvaW4oJywnKSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHVybC5zcGxpdChVUkxfU0NIRU1FX1NVRkZJWClbMF0sXG4gICAgICAgIHBhdGg6IHVybC5zcGxpdChVUkxfU0NIRU1FX1NVRkZJWClbMV0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNsb25lTW9kZWxJbnRlcm5hbChzb3VyY2VVUkwsIGRlc3RVUkwsIGRlbGV0ZVNvdXJjZSkge1xuICAgIGlmIChkZWxldGVTb3VyY2UgPT09IHZvaWQgMCkgeyBkZWxldGVTb3VyY2UgPSBmYWxzZTsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvYWRIYW5kbGVycywgbG9hZEhhbmRsZXIsIHNhdmVIYW5kbGVycywgc2F2ZUhhbmRsZXIsIHNvdXJjZVNjaGVtZSwgc291cmNlUGF0aCwgc2FtZU1lZGl1bSwgbW9kZWxBcnRpZmFjdHMsIHNhdmVSZXN1bHQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoc291cmNlVVJMICE9PSBkZXN0VVJMLCBcIk9sZCBwYXRoIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWU6ICdcIiArIHNvdXJjZVVSTCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEhhbmRsZXJzID0gcm91dGVyX3JlZ2lzdHJ5XzEuSU9Sb3V0ZXJSZWdpc3RyeS5nZXRMb2FkSGFuZGxlcnMoc291cmNlVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydChsb2FkSGFuZGxlcnMubGVuZ3RoID4gMCwgXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIGxvYWQgaGFuZGxlciBpcyBmb3VuZCBmb3Igc291cmNlIFVSTCBcIiArIHNvdXJjZVVSTCArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydChsb2FkSGFuZGxlcnMubGVuZ3RoIDwgMiwgXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG1vcmUgdGhhbiBvbmUgKFwiICsgbG9hZEhhbmRsZXJzLmxlbmd0aCArIFwiKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJsb2FkIGhhbmRsZXJzIGZvciBzb3VyY2UgVVJMIFwiICsgc291cmNlVVJMICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEhhbmRsZXIgPSBsb2FkSGFuZGxlcnNbMF07XG4gICAgICAgICAgICAgICAgICAgIHNhdmVIYW5kbGVycyA9IHJvdXRlcl9yZWdpc3RyeV8xLklPUm91dGVyUmVnaXN0cnkuZ2V0U2F2ZUhhbmRsZXJzKGRlc3RVUkwpO1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHNhdmVIYW5kbGVycy5sZW5ndGggPiAwLCBcIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2Ugbm8gc2F2ZSBoYW5kbGVyIGlzIGZvdW5kIGZvciBkZXN0aW5hdGlvbiBVUkwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGRlc3RVUkwgKyBcIi5cIikpO1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHNhdmVIYW5kbGVycy5sZW5ndGggPCAyLCBcIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSAoXCIgKyBsb2FkSGFuZGxlcnMubGVuZ3RoICsgXCIpIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcInNhdmUgaGFuZGxlcnMgZm9yIGRlc3RpbmF0aW9uIFVSTCBcIiArIGRlc3RVUkwgKyBcIi5cIikpO1xuICAgICAgICAgICAgICAgICAgICBzYXZlSGFuZGxlciA9IHNhdmVIYW5kbGVyc1swXTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU2NoZW1lID0gcGFyc2VVUkwoc291cmNlVVJMKS5zY2hlbWU7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVBhdGggPSBwYXJzZVVSTChzb3VyY2VVUkwpLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVNZWRpdW0gPSBzb3VyY2VTY2hlbWUgPT09IHBhcnNlVVJMKHNvdXJjZVVSTCkuc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGxvYWRIYW5kbGVyLmxvYWQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtb2RlbEFydGlmYWN0cyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVsZXRlU291cmNlICYmIHNhbWVNZWRpdW0pKSByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0TWFuYWdlcihzb3VyY2VTY2hlbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZU1vZGVsKHNvdXJjZVBhdGgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0LCBzYXZlSGFuZGxlci5zYXZlKG1vZGVsQXJ0aWZhY3RzKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBzYXZlUmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZWxldGVTb3VyY2UgJiYgIXNhbWVNZWRpdW0pKSByZXR1cm4gWzMsIDZdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIE1vZGVsU3RvcmVNYW5hZ2VyUmVnaXN0cnkuZ2V0TWFuYWdlcihzb3VyY2VTY2hlbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZU1vZGVsKHNvdXJjZVBhdGgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyLCBzYXZlUmVzdWx0Lm1vZGVsQXJ0aWZhY3RzSW5mb107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxudmFyIE1vZGVsTWFuYWdlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kZWxNYW5hZ2VtZW50KCkge1xuICAgIH1cbiAgICBNb2RlbE1hbmFnZW1lbnQubGlzdE1vZGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNjaGVtZXMsIG91dCwgX2ksIHNjaGVtZXNfMSwgc2NoZW1lLCBzY2hlbWVPdXQsIHBhdGgsIHVybDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtZXMgPSBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldFNjaGVtZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBzY2hlbWVzXzEgPSBzY2hlbWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IHNjaGVtZXNfMS5sZW5ndGgpKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1lID0gc2NoZW1lc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTW9kZWxTdG9yZU1hbmFnZXJSZWdpc3RyeS5nZXRNYW5hZ2VyKHNjaGVtZSkubGlzdE1vZGVscygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1lT3V0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwYXRoIGluIHNjaGVtZU91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHNjaGVtZSArIFVSTF9TQ0hFTUVfU1VGRklYICsgcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRbdXJsXSA9IHNjaGVtZU91dFtwYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyLCBvdXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1vZGVsTWFuYWdlbWVudC5yZW1vdmVNb2RlbCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNjaGVtZUFuZFBhdGgsIG1hbmFnZXI7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWVBbmRQYXRoID0gcGFyc2VVUkwodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXIgPSBNb2RlbFN0b3JlTWFuYWdlclJlZ2lzdHJ5LmdldE1hbmFnZXIoc2NoZW1lQW5kUGF0aC5zY2hlbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtYW5hZ2VyLnJlbW92ZU1vZGVsKHNjaGVtZUFuZFBhdGgucGF0aCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNb2RlbE1hbmFnZW1lbnQuY29weU1vZGVsID0gZnVuY3Rpb24gKHNvdXJjZVVSTCwgZGVzdFVSTCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVsZXRlU291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlU291cmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGNsb25lTW9kZWxJbnRlcm5hbChzb3VyY2VVUkwsIGRlc3RVUkwsIGRlbGV0ZVNvdXJjZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNb2RlbE1hbmFnZW1lbnQubW92ZU1vZGVsID0gZnVuY3Rpb24gKHNvdXJjZVVSTCwgZGVzdFVSTCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVsZXRlU291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlU291cmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2xvbmVNb2RlbEludGVybmFsKHNvdXJjZVVSTCwgZGVzdFVSTCwgZGVsZXRlU291cmNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ01hbmFnZW1lbnQnLCBuYW1lc3BhY2U6ICdpbycgfSlcbiAgICBdLCBNb2RlbE1hbmFnZW1lbnQsIFwibGlzdE1vZGVsc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdNYW5hZ2VtZW50JywgbmFtZXNwYWNlOiAnaW8nIH0pXG4gICAgXSwgTW9kZWxNYW5hZ2VtZW50LCBcInJlbW92ZU1vZGVsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ01hbmFnZW1lbnQnLCBuYW1lc3BhY2U6ICdpbycgfSlcbiAgICBdLCBNb2RlbE1hbmFnZW1lbnQsIFwiY29weU1vZGVsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ01hbmFnZW1lbnQnLCBuYW1lc3BhY2U6ICdpbycgfSlcbiAgICBdLCBNb2RlbE1hbmFnZW1lbnQsIFwibW92ZU1vZGVsXCIsIG51bGwpO1xuICAgIHJldHVybiBNb2RlbE1hbmFnZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5Nb2RlbE1hbmFnZW1lbnQgPSBNb2RlbE1hbmFnZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbF9tYW5hZ2VtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIElPUm91dGVyUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElPUm91dGVyUmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuc2F2ZVJvdXRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5sb2FkUm91dGVycyA9IFtdO1xuICAgIH1cbiAgICBJT1JvdXRlclJlZ2lzdHJ5LmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoSU9Sb3V0ZXJSZWdpc3RyeS5pbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBJT1JvdXRlclJlZ2lzdHJ5Lmluc3RhbmNlID0gbmV3IElPUm91dGVyUmVnaXN0cnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSU9Sb3V0ZXJSZWdpc3RyeS5pbnN0YW5jZTtcbiAgICB9O1xuICAgIElPUm91dGVyUmVnaXN0cnkucmVnaXN0ZXJTYXZlUm91dGVyID0gZnVuY3Rpb24gKHNhdmVSb3V0ZXIpIHtcbiAgICAgICAgSU9Sb3V0ZXJSZWdpc3RyeS5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzLnB1c2goc2F2ZVJvdXRlcik7XG4gICAgfTtcbiAgICBJT1JvdXRlclJlZ2lzdHJ5LnJlZ2lzdGVyTG9hZFJvdXRlciA9IGZ1bmN0aW9uIChsb2FkUm91dGVyKSB7XG4gICAgICAgIElPUm91dGVyUmVnaXN0cnkuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVycy5wdXNoKGxvYWRSb3V0ZXIpO1xuICAgIH07XG4gICAgSU9Sb3V0ZXJSZWdpc3RyeS5nZXRTYXZlSGFuZGxlcnMgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBJT1JvdXRlclJlZ2lzdHJ5LmdldEhhbmRsZXJzKHVybCwgJ3NhdmUnKTtcbiAgICB9O1xuICAgIElPUm91dGVyUmVnaXN0cnkuZ2V0TG9hZEhhbmRsZXJzID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gSU9Sb3V0ZXJSZWdpc3RyeS5nZXRIYW5kbGVycyh1cmwsICdsb2FkJyk7XG4gICAgfTtcbiAgICBJT1JvdXRlclJlZ2lzdHJ5LmdldEhhbmRsZXJzID0gZnVuY3Rpb24gKHVybCwgaGFuZGxlclR5cGUpIHtcbiAgICAgICAgdmFyIHZhbGlkSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdmFyIHJvdXRlcnMgPSBoYW5kbGVyVHlwZSA9PT0gJ2xvYWQnID8gdGhpcy5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzIDpcbiAgICAgICAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycztcbiAgICAgICAgcm91dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gcm91dGVyKHVybCk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbGlkSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWxpZEhhbmRsZXJzO1xuICAgIH07XG4gICAgcmV0dXJuIElPUm91dGVyUmVnaXN0cnk7XG59KCkpO1xuZXhwb3J0cy5JT1JvdXRlclJlZ2lzdHJ5ID0gSU9Sb3V0ZXJSZWdpc3RyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlcl9yZWdpc3RyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRFRZUEVfVkFMVUVfU0laRV9NQVAgPSB7XG4gICAgJ2Zsb2F0MzInOiA0LFxuICAgICdpbnQzMic6IDQsXG4gICAgJ3VpbnQxNic6IDIsXG4gICAgJ3VpbnQ4JzogMSxcbiAgICAnYm9vbCc6IDEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5mdW5jdGlvbiBsb2FkV2VpZ2h0c0FzQXJyYXlCdWZmZXIoZmV0Y2hVUkxzLCByZXF1ZXN0T3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RzLCByZXNwb25zZXMsIGJ1ZmZlcnM7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzID0gZmV0Y2hVUkxzLm1hcChmdW5jdGlvbiAoZmV0Y2hVUkwpIHsgcmV0dXJuIGZldGNoKGZldGNoVVJMLCByZXF1ZXN0T3B0aW9ucyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIFByb21pc2UuYWxsKHJlcXVlc3RzKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgUHJvbWlzZS5hbGwocmVzcG9uc2VzLm1hcChmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7IH0pKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBidWZmZXJzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGJ1ZmZlcnNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZFdlaWdodHNBc0FycmF5QnVmZmVyID0gbG9hZFdlaWdodHNBc0FycmF5QnVmZmVyO1xuZnVuY3Rpb24gbG9hZFdlaWdodHMobWFuaWZlc3QsIGZpbGVQYXRoUHJlZml4LCB3ZWlnaHROYW1lcywgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICBpZiAoZmlsZVBhdGhQcmVmaXggPT09IHZvaWQgMCkgeyBmaWxlUGF0aFByZWZpeCA9ICcnOyB9XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXBJbmRpY2VzVG9GZXRjaE1hcCwgZ3JvdXBXZWlnaHRzVG9GZXRjaCwgd2VpZ2h0c0ZvdW5kLCBhbGxNYW5pZmVzdFdlaWdodE5hbWVzLCB3ZWlnaHRzTm90Rm91bmQsIGdyb3VwSW5kaWNlc1RvRmV0Y2gsIGZldGNoVXJscywgYnVmZmVycywgd2VpZ2h0c1RlbnNvck1hcCwgYnVmZmVySW5kZXhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kaWNlc1RvRmV0Y2hNYXAgPSBtYW5pZmVzdC5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgICAgICAgICAgICAgICAgICBncm91cFdlaWdodHNUb0ZldGNoID0ge307XG4gICAgICAgICAgICAgICAgICAgIHdlaWdodHNGb3VuZCA9IHdlaWdodE5hbWVzICE9IG51bGwgPyB3ZWlnaHROYW1lcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pIDogW107XG4gICAgICAgICAgICAgICAgICAgIGFsbE1hbmlmZXN0V2VpZ2h0TmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3QuZm9yRWFjaChmdW5jdGlvbiAobWFuaWZlc3RHcm91cENvbmZpZywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0R3JvdXBDb25maWcud2VpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uICh3ZWlnaHRzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3RHR5cGUgPSAoJ3F1YW50aXphdGlvbicgaW4gd2VpZ2h0c0VudHJ5KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNFbnRyeS5xdWFudGl6YXRpb24uZHR5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzRW50cnkuZHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodHNCeXRlcyA9IHR5cGVzXzEuRFRZUEVfVkFMVUVfU0laRV9NQVBbcmF3RHR5cGVdICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHdlaWdodHNFbnRyeS5zaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVucXVldWVXZWlnaHRzRm9yRmV0Y2hpbmdGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRpY2VzVG9GZXRjaE1hcFtncm91cEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cFdlaWdodHNUb0ZldGNoW2dyb3VwSW5kZXhdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwV2VpZ2h0c1RvRmV0Y2hbZ3JvdXBJbmRleF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cFdlaWdodHNUb0ZldGNoW2dyb3VwSW5kZXhdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3RFbnRyeTogd2VpZ2h0c0VudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IGdyb3VwT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUJ5dGVzOiB3ZWlnaHRzQnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0TmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh3ZWlnaHROYW1lLCB3ZWlnaHRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlaWdodE5hbWUgPT09IHdlaWdodHNFbnRyeS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVdlaWdodHNGb3JGZXRjaGluZ0ZuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c0ZvdW5kW3dlaWdodEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVdlaWdodHNGb3JGZXRjaGluZ0ZuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbE1hbmlmZXN0V2VpZ2h0TmFtZXMucHVzaCh3ZWlnaHRzRW50cnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQgKz0gd2VpZ2h0c0J5dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdlaWdodHNGb3VuZC5ldmVyeShmdW5jdGlvbiAoZm91bmQpIHsgcmV0dXJuIGZvdW5kOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c05vdEZvdW5kID0gd2VpZ2h0TmFtZXMuZmlsdGVyKGZ1bmN0aW9uICh3ZWlnaHQsIGkpIHsgcmV0dXJuICF3ZWlnaHRzRm91bmRbaV07IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2VpZ2h0cyBpbiBtYW5pZmVzdCB3aXRoIG5hbWVzOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdlaWdodHNOb3RGb3VuZC5qb2luKCcsICcpICsgXCIuIFxcblwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYW5pZmVzdCBKU09OIGhhcyB3ZWlnaHRzIHdpdGggbmFtZXM6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWxsTWFuaWZlc3RXZWlnaHROYW1lcy5qb2luKCcsICcpICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncm91cEluZGljZXNUb0ZldGNoID0gZ3JvdXBJbmRpY2VzVG9GZXRjaE1hcC5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBzaG91bGRGZXRjaCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFVybHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRpY2VzVG9GZXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdFtpXS5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZXRjaFVybCA9IGZpbGVQYXRoUHJlZml4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFmaWxlUGF0aFByZWZpeC5lbmRzV2l0aCgnLycpID8gJy8nIDogJycpICsgZmlsZXBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hVcmxzLnB1c2goZmV0Y2hVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGxvYWRXZWlnaHRzQXNBcnJheUJ1ZmZlcihmZXRjaFVybHMsIHJlcXVlc3RPcHRpb25zKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBidWZmZXJzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzVGVuc29yTWFwID0ge307XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGV4T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRpY2VzVG9GZXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtQnVmZmVycyA9IG1hbmlmZXN0W2ldLnBhdGhzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cEJ5dGVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IG51bUJ1ZmZlcnM7IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBCeXRlcyArPSBidWZmZXJzW2J1ZmZlckluZGV4T2Zmc2V0ICsgaV8xXS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGdyb3VwQnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwQnl0ZUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGdyb3VwQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzIgPSAwOyBpXzIgPCBudW1CdWZmZXJzOyBpXzIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXJzW2J1ZmZlckluZGV4T2Zmc2V0ICsgaV8yXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBCeXRlQnVmZmVyLnNldChidWZmZXIsIGdyb3VwQnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEJ1ZmZlck9mZnNldCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRzRW50cmllcyA9IGdyb3VwV2VpZ2h0c1RvRmV0Y2hbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzRW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uICh3ZWlnaHRzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZUJ1ZmZlciA9IGdyb3VwQnVmZmVyLnNsaWNlKHdlaWdodHNFbnRyeS5ncm91cE9mZnNldCwgd2VpZ2h0c0VudHJ5Lmdyb3VwT2Zmc2V0ICsgd2VpZ2h0c0VudHJ5LnNpemVCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR0eXBlID0gd2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkuZHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdxdWFudGl6YXRpb24nIGluIHdlaWdodHNFbnRyeS5tYW5pZmVzdEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWFudGl6YXRpb25fMSA9IHdlaWdodHNFbnRyeS5tYW5pZmVzdEVudHJ5LnF1YW50aXphdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1YW50aXphdGlvbl8xLmR0eXBlICE9PSAndWludDgnICYmIHF1YW50aXphdGlvbl8xLmR0eXBlICE9PSAndWludDE2Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IFwiICsgd2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkubmFtZSArIFwiIGhhcyB1bmtub3duIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJxdWFudGl6YXRpb24gZHR5cGUgXCIgKyBxdWFudGl6YXRpb25fMS5kdHlwZSArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1YW50aXplZEFycmF5ID0gKHF1YW50aXphdGlvbl8xLmR0eXBlID09PSAndWludDgnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShieXRlQnVmZmVyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVWludDE2QXJyYXkoYnl0ZUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5ID0gRmxvYXQzMkFycmF5LmZyb20ocXVhbnRpemVkQXJyYXksIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICogcXVhbnRpemF0aW9uXzEuc2NhbGUgKyBxdWFudGl6YXRpb25fMS5taW47IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5ID0gSW50MzJBcnJheS5mcm9tKHF1YW50aXplZEFycmF5LCBmdW5jdGlvbiAodikgeyByZXR1cm4gTWF0aC5yb3VuZCh2ICogcXVhbnRpemF0aW9uXzEuc2NhbGUgKyBxdWFudGl6YXRpb25fMS5taW4pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlaWdodCBcIiArIHdlaWdodHNFbnRyeS5tYW5pZmVzdEVudHJ5Lm5hbWUgKyBcIiBoYXMgYSBkdHlwZSBub3QgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInN1cHBvcnRlZCBieSBxdWFudGl6YXRpb246IFwiICsgZHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGJ5dGVCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IEludDMyQXJyYXkoYnl0ZUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgXCIgKyB3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeS5uYW1lICsgXCIgaGFzIHVua25vd24gZHR5cGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkdHlwZSArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodE5hbWUgPSB3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWlnaHRzVGVuc29yTWFwW3dlaWdodE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIHdlaWdodCB3aXRoIG5hbWUgXCIgKyB3ZWlnaHROYW1lICsgXCIuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIG1ha2Ugc3VyZSB3ZWlnaHRzIG5hbWVzIGFyZSB1bmlxdWUgaW4gdGhlIG1hbmlmZXN0IEpTT04uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzVGVuc29yTWFwW3dlaWdodE5hbWVdID0gb3BzXzEudGVuc29yKHR5cGVkQXJyYXksIHdlaWdodHNFbnRyeS5tYW5pZmVzdEVudHJ5LnNoYXBlLCB3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeS5kdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGV4T2Zmc2V0ICs9IG51bUJ1ZmZlcnM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHdlaWdodHNUZW5zb3JNYXBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZFdlaWdodHMgPSBsb2FkV2VpZ2h0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWdodHNfbG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoXCJzZWVkcmFuZG9tXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4uL29wcy9heGlzX3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vb3BzL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uL29wcy9jb25jYXRfdXRpbFwiKTtcbnZhciBlcmZfdXRpbCA9IHJlcXVpcmUoXCIuLi9vcHMvZXJmX3V0aWxcIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBzZWx1X3V0aWwgPSByZXF1aXJlKFwiLi4vb3BzL3NlbHVfdXRpbFwiKTtcbnZhciBzbGljZV91dGlsXzEgPSByZXF1aXJlKFwiLi4vb3BzL3NsaWNlX3V0aWxcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yXCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBiYWNrZW5kX3V0aWwgPSByZXF1aXJlKFwiLi9iYWNrZW5kX3V0aWxcIik7XG52YXIgTWF0aEJhY2tlbmRDUFUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGhCYWNrZW5kQ1BVKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLmZpcnN0VXNlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkYXRhSWQsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAodGhpcy5maXJzdFVzZSkge1xuICAgICAgICAgICAgdGhpcy5maXJzdFVzZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfTk9ERScpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdIaSB0aGVyZSDwn5GLLiBMb29rcyBsaWtlIHlvdSBhcmUgcnVubmluZyBUZW5zb3JGbG93LmpzIGluICcgK1xuICAgICAgICAgICAgICAgICAgICAnTm9kZS5qcy4gVG8gc3BlZWQgdGhpbmdzIHVwIGRyYW1hdGljYWxseSwgaW5zdGFsbCBvdXIgbm9kZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tlbmQsIHdoaWNoIGJpbmRzIHRvIFRlbnNvckZsb3cgQysrLCBieSBydW5uaW5nICcgK1xuICAgICAgICAgICAgICAgICAgICAnbnBtIGkgQHRlbnNvcmZsb3cvdGZqcy1ub2RlLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ29yIG5wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZS1ncHUgaWYgeW91IGhhdmUgQ1VEQS4gJyArXG4gICAgICAgICAgICAgICAgICAgICdUaGVuIGNhbGwgcmVxdWlyZShcXCd0ZW5zb3JmbG93L3RmanMtbm9kZVxcJyk7ICgtZ3B1ICcgK1xuICAgICAgICAgICAgICAgICAgICAnc3VmZml4IGZvciBDVURBKSBhdCB0aGUgc3RhcnQgb2YgeW91ciBwcm9ncmFtLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1Zpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtbm9kZSBmb3IgbW9yZSBkZXRhaWxzLicgK1xuICAgICAgICAgICAgICAgICAgICAnXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgYnVmZmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEuc2V0KGRhdGFJZCwgbnVsbCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGhCYWNrZW5kQ1BVLndyaXRlKCk6IHZhbHVlcyBjYW4gbm90IGJlIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93SWZOb0RhdGEoZGF0YUlkKTtcbiAgICAgICAgdGhpcy5kYXRhLnNldChkYXRhSWQsIHZhbHVlcyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZnJvbVBpeGVscyA9IGZ1bmN0aW9uIChwaXhlbHMsIG51bUNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChwaXhlbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRoQmFja2VuZENQVS53cml0ZVBpeGVscygpOiBwaXhlbHMgY2FuIG5vdCBiZSBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHM7XG4gICAgICAgIGlmIChwaXhlbHMgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICAgICAgICAgIHZhbHMgPSBwaXhlbHMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwaXhlbHMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgdmFscyA9IHBpeGVscy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICAgICAgLmdldEltYWdlRGF0YSgwLCAwLCBwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGl4ZWxzIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fFxuICAgICAgICAgICAgcGl4ZWxzIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcmVhZCBwaXhlbHMgZnJvbSBIVE1MSW1hZ2VFbGVtZW50IG91dHNpZGUgJyArXG4gICAgICAgICAgICAgICAgICAgICd0aGUgYnJvd3Nlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGl4ZWxzLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxzLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHBpeGVscywgMCwgMCwgcGl4ZWxzLndpZHRoLCBwaXhlbHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhbHMgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICAgICAgLmdldEltYWdlRGF0YSgwLCAwLCBwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgaXMgb2YgdW5rbm93biB0eXBlOiBcIiArIHBpeGVscy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVzO1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KHZhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG51bVBpeGVscyA9IHBpeGVscy53aWR0aCAqIHBpeGVscy5oZWlnaHQ7XG4gICAgICAgICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShudW1QaXhlbHMgKiBudW1DaGFubmVscyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBpeGVsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBudW1DaGFubmVsczsgKytjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpICogbnVtQ2hhbm5lbHMgKyBjaGFubmVsXSA9IHZhbHNbaSAqIDQgKyBjaGFubmVsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dFNoYXBlID0gW3BpeGVscy5oZWlnaHQsIHBpeGVscy53aWR0aCwgbnVtQ2hhbm5lbHNdO1xuICAgICAgICByZXR1cm4gb3BzXzEudGVuc29yM2QodmFsdWVzLCBvdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZWFkU3luYyhkYXRhSWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWFkU3luYyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0KGRhdGFJZCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZGlzcG9zZURhdGEgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5kZWxldGUoZGF0YUlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIGtlcm5lbE1zO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgZigpO1xuICAgICAgICAgICAgICAgIGtlcm5lbE1zID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsga2VybmVsTXM6IGtlcm5lbE1zIH1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1lbW9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVucmVsaWFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50aHJvd0lmTm9EYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAoIXRoaXMuZGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ1BVIGJhY2tlbmQ6IE5vIGRhdGEgZm91bmQgZm9yIHRoaXMgdGVuc29yLiBcIiArXG4gICAgICAgICAgICAgICAgXCJEaWQgeW91IGNoYW5nZSB5b3VyIGJhY2tlbmQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcHJvZ3JhbT8gXCIgK1xuICAgICAgICAgICAgICAgIFwiTmV3IGJhY2tlbmRzIGNhbid0IHVzZSBUZW5zb3JzIGNyZWF0ZWQgd2l0aCBwcmV2aW91cyBiYWNrZW5kc1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBvcHMuYnVmZmVyKHNpemUsIHguZHR5cGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5zaXplOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBidWZmZXIuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciB4TG9jID0gbG9jLm1hcChmdW5jdGlvbiAoaWR4LCBqKSB7IHJldHVybiBpZHggKyBiZWdpbltqXTsgfSk7XG4gICAgICAgICAgICBidWZmZXIuc2V0LmFwcGx5KGJ1ZmZlciwgW3guZ2V0LmFwcGx5KHgsIHhMb2MpXS5jb25jYXQobG9jKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnN0cmlkZWRTbGljZSA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgZW5kLCBzdHJpZGVzLCBiZWdpbk1hc2ssIGVuZE1hc2spIHtcbiAgICAgICAgdmFyIF9hID0gc2xpY2VfdXRpbF8xLmdldFN0cmlkZWRTbGljZWRJbmZvKHguc2hhcGUsIGJlZ2luLCBlbmQsIHN0cmlkZXMsIGJlZ2luTWFzaywgZW5kTWFzayksIGJlZ2luSW5kZXggPSBfYVswXSwgc2l6ZSA9IF9hWzFdO1xuICAgICAgICBpZiAoc2l6ZS5zb21lKGZ1bmN0aW9uIChheGlzKSB7IHJldHVybiBheGlzID09PSAwOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wcy50ZW5zb3IoW10sIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBvcHMuYnVmZmVyKHNpemUsIHguZHR5cGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBidWZmZXIuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBuZXdMb2MgPSBuZXcgQXJyYXkobG9jLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0xvYy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG5ld0xvY1tqXSA9IGxvY1tqXSAqIHN0cmlkZXNbal0gKyBiZWdpbkluZGV4W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldC5hcHBseShidWZmZXIsIFt4LmdldC5hcHBseSh4LCBuZXdMb2MpXS5jb25jYXQobG9jKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB2YXIgYnVmZmVyID0gb3BzLmJ1ZmZlcih4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHhCdWZmZXIgPSB4LmJ1ZmZlcigpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgb3V0TG9jID0gYnVmZmVyLmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgaW5Mb2MgPSBvdXRMb2Muc2xpY2UoKTtcbiAgICAgICAgICAgIGF4aXMuZm9yRWFjaChmdW5jdGlvbiAoYXgpIHsgcmV0dXJuIGluTG9jW2F4XSA9IHguc2hhcGVbYXhdIC0gMSAtIGluTG9jW2F4XTsgfSk7XG4gICAgICAgICAgICBidWZmZXIuc2V0LmFwcGx5KGJ1ZmZlciwgW3hCdWZmZXIuZ2V0LmFwcGx5KHhCdWZmZXIsIGluTG9jKV0uY29uY2F0KG91dExvYykpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhLnNoYXBlLCBiLnNoYXBlLCAxKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG9wcy5idWZmZXIob3V0U2hhcGUsIGEuZHR5cGUpO1xuICAgICAgICBpZiAoYS5zaGFwZVswXSA9PT0gMSAmJiBiLnNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgYVZhbHMgPSBhLmRhdGFTeW5jKCk7XG4gICAgICAgICAgICB2YXIgYlZhbHMgPSBiLmRhdGFTeW5jKCk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IGJ1ZmZlci52YWx1ZXM7XG4gICAgICAgICAgICB2YWxzLnNldChhVmFscywgMCk7XG4gICAgICAgICAgICB2YWxzLnNldChiVmFscywgYS5zaXplKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIudG9UZW5zb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dFNoYXBlWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYS5zaGFwZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldChhLmdldChpLCBqKSwgaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIuc2hhcGVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoYi5nZXQoaSwgaiksIGksIGogKyBhLnNoYXBlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkob3BzLnNjYWxhcigtMSksIHgpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBhVmFsdWUgKyBiVmFsdWU7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpLCBmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHsgcmV0dXJuIGFWYWx1ZSAtIGJWYWx1ZTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCBhLmR0eXBlLCBmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHsgcmV0dXJuIE1hdGgucG93KGFWYWx1ZSwgYlZhbHVlKTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF0TXVsID0gZnVuY3Rpb24gKGEsIGIsIHRyYW5zcG9zZUEsIHRyYW5zcG9zZUIpIHtcbiAgICAgICAgdmFyIHNoYXJlZERpbSA9IHRyYW5zcG9zZUEgPyBhLnNoYXBlWzBdIDogYS5zaGFwZVsxXTtcbiAgICAgICAgdmFyIGxlZnREaW0gPSB0cmFuc3Bvc2VBID8gYS5zaGFwZVsxXSA6IGEuc2hhcGVbMF07XG4gICAgICAgIHZhciByaWdodERpbSA9IHRyYW5zcG9zZUIgPyBiLnNoYXBlWzBdIDogYi5zaGFwZVsxXTtcbiAgICAgICAgdmFyIGFWYWx1ZXMgPSBhLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBiVmFsdWVzID0gYi5kYXRhU3luYygpO1xuICAgICAgICB2YXIgX2EgPSB0cmFuc3Bvc2VBID8gWzEsIGEuc3RyaWRlc1swXV0gOiBbYS5zdHJpZGVzWzBdLCAxXSwgYU91dGVyU3RlcCA9IF9hWzBdLCBhSW5uZXJTdGVwID0gX2FbMV07XG4gICAgICAgIHZhciBfYiA9IHRyYW5zcG9zZUIgPyBbYi5zdHJpZGVzWzBdLCAxXSA6IFsxLCBiLnN0cmlkZXNbMF1dLCBiT3V0ZXJTdGVwID0gX2JbMF0sIGJJbm5lclN0ZXAgPSBfYlsxXTtcbiAgICAgICAgdmFyIGFPdXRlckVuZCA9IGxlZnREaW0gKiBhT3V0ZXJTdGVwO1xuICAgICAgICB2YXIgYk91dGVyRW5kID0gcmlnaHREaW0gKiBiT3V0ZXJTdGVwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShsZWZ0RGltICogcmlnaHREaW0pO1xuICAgICAgICB2YXIgcmVzdWx0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKHZhciBhT3V0ZXIgPSAwOyBhT3V0ZXIgPCBhT3V0ZXJFbmQ7IGFPdXRlciArPSBhT3V0ZXJTdGVwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBiT3V0ZXIgPSAwOyBiT3V0ZXIgPCBiT3V0ZXJFbmQ7IGJPdXRlciArPSBiT3V0ZXJTdGVwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFJbm5lciA9IGFPdXRlcjtcbiAgICAgICAgICAgICAgICB2YXIgYklubmVyID0gYk91dGVyO1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2hhcmVkRGltOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGFWYWx1ZXNbYUlubmVyXSAqIGJWYWx1ZXNbYklubmVyXTtcbiAgICAgICAgICAgICAgICAgICAgYUlubmVyICs9IGFJbm5lclN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIGJJbm5lciArPSBiSW5uZXJTdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0SW5kZXgrK10gPSBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wcy50ZW5zb3IyZChyZXN1bHQsIFtsZWZ0RGltLCByaWdodERpbV0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpLCBmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHsgcmV0dXJuIGFWYWx1ZSAqIGJWYWx1ZTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVhbERpdmlkZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBvcCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC8gYjsgfTtcbiAgICAgICAgdmFyIG91dHB1dER0eXBlID0gJ2Zsb2F0MzInO1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIG91dHB1dER0eXBlLCBvcCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZmxvb3JEaXYgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgb3AgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5mbG9vcihhIC8gYik7IH07XG4gICAgICAgIHZhciBvdXRwdXREdHlwZSA9ICdpbnQzMic7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgb3V0cHV0RHR5cGUsIG9wKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ3N1bScsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0RHR5cGUgPSB0eXBlcy51cGNhc3RUeXBlKHguZHR5cGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKG91dFNoYXBlLCByZXN1bHREdHlwZSk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gc3VtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYXJnTWluID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdmFyIGF4ZXMgPSBbYXhpc107XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWluJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3Mob3V0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWluID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFyZ01heCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHZhciBheGVzID0gW2F4aXNdO1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01heCcsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKG91dFNoYXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1heCA9IGFWYWxzW29mZnNldF07XG4gICAgICAgICAgICB2YXIgbWF4SW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG1heEluZGV4ID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWF4SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jdW1zdW0gPSBmdW5jdGlvbiAoeCwgYXhpcywgZXhjbHVzaXZlLCByZXZlcnNlKSB7XG4gICAgICAgIGlmIChheGlzICE9PSB4LnJhbmsgLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWNrZW5kLmN1bXN1bSBpbiBDUFUgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIgKyAoeC5yYW5rIC0gMSkgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IGdvdCBheGlzPVwiICsgYXhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHREdHlwZSA9IHR5cGVzLnVwY2FzdFR5cGUoeC5kdHlwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3MoeC5zaGFwZSwgcmVzdWx0RHR5cGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBmaW5hbERpbSA9IHguc2hhcGVbeC5yYW5rIC0gMV07XG4gICAgICAgIHZhciBpbmRleEFkanVzdGVyID0gcmV2ZXJzZSA/XG4gICAgICAgICAgICBmdW5jdGlvbiAoaSwgaikgeyByZXR1cm4gaSArIGZpbmFsRGltIC0gaiAtIDE7IH0gOlxuICAgICAgICAgICAgZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIGkgKyBqOyB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWxzLmxlbmd0aDsgaSArPSBmaW5hbERpbSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaW5hbERpbTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGluZGV4QWRqdXN0ZXIoaSwgaik7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsc1tpZHhdID0gZXhjbHVzaXZlID8gMCA6IGFWYWxzW2lkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldklkeCA9IGluZGV4QWRqdXN0ZXIoaSwgaiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YWxzW2lkeF0gPSBleGNsdXNpdmUgPyBhVmFsc1twcmV2SWR4XSArIHZhbHNbcHJldklkeF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgYVZhbHNbaWR4XSArIHZhbHNbcHJldklkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoYVZhbCA9PT0gYlZhbCkgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubm90RXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiAoYVZhbCAhPT0gYlZhbCkgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChhVmFsIDwgYlZhbCkgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubGVzc0VxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFWYWwgPD0gYlZhbCkgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZ3JlYXRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIChhVmFsID4gYlZhbCkgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZ3JlYXRlckVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFWYWwgPj0gYlZhbCkgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubG9naWNhbE5vdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgSW50MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IHZhbHVlc1tpXSA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0sICdib29sJyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubG9naWNhbEFuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFWYWwgJiYgYlZhbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubG9naWNhbE9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYVZhbCB8fCBiVmFsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGEsIGIsIGR0eXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBjb25kaXRpb24uZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFWYWx1ZXMgPSBhLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBiVmFsdWVzID0gYi5kYXRhU3luYygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKGEuc2hhcGUsIGR0eXBlKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gY29uZGl0aW9uLnJhbmsgPT09IDAgfHwgY29uZGl0aW9uLnJhbmsgPiAxIHx8IGEucmFuayA9PT0gMSA/XG4gICAgICAgICAgICAxIDpcbiAgICAgICAgICAgIGEuc2hhcGVbMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9mZnNldDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaW5kZXgrK10gPSBhVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzW2luZGV4KytdID0gYlZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50b3BLVmFsdWVzID0gZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wSyh4LCBrKS52YWx1ZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudG9wS0luZGljZXMgPSBmdW5jdGlvbiAoeCwgaykge1xuICAgICAgICByZXR1cm4gdGhpcy50b3BLKHgsIGspLmluZGljZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudG9wSyA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciB2YWx1ZXNBbmRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNBbmRJbmRpY2VzLnB1c2goeyB2YWx1ZTogdmFsdWVzW2ldLCBpbmRleDogaSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNBbmRJbmRpY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0b3BrVmFsdWVzID0gdXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKHguZHR5cGUsIGspO1xuICAgICAgICB2YXIgdG9wa0luZGljZXMgPSBuZXcgSW50MzJBcnJheShrKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgIHRvcGtWYWx1ZXNbaV0gPSB2YWx1ZXNBbmRJbmRpY2VzW2ldLnZhbHVlO1xuICAgICAgICAgICAgdG9wa0luZGljZXNbaV0gPSB2YWx1ZXNBbmRJbmRpY2VzW2ldLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZXM6IG9wcy50ZW5zb3IxZCh0b3BrVmFsdWVzLCB4LmR0eXBlKSxcbiAgICAgICAgICAgIGluZGljZXM6IG9wcy50ZW5zb3IxZCh0b3BrSW5kaWNlcywgJ2ludDMyJylcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21pbicsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1pbiA9IGFWYWxzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1pbmltdW0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIGEuZHR5cGUsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7IHJldHVybiBNYXRoLm1pbihhVmFsLCBiVmFsKTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCBhLmR0eXBlLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgdmFyIHJlbSA9IGFWYWwgJSBiVmFsO1xuICAgICAgICAgICAgaWYgKChhVmFsIDwgMCAmJiBiVmFsIDwgMCkgfHwgKGFWYWwgPj0gMCAmJiBiVmFsID49IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAocmVtICsgYlZhbCkgJSBiVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21heCcsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1heCA9IGFWYWxzW29mZnNldF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHsgcmV0dXJuIE1hdGgubWF4KGFWYWwsIGJWYWwpOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gYVZhbCAtIGJWYWw7XG4gICAgICAgICAgICByZXR1cm4gZGlmZiAqIGRpZmY7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNlaWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguY2VpbCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmZsb29yKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlc1tpXSA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSBNYXRoLmZsb29yKHZhbHVlc1tpXSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2ldIC0gYmFzZSA8IDAuNSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguZmxvb3IodmFsdWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlc1tpXSAtIGJhc2UgPiAwLjUpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmNlaWwodmFsdWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChiYXNlICUgMi4wID09PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gYmFzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IGJhc2UgKyAxLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5leHAodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5leHBtMSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5leHBtMSh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5sb2codmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvZzFwID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmxvZzFwKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLnNxcnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJzcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSAxIC8gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IHZhbHVlICogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVjaXByb2NhbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gMSAvIHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlcyA9IG9wcy56ZXJvcyh4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlc1ZhbHMgPSByZXMuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGluVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpblZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1ZhbHNbaV0gPSBNYXRoLm1heCgwLCBpblZhbHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSAoTWF0aC5leHAodikgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5lbHVEZXIgPSBmdW5jdGlvbiAoZHksIHkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHkuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGR5VmFsdWVzID0gZHkuZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IGR5VmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gZHlWYWx1ZXNbaV0gKiAodiArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnNlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgc2NhbGVBbHBoYSA9IHNlbHVfdXRpbC5TRUxVX1NDQUxFQUxQSEE7XG4gICAgICAgIHZhciBzY2FsZSA9IHNlbHVfdXRpbC5TRUxVX1NDQUxFO1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gc2NhbGUgKiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gc2NhbGVBbHBoYSAqIChNYXRoLmV4cCh2KSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hYnModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5pbnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEludDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9LCAnaW50MzInKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zaWdtb2lkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IDEgLyAoMSArIE1hdGguZXhwKC12YWx1ZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zb2Z0cGx1cyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBlcHNpbG9uID0gMS4xOTIwOTI4OTU1MDc4MTI1ZS03O1xuICAgICAgICB2YXIgdGhyZXNob2xkID0gTWF0aC5sb2coZXBzaWxvbikgKyAyLjA7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdG9vTGFyZ2UgPSB2YWx1ZXNbaV0gPiAtdGhyZXNob2xkO1xuICAgICAgICAgICAgdmFyIHRvb1NtYWxsID0gdmFsdWVzW2ldIDwgdGhyZXNob2xkO1xuICAgICAgICAgICAgdmFyIGV4cFggPSBNYXRoLmV4cCh2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cFg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b29MYXJnZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE1hdGgubG9nKDEuMCArIGV4cFgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnNpbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmNvcyh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRhbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnRhbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFzaW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hc2luKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYWNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFjb3ModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hdGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYXRhbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmF0YW4yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCBhLmR0eXBlLCBmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHsgcmV0dXJuIE1hdGguYXRhbjIoYVZhbHVlLCBiVmFsdWUpOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zaW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguc2luaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5jb3NoKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudGFuaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB1dGlsLnRhbmgodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hc2luaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFzaW5oKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYWNvc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hY29zaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmF0YW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYXRhbmgodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5lcmYgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgcCA9IGVyZl91dGlsLkVSRl9QO1xuICAgICAgICB2YXIgYTEgPSBlcmZfdXRpbC5FUkZfQTE7XG4gICAgICAgIHZhciBhMiA9IGVyZl91dGlsLkVSRl9BMjtcbiAgICAgICAgdmFyIGEzID0gZXJmX3V0aWwuRVJGX0EzO1xuICAgICAgICB2YXIgYTQgPSBlcmZfdXRpbC5FUkZfQTQ7XG4gICAgICAgIHZhciBhNSA9IGVyZl91dGlsLkVSRl9BNTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgdmFyIHQgPSAxLjAgLyAoMS4wICsgcCAqIHYpO1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gMS4wIC1cbiAgICAgICAgICAgICAgICAoKCgoKGE1ICogdCArIGE0KSAqIHQpICsgYTMpICogdCArIGEyKSAqIHQgKyBhMSkgKiB0ICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5leHAoLXYgKiB2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMDsgfVxuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHZhbHVlID4gMCA/IDEgOiBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb252MmQgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgIHZhciBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHkgPSBvcHMuYnVmZmVyKGNvbnZJbmZvLm91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IGNvbnZJbmZvLm91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IGNvbnZJbmZvLm91dEhlaWdodDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIGNvbnZJbmZvLnN0cmlkZUhlaWdodCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCBjb252SW5mby5vdXRXaWR0aDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBjb252SW5mby5zdHJpZGVXaWR0aCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7IHdSKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFIgPSB4UkNvcm5lciArIHdSICogZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBjb252SW5mby5pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyB3QysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4QyA9IHhDQ29ybmVyICsgd0MgKiBkaWxhdGlvbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IGNvbnZJbmZvLmluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldChiLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmaWx0ZXIuZ2V0KHdSLCB3QywgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5LnNldChkb3RQcm9kLCBiLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geS50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvbnYyZERlcklucHV0ID0gZnVuY3Rpb24gKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBkeCA9IG9wcy5idWZmZXIoY29udkluZm8uaW5TaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgdmFyIGR4VmFsdWVzID0gZHgudmFsdWVzO1xuICAgICAgICB2YXIgX2EgPSBkeC5zdHJpZGVzLCBkeFMwID0gX2FbMF0sIGR4UzEgPSBfYVsxXSwgZHhTMiA9IF9hWzJdO1xuICAgICAgICB2YXIgZHlWYWx1ZXMgPSBkeS5kYXRhU3luYygpO1xuICAgICAgICB2YXIgX2IgPSBkeS5zdHJpZGVzLCBkeVMwID0gX2JbMF0sIGR5UzEgPSBfYlsxXSwgZHlTMiA9IF9iWzJdO1xuICAgICAgICB2YXIgZmx0VmFsdWVzID0gZmlsdGVyLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBfYyA9IGZpbHRlci5zdHJpZGVzLCBmbHRTMCA9IF9jWzBdLCBmbHRTMSA9IF9jWzFdLCBmbHRTMiA9IF9jWzJdO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29udkluZm8uYmF0Y2hTaXplLCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGgsIGluQ2hhbm5lbHMgPSBjb252SW5mby5pbkNoYW5uZWxzLCBpbkhlaWdodCA9IGNvbnZJbmZvLmluSGVpZ2h0LCBpbldpZHRoID0gY29udkluZm8uaW5XaWR0aCwgb3V0Q2hhbm5lbHMgPSBjb252SW5mby5vdXRDaGFubmVscywgb3V0SGVpZ2h0ID0gY29udkluZm8ub3V0SGVpZ2h0LCBvdXRXaWR0aCA9IGNvbnZJbmZvLm91dFdpZHRoLCBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciB0b3BQYWQgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBsZWZ0UGFkID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0gMDsgeFIgPCBpbkhlaWdodDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB4UiAtIHRvcFBhZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhSQ29ybmVyIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5Uk1heCA9IE1hdGgubWluKG91dEhlaWdodCwgKGZpbHRlckhlaWdodCArIHhSQ29ybmVyKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0gMDsgeEMgPCBpbldpZHRoOyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB4QyAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeENDb3JuZXIgLyBzdHJpZGVXaWR0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4ob3V0V2lkdGgsIChmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0geFJNaW47IHlSIDwgeVJNYXg7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB5UiAqIHN0cmlkZUhlaWdodCAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geENNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geUMgKiBzdHJpZGVXaWR0aCAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlPZmZzZXQgPSBkeVMwICogYiArIGR5UzEgKiB5UiArIGR5UzIgKiB5QztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsdE9mZnNldCA9IGZsdFMwICogKGZpbHRlckhlaWdodCAtIDEgLSB3UikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx0UzEgKiAoZmlsdGVyV2lkdGggLSAxIC0gd0MpICsgZmx0UzIgKiBkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IG91dENoYW5uZWxzOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeVZhbHVlc1tkeU9mZnNldCArIGQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmbHRWYWx1ZXNbZmx0T2Zmc2V0ICsgZDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGR4VmFsdWVzW2R4UzAgKiBiICsgZHhTMSAqIHhSICsgZHhTMiAqIHhDICsgZDFdID0gZG90UHJvZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHgudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXIgPSBmdW5jdGlvbiAoeCwgZHksIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGRXID0gb3BzLmJ1ZmZlcihjb252SW5mby5maWx0ZXJTaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgdmFyIGxlZnRQYWQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciB0b3BQYWQgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgdmFyIHlSTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCh0b3BQYWQgLSB3UikgLyBzdHJpZGVIZWlnaHQpKTtcbiAgICAgICAgICAgIHZhciB5Uk1heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dEhlaWdodCwgKGNvbnZJbmZvLmluSGVpZ2h0ICsgdG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgIHZhciB5Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4oY29udkluZm8ub3V0V2lkdGgsIChjb252SW5mby5pbldpZHRoICsgbGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgY29udkluZm8ub3V0Q2hhbm5lbHM7ICsrZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHlSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4UiA9IHdSICsgeVIgKiBzdHJpZGVIZWlnaHQgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geUNNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4QyA9IHdDICsgeUMgKiBzdHJpZGVXaWR0aCAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHguZ2V0KGIsIHhSLCB4QywgZDEpICogZHkuZ2V0KGIsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZFcuc2V0KGRvdFByb2QsIHdSLCB3QywgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZFcudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgIHZhciBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIGNoTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuICAgICAgICB2YXIgeSA9IG9wcy5idWZmZXIoY29udkluZm8ub3V0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCBjb252SW5mby5vdXRIZWlnaHQ7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBjb252SW5mby5zdHJpZGVIZWlnaHQgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgY29udkluZm8ub3V0V2lkdGg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IGNoTXVsOyArK3EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeFIgPSB4UkNvcm5lciArIHdSICogZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gY29udkluZm8uaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDID0geENDb3JuZXIgKyB3QyAqIGRpbGF0aW9uV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IGNvbnZJbmZvLmluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZpbHRlci5nZXQod1IsIHdDLCBkMSwgcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkuc2V0KGRvdFByb2QsIGIsIHlSLCB5QywgZDEgKiBjaE11bCArIHEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQgPSBmdW5jdGlvbiAoZHksIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGR4ID0gb3BzLmJ1ZmZlcihjb252SW5mby5pblNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgZHhWYWx1ZXMgPSBkeC52YWx1ZXM7XG4gICAgICAgIHZhciBfYSA9IGR4LnN0cmlkZXMsIGR4UzAgPSBfYVswXSwgZHhTMSA9IF9hWzFdLCBkeFMyID0gX2FbMl07XG4gICAgICAgIHZhciBkeVZhbHVlcyA9IGR5LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBfYiA9IGR5LnN0cmlkZXMsIGR5UzAgPSBfYlswXSwgZHlTMSA9IF9iWzFdLCBkeVMyID0gX2JbMl07XG4gICAgICAgIHZhciBmbHRWYWx1ZXMgPSBmaWx0ZXIuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIF9jID0gZmlsdGVyLnN0cmlkZXMsIGZsdFMwID0gX2NbMF0sIGZsdFMxID0gX2NbMV0sIGZsdFMyID0gX2NbMl07XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBjb252SW5mby5iYXRjaFNpemUsIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aCwgaW5DaGFubmVscyA9IGNvbnZJbmZvLmluQ2hhbm5lbHMsIGluSGVpZ2h0ID0gY29udkluZm8uaW5IZWlnaHQsIGluV2lkdGggPSBjb252SW5mby5pbldpZHRoLCBvdXRDaGFubmVscyA9IGNvbnZJbmZvLm91dENoYW5uZWxzLCBvdXRIZWlnaHQgPSBjb252SW5mby5vdXRIZWlnaHQsIG91dFdpZHRoID0gY29udkluZm8ub3V0V2lkdGgsIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHRvcFBhZCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIGxlZnRQYWQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBjaE11bCA9IG91dENoYW5uZWxzIC8gaW5DaGFubmVscztcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IDA7IHhSIDwgaW5IZWlnaHQ7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geFIgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4UkNvcm5lciAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihvdXRIZWlnaHQsIChmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcikgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IDA7IHhDIDwgaW5XaWR0aDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geEMgLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhDQ29ybmVyIC8gc3RyaWRlV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKG91dFdpZHRoLCAoZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcikgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHhSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geVIgKiBzdHJpZGVIZWlnaHQgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHhDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHlDICogc3RyaWRlV2lkdGggLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5T2Zmc2V0ID0gZHlTMCAqIGIgKyBkeVMxICogeVIgKyBkeVMyICogeUM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbHRPZmZzZXQgPSBmbHRTMCAqIChmaWx0ZXJIZWlnaHQgLSAxIC0gd1IpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdFMxICogKGZpbHRlcldpZHRoIC0gMSAtIHdDKSArIGZsdFMyICogZDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGRtID0gMDsgZG0gPCBjaE11bDsgKytkbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQyID0gZDEgKiBjaE11bCArIGRtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gZHlWYWx1ZXNbZHlPZmZzZXQgKyBkMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZmx0VmFsdWVzW2ZsdE9mZnNldCArIGRtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkeFZhbHVlc1tkeFMwICogYiArIGR4UzEgKiB4UiArIGR4UzIgKiB4QyArIGQxXSA9IGRvdFByb2Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR4LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyID0gZnVuY3Rpb24gKHgsIGR5LCBjb252SW5mbykge1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBkVyA9IG9wcy5idWZmZXIoY29udkluZm8uZmlsdGVyU2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHZhciBsZWZ0UGFkID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgdG9wUGFkID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBjaE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgdmFyIHlSTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCh0b3BQYWQgLSB3UikgLyBzdHJpZGVIZWlnaHQpKTtcbiAgICAgICAgICAgIHZhciB5Uk1heCA9IE1hdGgubWluKGNvbnZJbmZvLm91dEhlaWdodCwgKGNvbnZJbmZvLmluSGVpZ2h0ICsgdG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgIHZhciB5Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4oY29udkluZm8ub3V0V2lkdGgsIChjb252SW5mby5pbldpZHRoICsgbGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgY29udkluZm8ub3V0Q2hhbm5lbHM7ICsrZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQxID0gTWF0aC50cnVuYyhkMiAvIGNoTXVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRtID0gZDIgJSBjaE11bDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHlSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhSID0gd1IgKyB5UiAqIHN0cmlkZUhlaWdodCAtIHRvcFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHlDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4QyA9IHdDICsgeUMgKiBzdHJpZGVXaWR0aCAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geC5nZXQoYiwgeFIsIHhDLCBkMSkgKiBkeS5nZXQoYiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRXLnNldChkb3RQcm9kLCB3Uiwgd0MsIGQxLCBkbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkVy50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRpbGUgPSBmdW5jdGlvbiAoeCwgcmVwcykge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkoeC5yYW5rKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3U2hhcGVbaV0gPSB4LnNoYXBlW2ldICogcmVwc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLmJ1ZmZlcihuZXdTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciB4QnVmID0geC5idWZmZXIoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmV3TG9jID0gcmVzdWx0LmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxMb2MgPSBuZXcgQXJyYXkoeC5yYW5rKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IG9yaWdpbmFsTG9jLmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExvY1tpXzFdID0gbmV3TG9jW2lfMV0gJSB4LnNoYXBlW2lfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxJbmRleCA9IHhCdWYubG9jVG9JbmRleChvcmlnaW5hbExvYyk7XG4gICAgICAgICAgICByZXN1bHQudmFsdWVzW2ldID0geEJ1Zi52YWx1ZXNbb3JpZ2luYWxJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIHBbMF0gKyB4LnNoYXBlW2ldICsgcFsxXTsgfSk7XG4gICAgICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSk7XG4gICAgICAgIHZhciB4QnVmZmVyID0geC5idWZmZXIoKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG9wcy5idWZmZXIob3V0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICBpZiAoY29uc3RhbnRWYWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyLnZhbHVlcy5maWxsKGNvbnN0YW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSB4QnVmZmVyLmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgb3V0Q29vcmRzID0gY29vcmRzLm1hcChmdW5jdGlvbiAoYywgaSkgeyByZXR1cm4gYyArIHN0YXJ0W2ldOyB9KTtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQuYXBwbHkoYnVmZmVyLCBbeC5nZXQuYXBwbHkoeCwgY29vcmRzKV0uY29uY2F0KG91dENvb3JkcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXIudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoeCwgcGVybSkge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkoeC5yYW5rKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3U2hhcGVbaV0gPSB4LnNoYXBlW3Blcm1baV1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHNfMS5idWZmZXIobmV3U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgeEJ1ZiA9IHguYnVmZmVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5zaXplOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSB4QnVmLmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgbmV3TG9jID0gbmV3IEFycmF5KGxvYy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaV8yID0gMDsgaV8yIDwgbmV3TG9jLmxlbmd0aDsgaV8yKyspIHtcbiAgICAgICAgICAgICAgICBuZXdMb2NbaV8yXSA9IGxvY1twZXJtW2lfMl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gcmVzdWx0LmxvY1RvSW5kZXgobmV3TG9jKTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZXNbbmV3SW5kZXhdID0gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5nYXRoZXIgPSBmdW5jdGlvbiAoeCwgaW5kaWNlcywgYXhpcykge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHZhciBpbmRpY2VzVmFsdWVzID0gaW5kaWNlcy5kYXRhU3luYygpO1xuICAgICAgICBuZXdTaGFwZVtheGlzXSA9IGluZGljZXNWYWx1ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzXzEuYnVmZmVyKG5ld1NoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHhCdWYgPSB4LmJ1ZmZlcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5zaXplOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuZXdMb2MgPSByZXN1bHQuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbExvYyA9IG5ld0xvYy5zbGljZSgpO1xuICAgICAgICAgICAgb3JpZ2luYWxMb2NbYXhpc10gPSBpbmRpY2VzVmFsdWVzW25ld0xvY1theGlzXV07XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxJbmRleCA9IHhCdWYubG9jVG9JbmRleChvcmlnaW5hbExvYyk7XG4gICAgICAgICAgICByZXN1bHQudmFsdWVzW2ldID0geEJ1Zi52YWx1ZXNbb3JpZ2luYWxJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnBvb2wgPSBmdW5jdGlvbiAoeCwgY29udkluZm8sIHBvb2xUeXBlKSB7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHkgPSBvcHMuYnVmZmVyKGNvbnZJbmZvLm91dFNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCBjb252SW5mby5vdXRIZWlnaHQ7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5IZWlnaHQsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLmluV2lkdGgsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbk1heFZhbHVlID0gKHBvb2xUeXBlID09PSAnbWF4JyA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdmdWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0geC5nZXQoYiwgeFIsIHhDLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwb29sVHlwZSA9PT0gJ21heCcgJiYgcGl4ZWwgPiBtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmdWYWx1ZSArPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG1pbk1heFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5LnNldChwb29sVHlwZSA9PT0gJ2F2ZycgPyBhdmdWYWx1ZSAvIGNvdW50IDogbWluTWF4VmFsdWUsIGIsIHlSLCB5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHkudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tYXhQb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2woeCwgY29udkluZm8sICdtYXgnKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tYXhQb29sUG9zaXRpb25zID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBtYXhQb3NpdGlvbnMgPSBvcHMuYnVmZmVyKGNvbnZJbmZvLm91dFNoYXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCBjb252SW5mby5vdXRIZWlnaHQ7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5IZWlnaHQsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLmluV2lkdGgsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geFIgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KGIsIHhSLCB4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbCA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb24gPSB3UiAqIGZpbHRlcldpZHRoICsgd0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbnMuc2V0KG1heFBvc2l0aW9uLCBiLCB5UiwgeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhQb3NpdGlvbnMudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIHgsIHksIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBtYXhQb3NpdGlvbnMgPSB0aGlzLm1heFBvb2xQb3NpdGlvbnMoeCwgY29udkluZm8pO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgZHggPSBvcHMuYnVmZmVyKHguc2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHhSID0gMDsgZHhSIDwgY29udkluZm8uaW5IZWlnaHQ7ICsrZHhSKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGR4QyA9IDA7IGR4QyA8IGNvbnZJbmZvLmluV2lkdGg7ICsrZHhDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlSQ29ybmVyID0gZHhSIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5Q0Nvcm5lciA9IGR4QyAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UiA9IChkeVJDb3JuZXIgKyB3UikgLyBzdHJpZGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IGNvbnZJbmZvLm91dEhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGR5UikgIT09IGR5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUMgPSAoZHlDQ29ybmVyICsgd0MpIC8gc3RyaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBjb252SW5mby5vdXRXaWR0aCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeUMpICE9PSBkeUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhQb3MgPSBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCAtIDEgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb25zLmdldChiLCBkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJQb3MgPSB3UiAqIGZpbHRlcldpZHRoICsgd0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXNrID0gbWF4UG9zID09PSBjdXJQb3MgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5LmdldChiLCBkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiBtYXNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGR4LnNldChkb3RQcm9kLCBiLCBkeFIsIGR4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR4LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgZHggPSBvcHMuYnVmZmVyKHguc2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHZhciBhdmdNdWx0aXBsaWVyID0gMSAvIChmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCk7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHhSID0gMDsgZHhSIDwgY29udkluZm8uaW5IZWlnaHQ7ICsrZHhSKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGR4QyA9IDA7IGR4QyA8IGNvbnZJbmZvLmluV2lkdGg7ICsrZHhDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlSQ29ybmVyID0gZHhSIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5Q0Nvcm5lciA9IGR4QyAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UiA9IChkeVJDb3JuZXIgKyB3UikgLyBzdHJpZGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IGNvbnZJbmZvLm91dEhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGR5UikgIT09IGR5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUMgPSAoZHlDQ29ybmVyICsgd0MpIC8gc3RyaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBjb252SW5mby5vdXRXaWR0aCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeUMpICE9PSBkeUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5LmdldChiLCBkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZHguc2V0KGRvdFByb2QgKiBhdmdNdWx0aXBsaWVyLCBiLCBkeFIsIGR4QywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR4LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uICh4LCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gYmFja2VuZF91dGlsLmNhc3RUZW5zb3IoeCwgZHR5cGUsIHRoaXMpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbiAoeCwgc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmRfdXRpbC5yZXNoYXBlVGVuc29yKHgsIHNoYXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hdmdQb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvb2woeCwgY29udkluZm8sICdhdmcnKS50b0Zsb2F0KCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIgPSBmdW5jdGlvbiAoeCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBfYSA9IHguc2hhcGUsIGJhdGNoID0gX2FbMF0sIG9sZEhlaWdodCA9IF9hWzFdLCBvbGRXaWR0aCA9IF9hWzJdLCBudW1DaGFubmVscyA9IF9hWzNdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gb3BzLmJ1ZmZlcihbYmF0Y2gsIG5ld0hlaWdodCwgbmV3V2lkdGgsIG51bUNoYW5uZWxzXSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciBlZmZlY3RpdmVJbnB1dFNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gb2xkSGVpZ2h0IC0gMSA6IG9sZEhlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3V2lkdGggPiAxKSA/IG9sZFdpZHRoIC0gMSA6IG9sZFdpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBlZmZlY3RpdmVPdXRwdXRTaXplID0gW1xuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdIZWlnaHQgPiAxKSA/IG5ld0hlaWdodCAtIDEgOiBuZXdIZWlnaHQsXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld1dpZHRoID4gMSkgPyBuZXdXaWR0aCAtIDEgOiBuZXdXaWR0aFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoOyBiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgbmV3SGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5ld1dpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBudW1DaGFubmVsczsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY1JvdyA9IChlZmZlY3RpdmVJbnB1dFNpemVbMF0pICogciAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VGcmFjQ29sID0gKGVmZmVjdGl2ZUlucHV0U2l6ZVsxXSkgKiBjIC8gKGVmZmVjdGl2ZU91dHB1dFNpemVbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVJvd0Zsb29yID0gTWF0aC5mbG9vcihzb3VyY2VGcmFjUm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VSb3dDZWlsID0gTWF0aC5taW4ob2xkSGVpZ2h0IC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNSb3cpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDb2xGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY0NvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sQ2VpbCA9IE1hdGgubWluKG9sZFdpZHRoIC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNDb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BMZWZ0ID0geC5nZXQoYiwgc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbEZsb29yLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21MZWZ0ID0geC5nZXQoYiwgc291cmNlUm93Q2VpbCwgc291cmNlQ29sRmxvb3IsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcFJpZ2h0ID0geC5nZXQoYiwgc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbENlaWwsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0geC5nZXQoYiwgc291cmNlUm93Q2VpbCwgc291cmNlQ29sQ2VpbCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93RnJhYyA9IHNvdXJjZUZyYWNSb3cgLSBzb3VyY2VSb3dGbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xGcmFjID0gc291cmNlRnJhY0NvbCAtIHNvdXJjZUNvbEZsb29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcF8xID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogY29sRnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBjb2xGcmFjO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9wXzEgKyAoYm90dG9tIC0gdG9wXzEpICogcm93RnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQobmV3VmFsdWUsIGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdmFyIF9hID0geC5zaGFwZSwgYmF0Y2ggPSBfYVswXSwgeEhlaWdodCA9IF9hWzFdLCB4V2lkdGggPSBfYVsyXSwgZGVwdGggPSBfYVszXTtcbiAgICAgICAgdmFyIF9iID0gZHkuc2hhcGUsIHlIZWlnaHQgPSBfYlsxXSwgeVdpZHRoID0gX2JbMl07XG4gICAgICAgIHZhciBvdXRwdXQgPSBvcHMuYnVmZmVyKFtiYXRjaCwgeEhlaWdodCwgeFdpZHRoLCBkZXB0aF0sIHguZHR5cGUpO1xuICAgICAgICB2YXIgZWZmZWN0aXZlWFNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlIZWlnaHQgPiAxKSA/IHhIZWlnaHQgLSAxIDogeEhlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeVdpZHRoID4gMSkgPyB4V2lkdGggLSAxIDogeFdpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBlZmZlY3RpdmVZU2l6ZSA9IFtcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeUhlaWdodCA+IDEpID8geUhlaWdodCAtIDEgOiB5SGVpZ2h0LFxuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5V2lkdGggPiAxKSA/IHlXaWR0aCAtIDEgOiB5V2lkdGhcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGhlaWdodFNjYWxlID0gZWZmZWN0aXZlWFNpemVbMF0gLyBlZmZlY3RpdmVZU2l6ZVswXTtcbiAgICAgICAgdmFyIHdpZHRoU2NhbGUgPSBlZmZlY3RpdmVYU2l6ZVsxXSAvIGVmZmVjdGl2ZVlTaXplWzFdO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoOyBiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgeUhlaWdodDsgcisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR4UiA9IHIgKiBoZWlnaHRTY2FsZTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wRHhSSW5kZXggPSBNYXRoLmZsb29yKGR4Uik7XG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbUR4UkluZGV4ID0gTWF0aC5taW4oTWF0aC5jZWlsKGR4UiksIHhIZWlnaHQgLSAxKTtcbiAgICAgICAgICAgICAgICB2YXIgZHhSTGVycCA9IGR4UiAtIHRvcER4UkluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlRHhSTGVycCA9IDEuMCAtIGR4UkxlcnA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB5V2lkdGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHhDID0gYyAqIHdpZHRoU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0RHhDSW5kZXggPSBNYXRoLmZsb29yKGR4Qyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaWdodER4Q0luZGV4ID0gTWF0aC5taW4oTWF0aC5jZWlsKGR4QyksIHhXaWR0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHhDTGVycCA9IGR4QyAtIGxlZnREeENJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludmVyc2VEeENMZXJwID0gMS4wIC0gZHhDTGVycDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlWYWwgPSBkeS5nZXQoYiwgciwgYywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wTGVmdCA9IG91dHB1dC5nZXQoYiwgdG9wRHhSSW5kZXgsIGxlZnREeENJbmRleCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BMZWZ0ICs9IGR5VmFsICogaW52ZXJzZUR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQodG9wTGVmdCwgYiwgdG9wRHhSSW5kZXgsIGxlZnREeENJbmRleCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wUmlnaHQgPSBvdXRwdXQuZ2V0KGIsIHRvcER4UkluZGV4LCByaWdodER4Q0luZGV4LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcFJpZ2h0ICs9IGR5VmFsICogaW52ZXJzZUR4UkxlcnAgKiBkeENMZXJwO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldCh0b3BSaWdodCwgYiwgdG9wRHhSSW5kZXgsIHJpZ2h0RHhDSW5kZXgsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbUxlZnQgPSBvdXRwdXQuZ2V0KGIsIGJvdHRvbUR4UkluZGV4LCBsZWZ0RHhDSW5kZXgsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tTGVmdCArPSBkeVZhbCAqIGR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQoYm90dG9tTGVmdCwgYiwgYm90dG9tRHhSSW5kZXgsIGxlZnREeENJbmRleCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSBvdXRwdXQuZ2V0KGIsIGJvdHRvbUR4UkluZGV4LCByaWdodER4Q0luZGV4LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0ICs9IGR5VmFsICogZHhSTGVycCAqIGR4Q0xlcnA7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0KGJvdHRvbVJpZ2h0LCBiLCBib3R0b21EeFJJbmRleCwgcmlnaHREeENJbmRleCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvciA9IGZ1bmN0aW9uICh4LCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdmFyIF9hID0geC5zaGFwZSwgYmF0Y2ggPSBfYVswXSwgb2xkSGVpZ2h0ID0gX2FbMV0sIG9sZFdpZHRoID0gX2FbMl0sIG51bUNoYW5uZWxzID0gX2FbM107XG4gICAgICAgIHZhciBvdXRwdXQgPSBvcHMuYnVmZmVyKFtiYXRjaCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgbnVtQ2hhbm5lbHNdLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUlucHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFtvbGRIZWlnaHQgLSAxLCBvbGRXaWR0aCAtIDFdIDogW29sZEhlaWdodCwgb2xkV2lkdGhdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3V0cHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFtuZXdIZWlnaHQgLSAxLCBuZXdXaWR0aCAtIDFdIDogW25ld0hlaWdodCwgbmV3V2lkdGhdO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoOyBiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgbmV3SGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5ld1dpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBudW1DaGFubmVsczsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY1JvdyA9IChlZmZlY3RpdmVJbnB1dFNpemVbMF0pICogciAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VGcmFjQ29sID0gKGVmZmVjdGl2ZUlucHV0U2l6ZVsxXSkgKiBjIC8gKGVmZmVjdGl2ZU91dHB1dFNpemVbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5lYXJlc3RSb3cgPSBNYXRoLm1pbihvbGRIZWlnaHQgLSAxLCBhbGlnbkNvcm5lcnMgPyBNYXRoLnJvdW5kKHNvdXJjZUZyYWNSb3cpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHNvdXJjZUZyYWNSb3cpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VOZWFyZXN0Q29sID0gTWF0aC5taW4ob2xkV2lkdGggLSAxLCBhbGlnbkNvcm5lcnMgPyBNYXRoLnJvdW5kKHNvdXJjZUZyYWNDb2wpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHNvdXJjZUZyYWNDb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHguZ2V0KGIsIHNvdXJjZU5lYXJlc3RSb3csIHNvdXJjZU5lYXJlc3RDb2wsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNldChuZXdWYWx1ZSwgYiwgciwgYywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB4VmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbWVhblZhbHVlcyA9IG1lYW4uZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHZhcmlhbmNlVmFsdWVzID0gdmFyaWFuY2UuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHNjYWxlVmFsdWVzID0gc2NhbGUgPyBzY2FsZS5kYXRhU3luYygpIDogbmV3IEZsb2F0MzJBcnJheShbMV0pO1xuICAgICAgICB2YXIgb2Zmc2V0VmFsdWVzID0gb2Zmc2V0ID8gb2Zmc2V0LmRhdGFTeW5jKCkgOiBuZXcgRmxvYXQzMkFycmF5KFswXSk7XG4gICAgICAgIHZhciBvdXRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhWYWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRWYWx1ZXNbaV0gPSBvZmZzZXRWYWx1ZXNbaSAlIG9mZnNldFZhbHVlcy5sZW5ndGhdICtcbiAgICAgICAgICAgICAgICAoeFZhbHVlc1tpXSAtIG1lYW5WYWx1ZXNbaSAlIG1lYW5WYWx1ZXMubGVuZ3RoXSkgKlxuICAgICAgICAgICAgICAgICAgICBzY2FsZVZhbHVlc1tpICUgc2NhbGVWYWx1ZXMubGVuZ3RoXSAvXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc3FydCh2YXJpYW5jZVZhbHVlc1tpICUgdmFyaWFuY2VWYWx1ZXMubGVuZ3RoXSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wc18xLnRlbnNvcjRkKG91dFZhbHVlcywgeC5zaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RCA9IGZ1bmN0aW9uICh4LCByYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBvcHMuYnVmZmVyKHguc2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHZhciByYWQgPSByYWRpdXM7XG4gICAgICAgIHZhciBtYXhEID0gb3V0cHV0LnNoYXBlWzNdIC0gMTtcbiAgICAgICAgZnVuY3Rpb24gc3VtQWNyb3NzQ2hhbm5lbHMoYiwgciwgYywgZCkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDAuMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBkIC0gcmFkKTsgaiA8PSBNYXRoLm1pbihkICsgcmFkLCBtYXhEKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHogPSB4LmdldChiLCByLCBjLCBqKTtcbiAgICAgICAgICAgICAgICBzdW0gKz0geiAqIHo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgb3V0cHV0LnNoYXBlWzBdOyBiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDw9IG91dHB1dC5zaGFwZVsxXTsgcisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvdXRwdXQuc2hhcGVbMl07IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG91dHB1dC5zaGFwZVszXTsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gc3VtQWNyb3NzQ2hhbm5lbHMoYiwgciwgYywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0geC5nZXQoYiwgciwgYywgZCkgKiBNYXRoLnBvdyhiaWFzICsgYWxwaGEgKiBzdW0sIC1iZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQodmFsLCBiLCByLCBjLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubXVsdGlub21pYWwgPSBmdW5jdGlvbiAobG9naXRzLCBub3JtYWxpemVkLCBudW1TYW1wbGVzLCBzZWVkKSB7XG4gICAgICAgIHZhciBwcm9iYWJpbGl0aWVzID0gbm9ybWFsaXplZCA/IGxvZ2l0cyA6IG9wcy5zb2Z0bWF4KGxvZ2l0cyk7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBwcm9iYWJpbGl0aWVzLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbnVtRXZlbnRzID0gcHJvYmFiaWxpdGllcy5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHJlcyA9IG9wcy56ZXJvcyhbYmF0Y2hTaXplLCBudW1TYW1wbGVzXSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciByZXNWYWxzID0gcmVzLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBwcm9iVmFscyA9IHByb2JhYmlsaXRpZXMuZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGIgKiBudW1FdmVudHM7XG4gICAgICAgICAgICB2YXIgY2RmID0gbmV3IEZsb2F0MzJBcnJheShudW1FdmVudHMgLSAxKTtcbiAgICAgICAgICAgIGNkZlswXSA9IHByb2JWYWxzW29mZnNldF07XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudF8xID0gMTsgZXZlbnRfMSA8IGNkZi5sZW5ndGg7ICsrZXZlbnRfMSkge1xuICAgICAgICAgICAgICAgIGNkZltldmVudF8xXSA9IGNkZltldmVudF8xIC0gMV0gKyBwcm9iVmFsc1tvZmZzZXQgKyBldmVudF8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByYW5kb20gPSBzZWVkcmFuZG9tLmFsZWEoc2VlZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhciBvdXRPZmZzZXQgPSBiICogbnVtU2FtcGxlcztcbiAgICAgICAgICAgIGZvciAodmFyIHNhbXBsZUlkID0gMDsgc2FtcGxlSWQgPCBudW1TYW1wbGVzOyArK3NhbXBsZUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByYW5kb20oKTtcbiAgICAgICAgICAgICAgICByZXNWYWxzW291dE9mZnNldCArIHNhbXBsZUlkXSA9IGNkZi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRfMiA9IDA7IGV2ZW50XzIgPCBjZGYubGVuZ3RoOyBldmVudF8yKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPCBjZGZbZXZlbnRfMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1ZhbHNbb3V0T2Zmc2V0ICsgc2FtcGxlSWRdID0gZXZlbnRfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUub25lSG90ID0gZnVuY3Rpb24gKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLnNpemUgKiBkZXB0aCk7XG4gICAgICAgIHJlcy5maWxsKG9mZlZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgZXZlbnRfMyA9IDA7IGV2ZW50XzMgPCBpbmRpY2VzLnNpemU7ICsrZXZlbnRfMykge1xuICAgICAgICAgICAgcmVzW2V2ZW50XzMgKiBkZXB0aCArIGluZGljZXMuZ2V0KGV2ZW50XzMpXSA9IG9uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wcy50ZW5zb3IyZChyZXMsIFtpbmRpY2VzLnNpemUsIGRlcHRoXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYnJvYWRjYXN0ZWRCaW5hcnlPcCA9IGZ1bmN0aW9uIChhLCBiLCBkdHlwZSwgb3ApIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuYnVmZmVyKG5ld1NoYXBlLCBkdHlwZSk7XG4gICAgICAgIHZhciBhVmFsdWVzID0gYS5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFCcm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhhLnNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBiQnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoYi5zaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgICB2YXIgYUJ1ZiA9IGEuYnVmZmVyKCk7XG4gICAgICAgIHZhciBiQnVmID0gYi5idWZmZXIoKTtcbiAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IHJlc3VsdC5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIGFMb2MgPSBsb2Muc2xpY2UoLWEucmFuayk7XG4gICAgICAgICAgICBhQnJvYWRjYXN0RGltcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBhTG9jW2RdID0gMDsgfSk7XG4gICAgICAgICAgICB2YXIgYUluZGV4ID0gYUJ1Zi5sb2NUb0luZGV4KGFMb2MpO1xuICAgICAgICAgICAgdmFyIGJMb2MgPSBsb2Muc2xpY2UoLWIucmFuayk7XG4gICAgICAgICAgICBiQnJvYWRjYXN0RGltcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBiTG9jW2RdID0gMDsgfSk7XG4gICAgICAgICAgICB2YXIgYkluZGV4ID0gYkJ1Zi5sb2NUb0luZGV4KGJMb2MpO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlc1tpXSA9IG9wKGFWYWx1ZXNbYUluZGV4XSwgYlZhbHVlc1tiSW5kZXhdKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBfbG9vcF8yKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBNYXRoQmFja2VuZENQVTtcbn0oKSk7XG5leHBvcnRzLk1hdGhCYWNrZW5kQ1BVID0gTWF0aEJhY2tlbmRDUFU7XG5lbnZpcm9ubWVudF8xLkVOVi5yZWdpc3RlckJhY2tlbmQoJ2NwdScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXRoQmFja2VuZENQVSgpOyB9LCAxKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmRfY3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbnZhciBhcnJheV9vcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvYXJyYXlfb3BzXCIpO1xuZnVuY3Rpb24gY2FzdFRlbnNvcih4LCBkdHlwZSwgYmFja2VuZCkge1xuICAgIGlmICghX18xLnV0aWwuaGFzRW5jb2RpbmdMb3NzKHguZHR5cGUsIGR0eXBlKSkge1xuICAgICAgICByZXR1cm4gX18xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgZGF0YUlkOiB4LmRhdGFJZCB9LCBkdHlwZSk7XG4gICAgfVxuICAgIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gYmFja2VuZC5pbnQoeCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQubm90RXF1YWwoeCwgYXJyYXlfb3BzXzEuQXJyYXlPcHMuc2NhbGFyKDAsIHguZHR5cGUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIENhc3Q6IHVua25vd24gZHR5cGUgYXJndW1lbnQgKFwiICsgZHR5cGUgKyBcIilcIik7XG4gICAgfVxufVxuZXhwb3J0cy5jYXN0VGVuc29yID0gY2FzdFRlbnNvcjtcbmZ1bmN0aW9uIHJlc2hhcGVUZW5zb3IoeCwgc2hhcGUpIHtcbiAgICByZXR1cm4gX18xLlRlbnNvci5tYWtlKHNoYXBlLCB7IGRhdGFJZDogeC5kYXRhSWQgfSwgeC5kdHlwZSk7XG59XG5leHBvcnRzLnJlc2hhcGVUZW5zb3IgPSByZXNoYXBlVGVuc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi4vb3BzL2F4aXNfdXRpbFwiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciByZWR1Y2VfdXRpbCA9IHJlcXVpcmUoXCIuLi9vcHMvcmVkdWNlX3V0aWxcIik7XG52YXIgc2xpY2VfdXRpbF8xID0gcmVxdWlyZShcIi4uL29wcy9zbGljZV91dGlsXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYmFja2VuZF91dGlsID0gcmVxdWlyZShcIi4vYmFja2VuZF91dGlsXCIpO1xudmFyIGFyZ21pbm1heF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2FyZ21pbm1heF9ncHVcIik7XG52YXIgYXZnX3Bvb2xfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9hdmdfcG9vbF9iYWNrcHJvcF9ncHVcIik7XG52YXIgYmF0Y2hub3JtX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYmF0Y2hub3JtX2dwdVwiKTtcbnZhciBiaW5hcnlvcF9ncHUgPSByZXF1aXJlKFwiLi93ZWJnbC9iaW5hcnlvcF9ncHVcIik7XG52YXIgYmluYXJ5b3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9iaW5hcnlvcF9ncHVcIik7XG52YXIgY2xpcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NsaXBfZ3B1XCIpO1xudmFyIGNvbmNhdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbmNhdF9ncHVcIik7XG52YXIgY29udl9iYWNrcHJvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbnZfYmFja3Byb3BfZ3B1XCIpO1xudmFyIGNvbnZfYmFja3Byb3BfZ3B1X2RlcHRod2lzZV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29udl9iYWNrcHJvcF9ncHVfZGVwdGh3aXNlXCIpO1xudmFyIGNvbnZfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2dwdVwiKTtcbnZhciBjb252X2dwdV9kZXB0aHdpc2VfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZVwiKTtcbnZhciBjdW1zdW1fZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jdW1zdW1fZ3B1XCIpO1xudmFyIGZyb21fcGl4ZWxzX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvZnJvbV9waXhlbHNfZ3B1XCIpO1xudmFyIGdhdGhlcl9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2dhdGhlcl9ncHVcIik7XG52YXIgZ3BncHVfY29udGV4dF8xID0gcmVxdWlyZShcIi4vd2ViZ2wvZ3BncHVfY29udGV4dFwiKTtcbnZhciBncGdwdV9tYXRoID0gcmVxdWlyZShcIi4vd2ViZ2wvZ3BncHVfbWF0aFwiKTtcbnZhciBncGdwdV91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2wvZ3BncHVfdXRpbFwiKTtcbnZhciBsb2dpY2FsX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbG9naWNhbF9ncHVcIik7XG52YXIgbHJuX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbHJuX2dwdVwiKTtcbnZhciBtYXhfcG9vbF9iYWNrcHJvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL21heF9wb29sX2JhY2twcm9wX2dwdVwiKTtcbnZhciBtdWxtYXRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9tdWxtYXRfZ3B1XCIpO1xudmFyIG11bHRpbm9taWFsX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbXVsdGlub21pYWxfZ3B1XCIpO1xudmFyIG9uZWhvdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL29uZWhvdF9ncHVcIik7XG52YXIgcGFkX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcGFkX2dwdVwiKTtcbnZhciBwb29sX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcG9vbF9ncHVcIik7XG52YXIgcmVkdWNlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcmVkdWNlX2dwdVwiKTtcbnZhciByZXNpemVfYmlsaW5lYXJfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZXNpemVfYmlsaW5lYXJfYmFja3Byb3BfZ3B1XCIpO1xudmFyIHJlc2l6ZV9iaWxpbmVhcl9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHVcIik7XG52YXIgcmVzaXplX25lYXJlc3RfbmVpZ2hib3JfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZXNpemVfbmVhcmVzdF9uZWlnaGJvcl9ncHVcIik7XG52YXIgcmV2ZXJzZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3JldmVyc2VfZ3B1XCIpO1xudmFyIHNsaWNlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvc2xpY2VfZ3B1XCIpO1xudmFyIHN0cmlkZWRfc2xpY2VfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9zdHJpZGVkX3NsaWNlX2dwdVwiKTtcbnZhciB0ZXhfdXRpbF8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdGV4X3V0aWxcIik7XG52YXIgdGV4dHVyZV9tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi93ZWJnbC90ZXh0dXJlX21hbmFnZXJcIik7XG52YXIgdGlsZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RpbGVfZ3B1XCIpO1xudmFyIHRyYW5zcG9zZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RyYW5zcG9zZV9ncHVcIik7XG52YXIgdW5hcnlfb3AgPSByZXF1aXJlKFwiLi93ZWJnbC91bmFyeW9wX2dwdVwiKTtcbnZhciB1bmFyeW9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdW5hcnlvcF9ncHVcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsL3dlYmdsX3V0aWxcIik7XG52YXIgQkVGT1JFX1BBR0lOR19DT05TVEFOVCA9IDMwMDtcbnZhciBNYXRoQmFja2VuZFdlYkdMID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRoQmFja2VuZFdlYkdMKGdwZ3B1LCBkZWxheWVkU3RvcmFnZSkge1xuICAgICAgICBpZiAoZGVsYXllZFN0b3JhZ2UgPT09IHZvaWQgMCkgeyBkZWxheWVkU3RvcmFnZSA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5ncGdwdSA9IGdwZ3B1O1xuICAgICAgICB0aGlzLmRlbGF5ZWRTdG9yYWdlID0gZGVsYXllZFN0b3JhZ2U7XG4gICAgICAgIHRoaXMudGV4RGF0YSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlYWQgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaXNwb3NhbCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgIHRoaXMubHJ1RGF0YUdQVSA9IFtdO1xuICAgICAgICB0aGlzLm51bUJ5dGVzSW5HUFUgPSAwO1xuICAgICAgICB0aGlzLnVwbG9hZFdhaXRNcyA9IDA7XG4gICAgICAgIHRoaXMuZG93bmxvYWRXYWl0TXMgPSAwO1xuICAgICAgICB0aGlzLmJpbmFyeUNhY2hlID0ge307XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncGdwdSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1ID0gbmV3IGdwZ3B1X2NvbnRleHRfMS5HUEdQVUNvbnRleHQoZ3BncHVfdXRpbC5jcmVhdGVXZWJHTENvbnRleHQodGhpcy5jYW52YXMpKTtcbiAgICAgICAgICAgIHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLk5VTV9CWVRFU19CRUZPUkVfUEFHSU5HID1cbiAgICAgICAgICAgICh3aW5kb3cuc2NyZWVuLmhlaWdodCAqIHdpbmRvdy5zY3JlZW4ud2lkdGggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgKlxuICAgICAgICAgICAgICAgIEJFRk9SRV9QQUdJTkdfQ09OU1RBTlQ7XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgdGV4dHVyZV9tYW5hZ2VyXzEuVGV4dHVyZU1hbmFnZXIodGhpcy5ncGdwdSk7XG4gICAgfVxuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRhdGFJZCwgc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnRleERhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXhEYXRhLnNldChkYXRhSWQsIHtcbiAgICAgICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgICAgIGR0eXBlOiBkdHlwZSxcbiAgICAgICAgICAgIHZhbHVlczogbnVsbCxcbiAgICAgICAgICAgIHRleHR1cmU6IG51bGwsXG4gICAgICAgICAgICB0ZXhTaGFwZTogbnVsbCxcbiAgICAgICAgICAgIHRleFR5cGU6IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuRkxPQVRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5mcm9tUGl4ZWxzID0gZnVuY3Rpb24gKHBpeGVscywgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKHBpeGVscyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGhCYWNrZW5kV2ViR0wud3JpdGVQaXhlbHMoKTogcGl4ZWxzIGNhbiBub3QgYmUgbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXhTaGFwZSA9IFtwaXhlbHMuaGVpZ2h0LCBwaXhlbHMud2lkdGhdO1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBbcGl4ZWxzLmhlaWdodCwgcGl4ZWxzLndpZHRoLCBudW1DaGFubmVsc107XG4gICAgICAgIGlmIChwaXhlbHMgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tUGl4ZWxzQ2FudmFzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnSVNfQlJPV1NFUicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCByZWFkIHBpeGVscyBmcm9tIEhUTUxJbWFnZUVsZW1lbnQgb3V0c2lkZSB0aGUgYnJvd3Nlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgRE9NIGlzIG5vdCByZWFkeSB5ZXQuIFBsZWFzZSBjYWxsIHRmLmZyb21QaXhlbHMoKSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvbmNlIHRoZSBET00gaXMgcmVhZHkuIE9uZSB3YXkgdG8gZG8gdGhhdCBpcyB0byBhZGQgYW4gZXZlbnQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdGVuZXIgZm9yIGBET01Db250ZW50TG9hZGVkYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVBpeGVsc0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcm9tUGl4ZWxzQ2FudmFzLndpZHRoID0gcGl4ZWxzLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5mcm9tUGl4ZWxzQ2FudmFzLmhlaWdodCA9IHBpeGVscy5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmZyb21QaXhlbHNDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UocGl4ZWxzLCAwLCAwLCBwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHQpO1xuICAgICAgICAgICAgcGl4ZWxzID0gdGhpcy5mcm9tUGl4ZWxzQ2FudmFzO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wUGl4ZWxBcnJheSA9IHRlbnNvcl8xLlRlbnNvci5tYWtlKHRleFNoYXBlLCB7fSwgJ2ludDMyJyk7XG4gICAgICAgIHRoaXMudGV4RGF0YS5nZXQodGVtcFBpeGVsQXJyYXkuZGF0YUlkKS50ZXhUeXBlID0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5VTlNJR05FRF9CWVRFO1xuICAgICAgICB0aGlzLmdwZ3B1LnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0aGlzLmdldFRleHR1cmUodGVtcFBpeGVsQXJyYXkuZGF0YUlkKSwgcGl4ZWxzKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgZnJvbV9waXhlbHNfZ3B1XzEuRnJvbVBpeGVsc1Byb2dyYW0ob3V0U2hhcGUpO1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt0ZW1wUGl4ZWxBcnJheV0pO1xuICAgICAgICB0ZW1wUGl4ZWxBcnJheS5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhSWQsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0aEJhY2tlbmRXZWJHTC53cml0ZSgpOiB2YWx1ZXMgY2FuIG5vdCBiZSBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgIHZhciB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRleERhdGEudGV4dHVyZSwgdGV4U2hhcGUgPSB0ZXhEYXRhLnRleFNoYXBlLCB0ZXhUeXBlID0gdGV4RGF0YS50ZXhUeXBlO1xuICAgICAgICBpZiAodGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VUZXh0dXJlKGRhdGFJZCwgdGV4dHVyZSwgdGV4U2hhcGUsIHRleFR5cGUpO1xuICAgICAgICAgICAgdGV4RGF0YS50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgIHRleERhdGEudGV4U2hhcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRleERhdGEudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkVG9HUFUoZGF0YUlkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVhZFN5bmMgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YShkYXRhSWQpO1xuICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0ZXhEYXRhLnRleHR1cmUsIHZhbHVlcyA9IHRleERhdGEudmFsdWVzLCB0ZXhTaGFwZSA9IHRleERhdGEudGV4U2hhcGU7XG4gICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZU9uQ1BVKGRhdGFJZCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRUaW1lUHJvZ3JhbSA9IHRoaXMuYWN0aXZlVGltZXJzICE9IG51bGw7XG4gICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbG9hdDMyVmFsdWVzID0gdGhpcy5ncGdwdS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlKHRleHR1cmUsIHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSk7XG4gICAgICAgIGlmIChzaG91bGRUaW1lUHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5kb3dubG9hZFdhaXRNcyArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVPbkNQVShkYXRhSWQsIGZsb2F0MzJWYWx1ZXMpO1xuICAgICAgICByZXR1cm4gdGV4RGF0YS52YWx1ZXM7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaWJlcnNfMSwgdGV4RGF0YSwgdGV4dHVyZSwgdmFsdWVzLCB0ZXhTaGFwZSwgZmxvYXQzMlZhbHVlcywgc3Vic2NyaWJlcnMsIHZhbHM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmVhZC5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzXzEgPSB0aGlzLnBlbmRpbmdSZWFkLmdldChkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHN1YnNjcmliZXJzXzEucHVzaChyZXNvbHZlKTsgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IHRleERhdGEudGV4dHVyZSwgdmFsdWVzID0gdGV4RGF0YS52YWx1ZXMsIHRleFNoYXBlID0gdGV4RGF0YS50ZXhTaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVPbkNQVShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZ3BncHUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZUFzeW5jKHRleHR1cmUsIHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdDMyVmFsdWVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZU9uQ1BVKGRhdGFJZCwgZmxvYXQzMlZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRleERhdGEudmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZWFkU3luYyhkYXRhSWQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlYWQuc2V0KGRhdGFJZCwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmdwZ3B1LnJ1blF1ZXJ5KGZ1bmN0aW9uICgpIHsgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVycyA9IHRoaXMucGVuZGluZ1JlYWQuZ2V0KGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZWFkLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFscyA9IHRoaXMucmVhZFN5bmMoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHJlc29sdmUodmFscyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGlzcG9zYWwuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlRGF0YShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB2YWxzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9sZEFjdGl2ZVRpbWVycywgbmV3QWN0aXZlVGltZXJzLCBvdXRlck1vc3RUaW1lLCBmbGF0dGVuZWRBY3RpdmVUaW1lcnMsIGtlcm5lbE1zLCByZXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRBY3RpdmVUaW1lcnMgPSB0aGlzLmFjdGl2ZVRpbWVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FjdGl2ZVRpbWVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJNb3N0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2dyYW1UaW1lcnNTdGFjayA9IG5ld0FjdGl2ZVRpbWVycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlck1vc3RUaW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGltZXJzLnB1c2gobmV3QWN0aXZlVGltZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGltZXJzID0gbmV3QWN0aXZlVGltZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlbmVkQWN0aXZlVGltZXJzID0gdXRpbC5mbGF0dGVuKHRoaXMuYWN0aXZlVGltZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGltZXJzID0gb2xkQWN0aXZlVGltZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVyTW9zdFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2dyYW1UaW1lcnNTdGFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIFByb21pc2UuYWxsKGZsYXR0ZW5lZEFjdGl2ZVRpbWVycykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHN1bSArPSByZXN1bHQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAga2VybmVsTXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkV2FpdE1zOiB0aGlzLnVwbG9hZFdhaXRNcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFdhaXRNczogdGhpcy5kb3dubG9hZFdhaXRNcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXJuZWxNczoga2VybmVsTXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsbE1zOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGxvYWRXYWl0TXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3dubG9hZFdhaXRNcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWVtb3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyB1bnJlbGlhYmxlOiBmYWxzZSwgbnVtQnl0ZXNJbkdQVTogdGhpcy5udW1CeXRlc0luR1BVIH07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zdGFydFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3BncHUuYmVnaW5RdWVyeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0TXM6IHBlcmZvcm1hbmNlLm5vdygpLCBlbmRNczogbnVsbCB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZW5kVGltZXIgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUuZW5kUXVlcnkoKTtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBxdWVyeS5lbmRNcyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRRdWVyeVRpbWUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpbWVyUXVlcnk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdwZ3B1LnBvbGxRdWVyeVRpbWUocXVlcnkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZXJRdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGltZXJRdWVyeS5lbmRNcyAtIHRpbWVyUXVlcnkuc3RhcnRNc107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5kaXNwb3NlRGF0YSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1JlYWQuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmFkZChkYXRhSWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRleERhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKSwgdGV4dHVyZSA9IF9hLnRleHR1cmUsIHRleFNoYXBlID0gX2EudGV4U2hhcGUsIHRleFR5cGUgPSBfYS50ZXhUeXBlO1xuICAgICAgICAgICAgaWYgKHRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZVRleHR1cmUoZGF0YUlkLCB0ZXh0dXJlLCB0ZXhTaGFwZSwgdGV4VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleERhdGEuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHRoaXMudXBsb2FkVG9HUFUoZGF0YUlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKS50ZXh0dXJlO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0R1BHUFVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncGdwdTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldENhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgc2xpY2VfZ3B1XzEuU2xpY2VQcm9ncmFtKHNpemUpO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhiZWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBudWxsLCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zdHJpZGVkU2xpY2UgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIGVuZCwgc3RyaWRlcywgYmVnaW5NYXNrLCBlbmRNYXNrKSB7XG4gICAgICAgIHZhciBfYSA9IHNsaWNlX3V0aWxfMS5nZXRTdHJpZGVkU2xpY2VkSW5mbyh4LnNoYXBlLCBiZWdpbiwgZW5kLCBzdHJpZGVzLCBiZWdpbk1hc2ssIGVuZE1hc2spLCBiZWdpbkluZGV4ID0gX2FbMF0sIHNpemUgPSBfYVsxXTtcbiAgICAgICAgaWYgKHNpemUuc29tZShmdW5jdGlvbiAoYXhpcykgeyByZXR1cm4gYXhpcyA9PT0gMDsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHMudGVuc29yKFtdLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBzdHJpZGVkX3NsaWNlX2dwdV8xLlN0cmlkZWRTbGljZVByb2dyYW0oYmVnaW5JbmRleCwgc3RyaWRlcywgc2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZXZlcnNlX2dwdV8xLlJldmVyc2VQcm9ncmFtKHguc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb25jYXRfZ3B1XzEuQ29uY2F0UHJvZ3JhbShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5ORUcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tYXRNdWwgPSBmdW5jdGlvbiAoYSwgYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBtdWxtYXRfZ3B1XzEuTWF0TXVsUHJvZ3JhbShhLnNoYXBlLCBiLnNoYXBlLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1Lk1VTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgaW5wdXRzID0gW3gsIG1lYW4sIHZhcmlhbmNlXTtcbiAgICAgICAgdmFyIG9mZnNldFNoYXBlID0gbnVsbDtcbiAgICAgICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvZmZzZXRTaGFwZSA9IG9mZnNldC5zaGFwZTtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjYWxlU2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2NhbGVTaGFwZSA9IHNjYWxlLnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2goc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJhdGNobm9ybV9ncHVfMS5CYXRjaE5vcm1Qcm9ncmFtKHguc2hhcGUsIG1lYW4uc2hhcGUsIHZhcmlhbmNlLnNoYXBlLCBvZmZzZXRTaGFwZSwgc2NhbGVTaGFwZSwgdmFyaWFuY2VFcHNpbG9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBpbnB1dHMpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RCA9IGZ1bmN0aW9uICh4LCByYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGxybl9ncHVfMS5MUk5Qcm9ncmFtKHguc2hhcGUsIHJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50aWxlID0gZnVuY3Rpb24gKHgsIHJlcHMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdGlsZV9ncHVfMS5UaWxlUHJvZ3JhbSh4LnNoYXBlLCByZXBzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucGFkID0gZnVuY3Rpb24gKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHBhZF9ncHVfMS5QYWRQcm9ncmFtKHguc2hhcGUsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gKHgsIHBlcm0pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdHJhbnNwb3NlX2dwdV8xLlRyYW5zcG9zZVByb2dyYW0oeC5zaGFwZSwgcGVybSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdhdGhlciA9IGZ1bmN0aW9uICh4LCBpbmRpY2VzLCBheGlzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGdhdGhlcl9ncHVfMS5HYXRoZXJQcm9ncmFtKHguc2hhcGUsIGluZGljZXMuc2l6ZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3gsIGluZGljZXNdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uICh4LCByZWR1Y2VUeXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0geC5zaGFwZVswXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHguc2hhcGVbMV07XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlX3V0aWwuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGluU2l6ZSk7XG4gICAgICAgIHZhciByZWR1Y2VJbmZvID0geyB3aW5kb3dTaXplOiB3aW5kb3dTaXplLCBpblNpemU6IGluU2l6ZSwgYmF0Y2hTaXplOiBiYXRjaFNpemUgfTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcmVkdWNlX2dwdV8xLlJlZHVjZVByb2dyYW0ocmVkdWNlSW5mbywgcmVkdWNlVHlwZSk7XG4gICAgICAgIHZhciBfYSA9IHByb2dyYW0ub3V0cHV0U2hhcGUsIHJvd3MgPSBfYVswXSwgY29scyA9IF9hWzFdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkoW3Jvd3MsIGNvbHNdLCBkdHlwZSk7XG4gICAgICAgIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIG91dHB1dCk7XG4gICAgICAgIGlmIChvdXRwdXQuc2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKG91dHB1dCwgcmVkdWNlVHlwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXJnUmVkdWNlID0gZnVuY3Rpb24gKHgsIHJlZHVjZVR5cGUsIGJlc3RJbmRpY2VzQSkge1xuICAgICAgICBpZiAoYmVzdEluZGljZXNBID09PSB2b2lkIDApIHsgYmVzdEluZGljZXNBID0gbnVsbDsgfVxuICAgICAgICB2YXIgYmF0Y2hTaXplID0geC5zaGFwZVswXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHguc2hhcGVbMV07XG4gICAgICAgIGlmIChiZXN0SW5kaWNlc0EgIT0gbnVsbCkge1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gYmVzdEluZGljZXNBLnNoYXBlWzBdO1xuICAgICAgICAgICAgaW5TaXplID0gYmVzdEluZGljZXNBLnNoYXBlWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlX3V0aWwuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKGluU2l6ZSk7XG4gICAgICAgIHZhciByZWR1Y2VJbmZvID0geyB3aW5kb3dTaXplOiB3aW5kb3dTaXplLCBpblNpemU6IGluU2l6ZSwgYmF0Y2hTaXplOiBiYXRjaFNpemUgfTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYXJnbWlubWF4X2dwdV8xLkFyZ01pbk1heFByb2dyYW0ocmVkdWNlSW5mbywgcmVkdWNlVHlwZSwgYmVzdEluZGljZXNBID09IG51bGwpO1xuICAgICAgICB2YXIgX2EgPSBwcm9ncmFtLm91dHB1dFNoYXBlLCByb3dzID0gX2FbMF0sIGNvbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KFtyb3dzLCBjb2xzXSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbeF07XG4gICAgICAgIGlmIChiZXN0SW5kaWNlc0EgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXRzLnB1c2goYmVzdEluZGljZXNBKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpO1xuICAgICAgICBpZiAob3V0cHV0LnNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ1JlZHVjZSh4LCByZWR1Y2VUeXBlLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSB4LmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHZhciBvdXRwdXREVHlwZSA9IHR5cGVzLnN1bU91dFR5cGUoeC5kdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShhMkQsICdzdW0nLCBvdXRwdXREVHlwZSkucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hcmdNaW4gPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB2YXIgYXhlcyA9IFtheGlzXTtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNaW4nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSB4LmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ1JlZHVjZShhMkQsICdtaW4nKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFyZ01heCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHZhciBheGVzID0gW2F4aXNdO1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01heCcsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IHguYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJnUmVkdWNlKGEyRCwgJ21heCcpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY3Vtc3VtID0gZnVuY3Rpb24gKHgsIGF4aXMsIGV4Y2x1c2l2ZSwgcmV2ZXJzZSkge1xuICAgICAgICBpZiAoYXhpcyAhPT0geC5yYW5rIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgY3Vtc3VtIHNoYWRlciBleHBlY3RzIGFuIGlubmVyLW1vc3QgYXhpcz1cIiArICh4LnJhbmsgLSAxKSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IGF4aXM9XCIgKyBheGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY3Vtc3VtX2dwdV8xLkN1bVN1bVByb2dyYW0oeC5zaGFwZSwgZXhjbHVzaXZlLCByZXZlcnNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkVRVUFMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubm90RXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1Lk5PVF9FUVVBTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkxFU1MsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sZXNzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkxFU1NfRVFVQUwsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5ncmVhdGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5HUkVBVEVSLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5HUkVBVEVSX0VRVUFMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubG9naWNhbE5vdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuTE9HSUNBTF9OT1QpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sb2dpY2FsQW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5MT0dJQ0FMX0FORCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvZ2ljYWxPciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTE9HSUNBTF9PUiwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgYSwgYiwgZHR5cGUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbG9naWNhbF9ncHVfMS5XaGVyZVByb2dyYW0oY29uZGl0aW9uLnJhbmssIGEuc2hhcGUsIGEucmFuayk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCBkdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2NvbmRpdGlvbiwgYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50b3BLVmFsdWVzID0gZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b3BLVmFsdWVzIEdQVSBub3QgeWV0IGltcGxlbWVudGVkIScpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudG9wS0luZGljZXMgPSBmdW5jdGlvbiAoeCwgaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvcEtJbmRpY2VzIEdQVSBub3QgeWV0IGltcGxlbWVudGVkIScpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtaW4nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSB4LmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShhMkQsICdtaW4nLCBhMkQuZHR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWluaW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTUlOLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5NT0QsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21heCcsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IHguYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGEyRCwgJ21heCcsIGEyRC5kdHlwZSkucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tYXhpbXVtID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5NQVgsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuU1FVQVJFRF9ESUZGRVJFTkNFLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVhbERpdmlkZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBvcCA9IGJpbmFyeW9wX2dwdS5ESVY7XG4gICAgICAgIHZhciBvdXRwdXREdHlwZSA9ICdmbG9hdDMyJztcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKG9wLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIG91dHB1dER0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5mbG9vckRpdiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBvcCA9IGJpbmFyeW9wX2dwdS5JTlRfRElWO1xuICAgICAgICB2YXIgb3V0cHV0RHR5cGUgPSAnaW50MzInO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0ob3AsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgb3V0cHV0RHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuQURELCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5TVUIsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5QT1csIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQ0VJTCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5GTE9PUik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNJR04pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuUk9VTkQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkVYUCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmV4cG0xID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5FWFBNMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuTE9HKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubG9nMXAgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkxPRzFQKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU1FSVCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJzcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5SU1FSVCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU1FVQVJFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVjaXByb2NhbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuUkVDSVBST0NBTCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlJFTFUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5lbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkVMVSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmVsdURlciA9IGZ1bmN0aW9uIChkeSwgeSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkVMVV9ERVIsIGR5LnNoYXBlLCB5LnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZHksIHldKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNFTFUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5pbnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlRPX0lOVCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnaW50MzInKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKHgsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNsaXBfZ3B1XzEuQ2xpcFByb2dyYW0oeC5zaGFwZSwgbWluLCBtYXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFCUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnNpZ21vaWQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNJR01PSUQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zb2Z0cGx1cyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU09GVFBMVVMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zaW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNJTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQ09TKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUudGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5UQU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hc2luID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5BU0lOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYWNvcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQUNPUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmF0YW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFUQU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdGFuMiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuQVRBTjIsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zaW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TSU5IKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29zaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQ09TSCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlRBTkgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hc2luaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQVNJTkgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hY29zaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQUNPU0gpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdGFuaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQVRBTkgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5lcmYgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkVSRik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TVEVQKGFscGhhKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfZ3B1XzEuQ29udjJEUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3gsIGZpbHRlcl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29udjJkRGVySW5wdXQgPSBmdW5jdGlvbiAoZHksIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9iYWNrcHJvcF9ncHVfMS5Db252MkREZXJJbnB1dFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtkeSwgZmlsdGVyXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXIgPSBmdW5jdGlvbiAoeCwgZHksIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfYmFja3Byb3BfZ3B1XzEuQ29udjJERGVyRmlsdGVyUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3gsIGR5XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2dwdV9kZXB0aHdpc2VfMS5EZXB0aHdpc2VDb252MkRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeCwgZmlsdGVyXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dCA9IGZ1bmN0aW9uIChkeSwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV9kZXB0aHdpc2VfMS5EZXB0aHdpc2VDb252MkREZXJJbnB1dFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtkeSwgZmlsdGVyXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXIgPSBmdW5jdGlvbiAoeCwgZHksIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfYmFja3Byb3BfZ3B1X2RlcHRod2lzZV8xLkRlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBkeV0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdtYXgnLCBmYWxzZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdmdQb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ2F2ZycsIGZhbHNlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCB5LCBjb252SW5mbykge1xuICAgICAgICB2YXIgZ2V0UG9zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21heCcsIGdldFBvc2l0aW9ucyk7XG4gICAgICAgIHZhciBtYXhQb29sUG9zaXRpb25zID0gdGhpcy5jb21waWxlQW5kUnVuKG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtLCBbeF0pO1xuICAgICAgICB2YXIgbWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSA9IG5ldyBtYXhfcG9vbF9iYWNrcHJvcF9ncHVfMS5NYXhQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkobWF4UG9vbEJhY2tQcm9wUHJvZ3JhbS5vdXRwdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbXBpbGVBbmRSdW4obWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSwgW2R5LCBtYXhQb29sUG9zaXRpb25zXSwgb3V0cHV0KTtcbiAgICAgICAgbWF4UG9vbFBvc2l0aW9ucy5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBhdmdQb29sQmFja3Byb3BQcm9ncmFtID0gbmV3IGF2Z19wb29sX2JhY2twcm9wX2dwdV8xLkF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShhdmdQb29sQmFja3Byb3BQcm9ncmFtLm91dHB1dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhdmdQb29sQmFja3Byb3BQcm9ncmFtLCBbZHldLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uICh4LCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gYmFja2VuZF91dGlsLmNhc3RUZW5zb3IoeCwgZHR5cGUsIHRoaXMpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uICh4LCBzaGFwZSkge1xuICAgICAgICByZXR1cm4gYmFja2VuZF91dGlsLnJlc2hhcGVUZW5zb3IoeCwgc2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIgPSBmdW5jdGlvbiAoeCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlc2l6ZV9iaWxpbmVhcl9ncHVfMS5SZXNpemVCaWxpbmVhclByb2dyYW0oeC5zaGFwZSwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgeCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlc2l6ZV9iaWxpbmVhcl9iYWNrcHJvcF9ncHVfMS5SZXNpemVCaWxpbmVhckJhY2twcm9wUHJvZ3JhbShkeSwgeCwgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZHldKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvciA9IGZ1bmN0aW9uICh4LCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcmVzaXplX25lYXJlc3RfbmVpZ2hib3JfZ3B1XzEuUmVzaXplTmVhcmVzdE5laWdoYm9yUHJvZ3JhbSh4LnNoYXBlLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tdWx0aW5vbWlhbCA9IGZ1bmN0aW9uIChsb2dpdHMsIG5vcm1hbGl6ZWQsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIHByb2JzID0gbm9ybWFsaXplZCA/IGxvZ2l0cyA6IG9wcy5zb2Z0bWF4KGxvZ2l0cyk7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBwcm9icy5zaGFwZVswXTtcbiAgICAgICAgdmFyIG51bU91dGNvbWVzID0gcHJvYnMuc2hhcGVbMV07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IG11bHRpbm9taWFsX2dwdV8xLk11bHRpbm9taWFsUHJvZ3JhbShiYXRjaFNpemUsIG51bU91dGNvbWVzLCBudW1TYW1wbGVzKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhzZWVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbcHJvYnNdLCBvdXRwdXQsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm9uZUhvdCA9IGZ1bmN0aW9uIChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgb25laG90X2dwdV8xLk9uZUhvdFByb2dyYW0oaW5kaWNlcy5zaXplLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbmRpY2VzXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tYWtlT3V0cHV0QXJyYXkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwge30sIGR0eXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvbXBpbGVBbmRSdW4gPSBmdW5jdGlvbiAocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQsIGN1c3RvbVNldHVwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvdXRwdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgaW5wdXRzWzBdLmR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRzRGF0YSA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBfdGhpcy51cGxvYWRUb0dQVShpbnB1dC5kYXRhSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdGVuc29yOiBpbnB1dCwgdGV4RGF0YTogX3RoaXMudGV4RGF0YS5nZXQoaW5wdXQuZGF0YUlkKSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGxvYWRUb0dQVShvdXRwdXQuZGF0YUlkKTtcbiAgICAgICAgdmFyIG91dHB1dERhdGEgPSB7XG4gICAgICAgICAgICB0ZW5zb3I6IG91dHB1dCxcbiAgICAgICAgICAgIHRleERhdGE6IHRoaXMudGV4RGF0YS5nZXQob3V0cHV0LmRhdGFJZClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGtleSA9IGdwZ3B1X21hdGgubWFrZVNoYWRlcktleShwcm9ncmFtLCBpbnB1dHNEYXRhLCBvdXRwdXREYXRhKTtcbiAgICAgICAgdmFyIGJpbmFyeSA9IHRoaXMuZ2V0QW5kU2F2ZUJpbmFyeShrZXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBncGdwdV9tYXRoLmNvbXBpbGVQcm9ncmFtKF90aGlzLmdwZ3B1LCBwcm9ncmFtLCBpbnB1dHNEYXRhLCBvdXRwdXREYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzaG91bGRUaW1lUHJvZ3JhbSA9IHRoaXMuYWN0aXZlVGltZXJzICE9IG51bGw7XG4gICAgICAgIHZhciBxdWVyeTtcbiAgICAgICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuc3RhcnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGdwZ3B1X21hdGgucnVuUHJvZ3JhbShiaW5hcnksIGlucHV0c0RhdGEsIG91dHB1dERhdGEsIGN1c3RvbVNldHVwKTtcbiAgICAgICAgaWYgKHRoaXMubnVtQnl0ZXNJbkdQVSA+IHRoaXMuTlVNX0JZVEVTX0JFRk9SRV9QQUdJTkcpIHtcbiAgICAgICAgICAgIHZhciBudW1CeXRlc1RvUGFnZSA9IHRoaXMubnVtQnl0ZXNJbkdQVSAtIHRoaXMuTlVNX0JZVEVTX0JFRk9SRV9QQUdJTkc7XG4gICAgICAgICAgICB3aGlsZSAobnVtQnl0ZXNUb1BhZ2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJZCA9IHRoaXMubHJ1RGF0YUdQVS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKSwgc2hhcGUgPSBfYS5zaGFwZSwgZHR5cGUgPSBfYS5kdHlwZTtcbiAgICAgICAgICAgICAgICBudW1CeXRlc1RvUGFnZSAtPSB0aGlzLmNvbXB1dGVCeXRlcyhzaGFwZSwgZHR5cGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZChkYXRhSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRUaW1lUHJvZ3JhbSkge1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmVuZFRpbWVyKHF1ZXJ5KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVGltZXJzLnB1c2godGhpcy5nZXRRdWVyeVRpbWUocXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0QW5kU2F2ZUJpbmFyeSA9IGZ1bmN0aW9uIChrZXksIGdldEJpbmFyeSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5Q2FjaGVba2V5XSA9IGdldEJpbmFyeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeUNhY2hlW2tleV07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRUZXh0dXJlTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXI7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmJpbmFyeUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LmRlbGV0ZVByb2dyYW0odGhpcy5iaW5hcnlDYWNoZVtrZXldLndlYkdMUHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5mcm9tUGl4ZWxzQ2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVBpeGVsc0NhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5KSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRocm93SWZOb0RhdGEgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXhEYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBiYWNrZW5kOiBObyBkYXRhIGZvdW5kIGZvciB0aGlzIHRlbnNvci4gXCIgK1xuICAgICAgICAgICAgICAgIFwiRGlkIHlvdSBjaGFuZ2UgeW91ciBiYWNrZW5kIGluIHRoZSBtaWRkbGUgb2YgdGhlIHByb2dyYW0/IFwiICtcbiAgICAgICAgICAgICAgICBcIk5ldyBiYWNrZW5kcyBjYW4ndCB1c2UgVGVuc29ycyBjcmVhdGVkIHdpdGggcHJldmlvdXMgYmFja2VuZHNcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnVwbG9hZFRvR1BVID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB0aGlzLnRocm93SWZOb0RhdGEoZGF0YUlkKTtcbiAgICAgICAgdmFyIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICAgIHZhciBzaGFwZSA9IHRleERhdGEuc2hhcGUsIHZhbHVlcyA9IHRleERhdGEudmFsdWVzLCB0ZXh0dXJlID0gdGV4RGF0YS50ZXh0dXJlLCBkdHlwZSA9IHRleERhdGEuZHR5cGUsIHRleFR5cGUgPSB0ZXhEYXRhLnRleFR5cGU7XG4gICAgICAgIGlmICh0ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubHJ1RGF0YUdQVS5zcGxpY2UodGhpcy5scnVEYXRhR1BVLmluZGV4T2YoZGF0YUlkKSwgMSk7XG4gICAgICAgICAgICB0aGlzLmxydURhdGFHUFUucHVzaChkYXRhSWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRUaW1lUHJvZ3JhbSA9IHRoaXMuYWN0aXZlVGltZXJzICE9IG51bGw7XG4gICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXhTaGFwZSA9IHdlYmdsX3V0aWwuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSh0aGlzLmdwZ3B1LmdsLCBzaGFwZSk7XG4gICAgICAgIHRleERhdGEudGV4U2hhcGUgPSB0ZXhTaGFwZTtcbiAgICAgICAgdmFyIG5ld1RleHR1cmUgPSB0aGlzLmFjcXVpcmVUZXh0dXJlKGRhdGFJZCwgdGV4U2hhcGUsIHRleFR5cGUpO1xuICAgICAgICB0ZXhEYXRhLnRleHR1cmUgPSBuZXdUZXh0dXJlO1xuICAgICAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUudXBsb2FkTWF0cml4VG9UZXh0dXJlKG5ld1RleHR1cmUsIHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSwgdHlwZWRBcnJheVRvRmxvYXQzMih2YWx1ZXMsIGR0eXBlKSk7XG4gICAgICAgICAgICB0ZXhEYXRhLnZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFdhaXRNcyArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jYWNoZU9uQ1BVID0gZnVuY3Rpb24gKGRhdGFJZCwgZmxvYXQzMlZhbHVlcykge1xuICAgICAgICB2YXIgZG9udEtlZXBDb3B5T25HUFUgPSB0aGlzLmRlbGF5ZWRTdG9yYWdlO1xuICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0ZXhEYXRhLnRleHR1cmUsIHRleFNoYXBlID0gdGV4RGF0YS50ZXhTaGFwZSwgZHR5cGUgPSB0ZXhEYXRhLmR0eXBlLCB0ZXhUeXBlID0gdGV4RGF0YS50ZXhUeXBlO1xuICAgICAgICBpZiAoZG9udEtlZXBDb3B5T25HUFUgJiYgdGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VUZXh0dXJlKGRhdGFJZCwgdGV4dHVyZSwgdGV4U2hhcGUsIHRleFR5cGUpO1xuICAgICAgICAgICAgdGV4RGF0YS50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgIHRleERhdGEudGV4U2hhcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbG9hdDMyVmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRleERhdGEudmFsdWVzID0gZmxvYXQzMlRvVHlwZWRBcnJheShmbG9hdDMyVmFsdWVzLCBkdHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlID0gZnVuY3Rpb24gKGRhdGFJZCwgdGV4dHVyZSwgdGV4U2hhcGUsIHRleFR5cGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpLCBzaGFwZSA9IF9hLnNoYXBlLCBkdHlwZSA9IF9hLmR0eXBlO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5scnVEYXRhR1BVLmluZGV4T2YoZGF0YUlkKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxydURhdGFHUFUuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5udW1CeXRlc0luR1BVIC09IHRoaXMuY29tcHV0ZUJ5dGVzKHNoYXBlLCBkdHlwZSk7XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGV4dHVyZSwgdGV4U2hhcGUsIHRleFR5cGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmUgPSBmdW5jdGlvbiAoZGF0YUlkLCB0ZXhTaGFwZSwgdGV4VHlwZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCksIHNoYXBlID0gX2Euc2hhcGUsIGR0eXBlID0gX2EuZHR5cGU7XG4gICAgICAgIHRoaXMubHJ1RGF0YUdQVS5wdXNoKGRhdGFJZCk7XG4gICAgICAgIHRoaXMubnVtQnl0ZXNJbkdQVSArPSB0aGlzLmNvbXB1dGVCeXRlcyhzaGFwZSwgZHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0ZXhTaGFwZSwgdGV4VHlwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb21wdXRlQnl0ZXMgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpICogdXRpbC5ieXRlc1BlckVsZW1lbnQoZHR5cGUpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hdGhCYWNrZW5kV2ViR0w7XG59KCkpO1xuZXhwb3J0cy5NYXRoQmFja2VuZFdlYkdMID0gTWF0aEJhY2tlbmRXZWJHTDtcbmlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgIGVudmlyb25tZW50XzEuRU5WLnJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWF0aEJhY2tlbmRXZWJHTCgpOyB9LCAyKTtcbn1cbmZ1bmN0aW9uIGZsb2F0MzJUb1R5cGVkQXJyYXkoYSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicgfHwgZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gKGR0eXBlID09PSAnaW50MzInKSA/IG5ldyBJbnQzMkFycmF5KGEubGVuZ3RoKSA6XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHR5cGVkQXJyYXlUb0Zsb2F0MzIoYSwgZHR5cGUpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpID8gYSA6IG5ldyBGbG9hdDMyQXJyYXkoYSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrZW5kX3dlYmdsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFyZ01pbk1heFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFyZ01pbk1heFByb2dyYW0ocmVkdWNlSW5mbywgb3AsIGZpcnN0UGFzcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VJbmZvLndpbmRvd1NpemU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSByZWR1Y2VJbmZvLmJhdGNoU2l6ZTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHJlZHVjZUluZm8uaW5TaXplO1xuICAgICAgICB2YXIgb3V0U2l6ZSA9IE1hdGguY2VpbChpblNpemUgLyB3aW5kb3dTaXplKTtcbiAgICAgICAgaWYgKCFmaXJzdFBhc3MpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiZXN0SW5kaWNlc0EnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0U2l6ZV07XG4gICAgICAgIHZhciBjb21wT3AgPSAob3AgPT09ICdtYXgnKSA/ICc+JyA6ICc8JztcbiAgICAgICAgdmFyIGluZGV4U25pcHBldCA9IGZpcnN0UGFzcyA/XG4gICAgICAgICAgICAnaW5PZmZzZXQgKyBpOycgOlxuICAgICAgICAgICAgJ3JvdW5kKGdldEJlc3RJbmRpY2VzQShiYXRjaCwgaW5PZmZzZXQgKyBpKSk7JztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIgKyB3aW5kb3dTaXplICsgXCI7XFxuXFxuICAgICAgICBpbnQgYmVzdEluZGV4ID0gMDtcXG4gICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldEEoYmF0Y2gsIGluT2Zmc2V0KTtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplICsgXCI7IGkrKykge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBcIiArIGluZGV4U25pcHBldCArIFwiO1xcbiAgICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRBKGJhdGNoLCBpbklkeCk7XFxuICAgICAgICAgIGlmIChjYW5kaWRhdGUgXCIgKyBjb21wT3AgKyBcIiBiZXN0VmFsdWUpIHtcXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XFxuICAgICAgICAgICAgYmVzdEluZGV4ID0gaW5JZHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChiZXN0SW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQXJnTWluTWF4UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkFyZ01pbk1heFByb2dyYW0gPSBBcmdNaW5NYXhQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnbWlubWF4X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBdmdQb29sMkRCYWNrcHJvcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgYXZnTXVsdGlwbGllciA9IDEgLyAoZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGgpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdChcIiArIGF2Z011bHRpcGxpZXIgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbSA9IEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF2Z19wb29sX2JhY2twcm9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9vcHMvYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgQmF0Y2hOb3JtUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmF0Y2hOb3JtUHJvZ3JhbSh4U2hhcGUsIG1lYW5TaGFwZSwgdmFyaWFuY2VTaGFwZSwgb2Zmc2V0U2hhcGUsIHNjYWxlU2hhcGUsIHZhcmlhbmNlRXBzaWxvbikge1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMuc3VwcG9ydHNCcm9hZGNhc3RpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnbWVhbicsICd2YXJpYW5jZSddO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh4U2hhcGUsIG1lYW5TaGFwZSk7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgdmFyaWFuY2VTaGFwZSk7XG4gICAgICAgIHZhciBvZmZzZXRTbmlwcGV0ID0gJzAuMCc7XG4gICAgICAgIGlmIChvZmZzZXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh4U2hhcGUsIG9mZnNldFNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdvZmZzZXQnKTtcbiAgICAgICAgICAgIG9mZnNldFNuaXBwZXQgPSAnZ2V0T2Zmc2V0QXRPdXRDb29yZHMoKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjYWxlU25pcHBldCA9ICcxLjAnO1xuICAgICAgICBpZiAoc2NhbGVTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh4U2hhcGUsIHNjYWxlU2hhcGUpO1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ3NjYWxlJyk7XG4gICAgICAgICAgICBzY2FsZVNuaXBwZXQgPSAnZ2V0U2NhbGVBdE91dENvb3JkcygpJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0WEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG9mZnNldCA9IFwiICsgb2Zmc2V0U25pcHBldCArIFwiO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBcIiArIHNjYWxlU25pcHBldCArIFwiO1xcbiAgICAgICAgZmxvYXQgaW52ID0gc2NhbGUgKiBpbnZlcnNlc3FydCh2YXJpYW5jZSArIGZsb2F0KFwiICsgdmFyaWFuY2VFcHNpbG9uICsgXCIpKTtcXG4gICAgICAgIHNldE91dHB1dCgoeCAtIG1lYW4pICogaW52ICsgb2Zmc2V0KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQmF0Y2hOb3JtUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkJhdGNoTm9ybVByb2dyYW0gPSBCYXRjaE5vcm1Qcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmF0Y2hub3JtX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9vcHMvYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgQ0hFQ0tfTkFOX1NOSVBQRVQgPSBcIlxcbiAgaWYgKGlzTmFOKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc05hTihiKSkgcmV0dXJuIGI7XFxuXCI7XG5leHBvcnRzLkFERCA9ICdyZXR1cm4gYSArIGI7JztcbmV4cG9ydHMuU1VCID0gJ3JldHVybiBhIC0gYjsnO1xuZXhwb3J0cy5NVUwgPSAncmV0dXJuIGEgKiBiOyc7XG5leHBvcnRzLkRJViA9ICdyZXR1cm4gYSAvIGI7JztcbmV4cG9ydHMuSU5UX0RJViA9IFwiXFxuICBmbG9hdCByZXN1bHRTaWduID0gc2lnbihhKSAqIHNpZ24oYik7XFxuICBpbnQgaWEgPSByb3VuZChhKTtcXG4gIGludCBpYiA9IHJvdW5kKGIpO1xcbiAgaW50IHJlc3VsdCA9IGlhIC8gaWI7XFxuICBpbnQgYW1vZGIgPSBpYSAtIGliICogcmVzdWx0O1xcblxcbiAgaWYgKHJlc3VsdFNpZ24gPCAwLjAgJiYgYW1vZGIgIT0gMCkge1xcbiAgICByZXN1bHQgLT0gMTtcXG4gIH1cXG4gIHJldHVybiBmbG9hdChyZXN1bHQpO1xcblwiO1xuZXhwb3J0cy5QT1cgPSBcIlxcbiAgcmV0dXJuIChyb3VuZChtb2QoYiwgMi4wKSkgPT0gMCB8fCByb3VuZChtb2QoYiwgMi4wKSkgPT0gMikgP1xcbiAgICAgIHBvdyhhYnMoYSksIGIpIDogc2lnbihhKSAqIHBvdyhhYnMoYSksIGIpO1xcblwiO1xuZXhwb3J0cy5TUVVBUkVEX0RJRkZFUkVOQ0UgPSAncmV0dXJuIChhIC0gYikgKiAoYSAtIGIpOyc7XG5leHBvcnRzLkVRVUFMID0gXCJyZXR1cm4gZmxvYXQoYSA9PSBiKTtcIjtcbmV4cG9ydHMuTk9UX0VRVUFMID0gXCJyZXR1cm4gZmxvYXQoYSAhPSBiKTtcIjtcbmV4cG9ydHMuTEVTUyA9IFwicmV0dXJuIGZsb2F0KGEgPCBiKTtcIjtcbmV4cG9ydHMuTEVTU19FUVVBTCA9IFwicmV0dXJuIGZsb2F0KGEgPD0gYik7XCI7XG5leHBvcnRzLkdSRUFURVIgPSBcInJldHVybiBmbG9hdChhID4gYik7XCI7XG5leHBvcnRzLkdSRUFURVJfRVFVQUwgPSBcInJldHVybiBmbG9hdChhID49IGIpO1wiO1xuZXhwb3J0cy5MT0dJQ0FMX0FORCA9IFwicmV0dXJuIGZsb2F0KGEgPj0gMS4wICYmIGIgPj0gMS4wKTtcIjtcbmV4cG9ydHMuTE9HSUNBTF9PUiA9IFwicmV0dXJuIGZsb2F0KGEgPj0gMS4wIHx8IGIgPj0gMS4wKTtcIjtcbmV4cG9ydHMuTUFYID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIG1heChhLCBiKTtcXG5cIjtcbmV4cG9ydHMuTUlOID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIG1pbihhLCBiKTtcXG5cIjtcbmV4cG9ydHMuTU9EID0gXCJyZXR1cm4gbW9kKGEsIGIpO1wiO1xuZXhwb3J0cy5BVEFOMiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBhdGFuKGEsIGIpO1xcblwiO1xuZXhwb3J0cy5FTFVfREVSID0gXCJyZXR1cm4gKGIgPj0gMS4wKSA/IGEgOiBhICogKGIgKyAxLjApO1wiO1xudmFyIEJpbmFyeU9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluYXJ5T3BQcm9ncmFtKG9wLCBhU2hhcGUsIGJTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9XG4gICAgICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhU2hhcGUsIGJTaGFwZSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIiArIG9wICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wZXJhdGlvbihhLCBiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeU9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkJpbmFyeU9wUHJvZ3JhbSA9IEJpbmFyeU9wUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeW9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDbGlwUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpcFByb2dyYW0oYVNoYXBlLCBtaW4sIG1heCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGFTaGFwZTtcbiAgICAgICAgdmFyIG1pbkZpeGVkID0gbWluLnRvRml4ZWQoMjApO1xuICAgICAgICB2YXIgbWF4Rml4ZWQgPSBtYXgudG9GaXhlZCgyMCk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgXCIgKyBtaW5GaXhlZCArIFwiLCBcIiArIG1heEZpeGVkICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ2xpcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5DbGlwUHJvZ3JhbSA9IENsaXBQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL2NvbmNhdF91dGlsXCIpO1xudmFyIENvbmNhdFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmNhdFByb2dyYW0oYVNoYXBlLCBiU2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID1cbiAgICAgICAgICAgIGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhU2hhcGUsIGJTaGFwZSwgMSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHlSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgeUMgPSBjb29yZHMueTtcXG5cXG4gICAgICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICAgICAgaWYgKHlDIDwgXCIgKyBhU2hhcGVbMV0gKyBcIikge1xcbiAgICAgICAgICB2YWx1ZSA9IGdldEEoeVIsIHlDKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHlDIC09IFwiICsgYVNoYXBlWzFdICsgXCI7XFxuICAgICAgICAgIHZhbHVlID0gZ2V0Qih5UiwgeUMpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29uY2F0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbmNhdFByb2dyYW0gPSBDb25jYXRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb252MkREZXJGaWx0ZXJQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkREZXJGaWx0ZXJQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdkeSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uZmlsdGVyU2hhcGU7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCBkeSg6LCA6LCBkMikgdG8gZ2V0IGR3KHdSLCB3QywgZDEsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIgKyBjb252SW5mby5iYXRjaFNpemUgKyBcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIiArIGNvbnZJbmZvLm91dEhlaWdodCArIFwiOyB5UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIgLSBcIiArIHBhZFRvcCArIFwiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiICsgc3RyaWRlV2lkdGggKyBcIiAtIFwiICsgcGFkTGVmdCArIFwiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVyRmlsdGVyUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlckZpbHRlclByb2dyYW0gPSBDb252MkREZXJGaWx0ZXJQcm9ncmFtO1xudmFyIENvbnYyRERlcklucHV0UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknLCAnVyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIiArIGZpbHRlcldpZHRoICsgXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8IFwiICsgY29udkluZm8ub3V0Q2hhbm5lbHMgKyBcIjsgZDIrKykge1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVySW5wdXRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJERGVySW5wdXRQcm9ncmFtID0gQ29udjJERGVySW5wdXRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl9iYWNrcHJvcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGVwdGh3aXNlQ29udjJERGVyRmlsdGVyUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVwdGh3aXNlQ29udjJERGVyRmlsdGVyUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnZHknXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmZpbHRlclNoYXBlO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIGNoYW5uZWxNdWwgPSBjb252SW5mby5vdXRDaGFubmVscyAvIGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGRtID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDIgPSBkMSAqIFwiICsgY2hhbm5lbE11bCArIFwiICsgZG07XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgLy8gVE9ETzogVmVjNCBvdmVyIHRoZSBiYXRjaCBzaXplXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiICsgY29udkluZm8uYmF0Y2hTaXplICsgXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIiArIHN0cmlkZUhlaWdodCArIFwiIC0gXCIgKyBwYWRUb3AgKyBcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIiArIHN0cmlkZVdpZHRoICsgXCIgLSBcIiArIHBhZExlZnQgKyBcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIERlcHRod2lzZUNvbnYyRERlckZpbHRlclByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5EZXB0aHdpc2VDb252MkREZXJGaWx0ZXJQcm9ncmFtID0gRGVwdGh3aXNlQ29udjJERGVyRmlsdGVyUHJvZ3JhbTtcbnZhciBEZXB0aHdpc2VDb252MkREZXJJbnB1dFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcHRod2lzZUNvbnYyRERlcklucHV0UHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBjaGFubmVsTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiICsgZmlsdGVySGVpZ2h0ICsgXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIiArIHN0cmlkZVdpZHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIiArIGNvbnZJbmZvLm91dFdpZHRoICsgXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIgKyBmaWx0ZXJXaWR0aCArIFwiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIC8vIFRPRE86IFZlYzQgb3ZlciB0aGUgY2hhbm5lbE11bFxcbiAgICAgICAgICAgIGZvciAoaW50IGRtID0gMDsgZG0gPCBcIiArIGNoYW5uZWxNdWwgKyBcIjsgZG0rKykge1xcbiAgICAgICAgICAgICAgaW50IGQyID0gZDEgKiBcIiArIGNoYW5uZWxNdWwgKyBcIiArIGRtO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkbSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtID0gRGVwdGh3aXNlQ29udjJERGVySW5wdXRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl9iYWNrcHJvcF9ncHVfZGVwdGh3aXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbnYyRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYyRFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGRpbGF0aW9uSGVpZ2h0ID0gY29udkluZm8uZGlsYXRpb25IZWlnaHQ7XG4gICAgICAgIHZhciBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKGNvbnZJbmZvLmluQ2hhbm5lbHMgLyA0KSAqIDQ7XG4gICAgICAgIHZhciBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IGNvbnZJbmZvLmluQ2hhbm5lbHMgJSA0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIgKyBkaWxhdGlvbkhlaWdodCArIFwiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIgKyBkaWxhdGlvbldpZHRoICsgXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiOyBkMSArPSA0KSB7XFxuICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpICpcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMiwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkRQcm9ncmFtID0gQ29udjJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERlcHRod2lzZUNvbnYyRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcHRod2lzZUNvbnYyRFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgeE51bVJvd3MgPSBjb252SW5mby5pbkhlaWdodDtcbiAgICAgICAgdmFyIHhOdW1Db2xzID0gY29udkluZm8uaW5XaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgICAgICB2YXIgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgY2hhbm5lbE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMSA9IGQyIC8gXCIgKyBjaGFubmVsTXVsICsgXCI7XFxuICAgICAgICBpbnQgcSA9IGQyIC0gZDEgKiBcIiArIGNoYW5uZWxNdWwgKyBcIjtcXG5cXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgLy8gVE9ETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIgKyBkaWxhdGlvbkhlaWdodCArIFwiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIgKyBkaWxhdGlvbldpZHRoICsgXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcod1IsIHdDLCBkMSwgcSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBEZXB0aHdpc2VDb252MkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuRGVwdGh3aXNlQ29udjJEUHJvZ3JhbSA9IERlcHRod2lzZUNvbnYyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X2dwdV9kZXB0aHdpc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgQ3VtU3VtUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ3VtU3VtUHJvZ3JhbShzaGFwZSwgZXhjbHVzaXZlLCByZXZlcnNlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gc2hhcGU7XG4gICAgICAgIHZhciByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZmluYWxEaW0gPSBzaGFwZVtzaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSByZXZlcnNlID8gJzwnIDogJz4nO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBpbnQgZ2V0SW5kZXgoaW50IGkpIHtcXG4gICAgICAgIFwiICsgKHJldmVyc2UgPyBcInJldHVybiBcIiArIGZpbmFsRGltICsgXCIgLWkgLSAxO1wiIDogJ3JldHVybiBpOycpICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZShyYW5rKSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGVuZCA9IFwiICsgZ2V0RmluYWxDb29yZChyYW5rLCAnY29vcmRzJykgKyBcIjtcXG4gICAgICAgIGZsb2F0IHZhbCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGkgPSBcIiArIGZpbmFsRGltICsgXCIgLSAxOyBpID49IDA7IGkgLT0gMSkge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZ2V0SW5kZXgoaSk7XFxuICAgICAgICAgIGlmIChpZHggXCIgKyBjb21wYXJhdG9yICsgXCIgZW5kKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGlkeCA9PSBlbmQgJiYgXCIgKyBleGNsdXNpdmUgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIFwiICsgZ2V0RmluYWxDb29yZChyYW5rLCAnY29vcmRzJykgKyBcIiA9IGlkeDtcXG4gICAgICAgICAgdmFsICs9IGdldFgoXCIgKyBnZXRDb29yZHMocmFuaywgJ2Nvb3JkcycpICsgXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEN1bVN1bVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5DdW1TdW1Qcm9ncmFtID0gQ3VtU3VtUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldENvb3JkcyhyYW5rLCBuYW1lKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIueCwgXCIgKyBuYW1lICsgXCIueVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIueCwgXCIgKyBuYW1lICsgXCIueSwgXCIgKyBuYW1lICsgXCIuelwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgXCIueCwgXCIgKyBuYW1lICsgXCIueSwgXCIgKyBuYW1lICsgXCIueiwgXCIgKyBuYW1lICsgXCIud1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRGaW5hbENvb3JkKHJhbmssIG5hbWUpIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcIiArIG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIi55XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIi56XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIi53XCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkN1bXVsYXRpdmUgc3VtIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1bXN1bV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRnJvbVBpeGVsc1Byb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZyb21QaXhlbHNQcm9ncmFtKG91dHB1dFNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb3V0cHV0U2hhcGVbMF0sIHdpZHRoID0gb3V0cHV0U2hhcGVbMV07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgdGV4UiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCB0ZXhDID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGRlcHRoID0gY29vcmRzWzJdO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB3aWR0aCArIFwiLjAsIFwiICsgaGVpZ2h0ICsgXCIuMCk7XFxuXFxuICAgICAgICB2ZWM0IHZhbHVlcyA9IHRleHR1cmUyRChBLCB1dik7XFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZztcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5iO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvb3IodmFsdWUgKiAyNTUuMCArIDAuNSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBGcm9tUGl4ZWxzUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkZyb21QaXhlbHNQcm9ncmFtID0gRnJvbVBpeGVsc1Byb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tX3BpeGVsc19ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgR2F0aGVyUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2F0aGVyUHJvZ3JhbShhU2hhcGUsIGluZGljZXNMZW5ndGgsIGF4aXMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ2luZGljZXMnXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gYVNoYXBlLnNsaWNlKCk7XG4gICAgICAgIG91dHB1dFNoYXBlW2F4aXNdID0gaW5kaWNlc0xlbmd0aDtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBnZXRTb3VyY2VDb29yZHMoYVNoYXBlLCBheGlzKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEdhdGhlclByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5HYXRoZXJQcm9ncmFtID0gR2F0aGVyUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldFNvdXJjZUNvb3JkcyhhU2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgcmFuayA9IGFTaGFwZS5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPiA0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiR2F0aGVyIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJpbnQoZ2V0SW5kaWNlcyhyZXNSQykpXCI7XG4gICAgfVxuICAgIHZhciBjdXJyZW50Q29vcmRzID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53J107XG4gICAgdmFyIHNvdXJjZUNvb3JkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBheGlzKSB7XG4gICAgICAgICAgICBzb3VyY2VDb29yZHMucHVzaChcImludChnZXRJbmRpY2VzKFwiICsgY3VycmVudENvb3Jkc1tpXSArIFwiKSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VDb29yZHMucHVzaChcIlwiICsgY3VycmVudENvb3Jkc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUNvb3Jkcy5qb2luKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nYXRoZXJfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL2dwZ3B1X3V0aWxcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2xfdXRpbFwiKTtcbnZhciBHUEdQVUNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdQR1BVQ29udGV4dChnbCkge1xuICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXRlbXNUb1BvbGwgPSBbXTtcbiAgICAgICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBncGdwdV91dGlsLmNyZWF0ZVdlYkdMQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvc2VDb250ZXh0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9nZXRfYnVmZmVyX3N1Yl9kYXRhX2FzeW5jJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBncGdwdV91dGlsLmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdwZ3B1X3V0aWwuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSB3ZWJnbF91dGlsLmNyZWF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgIH1cbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIFdlYkdMUHJvZ3JhbS4nICtcbiAgICAgICAgICAgICAgICAnIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIHByb2dyYW0gd2l0aCAnICtcbiAgICAgICAgICAgICAgICAnR1BHUFVDb250ZXh0LmRlbGV0ZVByb2dyYW0gYmVmb3JlIGRpc3Bvc2luZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRwdXRUZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgb3V0cHV0IG1hdHJpeCAnICtcbiAgICAgICAgICAgICAgICAndGV4dHVyZS4gIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIG91dHB1dCAnICtcbiAgICAgICAgICAgICAgICAnbWF0cml4IHRleHR1cmUgd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlTWF0cml4VGV4dHVyZSBiZWZvcmUgJyArXG4gICAgICAgICAgICAgICAgJ2Rpc3Bvc2luZy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZmluaXNoKCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kZWxldGVGcmFtZWJ1ZmZlcihfdGhpcy5mcmFtZWJ1ZmZlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRlbGV0ZUJ1ZmZlcihfdGhpcy52ZXJ0ZXhCdWZmZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRlbGV0ZUJ1ZmZlcihfdGhpcy5pbmRleEJ1ZmZlcik7IH0pO1xuICAgICAgICB0aGlzLmxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5lbmFibGVBdXRvbWF0aWNEZWJ1Z1ZhbGlkYXRpb24gPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlID0gZW5hYmxlZDtcbiAgICAgICAgd2ViZ2xfdXRpbC5lbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyhlbmFibGVkKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLmNyZWF0ZU1hdHJpeFRleHR1cmUodGhpcy5nbCwgcm93cywgY29sdW1ucyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBwaXhlbHMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgZ3BncHVfdXRpbC51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgcGl4ZWxzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUodGhpcy5nbCwgcm93cywgY29sdW1ucyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRlbGV0ZU1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRUZXh0dXJlID09PSB0ZXh0dXJlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0VGV4dHVyZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIG51bUNoYW5uZWxzID0gMTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwudXBsb2FkTWF0cml4VG9UZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCwgbnVtQ2hhbm5lbHMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS51cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBncGdwdV91dGlsLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodGV4dHVyZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShfdGhpcy5nbCwgcm93cywgY29sdW1ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlQXN5bmMgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkb3dubG9hZCBtYXRyaXggZnJvbSBvdXRwdXQgdGV4dHVyZSBhc3luY2hyb25vdXNseSwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJXRUJHTF9nZXRfYnVmZmVyX3N1Yl9kYXRhX2FzeW5jIGlzIG5vdCBlbmFibGVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyQXN5bmModGV4dHVyZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmMoX3RoaXMuZ2wsIF90aGlzLmdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiwgcm93cywgY29sdW1ucyk7IH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBjaGFubmVscykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB3ZWJnbF91dGlsLmNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBncGdwdV91dGlsLmNyZWF0ZVZlcnRleFNoYWRlcihnbCk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gd2ViZ2xfdXRpbC5jcmVhdGVQcm9ncmFtKGdsKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmxpbmtQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudmVydGV4QXR0cnNBcmVCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kID0gZ3BncHVfdXRpbC5iaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoZ2wsIHRoaXMucHJvZ3JhbSwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWxldGVQcm9ncmFtID0gZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHByb2dyYW0gPT09IHRoaXMucHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRQcm9ncmFtID0gZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgaWYgKCh0aGlzLnByb2dyYW0gIT0gbnVsbCkgJiYgdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uID0gZnVuY3Rpb24gKHByb2dyYW0sIHVuaWZvcm1OYW1lLCBzaG91bGRUaHJvdykge1xuICAgICAgICBpZiAoc2hvdWxkVGhyb3cgPT09IHZvaWQgMCkgeyBzaG91bGRUaHJvdyA9IHRydWU7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gd2ViZ2xfdXRpbC5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyh0aGlzLmdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2ViZ2xfdXRpbC5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uKHRoaXMuZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmFtLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZSk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93ID0gZnVuY3Rpb24gKHByb2dyYW0sIHVuaWZvcm1OYW1lKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldElucHV0TWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChpbnB1dE1hdHJpeFRleHR1cmUsIHVuaWZvcm1Mb2NhdGlvbiwgdGV4dHVyZVVuaXQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcih0aGlzLmdsLCB0aGlzLnByb2dyYW0sIGlucHV0TWF0cml4VGV4dHVyZSwgdW5pZm9ybUxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAob3V0cHV0TWF0cml4VGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIob3V0cHV0TWF0cml4VGV4dHVyZSwgY29sdW1ucywgcm93cyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAob3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihvdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb24gPSBmdW5jdGlvbiAoc3RhcnRSb3csIG51bVJvd3MsIHN0YXJ0Q29sdW1uLCBudW1Db2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIoc3RhcnRDb2x1bW4sIHN0YXJ0Um93LCBudW1Db2x1bW5zLCBudW1Sb3dzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gPSBmdW5jdGlvbiAoc3RhcnRSb3csIG51bVJvd3MsIHN0YXJ0Q29sdW1uLCBudW1Db2x1bW5zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gbm90IGltcGxlbWVudGVkLicpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWJ1Z1ZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5leGVjdXRlUHJvZ3JhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnVmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5maW5pc2goKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsIGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA9PT0gMiA/XG4gICAgICAgICAgICAgICAgICAgICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJyA6XG4gICAgICAgICAgICAgICAgICAgICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb247XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbigpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5ydW5RdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUZuKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMuYmVnaW5RdWVyeSgpO1xuICAgICAgICBxdWVyeUZuKCk7XG4gICAgICAgIHRoaXMuZW5kUXVlcnkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9sbFF1ZXJ5VGltZShxdWVyeSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmJlZ2luUXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBnbDIgPSB0aGlzLmdsO1xuICAgICAgICAgICAgdmFyIGV4dF8xID0gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCk7XG4gICAgICAgICAgICB2YXIgcXVlcnlfMSA9IGdsMi5jcmVhdGVRdWVyeSgpO1xuICAgICAgICAgICAgZ2wyLmJlZ2luUXVlcnkoZXh0XzEuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnlfMSk7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlfMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0ID0gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7XG4gICAgICAgIHZhciBxdWVyeSA9IGV4dC5jcmVhdGVRdWVyeUVYVCgpO1xuICAgICAgICBleHQuYmVnaW5RdWVyeUVYVChleHQuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpO1xuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmVuZFF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZ2wyID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHZhciBleHRfMiA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO1xuICAgICAgICAgICAgZ2wyLmVuZFF1ZXJ5KGV4dF8yLlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHQgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtcbiAgICAgICAgZXh0LmVuZFF1ZXJ5RVhUKGV4dC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuaXNRdWVyeUF2YWlsYWJsZSA9IGZ1bmN0aW9uIChxdWVyeSwgcXVlcnlUaW1lclZlcnNpb24pIHtcbiAgICAgICAgaWYgKHF1ZXJ5VGltZXJWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnlUaW1lclZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBnbDIgPSB0aGlzLmdsO1xuICAgICAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IGdsMi5nZXRRdWVyeVBhcmFtZXRlcihxdWVyeSwgZ2wyLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzam9pbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzam9pbnQgPSB0aGlzLmdsLmdldFBhcmFtZXRlcihleHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlICYmICF0aGlzLmRpc2pvaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IGV4dC5nZXRRdWVyeU9iamVjdEVYVChxdWVyeSwgZXh0LlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2pvaW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2pvaW50ID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIoZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhdGhpcy5kaXNqb2ludDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5wb2xsUXVlcnlUaW1lID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5VGltZXJWZXJzaW9uID0gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpO1xuICAgICAgICAgICAgX3RoaXMuYWRkSXRlbVRvUG9sbChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pc1F1ZXJ5QXZhaWxhYmxlKHF1ZXJ5LCBxdWVyeVRpbWVyVmVyc2lvbik7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoX3RoaXMuZ2V0UXVlcnlUaW1lKHF1ZXJ5LCBxdWVyeVRpbWVyVmVyc2lvbikpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnBvbGxJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmluU2VhcmNoTGFzdFRydWUodGhpcy5pdGVtc1RvUG9sbC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaXNEb25lRm47IH0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaW5kZXg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVGbiA9IHRoaXMuaXRlbXNUb1BvbGxbaV0ucmVzb2x2ZUZuO1xuICAgICAgICAgICAgcmVzb2x2ZUZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtc1RvUG9sbCA9IHRoaXMuaXRlbXNUb1BvbGwuc2xpY2UoaW5kZXggKyAxKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuYWRkSXRlbVRvUG9sbCA9IGZ1bmN0aW9uIChpc0RvbmVGbiwgcmVzb2x2ZUZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaXRlbXNUb1BvbGwucHVzaCh7IGlzRG9uZUZuOiBpc0RvbmVGbiwgcmVzb2x2ZUZuOiByZXNvbHZlRm4gfSk7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLnJlcGVhdGVkVHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnBvbGxJdGVtcygpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZSA9IGZ1bmN0aW9uIChxdWVyeSwgcXVlcnlUaW1lclZlcnNpb24pIHtcbiAgICAgICAgaWYgKHF1ZXJ5VGltZXJWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnlUaW1lclZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBnbDIgPSB0aGlzLmdsO1xuICAgICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTmFub3MgPSBnbDIuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIGdsMi5RVUVSWV9SRVNVTFQpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVFbGFwc2VkTmFub3MgLyAxMDAwMDAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO1xuICAgICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTmFub3MgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfRVhUKTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lRWxhcHNlZE5hbm9zIC8gMTAwMDAwMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlclNldHVwID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0ZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlclRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRUZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5vdXRwdXRUZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXIgPSBmdW5jdGlvbiAodGV4dHVyZSwgZG93bmxvYWRBbmREZWNvZGUpIHtcbiAgICAgICAgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlclNldHVwKHRleHR1cmUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZG93bmxvYWRBbmREZWNvZGUoKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlclRlYXJkb3duKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyQXN5bmMgPSBmdW5jdGlvbiAodGV4dHVyZSwgZG93bmxvYWRBbmREZWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZG93bmxvYWRBbmREZWNvZGUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93bigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlciA9IGZ1bmN0aW9uIChvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcihnbCwgb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcihnbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2Npc3NvcigwLCAwLCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVzZSBkaXNwb3NlZCBHUEdQVUNvbnRleHQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEdQVSBwcm9ncmFtIGlzIGN1cnJlbnRseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHUEdQVUNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5HUEdQVUNvbnRleHQgPSBHUEdQVUNvbnRleHQ7XG5mdW5jdGlvbiBiaW5TZWFyY2hMYXN0VHJ1ZShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB2YXIgYmVzdCA9IC0xO1xuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIG1pZCA9IChzdGFydCArIGVuZCkgPj4gMTtcbiAgICAgICAgdmFyIGlzRG9uZSA9IGFyclttaWRdKCk7XG4gICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICAgIGJlc3QgPSBtaWQ7XG4gICAgICAgICAgICBzdGFydCA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xufVxuZXhwb3J0cy5iaW5TZWFyY2hMYXN0VHJ1ZSA9IGJpblNlYXJjaExhc3RUcnVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3BncHVfY29udGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBzaGFkZXJfY29tcGlsZXIgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgTkFOX1VOSUZPUk1fTkFNRSA9ICdOYU4nO1xuZnVuY3Rpb24gc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpIHtcbiAgICByZXR1cm4gIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJyk7XG59XG5mdW5jdGlvbiBjb21waWxlUHJvZ3JhbShncGdwdSwgcHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpIHtcbiAgICB2YXIgdXNlckNvZGUgPSBwcm9ncmFtLnVzZXJDb2RlO1xuICAgIHZhciBpbnB1dEluZm9zID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgdmFyIHNoYXBlSW5mbyA9IHtcbiAgICAgICAgICAgIGxvZ2ljYWxTaGFwZTogaW5wdXQudGVuc29yLnNoYXBlLFxuICAgICAgICAgICAgdGV4U2hhcGU6IGlucHV0LnRleERhdGEudGV4U2hhcGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogcHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldLCBzaGFwZUluZm86IHNoYXBlSW5mbyB9O1xuICAgIH0pO1xuICAgIHZhciBpblNoYXBlSW5mb3MgPSBpbnB1dEluZm9zLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZUluZm87IH0pO1xuICAgIHZhciBvdXRTaGFwZUluZm8gPSB7XG4gICAgICAgIGxvZ2ljYWxTaGFwZTogb3V0cHV0LnRlbnNvci5zaGFwZSxcbiAgICAgICAgdGV4U2hhcGU6IG91dHB1dC50ZXhEYXRhLnRleFNoYXBlXG4gICAgfTtcbiAgICB2YXIgc291cmNlID0gc2hhZGVyX2NvbXBpbGVyLm1ha2VTaGFkZXIoaW5wdXRJbmZvcywgb3V0U2hhcGVJbmZvLCB1c2VyQ29kZSwgcHJvZ3JhbS5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9PT0gdHJ1ZSk7XG4gICAgdmFyIHdlYkdMUHJvZ3JhbSA9IGdwZ3B1LmNyZWF0ZVByb2dyYW0oc291cmNlKTtcbiAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbS52YXJpYWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB1bmlmb3JtTmFtZSA9IHByb2dyYW0udmFyaWFibGVOYW1lc1tpXTtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1t1bmlmb3JtTmFtZV0gPVxuICAgICAgICAgICAgZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpKSB7XG4gICAgICAgIHZhciB0aHJvd0lmTmFOVW5pZm9ybUlzTm90VXNlZCA9IGZhbHNlO1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW05BTl9VTklGT1JNX05BTUVdID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgTkFOX1VOSUZPUk1fTkFNRSwgdGhyb3dJZk5hTlVuaWZvcm1Jc05vdFVzZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgd2ViR0xQcm9ncmFtOiB3ZWJHTFByb2dyYW0sXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgICAgIGdwZ3B1OiBncGdwdSxcbiAgICAgICAgaW5TaGFwZUluZm9zOiBpblNoYXBlSW5mb3MsXG4gICAgICAgIG91dFNoYXBlSW5mbzogb3V0U2hhcGVJbmZvXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcGlsZVByb2dyYW0gPSBjb21waWxlUHJvZ3JhbTtcbmZ1bmN0aW9uIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShzaGFwZUluZm9zLCBpbnB1dHMpIHtcbiAgICBpZiAoc2hhcGVJbmZvcy5sZW5ndGggIT09IGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggXCIgKyBzaGFwZUluZm9zLmxlbmd0aCArIFwiIGlucHV0cywgYnV0IFwiICtcbiAgICAgICAgICAgIChcIndhcyBleGVjdXRlZCB3aXRoIFwiICsgaW5wdXRzLmxlbmd0aCArIFwiIGlucHV0c1wiKSk7XG4gICAgfVxuICAgIHNoYXBlSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICB2YXIgc2hhcGVBID0gcy5sb2dpY2FsU2hhcGU7XG4gICAgICAgIHZhciB0ZXhTaGFwZUEgPSBzLnRleFNoYXBlO1xuICAgICAgICB2YXIgc2hhcGVCID0gaW5wdXRzW2ldLnRlbnNvci5zaGFwZTtcbiAgICAgICAgdmFyIHRleFNoYXBlQiA9IGlucHV0c1tpXS50ZXhEYXRhLnRleFNoYXBlO1xuICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoc2hhcGVBLCBzaGFwZUIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgc2hhcGVzIHRoYW4gXCIgK1xuICAgICAgICAgICAgICAgIChcInRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyBcIiArIHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbCh0ZXhTaGFwZUEsIHRleFNoYXBlQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZVwiICtcbiAgICAgICAgICAgICAgICAoXCIgY3VycmVudCBhcmdzLiBTaGFwZSBcIiArIHRleFNoYXBlQSArIFwiIGFuZCBcIiArIHRleFNoYXBlQiArIFwiIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBydW5Qcm9ncmFtKGJpbmFyeSwgaW5wdXRzLCBvdXRwdXQsIGN1c3RvbVNldHVwKSB7XG4gICAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKGJpbmFyeS5pblNoYXBlSW5mb3MsIGlucHV0cyk7XG4gICAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKFtiaW5hcnkub3V0U2hhcGVJbmZvXSwgW291dHB1dF0pO1xuICAgIHZhciBvdXRUZXggPSBvdXRwdXQudGV4RGF0YS50ZXh0dXJlO1xuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dHB1dC50ZXhEYXRhLnRleFNoYXBlO1xuICAgIHZhciBncGdwdSA9IGJpbmFyeS5ncGdwdTtcbiAgICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKG91dFRleCwgb3V0VGV4U2hhcGVbMF0sIG91dFRleFNoYXBlWzFdKTtcbiAgICBncGdwdS5zZXRQcm9ncmFtKGJpbmFyeS53ZWJHTFByb2dyYW0pO1xuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCwgaSkge1xuICAgICAgICB2YXIgdGV4ID0gaW5wdXQudGV4RGF0YS50ZXh0dXJlO1xuICAgICAgICB2YXIgdmFyaWFibGVOYW1lID0gYmluYXJ5LnByb2dyYW0udmFyaWFibGVOYW1lc1tpXTtcbiAgICAgICAgdmFyIHZhcmlhYmxlVW5pZm9ybUxvY2F0aW9uID0gYmluYXJ5LnVuaWZvcm1Mb2NhdGlvbnNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHRleCwgdmFyaWFibGVVbmlmb3JtTG9jYXRpb24sIGkpO1xuICAgIH0pO1xuICAgIGlmIChzaG91bGRVcGxvYWROYU5Vbmlmb3JtKCkpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKGJpbmFyeS51bmlmb3JtTG9jYXRpb25zW05BTl9VTklGT1JNX05BTUVdLCBOYU4pO1xuICAgIH1cbiAgICBpZiAoY3VzdG9tU2V0dXAgIT0gbnVsbCkge1xuICAgICAgICBjdXN0b21TZXR1cChncGdwdSwgYmluYXJ5LndlYkdMUHJvZ3JhbSk7XG4gICAgfVxuICAgIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG5leHBvcnRzLnJ1blByb2dyYW0gPSBydW5Qcm9ncmFtO1xuZnVuY3Rpb24gbWFrZVNoYWRlcktleShwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCkge1xuICAgIHZhciBrZXlJbnB1dHMgPSAnJztcbiAgICBpbnB1dHMuY29uY2F0KG91dHB1dCkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBrZXlJbnB1dHMgKz0geC50ZW5zb3Iuc2hhcGUgKyBcIl9cIiArIHgudGV4RGF0YS50ZXhTaGFwZTtcbiAgICB9KTtcbiAgICB2YXIga2V5VXNlckNvZGUgPSBwcm9ncmFtLnVzZXJDb2RlO1xuICAgIHZhciBrZXlCcm9hZGNhc3QgPSAocHJvZ3JhbS5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9PT0gdHJ1ZSkudG9TdHJpbmcoKTtcbiAgICB2YXIga2V5ID0gcHJvZ3JhbS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGtleSArPSAnXycgKyBrZXlCcm9hZGNhc3QgKyAnXycgKyBrZXlJbnB1dHMgKyAnXycgKyBrZXlVc2VyQ29kZTtcbiAgICByZXR1cm4ga2V5O1xufVxuZXhwb3J0cy5tYWtlU2hhZGVyS2V5ID0gbWFrZVNoYWRlcktleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X21hdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsX3V0aWxcIik7XG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZVxuICAgIH07XG59XG5leHBvcnRzLmdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzO1xuZnVuY3Rpb24gY3JlYXRlV2ViR0xDb250ZXh0KGNhbnZhcykge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIHZhciBnbDtcbiAgICBpZiAoY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgZ2wgPSB3ZWJnbF91dGlsLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsID0gd2ViZ2xfdXRpbC5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5CTEVORCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLkRJVEhFUik7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5TQU1QTEVfQ09WRVJBR0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmN1bGxGYWNlKGdsLkJBQ0spOyB9KTtcbiAgICByZXR1cm4gZ2w7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMQ29udGV4dCA9IGNyZWF0ZVdlYkdMQ29udGV4dDtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihnbCkge1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIGF0dHJpYnV0ZSB2ZWMzIGNsaXBTcGFjZVBvcztcXG4gICAgYXR0cmlidXRlIHZlYzIgdXY7XFxuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2VQb3MsIDEpO1xcbiAgICAgIHJlc3VsdFVWID0gdXY7XFxuICAgIH1cIjtcbiAgICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSk7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleFNoYWRlciA9IGNyZWF0ZVZlcnRleFNoYWRlcjtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleEJ1ZmZlcihnbCkge1xuICAgIHZhciB2ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAxLCAwLCAwLCAxLCAtMSwgLTEsIDAsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDEsIC0xLCAwLCAxLCAwXSk7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCB2ZXJ0ZXhBcnJheSk7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleEJ1ZmZlciA9IGNyZWF0ZVZlcnRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGNyZWF0ZUluZGV4QnVmZmVyKGdsKSB7XG4gICAgdmFyIHRyaWFuZ2xlVmVydGV4SW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMiwgMSwgM10pO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGdsLCB0cmlhbmdsZVZlcnRleEluZGljZXMpO1xufVxuZXhwb3J0cy5jcmVhdGVJbmRleEJ1ZmZlciA9IGNyZWF0ZUluZGV4QnVmZmVyO1xuZnVuY3Rpb24gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscykge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICB9XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIGlmIChudW1DaGFubmVscyA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsLlJHQkEzMkY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsLlIzMkY7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbC5SRUQ7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZVR5cGUoZ2wpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgfVxuICAgIHJldHVybiBnbC5GTE9BVDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKSB7XG4gICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgdGV4dHVyZSA9IHdlYmdsX3V0aWwuY3JlYXRlVGV4dHVyZShnbCk7XG4gICAgdmFyIHRleDJkID0gZ2wuVEVYVFVSRV8yRDtcbiAgICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgICB2YXIgZm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZSh0ZXgyZCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleEltYWdlMkQodGV4MmQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIGdldFRleHR1cmVUeXBlKGdsKSwgbnVsbCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXRyaXhUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG51bUNoYW5uZWxzID0gMTtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy5jcmVhdGVNYXRyaXhUZXh0dXJlID0gY3JlYXRlTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDQ7XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMuY3JlYXRlQ29sb3JNYXRyaXhUZXh0dXJlID0gY3JlYXRlQ29sb3JNYXRyaXhUZXh0dXJlO1xuZnVuY3Rpb24gY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUgPSBjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlO1xuZnVuY3Rpb24gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhCdWZmZXIpIHtcbiAgICB2YXIgcG9zT2Zmc2V0ID0gMDtcbiAgICB2YXIgdXZPZmZzZXQgPSAzICogNDtcbiAgICB2YXIgc3RyaWRlID0gKDMgKiA0KSArICgyICogNCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpOyB9KTtcbiAgICB2YXIgc3VjY2VzcyA9IHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ2NsaXBTcGFjZVBvcycsIHZlcnRleEJ1ZmZlciwgMywgc3RyaWRlLCBwb3NPZmZzZXQpO1xuICAgIHJldHVybiBzdWNjZXNzICYmXG4gICAgICAgIHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ3V2JywgdmVydGV4QnVmZmVyLCAyLCBzdHJpZGUsIHV2T2Zmc2V0KTtcbn1cbmV4cG9ydHMuYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zID0gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zO1xuZnVuY3Rpb24gdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCBwaXhlbHMpIHtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5leHBvcnRzLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSA9IHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZTtcbmZ1bmN0aW9uIHVwbG9hZERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIGRhdGEsIG51bUNoYW5uZWxzKSB7XG4gICAgdmFyIHRleHR1cmVGb3JtYXQgPSBnZXRUZXh0dXJlRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVGb3JtYXQsIGdldFRleHR1cmVUeXBlKGdsKSwgZGF0YSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5mdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCwgbnVtQ2hhbm5lbHMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgdW5wYWNrZWRBcnJheTtcbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICB2YXIgY2hhbm5lbHNQZXJUZXh0dXJlID0gbnVtQ2hhbm5lbHMgPT09IDEgPyB3ZWJnbF91dGlsLmdldENoYW5uZWxzUGVyVGV4dHVyZSgpIDogbnVtQ2hhbm5lbHM7XG4gICAgICAgIGlmIChjaGFubmVsc1BlclRleHR1cmUgPT09IDEpIHtcbiAgICAgICAgICAgIHVucGFja2VkQXJyYXkgPSBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bnBhY2tlZEFycmF5ID1cbiAgICAgICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRleF91dGlsLmdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gICAgICAgICAgICB0ZXhfdXRpbC5lbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkobWF0cml4LCB1bnBhY2tlZEFycmF5LCBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnBhY2tlZEFycmF5ID0gdGV4X3V0aWwuZW5jb2RlRmxvYXRBcnJheShtYXRyaXgpO1xuICAgIH1cbiAgICB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3LCBoLCB1bnBhY2tlZEFycmF5LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSA9IHVwbG9hZE1hdHJpeFRvVGV4dHVyZTtcbmZ1bmN0aW9uIHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZShnbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBwYWNrZWRSR0JBID0gbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpKTtcbiAgICB0ZXhfdXRpbC5lbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkEobWF0cml4LCByb3dzLCBjb2x1bW5zLCBwYWNrZWRSR0JBKTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHVwbG9hZERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHcsIGgsIHBhY2tlZFJHQkEsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlID0gdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlO1xudmFyIGZsb2F0RG93bmxvYWRCdWZmZXIgPSBudWxsO1xudmFyIGJ5dGVEb3dubG9hZEJ1ZmZlciA9IG51bGw7XG5mdW5jdGlvbiBnZXREb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHZhciBpc0Zsb2F0VGV4dHVyZSA9IGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJyk7XG4gICAgdmFyIG5lZWRlZFNpemUgPSByb3dzICogY29sdW1ucyAqIGNoYW5uZWxzUGVyVGV4dHVyZTtcbiAgICBpZiAoaXNGbG9hdFRleHR1cmUpIHtcbiAgICAgICAgaWYgKGZsb2F0RG93bmxvYWRCdWZmZXIgPT0gbnVsbCB8fFxuICAgICAgICAgICAgZmxvYXREb3dubG9hZEJ1ZmZlci5sZW5ndGggPCBuZWVkZWRTaXplKSB7XG4gICAgICAgICAgICBmbG9hdERvd25sb2FkQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShuZWVkZWRTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJ5dGVEb3dubG9hZEJ1ZmZlciA9PSBudWxsIHx8IGJ5dGVEb3dubG9hZEJ1ZmZlci5sZW5ndGggPCBuZWVkZWRTaXplKSB7XG4gICAgICAgICAgICBieXRlRG93bmxvYWRCdWZmZXIgPSBuZXcgVWludDhBcnJheShuZWVkZWRTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGlzRmxvYXRUZXh0dXJlID8gZmxvYXREb3dubG9hZEJ1ZmZlciA6IGJ5dGVEb3dubG9hZEJ1ZmZlcilcbiAgICAgICAgLnN1YmFycmF5KDAsIG5lZWRlZFNpemUpO1xufVxuZnVuY3Rpb24gZGVjb2RlRG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihkb3dubG9hZFRhcmdldCwgcm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCkge1xuICAgIHZhciBpc0Zsb2F0VGV4dHVyZSA9IGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJyk7XG4gICAgaWYgKGlzRmxvYXRUZXh0dXJlKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zKTtcbiAgICAgICAgdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkoZG93bmxvYWRUYXJnZXQsIG1hdHJpeCwgY2hhbm5lbHNQZXJQaXhlbCk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGV4X3V0aWwuZGVjb2RlVG9GbG9hdEFycmF5KGRvd25sb2FkVGFyZ2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmMoZ2wsIGdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiwgcm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsMiwgY2hhbm5lbHNQZXJQaXhlbCwgZG93bmxvYWRUYXJnZXQsIGJ1ZmZlclNpemVCeXRlcywgYnVmZmVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBnbDIgPSBnbDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHNQZXJQaXhlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVGFyZ2V0ID0gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyU2l6ZUJ5dGVzID0gZG93bmxvYWRUYXJnZXQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRUYXJnZXQubGVuZ3RoICogNCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5idWZmZXJEYXRhKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyU2l6ZUJ5dGVzLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsMi5yZWFkUGl4ZWxzKDAsIDAsIGNvbHVtbnMsIHJvd3MsIGdsLlJHQkEsIGdldFRleHR1cmVUeXBlKGdsKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbi5nZXRCdWZmZXJTdWJEYXRhQXN5bmMoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCAwLCBkb3dubG9hZFRhcmdldCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGRlY29kZURvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIoZG93bmxvYWRUYXJnZXQsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYyA9IGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYztcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgY2hhbm5lbHNQZXJQaXhlbCA9IDQ7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0ID0gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIGRvd25sb2FkVGFyZ2V0KTsgfSk7XG4gICAgcmV0dXJuIGRlY29kZURvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIoZG93bmxvYWRUYXJnZXQsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpO1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlID0gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZTtcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzKSB7XG4gICAgdmFyIHNpemUgPSByb3dzICogY29sdW1ucyAqIDQ7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgY29sdW1ucywgcm93cywgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZG93bmxvYWRUYXJnZXQpOyB9KTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb3dubG9hZFRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYWNrZWRSR0JBW2ldID0gZG93bmxvYWRUYXJnZXRbaV07XG4gICAgfVxuICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zICogY2hhbm5lbHMpO1xuICAgIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5KHBhY2tlZFJHQkEsIG1hdHJpeCwgY2hhbm5lbHMpO1xuICAgIHJldHVybiBtYXRyaXg7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUgPSBkb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlO1xuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgZ2wuUkdCQSwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBwYWNrZWRSR0JBKTsgfSk7XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkocm93cyAqIGNvbHVtbnMpO1xuICAgIHJldHVybiB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShwYWNrZWRSR0JBLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpO1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlID0gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgV2hlcmVQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaGVyZVByb2dyYW0oY1JhbmssIHNoYXBlLCByYW5rKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnYycsICdhJywgJ2InXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHNoYXBlO1xuICAgICAgICB2YXIgY0Nvb3JkcztcbiAgICAgICAgdmFyIGFiQ29vcmRzO1xuICAgICAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiV2hlcmUgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIGFiQ29vcmRzID0gXCJyZXNSQ1wiO1xuICAgICAgICAgICAgY0Nvb3JkcyA9IFwicmVzUkNcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29vcmRzID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53J107XG4gICAgICAgICAgICB2YXIgY0Nvb3JkVmFycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFiQ29vcmRWYXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWJDb29yZFZhcnMucHVzaChcIlwiICsgY3VycmVudENvb3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBjUmFuaykge1xuICAgICAgICAgICAgICAgICAgICBjQ29vcmRWYXJzLnB1c2goXCJcIiArIGN1cnJlbnRDb29yZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNDb29yZHMgPSBjQ29vcmRWYXJzLmpvaW4oKTtcbiAgICAgICAgICAgIGFiQ29vcmRzID0gYWJDb29yZFZhcnMuam9pbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGNWYWwgPSBnZXRDKFwiICsgY0Nvb3JkcyArIFwiKTtcXG4gICAgICAgIGlmIChjVmFsID49IDEuMCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIGFiQ29vcmRzICsgXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRCKFwiICsgYWJDb29yZHMgKyBcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBXaGVyZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5XaGVyZVByb2dyYW0gPSBXaGVyZVByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dpY2FsX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMUk5Qcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMUk5Qcm9ncmFtKHhTaGFwZSwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgcmFkID0gcmFkaXVzO1xuICAgICAgICB2YXIgbWF4RCA9IHhTaGFwZVszXSAtIDE7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICAgIHZhciBwb3dPcGVyYXRvcjtcbiAgICAgICAgdmFyIGJhc2lzID0gXCJmbG9hdChcIiArIGJpYXMgKyBcIikgKyBmbG9hdChcIiArIGFscGhhICsgXCIpICogc3VtXCI7XG4gICAgICAgIGlmIChiZXRhID09PSAwLjUpIHtcbiAgICAgICAgICAgIHBvd09wZXJhdG9yID0gXCJpbnZlcnNlc3FydChcIiArIGJhc2lzICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmV0YSA9PT0gMS4wKSB7XG4gICAgICAgICAgICBwb3dPcGVyYXRvciA9IFwiMS4wLyhcIiArIGJhc2lzICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3dPcGVyYXRvciA9IFwiZXhwKGxvZyhcIiArIGJhc2lzICsgXCIpICogZmxvYXQoLVwiICsgYmV0YSArIFwiKSk7XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYKGIsIHIsIGMsIGQpO1xcbiAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC1cIiArIHJhZCArIFwiOyBqIDw9IFwiICsgcmFkICsgXCI7IGorKykge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZCArIGo7XFxuICAgICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPD0gIFwiICsgbWF4RCArIFwiKSB7XFxuICAgICAgICAgICAgZmxvYXQgeiA9IGdldFgoYiwgciwgYywgaWR4KTtcXG4gICAgICAgICAgICBzdW0gKz0geiAqIHo7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IHZhbCA9IHggKiBcIiArIHBvd09wZXJhdG9yICsgXCI7XFxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTFJOUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkxSTlByb2dyYW0gPSBMUk5Qcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bHJuX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ21heFBvcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoIC0gMTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyBjb252SW5mby5vdXRXaWR0aCArIFwiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiICsgbGFzdEluZGV4ICsgXCIgLSBpbnQoZ2V0TWF4UG9zKGIsIGlkeVIsIGlkeUMsIGQpKTtcXG5cXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9IHdSICogXCIgKyBmaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk1heFBvb2wyREJhY2twcm9wUHJvZ3JhbSA9IE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heF9wb29sX2JhY2twcm9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXRNdWxQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRNdWxQcm9ncmFtKGFTaGFwZSwgYlNoYXBlLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKSB7XG4gICAgICAgIGlmICh0cmFuc3Bvc2VBID09PSB2b2lkIDApIHsgdHJhbnNwb3NlQSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0cmFuc3Bvc2VCID09PSB2b2lkIDApIHsgdHJhbnNwb3NlQiA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnbWF0cml4QScsICdtYXRyaXhCJ107XG4gICAgICAgIHZhciBvdXRlclNoYXBlQSA9IHRyYW5zcG9zZUEgPyBhU2hhcGVbMV0gOiBhU2hhcGVbMF07XG4gICAgICAgIHZhciBvdXRlclNoYXBlQiA9IHRyYW5zcG9zZUIgPyBiU2hhcGVbMF0gOiBiU2hhcGVbMV07XG4gICAgICAgIHZhciBzaGFyZWREaW0gPSB0cmFuc3Bvc2VBID8gYVNoYXBlWzBdIDogYVNoYXBlWzFdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW291dGVyU2hhcGVBLCBvdXRlclNoYXBlQl07XG4gICAgICAgIHZhciBhU25pcHBldEZyb21PZmZzZXQgPSBmdW5jdGlvbiAodmVjNE9mZnNldCwgaW5kZXhWYXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc3Bvc2VBID8gaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldCArIFwiLCBhUm93XCIgOlxuICAgICAgICAgICAgICAgIFwiYVJvdywgXCIgKyBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYlNuaXBwZXRGcm9tT2Zmc2V0ID0gZnVuY3Rpb24gKHZlYzRPZmZzZXQsIGluZGV4VmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNwb3NlQiA/IFwiYkNvbCwgXCIgKyBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0IDpcbiAgICAgICAgICAgICAgICBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0ICsgXCIsIGJDb2xcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNoYXJlZERpbU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihzaGFyZWREaW0gLyA0KSAqIDQ7XG4gICAgICAgIHZhciBzaGFyZWREaW1WZWM0UmVtYWluZGVyID0gc2hhcmVkRGltICUgNDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiIGZsb2F0IGRvdEFSb3dCQ29sKGludCBhUm93LCBpbnQgYkNvbCkge1xcbiAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgc2hhcmVkRGltTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICB2ZWM0IGEgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgyLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDMsICdpJykgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWM0IGIgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMSwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgyLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDMsICdpJykgKyBcIilcXG4gICAgICAgICk7XFxuXFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgcmVzdWx0ICs9IGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpICpcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIik7XFxuICAgICAgfSBlbHNlIGlmIChcIiArIChzaGFyZWREaW1WZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICB2ZWMyIGEgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMyIGIgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgdmVjMyBhID0gdmVjMyhcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDIsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHZlYzMgYiA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgyLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBpdmVjMiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChkb3RBUm93QkNvbChyZXNSQy54LCByZXNSQy55KSk7XFxuICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBNYXRNdWxQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTWF0TXVsUHJvZ3JhbSA9IE1hdE11bFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWxtYXRfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE11bHRpbm9taWFsUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlub21pYWxQcm9ncmFtKGJhdGNoU2l6ZSwgbnVtT3V0Y29tZXMsIG51bVNhbXBsZXMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydwcm9icyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgbnVtU2FtcGxlc107XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgc2VlZDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG5cXG4gICAgICAgIGZsb2F0IHIgPSByYW5kb20oc2VlZCk7XFxuICAgICAgICBmbG9hdCBjZGYgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgKG51bU91dGNvbWVzIC0gMSkgKyBcIjsgaSsrKSB7XFxuICAgICAgICAgIGNkZiArPSBnZXRQcm9icyhiYXRjaCwgaSk7XFxuXFxuICAgICAgICAgIGlmIChyIDwgY2RmKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGkpKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIElmIG5vIG90aGVyIGV2ZW50IGhhcHBlbmVkLCBsYXN0IGV2ZW50IGhhcHBlbmVkLlxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiICsgKG51bU91dGNvbWVzIC0gMSkgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIE11bHRpbm9taWFsUHJvZ3JhbS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2VlZExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VlZExvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdzZWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWYoX3RoaXMuc2VlZExvYywgc2VlZCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGlub21pYWxQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTXVsdGlub21pYWxQcm9ncmFtID0gTXVsdGlub21pYWxQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlub21pYWxfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9uZUhvdFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9uZUhvdFByb2dyYW0obnVtSW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnaW5kaWNlcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW251bUluZGljZXMsIGRlcHRoXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkcy54KSk7XFxuICAgICAgICBzZXRPdXRwdXQobWl4KGZsb2F0KFwiICsgb2ZmVmFsdWUgKyBcIiksIGZsb2F0KFwiICsgb25WYWx1ZSArIFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXQoaW5kZXggPT0gY29vcmRzLnkpKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE9uZUhvdFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5PbmVIb3RQcm9ncmFtID0gT25lSG90UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZWhvdF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgUGFkUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFkUHJvZ3JhbSh4U2hhcGUsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdICsgeFNoYXBlW2ldICsgcFsxXTsgfSk7XG4gICAgICAgIHZhciByYW5rID0geFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwWzBdOyB9KS5qb2luKCcsJyk7XG4gICAgICAgIHZhciBlbmQgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIHBbMF0gKyB4U2hhcGVbaV07IH0pLmpvaW4oJywnKTtcbiAgICAgICAgdmFyIHVucGFja2VkQ29vcmRzID0gWydjb29yZHNbMF0nLCAnY29vcmRzWzFdJywgJ2Nvb3Jkc1syXScsICdjb29yZHNbM10nXS5zbGljZSgwLCByYW5rKTtcbiAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgaW50IHN0YXJ0ID0gXCIgKyBzdGFydCArIFwiO1xcbiAgICAgICAgaW50IGVuZCA9IFwiICsgZW5kICsgXCI7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGlmIChvdXRDIDwgc3RhcnQgfHwgb3V0QyA+PSBlbmQpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIgKyBjb25zdGFudFZhbHVlICsgXCIpKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChvdXRDIC0gc3RhcnQpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIFwiICsgdHlwZSArIFwiIHN0YXJ0ID0gXCIgKyB0eXBlICsgXCIoXCIgKyBzdGFydCArIFwiKTtcXG4gICAgICBcIiArIHR5cGUgKyBcIiBlbmQgPSBcIiArIHR5cGUgKyBcIihcIiArIGVuZCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIHR5cGUgKyBcIiBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoYW55KGxlc3NUaGFuKG91dEMsIHN0YXJ0KSkgfHwgYW55KGdyZWF0ZXJUaGFuRXF1YWwob3V0QywgZW5kKSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiICsgY29uc3RhbnRWYWx1ZSArIFwiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBcIiArIHR5cGUgKyBcIiBjb29yZHMgPSBvdXRDIC0gc3RhcnQ7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKFwiICsgdW5wYWNrZWRDb29yZHMgKyBcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBQYWRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUGFkUHJvZ3JhbSA9IFBhZFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWRfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBvb2wyRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvb2wyRFByb2dyYW0oY29udkluZm8sIHBvb2xUeXBlLCBjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICBpZiAocG9vbFR5cGUgPT09ICdhdmcnICYmIGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciBpc0F2Z1Bvb2wgPSBwb29sVHlwZSA9PT0gJ2F2Zyc7XG4gICAgICAgIHZhciBpbml0aWFsaXphdGlvblZhbHVlID0gJzAuMCc7XG4gICAgICAgIGlmICghaXNBdmdQb29sKSB7XG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAwLjAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZU9wXzEgPSAnPj0nO1xuICAgICAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XFxuICAgICAgICAgIGludCBtaW5NYXhQb3NpdGlvbiA9IDA7XFxuICAgICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkKTtcXG5cXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgXCIgKyBjb21wYXJlT3BfMSArIFwiIGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IHdSICogXCIgKyBmaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSAnbWF4JztcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gcG9vbFR5cGUgKyBcIihcIiArIHBvb2xUeXBlICsgXCIoXCIgKyBwb29sVHlwZSArIFwiKFwiICtcbiAgICAgICAgICAgICdtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKSc7XG4gICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gXCJhdmdWYWx1ZSAvIGNvdW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKGZpbHRlcldpZHRoIC8gNCkgKiA0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID0gZmlsdGVyV2lkdGggJSA0O1xuICAgICAgICB2YXIgdXBkYXRlU25pcHBldCA9IFwiXFxuICAgICAgaWYgKFwiICsgaXNBdmdQb29sICsgXCIpIHtcXG4gICAgICAgIGF2Z1ZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiICsgY29tcGFyZU9wICsgXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGNvdW50ID0gMC4wO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhSLCBpbnQgeEMsIGludCBkKSB7XFxuICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgY29udkluZm8uaW5XaWR0aCArIFwiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgY291bnQgKz0gMS4wO1xcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIik7XFxuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG4gICAgICAgIGNvdW50ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIGNvbnZJbmZvLmluSGVpZ2h0ICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ICsgXCI7IHdDICs9IDQpIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDEsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDMsIGQpXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgXCIgKyBmaWx0ZXJXaWR0aE5lYXJlc3RWZWM0ICsgXCI7XFxuICAgICAgICAgIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAxLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDEsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiICsgcmV0dXJuVmFsdWUgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFBvb2wyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Qb29sMkRQcm9ncmFtID0gUG9vbDJEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvb2xfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlZHVjZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZHVjZVByb2dyYW0ocmVkdWNlSW5mbywgcmVkdWNlVHlwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VJbmZvLndpbmRvd1NpemU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSByZWR1Y2VJbmZvLmJhdGNoU2l6ZTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHJlZHVjZUluZm8uaW5TaXplO1xuICAgICAgICB2YXIgb3V0U2l6ZSA9IE1hdGguY2VpbChpblNpemUgLyB3aW5kb3dTaXplKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dFNpemVdO1xuICAgICAgICB2YXIgaXNSZWR1Y2VTdW0gPSByZWR1Y2VUeXBlID09PSAnc3VtJztcbiAgICAgICAgdmFyIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgaWYgKCFpc1JlZHVjZVN1bSkge1xuICAgICAgICAgICAgaWYgKHJlZHVjZVR5cGUgPT09ICdtaW4nKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcxLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICctMS4wIC8gMC4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGFyZU9wID0gcmVkdWNlVHlwZSA9PT0gJ21pbicgPyAnbWluJyA6ICdtYXgnO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSByZWR1Y2VUeXBlICsgXCIoXCIgKyByZWR1Y2VUeXBlICsgXCIoXCIgKyByZWR1Y2VUeXBlICsgXCIoXCIgK1xuICAgICAgICAgICAgJ21pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pJztcbiAgICAgICAgaWYgKHJlZHVjZVR5cGUgPT09ICdzdW0nKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwic3VtVmFsdWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93U2l6ZU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcih3aW5kb3dTaXplIC8gNCkgKiA0O1xuICAgICAgICB2YXIgd2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPSB3aW5kb3dTaXplICUgNDtcbiAgICAgICAgdmFyIHVwZGF0ZVNuaXBwZXQgPSBcIlxcbiAgICAgIGlmIChcIiArIGlzUmVkdWNlU3VtICsgXCIpIHtcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiICsgY29tcGFyZU9wICsgXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdmFyIGNoZWNrT3V0T2ZCb3VuZHMgPSAnJztcbiAgICAgICAgaWYgKGluU2l6ZSAlIHdpbmRvd1NpemUgPiAwKSB7XG4gICAgICAgICAgICBjaGVja091dE9mQm91bmRzID0gXCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIgKyBpblNpemUgKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIiArIGNoZWNrT3V0T2ZCb3VuZHMgKyBcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIgKyB3aW5kb3dTaXplICsgXCI7XFxuXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIik7XFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjtcXG4gICAgICAgIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiICsgcmV0dXJuVmFsdWUgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlZHVjZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZWR1Y2VQcm9ncmFtID0gUmVkdWNlUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVzaXplQmlsaW5lYXJCYWNrcHJvcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZUJpbGluZWFyQmFja3Byb3BQcm9ncmFtKGR5LCB4LCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4LnNoYXBlO1xuICAgICAgICB2YXIgX2EgPSB4LnNoYXBlLCB4SGVpZ2h0ID0gX2FbMV0sIHhXaWR0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgX2IgPSBkeS5zaGFwZSwgeUhlaWdodCA9IF9iWzFdLCB5V2lkdGggPSBfYlsyXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZVhTaXplID0gW1xuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiB5SGVpZ2h0ID4gMSkgPyB4SGVpZ2h0IC0gMSA6IHhIZWlnaHQsXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlXaWR0aCA+IDEpID8geFdpZHRoIC0gMSA6IHhXaWR0aFxuICAgICAgICBdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlWVNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIHlIZWlnaHQgPiAxKSA/IHlIZWlnaHQgLSAxIDogeUhlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgeVdpZHRoID4gMSkgPyB5V2lkdGggLSAxIDogeVdpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHZhciBoZWlnaHRTY2FsZSA9IGVmZmVjdGl2ZVhTaXplWzBdIC8gZWZmZWN0aXZlWVNpemVbMF07XG4gICAgICAgIHZhciB3aWR0aFNjYWxlID0gZWZmZWN0aXZlWFNpemVbMV0gLyBlZmZlY3RpdmVZU2l6ZVsxXTtcbiAgICAgICAgdmFyIGludkhlaWdodFNjYWxlID0gMSAvIGhlaWdodFNjYWxlO1xuICAgICAgICB2YXIgaW52V2lkdGhTY2FsZSA9IDEgLyB3aWR0aFNjYWxlO1xuICAgICAgICB2YXIgd2luSGVpZ2h0ID0gKE1hdGguY2VpbChpbnZIZWlnaHRTY2FsZSkgKiAyKSArIDI7XG4gICAgICAgIHZhciB3aW5XaWR0aCA9IChNYXRoLmNlaWwoaW52V2lkdGhTY2FsZSkgKiAyKSArIDI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIgKyBoZWlnaHRTY2FsZSArIFwiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IHdpZHRoU2NhbGUgPSBmbG9hdChcIiArIHdpZHRoU2NhbGUgKyBcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiICsgaW52SGVpZ2h0U2NhbGUgKyBcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZXaWR0aFNjYWxlID0gZmxvYXQoXCIgKyBpbnZXaWR0aFNjYWxlICsgXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIiArIHdpbkhlaWdodCArIFwiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIiArIHdpbldpZHRoICsgXCIpO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xcbiAgICAgICAgZmxvYXQgc3RhcnRSTGVycCA9IGZsb29yKGZsb2F0KHIpICogaW52SGVpZ2h0U2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdGFydENMZXJwID0gZmxvb3IoZmxvYXQoYykgKiBpbnZXaWR0aFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5QyA9IGludChzdGFydENMZXJwIC0gZmxvYXQod2luV2lkdGggLyAyKSk7XFxuXFxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcXG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcXG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xcblxcbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IFwiICsgeUhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XFxuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xcblxcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBcIiArIHlXaWR0aCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHhSID0gZmxvYXQoZHlSKSAqIGhlaWdodFNjYWxlO1xcbiAgICAgICAgICAgIGludCB0b3BEeFJJbmRleCA9IGludChmbG9vcihkeFIpKTtcXG4gICAgICAgICAgICBpbnQgYm90dG9tRHhSSW5kZXggPSBpbnQobWluKGNlaWwoZHhSKSwgXCIgKyAoeEhlaWdodCAtIDEpICsgXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4UkxlcnAgPSBkeFIgLSBmbG9hdCh0b3BEeFJJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4UkxlcnAgPSAxLjAgLSBkeFJMZXJwO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR4QyA9IGZsb2F0KGR5QykgKiB3aWR0aFNjYWxlO1xcbiAgICAgICAgICAgIGludCBsZWZ0RHhDSW5kZXggPSBpbnQoZmxvb3IoZHhDKSk7XFxuICAgICAgICAgICAgaW50IHJpZ2h0RHhDSW5kZXggPSBpbnQobWluKGNlaWwoZHhDKSwgXCIgKyAoeFdpZHRoIC0gMSkgKyBcIi4wKSk7XFxuICAgICAgICAgICAgZmxvYXQgZHhDTGVycCA9IGR4QyAtIGZsb2F0KGxlZnREeENJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4Q0xlcnAgPSAxLjAgLSBkeENMZXJwO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyB0b3BMZWZ0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPVxcbiAgICAgICAgICAgICAgICBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIHRvcFJpZ2h0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyBib3R0b21MZWZ0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gYm90dG9tUmlnaHRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGR4UkxlcnAgKiBkeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRW5kIGxvb3Agb3ZlciBkeVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGFjY3VtdWxhdG9yKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVzaXplQmlsaW5lYXJCYWNrcHJvcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZXNpemVCaWxpbmVhckJhY2twcm9wUHJvZ3JhbSA9IFJlc2l6ZUJpbGluZWFyQmFja3Byb3BQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaXplX2JpbGluZWFyX2JhY2twcm9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXNpemVCaWxpbmVhclByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZUJpbGluZWFyUHJvZ3JhbShpbnB1dFNoYXBlLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGJhdGNoID0gaW5wdXRTaGFwZVswXSwgb2xkSGVpZ2h0ID0gaW5wdXRTaGFwZVsxXSwgb2xkV2lkdGggPSBpbnB1dFNoYXBlWzJdLCBkZXB0aCA9IGlucHV0U2hhcGVbM107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGRlcHRoXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUluU2l6ZSA9IFtcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3SGVpZ2h0ID4gMSkgPyBvbGRIZWlnaHQgLSAxIDogb2xkSGVpZ2h0LFxuICAgICAgICAgICAgKGFsaWduQ29ybmVycyAmJiBuZXdXaWR0aCA+IDEpID8gb2xkV2lkdGggLSAxIDogb2xkV2lkdGhcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dFNpemUgPSBbXG4gICAgICAgICAgICAoYWxpZ25Db3JuZXJzICYmIG5ld0hlaWdodCA+IDEpID8gbmV3SGVpZ2h0IC0gMSA6IG5ld0hlaWdodCxcbiAgICAgICAgICAgIChhbGlnbkNvcm5lcnMgJiYgbmV3V2lkdGggPiAxKSA/IG5ld1dpZHRoIC0gMSA6IG5ld1dpZHRoXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5TaXplWzBdIC8gZWZmZWN0aXZlT3V0U2l6ZVswXSArIFwiLFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUluU2l6ZVsxXSAvIGVmZmVjdGl2ZU91dFNpemVbMV0gKyBcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiICsgb2xkSGVpZ2h0ICsgXCIuMCwgXCIgKyBvbGRXaWR0aCArIFwiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVCaWxpbmVhclByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZXNpemVCaWxpbmVhclByb2dyYW0gPSBSZXNpemVCaWxpbmVhclByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNpemVfYmlsaW5lYXJfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlc2l6ZU5lYXJlc3ROZWlnaGJvclByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU5lYXJlc3ROZWlnaGJvclByb2dyYW0oaW5wdXRTaGFwZSwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHZhciBiYXRjaCA9IGlucHV0U2hhcGVbMF0sIG9sZEhlaWdodCA9IGlucHV0U2hhcGVbMV0sIG9sZFdpZHRoID0gaW5wdXRTaGFwZVsyXSwgZGVwdGggPSBpbnB1dFNoYXBlWzNdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBkZXB0aF07XG4gICAgICAgIHZhciBlZmZlY3RpdmVJblNpemUgPSBhbGlnbkNvcm5lcnMgPyBbb2xkSGVpZ2h0IC0gMSwgb2xkV2lkdGggLSAxXSA6IFtvbGRIZWlnaHQsIG9sZFdpZHRoXTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dFNpemUgPSBhbGlnbkNvcm5lcnMgPyBbbmV3SGVpZ2h0IC0gMSwgbmV3V2lkdGggLSAxXSA6IFtuZXdIZWlnaHQsIG5ld1dpZHRoXTtcbiAgICAgICAgdmFyIHJvdW5kQmFzZSA9IGFsaWduQ29ybmVycyA/ICcwLjUnIDogJzAuMCc7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5TaXplWzBdIC8gZWZmZWN0aXZlT3V0U2l6ZVswXSArIFwiLFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUluU2l6ZVsxXSAvIGVmZmVjdGl2ZU91dFNpemVbMV0gKyBcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiICsgb2xkSGVpZ2h0ICsgXCIuMCwgXCIgKyBvbGRXaWR0aCArIFwiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZU5lYXJlc3RSQyA9IGl2ZWMyKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBmbG9vcihzb3VyY2VGcmFjSW5kZXhSQyArIFwiICsgcm91bmRCYXNlICsgXCIpKSk7XFxuXFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEEoYiwgc291cmNlTmVhcmVzdFJDLngsIHNvdXJjZU5lYXJlc3RSQy55LCBkKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU5lYXJlc3ROZWlnaGJvclByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZXNpemVOZWFyZXN0TmVpZ2hib3JQcm9ncmFtID0gUmVzaXplTmVhcmVzdE5laWdoYm9yUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2l6ZV9uZWFyZXN0X25laWdoYm9yX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBSZXZlcnNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV2ZXJzZVByb2dyYW0oeFNoYXBlLCBheGlzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB2YXIgcmFuayA9IHhTaGFwZS5sZW5ndGg7XG4gICAgICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgYmFja2VuZDogUmV2ZXJzZSBvZiByYW5rLVwiICsgcmFuayArIFwiIHRlbnNvciBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBjb29yZCA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIHhTaGFwZVswXSArIFwiIC0gY29vcmQgLSAxKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdldEluQ29vcmQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGF4aXMuaW5kZXhPZihpKSAhPT0gLTEgJiYgeFNoYXBlW2ldICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhTaGFwZVtpXSArIFwiIC0gY29vcmRzW1wiICsgaSArIFwiXSAtIDFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcImNvb3Jkc1tcIiArIGkgKyBcIl1cIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGluQ29vcmRzID0geFNoYXBlLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gZ2V0SW5Db29yZChpKTsgfSkuam9pbignLCcpO1xuICAgICAgICB2YXIgdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIHR5cGUgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiICsgaW5Db29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXZlcnNlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlJldmVyc2VQcm9ncmFtID0gUmV2ZXJzZVByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZlcnNlX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9vcHMvYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbmZ1bmN0aW9uIG1ha2VTaGFkZXIoaW5wdXRzSW5mbywgb3V0cHV0U2hhcGUsIHVzZXJDb2RlLCBicm9hZGNhc3QpIHtcbiAgICB2YXIgc2FtcGxlU25pcHBldCA9IGdldFNhbXBsZVNuaXBwZXQoKTtcbiAgICB2YXIgc2V0T3V0cHV0U25pcHBldCA9IGdldFNldE91dHB1dFNuaXBwZXQoKTtcbiAgICB2YXIgaW5wdXRQcmVmaXhTbmlwcGV0ID0gaW5wdXRzSW5mby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFwidW5pZm9ybSBzYW1wbGVyMkQgXCIgKyB4Lm5hbWUgKyBcIjtcIjsgfSkuam9pbignXFxuJyk7XG4gICAgdmFyIGlucHV0U2FtcGxpbmdTbmlwcGV0ID0gaW5wdXRzSW5mby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGdldElucHV0U2FtcGxpbmdTbmlwcGV0KHgsIG91dHB1dFNoYXBlLCBicm9hZGNhc3QpOyB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG4gICAgdmFyIG91dFRleFNoYXBlID0gb3V0cHV0U2hhcGUudGV4U2hhcGU7XG4gICAgdmFyIG91dHB1dFNhbXBsaW5nU25pcHBldCA9IGdldE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRTaGFwZS5sb2dpY2FsU2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICB2YXIgc291cmNlID0gW1xuICAgICAgICBTSEFERVJfUFJFRklYLCBzYW1wbGVTbmlwcGV0LCBzZXRPdXRwdXRTbmlwcGV0LCBpbnB1dFByZWZpeFNuaXBwZXQsXG4gICAgICAgIG91dHB1dFNhbXBsaW5nU25pcHBldCwgaW5wdXRTYW1wbGluZ1NuaXBwZXQsIHVzZXJDb2RlXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgICByZXR1cm4gc291cmNlO1xufVxuZXhwb3J0cy5tYWtlU2hhZGVyID0gbWFrZVNoYWRlcjtcbmZ1bmN0aW9uIGdldFNhbXBsZVNuaXBwZXQoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykgP1xuICAgICAgICBGTE9BVF9URVhUVVJFX1NBTVBMRV9TTklQUEVUIDpcbiAgICAgICAgVU5TSUdORURfQllURV9URVhUVVJFX1NBTVBMRV9TTklQUEVUO1xufVxuZnVuY3Rpb24gZ2V0U2V0T3V0cHV0U25pcHBldCgpIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSA/XG4gICAgICAgIEZMT0FUX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQgOlxuICAgICAgICBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQ7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyRnJvbUluSW5mbyhpbkluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbkluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlclNjYWxhcihpbkluZm8pO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjFEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyMkQoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXIzRChpbkluZm8pO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjREKGluSW5mbyk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyNUQoaW5JbmZvKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzaGFwZS5sZW5ndGggKyBcIi1EIGlucHV0IHNhbXBsaW5nXCIgK1xuICAgICAgICAgICAgICAgIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldElucHV0U2FtcGxpbmdTbmlwcGV0KGluSW5mbywgb3V0U2hhcGVJbmZvLCBicm9hZGNhc3QpIHtcbiAgICB2YXIgcmVzID0gZ2V0U2FtcGxlckZsYXQoaW5JbmZvKTtcbiAgICByZXMgKz0gZ2V0U2FtcGxlckZyb21JbkluZm8oaW5JbmZvKTtcbiAgICBpZiAoYnJvYWRjYXN0IHx8XG4gICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoaW5JbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsIG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpKSB7XG4gICAgICAgIHJlcyArPSBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoaW5JbmZvLCBvdXRTaGFwZUluZm8sIGJyb2FkY2FzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0U2hhcGUsIG91dFRleFNoYXBlKSB7XG4gICAgc3dpdGNoIChvdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dFNjYWxhckNvb3JkcygpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0MURDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDJEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQzRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0NERDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDVEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3V0U2hhcGUubGVuZ3RoICsgXCItRCBvdXRwdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxudmFyIFNBTVBMRV8xRF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfMkRfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBudW1DLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgaW5kZXggPSByb3cgKiBudW1DICsgY29sO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgU0FNUExFXzNEX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgc3RyaWRlMCxcXG4gICAgaW50IHN0cmlkZTEsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV80RF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTREKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgc3RyaWRlMiwgaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICBpbnQgZGVwdGgyKSB7XFxuICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArIGRlcHRoICogc3RyaWRlMiArIGRlcHRoMjtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV81RF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTVEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgc3RyaWRlMiwgaW50IHN0cmlkZTMsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBcXG4gICAgICAgICAgICAgIGRlcHRoICogc3RyaWRlMiArIGRlcHRoMiAqIHN0cmlkZTMgKyBkZXB0aDM7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQgPSBcIlxcbiAgdW5pZm9ybSBmbG9hdCBOYU47XFxuXFxuICBjb25zdCB2ZWM0IGZsb2F0RGVsdGFzID0gdmVjNChcXG4gICAgICAxLjAsXFxuICAgICAgMS4wIC8gMjU1LjAsXFxuICAgICAgMS4wIC8gKDI1NS4wICogMjU1LjApLFxcbiAgICAgIDEuMCAvICgyNTUuMCAqIDI1NS4wICogMjU1LjApXFxuICApO1xcbiAgY29uc3QgZmxvYXQgbWluVmFsdWUgPSBcIiArIHRleF91dGlsLkZMT0FUX01JTiArIFwiLjA7XFxuICBjb25zdCBmbG9hdCBtYXhWYWx1ZSA9IFwiICsgdGV4X3V0aWwuRkxPQVRfTUFYICsgXCIuMDtcXG4gIGNvbnN0IGZsb2F0IHJhbmdlID0gKG1heFZhbHVlIC0gbWluVmFsdWUpIC8gMjU1LjA7XFxuICBjb25zdCB2ZWMyIGRvdFJhbmdlID0gdmVjMigxLjAsIHJhbmdlKTtcXG5cXG4gIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XFxuICAgIHZlYzQgc2FtcGxlVmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHV2KTtcXG4gICAgaWYgKGFsbChlcXVhbChzYW1wbGVWYWx1ZSwgdmVjNChcIiArIHRleF91dGlsLkJZVEVfTkFOX1ZBTFVFICsgXCIpKSkpIHtcXG4gICAgICByZXR1cm4gTmFOO1xcbiAgICB9XFxuXFxuICAgIHZlYzQgZW5jVmFsdWUgPSBmbG9vcihzYW1wbGVWYWx1ZSAqIDI1NS4wICsgMC41KTtcXG4gICAgZmxvYXQgZGVjb2RlZFZhbHVlID0gZG90KGVuY1ZhbHVlLCBmbG9hdERlbHRhcyk7XFxuICAgIHJldHVybiBkb3QodmVjMihtaW5WYWx1ZSwgZGVjb2RlZFZhbHVlKSwgZG90UmFuZ2UpO1xcbiAgfVxcblwiO1xudmFyIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TRVRPVVRQVVRfU05JUFBFVCA9IFwiXFxuICBjb25zdCB2ZWM0IGZsb2F0UG93ZXJzID0gdmVjNChcXG4gICAgMS4wLFxcbiAgICAyNTUuMCxcXG4gICAgMjU1LjAgKiAyNTUuMCxcXG4gICAgMjU1LjAgKiAyNTUuMCAqIDI1NS4wXFxuICApO1xcbiAgY29uc3QgdmVjMiByZWNpcFJhbmdlID0gdmVjMigxLjAvcmFuZ2UpO1xcbiAgY29uc3QgdmVjMiByZWNpcFJhbmdlMjU1ID0gdmVjMigxLjAvKG1heFZhbHVlIC0gbWluVmFsdWUpKTtcXG5cXG4gIHZvaWQgc2V0T3V0cHV0KGZsb2F0IGRlY29kZWRWYWx1ZSkge1xcbiAgICBpZiAoaXNOYU4oZGVjb2RlZFZhbHVlKSkge1xcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoXCIgKyB0ZXhfdXRpbC5CWVRFX05BTl9WQUxVRSArIFwiKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgYSA9IGRvdCh2ZWMyKGRlY29kZWRWYWx1ZSwgLW1pblZhbHVlKSwgcmVjaXBSYW5nZSk7XFxuICAgIGZsb2F0IGIgPSBmcmFjdChhKSAqIDI1NS4wO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoYikgKiAyNTUuMDtcXG4gICAgZmxvYXQgZCA9IGZyYWN0KGMpICogMjU1LjA7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGZsb29yKHZlYzQoYSwgYiwgYywgZCkpIC8gMjU1LjA7XFxuXFxuICAgIC8vIFRPRE8oZHNtaWxrb3YpOiBWZXJzaW9uIGFib3ZlIGdldHMgYmV0dGVyIGFjY3VyYWN5IGJ1dCBwcm9iYWJseSBzbG93ZXJcXG4gICAgLy8gdGhhbiB0aGUgdmVyc2lvbiBiZWxvdy4gQmVuY2htYXJrIHRvIGRldGVybWluZSBpZiB0aGUgYWNjdXJhY3kgaXMgd29ydGhcXG4gICAgLy8gdGhlIGNvc3QuXFxuXFxuICAgIC8vIGZsb2F0IG5vcm1WYWx1ZSA9IGRvdCh2ZWMyKGRlY29kZWRWYWx1ZSwgLW1pblZhbHVlKSwgcmVjaXBSYW5nZTI1NSk7XFxuICAgIC8vIHZlYzQgZiA9IG5vcm1WYWx1ZSAqIGZsb2F0UG93ZXJzO1xcbiAgICAvLyBnbF9GcmFnQ29sb3IgPSBmbG9vcihmcmFjdChmKSAqIDI1NS4wKSAvIDI1NS4wO1xcbiAgfVxcblwiO1xudmFyIEZMT0FUX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQgPSBcIlxcbiAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcXG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICB9XFxuXCI7XG52YXIgRkxPQVRfVEVYVFVSRV9TRVRPVVRQVVRfU05JUFBFVCA9IFwiXFxuICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2YWwsIDAsIDAsIDApO1xcbiAgfVxcblwiO1xudmFyIFNIQURFUl9QUkVGSVggPSBcIlxcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcXG4gIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XFxuXFxuICBzdHJ1Y3QgaXZlYzVcXG4gIHtcXG4gICAgaW50IHg7XFxuICAgIGludCB5O1xcbiAgICBpbnQgejtcXG4gICAgaW50IHc7XFxuICAgIGludCB1O1xcbiAgfTtcXG5cXG4gIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XFxuICAgIGZsb2F0IHYxID0gdmFsICogdmFsO1xcbiAgICBmbG9hdCB2MiA9IHZhbCAqIHZhbDtcXG4gICAgcmV0dXJuIHYxID09IHYyID8gZmFsc2UgOiB0cnVlO1xcbiAgfVxcblxcbiAgYm9vbCBoYXNOYU4odmVjNCB2YWx1ZXMpIHtcXG4gICAgdmVjNCB2MSA9IHZhbHVlcyAqIHZhbHVlcztcXG4gICAgdmVjNCB2MiA9IHZhbHVlcyAqIHZhbHVlcztcXG4gICAgcmV0dXJuIGFueShub3RFcXVhbCh2MSwgdjIpKTtcXG4gIH1cXG5cXG4gIGZsb2F0IGdldE5hTih2ZWM0IHZhbHVlcykge1xcbiAgICByZXR1cm4gZG90KHZlYzQoMSksIHZhbHVlcyk7XFxuICB9XFxuXFxuICBpbnQgcm91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgfVxcblxcbiAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XFxuICB9XFxuXFxuICAvL0Jhc2VkIG9uIHRoZSB3b3JrIG9mIERhdmUgSG9za2luc1xcbiAgLy9odHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNGRqU1JXXFxuICAjZGVmaW5lIEhBU0hTQ0FMRTEgNDQzLjg5NzVcXG4gIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKXtcXG4gICAgdmVjMiBwID0gcmVzdWx0VVYgKiBzZWVkO1xcbiAgICB2ZWMzIHAzICA9IGZyYWN0KHZlYzMocC54eXgpICogSEFTSFNDQUxFMSk7XFxuICAgIHAzICs9IGRvdChwMywgcDMueXp4ICsgMTkuMTkpO1xcbiAgICByZXR1cm4gZnJhY3QoKHAzLnggKyBwMy55KSAqIHAzLnopO1xcbiAgfVxcblxcbiAgXCIgKyBTQU1QTEVfMURfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV8yRF9TTklQUEVUICsgXCJcXG4gIFwiICsgU0FNUExFXzNEX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfNERfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV81RF9TTklQUEVUICsgXCJcXG5cIjtcbmZ1bmN0aW9uIGdldE91dHB1dFNjYWxhckNvb3JkcygpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQxRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICBpZiAodGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4U2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueSAqIFwiICsgdGV4U2hhcGVbMF0gKyBcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0M0RDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl07XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzdHJpZGUwICsgXCI7XFxuICAgICAgaW5kZXggLT0gciAqIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGludCBjID0gaW5kZXggLyBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICBpbnQgZCA9IGluZGV4IC0gYyAqIFwiICsgc3RyaWRlMSArIFwiO1xcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQ0RENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGluZGV4IC09IHIgKiBcIiArIHN0cmlkZTAgKyBcIjtcXG5cXG4gICAgICBpbnQgYyA9IGluZGV4IC8gXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgaW5kZXggLT0gYyAqIFwiICsgc3RyaWRlMSArIFwiO1xcblxcbiAgICAgIGludCBkID0gaW5kZXggLyBcIiArIHN0cmlkZTIgKyBcIjtcXG4gICAgICBpbnQgZDIgPSBpbmRleCAtIGQgKiBcIiArIHN0cmlkZTIgKyBcIjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDVEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIHZhciBzdHJpZGUzID0gc2hhcGVbNF07XG4gICAgdmFyIHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG5cXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzdHJpZGUwICsgXCI7XFxuICAgICAgaW5kZXggLT0gciAqIFwiICsgc3RyaWRlMCArIFwiO1xcblxcbiAgICAgIGludCBjID0gaW5kZXggLyBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICBpbmRleCAtPSBjICogXCIgKyBzdHJpZGUxICsgXCI7XFxuXFxuICAgICAgaW50IGQgPSBpbmRleCAvIFwiICsgc3RyaWRlMiArIFwiO1xcbiAgICAgIGluZGV4IC09IGQgKiBcIiArIHN0cmlkZTIgKyBcIjtcXG5cXG4gICAgICBpbnQgZDIgPSBpbmRleCAgLyBcIiArIHN0cmlkZTMgKyBcIjtcXG4gICAgICBpbnQgZDMgPSBpbmRleCAtIGQyICogXCIgKyBzdHJpZGUzICsgXCI7XFxuXFxuICAgICAgaXZlYzUgb3V0U2hhcGUgPSBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xcbiAgICAgIHJldHVybiBvdXRTaGFwZTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQyRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAoc2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKGluZGV4LCAwKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAoc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKDAsIGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gaW5kZXggLyBcIiArIHNoYXBlWzFdICsgXCI7XFxuICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiBcIiArIHNoYXBlWzFdICsgXCI7XFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJTY2FsYXIoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIGhhbGZDUik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjFEKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCJGbGF0KGluZGV4KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyMkQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIGlmICh1dGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICB2YXIgX2EgPSB1dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgdmFyIHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIgKyBzaGFwZVsxXSArIFwiICsgY29sO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bVIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIgKyBzaGFwZVsxXSArIFwiICsgY29sO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0ZXhOdW1DICsgXCIuMCwgMC41KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICB2ZWMyIHV2ID0gVVZmcm9tMkQoXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHNoYXBlWzFdICsgXCIsIHJvdywgY29sKTtcXG4gICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gIH1cXG5cIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXIzRChpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl07XG4gICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIHZhciBzcXVlZXplZFNoYXBlID0gbmV3U2hhcGU7XG4gICAgaWYgKHNxdWVlemVkU2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dEluZm8gPSBzcXVlZXplSW5wdXRJbmZvKGlucHV0SW5mbywgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnXTtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUwKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgICAgaW50IHRleEMgPSBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgIGludCB0ZXhSID0gcm93ICogXCIgKyBzaGFwZVsxXSArIFwiICsgY29sO1xcbiAgICAgIGludCB0ZXhDID0gZGVwdGg7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSBVVmZyb20zRChcXG4gICAgICAgICAgICBcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc3RyaWRlMCArIFwiLCBcIiArIHN0cmlkZTEgKyBcIiwgcm93LCBjb2wsIGRlcHRoKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyNEQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIHZhciBzdHJpZGUyID0gc2hhcGVbM107XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgZ2V0U2FtcGxlckZyb21JbkluZm8obmV3SW5wdXRJbmZvKSArIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUwKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgaW50IHRleEMgPSBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoICogXCIgKyBzdHJpZGUyICsgXCIgKyBkZXB0aDI7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTIpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgaW50IHRleFIgPSByb3cgKiBcIiArIHNoYXBlWzFdICogc2hhcGVbMl0gKyBcIiArIGNvbCAqIFwiICsgc2hhcGVbMl0gKyBcIiArIGRlcHRoO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDI7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb200RChcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc3RyaWRlMCArIFwiLCBcIiArIHN0cmlkZTEgKyBcIixcXG4gICAgICAgICAgXCIgKyBzdHJpZGUyICsgXCIsIHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXI1RChpbnB1dEluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIHN0cmlkZTMgPSBzaGFwZVs0XTtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdICogc3RyaWRlMztcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcbiAgICB2YXIgX2EgPSB1dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInLCAnZGVwdGgzJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgZ2V0U2FtcGxlckZyb21JbkluZm8obmV3SW5wdXRJbmZvKSArIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUwKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgaW50IHRleEMgPSBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoICogXCIgKyBzdHJpZGUyICsgXCIgK1xcbiAgICAgICAgICAgICAgICAgICBkZXB0aDIgKiBcIiArIHN0cmlkZTMgKyBcIiArIGRlcHRoMztcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMykge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKiBzaGFwZVsyXSArIFwiICsgY29sICogXCIgKyBzaGFwZVsyXSArIFwiICtcXG4gICAgICAgICAgICAgICAgICAgZGVwdGggKiBcIiArIHNoYXBlWzNdICsgXCIgKyBkZXB0aDI7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoMztcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgdmVjMiB1diA9IFVWZnJvbTVEKFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgXCIgKyBzdHJpZGUwICsgXCIsIFwiICsgc3RyaWRlMSArIFwiLFxcbiAgICAgICAgICBcIiArIHN0cmlkZTIgKyBcIiwgXCIgKyBzdHJpZGUzICsgXCIsIHJvdywgY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckZsYXQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSkgKyAnRmxhdCc7XG4gICAgdmFyIHROdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHROdW1DID0gdGV4U2hhcGVbMV07XG4gICAgaWYgKHROdW1DID09PSAxICYmIHROdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0TnVtQyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodE51bVIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHROdW1DICsgXCIuMCwgMC41KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tMUQoXCIgKyB0TnVtUiArIFwiLCBcIiArIHROdW1DICsgXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldEJyb2FkY2FzdE91dHB1dENvb3Jkc1NhbXBsZXIoaW5wdXRJbmZvLCBvdXRTaGFwZUluZm8sIHRleEZ1bmNTbmlwcGV0LCBmdW5jTmFtZSkge1xuICAgIHZhciBpblJhbmsgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIG91dFJhbmsgPSBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgdHlwZSA9ICdpbnQnO1xuICAgIGlmIChvdXRSYW5rID09PSAyKSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzInO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRSYW5rID09PSAzKSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRSYW5rID09PSA0KSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzQnO1xuICAgIH1cbiAgICB2YXIgYnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsIG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgIHZhciByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgdmFyIGNvb3Jkc1NuaXBwZXQ7XG4gICAgaWYgKGluUmFuayA9PT0gMCkge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgY29vcmRzU25pcHBldCA9ICdjb29yZHMgPSAwOyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID1cbiAgICAgICAgICAgIGJyb2FkY2FzdERpbXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBcImNvb3Jkc1tcIiArIChkICsgcmFua0RpZmYpICsgXCJdID0gMDtcIjsgfSkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHZhciB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBcImNvb3Jkc1tcIiArIChpICsgcmFua0RpZmYpICsgXCJdXCI7IH0pXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICBcIiArIHR5cGUgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBcIiArIGNvb3Jkc1NuaXBwZXQgKyBcIlxcbiAgICAgIHJldHVybiBnZXRcIiArIHRleEZ1bmNTbmlwcGV0ICsgXCIoXCIgKyB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgKyBcIik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKGlucHV0SW5mbywgb3V0U2hhcGVJbmZvLCBzdXBwb3J0c0Jyb2FkY2FzdGluZykge1xuICAgIHZhciBpblRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciB0ZXhGdW5jU25pcHBldCA9IHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4RnVuY1NuaXBwZXQgKyAnQXRPdXRDb29yZHMnO1xuICAgIHZhciBicm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7XG4gICAgdmFyIGluUmFuayA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3V0UmFuayA9IG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciBkb0Jyb2FkY2FzdCA9IHN1cHBvcnRzQnJvYWRjYXN0aW5nICYmICgob3V0UmFuayA+IGluUmFuaykgfHwgYnJvYWRjYXN0RGltcy5sZW5ndGggPiAwKTtcbiAgICB2YXIgYnJvYWRjYXN0T3Zlck91dGVyID0gYnJvYWRjYXN0X3V0aWwuYnJvYWRjYXN0RGltc0FyZU91dGVyKGJyb2FkY2FzdERpbXMpO1xuICAgIGlmIChkb0Jyb2FkY2FzdCAmJiAhYnJvYWRjYXN0T3Zlck91dGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCcm9hZGNhc3RPdXRwdXRDb29yZHNTYW1wbGVyKGlucHV0SW5mbywgb3V0U2hhcGVJbmZvLCB0ZXhGdW5jU25pcHBldCwgZnVuY05hbWUpO1xuICAgIH1cbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRTaGFwZUluZm8udGV4U2hhcGU7XG4gICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoaW5UZXhTaGFwZSwgb3V0VGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiICsgdGV4TmFtZSArIFwiLCByZXN1bHRVVik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShpblRleFNoYXBlKTtcbiAgICB2YXIgYnJvYWRjYXN0U25pcHBldCA9ICcnO1xuICAgIGlmIChkb0Jyb2FkY2FzdCAmJiBicm9hZGNhc3RPdmVyT3V0ZXIpIHtcbiAgICAgICAgYnJvYWRjYXN0U25pcHBldCA9IFwiXFxuICAgICAgICBpbnQgbWFpblBhcnQgPSBpbmRleCAvIFwiICsgaW5TaXplICsgXCI7XFxuICAgICAgICBpbmRleCAtPSBtYWluUGFydCAqIFwiICsgaW5TaXplICsgXCI7XFxuICAgICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgb3V0VGV4U2hhcGVbMF0gKyBcIiwgXCIgKyBvdXRUZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgb3V0VGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIgKyBicm9hZGNhc3RTbmlwcGV0ICsgXCJcXG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gXCIgKyBpblRleFNoYXBlWzFdICsgXCI7XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiBcIiArIGluVGV4U2hhcGVbMV0gKyBcIjtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgIHZlYzIoXCIgKyBpblRleFNoYXBlWzFdICsgXCIuMCwgXCIgKyBpblRleFNoYXBlWzBdICsgXCIuMCk7XFxuXFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRDb29yZHNEYXRhVHlwZShyYW5rKSB7XG4gICAgaWYgKHJhbmsgPD0gMSkge1xuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjNCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDUpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjNSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkdQVSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmdldENvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGU7XG5mdW5jdGlvbiBzcXVlZXplSW5wdXRJbmZvKGluSW5mbywgc3F1ZWV6ZWRTaGFwZSkge1xuICAgIHZhciBuZXdJbnB1dEluZm8gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGluSW5mbykpO1xuICAgIG5ld0lucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlID0gc3F1ZWV6ZWRTaGFwZTtcbiAgICByZXR1cm4gbmV3SW5wdXRJbmZvO1xufVxuZnVuY3Rpb24gZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykge1xuICAgIHJldHVybiBrZXB0RGltcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHBhcmFtc1tkXTsgfSkuam9pbignLCAnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlcl9jb21waWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBTbGljZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWNlUHJvZ3JhbShkZXN0U2l6ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3NvdXJjZSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gZGVzdFNpemU7XG4gICAgICAgIHRoaXMucmFuayA9IGRlc3RTaXplLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHNvdXJjZUNvb3JkcyA9IGdldENvb3Jkcyh0aGlzLnJhbmspO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIFwiICsgZHR5cGUgKyBcIiBzdGFydDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgc291cmNlTG9jID0gc3RhcnQgKyBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRTb3VyY2UoXCIgKyBzb3VyY2VDb29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIFNsaWNlUHJvZ3JhbS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzdGFydC5sZW5ndGggIT09IHRoaXMucmFuaykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgcmFuayAoXCIgKyB0aGlzLnJhbmsgKyBcIikgb2YgdGhlIHByb2dyYW0gbXVzdCBtYXRjaCB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIChcImxlbmd0aCBvZiBzdGFydCAoXCIgKyBzdGFydC5sZW5ndGggKyBcIilcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0TG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydExvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cod2ViR0xQcm9ncmFtLCAnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMWkoX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMmkoX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdLCBzdGFydFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTNpKF90aGlzLnN0YXJ0TG9jLCBzdGFydFswXSwgc3RhcnRbMV0sIHN0YXJ0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtNGkoX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdLCBzdGFydFsxXSwgc3RhcnRbMl0sIHN0YXJ0WzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIiArIF90aGlzLnJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTbGljZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5TbGljZVByb2dyYW0gPSBTbGljZVByb2dyYW07XG5mdW5jdGlvbiBnZXRDb29yZHMocmFuaykge1xuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYy54LCBzb3VyY2VMb2MueSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MueCwgc291cmNlTG9jLnksIHNvdXJjZUxvYy56JztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYy54LCBzb3VyY2VMb2MueSwgc291cmNlTG9jLnosIHNvdXJjZUxvYy53JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGljZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgU3RyaWRlZFNsaWNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaWRlZFNsaWNlUHJvZ3JhbShiZWdpbiwgc3RyaWRlcywgc2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgbmV3Q29vcmRzID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIG5ld0Nvb3JkcyA9ICdjb29yZHMgKiBzdHJpZGVzICsgYmVnaW4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29vcmRzID1cbiAgICAgICAgICAgICAgICBzaGFwZS5tYXAoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIFwiY29vcmRzW1wiICsgaSArIFwiXSAqIHN0cmlkZXNbXCIgKyBpICsgXCJdICsgYmVnaW5bXCIgKyBpICsgXCJdXCI7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgXCIgKyBkdHlwZSArIFwiIGJlZ2luID0gXCIgKyBkdHlwZSArIFwiKFwiICsgYmVnaW4gKyBcIik7XFxuICAgICAgXCIgKyBkdHlwZSArIFwiIHN0cmlkZXMgPSBcIiArIGR0eXBlICsgXCIoXCIgKyBzdHJpZGVzICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiICsgbmV3Q29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaWRlZFNsaWNlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlN0cmlkZWRTbGljZVByb2dyYW0gPSBTdHJpZGVkU2xpY2VQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaWRlZF9zbGljZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGV4dHVyZVR5cGU7XG4oZnVuY3Rpb24gKFRleHR1cmVUeXBlKSB7XG4gICAgVGV4dHVyZVR5cGVbVGV4dHVyZVR5cGVbXCJGTE9BVFwiXSA9IDBdID0gXCJGTE9BVFwiO1xuICAgIFRleHR1cmVUeXBlW1RleHR1cmVUeXBlW1wiVU5TSUdORURfQllURVwiXSA9IDFdID0gXCJVTlNJR05FRF9CWVRFXCI7XG59KShUZXh0dXJlVHlwZSA9IGV4cG9ydHMuVGV4dHVyZVR5cGUgfHwgKGV4cG9ydHMuVGV4dHVyZVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtjb2x1bW5zLCByb3dzXTtcbn1cbmV4cG9ydHMuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCA9IGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQ7XG5mdW5jdGlvbiBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeFNpemUsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHJldHVybiBtYXRyaXhTaXplICogY2hhbm5lbHNQZXJUZXh0dXJlO1xufVxuZXhwb3J0cy5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplID0gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZTtcbmZ1bmN0aW9uIGdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbY29sdW1ucyAqIDQsIHJvd3NdO1xufVxuZXhwb3J0cy5nZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0ID0gZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodDtcbmZ1bmN0aW9uIGdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUodW5wYWNrZWRTaXplLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICBpZiAodW5wYWNrZWRTaXplICUgY2hhbm5lbHNQZXJUZXh0dXJlICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucGFja2VkU2l6ZSAoXCIgKyB1bnBhY2tlZFNpemUgKyBcIikgbXVzdCBiZSBhIG11bHRpcGxlIG9mIFwiICtcbiAgICAgICAgICAgIChcIlwiICsgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiB1bnBhY2tlZFNpemUgLyBjaGFubmVsc1BlclRleHR1cmU7XG59XG5leHBvcnRzLmdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUgPSBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplO1xuZnVuY3Rpb24gZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KG1hdHJpeCwgdW5wYWNrZWRBcnJheSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICBpZiAodW5wYWNrZWRBcnJheS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5wYWNrZWRBcnJheSBsZW5ndGggKFwiICsgdW5wYWNrZWRBcnJheS5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArXG4gICAgICAgICAgICAoXCJcIiArIHJlcXVpcmVkU2l6ZSkpO1xuICAgIH1cbiAgICB2YXIgZHN0ID0gMDtcbiAgICBmb3IgKHZhciBzcmMgPSAwOyBzcmMgPCBtYXRyaXgubGVuZ3RoOyArK3NyYykge1xuICAgICAgICB1bnBhY2tlZEFycmF5W2RzdF0gPSBtYXRyaXhbc3JjXTtcbiAgICAgICAgZHN0ICs9IGNoYW5uZWxzUGVyVGV4dHVyZTtcbiAgICB9XG59XG5leHBvcnRzLmVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheSA9IGVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheTtcbmV4cG9ydHMuRkxPQVRfTUFYID0gMjAwMDA7XG5leHBvcnRzLkZMT0FUX01JTiA9IC1leHBvcnRzLkZMT0FUX01BWDtcbnZhciBGTE9BVF9SQU5HRSA9IChleHBvcnRzLkZMT0FUX01BWCAtIGV4cG9ydHMuRkxPQVRfTUlOKSAvIDI1NTtcbnZhciBGTE9BVF9ERUxUQVMgPSBbMSwgMSAvIDI1NSwgMSAvICgyNTUgKiAyNTUpLCAxIC8gKDI1NSAqIDI1NSAqIDI1NSldO1xudmFyIEZMT0FUX1BPV0VSUyA9IFsxLCAyNTUsIDI1NSAqIDI1NV07XG5leHBvcnRzLkJZVEVfTkFOX1ZBTFVFID0gMDtcbmZ1bmN0aW9uIGVuY29kZUZsb2F0QXJyYXkoZmxvYXRBcnJheSkge1xuICAgIHZhciB1aW50QXJyYXkgPSBuZXcgVWludDhBcnJheShmbG9hdEFycmF5Lmxlbmd0aCAqIDQpO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZmxvYXRBcnJheVtpIC8gNF07XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDFdID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMl0gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgdWludEFycmF5W2kgKyAzXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSAodmFsdWUgLSBleHBvcnRzLkZMT0FUX01JTikgLyBGTE9BVF9SQU5HRTtcbiAgICAgICAgdmFyIGVuYyA9IEZMT0FUX1BPV0VSUy5tYXAoZnVuY3Rpb24gKHBvdykgeyByZXR1cm4gcG93ICogbm9ybWFsaXplZFZhbHVlOyB9KTtcbiAgICAgICAgdmFyIGJ1Y2tldHMgPSBlbmMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTWF0aC5mbG9vcigodmFsdWUgJSAxKSAqIDI1NSk7IH0pO1xuICAgICAgICB1aW50QXJyYXlbaV0gPSBNYXRoLmZsb29yKG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgICAgIHVpbnRBcnJheVtpICsgMV0gPSBidWNrZXRzWzBdO1xuICAgICAgICB1aW50QXJyYXlbaSArIDJdID0gYnVja2V0c1sxXTtcbiAgICAgICAgdWludEFycmF5W2kgKyAzXSA9IGJ1Y2tldHNbMl07XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVpbnRBcnJheS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdWludEFycmF5O1xufVxuZXhwb3J0cy5lbmNvZGVGbG9hdEFycmF5ID0gZW5jb2RlRmxvYXRBcnJheTtcbmZ1bmN0aW9uIGRlY29kZVRvRmxvYXRBcnJheSh1aW50QXJyYXkpIHtcbiAgICB2YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodWludEFycmF5Lmxlbmd0aCAvIDQpO1xuICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgaWYgKHVpbnRBcnJheVtpXSA9PT0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRSAmJlxuICAgICAgICAgICAgdWludEFycmF5W2kgKyAxXSA9PT0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRSAmJlxuICAgICAgICAgICAgdWludEFycmF5W2kgKyAyXSA9PT0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRSAmJlxuICAgICAgICAgICAgdWludEFycmF5W2kgKyAzXSA9PT0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRSkge1xuICAgICAgICAgICAgZmxvYXRBcnJheVtpIC8gNF0gPSBOYU47XG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb3QgPSAwO1xuICAgICAgICBGTE9BVF9ERUxUQVMuZm9yRWFjaChmdW5jdGlvbiAoZGVsdGEsIGopIHtcbiAgICAgICAgICAgIGRvdCArPSBkZWx0YSAqIHVpbnRBcnJheVtpICsgal07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmFsdWUgPSBkb3QgKiBGTE9BVF9SQU5HRSArIGV4cG9ydHMuRkxPQVRfTUlOO1xuICAgICAgICBmbG9hdEFycmF5W2kgLyA0XSA9IHZhbHVlO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1aW50QXJyYXkubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgX2xvb3BfMihpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsb2F0QXJyYXk7XG59XG5leHBvcnRzLmRlY29kZVRvRmxvYXRBcnJheSA9IGRlY29kZVRvRmxvYXRBcnJheTtcbmZ1bmN0aW9uIGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5KHVucGFja2VkQXJyYXksIG1hdHJpeCwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IGdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUodW5wYWNrZWRBcnJheS5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gICAgaWYgKG1hdHJpeC5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIgKyBtYXRyaXgubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgZHN0ID0gMDtcbiAgICBmb3IgKHZhciBzcmMgPSAwOyBzcmMgPCB1bnBhY2tlZEFycmF5Lmxlbmd0aDsgc3JjICs9IGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgICAgICBtYXRyaXhbZHN0KytdID0gdW5wYWNrZWRBcnJheVtzcmNdO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkgPSBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheTtcbmZ1bmN0aW9uIGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5KHVucGFja2VkQXJyYXksIG1hdHJpeCwgY2hhbm5lbHMpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gdW5wYWNrZWRBcnJheS5sZW5ndGggKiBjaGFubmVscyAvIDQ7XG4gICAgaWYgKG1hdHJpeC5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIgKyBtYXRyaXgubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgZHN0ID0gMDtcbiAgICBmb3IgKHZhciBzcmMgPSAwOyBzcmMgPCB1bnBhY2tlZEFycmF5Lmxlbmd0aDsgc3JjICs9IDQpIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgICBtYXRyaXhbZHN0KytdID0gdW5wYWNrZWRBcnJheVtzcmMgKyBjXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXkgPSBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheTtcbmZ1bmN0aW9uIGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gW01hdGguY2VpbChjb2x1bW5zIC8gMiksIE1hdGguY2VpbChyb3dzIC8gMildO1xufVxuZXhwb3J0cy5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0O1xuZnVuY3Rpb24gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHJldHVybiB3ICogaCAqIDQ7XG59XG5leHBvcnRzLmdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUgPSBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlO1xuZnVuY3Rpb24gZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKG1hdHJpeCwgcm93cywgY29sdW1ucywgcGFja2VkUkdCQSkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpO1xuICAgIGlmIChwYWNrZWRSR0JBLmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWNrZWRSR0JBIGxlbmd0aCAoXCIgKyBwYWNrZWRSR0JBLmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHRleHR1cmVXaWR0aCA9IF9hWzBdLCB0ZXh0dXJlSGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG9kZFdpZHRoID0gKGNvbHVtbnMgJSAyKSA9PT0gMTtcbiAgICB2YXIgb2RkSGVpZ2h0ID0gKHJvd3MgJSAyKSA9PT0gMTtcbiAgICB2YXIgd2lkdGhJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKGNvbHVtbnMgLyAyKTtcbiAgICB2YXIgaGVpZ2h0SW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihyb3dzIC8gMik7XG4gICAge1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gKG9kZFdpZHRoID8gNCA6IDApO1xuICAgICAgICB2YXIgb25lUm93ID0gY29sdW1ucztcbiAgICAgICAgdmFyIGRzdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIHZhciBtYXRyaXhTcmNSb3cgPSAoYmxvY2tZICogMiAqIGNvbHVtbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeFNyY0NvbCA9IGJsb2NrWCAqIDI7XG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IG1hdHJpeFNyY1JvdyArIG1hdHJpeFNyY0NvbDtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdF0gPSBtYXRyaXhbc3JjXTtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDFdID0gbWF0cml4W3NyYyArIDFdO1xuICAgICAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgMl0gPSBtYXRyaXhbc3JjICsgb25lUm93XTtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDNdID0gbWF0cml4W3NyYyArIG9uZVJvdyArIDFdO1xuICAgICAgICAgICAgICAgIGRzdCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHN0ICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkV2lkdGgpIHtcbiAgICAgICAgdmFyIHNyYyA9IGNvbHVtbnMgLSAxO1xuICAgICAgICB2YXIgZHN0ID0gKHRleHR1cmVXaWR0aCAtIDEpICogNDtcbiAgICAgICAgdmFyIHNyY1N0cmlkZSA9IDIgKiBjb2x1bW5zO1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDJdID0gbWF0cml4W3NyYyArIGNvbHVtbnNdO1xuICAgICAgICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgICAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZEhlaWdodCkge1xuICAgICAgICB2YXIgc3JjID0gKHJvd3MgLSAxKSAqIGNvbHVtbnM7XG4gICAgICAgIHZhciBkc3QgPSAodGV4dHVyZUhlaWdodCAtIDEpICogdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCsrXSA9IG1hdHJpeFtzcmMrK107XG4gICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCsrXSA9IG1hdHJpeFtzcmMrK107XG4gICAgICAgICAgICBkc3QgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkV2lkdGggJiYgb2RkSGVpZ2h0KSB7XG4gICAgICAgIHBhY2tlZFJHQkFbcGFja2VkUkdCQS5sZW5ndGggLSA0XSA9IG1hdHJpeFttYXRyaXgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBwYWNrZWRSR0JBO1xufVxuZXhwb3J0cy5lbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkEgPSBlbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkE7XG5mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShwYWNrZWRSR0JBLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gcm93cyAqIGNvbHVtbnM7XG4gICAgaWYgKHJlcXVpcmVkU2l6ZSA8IG1hdHJpeC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIgKyBtYXRyaXgubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgb2RkV2lkdGggPSAoY29sdW1ucyAlIDIpID09PSAxO1xuICAgIHZhciBvZGRIZWlnaHQgPSAocm93cyAlIDIpID09PSAxO1xuICAgIHZhciB3aWR0aEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3IoY29sdW1ucyAvIDIpO1xuICAgIHZhciBoZWlnaHRJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKHJvd3MgLyAyKTtcbiAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdGV4dHVyZVdpZHRoID0gX2FbMF0sIHRleHR1cmVIZWlnaHQgPSBfYVsxXTtcbiAgICB7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSBvZGRXaWR0aCA/IDQgOiAwO1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gY29sdW1ucyArIChvZGRXaWR0aCA/IDEgOiAwKTtcbiAgICAgICAgdmFyIHNyYyA9IDA7XG4gICAgICAgIHZhciBkc3RSb3cxID0gMDtcbiAgICAgICAgdmFyIGRzdFJvdzIgPSBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MSsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cxKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzIrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MisrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgICAgICAgIGRzdFJvdzEgKz0gZHN0U3RyaWRlO1xuICAgICAgICAgICAgZHN0Um93MiArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoKSB7XG4gICAgICAgIHZhciBzcmMgPSAodGV4dHVyZVdpZHRoIC0gMSkgKiA0O1xuICAgICAgICB2YXIgZHN0ID0gY29sdW1ucyAtIDE7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gMiAqIGNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIG1hdHJpeFtkc3RdID0gcGFja2VkUkdCQVtzcmNdO1xuICAgICAgICAgICAgbWF0cml4W2RzdCArIGNvbHVtbnNdID0gcGFja2VkUkdCQVtzcmMgKyAyXTtcbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRIZWlnaHQpIHtcbiAgICAgICAgdmFyIHNyYyA9ICh0ZXh0dXJlSGVpZ2h0IC0gMSkgKiB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICB2YXIgZHN0ID0gKHJvd3MgLSAxKSAqIGNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgc3JjICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgICAgICBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdID0gcGFja2VkUkdCQVtwYWNrZWRSR0JBLmxlbmd0aCAtIDRdO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufVxuZXhwb3J0cy5kZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQSA9IGRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGV4X3V0aWxfMSA9IHJlcXVpcmUoXCIuL3RleF91dGlsXCIpO1xudmFyIFRleHR1cmVNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0dXJlTWFuYWdlcihncGdwdSkge1xuICAgICAgICB0aGlzLmdwZ3B1ID0gZ3BncHU7XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLmZyZWVUZXh0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZXMgPSB7fTtcbiAgICB9XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlID0gZnVuY3Rpb24gKHNoYXBlUkMsIHRleFR5cGUpIHtcbiAgICAgICAgaWYgKHRleFR5cGUgPT09IHZvaWQgMCkgeyB0ZXhUeXBlID0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5GTE9BVDsgfVxuICAgICAgICB2YXIgc2hhcGVLZXkgPSBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUkMsIHRleFR5cGUpO1xuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLmZyZWVUZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMudXNlZFRleHR1cmVzKSkge1xuICAgICAgICAgICAgdGhpcy51c2VkVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcy0tO1xuICAgICAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMrKztcbiAgICAgICAgICAgIHRoaXMubG9nKCk7XG4gICAgICAgICAgICB2YXIgbmV3VGV4dHVyZV8xID0gdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLnVzZWRUZXh0dXJlc1tzaGFwZUtleV0ucHVzaChuZXdUZXh0dXJlXzEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1RleHR1cmVfMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcysrO1xuICAgICAgICB0aGlzLmxvZygpO1xuICAgICAgICB2YXIgbmV3VGV4dHVyZSA9IHRoaXMuZ3BncHUuY3JlYXRlTWF0cml4VGV4dHVyZShzaGFwZVJDWzBdLCBzaGFwZVJDWzFdKTtcbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZXNbc2hhcGVLZXldLnB1c2gobmV3VGV4dHVyZSk7XG4gICAgICAgIHJldHVybiBuZXdUZXh0dXJlO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHNoYXBlLCB0ZXhUeXBlKSB7XG4gICAgICAgIGlmICh0ZXhUeXBlID09PSB2b2lkIDApIHsgdGV4VHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuRkxPQVQ7IH1cbiAgICAgICAgdmFyIHNoYXBlS2V5ID0gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZSwgdGV4VHlwZSk7XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMuZnJlZVRleHR1cmVzKSkge1xuICAgICAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLnB1c2godGV4dHVyZSk7XG4gICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzKys7XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzLS07XG4gICAgICAgIHZhciB0ZXhMaXN0ID0gdGhpcy51c2VkVGV4dHVyZXNbc2hhcGVLZXldO1xuICAgICAgICB2YXIgdGV4SW5kZXggPSB0ZXhMaXN0LmluZGV4T2YodGV4dHVyZSk7XG4gICAgICAgIGlmICh0ZXhJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbGVhc2UgYSB0ZXh0dXJlIHRoYXQgd2FzIG5ldmVyIHByb3ZpZGVkIGJ5IHRoaXMgJyArXG4gICAgICAgICAgICAgICAgJ3RleHR1cmUgbWFuYWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHRleExpc3Quc3BsaWNlKHRleEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5sb2coKTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5udW1GcmVlVGV4dHVyZXMgKyB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyZWUvVXNlZCcsIHRoaXMubnVtRnJlZVRleHR1cmVzICsgXCIgLyBcIiArIHRoaXMubnVtVXNlZFRleHR1cmVzLCBcIihcIiArIHRvdGFsICsgXCIpXCIpO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmdldE51bVVzZWRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmdldE51bUZyZWVUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtRnJlZVRleHR1cmVzO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgdGV4U2hhcGUgaW4gdGhpcy5mcmVlVGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3RleFNoYXBlXS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB0ZXhTaGFwZSBpbiB0aGlzLnVzZWRUZXh0dXJlcykge1xuICAgICAgICAgICAgdGhpcy51c2VkVGV4dHVyZXNbdGV4U2hhcGVdLmZvckVhY2goZnVuY3Rpb24gKHRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUodGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJlZVRleHR1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcyA9IDA7XG4gICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0dXJlTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlRleHR1cmVNYW5hZ2VyID0gVGV4dHVyZU1hbmFnZXI7XG5mdW5jdGlvbiBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUm93c0NvbCwgdGV4VHlwZSkge1xuICAgIHJldHVybiBzaGFwZVJvd3NDb2xbMF0gKyBcIl9cIiArIHNoYXBlUm93c0NvbFsxXSArIFwiX1wiICsgdGV4VHlwZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHR1cmVfbWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBUaWxlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGlsZVByb2dyYW0oYVNoYXBlLCByZXBzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBuZXcgQXJyYXkoYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlW2ldID0gYVNoYXBlW2ldICogcmVwc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMucmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHNvdXJjZUNvb3JkcyA9IGdldFNvdXJjZUNvb3JkcyhhU2hhcGUpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiICsgc291cmNlQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVGlsZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5UaWxlUHJvZ3JhbSA9IFRpbGVQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0U291cmNlQ29vcmRzKGFTaGFwZSkge1xuICAgIHZhciByYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICBpZiAocmFuayA+IDUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUaWxlIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJpbW9kKHJlc1JDLCBcIiArIGFTaGFwZVswXSArIFwiKVwiO1xuICAgIH1cbiAgICB2YXIgY3VycmVudENvb3JkcyA9IFsncmVzUkMueCcsICdyZXNSQy55JywgJ3Jlc1JDLnonLCAncmVzUkMudycsICdyZXNSQy51J107XG4gICAgdmFyIHNvdXJjZUNvb3JkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZUNvb3Jkcy5wdXNoKFwiaW1vZChcIiArIGN1cnJlbnRDb29yZHNbaV0gKyBcIiwgXCIgKyBhU2hhcGVbaV0gKyBcIilcIik7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VDb29yZHMuam9pbigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlsZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgVHJhbnNwb3NlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3NlUHJvZ3JhbShhU2hhcGUsIG5ld0RpbSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGFTaGFwZVtuZXdEaW1baV1dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc3dpdGNoZWQgPSBnZXRTd2l0Y2hlZENvb3JkcyhuZXdEaW0pO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChnZXRBKFwiICsgc3dpdGNoZWQgKyBcIikpO1xcbiAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNwb3NlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlRyYW5zcG9zZVByb2dyYW0gPSBUcmFuc3Bvc2VQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0U3dpdGNoZWRDb29yZHMobmV3RGltKSB7XG4gICAgdmFyIHJhbmsgPSBuZXdEaW0ubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRyYW5zcG9zZSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgdmFyIG9yaWdpbmFsT3JkZXIgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnLCAncmVzUkMudSddO1xuICAgIHZhciBzd2l0Y2hlZENvb3JkcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RpbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2hlZENvb3Jkc1tuZXdEaW1baV1dID0gb3JpZ2luYWxPcmRlcltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN3aXRjaGVkQ29vcmRzLmpvaW4oKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9zZV9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXJmX3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL2VyZl91dGlsXCIpO1xudmFyIHNlbHVfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9vcHMvc2VsdV91dGlsXCIpO1xudmFyIFVuYXJ5T3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbmFyeU9wUHJvZ3JhbShhU2hhcGUsIG9wU25pcHBldCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGFTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgZmxvYXQgdW5hcnlPcGVyYXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgXCIgKyBvcFNuaXBwZXQgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFVuYXJ5T3BQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuVW5hcnlPcFByb2dyYW0gPSBVbmFyeU9wUHJvZ3JhbTtcbnZhciBDSEVDS19OQU5fU05JUFBFVCA9IFwiaWYgKGlzTmFOKHgpKSByZXR1cm4geDtcIjtcbmV4cG9ydHMuQUJTID0gXCJyZXR1cm4gYWJzKHgpO1wiO1xuZXhwb3J0cy5SRUxVID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XFxuXCI7XG5leHBvcnRzLkVMVSA9IFwicmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XCI7XG5leHBvcnRzLlNFTFUgPSBcIlxcbiAgLy8gU3RhYmxlIGFuZCBBdHRyYWN0aW5nIEZpeGVkIFBvaW50ICgwLCAxKSBmb3IgTm9ybWFsaXplZCBXZWlnaHRzLlxcbiAgLy8gc2VlOiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNi4wMjUxNVxcbiAgZmxvYXQgc2NhbGVBbHBoYSA9IFwiICsgc2VsdV91dGlsLlNFTFVfU0NBTEVBTFBIQSArIFwiO1xcbiAgZmxvYXQgc2NhbGUgPSBcIiArIHNlbHVfdXRpbC5TRUxVX1NDQUxFICsgXCI7XFxuICByZXR1cm4gKHggPj0gMC4wKSA/IHNjYWxlICogeCA6IHNjYWxlQWxwaGEgKiAoZXhwKHgpIC0gMS4wKTtcXG5cIjtcbmZ1bmN0aW9uIFNURVAoYWxwaGEpIHtcbiAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMDsgfVxuICAgIHJldHVybiBDSEVDS19OQU5fU05JUFBFVCArIChcIlxcbiAgICByZXR1cm4geCA+IDAuMCA/IDEuMCA6IGZsb2F0KFwiICsgYWxwaGEgKyBcIik7XFxuICBcIik7XG59XG5leHBvcnRzLlNURVAgPSBTVEVQO1xuZXhwb3J0cy5ORUcgPSBcInJldHVybiAteDtcIjtcbmV4cG9ydHMuQ0VJTCA9IFwicmV0dXJuIGNlaWwoeCk7XCI7XG5leHBvcnRzLkZMT09SID0gXCJyZXR1cm4gZmxvb3IoeCk7XCI7XG5leHBvcnRzLlNJR04gPSBcIlxcbiAgaWYgKGlzTmFOKHgpKSB7IHJldHVybiAwLjA7IH1cXG4gIHJldHVybiBzaWduKHgpO1xcblwiO1xuZXhwb3J0cy5ST1VORCA9IFwiXFxuICAvLyBPcGVuR0wgRVMgZG9lcyBub3Qgc3VwcG9ydCByb3VuZCBmdW5jdGlvbi5cXG4gIC8vIFRoZSBhbGdvcml0aG0gaXMgYmFzZWQgb24gYmFua2VyJ3Mgcm91bmRpbmcuXFxuICBmbG9hdCBiYXNlID0gZmxvb3IoeCk7XFxuICBpZiAoKHggLSBiYXNlKSA8IDAuNSkge1xcbiAgICByZXR1cm4gZmxvb3IoeCk7XFxuICB9IGVsc2UgaWYgKCh4IC0gYmFzZSkgPiAwLjUpIHtcXG4gICAgcmV0dXJuIGNlaWwoeCk7XFxuICB9IGVsc2Uge1xcbiAgICBpZiAobW9kKGJhc2UsIDIuMCkgPT0gMC4wKSB7XFxuICAgICAgcmV0dXJuIGJhc2U7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGJhc2UgKyAxLjA7XFxuICAgIH1cXG4gIH1cXG5cIjtcbmV4cG9ydHMuRVhQID0gXCJyZXR1cm4gZXhwKHgpO1wiO1xuZXhwb3J0cy5FWFBNMSA9IFwicmV0dXJuIGV4cCh4KSAtIDEuMDtcIjtcbmV4cG9ydHMuTE9HID0gXCJyZXR1cm4gbG9nKHgpO1wiO1xuZXhwb3J0cy5MT0cxUCA9IFwicmV0dXJuIGxvZygxLjAgKyB4KTtcIjtcbmV4cG9ydHMuU1FSVCA9IFwicmV0dXJuIHNxcnQoeCk7XCI7XG5leHBvcnRzLlJTUVJUID0gXCJyZXR1cm4gaW52ZXJzZXNxcnQoeCk7XCI7XG5leHBvcnRzLlNJR01PSUQgPSBcInJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XCI7XG5leHBvcnRzLlNPRlRQTFVTID0gXCJcXG4gIGZsb2F0IGVwc2lsb24gPSAxLjE5MjA5Mjg5NTUwNzgxMjVlLTc7XFxuICBmbG9hdCB0aHJlc2hvbGQgPSBsb2coZXBzaWxvbikgKyAyLjA7XFxuXFxuICBib29sIHRvb19sYXJnZSA9IHggPiAtdGhyZXNob2xkO1xcbiAgYm9vbCB0b29fc21hbGwgPSB4IDwgdGhyZXNob2xkO1xcblxcbiAgZmxvYXQgcmVzdWx0O1xcbiAgZmxvYXQgZXhwX3ggPSBleHAoeCk7XFxuXFxuICBpZiAodG9vX2xhcmdlKXtcXG4gICAgcmVzdWx0ID0geDtcXG4gIH1cXG4gIGVsc2UgaWYgKHRvb19zbWFsbCl7XFxuICAgIHJlc3VsdCA9IGV4cF94O1xcbiAgfVxcbiAgZWxzZXtcXG4gICAgcmVzdWx0ID0gbG9nKGV4cF94ICsgMS4wKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxuXCI7XG5leHBvcnRzLlNJTiA9IFwicmV0dXJuIHNpbih4KTtcIjtcbmV4cG9ydHMuQ09TID0gXCJyZXR1cm4gY29zKHgpO1wiO1xuZXhwb3J0cy5UQU4gPSBcInJldHVybiB0YW4oeCk7XCI7XG5leHBvcnRzLkFTSU4gPSBcInJldHVybiBhc2luKHgpO1wiO1xuZXhwb3J0cy5BQ09TID0gXCJyZXR1cm4gYWNvcyh4KTtcIjtcbmV4cG9ydHMuQVRBTiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBhdGFuKHgpO1xcblwiO1xuZXhwb3J0cy5TSU5IID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCh4KTtcXG4gIHJldHVybiAoZTJ4IC0gMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIjtcbmV4cG9ydHMuQ09TSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoLXgpO1xcbiAgcmV0dXJuIChlMnggKyAxLjAgLyBlMngpIC8gMi4wO1xcblwiO1xuZXhwb3J0cy5UQU5IID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHgpKTtcXG4gIHJldHVybiBzaWduKHgpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcXG5cIjtcbmV4cG9ydHMuQVNJTkggPSBcInJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxLjApKTtcIjtcbmV4cG9ydHMuQUNPU0ggPSBcInJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxLjApKTtcIjtcbmV4cG9ydHMuQVRBTkggPSBcInJldHVybiAobG9nKDEuMCArIHgpIC0gbG9nKDEuMCAtIHgpKSAvIDIuMDtcIjtcbmV4cG9ydHMuRVJGID0gXCJcXG4gIC8vIEVycm9yIGZ1bmN0aW9uIGlzIGNhbGN1bGF0ZWQgYXBwcm94aW1hdGVseSB3aXRoIGVsZW1lbnRhcnkgZnVuY3Rpb24uXFxuICAvLyBTZWUgXFxcIkhhbmRib29rIG9mIE1hdGhlbWF0aWNhbCBGdW5jdGlvbnMgd2l0aCBGb3JtdWxhcyxcXG4gIC8vIEdyYXBocywgYW5kIE1hdGhlbWF0aWNhbCBUYWJsZXNcXFwiLCBBYnJhbW93aXR6IGFuZCBTdGVndW4uXFxuICBmbG9hdCBwID0gXCIgKyBlcmZfdXRpbC5FUkZfUCArIFwiO1xcbiAgZmxvYXQgYTEgPSBcIiArIGVyZl91dGlsLkVSRl9BMSArIFwiO1xcbiAgZmxvYXQgYTIgPSBcIiArIGVyZl91dGlsLkVSRl9BMiArIFwiO1xcbiAgZmxvYXQgYTMgPSBcIiArIGVyZl91dGlsLkVSRl9BMyArIFwiO1xcbiAgZmxvYXQgYTQgPSBcIiArIGVyZl91dGlsLkVSRl9BNCArIFwiO1xcbiAgZmxvYXQgYTUgPSBcIiArIGVyZl91dGlsLkVSRl9BNSArIFwiO1xcblxcbiAgZmxvYXQgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XFxuICByZXR1cm4gMS4wIC0gKCgoKChhNSp0ICsgYTQpKnQpICsgYTMpKnQgKyBhMikqdCArIGExKSp0KmV4cCgteCp4KTtcXG5cIjtcbmV4cG9ydHMuU1FVQVJFID0gXCJyZXR1cm4geCAqIHg7XCI7XG5leHBvcnRzLlJFQ0lQUk9DQUwgPSBcInJldHVybiAxLjAgLyB4O1wiO1xuZXhwb3J0cy5MT0dJQ0FMX05PVCA9IFwicmV0dXJuIGZsb2F0KCEoeCA+PSAxLjApKTtcIjtcbmV4cG9ydHMuVE9fSU5UID0gXCJyZXR1cm4gZmxvYXQoaW50KHgpKTtcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuYXJ5b3BfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1BWF9URVhUVVJFX1NJWkUgPSBudWxsO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xuZnVuY3Rpb24gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0KGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICByZXR1cm4gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnV0ZXMpO1xufVxuZXhwb3J0cy5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQgPSBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG5mdW5jdGlvbiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcykge1xuICAgIHZhciBnbDtcbiAgICB2YXIgd2ViZ2xWZXJzaW9uID0gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJyk7XG4gICAgaWYgKHdlYmdsVmVyc2lvbiA9PT0gMikge1xuICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2ViZ2xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGdsID0gKGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8XG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgICBpZiAod2ViZ2xWZXJzaW9uID09PSAwIHx8IGdsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsO1xufVxuZXhwb3J0cy5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzID0gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcztcbmZ1bmN0aW9uIGNhbGxBbmRDaGVjayhnbCwgZnVuYykge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IGZ1bmMoKTtcbiAgICBjaGVja1dlYkdMRXJyb3IoZ2wpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmV4cG9ydHMuY2FsbEFuZENoZWNrID0gY2FsbEFuZENoZWNrO1xudmFyIHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcoZW5hYmxlZCkge1xuICAgIHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCA9IGVuYWJsZWQ7XG59XG5leHBvcnRzLmVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nID0gZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmc7XG5mdW5jdGlvbiBjaGVja1dlYkdMRXJyb3IoZ2wpIHtcbiAgICBpZiAod2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGdsLmdldEVycm9yKCk7XG4gICAgICAgIGlmIChlcnJvciAhPT0gZ2wuTk9fRVJST1IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgRXJyb3I6ICcgKyBnZXRXZWJHTEVycm9yTWVzc2FnZShnbCwgZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tXZWJHTEVycm9yID0gY2hlY2tXZWJHTEVycm9yO1xuZnVuY3Rpb24gZ2V0V2ViR0xFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgZ2wuTk9fRVJST1I6XG4gICAgICAgICAgICByZXR1cm4gJ05PX0VSUk9SJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX0VOVU06XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfRU5VTSc7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9WQUxVRTpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9WQUxVRSc7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9PUEVSQVRJT046XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfT1BFUkFUSU9OJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGdsLk9VVF9PRl9NRU1PUlk6XG4gICAgICAgICAgICByZXR1cm4gJ09VVF9PRl9NRU1PUlknO1xuICAgICAgICBjYXNlIGdsLkNPTlRFWFRfTE9TVF9XRUJHTDpcbiAgICAgICAgICAgIHJldHVybiAnQ09OVEVYVF9MT1NUX1dFQkdMJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVua25vd24gZXJyb3IgY29kZSBcIiArIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLmdldFdlYkdMRXJyb3JNZXNzYWdlID0gZ2V0V2ViR0xFcnJvck1lc3NhZ2U7XG5mdW5jdGlvbiBnZXRFeHRlbnNpb25PclRocm93KGdsLCBleHRlbnNpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7IH0sICdFeHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKTtcbn1cbmV4cG9ydHMuZ2V0RXh0ZW5zaW9uT3JUaHJvdyA9IGdldEV4dGVuc2lvbk9yVGhyb3c7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSkge1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSB2ZXJ0ZXggV2ViR0xTaGFkZXIuJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTsgfSk7XG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXI7XG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7IH0sICdVbmFibGUgdG8gY3JlYXRlIGZyYWdtZW50IFdlYkdMU2hhZGVyLicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7IH0pO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhmcmFnbWVudFNoYWRlclNvdXJjZSwgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xufVxuZXhwb3J0cy5jcmVhdGVGcmFnbWVudFNoYWRlciA9IGNyZWF0ZUZyYWdtZW50U2hhZGVyO1xudmFyIGxpbmVOdW1iZXJSZWdleCA9IC9FUlJPUjogWzAtOV0rOihbMC05XSspOi9nO1xuZnVuY3Rpb24gbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhzaGFkZXJTb3VyY2UsIHNoYWRlckluZm9Mb2cpIHtcbiAgICB2YXIgbGluZU51bWJlclJlZ2V4UmVzdWx0ID0gbGluZU51bWJlclJlZ2V4LmV4ZWMoc2hhZGVySW5mb0xvZyk7XG4gICAgaWYgKGxpbmVOdW1iZXJSZWdleFJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6IFwiICsgc2hhZGVySW5mb0xvZyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNoYWRlclNvdXJjZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpbmVOdW1iZXIgPSArbGluZU51bWJlclJlZ2V4UmVzdWx0WzFdO1xuICAgIHZhciBzaGFkZXJMaW5lcyA9IHNoYWRlclNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHBhZCA9IHNoYWRlckxpbmVzLmxlbmd0aC50b1N0cmluZygpLmxlbmd0aCArIDI7XG4gICAgdmFyIGxpbmVzV2l0aExpbmVOdW1iZXJzID0gc2hhZGVyTGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlsLnJpZ2h0UGFkKChsaW5lTnVtYmVyICsgMSkudG9TdHJpbmcoKSwgcGFkKSArIGxpbmU7XG4gICAgfSk7XG4gICAgdmFyIG1heExpbmVMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNXaXRoTGluZU51bWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KGxpbmVzV2l0aExpbmVOdW1iZXJzW2ldLmxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBiZWZvcmVFcnJvckxpbmVzID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UoMCwgbGluZU51bWJlciAtIDEpO1xuICAgIHZhciBlcnJvckxpbmUgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZShsaW5lTnVtYmVyIC0gMSwgbGluZU51bWJlcik7XG4gICAgdmFyIGFmdGVyRXJyb3JMaW5lcyA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKGxpbmVOdW1iZXIpO1xuICAgIGNvbnNvbGUubG9nKGJlZm9yZUVycm9yTGluZXMuam9pbignXFxuJykpO1xuICAgIGNvbnNvbGUubG9nKHNoYWRlckluZm9Mb2cuc3BsaXQoJ1xcbicpWzBdKTtcbiAgICBjb25zb2xlLmxvZyhcIiVjIFwiICsgdXRpbC5yaWdodFBhZChlcnJvckxpbmVbMF0sIG1heExpbmVMZW5ndGgpLCAnYm9yZGVyOjFweCBzb2xpZCByZWQ7IGJhY2tncm91bmQtY29sb3I6I2UzZDJkMjsgY29sb3I6I2E2MTcxNycpO1xuICAgIGNvbnNvbGUubG9nKGFmdGVyRXJyb3JMaW5lcy5qb2luKCdcXG4nKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVQcm9ncmFtKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS4nKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW07XG5mdW5jdGlvbiBsaW5rUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsaW5rIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy4nKTtcbiAgICB9XG59XG5leHBvcnRzLmxpbmtQcm9ncmFtID0gbGlua1Byb2dyYW07XG5mdW5jdGlvbiB2YWxpZGF0ZVByb2dyYW0oZ2wsIHByb2dyYW0pIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRlciBwcm9ncmFtIHZhbGlkYXRpb24gZmFpbGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9ncmFtID0gdmFsaWRhdGVQcm9ncmFtO1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCBkYXRhKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVCdWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXInKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlciA9IGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGdsLCBkYXRhKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVCdWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXInKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpOyB9KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5jcmVhdGVTdGF0aWNJbmRleEJ1ZmZlciA9IGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyO1xuZnVuY3Rpb24gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCkge1xuICAgIGlmIChNQVhfVEVYVFVSRV9TSVpFICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1BWF9URVhUVVJFX1NJWkU7XG4gICAgfVxuICAgIE1BWF9URVhUVVJFX1NJWkUgPVxuICAgICAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTsgfSk7XG4gICAgcmV0dXJuIE1BWF9URVhUVVJFX1NJWkU7XG59XG5leHBvcnRzLnF1ZXJ5TWF4VGV4dHVyZVNpemUgPSBxdWVyeU1heFRleHR1cmVTaXplO1xuZnVuY3Rpb24gZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlKCkge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gNDtcbn1cbmV4cG9ydHMuZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlID0gZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlO1xuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlVGV4dHVyZSgpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuJyk7XG59XG5leHBvcnRzLmNyZWF0ZVRleHR1cmUgPSBjcmVhdGVUZXh0dXJlO1xuZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBtYXhUZXh0dXJlU2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpO1xuICAgIGlmICgod2lkdGggPD0gMCkgfHwgKGhlaWdodCA8PSAwKSkge1xuICAgICAgICB2YXIgcmVxdWVzdGVkID0gXCJbXCIgKyB3aWR0aCArIFwieFwiICsgaGVpZ2h0ICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSAnICsgcmVxdWVzdGVkICsgJyBpcyBpbnZhbGlkLicpO1xuICAgIH1cbiAgICBpZiAoKHdpZHRoID4gbWF4VGV4dHVyZVNpemUpIHx8IChoZWlnaHQgPiBtYXhUZXh0dXJlU2l6ZSkpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZCA9IFwiW1wiICsgd2lkdGggKyBcInhcIiArIGhlaWdodCArIFwiXVwiO1xuICAgICAgICB2YXIgbWF4ID0gXCJbXCIgKyBtYXhUZXh0dXJlU2l6ZSArIFwieFwiICsgbWF4VGV4dHVyZVNpemUgKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgK1xuICAgICAgICAgICAgJyBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgJyArIG1heCArICcuJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVRleHR1cmVTaXplID0gdmFsaWRhdGVUZXh0dXJlU2l6ZTtcbmZ1bmN0aW9uIGNyZWF0ZUZyYW1lYnVmZmVyKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEZyYW1lYnVmZmVyLicpO1xufVxuZXhwb3J0cy5jcmVhdGVGcmFtZWJ1ZmZlciA9IGNyZWF0ZUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgYXR0cmlidXRlLCBidWZmZXIsIGFycmF5RW50cmllc1Blckl0ZW0sIGl0ZW1TdHJpZGVJbkJ5dGVzLCBpdGVtT2Zmc2V0SW5CeXRlcykge1xuICAgIHZhciBsb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGUpO1xuICAgIGlmIChsb2MgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvYywgYXJyYXlFbnRyaWVzUGVySXRlbSwgZ2wuRkxPQVQsIGZhbHNlLCBpdGVtU3RyaWRlSW5CeXRlcywgaXRlbU9mZnNldEluQnl0ZXMpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvYyk7IH0pO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5iaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlID0gYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTtcbmZ1bmN0aW9uIGJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbn1cbmV4cG9ydHMuYmluZFRleHR1cmVVbml0ID0gYmluZFRleHR1cmVVbml0O1xuZnVuY3Rpb24gdW5iaW5kVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5leHBvcnRzLnVuYmluZFRleHR1cmVVbml0ID0gdW5iaW5kVGV4dHVyZVVuaXQ7XG5mdW5jdGlvbiBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyhnbCwgcHJvZ3JhbSwgdW5pZm9ybU5hbWUpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7IH0sICd1bmlmb3JtIFwiJyArIHVuaWZvcm1OYW1lICsgJ1wiIG5vdCBwcmVzZW50IGluIHByb2dyYW0uJyk7XG59XG5leHBvcnRzLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93ID0gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3c7XG5mdW5jdGlvbiBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uKGdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgIHJldHVybiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xufVxuZXhwb3J0cy5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uID0gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbjtcbmZ1bmN0aW9uIGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIoZ2wsIHByb2dyYW0sIHRleHR1cmUsIHVuaWZvcm1TYW1wbGVyTG9jYXRpb24sIHRleHR1cmVVbml0KSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBiaW5kVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC51bmlmb3JtMWkodW5pZm9ybVNhbXBsZXJMb2NhdGlvbiwgdGV4dHVyZVVuaXQpOyB9KTtcbn1cbmV4cG9ydHMuYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlciA9IGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXI7XG5mdW5jdGlvbiBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcihnbCkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNjaXNzb3IoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTsgfSk7XG59XG5leHBvcnRzLmJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyID0gYmluZENhbnZhc1RvRnJhbWVidWZmZXI7XG5mdW5jdGlvbiBiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcihnbCwgdGV4dHVyZSwgZnJhbWVidWZmZXIpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7IH0pO1xufVxuZXhwb3J0cy5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlciA9IGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKGdsLCBmcmFtZWJ1ZmZlcikge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBudWxsLCAwKTsgfSk7XG59XG5leHBvcnRzLnVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlciA9IHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIHZhbGlkYXRlRnJhbWVidWZmZXIoZ2wpIHtcbiAgICB2YXIgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG4gICAgaWYgKHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBiaW5kaW5nIGZyYW1lYnVmZmVyOiAnICsgZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVGcmFtZWJ1ZmZlciA9IHZhbGlkYXRlRnJhbWVidWZmZXI7XG5mdW5jdGlvbiBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVCc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XG4gICAgICAgICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcInVua25vd24gZXJyb3IgXCIgKyBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZSA9IGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlO1xuZnVuY3Rpb24gdGhyb3dJZk51bGwoZ2wsIHJldHVyblRPck51bGwsIGZhaWx1cmVNZXNzYWdlKSB7XG4gICAgdmFyIHRPck51bGwgPSBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHVyblRPck51bGwoKTsgfSk7XG4gICAgaWYgKHRPck51bGwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFpbHVyZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdE9yTnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgdmFyIG1heFRleHR1cmVVbml0ID0gZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgLSAxO1xuICAgIHZhciBnbFRleHR1cmVVbml0ID0gdGV4dHVyZVVuaXQgKyBnbC5URVhUVVJFMDtcbiAgICBpZiAoZ2xUZXh0dXJlVW5pdCA8IGdsLlRFWFRVUkUwIHx8IGdsVGV4dHVyZVVuaXQgPiBtYXhUZXh0dXJlVW5pdCkge1xuICAgICAgICB2YXIgdGV4dHVyZVVuaXRSYW5nZSA9IFwiW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFXCIgKyBtYXhUZXh0dXJlVW5pdCArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZXh0dXJlVW5pdCBtdXN0IGJlIGluIFwiICsgdGV4dHVyZVVuaXRSYW5nZSArIFwiLlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKGdsLCBsb2dTaGFwZSkge1xuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdmFyIHNxdWVlemVSZXN1bHQgPSB1dGlsLnNxdWVlemVTaGFwZShsb2dTaGFwZSk7XG4gICAgICAgIGxvZ1NoYXBlID0gc3F1ZWV6ZVJlc3VsdC5uZXdTaGFwZTtcbiAgICB9XG4gICAgdmFyIG1heFRleFNpemUgPSBxdWVyeU1heFRleHR1cmVTaXplKGdsKTtcbiAgICB2YXIgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShsb2dTaGFwZSk7XG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCA8PSAxICYmIHNpemUgPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW3NpemUsIDFdO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDIgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBsb2dTaGFwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl1dO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDQgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM10gPD0gbWF4VGV4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdLCBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM11dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUgPSBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZ2xfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB0ZW5zb3JfdXRpbCA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfdXRpbFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsXzEgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKFwiLi9jb25jYXRcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgcmFuZF8xID0gcmVxdWlyZShcIi4vcmFuZFwiKTtcbnZhciByZWR1Y3Rpb25fb3BzXzEgPSByZXF1aXJlKFwiLi9yZWR1Y3Rpb25fb3BzXCIpO1xudmFyIEFycmF5T3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcnJheU9wcygpIHtcbiAgICB9XG4gICAgQXJyYXlPcHMudGVuc29yID0gZnVuY3Rpb24gKHZhbHVlcywgc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgIGlmIChzaGFwZSAhPSBudWxsICYmIGluZmVycmVkU2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBcIkVycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvci4gXCIgK1xuICAgICAgICAgICAgICAgIChcIkluZmVycmVkIHNoYXBlIChcIiArIGluZmVycmVkU2hhcGUgKyBcIikgZG9lcyBub3QgbWF0Y2ggdGhlIFwiKSArXG4gICAgICAgICAgICAgICAgKFwicHJvdmlkZWQgc2hhcGUgKFwiICsgc2hhcGUgKyBcIikuIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmlzVHlwZWRBcnJheSh2YWx1ZXMpICYmICFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlID0gc2hhcGUgfHwgaW5mZXJyZWRTaGFwZTtcbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHNoYXBlLCB7IHZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcywgZHR5cGUpIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnNjYWxhciA9IGZ1bmN0aW9uICh2YWx1ZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgaWYgKHV0aWwuaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjcmVhdGluZyBhIG5ldyBTY2FsYXI6IHZhbHVlIG11c3QgYmUgYSBwcmltaXRpdmUgJyArXG4gICAgICAgICAgICAgICAgJyhudW1iZXJ8Ym9vbGVhbiknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXlPcHMudGVuc29yKHZhbHVlLCBbXSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMudGVuc29yMWQgPSBmdW5jdGlvbiAodmFsdWVzLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yMWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgYSBmbGF0L1R5cGVkQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXlPcHMudGVuc29yKHZhbHVlcywgaW5mZXJyZWRTaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMudGVuc29yMmQgPSBmdW5jdGlvbiAodmFsdWVzLCBzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgaWYgKHNoYXBlICE9IG51bGwgJiYgc2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvcjJkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSB0d28gbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gMiAmJiBpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IyZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdIG9yIGZsYXQvVHlwZWRBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA9PT0gMSAmJiBzaGFwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvcjJkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCAnICtcbiAgICAgICAgICAgICAgICAnYXJlIGEgZmxhdC9UeXBlZEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2hhcGUgPSBzaGFwZSB8fCBpbmZlcnJlZFNoYXBlO1xuICAgICAgICByZXR1cm4gQXJyYXlPcHMudGVuc29yKHZhbHVlcywgc2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRlbnNvcjNkID0gZnVuY3Rpb24gKHZhbHVlcywgc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmIChzaGFwZSAhPSBudWxsICYmIHNoYXBlLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdGhyZWUgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gMyAmJiBpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IzZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoID09PSAxICYmIHNoYXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgICcgK1xuICAgICAgICAgICAgICAgICdhcmUgYSBmbGF0IGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2hhcGUgPSBzaGFwZSB8fCBpbmZlcnJlZFNoYXBlO1xuICAgICAgICByZXR1cm4gQXJyYXlPcHMudGVuc29yKHZhbHVlcywgc2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRlbnNvcjRkID0gZnVuY3Rpb24gKHZhbHVlcywgc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmIChzaGFwZSAhPSBudWxsICYmIHNoYXBlLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgZm91ciBudW1iZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoICE9PSA0ICYmIGluZmVycmVkU2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvcjRkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA9PT0gMSAmJiBzaGFwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvcjRkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCAnICtcbiAgICAgICAgICAgICAgICAnYXJlIGEgZmxhdCBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlID0gc2hhcGUgfHwgaW5mZXJyZWRTaGFwZTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcih2YWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy50ZW5zb3I1ZCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICBpZiAoc2hhcGUgIT0gbnVsbCAmJiBzaGFwZS5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIGZpdmUgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gNSAmJiBpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3I1ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBcXFxuICAgICAgICAgICBudW1iZXJbXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA9PT0gMSAmJiBzaGFwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCAnICtcbiAgICAgICAgICAgICAgICAnYXJlIGEgZmxhdCBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlID0gc2hhcGUgfHwgaW5mZXJyZWRTaGFwZTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcih2YWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5vbmVzID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICB2YXIgdmFsdWVzID0gbWFrZU9uZXNUeXBlZEFycmF5KHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSksIGR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHNoYXBlLCB7IHZhbHVlczogdmFsdWVzIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnplcm9zID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICB2YXIgdmFsdWVzID0gbWFrZVplcm9zVHlwZWRBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpLCBkdHlwZSk7XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5maWxsID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIHZhbHVlcyA9IHV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShkdHlwZSwgdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKSk7XG4gICAgICAgIHZhbHVlcy5maWxsKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHNoYXBlLCB7IHZhbHVlczogdmFsdWVzIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLm9uZXNMaWtlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnb25lc0xpa2UnKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLm9uZXMoeC5zaGFwZSwgeC5kdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy56ZXJvc0xpa2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICd6ZXJvc0xpa2UnKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnplcm9zKHguc2hhcGUsIHguZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuY2xvbmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdjbG9uZScpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS50b0Zsb2F0KCk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IGRhdGFJZDogeC5kYXRhSWQgfSwgeC5kdHlwZSk7XG4gICAgICAgIH0sIHsgeDogeCB9LCBkZXIpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuZXllID0gZnVuY3Rpb24gKG51bVJvd3MsIG51bUNvbHVtbnMsIGJhdGNoU2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmIChudW1Db2x1bW5zID09IG51bGwpIHtcbiAgICAgICAgICAgIG51bUNvbHVtbnMgPSBudW1Sb3dzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBBcnJheU9wcy5idWZmZXIoW251bVJvd3MsIG51bUNvbHVtbnNdLCBkdHlwZSk7XG4gICAgICAgIHZhciBuID0gbnVtUm93cyA8PSBudW1Db2x1bW5zID8gbnVtUm93cyA6IG51bUNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBidWZmZXIuc2V0KDEsIGksIGkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBidWZmZXIudG9UZW5zb3IoKS5hczJEKG51bVJvd3MsIG51bUNvbHVtbnMpO1xuICAgICAgICBpZiAoYmF0Y2hTaGFwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJhdGNoU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRpbGUoQXJyYXlPcHMuZXhwYW5kRGltcyhvdXQsIDApLCBbYmF0Y2hTaGFwZVswXSwgMSwgMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmF0Y2hTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXlPcHMudGlsZShBcnJheU9wcy5leHBhbmREaW1zKEFycmF5T3BzLmV4cGFuZERpbXMob3V0LCAwKSwgMCksIFtiYXRjaFNoYXBlWzBdLCBiYXRjaFNoYXBlWzFdLCAxLCAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleWUoKSBjdXJyZW50bHkgc3VwcG9ydHMgb25seSAxRCBhbmQgMkQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJiYXRjaFNoYXBlcywgYnV0IHJlY2VpdmVkIFwiICsgYmF0Y2hTaGFwZS5sZW5ndGggKyBcIkQuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQXJyYXlPcHMucmFuZG9tTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYsIGR0eXBlLCBzZWVkKSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgaWYgKGR0eXBlICE9IG51bGwgJiYgZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5kR2F1c3MgPSBuZXcgcmFuZF8xLk1QUmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgZHR5cGUsIGZhbHNlLCBzZWVkKTtcbiAgICAgICAgdmFyIHJlcyA9IEFycmF5T3BzLmJ1ZmZlcihzaGFwZSwgZHR5cGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy52YWx1ZXNbaV0gPSByYW5kR2F1c3MubmV4dFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy50b1RlbnNvcigpO1xuICAgIH07XG4gICAgQXJyYXlPcHMudHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYsIGR0eXBlLCBzZWVkKSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgaWYgKGR0eXBlICE9IG51bGwgJiYgZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5kR2F1c3MgPSBuZXcgcmFuZF8xLk1QUmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgZHR5cGUsIHRydWUsIHNlZWQpO1xuICAgICAgICB2YXIgcmVzID0gQXJyYXlPcHMuYnVmZmVyKHNoYXBlLCBkdHlwZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzLnZhbHVlc1tpXSA9IHJhbmRHYXVzcy5uZXh0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5yYW5kb21Vbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBtaW52YWwsIG1heHZhbCwgZHR5cGUpIHtcbiAgICAgICAgaWYgKG1pbnZhbCA9PT0gdm9pZCAwKSB7IG1pbnZhbCA9IDA7IH1cbiAgICAgICAgaWYgKG1heHZhbCA9PT0gdm9pZCAwKSB7IG1heHZhbCA9IDE7IH1cbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIHJlcyA9IEFycmF5T3BzLmJ1ZmZlcihzaGFwZSwgZHR5cGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy52YWx1ZXNbaV0gPSB1dGlsLnJhbmRVbmlmb3JtKG1pbnZhbCwgbWF4dmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5yYW5kID0gZnVuY3Rpb24gKHNoYXBlLCByYW5kRnVuY3Rpb24sIGR0eXBlKSB7XG4gICAgICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG51bGw7XG4gICAgICAgIGlmIChkdHlwZSA9PSBudWxsIHx8IGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHJhbmRGdW5jdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5tdWx0aW5vbWlhbCA9IGZ1bmN0aW9uIChsb2dpdHMsIG51bVNhbXBsZXMsIHNlZWQsIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMCkgeyBub3JtYWxpemVkID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgbG9naXRzOiBsb2dpdHMgfSwgJ211bHRpbm9taWFsJyk7XG4gICAgICAgIHZhciBudW1PdXRjb21lcyA9IGxvZ2l0cy5zaXplO1xuICAgICAgICB2YXIgb3JpZ1JhbmsgPSBsb2dpdHMucmFuaztcbiAgICAgICAgaWYgKG51bU91dGNvbWVzIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbXVsdGlub21pYWw6IHlvdSBuZWVkIGF0IGxlYXN0IDIgb3V0Y29tZXMsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgICAgIChudW1PdXRjb21lcyArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdSYW5rID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuayBvZiBwcm9iYWJpbGl0aWVzIG11c3QgYmUgMSBvciAyLCBidXQgaXMgXCIgKyBvcmlnUmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdmFyIGxvZ2l0czJEID0gb3JpZ1JhbmsgPT09IDEgPyBsb2dpdHMuYXMyRCgxLCAtMSkgOiBsb2dpdHM7XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm11bHRpbm9taWFsKGxvZ2l0czJELCBub3JtYWxpemVkLCBudW1TYW1wbGVzLCBzZWVkKTsgfSwgeyBsb2dpdHMyRDogbG9naXRzMkQgfSk7XG4gICAgICAgIHJldHVybiBvcmlnUmFuayA9PT0gMSA/IHJlcy5hczFEKCkgOiByZXM7XG4gICAgfTtcbiAgICBBcnJheU9wcy5vbmVIb3QgPSBmdW5jdGlvbiAoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIGlmIChvblZhbHVlID09PSB2b2lkIDApIHsgb25WYWx1ZSA9IDE7IH1cbiAgICAgICAgaWYgKG9mZlZhbHVlID09PSB2b2lkIDApIHsgb2ZmVmFsdWUgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGluZGljZXMuZHR5cGUgPT09ICdpbnQzMicsICdJbmRpY2VzIG11c3QgYmUgb2YgZHR5cGUgYGludDMyYCcpO1xuICAgICAgICBpZiAoZGVwdGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBvbmVIb3Q6IGRlcHRoIG11c3QgYmUgPj0yLCBidXQgaXQgaXMgXCIgKyBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQub25lSG90KGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSk7IH0sIHsgaW5kaWNlczogaW5kaWNlcyB9KTtcbiAgICB9O1xuICAgIEFycmF5T3BzLmZyb21QaXhlbHMgPSBmdW5jdGlvbiAocGl4ZWxzLCBudW1DaGFubmVscykge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IHZvaWQgMCkgeyBudW1DaGFubmVscyA9IDM7IH1cbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IFRlbnNvciB3aXRoIG1vcmUgdGhhbiA0IGNoYW5uZWxzIGZyb20gcGl4ZWxzLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZnJvbVBpeGVscyhwaXhlbHMsIG51bUNoYW5uZWxzKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRvUGl4ZWxzID0gZnVuY3Rpb24gKGltZywgY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgaGVpZ2h0LCB3aWR0aCwgZGVwdGgsIG1pblRlbnNvciwgbWF4VGVuc29yLCBtaW4sIG1heCwgZGF0YSwgbXVsdGlwbGllciwgYnl0ZXMsIGksIHIsIGcsIGIsIGEsIGosIGN0eCwgaW1hZ2VEYXRhO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgaW1nOiBpbWcgfSwgJ3RvUGl4ZWxzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1nLnJhbmsgIT09IDIgJiYgaW1nLnJhbmsgIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b1BpeGVscyBvbmx5IHN1cHBvcnRzIHJhbmsgMiBvciAzIHRlbnNvcnMsIGdvdCByYW5rIFwiICsgaW1nLnJhbmsgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGltZy5zaGFwZS5zbGljZSgwLCAyKSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGltZy5yYW5rID09PSAyID8gMSA6IGltZy5zaGFwZVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IDQgfHwgZGVwdGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b1BpeGVscyBvbmx5IHN1cHBvcnRzIGRlcHRoIG9mIHNpemUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCIxLCAzIG9yIDQgYnV0IGdvdCBcIiArIGRlcHRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5UZW5zb3IgPSBpbWcubWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhUZW5zb3IgPSBpbWcubWF4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1pblRlbnNvci5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSAoX2Iuc2VudCgpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbWF4VGVuc29yLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IChfYi5zZW50KCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluVGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFRlbnNvci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1nLmR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluIDwgMCB8fCBtYXggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgZmxvYXQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwicmFuZ2UgWzAgLSAxXSBidXQgZ290IHJhbmdlIFtcIiArIG1pbiArIFwiIC0gXCIgKyBtYXggKyBcIl0uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbWcuZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluIDwgMCB8fCBtYXggPiAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIHZhbHVlcyBmb3IgYSBpbnQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwicmFuZ2UgWzAgLSAyNTVdIGJ1dCBnb3QgcmFuZ2UgW1wiICsgbWluICsgXCIgLSBcIiArIG1heCArIFwiXS5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgZm9yIHRvUGl4ZWxzOiBcIiArIGltZy5kdHlwZSArIFwiLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgUGxlYXNlIHVzZSBmbG9hdDMyIG9yIGludDMyIHRlbnNvcnMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBpbWcuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSBpbWcuZHR5cGUgPT09ICdmbG9hdDMyJyA/IDI1NSA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhlaWdodCAqIHdpZHRoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdm9pZCAwLCBnID0gdm9pZCAwLCBiID0gdm9pZCAwLCBhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gZGF0YVtpXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBkYXRhW2ldICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGRhdGFbaV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gZGF0YVtpICogM10gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gZGF0YVtpICogMyArIDFdICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGRhdGFbaSAqIDMgKyAyXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBkYXRhW2kgKiA0XSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBkYXRhW2kgKiA0ICsgMV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gZGF0YVtpICogNCArIDJdICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGRhdGFbaSAqIDQgKyAzXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpICogNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tqICsgMF0gPSBNYXRoLnJvdW5kKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2ogKyAxXSA9IE1hdGgucm91bmQoZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaiArIDJdID0gTWF0aC5yb3VuZChiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tqICsgM10gPSBNYXRoLnJvdW5kKGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKGJ5dGVzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGJ5dGVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5yZXNoYXBlID0gZnVuY3Rpb24gKHgsIHNoYXBlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3Jlc2hhcGUnKTtcbiAgICAgICAgc2hhcGUgPSB1dGlsLmluZmVyRnJvbUltcGxpY2l0U2hhcGUoc2hhcGUsIHguc2l6ZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHguc2l6ZSA9PT0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKSwgJ25ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5yZXNoYXBlKHguc2hhcGUpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnJlc2hhcGUoeCwgc2hhcGUpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5zcXVlZXplID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc3F1ZWV6ZScpO1xuICAgICAgICByZXR1cm4gQXJyYXlPcHMucmVzaGFwZSh4LCB1dGlsLnNxdWVlemVTaGFwZSh4LnNoYXBlLCBheGlzKS5uZXdTaGFwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5jYXN0ID0gZnVuY3Rpb24gKHgsIGR0eXBlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2Nhc3QnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmNsb25lKCk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuY2FzdCh4LCBkdHlwZSk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRpbGUgPSBmdW5jdGlvbiAoeCwgcmVwcykge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICd0aWxlJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gcmVwcy5sZW5ndGgsIFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiICsgeC5yYW5rICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBsZW5ndGggb2YgcmVwcyBcIiArIHJlcHMgKyBcIi5cIikpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIGRlclggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhHcmFkID0gQXJyYXlPcHMuemVyb3NMaWtlKHgpO1xuICAgICAgICAgICAgICAgIGlmICh4LnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBzWzBdOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhHcmFkID0geEdyYWQuYWRkKGR5LnNsaWNlKFtpICogeC5zaGFwZVswXV0sIFt4LnNoYXBlWzBdXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcHNbMF07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBzWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4R3JhZCA9IHhHcmFkLmFkZChkeS5zbGljZShbaSAqIHguc2hhcGVbMF0sIGogKiB4LnNoYXBlWzFdXSwgW3guc2hhcGVbMF0sIHguc2hhcGVbMV1dKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwc1swXTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcHNbMV07ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmVwc1syXTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhHcmFkID0geEdyYWQuYWRkKGR5LnNsaWNlKFtpICogeC5zaGFwZVswXSwgaiAqIHguc2hhcGVbMV0sIGsgKiB4LnNoYXBlWzJdXSwgW3guc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl1dKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcHNbMF07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBzWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJlcHNbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHJlcHNbM107ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeEdyYWQgPSB4R3JhZC5hZGQoZHkuc2xpY2UoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKiB4LnNoYXBlWzBdLCBqICogeC5zaGFwZVsxXSwgayAqIHguc2hhcGVbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAqIHguc2hhcGVbM11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sIFt4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdLCB4LnNoYXBlWzNdXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmb3IgdGlsZSBvcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvciByYW5rLVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh4LnJhbmsgKyBcIiB0ZW5zb3JzIHlldC5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geEdyYWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZGVyWCB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC50aWxlKHgsIHJlcHMpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5nYXRoZXIgPSBmdW5jdGlvbiAoeCwgaW5kaWNlcywgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHgsIGluZGljZXM6IGluZGljZXMgfSwgJ2dhdGhlcicpO1xuICAgICAgICB1dGlsLmFzc2VydChpbmRpY2VzLmR0eXBlID09PSAnaW50MzInLCAnSW5kaWNlcyBtdXN0IGJlIG9mIGR0eXBlIGBpbnQzMmAnKTtcbiAgICAgICAgYXhpcyA9IGF4aXNfdXRpbF8xLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpWzBdO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIGRlclggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMudW5zb3J0ZWRTZWdtZW50U3VtKGR5LCBpbmRpY2VzLCB4LnNoYXBlW2F4aXNdLCBheGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyB4OiBkZXJYIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmdhdGhlcih4LCBpbmRpY2VzLCBheGlzKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucGFkMWQgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnN0YW50VmFsdWUgPT09IHZvaWQgMCkgeyBjb25zdGFudFZhbHVlID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydChwYWRkaW5ncy5sZW5ndGggPT09IDIsICdJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMi4nKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnBhZCh4LCBbcGFkZGluZ3NdLCBjb25zdGFudFZhbHVlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnBhZDJkID0gZnVuY3Rpb24gKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIGlmIChjb25zdGFudFZhbHVlID09PSB2b2lkIDApIHsgY29uc3RhbnRWYWx1ZSA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQocGFkZGluZ3MubGVuZ3RoID09PSAyICYmIHBhZGRpbmdzWzBdLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgcGFkZGluZ3NbMV0ubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC4nKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnBhZCh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5wYWQzZCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICBpZiAoY29uc3RhbnRWYWx1ZSA9PT0gdm9pZCAwKSB7IGNvbnN0YW50VmFsdWUgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHBhZGRpbmdzLmxlbmd0aCA9PT0gMyAmJiBwYWRkaW5nc1swXS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhZGRpbmdzWzFdLmxlbmd0aCA9PT0gMiAmJiBwYWRkaW5nc1syXS5sZW5ndGggPT09IDIsICdJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLicpO1xuICAgICAgICByZXR1cm4gQXJyYXlPcHMucGFkKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnBhZDRkID0gZnVuY3Rpb24gKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIGlmIChjb25zdGFudFZhbHVlID09PSB2b2lkIDApIHsgY29uc3RhbnRWYWx1ZSA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQocGFkZGluZ3MubGVuZ3RoID09PSA0ICYmIHBhZGRpbmdzWzBdLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgcGFkZGluZ3NbMV0ubGVuZ3RoID09PSAyICYmIHBhZGRpbmdzWzJdLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgcGFkZGluZ3NbM10ubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC4nKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnBhZCh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5wYWQgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnN0YW50VmFsdWUgPT09IHZvaWQgMCkgeyBjb25zdGFudFZhbHVlID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdwYWQnKTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQoc2NhbGFyKSBpcyBub3QgZGVmaW5lZC4gUGFzcyBub24tc2NhbGFyIHRvIHBhZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWdpbiA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5zbGljZShiZWdpbiwgeC5zaGFwZSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQucGFkKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuc3RhY2sgPSBmdW5jdGlvbiAodGVuc29ycywgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHRlbnNvcnM6IHRlbnNvcnMgfSwgJ3N0YWNrJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRlbnNvcnMubGVuZ3RoID49IDEsICdQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuc3RhY2snKTtcbiAgICAgICAgaWYgKHRlbnNvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVuc29yc1swXS5leHBhbmREaW1zKGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5rID0gdGVuc29yc1swXS5yYW5rO1xuICAgICAgICB2YXIgc2hhcGUgPSB0ZW5zb3JzWzBdLnNoYXBlO1xuICAgICAgICB2YXIgZHR5cGUgPSB0ZW5zb3JzWzBdLmR0eXBlO1xuICAgICAgICB1dGlsLmFzc2VydChheGlzIDw9IHJhbmssICdBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yJyk7XG4gICAgICAgIHRlbnNvcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgdC5zaGFwZSwgJ0FsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgc2hhcGVzJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGR0eXBlID09PSB0LmR0eXBlLCAnQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBkdHlwZXMnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBleHBhbmRlZFRlbnNvcnMgPSB0ZW5zb3JzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5leHBhbmREaW1zKGF4aXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLkNvbmNhdE9wcy5jb25jYXQoZXhwYW5kZWRUZW5zb3JzLCBheGlzKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnVuc3RhY2sgPSBmdW5jdGlvbiAodmFsdWUsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB2YXIgbnVtID0gdmFsdWUuc2hhcGVbYXhpc107XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IEFycmF5KHZhbHVlLnJhbmsgLSAxKS5maWxsKDApO1xuICAgICAgICB2YXIgb3V0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLnJhbms7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgIT09IGF4aXMpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtvdXRJbmRleF0gPSB2YWx1ZS5zaGFwZVtpXTtcbiAgICAgICAgICAgICAgICBvdXRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzcGxpdFNpemVzO1xuICAgICAgICBzcGxpdFNpemVzID0gQXJyYXkobnVtKS5maWxsKDEpO1xuICAgICAgICB2YXIgYmVnaW4gPSBBcnJheSh2YWx1ZS5yYW5rKS5maWxsKDApO1xuICAgICAgICB2YXIgc2l6ZSA9IHZhbHVlLnNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBzcGxpdFNpemVzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgc2l6ZVtheGlzXSA9IHM7XG4gICAgICAgICAgICB2YXIgc2xpY2UgPSB2YWx1ZS5zbGljZShiZWdpbiwgc2l6ZSk7XG4gICAgICAgICAgICBiZWdpbltheGlzXSArPSBzO1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLnJlc2hhcGUob3V0cHV0U2hhcGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnNwbGl0ID0gZnVuY3Rpb24gKHgsIG51bU9yU2l6ZVNwbGl0cywgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3NwbGl0Jyk7XG4gICAgICAgIGF4aXMgPSBheGlzX3V0aWxfMS5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKVswXTtcbiAgICAgICAgdmFyIHNwbGl0U2l6ZXM7XG4gICAgICAgIGlmICh0eXBlb2YgKG51bU9yU2l6ZVNwbGl0cykgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh4LnNoYXBlW2F4aXNdICUgbnVtT3JTaXplU3BsaXRzID09PSAwLCAnTnVtYmVyIG9mIHNwbGl0cyBtdXN0IGV2ZW5seSBkaXZpZGUgdGhlIGF4aXMuJyk7XG4gICAgICAgICAgICBzcGxpdFNpemVzID0gQXJyYXkobnVtT3JTaXplU3BsaXRzKS5maWxsKHguc2hhcGVbYXhpc10gLyBudW1PclNpemVTcGxpdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoeC5zaGFwZVtheGlzXSA9PT0gbnVtT3JTaXplU3BsaXRzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0pLCAnVGhlIHN1bSBvZiBzaXplcyBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIHRoZSBheGlzIGRpbWVuc2lvbi4nKTtcbiAgICAgICAgICAgIHNwbGl0U2l6ZXMgPSBudW1PclNpemVTcGxpdHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZ2luID0gQXJyYXkoeC5yYW5rKS5maWxsKDApO1xuICAgICAgICB2YXIgc2l6ZSA9IHguc2hhcGUuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIHNwbGl0U2l6ZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBzaXplW2F4aXNdID0gcztcbiAgICAgICAgICAgIHZhciBzbGljZSA9IHguc2xpY2UoYmVnaW4sIHNpemUpO1xuICAgICAgICAgICAgYmVnaW5bYXhpc10gKz0gcztcbiAgICAgICAgICAgIHJldHVybiBzbGljZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5jdW1zdW0gPSBmdW5jdGlvbiAoeCwgYXhpcywgZXhjbHVzaXZlLCByZXZlcnNlKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgaWYgKGV4Y2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGV4Y2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChyZXZlcnNlID09PSB2b2lkIDApIHsgcmV2ZXJzZSA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2N1bXN1bScpO1xuICAgICAgICBheGlzID0gYXhpcyB8IDA7XG4gICAgICAgIHZhciBwZXJtdXRhdGlvbiA9IGF4aXNfdXRpbF8xLmdldEF4ZXNQZXJtdXRhdGlvbihbYXhpc10sIHgucmFuayk7XG4gICAgICAgIHZhciBwZXJtdXRlZFggPSB4O1xuICAgICAgICBpZiAocGVybXV0YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGVybXV0ZWRYID0geC50cmFuc3Bvc2UocGVybXV0YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJtdXRlZEF4aXMgPSBheGlzX3V0aWxfMS5nZXRJbm5lck1vc3RBeGVzKDEsIHgucmFuaylbMF07XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBwZXJtdXRlZFg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmN1bXN1bShheGlzLCBleGNsdXNpdmUsICFyZXZlcnNlKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdmFsdWUgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmN1bXN1bShwZXJtdXRlZFgsIHBlcm11dGVkQXhpcywgZXhjbHVzaXZlLCByZXZlcnNlKTsgfSwgeyBwZXJtdXRlZFg6IHBlcm11dGVkWCB9LCBncmFkKTtcbiAgICAgICAgaWYgKHBlcm11dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJhbnNwb3NlKHBlcm11dGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheU9wcy5leHBhbmREaW1zID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdleHBhbmREaW1zJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGF4aXMgPD0geC5yYW5rLCAnQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvcicpO1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgICAgIG5ld1NoYXBlLnNwbGljZShheGlzLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnJlc2hhcGUoeCwgbmV3U2hhcGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMubGluc3BhY2UgPSBmdW5jdGlvbiAoc3RhcnQsIHN0b3AsIG51bSkge1xuICAgICAgICBpZiAobnVtID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXF1ZXN0IHplcm8gc2FtcGxlcycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyAobnVtIC0gMSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBtYWtlWmVyb3NUeXBlZEFycmF5KG51bSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgdmFsdWVzWzBdID0gc3RhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbaSAtIDFdICsgc3RlcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXlPcHMudGVuc29yMWQodmFsdWVzLCAnZmxvYXQzMicpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIHN0b3AsIHN0ZXAsIGR0eXBlKSB7XG4gICAgICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDE7IH1cbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgYSBzdGVwIG9mIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2FtZVN0YXJ0U3RvcCA9IHN0YXJ0ID09PSBzdG9wO1xuICAgICAgICB2YXIgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwID0gc3RhcnQgPCBzdG9wICYmIHN0ZXAgPCAwO1xuICAgICAgICB2YXIgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwID0gc3RvcCA8IHN0YXJ0ICYmIHN0ZXAgPiAxO1xuICAgICAgICBpZiAoc2FtZVN0YXJ0U3RvcCB8fCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgfHxcbiAgICAgICAgICAgIGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5T3BzLnplcm9zKFswXSwgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1FbGVtZW50cyA9IE1hdGguYWJzKE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG1ha2VaZXJvc1R5cGVkQXJyYXkobnVtRWxlbWVudHMsIGR0eXBlKTtcbiAgICAgICAgaWYgKHN0b3AgPCBzdGFydCAmJiBzdGVwID09PSAxKSB7XG4gICAgICAgICAgICBzdGVwID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzWzBdID0gc3RhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbaSAtIDFdICsgc3RlcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXlPcHMudGVuc29yMWQodmFsdWVzLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5idWZmZXIgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0ZW5zb3JfMS5UZW5zb3JCdWZmZXIoc2hhcGUsIGR0eXBlLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucHJpbnQgPSBmdW5jdGlvbiAoeCwgdmVyYm9zZSkge1xuICAgICAgICBpZiAodmVyYm9zZSA9PT0gdm9pZCAwKSB7IHZlcmJvc2UgPSBmYWxzZTsgfVxuICAgICAgICBjb25zb2xlLmxvZyh0ZW5zb3JfdXRpbC50ZW5zb3JUb1N0cmluZyh4LCB2ZXJib3NlKSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwidGVuc29yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJzY2FsYXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInRlbnNvcjFkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJ0ZW5zb3IyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwidGVuc29yM2RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInRlbnNvcjRkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJ0ZW5zb3I1ZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJvbmVzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInplcm9zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImZpbGxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwib25lc0xpa2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwiemVyb3NMaWtlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImNsb25lXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImV5ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJyYW5kb21Ob3JtYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwidHJ1bmNhdGVkTm9ybWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInJhbmRvbVVuaWZvcm1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInJhbmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcIm11bHRpbm9taWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcIm9uZUhvdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJmcm9tUGl4ZWxzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVmlzdWFsaXphdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJ0b1BpeGVsc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnVHJhbnNmb3JtYXRpb25zJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwicmVzaGFwZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnVHJhbnNmb3JtYXRpb25zJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInNxdWVlemVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1RyYW5zZm9ybWF0aW9ucycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImNhc3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJ0aWxlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwiZ2F0aGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdUcmFuc2Zvcm1hdGlvbnMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJwYWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJzdGFja1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnU2xpY2luZyBhbmQgSm9pbmluZycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInVuc3RhY2tcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJzcGxpdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnU2NhbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJjdW1zdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1RyYW5zZm9ybWF0aW9ucycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImV4cGFuZERpbXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvbixcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwibGluc3BhY2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvbixcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwicmFuZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcImJ1ZmZlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwicHJpbnRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIEFycmF5T3BzO1xufSgpKTtcbmV4cG9ydHMuQXJyYXlPcHMgPSBBcnJheU9wcztcbmZ1bmN0aW9uIG1ha2VaZXJvc1R5cGVkQXJyYXkoc2l6ZSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgJCB7ZHR5cGV9XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VPbmVzVHlwZWRBcnJheShzaXplLCBkdHlwZSkge1xuICAgIHZhciBhcnJheSA9IG1ha2VaZXJvc1R5cGVkQXJyYXkoc2l6ZSwgZHR5cGUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiB0b1R5cGVkQXJyYXkoYSwgZHR5cGUpIHtcbiAgICBpZiAobm9Db252ZXJzaW9uTmVlZGVkKGEsIGR0eXBlKSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgYSA9IHV0aWwuZmxhdHRlbihhKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWwuY29weVR5cGVkQXJyYXkoYSwgZHR5cGUpO1xufVxuZnVuY3Rpb24gbm9Db252ZXJzaW9uTmVlZGVkKGEsIGR0eXBlKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmIGR0eXBlID09PSAnZmxvYXQzMicpIHx8XG4gICAgICAgIChhIGluc3RhbmNlb2YgSW50MzJBcnJheSAmJiBkdHlwZSA9PT0gJ2ludDMyJykgfHxcbiAgICAgICAgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGR0eXBlID09PSAnYm9vbCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXlfb3BzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGF4ZXNBcmVJbm5lck1vc3REaW1zKGF4ZXMsIHJhbmspIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGF4ZXNbYXhlcy5sZW5ndGggLSBpIC0gMV0gIT09IHJhbmsgLSAxIC0gaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5heGVzQXJlSW5uZXJNb3N0RGltcyA9IGF4ZXNBcmVJbm5lck1vc3REaW1zO1xuZnVuY3Rpb24gY29tYmluZUxvY2F0aW9ucyhvdXRwdXRMb2MsIHJlZHVjZUxvYywgYXhlcykge1xuICAgIHZhciByYW5rID0gb3V0cHV0TG9jLmxlbmd0aCArIHJlZHVjZUxvYy5sZW5ndGg7XG4gICAgdmFyIGxvYyA9IFtdO1xuICAgIHZhciBvdXRJZHggPSAwO1xuICAgIHZhciByZWR1Y2VJZHggPSAwO1xuICAgIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxvYy5wdXNoKG91dHB1dExvY1tvdXRJZHgrK10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9jLnB1c2gocmVkdWNlTG9jW3JlZHVjZUlkeCsrXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvYztcbn1cbmV4cG9ydHMuY29tYmluZUxvY2F0aW9ucyA9IGNvbWJpbmVMb2NhdGlvbnM7XG5mdW5jdGlvbiBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGFTaGFwZSwgYXhlcykge1xuICAgIHZhciBvdXRTaGFwZSA9IFtdO1xuICAgIHZhciByYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBvdXRTaGFwZS5wdXNoKGFTaGFwZVtkaW1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVkdWNlU2hhcGUgPSBheGVzLm1hcChmdW5jdGlvbiAoZGltKSB7IHJldHVybiBhU2hhcGVbZGltXTsgfSk7XG4gICAgcmV0dXJuIFtvdXRTaGFwZSwgcmVkdWNlU2hhcGVdO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzID0gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcztcbmZ1bmN0aW9uIGV4cGFuZFNoYXBlVG9LZWVwRGltKHNoYXBlLCBheGVzKSB7XG4gICAgdmFyIHJlZHVjZVN1YlNoYXBlID0gYXhlcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIDE7IH0pO1xuICAgIHJldHVybiBjb21iaW5lTG9jYXRpb25zKHNoYXBlLCByZWR1Y2VTdWJTaGFwZSwgYXhlcyk7XG59XG5leHBvcnRzLmV4cGFuZFNoYXBlVG9LZWVwRGltID0gZXhwYW5kU2hhcGVUb0tlZXBEaW07XG5mdW5jdGlvbiBwYXJzZUF4aXNQYXJhbShheGlzLCBzaGFwZSkge1xuICAgIHZhciByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGF4aXMgPSBheGlzID09IG51bGwgPyBzaGFwZS5tYXAoZnVuY3Rpb24gKHMsIGkpIHsgcmV0dXJuIGk7IH0pIDogW10uY29uY2F0KGF4aXMpO1xuICAgIHV0aWwuYXNzZXJ0KGF4aXMuZXZlcnkoZnVuY3Rpb24gKGF4KSB7IHJldHVybiBheCA+PSAtcmFuayAmJiBheCA8IHJhbms7IH0pLCBcIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstXCIgKyByYW5rICsgXCIsIFwiICsgcmFuayArIFwiKSBidXQgXCIgK1xuICAgICAgICAoXCJnb3QgYXhpcyBcIiArIGF4aXMpKTtcbiAgICB1dGlsLmFzc2VydChheGlzLmV2ZXJ5KGZ1bmN0aW9uIChheCkgeyByZXR1cm4gdXRpbC5pc0ludChheCk7IH0pLCBcIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCBcIiArXG4gICAgICAgIChcImdvdCBheGlzIFwiICsgYXhpcykpO1xuICAgIHJldHVybiBheGlzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSA8IDAgPyByYW5rICsgYSA6IGE7IH0pO1xufVxuZXhwb3J0cy5wYXJzZUF4aXNQYXJhbSA9IHBhcnNlQXhpc1BhcmFtO1xuZnVuY3Rpb24gYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMobXNnLCBheGVzLCByYW5rKSB7XG4gICAgdXRpbC5hc3NlcnQoYXhlc0FyZUlubmVyTW9zdERpbXMoYXhlcywgcmFuayksIG1zZyArIFwiIHN1cHBvcnRzIG9ubHkgaW5uZXItbW9zdCBheGVzIGZvciBub3cuIFwiICtcbiAgICAgICAgKFwiR290IGF4ZXMgXCIgKyBheGVzICsgXCIgYW5kIHJhbmstXCIgKyByYW5rICsgXCIgaW5wdXQuXCIpKTtcbn1cbmV4cG9ydHMuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMgPSBhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcztcbmZ1bmN0aW9uIGdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCByYW5rKSB7XG4gICAgaWYgKGF4ZXNBcmVJbm5lck1vc3REaW1zKGF4ZXMsIHJhbmspKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXhpcykgeyByZXR1cm4gcmVzdWx0LnB1c2goYXhpcyk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmdldEF4ZXNQZXJtdXRhdGlvbiA9IGdldEF4ZXNQZXJtdXRhdGlvbjtcbmZ1bmN0aW9uIGdldFVuZG9BeGVzUGVybXV0YXRpb24oYXhlcykge1xuICAgIHJldHVybiBheGVzLm1hcChmdW5jdGlvbiAoYXhpcywgaSkgeyByZXR1cm4gW2ksIGF4aXNdOyB9KVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHhbMF07IH0pO1xufVxuZXhwb3J0cy5nZXRVbmRvQXhlc1Blcm11dGF0aW9uID0gZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbjtcbmZ1bmN0aW9uIGdldElubmVyTW9zdEF4ZXMobnVtQXhlcywgcmFuaykge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gcmFuayAtIG51bUF4ZXM7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmdldElubmVyTW9zdEF4ZXMgPSBnZXRJbm5lck1vc3RBeGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXhpc191dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBhcnJheV9vcHNfMSA9IHJlcXVpcmUoXCIuL2FycmF5X29wc1wiKTtcbnZhciBicm9hZGNhc3RfdXRpbF8xID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi9vcHNcIik7XG52YXIgQmF0Y2hOb3JtT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXRjaE5vcm1PcHMoKSB7XG4gICAgfVxuICAgIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24yZCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMiwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gMiB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG1lYW4gbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDIgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gMiB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDIgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbih4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTtcbiAgICB9O1xuICAgIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24zZCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gMyB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IG1lYW4gbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDMgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gMyB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDMgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IG9mZnNldCBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbih4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTtcbiAgICB9O1xuICAgIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb240ZCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gNCwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gNCB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IG1lYW4gbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDQgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gNCB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiBzY2FsZSBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDQgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbih4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTtcbiAgICB9O1xuICAgIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4LCBtZWFuOiBtZWFuLCB2YXJpYW5jZTogdmFyaWFuY2UgfSwgJ2JhdGNoTm9ybWFsaXphdGlvbicpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgc2NhbGU6IHNjYWxlIH0sICdiYXRjaE5vcm1hbGl6YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IG9mZnNldDogb2Zmc2V0IH0sICdiYXRjaE5vcm1hbGl6YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChtZWFuLnJhbmsgPT09IHZhcmlhbmNlLnJhbmssICdCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHZhcmlhbmNlIHRvIGhhdmUgJyArXG4gICAgICAgICAgICAnZXF1YWwgcmFua3MuJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG9mZnNldCA9PSBudWxsIHx8IG1lYW4ucmFuayA9PT0gb2Zmc2V0LnJhbmssICdCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIG9mZnNldCB0byBoYXZlICcgK1xuICAgICAgICAgICAgJ2VxdWFsIHJhbmtzLicpO1xuICAgICAgICB1dGlsLmFzc2VydChzY2FsZSA9PSBudWxsIHx8IG1lYW4ucmFuayA9PT0gc2NhbGUucmFuaywgJ0JhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgc2NhbGUgdG8gaGF2ZSAnICtcbiAgICAgICAgICAgICdlcXVhbCByYW5rcy4nKTtcbiAgICAgICAgdmFyIHg0RDtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMCB8fCB4LnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCAxLCAxLCB4LnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMikge1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeDREID0geDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgc2NhbGVWYWx1ZSA9IHNjYWxlID09IG51bGwgPyBhcnJheV9vcHNfMS5BcnJheU9wcy5zY2FsYXIoMSkgOiBzY2FsZTtcbiAgICAgICAgICAgIHZhciByZWR1Y3Rpb25BeGVzID0gYnJvYWRjYXN0X3V0aWxfMS5nZXRSZWR1Y3Rpb25BeGVzKG1lYW4uc2hhcGUsIHg0RC5zaGFwZSk7XG4gICAgICAgICAgICB2YXIgdGlsZVNoYXBlID0gW107XG4gICAgICAgICAgICBpZiAobWVhbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4NEQuc2hhcGUubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVTaGFwZS5wdXNoKHg0RC5zaGFwZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbGVTaGFwZS5wdXNoKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHhNaW51c01lYW4gPSB4LnN1YihtZWFuKTtcbiAgICAgICAgICAgIHZhciBkeVRpbWVzU2NhbGVWYWx1ZSA9IGR5Lm11bChzY2FsZVZhbHVlKTtcbiAgICAgICAgICAgIHZhciBvbmVPdmVyU3FydFZhcmlhbmNlID0gb3BzXzEucnNxcnQodmFyaWFuY2UuYWRkKGFycmF5X29wc18xLkFycmF5T3BzLnNjYWxhcih2YXJpYW5jZUVwc2lsb24pKSk7XG4gICAgICAgICAgICB2YXIgbWludXNIYWxmUkN1YmUgPSBvbmVPdmVyU3FydFZhcmlhbmNlLm11bChvbmVPdmVyU3FydFZhcmlhbmNlKVxuICAgICAgICAgICAgICAgIC5tdWwob25lT3ZlclNxcnRWYXJpYW5jZSlcbiAgICAgICAgICAgICAgICAubXVsKGFycmF5X29wc18xLkFycmF5T3BzLnNjYWxhcigtMC41KSk7XG4gICAgICAgICAgICB2YXIgZGVyWCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVhbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bChhcnJheV9vcHNfMS5BcnJheU9wcy50aWxlKG9uZU92ZXJTcXJ0VmFyaWFuY2UuYXM0RCgxLCAxLCAxLCBtZWFuLnNoYXBlWzBdKSwgdGlsZVNoYXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tdWwoc2NhbGVWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXNoYXBlKHguc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR5Lm11bChvbmVPdmVyU3FydFZhcmlhbmNlKS5tdWwoc2NhbGVWYWx1ZSkucmVzaGFwZSh4LnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRlck1lYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lYW5EZXIgPSBvbmVPdmVyU3FydFZhcmlhbmNlLm11bChhcnJheV9vcHNfMS5BcnJheU9wcy5zY2FsYXIoLTEpKS5tdWwoZHlUaW1lc1NjYWxlVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChtZWFuLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVhbkRlciA9IG1lYW5EZXIuc3VtKHJlZHVjdGlvbkF4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVhbkRlci5yZXNoYXBlKG1lYW4uc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJWYXJpYW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFuY2VEZXIgPSBtaW51c0hhbGZSQ3ViZS5tdWwoeE1pbnVzTWVhbikubXVsKGR5VGltZXNTY2FsZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWVhbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhbmNlRGVyID0gdmFyaWFuY2VEZXIuc3VtKHJlZHVjdGlvbkF4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFuY2VEZXIucmVzaGFwZShtZWFuLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhNaW51c01lYW4yVGltZXNSc3FydCA9IHhNaW51c01lYW4ubXVsKG9uZU92ZXJTcXJ0VmFyaWFuY2UpO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZURlciA9IGR5Lm11bCh4TWludXNNZWFuMlRpbWVzUnNxcnQpO1xuICAgICAgICAgICAgICAgIGlmIChtZWFuLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVEZXIgPSBzY2FsZURlci5zdW0ocmVkdWN0aW9uQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZURlci5yZXNoYXBlKG1lYW4uc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldERlciA9IGR5O1xuICAgICAgICAgICAgICAgIGlmIChtZWFuLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0RGVyID0gb2Zmc2V0RGVyLnN1bShyZWR1Y3Rpb25BeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldERlci5yZXNoYXBlKG1lYW4uc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZGVyWCxcbiAgICAgICAgICAgICAgICBtZWFuOiBkZXJNZWFuLFxuICAgICAgICAgICAgICAgIHZhcmlhbmNlOiBkZXJWYXJpYW5jZSxcbiAgICAgICAgICAgICAgICBzY2FsZTogZGVyU2NhbGUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBkZXJPZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmJhdGNoTm9ybWFsaXphdGlvbih4NEQsIGJhdGNobm9ybVJlc2hhcGU0RChtZWFuKSwgYmF0Y2hub3JtUmVzaGFwZTREKHZhcmlhbmNlKSwgdmFyaWFuY2VFcHNpbG9uLCBiYXRjaG5vcm1SZXNoYXBlNEQoc2NhbGUpLCBiYXRjaG5vcm1SZXNoYXBlNEQob2Zmc2V0KSk7IH0sIHsgeDogeCwgbWVhbjogbWVhbiwgdmFyaWFuY2U6IHZhcmlhbmNlLCBzY2FsZTogc2NhbGUsIG9mZnNldDogb2Zmc2V0IH0sIGRlcik7XG4gICAgICAgIHJldHVybiByZXMucmVzaGFwZSh4LnNoYXBlKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCYXRjaE5vcm1PcHMsIFwiYmF0Y2hOb3JtYWxpemF0aW9uMmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJhdGNoTm9ybU9wcywgXCJiYXRjaE5vcm1hbGl6YXRpb24zZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmF0Y2hOb3JtT3BzLCBcImJhdGNoTm9ybWFsaXphdGlvbjRkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdOb3JtYWxpemF0aW9uJyB9KVxuICAgIF0sIEJhdGNoTm9ybU9wcywgXCJiYXRjaE5vcm1hbGl6YXRpb25cIiwgbnVsbCk7XG4gICAgcmV0dXJuIEJhdGNoTm9ybU9wcztcbn0oKSk7XG5leHBvcnRzLkJhdGNoTm9ybU9wcyA9IEJhdGNoTm9ybU9wcztcbmZ1bmN0aW9uIGJhdGNobm9ybVJlc2hhcGU0RCh4KSB7XG4gICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHgucmFuayA9PT0gMCkge1xuICAgICAgICByZXR1cm4geC5hczFEKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZWxzZSBpZiAoeC5yYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiB4LmFzNEQoMSwgMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhdGNobm9ybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIEJpbmFyeU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluYXJ5T3BzKCkge1xuICAgIH1cbiAgICBCaW5hcnlPcHMuYWRkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnYWRkJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKGEuc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYi5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYWRkKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5hZGRTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBhZGRTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5hZGQoYik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMuc3ViID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnc3ViJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKGEuc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYi5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5uZWcoKS5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc3VidHJhY3QoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLnN1YlN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHN1YlN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLnN1YihiKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5wb3cgPSBmdW5jdGlvbiAoYmFzZSwgZXhwKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGJhc2U6IGJhc2UsIGV4cDogZXhwIH0sICdwb3cnKTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYmFzZS5zaGFwZSwgZXhwLnNoYXBlKTtcbiAgICAgICAgYmFzZSA9IGJhc2UuY2FzdCh0eXBlc18xLnVwY2FzdFR5cGUoYmFzZS5kdHlwZSwgZXhwLmR0eXBlKSk7XG4gICAgICAgIGV4cCA9IGV4cC5jYXN0KHR5cGVzXzEudXBjYXN0VHlwZShiYXNlLmR0eXBlLCBleHAuZHR5cGUpKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHksIHNhdmVkKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHNhdmVkWzBdO1xuICAgICAgICAgICAgdmFyIGRlckJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5Lm11bChleHAudG9GbG9hdCgpLm11bCh5LmRpdihiYXNlKSkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhiYXNlLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc3VtKHJlZHVjZUF4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUoYmFzZS5zaGFwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRlckV4cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkubXVsKHkubXVsKGJhc2UubG9nKCkpLnRvRmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGV4cC5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKGV4cC5zaGFwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYmFzZTogZGVyQmFzZSwgZXhwOiBkZXJFeHAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQsIHNhdmUpIHsgcmV0dXJuIHNhdmUoYmFja2VuZC5wb3coYmFzZSwgZXhwKSk7IH0sIHsgYmFzZTogYmFzZSwgZXhwOiBleHAgfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMucG93U3RyaWN0ID0gZnVuY3Rpb24gKGJhc2UsIGV4cCkge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGJhc2Uuc2hhcGUsIGV4cC5zaGFwZSwgJ0Vycm9yIGluIHBvd1N0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBiYXNlLnBvdyhleHApO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLm11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ211bCcpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkubXVsKGIudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdW0ocmVkdWNlQXhlcykucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkubXVsKGEudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYi5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdW0ocmVkdWNlQXhlcykucmVzaGFwZShiLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm11bHRpcGx5KGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5tdWxTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBtdWx0aXBseVN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm11bChiKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5kaXYgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBhOiBhLCBiOiBiIH0sICdkaXYnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICB2YXIgZm9yd2FyZEZ1bmM7XG4gICAgICAgIGlmIChhLmR0eXBlID09PSAnaW50MzInICYmIGIuZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgIHJldHVybiBCaW5hcnlPcHMuZmxvb3JEaXYoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3J3YXJkRnVuYyA9IGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnJlYWxEaXZpZGUoYSwgYik7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5kaXYoYi50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhhLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGEuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5tdWwoYS50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhiLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc3VtKHJlZHVjZUF4ZXMpLnJlc2hhcGUoYi5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBiLnNxdWFyZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGl2KHRtcC50b0Zsb2F0KCkpLm5lZygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZm9yd2FyZEZ1bmMsIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLmZsb29yRGl2ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnZmxvb3JEaXYnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICB2YXIgZm9yd2FyZEZ1bmMgPSBmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5mbG9vckRpdihhLCBiKTsgfTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5kaXYoYi50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhhLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGEuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5tdWwoYS50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhiLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc3VtKHJlZHVjZUF4ZXMpLnJlc2hhcGUoYi5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBiLnNxdWFyZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGl2KHRtcC50b0Zsb2F0KCkpLm5lZygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZm9yd2FyZEZ1bmMsIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLmRpdlN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGRpdmlkZVN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmRpdihiKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5tb2QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBhOiBhLCBiOiBiIH0sICdtb2QnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIGRlckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGEuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeS5zdW0ocmVkdWNlQXhlcykucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5tdWwoYS5kaXYoYikuZmxvb3IoKS5uZWcoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGIuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuc3VtKHJlZHVjZUF4ZXMpLnJlc2hhcGUoYi5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogZGVyQSwgYjogZGVyQiB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tb2QoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLm1vZFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIG1vZFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm1vZChiKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5taW5pbXVtID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnbWluaW11bScpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGlmIChhLmR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIGEgPSBhLnRvSW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIuZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgYiA9IGIudG9JbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIGRlckEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWwoYS5sZXNzRXF1YWwoYikudG9GbG9hdCgpKTsgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKGEuZ3JlYXRlcihiKS50b0Zsb2F0KCkpOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogZGVyQSwgYjogZGVyQiB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5taW5pbXVtKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5taW5pbXVtU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbWluaW11bVN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm1pbmltdW0oYik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMubWF4aW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ21heGltdW0nKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBpZiAoYS5kdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICBhID0gYS50b0ludCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiLmR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIGIgPSBiLnRvSW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKGEuZ3JlYXRlckVxdWFsKGIpLnRvRmxvYXQoKSk7IH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bChhLmxlc3MoYikudG9GbG9hdCgpKTsgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubWF4aW11bShhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0sIGRlcik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMubWF4aW11bVN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIG1pbmltdW1TdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5tYXhpbXVtKGIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLnNxdWFyZWREaWZmZXJlbmNlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnc3F1YXJlZERpZmZlcmVuY2UnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHR3byA9IG9wc18xLnNjYWxhcigyKTtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKGEuc3ViKGIpLm11bCh0d28pKTsgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKGIuc3ViKGEpLm11bCh0d28pKTsgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc3F1YXJlZERpZmZlcmVuY2UoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5zcXVhcmVkRGlmZmVyZW5jZShiKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5hdGFuMiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2F0YW4yJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gQmluYXJ5T3BzLmFkZChvcHNfMS5zcXVhcmUoYSksIG9wc18xLnNxdWFyZShiKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5Lm11bChiLmRpdihkKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGEuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IEJpbmFyeU9wcy5hZGQob3BzXzEuc3F1YXJlKGEpLCBvcHNfMS5zcXVhcmUoYikpO1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBvcHNfMS5uZWcoZHkubXVsKGEuZGl2KGQpKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGIuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShiLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmF0YW4yKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcImFkZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcImFkZFN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJzdWJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJzdWJTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0FyaXRobWV0aWMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwicG93XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwicG93U3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcIm11bFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcIm11bFN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJkaXZcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0FyaXRobWV0aWMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwiZmxvb3JEaXZcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJkaXZTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0FyaXRobWV0aWMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwibW9kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwibW9kU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcIm1pbmltdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtaW5pbXVtU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcIm1heGltdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtYXhpbXVtU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcInNxdWFyZWREaWZmZXJlbmNlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwic3F1YXJlZERpZmZlcmVuY2VTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJhdGFuMlwiLCBudWxsKTtcbiAgICByZXR1cm4gQmluYXJ5T3BzO1xufSgpKTtcbmV4cG9ydHMuQmluYXJ5T3BzID0gQmluYXJ5T3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5X29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpIHtcbiAgICB2YXIgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gICAgdmFyIGRpbXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgICAgIHZhciBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICAgICAgdmFyIGEgPSBpblNoYXBlW2RpbV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBvdXRTaGFwZVtvdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICAgICAgaWYgKGIgPiAxICYmIGEgPT09IDEpIHtcbiAgICAgICAgICAgIGRpbXMudW5zaGlmdChkaW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xufVxuZXhwb3J0cy5nZXRCcm9hZGNhc3REaW1zID0gZ2V0QnJvYWRjYXN0RGltcztcbmZ1bmN0aW9uIGdldFJlZHVjdGlvbkF4ZXMoaW5TaGFwZSwgb3V0U2hhcGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5EaW0gPSBpblNoYXBlW2luU2hhcGUubGVuZ3RoIC0gaSAtIDFdO1xuICAgICAgICB2YXIgb3V0QXhpcyA9IG91dFNoYXBlLmxlbmd0aCAtIGkgLSAxO1xuICAgICAgICB2YXIgb3V0RGltID0gb3V0U2hhcGVbb3V0QXhpc107XG4gICAgICAgIGlmIChpbkRpbSA9PSBudWxsIHx8IChpbkRpbSA9PT0gMSAmJiBvdXREaW0gPiAxKSkge1xuICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQob3V0QXhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0UmVkdWN0aW9uQXhlcyA9IGdldFJlZHVjdGlvbkF4ZXM7XG5mdW5jdGlvbiBicm9hZGNhc3REaW1zQXJlT3V0ZXIoZGltcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGltc1tpXSAhPT0gaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5icm9hZGNhc3REaW1zQXJlT3V0ZXIgPSBicm9hZGNhc3REaW1zQXJlT3V0ZXI7XG5mdW5jdGlvbiBhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShzaGFwZUEsIHNoYXBlQikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZXJyTXNnID0gXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiICtcbiAgICAgICAgKHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiLlwiKTtcbiAgICB2YXIgbCA9IE1hdGgubWF4KHNoYXBlQS5sZW5ndGgsIHNoYXBlQi5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gc2hhcGVBW3NoYXBlQS5sZW5ndGggLSBpIC0gMV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBzaGFwZUJbc2hhcGVCLmxlbmd0aCAtIGkgLSAxXSB8fCAxO1xuICAgICAgICBpZiAoYSA+IDEgJiYgYiA+IDEgJiYgYSAhPT0gYikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudW5zaGlmdChNYXRoLm1heChhLCBiKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlID0gYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm9hZGNhc3RfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBDb21wYXJlT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wYXJlT3BzKCkge1xuICAgIH1cbiAgICBDb21wYXJlT3BzLm5vdEVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnbm90RXF1YWwnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubm90RXF1YWwoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMubm90RXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBub3RFcXVhbFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm5vdEVxdWFsKGIpO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5sZXNzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnbGVzcycpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sZXNzKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLmxlc3NTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBsZXNzU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEubGVzcyhiKTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBhOiBhLCBiOiBiIH0sICdlcXVhbCcpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5lcXVhbChhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0pO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5lcXVhbFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGVxdWFsU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuZXF1YWwoYik7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLmxlc3NFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGE6IGEsIGI6IGIgfSwgJ2xlc3NFcXVhbCcpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sZXNzRXF1YWwoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMubGVzc0VxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbGVzc0VxdWFsU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEubGVzc0VxdWFsKGIpO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5ncmVhdGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnZ3JlYXRlcicpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5ncmVhdGVyKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLmdyZWF0ZXJTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBncmVhdGVyU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuZ3JlYXRlcihiKTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMuZ3JlYXRlckVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnZ3JlYXRlckVxdWFsJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmdyZWF0ZXJFcXVhbChhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0pO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5ncmVhdGVyRXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBncmVhdGVyRXF1YWxTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5ncmVhdGVyRXF1YWwoYik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwibm90RXF1YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwibm90RXF1YWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImxlc3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwibGVzc1N0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwiZXF1YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwiZXF1YWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImxlc3NFcXVhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29tcGFyZU9wcywgXCJsZXNzRXF1YWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImdyZWF0ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwiZ3JlYXRlclN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwiZ3JlYXRlckVxdWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImdyZWF0ZXJFcXVhbFN0cmljdFwiLCBudWxsKTtcbiAgICByZXR1cm4gQ29tcGFyZU9wcztcbn0oKSk7XG5leHBvcnRzLkNvbXBhcmVPcHMgPSBDb21wYXJlT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGFyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsXzEgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi9jb25jYXRfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBDb25jYXRPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmNhdE9wcygpIHtcbiAgICB9XG4gICAgQ29uY2F0T3BzLmNvbmNhdDFkID0gZnVuY3Rpb24gKHRlbnNvcnMpIHtcbiAgICAgICAgcmV0dXJuIENvbmNhdE9wcy5jb25jYXQodGVuc29ycywgMCk7XG4gICAgfTtcbiAgICBDb25jYXRPcHMuY29uY2F0MmQgPSBmdW5jdGlvbiAodGVuc29ycywgYXhpcykge1xuICAgICAgICByZXR1cm4gQ29uY2F0T3BzLmNvbmNhdCh0ZW5zb3JzLCBheGlzKTtcbiAgICB9O1xuICAgIENvbmNhdE9wcy5jb25jYXQzZCA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBheGlzKSB7XG4gICAgICAgIHJldHVybiBDb25jYXRPcHMuY29uY2F0KHRlbnNvcnMsIGF4aXMpO1xuICAgIH07XG4gICAgQ29uY2F0T3BzLmNvbmNhdDRkID0gZnVuY3Rpb24gKHRlbnNvcnMsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIENvbmNhdE9wcy5jb25jYXQodGVuc29ycywgYXhpcyk7XG4gICAgfTtcbiAgICBDb25jYXRPcHMuY29uY2F0ID0gZnVuY3Rpb24gKHRlbnNvcnMsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydCh0ZW5zb3JzLmxlbmd0aCA+PSAxLCAnUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIGNvbmNhdCcpO1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB0ZW5zb3JzOiB0ZW5zb3JzIH0sICdjb25jYXQnKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRlbnNvcnNbMF07XG4gICAgICAgIGlmICh0ZW5zb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbF8xLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHJlc3VsdC5zaGFwZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29uY2F0MlRlbnNvcnMocmVzdWx0LCB0ZW5zb3JzW2ldLCBheGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb25jYXRPcHMsIFwiY29uY2F0XCIsIG51bGwpO1xuICAgIHJldHVybiBDb25jYXRPcHM7XG59KCkpO1xuZXhwb3J0cy5Db25jYXRPcHMgPSBDb25jYXRPcHM7XG5mdW5jdGlvbiBjb25jYXQyVGVuc29ycyhhLCBiLCBheGlzKSB7XG4gICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgIHZhciBvdXRTaGFwZSA9IGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhLnNoYXBlLCBiLnNoYXBlLCBheGlzKTtcbiAgICB2YXIgYTJEID0gYS5hczJEKC0xLCB1dGlsLnNpemVGcm9tU2hhcGUoYS5zaGFwZS5zbGljZShheGlzKSkpO1xuICAgIHZhciBiMkQgPSBiLmFzMkQoLTEsIHV0aWwuc2l6ZUZyb21TaGFwZShiLnNoYXBlLnNsaWNlKGF4aXMpKSk7XG4gICAgdmFyIF9hID0gY29uY2F0X3V0aWwuY29tcHV0ZUdyYWRpZW50U2xpY2VTaGFwZXMoYTJELnNoYXBlLCBiMkQuc2hhcGUpLCBhQmVnaW4gPSBfYS5hQmVnaW4sIGFTaXplID0gX2EuYVNpemUsIGJCZWdpbiA9IF9hLmJCZWdpbiwgYlNpemUgPSBfYS5iU2l6ZTtcbiAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgIHJldHVybiB7IGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LnNsaWNlKGFCZWdpbiwgYVNpemUpOyB9LCBiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5zbGljZShiQmVnaW4sIGJTaXplKTsgfSB9O1xuICAgIH07XG4gICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuY29uY2F0KGEyRCwgYjJEKTsgfSwgeyBhOiBhMkQsIGI6IGIyRCB9LCBkZXIpO1xuICAgIHJldHVybiByZXMucmVzaGFwZShvdXRTaGFwZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzZXJ0UGFyYW1zKGFTaGFwZSwgYlNoYXBlLCBheGlzKSB7XG4gICAgdmFyIGFSYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICB2YXIgYlJhbmsgPSBiU2hhcGUubGVuZ3RoO1xuICAgIHV0aWwuYXNzZXJ0KGFTaGFwZS5sZW5ndGggPT09IGJTaGFwZS5sZW5ndGgsIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogcmFuayBvZiB4MSAoXCIgKyBhUmFuayArIFwiKSBhbmQgeDIgKFwiICsgYlJhbmsgKyBcIikgXCIgK1xuICAgICAgICBcIm11c3QgYmUgdGhlIHNhbWUuXCIpO1xuICAgIHV0aWwuYXNzZXJ0KGF4aXMgPj0gMCAmJiBheGlzIDwgYVJhbmssIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogYXhpcyBtdXN0IGJlIFwiICtcbiAgICAgICAgKFwiYmV0d2VlbiAwIGFuZCBcIiArIChhUmFuayAtIDEpICsgXCIuXCIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFSYW5rOyBpKyspIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoKGkgPT09IGF4aXMpIHx8IChhU2hhcGVbaV0gPT09IGJTaGFwZVtpXSksIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogU2hhcGUgKFwiICsgYVNoYXBlICsgXCIpIGRvZXMgbm90IG1hdGNoIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIGJTaGFwZSArIFwiKSBhbG9uZyB0aGUgbm9uLWNvbmNhdGVuYXRlZCBheGlzIFwiICsgaSArIFwiLlwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRQYXJhbXMgPSBhc3NlcnRQYXJhbXM7XG5mdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUxRCh4MVNoYXBlLCB4MlNoYXBlKSB7XG4gICAgdXRpbC5hc3NlcnQoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEsICd4MSBhbmQgeDIgc2hvdWxkIGJlIDFkIGFycmF5LicpO1xuICAgIHZhciBvdXRwdXRTaGFwZSA9IHgxU2hhcGUuc2xpY2UoKTtcbiAgICBvdXRwdXRTaGFwZVswXSArPSB4MlNoYXBlWzBdO1xuICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dFNoYXBlMUQgPSBjb21wdXRlT3V0U2hhcGUxRDtcbmZ1bmN0aW9uIGNvbXB1dGVPdXRTaGFwZSh4MVNoYXBlLCB4MlNoYXBlLCBheGlzKSB7XG4gICAgdXRpbC5hc3NlcnQoeDFTaGFwZS5sZW5ndGggPT09IHgyU2hhcGUubGVuZ3RoLCAneDEgYW5kIHgyIHNob3VsZCBoYXZlIHRoZSBzYW1lIHJhbmsuJyk7XG4gICAgdmFyIG91dHB1dFNoYXBlID0geDFTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IHgyU2hhcGVbYXhpc107XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0U2hhcGUgPSBjb21wdXRlT3V0U2hhcGU7XG5mdW5jdGlvbiBjb21wdXRlR3JhZGllbnRTbGljZVNoYXBlcyhhU2hhcGUsIGJTaGFwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFCZWdpbjogWzAsIDBdLFxuICAgICAgICBhU2l6ZTogYVNoYXBlLFxuICAgICAgICBiQmVnaW46IFswLCBhU2hhcGVbMV1dLFxuICAgICAgICBiU2l6ZTogYlNoYXBlXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcHV0ZUdyYWRpZW50U2xpY2VTaGFwZXMgPSBjb21wdXRlR3JhZGllbnRTbGljZVNoYXBlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi9jb252X3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgQ29udk9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udk9wcygpIHtcbiAgICB9XG4gICAgQ29udk9wcy5jb252MWQgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBzdHJpZGUsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb24sIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnTldDJzsgfVxuICAgICAgICBpZiAoZGlsYXRpb24gPT09IHZvaWQgMCkgeyBkaWxhdGlvbiA9IDE7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCwgZmlsdGVyOiBmaWx0ZXIgfSwgJ2NvbnYxZCcpO1xuICAgICAgICB2YXIgeDNEID0geDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG8zRCA9IGZhbHNlO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAyKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvM0QgPSB0cnVlO1xuICAgICAgICAgICAgeDNEID0geC5hczNEKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgzRC5yYW5rID09PSAzLCBcIkVycm9yIGluIGNvbnYxZDogaW5wdXQgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIiArIHgzRC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gMywgXCJFcnJvciBpbiBjb252MWQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChmaWx0ZXIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGNvbnYxZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgzRC5zaGFwZVsyXSA9PT0gZmlsdGVyLnNoYXBlWzFdLCBcIkVycm9yIGluIGNvbnYxZDogZGVwdGggb2YgaW5wdXQgKFwiICsgeDNELnNoYXBlWzJdICsgXCIpIG11c3QgbWF0Y2ggXCIgK1xuICAgICAgICAgICAgKFwiaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVsxXSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGUsIGRpbGF0aW9uKSwgJ0Vycm9yIGluIGNvbnYxRDogRWl0aGVyIHN0cmlkZSBvciBkaWxhdGlvbiBtdXN0IGJlIDEuICcgK1xuICAgICAgICAgICAgKFwiR290IHN0cmlkZSBcIiArIHN0cmlkZSArIFwiIGFuZCBkaWxhdGlvbiAnXCIgKyBkaWxhdGlvbiArIFwiJ1wiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGRhdGFGb3JtYXQgPT09ICdOV0MnLCBcIkVycm9yIGluIGNvbnYxZDogZ290IGRhdGFGb3JtYXQgb2YgXCIgKyBkYXRhRm9ybWF0ICsgXCIgYnV0IG9ubHkgTldDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB2YXIgZmlsdGVyNEQgPSBmaWx0ZXIuYXM0RCgxLCBmaWx0ZXIuc2hhcGVbMF0sIGZpbHRlci5zaGFwZVsxXSwgZmlsdGVyLnNoYXBlWzJdKTtcbiAgICAgICAgdmFyIGlucHV0NEQgPSB4M0QuYXM0RCh4M0Quc2hhcGVbMF0sIDEsIHgzRC5zaGFwZVsxXSwgeDNELnNoYXBlWzJdKTtcbiAgICAgICAgdmFyIHN0cmlkZXMgPSBbMSwgc3RyaWRlXTtcbiAgICAgICAgdmFyIGRpbGF0aW9ucyA9IFsxLCBkaWxhdGlvbl07XG4gICAgICAgIHZhciBjb252MmREYXRhRm9ybWF0ID0gJ05IV0MnO1xuICAgICAgICB2YXIgcmVzID0gQ29udk9wcy5jb252MmQoaW5wdXQ0RCwgZmlsdGVyNEQsIHN0cmlkZXMsIHBhZCwgY29udjJkRGF0YUZvcm1hdCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzNEKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzMkQocmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMF0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICB9O1xuICAgIENvbnZPcHMuY29udjJkID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgc3RyaWRlcywgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnTkhXQyc7IH1cbiAgICAgICAgaWYgKGRpbGF0aW9ucyA9PT0gdm9pZCAwKSB7IGRpbGF0aW9ucyA9IFsxLCAxXTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4LCBmaWx0ZXI6IGZpbHRlciB9LCAnY29udjJkJyk7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gY29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiICsgeDRELnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gY29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnNoYXBlWzNdID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIgKyB4NEQuc2hhcGVbM10gKyBcIikgbXVzdCBtYXRjaCBcIiArXG4gICAgICAgICAgICAoXCJpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKHN0cmlkZXMsIGRpbGF0aW9ucyksICdFcnJvciBpbiBjb252MkQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuICcgK1xuICAgICAgICAgICAgKFwiR290IHN0cmlkZXMgXCIgKyBzdHJpZGVzICsgXCIgYW5kIGRpbGF0aW9ucyAnXCIgKyBkaWxhdGlvbnMgKyBcIidcIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkYXRhRm9ybWF0ID09PSAnTkhXQycsIFwiRXJyb3IgaW4gY29udjJkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIiArIGRhdGFGb3JtYXQgKyBcIiBidXQgb25seSBOSFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeDRELnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodHVwbGVWYWx1ZXNBcmVPbmUoZGlsYXRpb25zKSwgJ0Vycm9yIGluIGdyYWRpZW50IG9mIGNvbnYyRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCcgK1xuICAgICAgICAgICAgICAgIChcInlldCBzdXBwb3J0ZWQgaW4gZ3JhZGllbnRzLiBHb3QgZGlsYXRpb25zICdcIiArIGRpbGF0aW9ucyArIFwiJ1wiKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbnZPcHMuY29udjJkRGVySW5wdXQoeDRELnNoYXBlLCBkeSwgZmlsdGVyLCBzdHJpZGVzLCBwYWQpOyB9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udk9wcy5jb252MmREZXJGaWx0ZXIoeDRELCBkeSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBwYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNvbnYyZCh4NEQsIGZpbHRlciwgY29udkluZm8pOyB9LCB7IHg6IHg0RCwgZmlsdGVyOiBmaWx0ZXIgfSwgZ3JhZCk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgQ29udk9wcy5jb252MmREZXJJbnB1dCA9IGZ1bmN0aW9uICh4U2hhcGUsIGR5LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGR5OiBkeSwgZmlsdGVyOiBmaWx0ZXIgfSwgJ2NvbnYyZERlcklucHV0Jyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHhTaGFwZS5sZW5ndGggPT09IGR5LnJhbmssIFwiTGVuZ3RoIG9mIGluU2hhcGUgXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgeFNoYXBlLmxlbmd0aCArIFwiKSBhbmQgcmFuayBvZiBkeSAoXCIgKyBkeS5yYW5rICsgXCIpIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB2YXIgeFNoYXBlNEQgPSB4U2hhcGU7XG4gICAgICAgIHZhciBkeTREID0gZHk7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGR5LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICBkeTREID0gZHkuYXM0RCgxLCBkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV0sIGR5LnNoYXBlWzJdKTtcbiAgICAgICAgICAgIHhTaGFwZTREID0gWzEsIHhTaGFwZVswXSwgeFNoYXBlWzFdLCB4U2hhcGVbMl1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbkRlcHRoID0geFNoYXBlNERbM107XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGR5NEQuc2hhcGVbM107XG4gICAgICAgIHV0aWwuYXNzZXJ0KHhTaGFwZTRELmxlbmd0aCA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogaW5TaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IGxlbmd0aCBcIiArXG4gICAgICAgICAgICAoeFNoYXBlNEQubGVuZ3RoICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHk0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgZHk0RC5yYW5rKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGZpbHRlci5yYW5rKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGluRGVwdGggPT09IGZpbHRlci5zaGFwZVsyXSwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiICsgaW5EZXB0aCArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChvdXREZXB0aCA9PT0gZmlsdGVyLnNoYXBlWzNdLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiICsgb3V0RGVwdGggKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVszXSArIFwiLlwiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpbGF0aW9ucyA9IDE7XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4U2hhcGU0RCwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuY29udjJkRGVySW5wdXQoZHk0RCwgZmlsdGVyLCBjb252SW5mbyk7IH0sIHsgZHk0RDogZHk0RCB9KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBDb252T3BzLmNvbnYyZERlckZpbHRlciA9IGZ1bmN0aW9uICh4LCBkeSwgZmlsdGVyU2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHgsIGR5OiBkeSB9LCAnY29udjJkRGVyRmlsdGVyJyk7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR5NEQgPSBkeTtcbiAgICAgICAgaWYgKGR5NEQucmFuayA9PT0gMykge1xuICAgICAgICAgICAgZHk0RCA9IGR5LmFzNEQoMSwgZHkuc2hhcGVbMF0sIGR5LnNoYXBlWzFdLCBkeS5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIiArXG4gICAgICAgICAgICAoeDRELnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHk0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKGR5NEQuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXJTaGFwZS5sZW5ndGggPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChmaWx0ZXJTaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5zaGFwZVszXSA9PT0gZmlsdGVyU2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiBpbnB1dCBcIiArIHg0RC5zaGFwZVszXSArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIGlucHV0IGRlcHRoIGluIGZpbHRlciAoXCIgKyBmaWx0ZXJTaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5NEQuc2hhcGVbM10gPT09IGZpbHRlclNoYXBlWzNdLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiICsgZHk0RC5zaGFwZVszXSArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIiArIGZpbHRlclNoYXBlWzNdICsgXCIpLlwiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWxhdGlvbnMgPSAxO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeDRELnNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNvbnYyZERlckZpbHRlcih4NEQsIGR5NEQsIGNvbnZJbmZvKTsgfSwgeyB4NEQ6IHg0RCwgZHk0RDogZHk0RCB9KTtcbiAgICB9O1xuICAgIENvbnZPcHMuY29udjJkVHJhbnNwb3NlID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgb3V0cHV0U2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHgsIGZpbHRlcjogZmlsdGVyIH0sICdjb252MmRUcmFuc3Bvc2UnKTtcbiAgICAgICAgcmV0dXJuIENvbnZPcHMuY29udjJkRGVySW5wdXQob3V0cHV0U2hhcGUsIHgsIGZpbHRlciwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgQ29udk9wcy5kZXB0aHdpc2VDb252MmQgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRhdGFGb3JtYXQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0YUZvcm1hdCA9ICdOSFdDJzsgfVxuICAgICAgICBpZiAoZGlsYXRpb25zID09PSB2b2lkIDApIHsgZGlsYXRpb25zID0gWzEsIDFdOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHgsIGZpbHRlcjogZmlsdGVyIH0sICdkZXB0aHdpc2VDb252MmQnKTtcbiAgICAgICAgdmFyIHg0RCA9IHg7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB4NEQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnNoYXBlWzNdID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgeDRELnNoYXBlWzNdICsgXCIpIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIFwiKSArXG4gICAgICAgICAgICAoXCJmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICBpZiAoZGlsYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIGRpbGF0aW9ucyA9IFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoc3RyaWRlcywgZGlsYXRpb25zKSwgJ0Vycm9yIGluIGRlcHRod2lzZUNvbnYyZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gJyArXG4gICAgICAgICAgICAoXCJHb3Qgc3RyaWRlcyBcIiArIHN0cmlkZXMgKyBcIiBhbmQgZGlsYXRpb25zICdcIiArIGRpbGF0aW9ucyArIFwiJ1wiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4NEQuc2hhcGUsIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0dXBsZVZhbHVlc0FyZU9uZShkaWxhdGlvbnMpLCAnRXJyb3IgaW4gZ3JhZGllbnQgb2YgZGVwdGh3aXNlQ29udjJkOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgKFwiMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQuIEdvdCBkaWxhdGlvbnMgJ1wiICsgZGlsYXRpb25zICsgXCInXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVwdGh3aXNlQ29udjJkRGVySW5wdXQoeDRELnNoYXBlLCBkeSwgZmlsdGVyLCBjb252SW5mbyk7IH0sXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZXB0aHdpc2VDb252MmREZXJGaWx0ZXIoeDRELCBkeSwgZmlsdGVyLnNoYXBlLCBjb252SW5mbyk7IH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5kZXB0aHdpc2VDb252MkQoeDRELCBmaWx0ZXIsIGNvbnZJbmZvKTsgfSwgeyB4OiB4NEQsIGZpbHRlcjogZmlsdGVyIH0sIGdyYWQpO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIENvbnZPcHMuc2VwYXJhYmxlQ29udjJkID0gZnVuY3Rpb24gKHgsIGRlcHRod2lzZUZpbHRlciwgcG9pbnR3aXNlRmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRpbGF0aW9uLCBkYXRhRm9ybWF0KSB7XG4gICAgICAgIGlmIChkaWxhdGlvbiA9PT0gdm9pZCAwKSB7IGRpbGF0aW9uID0gWzEsIDFdOyB9XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0YUZvcm1hdCA9ICdOSFdDJzsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4LCBkZXB0aHdpc2VGaWx0ZXI6IGRlcHRod2lzZUZpbHRlciwgcG9pbnR3aXNlRmlsdGVyOiBwb2ludHdpc2VGaWx0ZXIgfSwgJ3NlcGFyYWJsZUNvbnYyZCcpO1xuICAgICAgICB2YXIgeDREID0geDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSAnTkNIVycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VwYXJhYmxlQ29udjJkIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQgTkNIVzsgb25seSAnICtcbiAgICAgICAgICAgICAgICAnTkhXQyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB4NEQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGRlcHRod2lzZUZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogZGVwdGh3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgZGVwdGh3aXNlRmlsdGVyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChwb2ludHdpc2VGaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGRlcHRod2lzZUZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQocG9pbnR3aXNlRmlsdGVyLnNoYXBlWzBdID09PSAxLCBcIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIFwiICtcbiAgICAgICAgICAgIChcIiBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIgKyBwb2ludHdpc2VGaWx0ZXIuc2hhcGVbMF0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChwb2ludHdpc2VGaWx0ZXIuc2hhcGVbMV0gPT09IDEsIFwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgc2Vjb25kIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIFwiICtcbiAgICAgICAgICAgIChcIiBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIgKyBwb2ludHdpc2VGaWx0ZXIuc2hhcGVbMV0gKyBcIi5cIikpO1xuICAgICAgICB2YXIgaW5DaGFubmVscyA9IGRlcHRod2lzZUZpbHRlci5zaGFwZVsyXTtcbiAgICAgICAgdmFyIGNoYW5uZWxNdWx0aXBsaWVyID0gZGVwdGh3aXNlRmlsdGVyLnNoYXBlWzNdO1xuICAgICAgICB1dGlsLmFzc2VydChwb2ludHdpc2VGaWx0ZXIuc2hhcGVbMl0gPT09IGluQ2hhbm5lbHMgKiBjaGFubmVsTXVsdGlwbGllciwgXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSB0aGlyZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IGJlIFwiICsgaW5DaGFubmVscyAqIGNoYW5uZWxNdWx0aXBsaWVyICsgXCIsIFwiKSArXG4gICAgICAgICAgICAoXCJidXQgZ290IFwiICsgcG9pbnR3aXNlRmlsdGVyLnNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGRlcHRod2lzZSA9IENvbnZPcHMuZGVwdGh3aXNlQ29udjJkKHg0RCwgZGVwdGh3aXNlRmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRhdGFGb3JtYXQsIGRpbGF0aW9uKTtcbiAgICAgICAgdmFyIHBvaW50d2lzZVN0cmlkZSA9IDE7XG4gICAgICAgIHZhciByZXMgPSBDb252T3BzLmNvbnYyZChkZXB0aHdpc2UsIHBvaW50d2lzZUZpbHRlciwgcG9pbnR3aXNlU3RyaWRlLCAndmFsaWQnLCBkYXRhRm9ybWF0KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQ29udm9sdXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb252T3BzLCBcImNvbnYxZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQ29udm9sdXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb252T3BzLCBcImNvbnYyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJjb252MmREZXJJbnB1dFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJjb252MmREZXJGaWx0ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJjb252MmRUcmFuc3Bvc2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJkZXB0aHdpc2VDb252MmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJzZXBhcmFibGVDb252MmRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIENvbnZPcHM7XG59KCkpO1xuZXhwb3J0cy5Db252T3BzID0gQ29udk9wcztcbmZ1bmN0aW9uIHBhcnNlVHVwbGVQYXJhbShwYXJhbSkge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInID8gW3BhcmFtLCBwYXJhbV0gOiBwYXJhbTtcbn1cbmZ1bmN0aW9uIHR1cGxlVmFsdWVzQXJlT25lKHBhcmFtKSB7XG4gICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHBhcmFtKSwgZGltQSA9IF9hWzBdLCBkaW1CID0gX2FbMV07XG4gICAgcmV0dXJuIGRpbUEgPT09IDEgJiYgZGltQiA9PT0gMTtcbn1cbmZ1bmN0aW9uIGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGVzLCBkaWxhdGlvbnMpIHtcbiAgICByZXR1cm4gdHVwbGVWYWx1ZXNBcmVPbmUoc3RyaWRlcykgfHwgdHVwbGVWYWx1ZXNBcmVPbmUoZGlsYXRpb25zKTtcbn1cbmZ1bmN0aW9uIGRlcHRod2lzZUNvbnYyZERlcklucHV0KHhTaGFwZSwgZHksIGZpbHRlciwgY29udkluZm8pIHtcbiAgICB2YXIgZHk0RCA9IGR5O1xuICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICBpZiAoZHkucmFuayA9PT0gMykge1xuICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICBkeTREID0gZHkuYXM0RCgxLCBkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV0sIGR5LnNoYXBlWzJdKTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZGVwdGh3aXNlQ29udjJERGVySW5wdXQoZHk0RCwgZmlsdGVyLCBjb252SW5mbyk7IH0sIHsgZHk0RDogZHk0RCB9KTtcbiAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRlcHRod2lzZUNvbnYyZERlckZpbHRlcih4LCBkeSwgZmlsdGVyU2hhcGUsIGNvbnZJbmZvKSB7XG4gICAgdmFyIHg0RCA9IHg7XG4gICAgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgfVxuICAgIHZhciBkeTREID0gZHk7XG4gICAgaWYgKGR5NEQucmFuayA9PT0gMykge1xuICAgICAgICBkeTREID0gZHkuYXM0RCgxLCBkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV0sIGR5LnNoYXBlWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyKHg0RCwgZHk0RCwgY29udkluZm8pOyB9LCB7IHg0RDogeDRELCBkeTREOiBkeTREIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBjb21wdXRlUG9vbDJESW5mbyhpblNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIHJvdW5kaW5nTW9kZSwgZGF0YUZvcm1hdCkge1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0YUZvcm1hdCA9ICdjaGFubmVsc0xhc3QnOyB9XG4gICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKGZpbHRlclNpemUpLCBmaWx0ZXJIZWlnaHQgPSBfYVswXSwgZmlsdGVyV2lkdGggPSBfYVsxXTtcbiAgICB2YXIgZmlsdGVyU2hhcGU7XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIGZpbHRlclNoYXBlID0gW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIGluU2hhcGVbM10sIGluU2hhcGVbM11dO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgZmlsdGVyU2hhcGUgPSBbZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgaW5TaGFwZVsxXSwgaW5TaGFwZVsxXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIgKyBkYXRhRm9ybWF0KTtcbiAgICB9XG4gICAgdmFyIGRpbGF0aW9ucyA9IDE7XG4gICAgcmV0dXJuIGNvbXB1dGVDb252MkRJbmZvKGluU2hhcGUsIGZpbHRlclNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgcm91bmRpbmdNb2RlLCBmYWxzZSwgZGF0YUZvcm1hdCk7XG59XG5leHBvcnRzLmNvbXB1dGVQb29sMkRJbmZvID0gY29tcHV0ZVBvb2wyREluZm87XG5mdW5jdGlvbiBjb21wdXRlQ29udjJESW5mbyhpblNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIHJvdW5kaW5nTW9kZSwgZGVwdGh3aXNlLCBkYXRhRm9ybWF0KSB7XG4gICAgaWYgKGRlcHRod2lzZSA9PT0gdm9pZCAwKSB7IGRlcHRod2lzZSA9IGZhbHNlOyB9XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRhRm9ybWF0ID0gJ2NoYW5uZWxzTGFzdCc7IH1cbiAgICB2YXIgX2EgPSBbLTEsIC0xLCAtMSwgLTFdLCBiYXRjaFNpemUgPSBfYVswXSwgaW5IZWlnaHQgPSBfYVsxXSwgaW5XaWR0aCA9IF9hWzJdLCBpbkNoYW5uZWxzID0gX2FbM107XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIGJhdGNoU2l6ZSA9IGluU2hhcGVbMF0sIGluSGVpZ2h0ID0gaW5TaGFwZVsxXSwgaW5XaWR0aCA9IGluU2hhcGVbMl0sIGluQ2hhbm5lbHMgPSBpblNoYXBlWzNdO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgYmF0Y2hTaXplID0gaW5TaGFwZVswXSwgaW5DaGFubmVscyA9IGluU2hhcGVbMV0sIGluSGVpZ2h0ID0gaW5TaGFwZVsyXSwgaW5XaWR0aCA9IGluU2hhcGVbM107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIgKyBkYXRhRm9ybWF0KTtcbiAgICB9XG4gICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlclNoYXBlWzBdLCBmaWx0ZXJXaWR0aCA9IGZpbHRlclNoYXBlWzFdLCBmaWx0ZXJDaGFubmVscyA9IGZpbHRlclNoYXBlWzNdO1xuICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgdmFyIF9jID0gcGFyc2VUdXBsZVBhcmFtKGRpbGF0aW9ucyksIGRpbGF0aW9uSGVpZ2h0ID0gX2NbMF0sIGRpbGF0aW9uV2lkdGggPSBfY1sxXTtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJIZWlnaHQsIGRpbGF0aW9uSGVpZ2h0KTtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlcldpZHRoLCBkaWxhdGlvbldpZHRoKTtcbiAgICB2YXIgX2QgPSBnZXRQYWRBbmRPdXRJbmZvKHBhZCwgaW5IZWlnaHQsIGluV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGVmZmVjdGl2ZUZpbHRlckhlaWdodCwgZWZmZWN0aXZlRmlsdGVyV2lkdGgsIHJvdW5kaW5nTW9kZSksIHBhZEluZm8gPSBfZC5wYWRJbmZvLCBvdXRIZWlnaHQgPSBfZC5vdXRIZWlnaHQsIG91dFdpZHRoID0gX2Qub3V0V2lkdGg7XG4gICAgdmFyIG91dENoYW5uZWxzID0gZGVwdGh3aXNlID8gZmlsdGVyQ2hhbm5lbHMgKiBpbkNoYW5uZWxzIDogZmlsdGVyQ2hhbm5lbHM7XG4gICAgdmFyIG91dFNoYXBlO1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgb3V0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRDaGFubmVscywgb3V0SGVpZ2h0LCBvdXRXaWR0aF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0SGVpZ2h0LCBvdXRXaWR0aCwgb3V0Q2hhbm5lbHNdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiYXRjaFNpemU6IGJhdGNoU2l6ZSxcbiAgICAgICAgZGF0YUZvcm1hdDogZGF0YUZvcm1hdCxcbiAgICAgICAgaW5IZWlnaHQ6IGluSGVpZ2h0LFxuICAgICAgICBpbldpZHRoOiBpbldpZHRoLFxuICAgICAgICBpbkNoYW5uZWxzOiBpbkNoYW5uZWxzLFxuICAgICAgICBvdXRIZWlnaHQ6IG91dEhlaWdodCxcbiAgICAgICAgb3V0V2lkdGg6IG91dFdpZHRoLFxuICAgICAgICBvdXRDaGFubmVsczogb3V0Q2hhbm5lbHMsXG4gICAgICAgIHBhZEluZm86IHBhZEluZm8sXG4gICAgICAgIHN0cmlkZUhlaWdodDogc3RyaWRlSGVpZ2h0LFxuICAgICAgICBzdHJpZGVXaWR0aDogc3RyaWRlV2lkdGgsXG4gICAgICAgIGZpbHRlckhlaWdodDogZmlsdGVySGVpZ2h0LFxuICAgICAgICBmaWx0ZXJXaWR0aDogZmlsdGVyV2lkdGgsXG4gICAgICAgIGRpbGF0aW9uSGVpZ2h0OiBkaWxhdGlvbkhlaWdodCxcbiAgICAgICAgZGlsYXRpb25XaWR0aDogZGlsYXRpb25XaWR0aCxcbiAgICAgICAgaW5TaGFwZTogaW5TaGFwZSxcbiAgICAgICAgb3V0U2hhcGU6IG91dFNoYXBlLFxuICAgICAgICBmaWx0ZXJTaGFwZTogZmlsdGVyU2hhcGVcbiAgICB9O1xufVxuZXhwb3J0cy5jb21wdXRlQ29udjJESW5mbyA9IGNvbXB1dGVDb252MkRJbmZvO1xuZnVuY3Rpb24gY29tcHV0ZU91dHB1dFNoYXBlM0QoaW5TaGFwZSwgZmllbGRTaXplLCBvdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkLCByb3VuZGluZ01vZGUpIHtcbiAgICBpZiAoemVyb1BhZCA9PSBudWxsKSB7XG4gICAgICAgIHplcm9QYWQgPSBjb21wdXRlRGVmYXVsdFBhZChpblNoYXBlLCBmaWVsZFNpemUsIHN0cmlkZSk7XG4gICAgfVxuICAgIHZhciBpbnB1dFJvd3MgPSBpblNoYXBlWzBdO1xuICAgIHZhciBpbnB1dENvbHMgPSBpblNoYXBlWzFdO1xuICAgIHZhciBvdXRwdXRSb3dzID0gY29uZGl0aW9uYWxSb3VuZCgoaW5wdXRSb3dzIC0gZmllbGRTaXplICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlICsgMSwgcm91bmRpbmdNb2RlKTtcbiAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KG91dHB1dFJvd3MpLCBcIlRoZSBvdXRwdXQgIyBvZiByb3dzIChcIiArIG91dHB1dFJvd3MgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIFwiICtcbiAgICAgICAgXCJzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7XG4gICAgdmFyIG91dHB1dENvbHMgPSBjb25kaXRpb25hbFJvdW5kKChpbnB1dENvbHMgLSBmaWVsZFNpemUgKyAyICogemVyb1BhZCkgLyBzdHJpZGUgKyAxLCByb3VuZGluZ01vZGUpO1xuICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQob3V0cHV0Q29scyksIFwiVGhlIG91dHB1dCAjIG9mIGNvbHVtbnMgKFwiICsgb3V0cHV0Q29scyArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSBcIiArXG4gICAgICAgIFwidGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICByZXR1cm4gW291dHB1dFJvd3MsIG91dHB1dENvbHMsIG91dERlcHRoXTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEZWZhdWx0UGFkKGlucHV0U2hhcGUsIGZpZWxkU2l6ZSwgc3RyaWRlLCBkaWxhdGlvbikge1xuICAgIGlmIChkaWxhdGlvbiA9PT0gdm9pZCAwKSB7IGRpbGF0aW9uID0gMTsgfVxuICAgIHZhciBlZmZlY3RpdmVGaWVsZFNpemUgPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpZWxkU2l6ZSwgZGlsYXRpb24pO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChpbnB1dFNoYXBlWzBdICogKHN0cmlkZSAtIDEpIC0gc3RyaWRlICsgZWZmZWN0aXZlRmllbGRTaXplKSAvIDIpO1xufVxuZXhwb3J0cy5jb21wdXRlRGVmYXVsdFBhZCA9IGNvbXB1dGVEZWZhdWx0UGFkO1xuZnVuY3Rpb24gcGFyc2VUdXBsZVBhcmFtKHBhcmFtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgPyBbcGFyYW0sIHBhcmFtXSA6IHBhcmFtO1xufVxuZnVuY3Rpb24gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJTaXplLCBkaWxhdGlvbikge1xuICAgIGlmIChkaWxhdGlvbiA8PSAxKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJTaXplO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyU2l6ZSArIChmaWx0ZXJTaXplIC0gMSkgKiAoZGlsYXRpb24gLSAxKTtcbn1cbmZ1bmN0aW9uIGdldFBhZEFuZE91dEluZm8ocGFkLCBpbkhlaWdodCwgaW5XaWR0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgcm91bmRpbmdNb2RlKSB7XG4gICAgdmFyIHBhZEluZm87XG4gICAgdmFyIG91dEhlaWdodDtcbiAgICB2YXIgb3V0V2lkdGg7XG4gICAgaWYgKHR5cGVvZiBwYWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBwYWRUeXBlID0gKHBhZCA9PT0gMCkgPyAnVkFMSUQnIDogJ05VTUJFUic7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogcGFkLCBib3R0b206IHBhZCwgbGVmdDogcGFkLCByaWdodDogcGFkLCB0eXBlOiBwYWRUeXBlIH07XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTNEKFtpbkhlaWdodCwgaW5XaWR0aCwgMV0sIGZpbHRlckhlaWdodCwgMSwgc3RyaWRlSGVpZ2h0LCBwYWQsIHJvdW5kaW5nTW9kZSk7XG4gICAgICAgIG91dEhlaWdodCA9IG91dFNoYXBlWzBdO1xuICAgICAgICBvdXRXaWR0aCA9IG91dFNoYXBlWzFdO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYWQgPT09ICdzYW1lJykge1xuICAgICAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoaW5IZWlnaHQgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGguY2VpbChpbldpZHRoIC8gc3RyaWRlV2lkdGgpO1xuICAgICAgICB2YXIgcGFkQWxvbmdIZWlnaHQgPSAob3V0SGVpZ2h0IC0gMSkgKiBzdHJpZGVIZWlnaHQgKyBmaWx0ZXJIZWlnaHQgLSBpbkhlaWdodDtcbiAgICAgICAgdmFyIHBhZEFsb25nV2lkdGggPSAob3V0V2lkdGggLSAxKSAqIHN0cmlkZVdpZHRoICsgZmlsdGVyV2lkdGggLSBpbldpZHRoO1xuICAgICAgICB2YXIgdG9wXzEgPSBNYXRoLmZsb29yKHBhZEFsb25nSGVpZ2h0IC8gMik7XG4gICAgICAgIHZhciBib3R0b20gPSBwYWRBbG9uZ0hlaWdodCAtIHRvcF8xO1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGguZmxvb3IocGFkQWxvbmdXaWR0aCAvIDIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwYWRBbG9uZ1dpZHRoIC0gbGVmdDtcbiAgICAgICAgcGFkSW5mbyA9IHsgdG9wOiB0b3BfMSwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCwgdHlwZTogJ1NBTUUnIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhZCA9PT0gJ3ZhbGlkJykge1xuICAgICAgICBwYWRJbmZvID0geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIHR5cGU6ICdWQUxJRCcgfTtcbiAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5jZWlsKChpbkhlaWdodCAtIGZpbHRlckhlaWdodCArIDEpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgb3V0V2lkdGggPSBNYXRoLmNlaWwoKGluV2lkdGggLSBmaWx0ZXJXaWR0aCArIDEpIC8gc3RyaWRlV2lkdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiBcIiArIHBhZCk7XG4gICAgfVxuICAgIHJldHVybiB7IHBhZEluZm86IHBhZEluZm8sIG91dEhlaWdodDogb3V0SGVpZ2h0LCBvdXRXaWR0aDogb3V0V2lkdGggfTtcbn1cbmZ1bmN0aW9uIGNvbmRpdGlvbmFsUm91bmQodmFsdWUsIHJvdW5kaW5nTW9kZSkge1xuICAgIGlmICghcm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc3dpdGNoIChyb3VuZGluZ01vZGUpIHtcbiAgICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwodmFsdWUpO1xuICAgICAgICBjYXNlICdmbG9vcic6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJvdW5kaW5nTW9kZSBcIiArIHJvdW5kaW5nTW9kZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FUkZfUCA9IDAuMzI3NTkxMTtcbmV4cG9ydHMuRVJGX0ExID0gMC4yNTQ4Mjk1OTI7XG5leHBvcnRzLkVSRl9BMiA9IC0wLjI4NDQ5NjczNjtcbmV4cG9ydHMuRVJGX0EzID0gMS40MjE0MTM3NDE7XG5leHBvcnRzLkVSRl9BNCA9IC0xLjQ1MzE1MjAyNztcbmV4cG9ydHMuRVJGX0E1ID0gMS4wNjE0MDU0Mjk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcmZfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgSW1hZ2VPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltYWdlT3BzKCkge1xuICAgIH1cbiAgICBJbWFnZU9wcy5yZXNpemVCaWxpbmVhciA9IGZ1bmN0aW9uIChpbWFnZXMsIHNpemUsIGFsaWduQ29ybmVycykge1xuICAgICAgICBpZiAoYWxpZ25Db3JuZXJzID09PSB2b2lkIDApIHsgYWxpZ25Db3JuZXJzID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgaW1hZ2VzOiBpbWFnZXMgfSwgJ3Jlc2l6ZUJpbGluZWFyJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGltYWdlcy5yYW5rID09PSAzIHx8IGltYWdlcy5yYW5rID09PSA0LCBcIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGltYWdlcy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoc2l6ZS5sZW5ndGggPT09IDIsIFwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgIChzaXplICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGJhdGNoSW1hZ2VzID0gaW1hZ2VzO1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbWFnZXMucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhdGNoSW1hZ2VzID1cbiAgICAgICAgICAgICAgICBpbWFnZXMuYXM0RCgxLCBpbWFnZXMuc2hhcGVbMF0sIGltYWdlcy5zaGFwZVsxXSwgaW1hZ2VzLnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gc2l6ZVswXSwgbmV3V2lkdGggPSBzaXplWzFdO1xuICAgICAgICB2YXIgZm9yd2FyZCA9IGZ1bmN0aW9uIChiYWNrZW5kLCBzYXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFja2VuZC5yZXNpemVCaWxpbmVhcihiYXRjaEltYWdlcywgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhY2t3YXJkID0gZnVuY3Rpb24gKGR5LCBzYXZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiYXRjaEltYWdlczogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFja2VuZC5yZXNpemVCaWxpbmVhckJhY2twcm9wKGR5LCBiYXRjaEltYWdlcywgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgICAgICAgICB9LCB7fSk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZvcndhcmQsIHsgYmF0Y2hJbWFnZXM6IGJhdGNoSW1hZ2VzIH0sIGJhY2t3YXJkKTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBJbWFnZU9wcy5yZXNpemVOZWFyZXN0TmVpZ2hib3IgPSBmdW5jdGlvbiAoaW1hZ2VzLCBzaXplLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgaWYgKGFsaWduQ29ybmVycyA9PT0gdm9pZCAwKSB7IGFsaWduQ29ybmVycyA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGltYWdlczogaW1hZ2VzIH0sICdyZXNpemVOZWFyZXN0TmVpZ2hib3InKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW1hZ2VzLnJhbmsgPT09IDMgfHwgaW1hZ2VzLnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGltYWdlcy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoc2l6ZS5sZW5ndGggPT09IDIsIFwiRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiBuZXcgc2hhcGUgbXVzdCAyRCwgYnV0IGdvdCBzaGFwZSBcIiArXG4gICAgICAgICAgICAoc2l6ZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGltYWdlcy5kdHlwZSA9PT0gJ2Zsb2F0MzInIHx8IGltYWdlcy5kdHlwZSA9PT0gJ2ludDMyJywgJ2BpbWFnZXNgIG11c3QgaGF2ZSBgaW50MzJgIG9yIGBmbG9hdDMyYCBhcyBkdHlwZScpO1xuICAgICAgICB2YXIgYmF0Y2hJbWFnZXMgPSBpbWFnZXM7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGltYWdlcy5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgYmF0Y2hJbWFnZXMgPVxuICAgICAgICAgICAgICAgIGltYWdlcy5hczREKDEsIGltYWdlcy5zaGFwZVswXSwgaW1hZ2VzLnNoYXBlWzFdLCBpbWFnZXMuc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBzaXplWzBdLCBuZXdXaWR0aCA9IHNpemVbMV07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihiYXRjaEltYWdlcywgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKTsgfSwgeyBiYXRjaEltYWdlczogYmF0Y2hJbWFnZXMgfSk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0ltYWdlcycsIG5hbWVzcGFjZTogJ2ltYWdlJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgSW1hZ2VPcHMsIFwicmVzaXplQmlsaW5lYXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0ltYWdlcycsIG5hbWVzcGFjZTogJ2ltYWdlJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgSW1hZ2VPcHMsIFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIsIG51bGwpO1xuICAgIHJldHVybiBJbWFnZU9wcztcbn0oKSk7XG5leHBvcnRzLkltYWdlT3BzID0gSW1hZ2VPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZV9vcHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIHRyYWNraW5nXzEgPSByZXF1aXJlKFwiLi4vdHJhY2tpbmdcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi9vcHNcIik7XG52YXIgTGluYWxnT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5hbGdPcHMoKSB7XG4gICAgfVxuICAgIExpbmFsZ09wcy5ncmFtU2NobWlkdCA9IGZ1bmN0aW9uICh4cykge1xuICAgICAgICB2YXIgaW5wdXRJc1RlbnNvcjJEO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICAgICAgICAgIGlucHV0SXNUZW5zb3IyRCA9IGZhbHNlO1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydCh4cyAhPSBudWxsICYmIHhzLmxlbmd0aCA+IDAsICdHcmFtLVNjaG1pZHQgcHJvY2VzczogaW5wdXQgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eScpO1xuICAgICAgICAgICAgdmFyIGRpbSA9IHhzWzBdLnNoYXBlWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB4cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoeHNbaV0uc2hhcGVbMF0gPT09IGRpbSwgJ0dyYW0tU2NobWlkdDogTm9uLXVuaXF1ZSBsZW5ndGhzIGZvdW5kIGluIHRoZSBpbnB1dCB2ZWN0b3JzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgKFwiKFwiICsgeHNbaV0uc2hhcGVbMF0gKyBcIiB2cy4gXCIgKyBkaW0gKyBcIilcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRJc1RlbnNvcjJEID0gdHJ1ZTtcbiAgICAgICAgICAgIHhzID0gb3BzXzEuc3BsaXQoeHMsIHhzLnNoYXBlWzBdLCAwKS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIG9wc18xLnNxdWVlemUoeCwgWzBdKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbF8xLmFzc2VydCh4cy5sZW5ndGggPD0geHNbMF0uc2hhcGVbMF0sIFwiR3JhbS1TY2htaWR0OiBOdW1iZXIgb2YgdmVjdG9ycyAoXCIgKyB4cy5sZW5ndGggKyBcIikgZXhjZWVkcyBcIiArXG4gICAgICAgICAgICAoXCJudW1iZXIgb2YgZGltZW5zaW9ucyAoXCIgKyB4c1swXS5zaGFwZVswXSArIFwiKS5cIikpO1xuICAgICAgICB2YXIgeXMgPSBbXTtcbiAgICAgICAgdmFyIHhzMWQgPSB4cztcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgeXMucHVzaCh0cmFja2luZ18xLlRyYWNraW5nLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0geHMxZFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9qID0gb3BzXzEuc3VtKHlzW2pdLm11bFN0cmljdCh4KSkubXVsKHlzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4LnN1Yihwcm9qKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geC5kaXYob3BzXzEubm9ybSh4LCAnZXVjbGlkZWFuJykpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dElzVGVuc29yMkQpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHNfMS5zdGFjayh5cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMaW5lYXIgQWxnZWJyYScgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExpbmFsZ09wcywgXCJncmFtU2NobWlkdFwiLCBudWxsKTtcbiAgICByZXR1cm4gTGluYWxnT3BzO1xufSgpKTtcbmV4cG9ydHMuTGluYWxnT3BzID0gTGluYWxnT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluYWxnX29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBMb2dpY2FsT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dpY2FsT3BzKCkge1xuICAgIH1cbiAgICBMb2dpY2FsT3BzLmxvZ2ljYWxOb3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdsb2dpY2FsTm90Jyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHguZHR5cGUgPT09ICdib29sJywgJ0Vycm9yIEFycmF5IG11c3QgYmUgb2YgdHlwZSBib29sLicpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sb2dpY2FsTm90KHgpOyB9LCB7IHg6IHggfSk7XG4gICAgfTtcbiAgICBMb2dpY2FsT3BzLmxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBhOiBhLCBiOiBiIH0sICdsb2dpY2FsQW5kJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEuZHR5cGUgPT09ICdib29sJyAmJiBiLmR0eXBlID09PSAnYm9vbCcsICdFcnJvciBBcnJheSBtdXN0IGJlIG9mIHR5cGUgYm9vbC4nKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmxvZ2ljYWxBbmQoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIExvZ2ljYWxPcHMubG9naWNhbE9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnbG9naWNhbE9yJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEuZHR5cGUgPT09ICdib29sJyAmJiBiLmR0eXBlID09PSAnYm9vbCcsICdFcnJvciBBcnJheSBtdXN0IGJlIG9mIHR5cGUgYm9vbC4nKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmxvZ2ljYWxPcihhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0pO1xuICAgIH07XG4gICAgTG9naWNhbE9wcy5sb2dpY2FsWG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnbG9naWNhbFhvcicpO1xuICAgICAgICB1dGlsLmFzc2VydChhLmR0eXBlID09PSAnYm9vbCcgJiYgYi5kdHlwZSA9PT0gJ2Jvb2wnLCAnRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuJyk7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gTG9naWNhbE9wcy5sb2dpY2FsT3IoYSwgYikubG9naWNhbEFuZChMb2dpY2FsT3BzLmxvZ2ljYWxBbmQoYSwgYikubG9naWNhbE5vdCgpKTtcbiAgICB9O1xuICAgIExvZ2ljYWxPcHMud2hlcmUgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGNvbmRpdGlvbjogY29uZGl0aW9uLCBhOiBhLCBiOiBiIH0sICd3aGVyZScpO1xuICAgICAgICB1dGlsLmFzc2VydChjb25kaXRpb24uZHR5cGUgPT09ICdib29sJywgJ0Vycm9yIENvbmRpdGlvbiBtdXN0IGJlIG9mIHR5cGUgYm9vbC4nKTtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gd2hlcmU6ICcpO1xuICAgICAgICBpZiAoY29uZGl0aW9uLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGNvbmRpdGlvbi5zaGFwZVswXSA9PT0gYS5zaGFwZVswXSwgJ1RoZSBmaXJzdCBkaW1lbnNpb24gb2YgYGFgIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgYGNvbmRpdGlvbmAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGNvbmRpdGlvbi5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHdoZXJlOiAnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHR5cGUgPSB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC53aGVyZShjb25kaXRpb24sIGEsIGIsIGR0eXBlKTsgfSwgeyBjb25kaXRpb246IGNvbmRpdGlvbiwgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9naWNhbE9wcywgXCJsb2dpY2FsTm90XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9naWNhbE9wcywgXCJsb2dpY2FsQW5kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9naWNhbE9wcywgXCJsb2dpY2FsT3JcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMb2dpY2FsT3BzLCBcImxvZ2ljYWxYb3JcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMb2dpY2FsT3BzLCBcIndoZXJlXCIsIG51bGwpO1xuICAgIHJldHVybiBMb2dpY2FsT3BzO1xufSgpKTtcbmV4cG9ydHMuTG9naWNhbE9wcyA9IExvZ2ljYWxPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dpY2FsX29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKFJlZHVjdGlvbikge1xuICAgIFJlZHVjdGlvbltSZWR1Y3Rpb25bXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBSZWR1Y3Rpb25bUmVkdWN0aW9uW1wiTUVBTlwiXSA9IDFdID0gXCJNRUFOXCI7XG4gICAgUmVkdWN0aW9uW1JlZHVjdGlvbltcIlNVTVwiXSA9IDJdID0gXCJTVU1cIjtcbiAgICBSZWR1Y3Rpb25bUmVkdWN0aW9uW1wiU1VNX0JZX05PTlpFUk9fV0VJR0hUU1wiXSA9IDNdID0gXCJTVU1fQllfTk9OWkVST19XRUlHSFRTXCI7XG59KShSZWR1Y3Rpb24gPSBleHBvcnRzLlJlZHVjdGlvbiB8fCAoZXhwb3J0cy5SZWR1Y3Rpb24gPSB7fSkpO1xudmFyIExvc3NPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvc3NPcHMoKSB7XG4gICAgfVxuICAgIExvc3NPcHMuY29tcHV0ZVdlaWdodGVkTG9zcyA9IGZ1bmN0aW9uIChsb3NzZXMsIHdlaWdodHMsIHJlZHVjdGlvbikge1xuICAgICAgICBpZiAocmVkdWN0aW9uID09PSB2b2lkIDApIHsgcmVkdWN0aW9uID0gUmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFM7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgbG9zc2VzOiBsb3NzZXMgfSwgJ2NvbXB1dGVXZWlnaHRlZExvc3MnKTtcbiAgICAgICAgaWYgKHdlaWdodHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgd2VpZ2h0czogd2VpZ2h0cyB9LCAnY29tcHV0ZVdlaWdodGVkTG9zcycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWlnaHRlZExvc3MgPSAod2VpZ2h0cyA9PSBudWxsKSA/IGxvc3NlcyA6IGxvc3Nlcy5tdWwod2VpZ2h0cyk7XG4gICAgICAgIGlmIChyZWR1Y3Rpb24gPT09IFJlZHVjdGlvbi5OT05FKSB7XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRMb3NzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWR1Y3Rpb24gPT09IFJlZHVjdGlvbi5TVU0pIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWlnaHRlZExvc3Muc3VtKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZHVjdGlvbiA9PT0gUmVkdWN0aW9uLk1FQU4pIHtcbiAgICAgICAgICAgIHJldHVybiAod2VpZ2h0cyA9PSBudWxsKSA/IHdlaWdodGVkTG9zcy5tZWFuKCkgOlxuICAgICAgICAgICAgICAgIHdlaWdodGVkTG9zcy5zdW0oKS5kaXYod2VpZ2h0cy5zdW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZHVjdGlvbiA9PT0gUmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpIHtcbiAgICAgICAgICAgIGlmICh3ZWlnaHRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRMb3NzLnN1bSgpLmRpdihvcHMuc2NhbGFyKGxvc3Nlcy5zaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtTm9uWmVyb3MgPSB3ZWlnaHRzLm5vdEVxdWFsKG9wcy5zY2FsYXIoMCkpLnN1bSgpLnRvRmxvYXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRMb3NzLnN1bSgpLmRpdihudW1Ob25aZXJvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHJlZHVjdGlvbjogXCIgKyByZWR1Y3Rpb24pO1xuICAgIH07XG4gICAgTG9zc09wcy5hYnNvbHV0ZURpZmZlcmVuY2UgPSBmdW5jdGlvbiAobGFiZWxzLCBwcmVkaWN0aW9ucywgd2VpZ2h0cywgcmVkdWN0aW9uKSB7XG4gICAgICAgIGlmIChyZWR1Y3Rpb24gPT09IHZvaWQgMCkgeyByZWR1Y3Rpb24gPSBSZWR1Y3Rpb24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUzsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBsYWJlbHM6IGxhYmVscywgcHJlZGljdGlvbnM6IHByZWRpY3Rpb25zIH0sICdhYnNvbHV0ZURpZmZlcmVuY2UnKTtcbiAgICAgICAgaWYgKHdlaWdodHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgd2VpZ2h0czogd2VpZ2h0cyB9LCAnYWJzb2x1dGVEaWZmZXJlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChsYWJlbHMuc2hhcGUsIHByZWRpY3Rpb25zLnNoYXBlLCAnRXJyb3IgaW4gYWJzb2x1dGVEaWZmZXJlbmNlOiAnKTtcbiAgICAgICAgdmFyIGxvc3NlcyA9IGxhYmVscy5zdWIocHJlZGljdGlvbnMpLmFicygpO1xuICAgICAgICByZXR1cm4gTG9zc09wcy5jb21wdXRlV2VpZ2h0ZWRMb3NzKGxvc3Nlcywgd2VpZ2h0cywgcmVkdWN0aW9uKTtcbiAgICB9O1xuICAgIExvc3NPcHMubWVhblNxdWFyZWRFcnJvciA9IGZ1bmN0aW9uIChsYWJlbHMsIHByZWRpY3Rpb25zLCB3ZWlnaHRzLCByZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKHJlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IHJlZHVjdGlvbiA9IFJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxhYmVsczogbGFiZWxzLCBwcmVkaWN0aW9uczogcHJlZGljdGlvbnMgfSwgJ21lYW5TcXVhcmVkRXJyb3InKTtcbiAgICAgICAgaWYgKHdlaWdodHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgd2VpZ2h0czogd2VpZ2h0cyB9LCAnbWVhblNxdWFyZWRFcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gobGFiZWxzLnNoYXBlLCBwcmVkaWN0aW9ucy5zaGFwZSwgJ0Vycm9yIGluIG1lYW5TcXVhcmVkRXJyb3I6ICcpO1xuICAgICAgICB2YXIgbG9zc2VzID0gbGFiZWxzLnNxdWFyZWREaWZmZXJlbmNlKHByZWRpY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIExvc3NPcHMuY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzZXMsIHdlaWdodHMsIHJlZHVjdGlvbik7XG4gICAgfTtcbiAgICBMb3NzT3BzLmNvc2luZURpc3RhbmNlID0gZnVuY3Rpb24gKGxhYmVscywgcHJlZGljdGlvbnMsIGF4aXMsIHdlaWdodHMsIHJlZHVjdGlvbikge1xuICAgICAgICBpZiAocmVkdWN0aW9uID09PSB2b2lkIDApIHsgcmVkdWN0aW9uID0gUmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFM7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgbGFiZWxzOiBsYWJlbHMsIHByZWRpY3Rpb25zOiBwcmVkaWN0aW9ucyB9LCAnY29zaW5lRGlzdGFuY2UnKTtcbiAgICAgICAgaWYgKHdlaWdodHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgd2VpZ2h0czogd2VpZ2h0cyB9LCAnY29zaW5lRGlzdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGxhYmVscy5zaGFwZSwgcHJlZGljdGlvbnMuc2hhcGUsICdFcnJvciBpbiBjb3NpbmVEaXN0YW5jZTogJyk7XG4gICAgICAgIHZhciBvbmUgPSBvcHMuc2NhbGFyKDEpO1xuICAgICAgICB2YXIgbG9zc2VzID0gb25lLnN1YihsYWJlbHMubXVsKHByZWRpY3Rpb25zKS5zdW0oYXhpcywgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gTG9zc09wcy5jb21wdXRlV2VpZ2h0ZWRMb3NzKGxvc3Nlcywgd2VpZ2h0cywgcmVkdWN0aW9uKTtcbiAgICB9O1xuICAgIExvc3NPcHMuaGluZ2VMb3NzID0gZnVuY3Rpb24gKGxhYmVscywgcHJlZGljdGlvbnMsIHdlaWdodHMsIHJlZHVjdGlvbikge1xuICAgICAgICBpZiAocmVkdWN0aW9uID09PSB2b2lkIDApIHsgcmVkdWN0aW9uID0gUmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFM7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgbGFiZWxzOiBsYWJlbHMsIHByZWRpY3Rpb25zOiBwcmVkaWN0aW9ucyB9LCAnaGluZ2VMb3NzJyk7XG4gICAgICAgIGlmICh3ZWlnaHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHdlaWdodHM6IHdlaWdodHMgfSwgJ2hpbmdlTG9zcycpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gobGFiZWxzLnNoYXBlLCBwcmVkaWN0aW9ucy5zaGFwZSwgJ0Vycm9yIGluIGhpbmdlTG9zczogJyk7XG4gICAgICAgIHZhciBvbmUgPSBvcHMuc2NhbGFyKDEpO1xuICAgICAgICBsYWJlbHMgPSBvcHMuc2NhbGFyKDIpLm11bChsYWJlbHMpLnN1YihvbmUpO1xuICAgICAgICB2YXIgbG9zc2VzID0gb25lLnN1YihsYWJlbHMubXVsKHByZWRpY3Rpb25zKSkucmVsdSgpO1xuICAgICAgICByZXR1cm4gTG9zc09wcy5jb21wdXRlV2VpZ2h0ZWRMb3NzKGxvc3Nlcywgd2VpZ2h0cywgcmVkdWN0aW9uKTtcbiAgICB9O1xuICAgIExvc3NPcHMubG9nTG9zcyA9IGZ1bmN0aW9uIChsYWJlbHMsIHByZWRpY3Rpb25zLCB3ZWlnaHRzLCBlcHNpbG9uLCByZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtNzsgfVxuICAgICAgICBpZiAocmVkdWN0aW9uID09PSB2b2lkIDApIHsgcmVkdWN0aW9uID0gUmVkdWN0aW9uLlNVTV9CWV9OT05aRVJPX1dFSUdIVFM7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgbGFiZWxzOiBsYWJlbHMsIHByZWRpY3Rpb25zOiBwcmVkaWN0aW9ucyB9LCAnbG9nTG9zcycpO1xuICAgICAgICBpZiAod2VpZ2h0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB3ZWlnaHRzOiB3ZWlnaHRzIH0sICdsb2dMb3NzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChsYWJlbHMuc2hhcGUsIHByZWRpY3Rpb25zLnNoYXBlLCAnRXJyb3IgaW4gbG9nTG9zczogJyk7XG4gICAgICAgIHZhciBvbmUgPSBvcHMuc2NhbGFyKDEpO1xuICAgICAgICB2YXIgZXBzaWxvblNjYWxhciA9IG9wcy5zY2FsYXIoZXBzaWxvbik7XG4gICAgICAgIHZhciBsb3NzZXMgPSBsYWJlbHMubXVsKHByZWRpY3Rpb25zLmFkZChlcHNpbG9uU2NhbGFyKS5sb2coKSlcbiAgICAgICAgICAgIC5uZWcoKVxuICAgICAgICAgICAgLnN1YihvbmUuc3ViKGxhYmVscykubXVsKG9uZS5zdWIocHJlZGljdGlvbnMpLmFkZChlcHNpbG9uU2NhbGFyKS5sb2coKSkpO1xuICAgICAgICByZXR1cm4gTG9zc09wcy5jb21wdXRlV2VpZ2h0ZWRMb3NzKGxvc3Nlcywgd2VpZ2h0cywgcmVkdWN0aW9uKTtcbiAgICB9O1xuICAgIExvc3NPcHMuaHViZXJMb3NzID0gZnVuY3Rpb24gKGxhYmVscywgcHJlZGljdGlvbnMsIHdlaWdodHMsIGRlbHRhLCByZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKGRlbHRhID09PSB2b2lkIDApIHsgZGVsdGEgPSAxLjA7IH1cbiAgICAgICAgaWYgKHJlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IHJlZHVjdGlvbiA9IFJlZHVjdGlvbi5TVU1fQllfTk9OWkVST19XRUlHSFRTOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxhYmVsczogbGFiZWxzLCBwcmVkaWN0aW9uczogcHJlZGljdGlvbnMgfSwgJ2h1YmVyTG9zcycpO1xuICAgICAgICBpZiAod2VpZ2h0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB3ZWlnaHRzOiB3ZWlnaHRzIH0sICdodWJlckxvc3MnKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGxhYmVscy5zaGFwZSwgcHJlZGljdGlvbnMuc2hhcGUsICdFcnJvciBpbiBodWJlckxvc3M6ICcpO1xuICAgICAgICB2YXIgZGVsdGFTY2FsYXIgPSBvcHMuc2NhbGFyKGRlbHRhKTtcbiAgICAgICAgdmFyIGVycm9yID0gcHJlZGljdGlvbnMuc3ViKGxhYmVscykuYWJzKCk7XG4gICAgICAgIHZhciBxdWFkcmF0aWMgPSBvcHMubWluaW11bShlcnJvciwgZGVsdGFTY2FsYXIpO1xuICAgICAgICB2YXIgbGluZWFyID0gZXJyb3Iuc3ViKHF1YWRyYXRpYyk7XG4gICAgICAgIHZhciBsb3NzZXMgPSBvcHMuc2NhbGFyKDAuNSkubXVsKHF1YWRyYXRpYy5zcXVhcmUoKSkuYWRkKGRlbHRhU2NhbGFyLm11bChsaW5lYXIpKTtcbiAgICAgICAgcmV0dXJuIExvc3NPcHMuY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzZXMsIHdlaWdodHMsIHJlZHVjdGlvbik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0xvc3NlcycsIG5hbWVzcGFjZTogJ2xvc3NlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvc3NPcHMsIFwiY29tcHV0ZVdlaWdodGVkTG9zc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0xvc3NlcycsIG5hbWVzcGFjZTogJ2xvc3NlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvc3NPcHMsIFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnTG9zc2VzJywgbmFtZXNwYWNlOiAnbG9zc2VzJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9zc09wcywgXCJtZWFuU3F1YXJlZEVycm9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnTG9zc2VzJywgbmFtZXNwYWNlOiAnbG9zc2VzJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9zc09wcywgXCJjb3NpbmVEaXN0YW5jZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0xvc3NlcycsIG5hbWVzcGFjZTogJ2xvc3NlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvc3NPcHMsIFwiaGluZ2VMb3NzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnTG9zc2VzJywgbmFtZXNwYWNlOiAnbG9zc2VzJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9zc09wcywgXCJsb2dMb3NzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnTG9zc2VzJywgbmFtZXNwYWNlOiAnbG9zc2VzJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9zc09wcywgXCJodWJlckxvc3NcIiwgbnVsbCk7XG4gICAgcmV0dXJuIExvc3NPcHM7XG59KCkpO1xuZXhwb3J0cy5Mb3NzT3BzID0gTG9zc09wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvc3Nfb3BzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBMUk5PcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExSTk9wcygpIHtcbiAgICB9XG4gICAgTFJOT3BzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uID0gZnVuY3Rpb24gKHgsIGRlcHRoUmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSkge1xuICAgICAgICBpZiAoZGVwdGhSYWRpdXMgPT09IHZvaWQgMCkgeyBkZXB0aFJhZGl1cyA9IDU7IH1cbiAgICAgICAgaWYgKGJpYXMgPT09IHZvaWQgMCkgeyBiaWFzID0gMTsgfVxuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDE7IH1cbiAgICAgICAgaWYgKGJldGEgPT09IHZvaWQgMCkgeyBiZXRhID0gMC41OyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2xvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gNCB8fCB4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IHggbXVzdCBiZSByYW5rIDMgb3IgNCBidXQgZ290XFxuICAgICAgICAgICAgICAgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChkZXB0aFJhZGl1cyksIFwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IGRlcHRoUmFkaXVzIG11c3QgYmUgYW4gaW50ZWdlclxcbiAgICAgICAgICAgICAgICAgICAgIGJ1dCBnb3QgZGVwdGhSYWRpdXMgXCIgKyBkZXB0aFJhZGl1cyArIFwiLlwiKTtcbiAgICAgICAgdmFyIHg0RCA9IHg7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREKHg0RCwgZGVwdGhSYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKTsgfSwgeyB4NEQ6IHg0RCB9KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ05vcm1hbGl6YXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMUk5PcHMsIFwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25cIiwgbnVsbCk7XG4gICAgcmV0dXJuIExSTk9wcztcbn0oKSk7XG5leHBvcnRzLkxSTk9wcyA9IExSTk9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIExTVE1PcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExTVE1PcHMoKSB7XG4gICAgfVxuICAgIExTVE1PcHMubXVsdGlSTk5DZWxsID0gZnVuY3Rpb24gKGxzdG1DZWxscywgZGF0YSwgYywgaCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBkYXRhOiBkYXRhLCBjOiBjLCBoOiBoIH0sICdtdWx0aVJOTkNlbGwnKTtcbiAgICAgICAgdmFyIGlucHV0ID0gZGF0YTtcbiAgICAgICAgdmFyIG5ld1N0YXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxzdG1DZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGxzdG1DZWxsc1tpXShpbnB1dCwgY1tpXSwgaFtpXSk7XG4gICAgICAgICAgICBuZXdTdGF0ZXMucHVzaChvdXRwdXRbMF0pO1xuICAgICAgICAgICAgbmV3U3RhdGVzLnB1c2gob3V0cHV0WzFdKTtcbiAgICAgICAgICAgIGlucHV0ID0gb3V0cHV0WzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdDID0gW107XG4gICAgICAgIHZhciBuZXdIID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBuZXdDLnB1c2gobmV3U3RhdGVzW2ldKTtcbiAgICAgICAgICAgIG5ld0gucHVzaChuZXdTdGF0ZXNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25ld0MsIG5ld0hdO1xuICAgIH07XG4gICAgTFNUTU9wcy5iYXNpY0xTVE1DZWxsID0gZnVuY3Rpb24gKGZvcmdldEJpYXMsIGxzdG1LZXJuZWwsIGxzdG1CaWFzLCBkYXRhLCBjLCBoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGZvcmdldEJpYXM6IGZvcmdldEJpYXMsIGxzdG1LZXJuZWw6IGxzdG1LZXJuZWwsIGxzdG1CaWFzOiBsc3RtQmlhcywgZGF0YTogZGF0YSwgYzogYywgaDogaCB9LCAnYmFzaWNMU1RNQ2VsbCcpO1xuICAgICAgICB2YXIgY29tYmluZWQgPSBkYXRhLmNvbmNhdChoLCAxKTtcbiAgICAgICAgdmFyIHdlaWdodGVkID0gY29tYmluZWQubWF0TXVsKGxzdG1LZXJuZWwpO1xuICAgICAgICB2YXIgcmVzID0gd2VpZ2h0ZWQuYWRkKGxzdG1CaWFzKTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHJlcy5zaGFwZVswXTtcbiAgICAgICAgdmFyIHNsaWNlQ29scyA9IHJlcy5zaGFwZVsxXSAvIDQ7XG4gICAgICAgIHZhciBzbGljZVNpemUgPSBbYmF0Y2hTaXplLCBzbGljZUNvbHNdO1xuICAgICAgICB2YXIgaSA9IHJlcy5zbGljZShbMCwgMF0sIHNsaWNlU2l6ZSk7XG4gICAgICAgIHZhciBqID0gcmVzLnNsaWNlKFswLCBzbGljZUNvbHNdLCBzbGljZVNpemUpO1xuICAgICAgICB2YXIgZiA9IHJlcy5zbGljZShbMCwgc2xpY2VDb2xzICogMl0sIHNsaWNlU2l6ZSk7XG4gICAgICAgIHZhciBvID0gcmVzLnNsaWNlKFswLCBzbGljZUNvbHMgKiAzXSwgc2xpY2VTaXplKTtcbiAgICAgICAgdmFyIG5ld0MgPSBpLnNpZ21vaWQoKS5tdWxTdHJpY3Qoai50YW5oKCkpLmFkZFN0cmljdChjLm11bFN0cmljdChmb3JnZXRCaWFzLmFkZChmKS5zaWdtb2lkKCkpKTtcbiAgICAgICAgdmFyIG5ld0ggPSBuZXdDLnRhbmgoKS5tdWxTdHJpY3Qoby5zaWdtb2lkKCkpO1xuICAgICAgICByZXR1cm4gW25ld0MsIG5ld0hdO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1JOTicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExTVE1PcHMsIFwibXVsdGlSTk5DZWxsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSTk4nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMU1RNT3BzLCBcImJhc2ljTFNUTUNlbGxcIiwgbnVsbCk7XG4gICAgcmV0dXJuIExTVE1PcHM7XG59KCkpO1xuZXhwb3J0cy5MU1RNT3BzID0gTFNUTU9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxzdG0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIE1hdG11bE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0bXVsT3BzKCkge1xuICAgIH1cbiAgICBNYXRtdWxPcHMubWF0TXVsID0gZnVuY3Rpb24gKGEsIGIsIHRyYW5zcG9zZUEsIHRyYW5zcG9zZUIpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9zZUEgPT09IHZvaWQgMCkgeyB0cmFuc3Bvc2VBID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRyYW5zcG9zZUIgPT09IHZvaWQgMCkgeyB0cmFuc3Bvc2VCID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgYTogYSwgYjogYiB9LCAnbWF0TXVsJyk7XG4gICAgICAgIHZhciBpbm5lclNoYXBlQSA9IHRyYW5zcG9zZUEgPyBhLnNoYXBlWzBdIDogYS5zaGFwZVsxXTtcbiAgICAgICAgdmFyIGlubmVyU2hhcGVCID0gdHJhbnNwb3NlQiA/IGIuc2hhcGVbMV0gOiBiLnNoYXBlWzBdO1xuICAgICAgICB1dGlsLmFzc2VydChhLnJhbmsgPT09IDIgJiYgYi5yYW5rID09PSAyLCBcIkVycm9yIGluIG1hdE11bDogaW5wdXRzIG11c3QgYmUgcmFuayAyLCBnb3QgcmFua3MgXCIgKyBhLnJhbmsgK1xuICAgICAgICAgICAgKFwiIGFuZCBcIiArIGIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlubmVyU2hhcGVBID09PSBpbm5lclNoYXBlQiwgXCJFcnJvciBpbiBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIgKyBpbm5lclNoYXBlQSArIFwiKSBhbmQgKFwiICtcbiAgICAgICAgICAgIChpbm5lclNoYXBlQiArIFwiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiICsgYS5zaGFwZSArIFwiIGFuZCBcIikgK1xuICAgICAgICAgICAgKGIuc2hhcGUgKyBcIiBhbmQgdHJhbnNwb3NlQT1cIiArIHRyYW5zcG9zZUEpICtcbiAgICAgICAgICAgIChcIiBhbmQgdHJhbnNwb3NlQj1cIiArIHRyYW5zcG9zZUIgKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zcG9zZUEgJiYgIXRyYW5zcG9zZUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tYXRNdWwoYi50b0Zsb2F0KCksIGZhbHNlLCB0cnVlKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgYjogZnVuY3Rpb24gKCkgeyByZXR1cm4gYS50b0Zsb2F0KCkubWF0TXVsKGR5LCB0cnVlLCBmYWxzZSk7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRyYW5zcG9zZUEgJiYgdHJhbnNwb3NlQikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm1hdE11bChiLnRvRmxvYXQoKSwgZmFsc2UsIGZhbHNlKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgYjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubWF0TXVsKGEudG9GbG9hdCgpLCB0cnVlLCBmYWxzZSk7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNwb3NlQSAmJiAhdHJhbnNwb3NlQikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGIudG9GbG9hdCgpLm1hdE11bChkeSwgZmFsc2UsIHRydWUpOyB9LFxuICAgICAgICAgICAgICAgICAgICBiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBhLnRvRmxvYXQoKS5tYXRNdWwoZHksIGZhbHNlLCBmYWxzZSk7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYTogZnVuY3Rpb24gKCkgeyByZXR1cm4gYi50b0Zsb2F0KCkubWF0TXVsKGR5LCB0cnVlLCB0cnVlKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgYjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubWF0TXVsKGEudG9GbG9hdCgpLCB0cnVlLCB0cnVlKTsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm1hdE11bChhLCBiLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKTsgfSwgeyBhOiBhLCBiOiBiIH0sIGdyYWQpO1xuICAgIH07XG4gICAgTWF0bXVsT3BzLnZlY3RvclRpbWVzTWF0cml4ID0gZnVuY3Rpb24gKHYsIG1hdHJpeCkge1xuICAgICAgICB1dGlsLmFzc2VydCh2LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IGZpcnN0IGlucHV0IG11c3QgYmUgcmFuayAxLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB2LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtYXRyaXgucmFuayA9PT0gMiwgXCJFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2Vjb25kIGlucHV0IG11c3QgYmUgcmFuayAyLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBtYXRyaXgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzBdLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzaXplIG9mIHZlY3RvciAoXCIgKyB2LnNpemUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBmaXJzdCBkaW1lbnNpb24gb2YgbWF0cml4IChcIiArIG1hdHJpeC5zaGFwZVswXSArIFwiKVwiKSk7XG4gICAgICAgIHJldHVybiB2LmFzMkQoMSwgLTEpLm1hdE11bChtYXRyaXgpLmFzMUQoKTtcbiAgICB9O1xuICAgIE1hdG11bE9wcy5tYXRyaXhUaW1lc1ZlY3RvciA9IGZ1bmN0aW9uIChtYXRyaXgsIHYpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5yYW5rID09PSAxLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBzZWNvbmQgaW5wdXQgbXVzdCByYW5rIDEsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIHYucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1hdHJpeC5yYW5rID09PSAyLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBmaXJzdCBpbnB1dCBtdXN0IGJlIGEgcmFuayAyLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBtYXRyaXgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzFdLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBzaXplIG9mIGZpcnN0IHJhbmsgMSBpbnB1dCBcIiArIHYuc2l6ZSArIFwiIFwiICtcbiAgICAgICAgICAgIFwibXVzdCBtYXRjaCBpbm5lciBkaW1lbnNpb24gb2Ygc2Vjb25kIHJhbmsgMiBpbnB1dCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJzaGFwZSBcIiArIG1hdHJpeC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiBtYXRyaXgubWF0TXVsKHYuYXMyRCgtMSwgMSkpLmFzMUQoKTtcbiAgICB9O1xuICAgIE1hdG11bE9wcy5kb3RQcm9kdWN0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5yYW5rID09PSAxICYmIHYyLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gZG90UHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIFwiICtcbiAgICAgICAgICAgICh2MS5yYW5rICsgXCIgYW5kIFwiICsgdjIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnNpemUgPT09IHYyLnNpemUsIFwiRXJyb3IgaW4gZG90UHJvZHVjdDogc2l6ZSBvZiBpbnB1dHMgKFwiICsgdjEuc2l6ZSArIFwiKSBhbmQgKFwiICtcbiAgICAgICAgICAgICh2Mi5zaXplICsgXCIpIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgcmV0dXJuIHYxLmFzMkQoMSwgLTEpLm1hdE11bCh2Mi5hczJEKC0xLCAxKSkuYXNTY2FsYXIoKTtcbiAgICB9O1xuICAgIE1hdG11bE9wcy5vdXRlclByb2R1Y3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnJhbmsgPT09IDEgJiYgdjIucmFuayA9PT0gMSwgXCJFcnJvciBpbiBvdXRlclByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIiArXG4gICAgICAgICAgICAodjEucmFuayArIFwiIGFuZCBcIiArIHYyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdjEuYXMyRCgtMSwgMSkubWF0TXVsKHYyLmFzMkQoMSwgLTEpKTtcbiAgICB9O1xuICAgIE1hdG11bE9wcy5kb3QgPSBmdW5jdGlvbiAodDEsIHQyKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KCh0MS5yYW5rID09PSAxIHx8IHQxLnJhbmsgPT09IDIpICYmICh0Mi5yYW5rID09PSAxIHx8IHQyLnJhbmsgPT09IDIpLCBcIkVycm9yIGluIGRvdDogaW5wdXRzIG11c3QgYWxsIGJlIHJhbmsgMSBvciAyLCBidXQgZ290IHJhbmtzIFwiICtcbiAgICAgICAgICAgICh0MS5yYW5rICsgXCIgYW5kIFwiICsgdDIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHZhciB0MUlubmVyID0gKHQxLnJhbmsgPT09IDEgPyB0MS5zaXplIDogdDEuc2hhcGVbMV0pO1xuICAgICAgICB2YXIgdDJJbm5lciA9ICh0Mi5yYW5rID09PSAxID8gdDIuc2l6ZSA6IHQyLnNoYXBlWzBdKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodDFJbm5lciA9PT0gdDJJbm5lciwgXCJFcnJvciBpbiBkb3Q6IGlubmVyIGRpbWVuc2lvbnMgb2YgaW5wdXRzIG11c3QgbWF0Y2gsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKHQxSW5uZXIgKyBcIiBhbmQgXCIgKyB0MklubmVyICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKHQxLnJhbmsgPT09IDEgJiYgdDIucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHQxLmFzMkQoMSwgLTEpLm1hdE11bCh0Mi5hczJEKC0xLCAxKSkuYXNTY2FsYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0MS5yYW5rID09PSAxICYmIHQyLnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0MS5hczJEKDEsIC0xKS5tYXRNdWwodDIuYXMyRCh0Mi5zaGFwZVswXSwgdDIuc2hhcGVbMV0pKS5hczFEKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodDEucmFuayA9PT0gMiAmJiB0Mi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdDEubWF0TXVsKHQyLmFzMkQoLTEsIDEpKS5hczFEKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdDEubWF0TXVsKHQyLmFzMkQodDIuc2hhcGVbMF0sIHQyLnNoYXBlWzFdKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdNYXRyaWNlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE1hdG11bE9wcywgXCJtYXRNdWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE1hdG11bE9wcywgXCJ2ZWN0b3JUaW1lc01hdHJpeFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTWF0bXVsT3BzLCBcIm1hdHJpeFRpbWVzVmVjdG9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBNYXRtdWxPcHMsIFwiZG90UHJvZHVjdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTWF0cmljZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBNYXRtdWxPcHMsIFwib3V0ZXJQcm9kdWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdNYXRyaWNlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE1hdG11bE9wcywgXCJkb3RcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE1hdG11bE9wcztcbn0oKSk7XG5leHBvcnRzLk1hdG11bE9wcyA9IE1hdG11bE9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdG11bC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGFycmF5X29wc18xID0gcmVxdWlyZShcIi4vYXJyYXlfb3BzXCIpO1xudmFyIGJpbmFyeV9vcHNfMSA9IHJlcXVpcmUoXCIuL2JpbmFyeV9vcHNcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgTW92aW5nQXZlcmFnZU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW92aW5nQXZlcmFnZU9wcygpIHtcbiAgICB9XG4gICAgTW92aW5nQXZlcmFnZU9wcy5tb3ZpbmdBdmVyYWdlID0gZnVuY3Rpb24gKHYsIHgsIGRlY2F5LCBzdGVwLCB6ZXJvRGViaWFzKSB7XG4gICAgICAgIGlmICh6ZXJvRGViaWFzID09PSB2b2lkIDApIHsgemVyb0RlYmlhcyA9IHRydWU7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgdjogdiwgeDogeCB9LCAnbW92aW5nQXZlcmFnZScpO1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2godiwgeCk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwodi5zaGFwZSwgeC5zaGFwZSksICdTaGFwZSBtaXNtYXRjaCBpbiB2IGFuZCB4Jyk7XG4gICAgICAgIHZhciBvbmUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5zY2FsYXIoMSk7XG4gICAgICAgIGRlY2F5ID0gdHlwZW9mIGRlY2F5ID09PSAnbnVtYmVyJyA/IGFycmF5X29wc18xLkFycmF5T3BzLnNjYWxhcihkZWNheSkgOiBkZWNheTtcbiAgICAgICAgdmFyIG9uZU1pbnVzRGVjYXkgPSBvbmUuc3ViKGRlY2F5KTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IHguc3ViKHYpLm11bChvbmVNaW51c0RlY2F5KTtcbiAgICAgICAgaWYgKHplcm9EZWJpYXMpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHN0ZXAgIT0gbnVsbCwgJ1doZW4gdXNpbmcgemVyb0RlYmlhczogdHJ1ZSwgc3RlcCBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgIHN0ZXAgPSB0eXBlb2Ygc3RlcCA9PT0gJ251bWJlcicgPyBhcnJheV9vcHNfMS5BcnJheU9wcy5zY2FsYXIoc3RlcCkgOiBzdGVwO1xuICAgICAgICAgICAgdXBkYXRlID0gdXBkYXRlLmRpdihvbmUuc3ViKGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMucG93KGRlY2F5LCBzdGVwKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2LmFkZCh1cGRhdGUpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ01vdmluZyBBdmVyYWdlJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTW92aW5nQXZlcmFnZU9wcywgXCJtb3ZpbmdBdmVyYWdlXCIsIG51bGwpO1xuICAgIHJldHVybiBNb3ZpbmdBdmVyYWdlT3BzO1xufSgpKTtcbmV4cG9ydHMuTW92aW5nQXZlcmFnZU9wcyA9IE1vdmluZ0F2ZXJhZ2VPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3ZpbmdfYXZlcmFnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbCA9IHJlcXVpcmUoXCIuL2F4aXNfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi9vcHNcIik7XG52YXIgTm9ybU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9ybU9wcygpIHtcbiAgICB9XG4gICAgTm9ybU9wcy5ub3JtID0gZnVuY3Rpb24gKHgsIG9yZCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKG9yZCA9PT0gdm9pZCAwKSB7IG9yZCA9ICdldWNsaWRlYW4nOyB9XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdub3JtJyk7XG4gICAgICAgIHZhciBub3JtID0gbm9ybUltcGwoeCwgb3JkLCBheGlzKTtcbiAgICAgICAgdmFyIGtlZXBEaW1zU2hhcGUgPSBub3JtLnNoYXBlO1xuICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICAgICAga2VlcERpbXNTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShub3JtLnNoYXBlLCBheGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybS5yZXNoYXBlKGtlZXBEaW1zU2hhcGUpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ01hdHJpY2VzJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTm9ybU9wcywgXCJub3JtXCIsIG51bGwpO1xuICAgIHJldHVybiBOb3JtT3BzO1xufSgpKTtcbmV4cG9ydHMuTm9ybU9wcyA9IE5vcm1PcHM7XG5mdW5jdGlvbiBub3JtSW1wbCh4LCBwLCBheGlzKSB7XG4gICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHguYWJzKCk7XG4gICAgfVxuICAgIGlmICh4LnJhbmsgIT09IDEgJiYgYXhpcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9ybUltcGwoeC5yZXNoYXBlKFstMV0pLCBwLCBheGlzKTtcbiAgICB9XG4gICAgaWYgKHgucmFuayA9PT0gMSB8fCB0eXBlb2YgYXhpcyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgYXhpcyBpbnN0YW5jZW9mIEFycmF5ICYmIGF4aXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChwID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5zdW0oYXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5tYXgoYXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkubWluKGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAnZXVjbGlkZWFuJyB8fCBwID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5wb3cob3BzLnNjYWxhcigyLCAnaW50MzInKSkuc3VtKGF4aXMpLnNxcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogXCIgKyBwKTtcbiAgICB9XG4gICAgaWYgKGF4aXMgaW5zdGFuY2VvZiBBcnJheSAmJiBheGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAocCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkuc3VtKGF4aXNbMF0pLm1heChheGlzWzFdIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5zdW0oYXhpc1sxXSkubWF4KGF4aXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmFicygpLnN1bShheGlzWzFdKS5taW4oYXhpc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgPT09ICdmcm8nIHx8IHAgPT09ICdldWNsaWRlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4geC5zcXVhcmUoKS5zdW0oYXhpcykuc3FydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgb3JkIHZhbHVlOiBcIiArIHApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIGF4aXM6IFwiICsgYXhpcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xuZnVuY3Rpb24gb3BlcmF0aW9uKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICAgIHZhciBmbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsc18xLnRpZHkobmFtZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4uYXBwbHkodm9pZCAwLCBhcmdzKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cbmV4cG9ydHMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlcmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFycmF5X29wc18xID0gcmVxdWlyZShcIi4vYXJyYXlfb3BzXCIpO1xudmFyIGJhdGNobm9ybV8xID0gcmVxdWlyZShcIi4vYmF0Y2hub3JtXCIpO1xudmFyIGJpbmFyeV9vcHNfMSA9IHJlcXVpcmUoXCIuL2JpbmFyeV9vcHNcIik7XG52YXIgY29tcGFyZV8xID0gcmVxdWlyZShcIi4vY29tcGFyZVwiKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoXCIuL2NvbmNhdFwiKTtcbnZhciBjb252XzEgPSByZXF1aXJlKFwiLi9jb252XCIpO1xudmFyIGltYWdlX29wc18xID0gcmVxdWlyZShcIi4vaW1hZ2Vfb3BzXCIpO1xudmFyIGxpbmFsZ19vcHNfMSA9IHJlcXVpcmUoXCIuL2xpbmFsZ19vcHNcIik7XG52YXIgbG9naWNhbF9vcHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2ljYWxfb3BzXCIpO1xudmFyIGxvc3Nfb3BzXzEgPSByZXF1aXJlKFwiLi9sb3NzX29wc1wiKTtcbnZhciBscm5fMSA9IHJlcXVpcmUoXCIuL2xyblwiKTtcbnZhciBsc3RtXzEgPSByZXF1aXJlKFwiLi9sc3RtXCIpO1xudmFyIG1hdG11bF8xID0gcmVxdWlyZShcIi4vbWF0bXVsXCIpO1xudmFyIG1vdmluZ19hdmVyYWdlXzEgPSByZXF1aXJlKFwiLi9tb3ZpbmdfYXZlcmFnZVwiKTtcbnZhciBub3JtXzEgPSByZXF1aXJlKFwiLi9ub3JtXCIpO1xudmFyIHBvb2xfMSA9IHJlcXVpcmUoXCIuL3Bvb2xcIik7XG52YXIgcmVkdWN0aW9uX29wc18xID0gcmVxdWlyZShcIi4vcmVkdWN0aW9uX29wc1wiKTtcbnZhciByZXZlcnNlXzEgPSByZXF1aXJlKFwiLi9yZXZlcnNlXCIpO1xudmFyIHNsaWNlXzEgPSByZXF1aXJlKFwiLi9zbGljZVwiKTtcbnZhciBzb2Z0bWF4XzEgPSByZXF1aXJlKFwiLi9zb2Z0bWF4XCIpO1xudmFyIHN0cmlkZWRfc2xpY2VfMSA9IHJlcXVpcmUoXCIuL3N0cmlkZWRfc2xpY2VcIik7XG52YXIgdHJhbnNwb3NlXzEgPSByZXF1aXJlKFwiLi90cmFuc3Bvc2VcIik7XG52YXIgdW5hcnlfb3BzXzEgPSByZXF1aXJlKFwiLi91bmFyeV9vcHNcIik7XG5leHBvcnRzLmJhdGNoTm9ybWFsaXphdGlvbiA9IGJhdGNobm9ybV8xLkJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb247XG5leHBvcnRzLmJhdGNoTm9ybWFsaXphdGlvbjJkID0gYmF0Y2hub3JtXzEuQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbjJkO1xuZXhwb3J0cy5iYXRjaE5vcm1hbGl6YXRpb24zZCA9IGJhdGNobm9ybV8xLkJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24zZDtcbmV4cG9ydHMuYmF0Y2hOb3JtYWxpemF0aW9uNGQgPSBiYXRjaG5vcm1fMS5CYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uNGQ7XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdF8xLkNvbmNhdE9wcy5jb25jYXQ7XG5leHBvcnRzLmNvbmNhdDFkID0gY29uY2F0XzEuQ29uY2F0T3BzLmNvbmNhdDFkO1xuZXhwb3J0cy5jb25jYXQyZCA9IGNvbmNhdF8xLkNvbmNhdE9wcy5jb25jYXQyZDtcbmV4cG9ydHMuY29uY2F0M2QgPSBjb25jYXRfMS5Db25jYXRPcHMuY29uY2F0M2Q7XG5leHBvcnRzLmNvbmNhdDRkID0gY29uY2F0XzEuQ29uY2F0T3BzLmNvbmNhdDRkO1xuZXhwb3J0cy5jb252MWQgPSBjb252XzEuQ29udk9wcy5jb252MWQ7XG5leHBvcnRzLmNvbnYyZCA9IGNvbnZfMS5Db252T3BzLmNvbnYyZDtcbmV4cG9ydHMuY29udjJkVHJhbnNwb3NlID0gY29udl8xLkNvbnZPcHMuY29udjJkVHJhbnNwb3NlO1xuZXhwb3J0cy5kZXB0aHdpc2VDb252MmQgPSBjb252XzEuQ29udk9wcy5kZXB0aHdpc2VDb252MmQ7XG5leHBvcnRzLnNlcGFyYWJsZUNvbnYyZCA9IGNvbnZfMS5Db252T3BzLnNlcGFyYWJsZUNvbnYyZDtcbmV4cG9ydHMubWF0TXVsID0gbWF0bXVsXzEuTWF0bXVsT3BzLm1hdE11bDtcbmV4cG9ydHMubWF0cml4VGltZXNWZWN0b3IgPSBtYXRtdWxfMS5NYXRtdWxPcHMubWF0cml4VGltZXNWZWN0b3I7XG5leHBvcnRzLm91dGVyUHJvZHVjdCA9IG1hdG11bF8xLk1hdG11bE9wcy5vdXRlclByb2R1Y3Q7XG5leHBvcnRzLnZlY3RvclRpbWVzTWF0cml4ID0gbWF0bXVsXzEuTWF0bXVsT3BzLnZlY3RvclRpbWVzTWF0cml4O1xuZXhwb3J0cy5kb3QgPSBtYXRtdWxfMS5NYXRtdWxPcHMuZG90O1xuZXhwb3J0cy5hdmdQb29sID0gcG9vbF8xLlBvb2xPcHMuYXZnUG9vbDtcbmV4cG9ydHMubWF4UG9vbCA9IHBvb2xfMS5Qb29sT3BzLm1heFBvb2w7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZV8xLlRyYW5zcG9zZU9wcy50cmFuc3Bvc2U7XG5leHBvcnRzLnJldmVyc2UgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlO1xuZXhwb3J0cy5yZXZlcnNlMWQgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlMWQ7XG5leHBvcnRzLnJldmVyc2UyZCA9IHJldmVyc2VfMS5SZXZlcnNlT3BzLnJldmVyc2UyZDtcbmV4cG9ydHMucmV2ZXJzZTNkID0gcmV2ZXJzZV8xLlJldmVyc2VPcHMucmV2ZXJzZTNkO1xuZXhwb3J0cy5yZXZlcnNlNGQgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlNGQ7XG5leHBvcnRzLnNsaWNlID0gc2xpY2VfMS5TbGljZU9wcy5zbGljZTtcbmV4cG9ydHMuc2xpY2UxZCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2UxZDtcbmV4cG9ydHMuc2xpY2UyZCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2UyZDtcbmV4cG9ydHMuc2xpY2UzZCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2UzZDtcbmV4cG9ydHMuc2xpY2U0ZCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2U0ZDtcbmV4cG9ydHMuc3RyaWRlZFNsaWNlID0gc3RyaWRlZF9zbGljZV8xLlN0cmlkZWRTbGljZU9wcy5zdHJpZGVkU2xpY2U7XG5leHBvcnRzLmFyZ01heCA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMuYXJnTWF4O1xuZXhwb3J0cy5hcmdNaW4gPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLmFyZ01pbjtcbmV4cG9ydHMubG9nU3VtRXhwID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5sb2dTdW1FeHA7XG5leHBvcnRzLm1heCA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMubWF4O1xuZXhwb3J0cy5tZWFuID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5tZWFuO1xuZXhwb3J0cy5taW4gPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLm1pbjtcbmV4cG9ydHMubW9tZW50cyA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMubW9tZW50cztcbmV4cG9ydHMuc3VtID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5zdW07XG5leHBvcnRzLnVuc29ydGVkU2VnbWVudFN1bSA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMudW5zb3J0ZWRTZWdtZW50U3VtO1xuZXhwb3J0cy5lcXVhbCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmVxdWFsO1xuZXhwb3J0cy5lcXVhbFN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmVxdWFsU3RyaWN0O1xuZXhwb3J0cy5ncmVhdGVyID0gY29tcGFyZV8xLkNvbXBhcmVPcHMuZ3JlYXRlcjtcbmV4cG9ydHMuZ3JlYXRlclN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmdyZWF0ZXJTdHJpY3Q7XG5leHBvcnRzLmdyZWF0ZXJFcXVhbCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmdyZWF0ZXJFcXVhbDtcbmV4cG9ydHMuZ3JlYXRlckVxdWFsU3RyaWN0ID0gY29tcGFyZV8xLkNvbXBhcmVPcHMuZ3JlYXRlckVxdWFsU3RyaWN0O1xuZXhwb3J0cy5sZXNzID0gY29tcGFyZV8xLkNvbXBhcmVPcHMubGVzcztcbmV4cG9ydHMubGVzc1N0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3NTdHJpY3Q7XG5leHBvcnRzLmxlc3NFcXVhbCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3NFcXVhbDtcbmV4cG9ydHMubGVzc0VxdWFsU3RyaWN0ID0gY29tcGFyZV8xLkNvbXBhcmVPcHMubGVzc0VxdWFsU3RyaWN0O1xuZXhwb3J0cy5ub3RFcXVhbCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLm5vdEVxdWFsO1xuZXhwb3J0cy5ub3RFcXVhbFN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLm5vdEVxdWFsU3RyaWN0O1xuZXhwb3J0cy5sb2dpY2FsTm90ID0gbG9naWNhbF9vcHNfMS5Mb2dpY2FsT3BzLmxvZ2ljYWxOb3Q7XG5leHBvcnRzLmxvZ2ljYWxBbmQgPSBsb2dpY2FsX29wc18xLkxvZ2ljYWxPcHMubG9naWNhbEFuZDtcbmV4cG9ydHMubG9naWNhbE9yID0gbG9naWNhbF9vcHNfMS5Mb2dpY2FsT3BzLmxvZ2ljYWxPcjtcbmV4cG9ydHMubG9naWNhbFhvciA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy5sb2dpY2FsWG9yO1xuZXhwb3J0cy53aGVyZSA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy53aGVyZTtcbmV4cG9ydHMuYWJzID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuYWJzO1xuZXhwb3J0cy5hY29zID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuYWNvcztcbmV4cG9ydHMuYWNvc2ggPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5hY29zaDtcbmV4cG9ydHMuYXNpbiA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmFzaW47XG5leHBvcnRzLmFzaW5oID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuYXNpbmg7XG5leHBvcnRzLmF0YW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5hdGFuO1xuZXhwb3J0cy5hdGFuaCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmF0YW5oO1xuZXhwb3J0cy5jZWlsID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuY2VpbDtcbmV4cG9ydHMuY2xpcEJ5VmFsdWUgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5jbGlwQnlWYWx1ZTtcbmV4cG9ydHMuY29zID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuY29zO1xuZXhwb3J0cy5jb3NoID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuY29zaDtcbmV4cG9ydHMuZWx1ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuZWx1O1xuZXhwb3J0cy5leHAgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5leHA7XG5leHBvcnRzLmV4cG0xID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuZXhwbTE7XG5leHBvcnRzLmZsb29yID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuZmxvb3I7XG5leHBvcnRzLnNpZ24gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zaWduO1xuZXhwb3J0cy5sZWFreVJlbHUgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5sZWFreVJlbHU7XG5leHBvcnRzLmxvZyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmxvZztcbmV4cG9ydHMubG9nMXAgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5sb2cxcDtcbmV4cG9ydHMubG9nU2lnbW9pZCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmxvZ1NpZ21vaWQ7XG5leHBvcnRzLm5lZyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLm5lZztcbmV4cG9ydHMucHJlbHUgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5wcmVsdTtcbmV4cG9ydHMucmVsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnJlbHU7XG5leHBvcnRzLnJlY2lwcm9jYWwgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5yZWNpcHJvY2FsO1xuZXhwb3J0cy5yb3VuZCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnJvdW5kO1xuZXhwb3J0cy5zZWx1ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc2VsdTtcbmV4cG9ydHMuc2lnbW9pZCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNpZ21vaWQ7XG5leHBvcnRzLnNpbiA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNpbjtcbmV4cG9ydHMuc2luaCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNpbmg7XG5leHBvcnRzLnNvZnRwbHVzID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc29mdHBsdXM7XG5leHBvcnRzLnNxcnQgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zcXJ0O1xuZXhwb3J0cy5yc3FydCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnJzcXJ0O1xuZXhwb3J0cy5zcXVhcmUgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zcXVhcmU7XG5leHBvcnRzLnN0ZXAgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zdGVwO1xuZXhwb3J0cy50YW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy50YW47XG5leHBvcnRzLnRhbmggPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy50YW5oO1xuZXhwb3J0cy5lcmYgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5lcmY7XG5leHBvcnRzLmFkZCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMuYWRkO1xuZXhwb3J0cy5hZGRTdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLmFkZFN0cmljdDtcbmV4cG9ydHMuYXRhbjIgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLmF0YW4yO1xuZXhwb3J0cy5kaXYgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLmRpdjtcbmV4cG9ydHMuZmxvb3JEaXYgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLmZsb29yRGl2O1xuZXhwb3J0cy5kaXZTdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLmRpdlN0cmljdDtcbmV4cG9ydHMubWF4aW11bSA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubWF4aW11bTtcbmV4cG9ydHMubWF4aW11bVN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubWF4aW11bVN0cmljdDtcbmV4cG9ydHMubWluaW11bSA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubWluaW11bTtcbmV4cG9ydHMubWluaW11bVN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubWluaW11bVN0cmljdDtcbmV4cG9ydHMubW9kID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5tb2Q7XG5leHBvcnRzLm1vZFN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubW9kU3RyaWN0O1xuZXhwb3J0cy5tdWwgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm11bDtcbmV4cG9ydHMubXVsU3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5tdWxTdHJpY3Q7XG5leHBvcnRzLnBvdyA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMucG93O1xuZXhwb3J0cy5wb3dTdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLnBvd1N0cmljdDtcbmV4cG9ydHMuc3ViID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5zdWI7XG5leHBvcnRzLnN1YlN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMuc3ViU3RyaWN0O1xuZXhwb3J0cy5zcXVhcmVkRGlmZmVyZW5jZSA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMuc3F1YXJlZERpZmZlcmVuY2U7XG5leHBvcnRzLnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdDtcbmV4cG9ydHMubm9ybSA9IG5vcm1fMS5Ob3JtT3BzLm5vcm07XG5leHBvcnRzLmNhc3QgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5jYXN0O1xuZXhwb3J0cy5jbG9uZSA9IGFycmF5X29wc18xLkFycmF5T3BzLmNsb25lO1xuZXhwb3J0cy5mcm9tUGl4ZWxzID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuZnJvbVBpeGVscztcbmV4cG9ydHMudG9QaXhlbHMgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50b1BpeGVscztcbmV4cG9ydHMub25lcyA9IGFycmF5X29wc18xLkFycmF5T3BzLm9uZXM7XG5leHBvcnRzLm9uZXNMaWtlID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMub25lc0xpa2U7XG5leHBvcnRzLnplcm9zID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuemVyb3M7XG5leHBvcnRzLnplcm9zTGlrZSA9IGFycmF5X29wc18xLkFycmF5T3BzLnplcm9zTGlrZTtcbmV4cG9ydHMuZXllID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuZXllO1xuZXhwb3J0cy5yYW5kID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucmFuZDtcbmV4cG9ydHMucmFuZG9tTm9ybWFsID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucmFuZG9tTm9ybWFsO1xuZXhwb3J0cy50cnVuY2F0ZWROb3JtYWwgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50cnVuY2F0ZWROb3JtYWw7XG5leHBvcnRzLnJhbmRvbVVuaWZvcm0gPSBhcnJheV9vcHNfMS5BcnJheU9wcy5yYW5kb21Vbmlmb3JtO1xuZXhwb3J0cy5tdWx0aW5vbWlhbCA9IGFycmF5X29wc18xLkFycmF5T3BzLm11bHRpbm9taWFsO1xuZXhwb3J0cy5yZXNoYXBlID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucmVzaGFwZTtcbmV4cG9ydHMuc3F1ZWV6ZSA9IGFycmF5X29wc18xLkFycmF5T3BzLnNxdWVlemU7XG5leHBvcnRzLnRpbGUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50aWxlO1xuZXhwb3J0cy5nYXRoZXIgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5nYXRoZXI7XG5leHBvcnRzLm9uZUhvdCA9IGFycmF5X29wc18xLkFycmF5T3BzLm9uZUhvdDtcbmV4cG9ydHMubGluc3BhY2UgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5saW5zcGFjZTtcbmV4cG9ydHMucmFuZ2UgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5yYW5nZTtcbmV4cG9ydHMuYnVmZmVyID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuYnVmZmVyO1xuZXhwb3J0cy5maWxsID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuZmlsbDtcbmV4cG9ydHMudGVuc29yID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudGVuc29yO1xuZXhwb3J0cy5zY2FsYXIgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5zY2FsYXI7XG5leHBvcnRzLnRlbnNvcjFkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudGVuc29yMWQ7XG5leHBvcnRzLnRlbnNvcjJkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudGVuc29yMmQ7XG5leHBvcnRzLnRlbnNvcjNkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudGVuc29yM2Q7XG5leHBvcnRzLnRlbnNvcjRkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudGVuc29yNGQ7XG5leHBvcnRzLnRlbnNvcjVkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudGVuc29yNWQ7XG5leHBvcnRzLnByaW50ID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucHJpbnQ7XG5leHBvcnRzLmV4cGFuZERpbXMgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5leHBhbmREaW1zO1xuZXhwb3J0cy5zdGFjayA9IGFycmF5X29wc18xLkFycmF5T3BzLnN0YWNrO1xuZXhwb3J0cy51bnN0YWNrID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMudW5zdGFjaztcbmV4cG9ydHMuc3BsaXQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5zcGxpdDtcbmV4cG9ydHMuY3Vtc3VtID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuY3Vtc3VtO1xuZXhwb3J0cy5wYWQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5wYWQ7XG5leHBvcnRzLnBhZDFkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucGFkMWQ7XG5leHBvcnRzLnBhZDJkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucGFkMmQ7XG5leHBvcnRzLnBhZDNkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucGFkM2Q7XG5leHBvcnRzLnBhZDRkID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucGFkNGQ7XG5leHBvcnRzLm1vdmluZ0F2ZXJhZ2UgPSBtb3ZpbmdfYXZlcmFnZV8xLk1vdmluZ0F2ZXJhZ2VPcHMubW92aW5nQXZlcmFnZTtcbmV4cG9ydHMuYmFzaWNMU1RNQ2VsbCA9IGxzdG1fMS5MU1RNT3BzLmJhc2ljTFNUTUNlbGw7XG5leHBvcnRzLm11bHRpUk5OQ2VsbCA9IGxzdG1fMS5MU1RNT3BzLm11bHRpUk5OQ2VsbDtcbmV4cG9ydHMuc29mdG1heCA9IHNvZnRtYXhfMS5Tb2Z0bWF4T3BzLnNvZnRtYXg7XG5leHBvcnRzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uID0gbHJuXzEuTFJOT3BzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uO1xuZXhwb3J0cy5saW5hbGcgPSBsaW5hbGdfb3BzXzEuTGluYWxnT3BzO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xuZXhwb3J0cy5vcGVyYXRpb24gPSBvcGVyYXRpb25fMS5vcGVyYXRpb247XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5bdGVuc29yXzEuVGVuc29yLCB0eXBlc18xLlJhbmtdO1xuW2xvc3Nfb3BzXzEuUmVkdWN0aW9uXTtcbmV4cG9ydHMubG9zc2VzID0ge1xuICAgIGFic29sdXRlRGlmZmVyZW5jZTogbG9zc19vcHNfMS5Mb3NzT3BzLmFic29sdXRlRGlmZmVyZW5jZSxcbiAgICBjb21wdXRlV2VpZ2h0ZWRMb3NzOiBsb3NzX29wc18xLkxvc3NPcHMuY29tcHV0ZVdlaWdodGVkTG9zcyxcbiAgICBjb3NpbmVEaXN0YW5jZTogbG9zc19vcHNfMS5Mb3NzT3BzLmNvc2luZURpc3RhbmNlLFxuICAgIGhpbmdlTG9zczogbG9zc19vcHNfMS5Mb3NzT3BzLmhpbmdlTG9zcyxcbiAgICBodWJlckxvc3M6IGxvc3Nfb3BzXzEuTG9zc09wcy5odWJlckxvc3MsXG4gICAgbG9nTG9zczogbG9zc19vcHNfMS5Mb3NzT3BzLmxvZ0xvc3MsXG4gICAgbWVhblNxdWFyZWRFcnJvcjogbG9zc19vcHNfMS5Mb3NzT3BzLm1lYW5TcXVhcmVkRXJyb3IsXG4gICAgc29mdG1heENyb3NzRW50cm9weTogc29mdG1heF8xLlNvZnRtYXhPcHMuc29mdG1heENyb3NzRW50cm9weVxufTtcbmV4cG9ydHMuaW1hZ2UgPSB7XG4gICAgcmVzaXplQmlsaW5lYXI6IGltYWdlX29wc18xLkltYWdlT3BzLnJlc2l6ZUJpbGluZWFyLFxuICAgIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogaW1hZ2Vfb3BzXzEuSW1hZ2VPcHMucmVzaXplTmVhcmVzdE5laWdoYm9yLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4vY29udl91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIFBvb2xPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvb2xPcHMoKSB7XG4gICAgfVxuICAgIFBvb2xPcHMubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdtYXhQb29sJyk7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gbWF4UG9vbDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICsgeDRELnJhbmsgKyBcIi5cIik7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIG1heFBvb2w6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgXCIgK1xuICAgICAgICAgICAgICAgIChcImRpbVJvdW5kaW5nTW9kZSBcIiArIGRpbVJvdW5kaW5nTW9kZSArIFwiIGJ1dCBnb3QgcGFkIFwiICsgcGFkICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZVBvb2wyREluZm8oeDRELnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5LCBzYXZlZCkge1xuICAgICAgICAgICAgdmFyIHk0RCA9IHNhdmVkWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQb29sT3BzLm1heFBvb2xCYWNrcHJvcChkeSwgeDRELCB5NEQsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kLCBzYXZlKSB7IHJldHVybiBzYXZlKGJhY2tlbmQubWF4UG9vbCh4NEQsIGNvbnZJbmZvKSk7IH0sIHsgeDogeDREIH0sIGdyYWQpO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFBvb2xPcHMubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCBpbnB1dCwgb3V0cHV0LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBkeTogZHksIGlucHV0OiBpbnB1dCwgb3V0cHV0OiBvdXRwdXQgfSwgJ21heFBvb2xCYWNrcHJvcCcpO1xuICAgICAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSBkeS5yYW5rLCBcIlJhbmsgb2YgaW5wdXQgKFwiICsgaW5wdXQucmFuayArIFwiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIiArIGR5LnJhbmsgKyBcIilcIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5LnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGR5LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSA0LCBcIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChpbnB1dC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKGlucHV0LnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm1heFBvb2xCYWNrcHJvcChkeSwgaW5wdXQsIG91dHB1dCwgY29udkluZm8pOyB9LCB7IGR5OiBkeSwgaW5wdXQ6IGlucHV0IH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUG9vbE9wcy5hdmdQb29sID0gZnVuY3Rpb24gKHgsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2F2Z1Bvb2wnKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5kdHlwZSA9PT0gJ2Zsb2F0MzInLCAnVGhlIGlucHV0IGR0eXBlIHRvIGF2Z1Bvb2wgbXVzdCBiZSBmbG9hdDMyJyk7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgKyB4NEQucmFuayArIFwiLlwiKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gYXZnUG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlUG9vbDJESW5mbyh4NEQuc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBvb2xPcHMuYXZnUG9vbEJhY2twcm9wKGR5LCB4NEQsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmF2Z1Bvb2woeDRELCBjb252SW5mbyk7IH0sIHsgeDogeDREIH0sIGdyYWQpO1xuICAgICAgICByZXMgPSByZXMuY2FzdCh4LmR0eXBlKTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBQb29sT3BzLmF2Z1Bvb2xCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgaW5wdXQsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyBkeTogZHksIGlucHV0OiBpbnB1dCB9LCAnYXZnUG9vbEJhY2twcm9wJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0LnJhbmsgPT09IGR5LnJhbmssIFwiUmFuayBvZiBpbnB1dCAoXCIgKyBpbnB1dC5yYW5rICsgXCIpIGRvZXMgbm90IG1hdGNoIHJhbmsgb2YgZHkgKFwiICsgZHkucmFuayArIFwiKVwiKTtcbiAgICAgICAgdmFyIGlucHV0NEQgPSBpbnB1dDtcbiAgICAgICAgdmFyIGR5NEQgPSBkeTtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5wdXQucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIGlucHV0NEQgPSBpbnB1dC5hczREKDEsIGlucHV0LnNoYXBlWzBdLCBpbnB1dC5zaGFwZVsxXSwgaW5wdXQuc2hhcGVbMl0pO1xuICAgICAgICAgICAgZHk0RCA9IGR5LmFzNEQoMSwgZHkuc2hhcGVbMF0sIGR5LnNoYXBlWzFdLCBkeS5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoZHk0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGF2Z1Bvb2xCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChkeTRELnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChpbnB1dDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGlucHV0NEQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlUG9vbDJESW5mbyhpbnB1dDRELnNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpO1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hdmdQb29sQmFja3Byb3AoZHk0RCwgaW5wdXQ0RCwgY29udkluZm8pOyB9LCB7IGR5NEQ6IGR5NEQsIGlucHV0NEQ6IGlucHV0NEQgfSk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUG9vbE9wcywgXCJtYXhQb29sXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBQb29sT3BzLCBcIm1heFBvb2xCYWNrcHJvcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQ29udm9sdXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBQb29sT3BzLCBcImF2Z1Bvb2xcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFBvb2xPcHMsIFwiYXZnUG9vbEJhY2twcm9wXCIsIG51bGwpO1xuICAgIHJldHVybiBQb29sT3BzO1xufSgpKTtcbmV4cG9ydHMuUG9vbE9wcyA9IFBvb2xPcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKFwic2VlZHJhbmRvbVwiKTtcbnZhciBNUFJhbmRHYXVzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTVBSYW5kR2F1c3MobWVhbiwgc3RkRGV2aWF0aW9uLCBkdHlwZSwgdHJ1bmNhdGVkLCBzZWVkKSB7XG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW47XG4gICAgICAgIHRoaXMuc3RkRGV2ID0gc3RkRGV2aWF0aW9uO1xuICAgICAgICB0aGlzLmR0eXBlID0gZHR5cGU7XG4gICAgICAgIHRoaXMubmV4dFZhbCA9IE5hTjtcbiAgICAgICAgdGhpcy50cnVuY2F0ZWQgPSB0cnVuY2F0ZWQ7XG4gICAgICAgIGlmICh0aGlzLnRydW5jYXRlZCkge1xuICAgICAgICAgICAgdGhpcy51cHBlciA9IHRoaXMubWVhbiArIHRoaXMuc3RkRGV2ICogMjtcbiAgICAgICAgICAgIHRoaXMubG93ZXIgPSB0aGlzLm1lYW4gLSB0aGlzLnN0ZERldiAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWRWYWx1ZSA9IHNlZWQgPyBzZWVkIDogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdGhpcy5yYW5kb20gPSBzZWVkcmFuZG9tLmFsZWEoc2VlZFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBNUFJhbmRHYXVzcy5wcm90b3R5cGUubmV4dFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzTmFOKHRoaXMubmV4dFZhbCkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubmV4dFZhbDtcbiAgICAgICAgICAgIHRoaXMubmV4dFZhbCA9IE5hTjtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0WCwgcmVzdWx0WTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB2YXIgdjEgPSB2b2lkIDAsIHYyID0gdm9pZCAwLCBzID0gdm9pZCAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHYxID0gMiAqIHRoaXMucmFuZG9tKCkgLSAxO1xuICAgICAgICAgICAgICAgIHYyID0gMiAqIHRoaXMucmFuZG9tKCkgLSAxO1xuICAgICAgICAgICAgICAgIHMgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSB8fCBzID09PSAwKTtcbiAgICAgICAgICAgIHZhciBtdWwgPSBNYXRoLnNxcnQoLTIuMCAqIE1hdGgubG9nKHMpIC8gcyk7XG4gICAgICAgICAgICByZXN1bHRYID0gdGhpcy5tZWFuICsgdGhpcy5zdGREZXYgKiB2MSAqIG11bDtcbiAgICAgICAgICAgIHJlc3VsdFkgPSB0aGlzLm1lYW4gKyB0aGlzLnN0ZERldiAqIHYyICogbXVsO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRydW5jYXRlZCB8fCB0aGlzLmlzVmFsaWRUcnVuY2F0ZWQocmVzdWx0WCkpIHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHJ1bmNhdGVkIHx8IHRoaXMuaXNWYWxpZFRydW5jYXRlZChyZXN1bHRZKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0VmFsID0gdGhpcy5jb252ZXJ0VmFsdWUocmVzdWx0WSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFZhbHVlKHJlc3VsdFgpO1xuICAgIH07XG4gICAgTVBSYW5kR2F1c3MucHJvdG90eXBlLmNvbnZlcnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5kdHlwZSA9PSBudWxsIHx8IHRoaXMuZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9O1xuICAgIE1QUmFuZEdhdXNzLnByb3RvdHlwZS5pc1ZhbGlkVHJ1bmNhdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnVwcGVyICYmIHZhbHVlID49IHRoaXMubG93ZXI7XG4gICAgfTtcbiAgICByZXR1cm4gTVBSYW5kR2F1c3M7XG59KCkpO1xuZXhwb3J0cy5NUFJhbmRHYXVzcyA9IE1QUmFuZEdhdXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUEFSQUxMRUxJWkVfVEhSRVNIT0xEID0gMzA7XG5mdW5jdGlvbiBjb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplKSB7XG4gICAgaWYgKGluU2l6ZSA8PSBleHBvcnRzLlBBUkFMTEVMSVpFX1RIUkVTSE9MRCkge1xuICAgICAgICByZXR1cm4gaW5TaXplO1xuICAgIH1cbiAgICByZXR1cm4gbmVhcmVzdERpdmlzb3IoaW5TaXplLCBNYXRoLmZsb29yKE1hdGguc3FydChpblNpemUpKSk7XG59XG5leHBvcnRzLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZSA9IGNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZTtcbmZ1bmN0aW9uIG5lYXJlc3REaXZpc29yKHNpemUsIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgIGlmIChzaXplICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2VfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBSZWR1Y3Rpb25PcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZHVjdGlvbk9wcygpIHtcbiAgICB9XG4gICAgUmVkdWN0aW9uT3BzLmxvZ1N1bUV4cCA9IGZ1bmN0aW9uICh4LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbG9nU3VtRXhwJyk7XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgeE1heCA9IHgubWF4KGF4ZXMsIHRydWUpO1xuICAgICAgICB2YXIgYSA9IHguc3ViKHhNYXgpO1xuICAgICAgICB2YXIgYiA9IGEuZXhwKCk7XG4gICAgICAgIHZhciBjID0gYi5zdW0oYXhlcyk7XG4gICAgICAgIHZhciBkID0gYy5sb2coKTtcbiAgICAgICAgdmFyIHJlcyA9IHhNYXgucmVzaGFwZShkLnNoYXBlKS5hZGQoZCk7XG4gICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlcy5zaGFwZSwgYXhlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSZWR1Y3Rpb25PcHMuc3VtID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdzdW0nKTtcbiAgICAgICAgaWYgKHguZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgeCA9IHgudG9JbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIGN1c3RvbU9wID0gZ2xvYmFsc18xLmN1c3RvbUdyYWQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciBwZXJtdXRhdGlvbiA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgICAgIHZhciByZWR1Y3Rpb25BeGVzID0gYXhlcztcbiAgICAgICAgICAgIHZhciBwZXJtdXRlZFggPSB4O1xuICAgICAgICAgICAgaWYgKHBlcm11dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwZXJtdXRlZFggPSB4LnRyYW5zcG9zZShwZXJtdXRhdGlvbik7XG4gICAgICAgICAgICAgICAgcmVkdWN0aW9uQXhlcyA9XG4gICAgICAgICAgICAgICAgICAgIGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKHJlZHVjdGlvbkF4ZXMubGVuZ3RoLCB4LnJhbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zdW0ocGVybXV0ZWRYLCByZWR1Y3Rpb25BeGVzKTsgfSwgeyBwZXJtdXRlZFg6IHBlcm11dGVkWCB9KTtcbiAgICAgICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbSh2YWx1ZS5zaGFwZSwgYXhlcyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncmFkRnVuYyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZER5U2hhcGUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkRHlTaGFwZVtheGlzXSA9IDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkRHkgPSBkeS5yZXNoYXBlKGV4cGFuZGVkRHlTaGFwZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlclggPSBleHBhbmRlZER5Lm11bChvcHMub25lcyh4LnNoYXBlLCAnZmxvYXQzMicpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVyWDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGdyYWRGdW5jOiBncmFkRnVuYyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1c3RvbU9wKHgpO1xuICAgIH07XG4gICAgUmVkdWN0aW9uT3BzLm1lYW4gPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ21lYW4nKTtcbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBzaGFwZXMgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKTtcbiAgICAgICAgdmFyIHJlZHVjZVNoYXBlID0gc2hhcGVzWzFdO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBjdXN0b21PcCA9IGdsb2JhbHNfMS5jdXN0b21HcmFkKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB2YXIgcmVkdWNlU2l6ZVNjYWxhciA9IG9wcy5zY2FsYXIocmVkdWNlU2l6ZSk7XG4gICAgICAgICAgICB2YXIgeFJlZHVjZSA9IHJlZHVjZVNpemVTY2FsYXIuZHR5cGUgPT09IHguZHR5cGUgP1xuICAgICAgICAgICAgICAgIHggOlxuICAgICAgICAgICAgICAgIHguY2FzdChyZWR1Y2VTaXplU2NhbGFyLmR0eXBlKTtcbiAgICAgICAgICAgIHZhciByZXMgPSB4UmVkdWNlLmRpdihyZWR1Y2VTaXplU2NhbGFyKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlcy5zdW0oYXhpcywga2VlcERpbXMpO1xuICAgICAgICAgICAgdmFyIGdyYWRGdW5jID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkRHlTaGFwZSA9IHguc2hhcGUuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBheGVzLmZvckVhY2goZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWREeVNoYXBlW2F4aXNdID0gMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5kZWREeSA9IGR5LnJlc2hhcGUoZXhwYW5kZWREeVNoYXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVyWCA9IGV4cGFuZGVkRHkubXVsKG9wcy5vbmVzKHguc2hhcGUsICdmbG9hdDMyJykpLmRpdihyZWR1Y2VTaXplU2NhbGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVyWDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGdyYWRGdW5jOiBncmFkRnVuYyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1c3RvbU9wKHgpO1xuICAgIH07XG4gICAgUmVkdWN0aW9uT3BzLm1pbiA9IGZ1bmN0aW9uICh4LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbWluJyk7XG4gICAgICAgIHZhciBvcmlnQXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIGF4ZXMgPSBvcmlnQXhlcztcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB4ID0geC50cmFuc3Bvc2UocGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5taW4oeCwgYXhlcyk7IH0sIHsgeDogeCB9KTtcbiAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSZWR1Y3Rpb25PcHMubWF4ID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdtYXgnKTtcbiAgICAgICAgdmFyIG9yaWdBeGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgICAgICB2YXIgcGVybXV0ZWRBeGVzID0gYXhpc191dGlsLmdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCB4LnJhbmspO1xuICAgICAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB4LnRyYW5zcG9zZShwZXJtdXRlZEF4ZXMpO1xuICAgICAgICAgICAgYXhlcyA9IGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCB4LnJhbmspO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm1heCh4LCBheGVzKTsgfSwgeyB4OiB4IH0pO1xuICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXMuc2hhcGUsIG9yaWdBeGVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFJlZHVjdGlvbk9wcy5hcmdNaW4gPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2FyZ01pbicpO1xuICAgICAgICBpZiAoYXhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBheGlzID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB4ID0geC50cmFuc3Bvc2UocGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hcmdNaW4oeCwgYXhlc1swXSk7IH0sIHsgeDogeCB9KTtcbiAgICB9O1xuICAgIFJlZHVjdGlvbk9wcy5hcmdNYXggPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2FyZ01heCcpO1xuICAgICAgICBpZiAoYXhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBheGlzID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB4ID0geC50cmFuc3Bvc2UocGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hcmdNYXgoeCwgYXhlc1swXSk7IH0sIHsgeDogeCB9KTtcbiAgICB9O1xuICAgIFJlZHVjdGlvbk9wcy5tb21lbnRzID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdtb21lbnRzJyk7XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgbWVhbiA9IHgubWVhbihheGVzLCBrZWVwRGltcyk7XG4gICAgICAgIHZhciBrZWVwRGltc1NoYXBlID0gbWVhbi5zaGFwZTtcbiAgICAgICAgaWYgKCFrZWVwRGltcykge1xuICAgICAgICAgICAga2VlcERpbXNTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShtZWFuLnNoYXBlLCBheGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV2U3F1YXJlZCA9IHgudG9GbG9hdCgpLnN1YihtZWFuLnJlc2hhcGUoa2VlcERpbXNTaGFwZSkpLnNxdWFyZSgpO1xuICAgICAgICB2YXIgdmFyaWFuY2UgPSBkZXZTcXVhcmVkLm1lYW4oYXhlcywga2VlcERpbXMpO1xuICAgICAgICByZXR1cm4geyBtZWFuOiBtZWFuLCB2YXJpYW5jZTogdmFyaWFuY2UgfTtcbiAgICB9O1xuICAgIFJlZHVjdGlvbk9wcy51bnNvcnRlZFNlZ21lbnRTdW0gPSBmdW5jdGlvbiAoeCwgc2VnbWVudElkcywgbnVtU2VnbWVudHMsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4LCBzZWdtZW50SWRzOiBzZWdtZW50SWRzIH0sICd1bnNvcnRlZFNlZ21lbnRTdW0nKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoc2VnbWVudElkcy5kdHlwZSA9PT0gJ2ludDMyJywgJ1NlZ21lbnQgSWRzIG11c3QgYmUgb2YgZHR5cGUgYGludDMyYCcpO1xuICAgICAgICBheGlzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpWzBdO1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBkaW0gPSBzZWdtZW50SWRzLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4LnNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gYXhpcykge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlLnB1c2goZGltKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlLnB1c2goMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc2hhcGVkU2VnbWVudElkcyA9IG9wcy5yZXNoYXBlKHNlZ21lbnRJZHMsIG5ld1NoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudElkID0gb3BzLnNjYWxhcihpLCAnaW50MzInKTtcbiAgICAgICAgICAgIHZhciBtYXNrID0gb3BzLmVxdWFsKHNlZ21lbnRJZCwgcmVzaGFwZWRTZWdtZW50SWRzKS5hc1R5cGUoJ2Zsb2F0MzInKTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBtYXNrLm11bCh4KS5zdW0oYXhpcyk7XG4gICAgICAgICAgICByZXMucHVzaChzdW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHMuc3RhY2socmVzLCBheGlzKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSZWR1Y3Rpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZWR1Y3Rpb25PcHMsIFwibG9nU3VtRXhwXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSZWR1Y3Rpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZWR1Y3Rpb25PcHMsIFwic3VtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSZWR1Y3Rpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZWR1Y3Rpb25PcHMsIFwibWVhblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcIm1pblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcIm1heFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcImFyZ01pblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcImFyZ01heFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTm9ybWFsaXphdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFJlZHVjdGlvbk9wcywgXCJtb21lbnRzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSZWR1Y3Rpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZWR1Y3Rpb25PcHMsIFwidW5zb3J0ZWRTZWdtZW50U3VtXCIsIG51bGwpO1xuICAgIHJldHVybiBSZWR1Y3Rpb25PcHM7XG59KCkpO1xuZXhwb3J0cy5SZWR1Y3Rpb25PcHMgPSBSZWR1Y3Rpb25PcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y3Rpb25fb3BzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWxfMSA9IHJlcXVpcmUoXCIuL2F4aXNfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBSZXZlcnNlT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXZlcnNlT3BzKCkge1xuICAgIH1cbiAgICBSZXZlcnNlT3BzLnJldmVyc2UxZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMSwgXCJFcnJvciBpbiByZXZlcnNlMUQ6IHggbXVzdCBiZSByYW5rIDEgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gUmV2ZXJzZU9wcy5yZXZlcnNlKHgsIDApO1xuICAgIH07XG4gICAgUmV2ZXJzZU9wcy5yZXZlcnNlMmQgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gcmV2ZXJzZTJEOiB4IG11c3QgYmUgcmFuayAyIGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIFJldmVyc2VPcHMucmV2ZXJzZSh4LCBheGlzKTtcbiAgICB9O1xuICAgIFJldmVyc2VPcHMucmV2ZXJzZTNkID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIHJldmVyc2UzRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290XFxuICAgICAgICAgICAgIHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHJldHVybiBSZXZlcnNlT3BzLnJldmVyc2UoeCwgYXhpcyk7XG4gICAgfTtcbiAgICBSZXZlcnNlT3BzLnJldmVyc2U0ZCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gNCwgXCJFcnJvciBpbiByZXZlcnNlNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gUmV2ZXJzZU9wcy5yZXZlcnNlKHgsIGF4aXMpO1xuICAgIH07XG4gICAgUmV2ZXJzZU9wcy5yZXZlcnNlID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAncmV2ZXJzZScpO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsXzEucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5yZXZlcnNlKGF4ZXMpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnJldmVyc2UoeCwgYXhlcyk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlQXMoeCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnU2xpY2luZyBhbmQgSm9pbmluZycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFJldmVyc2VPcHMsIFwicmV2ZXJzZVwiLCBudWxsKTtcbiAgICByZXR1cm4gUmV2ZXJzZU9wcztcbn0oKSk7XG5leHBvcnRzLlJldmVyc2VPcHMgPSBSZXZlcnNlT3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV2ZXJzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0VMVV9TQ0FMRUFMUEhBID0gMS43NTgwOTkzNDA4NDczNzY4NTk5NDAyMTc1MjA4MTIzO1xuZXhwb3J0cy5TRUxVX1NDQUxFID0gMS4wNTA3MDA5ODczNTU0ODA0OTM0MTkzMzQ5ODUyOTQ2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsdV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBzbGljZV91dGlsID0gcmVxdWlyZShcIi4vc2xpY2VfdXRpbFwiKTtcbnZhciBTbGljZU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpY2VPcHMoKSB7XG4gICAgfVxuICAgIFNsaWNlT3BzLnNsaWNlMWQgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAxLCBcInNsaWNlMWQgZXhwZWN0cyBhIHJhbmstMSB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiICsgeC5yYW5rICsgXCIgdGVuc29yXCIpO1xuICAgICAgICByZXR1cm4gU2xpY2VPcHMuc2xpY2UoeCwgW2JlZ2luXSwgW3NpemVdKTtcbiAgICB9O1xuICAgIFNsaWNlT3BzLnNsaWNlMmQgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAyLCBcInNsaWNlMWQgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiICsgeC5yYW5rICsgXCIgdGVuc29yXCIpO1xuICAgICAgICByZXR1cm4gU2xpY2VPcHMuc2xpY2UoeCwgYmVnaW4sIHNpemUpO1xuICAgIH07XG4gICAgU2xpY2VPcHMuc2xpY2UzZCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwic2xpY2UxZCBleHBlY3RzIGEgcmFuay0zIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIgKyB4LnJhbmsgKyBcIiB0ZW5zb3JcIik7XG4gICAgICAgIHJldHVybiBTbGljZU9wcy5zbGljZSh4LCBiZWdpbiwgc2l6ZSk7XG4gICAgfTtcbiAgICBTbGljZU9wcy5zbGljZTRkID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gNCwgXCJzbGljZTFkIGV4cGVjdHMgYSByYW5rLTQgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIiArIHgucmFuayArIFwiIHRlbnNvclwiKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlT3BzLnNsaWNlKHgsIGJlZ2luLCBzaXplKTtcbiAgICB9O1xuICAgIFNsaWNlT3BzLnNsaWNlID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3NsaWNlJyk7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2xpY2luZyBzY2FsYXIgaXMgbm90IHBvc3NpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZ2luXztcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGJlZ2luXyA9IFtiZWdpbl0uY29uY2F0KG5ldyBBcnJheSh4LnJhbmsgLSAxKS5maWxsKDApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWdpbi5sZW5ndGggPCB4LnJhbmspIHtcbiAgICAgICAgICAgIGJlZ2luXyA9IGJlZ2luLmNvbmNhdChuZXcgQXJyYXkoeC5yYW5rIC0gYmVnaW4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZ2luXyA9IGJlZ2luO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplXztcbiAgICAgICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2l6ZV8gPSBuZXcgQXJyYXkoeC5yYW5rKS5maWxsKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHNpemVfID0gW3NpemVdLmNvbmNhdChuZXcgQXJyYXkoeC5yYW5rIC0gMSkuZmlsbCgtMSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUubGVuZ3RoIDwgeC5yYW5rKSB7XG4gICAgICAgICAgICBzaXplXyA9IHNpemUuY29uY2F0KG5ldyBBcnJheSh4LnJhbmsgLSBzaXplLmxlbmd0aCkuZmlsbCgtMSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2l6ZV8gPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHNpemVfID0gc2l6ZV8ubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICBpZiAoZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydChkID09PSAtMSwgJ0JhZCB2YWx1ZSBpbiBzaXplJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguc2hhcGVbaV0gLSBiZWdpbl9baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbGljZV91dGlsLmFzc2VydFBhcmFtc1ZhbGlkKHgsIGJlZ2luXywgc2l6ZV8pO1xuICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IHguc2hhcGU7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHkucmFuazsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ3MucHVzaChbYmVnaW5fW2ldLCBpbnB1dFNoYXBlW2ldIC0gYmVnaW5fW2ldIC0gc2l6ZV9baV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LnBhZChwYWRkaW5ncyk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc2xpY2UoeCwgYmVnaW5fLCBzaXplXyk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgU2xpY2VPcHMsIFwic2xpY2VcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFNsaWNlT3BzO1xufSgpKTtcbmV4cG9ydHMuU2xpY2VPcHMgPSBTbGljZU9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2VydFBhcmFtc1ZhbGlkKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgIHV0aWwuYXNzZXJ0KGlucHV0LnJhbmsgPT09IGJlZ2luLmxlbmd0aCwgXCJFcnJvciBpbiBzbGljZVwiICsgaW5wdXQucmFuayArIFwiRDogTGVuZ3RoIG9mIGJlZ2luIFwiICsgYmVnaW4gKyBcIiBtdXN0IFwiICtcbiAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIiArIGlucHV0LnJhbmsgKyBcIikuXCIpKTtcbiAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSBzaXplLmxlbmd0aCwgXCJFcnJvciBpbiBzbGljZVwiICsgaW5wdXQucmFuayArIFwiRDogTGVuZ3RoIG9mIHNpemUgXCIgKyBzaXplICsgXCIgbXVzdCBcIiArXG4gICAgICAgIChcIm1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIgKyBpbnB1dC5yYW5rICsgXCIpLlwiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5yYW5rOyArK2kpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYmVnaW5baV0gKyBzaXplW2ldIDw9IGlucHV0LnNoYXBlW2ldLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBiZWdpbltcIiArIGkgKyBcIl0gKyBzaXplW1wiICsgaSArIFwiXSBcIiArXG4gICAgICAgICAgICAoXCIoXCIgKyAoYmVnaW5baV0gKyBzaXplW2ldKSArIFwiKSB3b3VsZCBvdmVyZmxvdyBpbnB1dC5zaGFwZVtcIiArIGkgKyBcIl0gKFwiICsgaW5wdXQuc2hhcGVbaV0gKyBcIilcIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0UGFyYW1zVmFsaWQgPSBhc3NlcnRQYXJhbXNWYWxpZDtcbmZ1bmN0aW9uIGdldFN0cmlkZWRTbGljZWRJbmZvKHNoYXBlLCBiZWdpbiwgZW5kLCBzdHJpZGVzLCBiZWdpbk1hc2ssIGVuZE1hc2spIHtcbiAgICBpZiAoYmVnaW5NYXNrID09PSB2b2lkIDApIHsgYmVnaW5NYXNrID0gMDsgfVxuICAgIGlmIChlbmRNYXNrID09PSB2b2lkIDApIHsgZW5kTWFzayA9IDA7IH1cbiAgICB2YXIgc3RhcnRJbmRleCA9IFtdO1xuICAgIHZhciBlbmRJbmRleCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhcnRJbmRleFtpXSA9IHN0YXJ0Rm9yQXhpcyhiZWdpbk1hc2ssIGJlZ2luLCBzdHJpZGVzLCBzaGFwZSwgaSk7XG4gICAgICAgIGVuZEluZGV4W2ldID0gc3RvcEZvckF4aXMoZW5kTWFzaywgZW5kLCBzdHJpZGVzLCBzaGFwZSwgaSk7XG4gICAgfVxuICAgIHZhciBzaXplID0gbmV3IEFycmF5KHNoYXBlLmxlbmd0aCkuZmlsbCgwKTtcbiAgICBzaXplID0gc2l6ZS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgc3RhcnQgPSBzdGFydEluZGV4W2ldOyAhKHN0cmlkZXNbaV0gPiAwID8gc3RhcnQgPj0gZW5kSW5kZXhbaV0gOiBzdGFydCA8PSBlbmRJbmRleFtpXSk7IHN0YXJ0ICs9IHN0cmlkZXNbaV0pIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0pO1xuICAgIHJldHVybiBbc3RhcnRJbmRleCwgc2l6ZV07XG59XG5leHBvcnRzLmdldFN0cmlkZWRTbGljZWRJbmZvID0gZ2V0U3RyaWRlZFNsaWNlZEluZm87XG5mdW5jdGlvbiBzdGFydEZvckF4aXMoYmVnaW5NYXNrLCBzdGFydEluZGljZXMsIHN0cmlkZXMsIGlucHV0U2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGFydEluZGljZXNbYXhpc107XG4gICAgaWYgKGJlZ2luTWFzayAmIDEgPDwgYXhpcykge1xuICAgICAgICBpZiAoc3RyaWRlc1theGlzXSA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBheGlzU2l6ZSA9IGlucHV0U2hhcGVbYXhpc107XG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCArPSBheGlzU2l6ZTtcbiAgICB9XG4gICAgc3RhcnQgPSB1dGlsLmNsYW1wKDAsIHN0YXJ0LCBheGlzU2l6ZSAtIDEpO1xuICAgIHJldHVybiBzdGFydDtcbn1cbmV4cG9ydHMuc3RhcnRGb3JBeGlzID0gc3RhcnRGb3JBeGlzO1xuZnVuY3Rpb24gc3RvcEZvckF4aXMoZW5kTWFzaywgc3RvcEluZGljZXMsIHN0cmlkZXMsIGlucHV0U2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgc3RvcCA9IHN0b3BJbmRpY2VzW2F4aXNdO1xuICAgIGlmIChlbmRNYXNrICYgKDEgPDwgYXhpcykpIHtcbiAgICAgICAgaWYgKHN0cmlkZXNbYXhpc10gPiAwKSB7XG4gICAgICAgICAgICBzdG9wID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdG9wID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGF4aXNTaXplID0gaW5wdXRTaGFwZVtheGlzXTtcbiAgICBpZiAoc3RvcCA8IDApIHtcbiAgICAgICAgc3RvcCArPSBheGlzU2l6ZTtcbiAgICB9XG4gICAgaWYgKHN0cmlkZXNbYXhpc10gPiAwKSB7XG4gICAgICAgIHN0b3AgPSB1dGlsLmNsYW1wKDAsIHN0b3AsIGF4aXNTaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0b3AgPSB1dGlsLmNsYW1wKC0xLCBzdG9wLCBheGlzU2l6ZSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcDtcbn1cbmV4cG9ydHMuc3RvcEZvckF4aXMgPSBzdG9wRm9yQXhpcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWNlX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIFNvZnRtYXhPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNvZnRtYXhPcHMoKSB7XG4gICAgfVxuICAgIFNvZnRtYXhPcHMuc29mdG1heCA9IGZ1bmN0aW9uIChsb2dpdHMsIGRpbSkge1xuICAgICAgICBpZiAoZGltID09PSB2b2lkIDApIHsgZGltID0gLTE7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgbG9naXRzOiBsb2dpdHMgfSwgJ3NvZnRtYXgnKTtcbiAgICAgICAgaWYgKGRpbSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGRpbSA9IGxvZ2l0cy5yYW5rIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltICE9PSBsb2dpdHMucmFuayAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgICAgICAgICAoXCJMb2dpdHMgd2FzIHJhbmsgXCIgKyBsb2dpdHMucmFuayArIFwiIGFuZCBkaW0gd2FzIFwiICsgZGltKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1c3RvbU9wID0gZ2xvYmFsc18xLmN1c3RvbUdyYWQoZnVuY3Rpb24gKGxvZ2l0cykge1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBsc2UgPSBsb2dpdHMubG9nU3VtRXhwKFtkaW1dLCBrZWVwRGltcyk7XG4gICAgICAgICAgICB2YXIgbG9nUmVzdWx0ID0gbG9naXRzLnRvRmxvYXQoKS5zdWIobHNlKTtcbiAgICAgICAgICAgIHZhciB5ID0gbG9nUmVzdWx0LmV4cCgpO1xuICAgICAgICAgICAgdmFyIGdyYWRGdW5jID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGR5VGltZXNZID0gZHkubXVsKHkpO1xuICAgICAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR5VGltZXNZLnN1YihkeVRpbWVzWS5zdW0oW2RpbV0sIGtlZXBEaW1zKS5tdWwoeSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB5LCBncmFkRnVuYzogZ3JhZEZ1bmMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdXN0b21PcChsb2dpdHMpO1xuICAgIH07XG4gICAgU29mdG1heE9wcy5zb2Z0bWF4Q3Jvc3NFbnRyb3B5ID0gZnVuY3Rpb24gKGxhYmVscywgbG9naXRzLCBkaW0pIHtcbiAgICAgICAgaWYgKGRpbSA9PT0gdm9pZCAwKSB7IGRpbSA9IC0xOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IGxhYmVsczogbGFiZWxzLCBsb2dpdHM6IGxvZ2l0cyB9LCAnc29mdG1heENyb3NzRW50cm9weScpO1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGxhYmVscy5zaGFwZSwgbG9naXRzLnNoYXBlLCAnRXJyb3IgaW4gc29mdG1heENyb3NzRW50cm9weTogJyk7XG4gICAgICAgIGlmIChkaW0gPT09IC0xKSB7XG4gICAgICAgICAgICBkaW0gPSBsb2dpdHMucmFuayAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbSAhPT0gbG9naXRzLnJhbmsgLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNvZnRtYXggY3Jvc3MgZW50cm9weSBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IFwiICtcbiAgICAgICAgICAgICAgICAoXCJzdXBwb3J0ZWQuIExhYmVscyAvIGxvZ2l0cyB3YXMgcmFuayBcIiArIGxvZ2l0cy5yYW5rICsgXCIgXCIpICtcbiAgICAgICAgICAgICAgICAoXCJhbmQgZGltIHdhcyBcIiArIGRpbSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXN0b21PcCA9IGdsb2JhbHNfMS5jdXN0b21HcmFkKGZ1bmN0aW9uIChsYWJlbHMsIGxvZ2l0cykge1xuICAgICAgICAgICAgdmFyIHByZWRpY3RlZFByb2JzID0gbG9naXRzLnNvZnRtYXgoZGltKTtcbiAgICAgICAgICAgIHZhciBjb3N0VmVjdG9yID0gb3BzLnNjYWxhcigxZS01KS5hZGQocHJlZGljdGVkUHJvYnMpLmxvZygpLm11bChsYWJlbHMpLm5lZygpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29zdFZlY3Rvci5zdW0oW2RpbV0pO1xuICAgICAgICAgICAgdmFyIGdyYWRGdW5jID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGR5U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0oZHkuc2hhcGUsIFtkaW1dKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBkeS5yZXNoYXBlKGR5U2hhcGUpLm11bChsYWJlbHMudG9GbG9hdCgpLnN1YihwcmVkaWN0ZWRQcm9icykpLFxuICAgICAgICAgICAgICAgICAgICBkeS5yZXNoYXBlKGR5U2hhcGUpLm11bChwcmVkaWN0ZWRQcm9icy5zdWIobGFiZWxzLnRvRmxvYXQoKSkpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBncmFkRnVuYzogZ3JhZEZ1bmMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdXN0b21PcChsYWJlbHMsIGxvZ2l0cyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTm9ybWFsaXphdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFNvZnRtYXhPcHMsIFwic29mdG1heFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0xvc3NlcycsIG5hbWVzcGFjZTogJ2xvc3NlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFNvZnRtYXhPcHMsIFwic29mdG1heENyb3NzRW50cm9weVwiLCBudWxsKTtcbiAgICByZXR1cm4gU29mdG1heE9wcztcbn0oKSk7XG5leHBvcnRzLlNvZnRtYXhPcHMgPSBTb2Z0bWF4T3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29mdG1heC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgU3RyaWRlZFNsaWNlT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpZGVkU2xpY2VPcHMoKSB7XG4gICAgfVxuICAgIFN0cmlkZWRTbGljZU9wcy5zdHJpZGVkU2xpY2UgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIGVuZCwgc3RyaWRlcywgYmVnaW5NYXNrLCBlbmRNYXNrKSB7XG4gICAgICAgIGlmIChiZWdpbk1hc2sgPT09IHZvaWQgMCkgeyBiZWdpbk1hc2sgPSAwOyB9XG4gICAgICAgIGlmIChlbmRNYXNrID09PSB2b2lkIDApIHsgZW5kTWFzayA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc3RyaWRlZFNsaWNlJyk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnN0cmlkZWRTbGljZSh4LCBiZWdpbiwgZW5kLCBzdHJpZGVzLCBiZWdpbk1hc2ssIGVuZE1hc2spOyB9LCB7IHg6IHggfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnU2xpY2luZyBhbmQgSm9pbmluZycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFN0cmlkZWRTbGljZU9wcywgXCJzdHJpZGVkU2xpY2VcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFN0cmlkZWRTbGljZU9wcztcbn0oKSk7XG5leHBvcnRzLlN0cmlkZWRTbGljZU9wcyA9IFN0cmlkZWRTbGljZU9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmlkZWRfc2xpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbCA9IHJlcXVpcmUoXCIuL2F4aXNfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBUcmFuc3Bvc2VPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9zZU9wcygpIHtcbiAgICB9XG4gICAgVHJhbnNwb3NlT3BzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uICh4LCBwZXJtKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3RyYW5zcG9zZScpO1xuICAgICAgICBpZiAocGVybSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwZXJtID0geC5zaGFwZS5tYXAoZnVuY3Rpb24gKHMsIGkpIHsgcmV0dXJuIGk7IH0pLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IHBlcm0ubGVuZ3RoLCBcIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIiArIHgucmFuayArIFwiIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggbGVuZ3RoIG9mIHBlcm0gXCIgKyBwZXJtICsgXCIuXCIpKTtcbiAgICAgICAgcGVybS5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChheGlzID49IDAgJiYgYXhpcyA8IHgucmFuaywgXCJBbGwgZW50cmllcyBpbiAncGVybScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIFwiICsgKHgucmFuayAtIDEpICtcbiAgICAgICAgICAgICAgICAoXCIgYnV0IGdvdCBcIiArIHBlcm0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh4LnJhbmsgPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHguY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgdW5kb1Blcm0gPSBheGlzX3V0aWwuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbihwZXJtKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LnRyYW5zcG9zZSh1bmRvUGVybSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQudHJhbnNwb3NlKHgsIHBlcm0pOyB9LCB7IHg6IHggfSwgZGVyKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdNYXRyaWNlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFRyYW5zcG9zZU9wcywgXCJ0cmFuc3Bvc2VcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFRyYW5zcG9zZU9wcztcbn0oKSk7XG5leHBvcnRzLlRyYW5zcG9zZU9wcyA9IFRyYW5zcG9zZU9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9zZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIHNlbHVfdXRpbCA9IHJlcXVpcmUoXCIuL3NlbHVfdXRpbFwiKTtcbnZhciBVbmFyeU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5hcnlPcHMoKSB7XG4gICAgfVxuICAgIFVuYXJ5T3BzLm5lZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ25lZycpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubmVnKCk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubmVnKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5jZWlsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnY2VpbCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb3BzLnplcm9zTGlrZShkeSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuY2VpbCh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuZmxvb3IgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdmbG9vcicpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb3BzLnplcm9zTGlrZShkeSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZmxvb3IoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnNpZ24gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdzaWduJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcHMuemVyb3NMaWtlKGR5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zaWduKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5yb3VuZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3JvdW5kJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcHMuemVyb3NMaWtlKGR5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5yb3VuZCh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuZXhwID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnZXhwJyk7XG4gICAgICAgIHZhciBiY2sgPSBmdW5jdGlvbiAoZHksIHNhdmVkKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHNhdmVkWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kLCBzYXZlKSB7IHJldHVybiBzYXZlKGJhY2tlbmQuZXhwKHgpKTsgfSwgeyB4OiB4IH0sIGJjayk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5leHBtMSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2V4cG0xJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWxTdHJpY3QoeC5leHAoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZXhwbTEoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2xvZycpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KHgudG9GbG9hdCgpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sb2coeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmxvZzFwID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbG9nMXAnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmRpdlN0cmljdCh4LmFkZChvcHMuc2NhbGFyKDEpKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubG9nMXAoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnNxcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdzcXJ0Jyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5kaXZTdHJpY3QoeC50b0Zsb2F0KCkuc3FydCgpLm11bChvcHMuc2NhbGFyKDIpKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc3FydCh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMucnNxcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdyc3FydCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5kaXZTdHJpY3QoeC5wb3cob3BzLnNjYWxhcigxLjUpKS5tdWwob3BzLnNjYWxhcigyKSkpLm5lZygpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5yc3FydCh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc3F1YXJlJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWxTdHJpY3QoeC50b0Zsb2F0KCkubXVsKG9wcy5zY2FsYXIoMikpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zcXVhcmUoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnJlY2lwcm9jYWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdyZWNpcHJvY2FsJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5kaXZTdHJpY3QoeC5zcXVhcmUoKS5uZWcoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQucmVjaXByb2NhbCh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuYWJzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnYWJzJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWxTdHJpY3QoeC50b0Zsb2F0KCkuc3RlcCgtMSkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmFicyh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuY2xpcEJ5VmFsdWUgPSBmdW5jdGlvbiAoeCwgY2xpcFZhbHVlTWluLCBjbGlwVmFsdWVNYXgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnY2xpcEJ5VmFsdWUnKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoKGNsaXBWYWx1ZU1pbiA8PSBjbGlwVmFsdWVNYXgpLCBcIkVycm9yIGluIGNsaXA6IG1pbiAoXCIgKyBjbGlwVmFsdWVNaW4gKyBcIikgbXVzdCBiZSBcIiArXG4gICAgICAgICAgICAoXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4IChcIiArIGNsaXBWYWx1ZU1heCArIFwiKS5cIikpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS53aGVyZSh4LmdyZWF0ZXJFcXVhbChvcHMuc2NhbGFyKGNsaXBWYWx1ZU1pbikpXG4gICAgICAgICAgICAgICAgICAgIC5sb2dpY2FsQW5kKHgubGVzc0VxdWFsKG9wcy5zY2FsYXIoY2xpcFZhbHVlTWF4KSkpLCBvcHNfMS56ZXJvc0xpa2UoZHkpKTsgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNsaXAoeCwgY2xpcFZhbHVlTWluLCBjbGlwVmFsdWVNYXgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5yZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAncmVsdScpO1xuICAgICAgICBpZiAoeC5kdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICByZXR1cm4geC50b0ludCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgc3RlcFJlcyA9IHguc3RlcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHN0ZXBSZXMudG9GbG9hdCgpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5yZWx1KHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5lbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdlbHUnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHksIHNhdmVkKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHNhdmVkWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmVsdURlcihkeSwgeSk7IH0sIHsgZHk6IGR5LCB5OiB5IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kLCBzYXZlKSB7IHJldHVybiBzYXZlKGJhY2tlbmQuZWx1KHgpKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc2VsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3NlbHUnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IHguZ3JlYXRlcihvcHMuc2NhbGFyKDApKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlQWxwaGEgPSBvcHMuc2NhbGFyKHNlbHVfdXRpbC5TRUxVX1NDQUxFQUxQSEEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBvcHMuc2NhbGFyKHNlbHVfdXRpbC5TRUxVX1NDQUxFKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyZWF0ZXJUaGFuWmVyb0RlciA9IGR5Lm11bChzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXNzRXF1YWxaZXJvRGVyID0gZHkubXVsKHNjYWxlQWxwaGEpLm11bCh4LnRvRmxvYXQoKS5leHAoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHMud2hlcmUobWFzaywgZ3JlYXRlclRoYW5aZXJvRGVyLCBsZXNzRXF1YWxaZXJvRGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zZWx1KHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5sZWFreVJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjI7IH1cbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbGVha3lSZWx1Jyk7XG4gICAgICAgIHJldHVybiBvcHMubWF4aW11bShvcHMuc2NhbGFyKGFscGhhKS5tdWwoeCksIHgpO1xuICAgIH07XG4gICAgVW5hcnlPcHMucHJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCwgYWxwaGE6IGFscGhhIH0sICdwcmVsdScpO1xuICAgICAgICB2YXIgemVybyA9IG9wcy5zY2FsYXIoMCk7XG4gICAgICAgIHJldHVybiBvcHMubWF4aW11bSh6ZXJvLCB4KS5hZGQoYWxwaGEubXVsKG9wcy5taW5pbXVtKHplcm8sIHgpKSk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5zaWdtb2lkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc2lnbW9pZCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSwgc2F2ZWQpIHtcbiAgICAgICAgICAgIHZhciB5ID0gc2F2ZWRbMF07XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWxTdHJpY3QoeS5tdWwob3BzLnNjYWxhcigxKS5zdWIoeSkpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCwgc2F2ZSkgeyByZXR1cm4gc2F2ZShiYWNrZW5kLnNpZ21vaWQoeCkpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5sb2dTaWdtb2lkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnbG9nU2lnbW9pZCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHgubmVnKCkuc2lnbW9pZCgpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zb2Z0cGx1cyh4Lm5lZygpKS5uZWcoKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc29mdHBsdXMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdzb2Z0cGx1cycpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHguc2lnbW9pZCgpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zb2Z0cGx1cyh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc2luID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc2luJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4LnRvRmxvYXQoKS5jb3MoKS5tdWxTdHJpY3QoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnNpbih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuY29zID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnY29zJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4LnRvRmxvYXQoKS5zaW4oKS5uZWcoKS5tdWxTdHJpY3QoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNvcyh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMudGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAndGFuJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5kaXZTdHJpY3QoeC5jb3MoKS5zcXVhcmUoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQudGFuKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5hc2luID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnYXNpbicpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeS5kaXZTdHJpY3QoVW5hcnlPcHMuc3FydChvcHMuc2NhbGFyKDEpLnN1Yih4LnRvRmxvYXQoKS5zcXVhcmUoKSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hc2luKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5hY29zID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnYWNvcycpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeS5kaXZTdHJpY3QoVW5hcnlPcHMuc3FydChvcHMuc2NhbGFyKDEpLnN1Yih4LnRvRmxvYXQoKS5zcXVhcmUoKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5lZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmFjb3MoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmF0YW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdhdGFuJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5kaXZTdHJpY3Qob3BzLnNjYWxhcigxKS5hZGQoeC50b0Zsb2F0KCkuc3F1YXJlKCkpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hdGFuKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5zaW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRBcmd1bWVudHNBcmVUZW5zb3JzKHsgeDogeCB9LCAnc2luaCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4geC50b0Zsb2F0KCkuY29zaCgpLm11bFN0cmljdChkeSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc2luaCh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuY29zaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ2Nvc2gnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHgudG9GbG9hdCgpLnNpbmgoKS5tdWxTdHJpY3QoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNvc2goeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICd0YW5oJyk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5LCBzYXZlZCkge1xuICAgICAgICAgICAgdmFyIHkgPSBzYXZlZFswXTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wcy5zY2FsYXIoMSkuc3ViKHkuc3F1YXJlKCkpLm11bFN0cmljdChkeSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQsIHNhdmUpIHsgcmV0dXJuIHNhdmUoYmFja2VuZC50YW5oKHgpKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuYXNpbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdhc2luaCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeS5kaXZTdHJpY3QoVW5hcnlPcHMuc3FydChvcHMuc2NhbGFyKDEpLmFkZCh4LnRvRmxvYXQoKS5zcXVhcmUoKSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hc2luaCh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuYWNvc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdhY29zaCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeS5kaXZTdHJpY3QoVW5hcnlPcHMuc3FydCh4LnRvRmxvYXQoKS5zcXVhcmUoKS5zdWIob3BzLnNjYWxhcigxKSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hY29zaCh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuYXRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoeyB4OiB4IH0sICdhdGFuaCcpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KG9wcy5zY2FsYXIoMSkuc3ViKHgudG9GbG9hdCgpLnNxdWFyZSgpKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXRhbmgoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmVyZiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHguZHR5cGUgPT09ICdpbnQzMicgfHwgeC5kdHlwZSA9PT0gJ2Zsb2F0MzInLCAnSW5wdXQgZHR5cGUgbXVzdCBiZSBgaW50MzJgIG9yIGBmbG9hdDMyYC4nKTtcbiAgICAgICAgaWYgKHguZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgIHggPSB4LnRvRmxvYXQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeS5tdWxTdHJpY3Qob3BzLnNjYWxhcigyIC8gTWF0aC5zcXJ0KE1hdGguUEkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bCh4LnNxdWFyZSgpLm5lZygpLmV4cCgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZXJmKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5zdGVwID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4wOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyh7IHg6IHggfSwgJ3N0ZXAnKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wcy56ZXJvc0xpa2UoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnN0ZXAoeCwgYWxwaGEpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcIm5lZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImNlaWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJmbG9vclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInNpZ25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJyb3VuZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImV4cFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImV4cG0xXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwibG9nXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwibG9nMXBcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzcXJ0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwicnNxcnRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzcXVhcmVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJyZWNpcHJvY2FsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiYWJzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiY2xpcEJ5VmFsdWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJyZWx1XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiZWx1XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwic2VsdVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImxlYWt5UmVsdVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInByZWx1XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwic2lnbW9pZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImxvZ1NpZ21vaWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzb2Z0cGx1c1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInNpblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImNvc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInRhblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImFzaW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJhY29zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiYXRhblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInNpbmhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJjb3NoXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwidGFuaFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImFzaW5oXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiYWNvc2hcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJhdGFuaFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImVyZlwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInN0ZXBcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFVuYXJ5T3BzO1xufSgpKTtcbmV4cG9ydHMuVW5hcnlPcHMgPSBVbmFyeU9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuYXJ5X29wcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2VyaWFsaXphdGlvblwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFkZWx0YU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYWRlbHRhT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYWRlbHRhT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgcmhvLCBlcHNpbG9uKSB7XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5yaG8gPSByaG87XG4gICAgICAgIF90aGlzLmVwc2lsb24gPSBlcHNpbG9uO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzID0ge307XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyA9IHt9O1xuICAgICAgICBfdGhpcy5jID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKC1sZWFybmluZ1JhdGUpKTtcbiAgICAgICAgX3RoaXMuZXBzaWxvblNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihlcHNpbG9uKSk7XG4gICAgICAgIF90aGlzLnJob1NjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihyaG8pKTtcbiAgICAgICAgX3RoaXMub25lTWludXNSaG8gPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSAtIHJobykpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYWRlbHRhT3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICBpZiAodGhpc18xLmFjY3VtdWxhdGVkR3JhZHNbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZV8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzW3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGVfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc18xLmFjY3VtdWxhdGVkVXBkYXRlc1t2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlXzIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlc1t2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlXzIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdmFyaWFibGVHcmFkaWVudHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZEdyYWQgPSB0aGlzXzEuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGVkVXBkYXRlID0gdGhpc18xLmFjY3VtdWxhdGVkVXBkYXRlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZEdyYWQgPSBfdGhpcy5yaG9TY2FsYXIubXVsKGFjY3VtdWxhdGVkR3JhZClcbiAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5vbmVNaW51c1Joby5tdWwoZ3JhZGllbnQuc3F1YXJlKCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlcyA9IGFjY3VtdWxhdGVkVXBkYXRlLmFkZChfdGhpcy5lcHNpbG9uU2NhbGFyKVxuICAgICAgICAgICAgICAgICAgICAuc3FydCgpXG4gICAgICAgICAgICAgICAgICAgIC5kaXYoYWNjdW11bGF0ZWRHcmFkLmFkZChfdGhpcy5lcHNpbG9uU2NhbGFyKS5zcXJ0KCkpXG4gICAgICAgICAgICAgICAgICAgIC5tdWwoZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZFVwZGF0ZSA9IF90aGlzLnJob1NjYWxhci5tdWwoYWNjdW11bGF0ZWRVcGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoX3RoaXMub25lTWludXNSaG8ubXVsKHVwZGF0ZXMuc3F1YXJlKCkpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkR3JhZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkVXBkYXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5jLm11bCh1cGRhdGVzKS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFzc2lnbihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHZhcmlhYmxlTmFtZSBpbiB2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICAgICAgX2xvb3BfMSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5lcHNpbG9uU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5yaG9TY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uZU1pbnVzUmhvLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXNbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRHcmFkcylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuYWNjdW11bGF0ZWRHcmFkc1tuYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVhcm5pbmdSYXRlOiB0aGlzLmxlYXJuaW5nUmF0ZSxcbiAgICAgICAgICAgIHJobzogdGhpcy5yaG8sXG4gICAgICAgICAgICBlcHNpbG9uOiB0aGlzLmVwc2lsb25cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEFkYWRlbHRhT3B0aW1pemVyLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnLmxlYXJuaW5nUmF0ZSwgY29uZmlnLnJobywgY29uZmlnLmVwc2lsb24pO1xuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIuY2xhc3NOYW1lID0gJ0FkYWRlbHRhT3B0aW1pemVyJztcbiAgICByZXR1cm4gQWRhZGVsdGFPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5BZGFkZWx0YU9wdGltaXplciA9IEFkYWRlbHRhT3B0aW1pemVyO1xuc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoQWRhZGVsdGFPcHRpbWl6ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhZGVsdGFfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zZXJpYWxpemF0aW9uXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIEFkYWdyYWRPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGFncmFkT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYWdyYWRPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSkge1xuICAgICAgICBpZiAoaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUgPT09IHZvaWQgMCkgeyBpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSA9IDAuMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlID0gaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWU7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkR3JhZHMgPSB7fTtcbiAgICAgICAgX3RoaXMuYyA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigtbGVhcm5pbmdSYXRlKSk7XG4gICAgICAgIF90aGlzLmVwc2lsb24gPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMWUtOCkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYWdyYWRPcHRpbWl6ZXIucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzID0gZnVuY3Rpb24gKHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIGlmICh0aGlzXzEuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlXzEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkR3JhZHNbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS5maWxsKHZhbHVlLnNoYXBlLCBfdGhpcy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFyaWFibGUodHJhaW5hYmxlXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdmFyaWFibGVHcmFkaWVudHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZEdyYWQgPSB0aGlzXzEuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZEdyYWQgPSBhY2N1bXVsYXRlZEdyYWQuYWRkKGdyYWRpZW50LnNxdWFyZSgpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkR3JhZCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuY1xuICAgICAgICAgICAgICAgICAgICAubXVsKGdyYWRpZW50LmRpdihuZXdBY2N1bXVsYXRlZEdyYWQuYWRkKF90aGlzLmVwc2lsb24pLnNxcnQoKSkpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFzc2lnbihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHZhcmlhYmxlTmFtZSBpbiB2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICAgICAgX2xvb3BfMSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVwc2lsb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZEdyYWRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRHcmFkcylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuYWNjdW11bGF0ZWRHcmFkc1tuYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWFybmluZ1JhdGU6IHRoaXMubGVhcm5pbmdSYXRlLFxuICAgICAgICAgICAgaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWU6IHRoaXMuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnLmxlYXJuaW5nUmF0ZSwgY29uZmlnLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlKTtcbiAgICB9O1xuICAgIEFkYWdyYWRPcHRpbWl6ZXIuY2xhc3NOYW1lID0gJ0FkYWdyYWRPcHRpbWl6ZXInO1xuICAgIHJldHVybiBBZGFncmFkT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhZ3JhZE9wdGltaXplciA9IEFkYWdyYWRPcHRpbWl6ZXI7XG5zZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihBZGFncmFkT3B0aW1pemVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYWdyYWRfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zZXJpYWxpemF0aW9uXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIEFkYW1PcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGFtT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYW1PcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIGVwc2lsb24pIHtcbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmJldGExID0gYmV0YTE7XG4gICAgICAgIF90aGlzLmJldGEyID0gYmV0YTI7XG4gICAgICAgIF90aGlzLmVwc2lsb24gPSBlcHNpbG9uO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50ID0ge307XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50ID0ge307XG4gICAgICAgIF90aGlzLmMgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoLWxlYXJuaW5nUmF0ZSkpO1xuICAgICAgICBfdGhpcy5lcHNTY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoZXBzaWxvbikpO1xuICAgICAgICBfdGhpcy5iZXRhMVNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihiZXRhMSkpO1xuICAgICAgICBfdGhpcy5iZXRhMlNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihiZXRhMikpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5hY2NCZXRhMSA9IG9wc18xLnNjYWxhcihiZXRhMSkudmFyaWFibGUoKTtcbiAgICAgICAgICAgIF90aGlzLmFjY0JldGEyID0gb3BzXzEuc2NhbGFyKGJldGEyKS52YXJpYWJsZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub25lTWludXNCZXRhMSA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigxIC0gYmV0YTEpKTtcbiAgICAgICAgX3RoaXMub25lTWludXNCZXRhMiA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigxIC0gYmV0YTIpKTtcbiAgICAgICAgX3RoaXMub25lID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKDEpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb25lTWludXNBY2NCZXRhMSA9IF90aGlzLm9uZS5zdWIoX3RoaXMuYWNjQmV0YTEpO1xuICAgICAgICAgICAgdmFyIG9uZU1pbnVzQWNjQmV0YTIgPSBfdGhpcy5vbmUuc3ViKF90aGlzLmFjY0JldGEyKTtcbiAgICAgICAgICAgIGZvciAodmFyIHZhcmlhYmxlTmFtZSBpbiB2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFt2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W3ZhcmlhYmxlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSB2YXJpYWJsZUdyYWRpZW50c1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdE1vbWVudCA9IF90aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kTW9tZW50ID0gX3RoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Rmlyc3RNb21lbnQgPSBfdGhpcy5iZXRhMVNjYWxhci5tdWwoZmlyc3RNb21lbnQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoX3RoaXMub25lTWludXNCZXRhMS5tdWwoZ3JhZGllbnQpKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2Vjb25kTW9tZW50ID0gX3RoaXMuYmV0YTJTY2FsYXIubXVsKHNlY29uZE1vbWVudClcbiAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5vbmVNaW51c0JldGEyLm11bChncmFkaWVudC5zcXVhcmUoKSkpO1xuICAgICAgICAgICAgICAgIHZhciBiaWFzQ29ycmVjdGVkRmlyc3RNb21lbnQgPSBuZXdGaXJzdE1vbWVudC5kaXYob25lTWludXNBY2NCZXRhMSk7XG4gICAgICAgICAgICAgICAgdmFyIGJpYXNDb3JyZWN0ZWRTZWNvbmRNb21lbnQgPSBuZXdTZWNvbmRNb21lbnQuZGl2KG9uZU1pbnVzQWNjQmV0YTIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbdmFyaWFibGVOYW1lXS5hc3NpZ24obmV3Rmlyc3RNb21lbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld1NlY29uZE1vbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuY1xuICAgICAgICAgICAgICAgICAgICAubXVsKGJpYXNDb3JyZWN0ZWRGaXJzdE1vbWVudC5kaXYoX3RoaXMuZXBzU2NhbGFyLmFkZChiaWFzQ29ycmVjdGVkU2Vjb25kTW9tZW50LnNxcnQoKSkpKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5hc3NpZ24obmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuYWNjQmV0YTEuYXNzaWduKF90aGlzLmFjY0JldGExLm11bChfdGhpcy5iZXRhMVNjYWxhcikpO1xuICAgICAgICAgICAgX3RoaXMuYWNjQmV0YTIuYXNzaWduKF90aGlzLmFjY0JldGEyLm11bChfdGhpcy5iZXRhMlNjYWxhcikpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFkYW1PcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZXBzU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iZXRhMVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYmV0YTJTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0JldGExLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2NCZXRhMi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub25lTWludXNCZXRhMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub25lTWludXNCZXRhMi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub25lLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtuYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWFybmluZ1JhdGU6IHRoaXMubGVhcm5pbmdSYXRlLFxuICAgICAgICAgICAgYmV0YTE6IHRoaXMuYmV0YTEsXG4gICAgICAgICAgICBiZXRhMjogdGhpcy5iZXRhMixcbiAgICAgICAgICAgIGVwc2lsb246IHRoaXMuZXBzaWxvbixcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEFkYW1PcHRpbWl6ZXIuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNscyhjb25maWcubGVhcm5pbmdSYXRlLCBjb25maWcuYmV0YTEsIGNvbmZpZy5iZXRhMiwgY29uZmlnLmVwc2lsb24pO1xuICAgIH07XG4gICAgQWRhbU9wdGltaXplci5jbGFzc05hbWUgPSAnQWRhbU9wdGltaXplcic7XG4gICAgcmV0dXJuIEFkYW1PcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5BZGFtT3B0aW1pemVyID0gQWRhbU9wdGltaXplcjtcbnNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEFkYW1PcHRpbWl6ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhbV9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlcmlhbGl6YXRpb25cIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhbWF4T3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhbWF4T3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYW1heE9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgZXBzaWxvbiwgZGVjYXkpIHtcbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICBpZiAoZGVjYXkgPT09IHZvaWQgMCkgeyBkZWNheSA9IDAuMDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmJldGExID0gYmV0YTE7XG4gICAgICAgIF90aGlzLmJldGEyID0gYmV0YTI7XG4gICAgICAgIF90aGlzLmVwc2lsb24gPSBlcHNpbG9uO1xuICAgICAgICBfdGhpcy5kZWNheSA9IGRlY2F5O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50ID0ge307XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtID0ge307XG4gICAgICAgIF90aGlzLmMgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoLWxlYXJuaW5nUmF0ZSkpO1xuICAgICAgICBfdGhpcy5lcHNTY2FsYXIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoZXBzaWxvbikpO1xuICAgICAgICBfdGhpcy5iZXRhMVNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihiZXRhMSkpO1xuICAgICAgICBfdGhpcy5iZXRhMlNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihiZXRhMikpO1xuICAgICAgICBfdGhpcy5kZWNheVNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihkZWNheSkpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pdGVyYXRpb24gPSBvcHNfMS5zY2FsYXIoMCkudmFyaWFibGUoKTtcbiAgICAgICAgICAgIF90aGlzLmFjY0JldGExID0gb3BzXzEuc2NhbGFyKGJldGExKS52YXJpYWJsZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub25lTWludXNCZXRhMSA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigxIC0gYmV0YTEpKTtcbiAgICAgICAgX3RoaXMub25lID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKDEpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFtYXhPcHRpbWl6ZXIucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzID0gZnVuY3Rpb24gKHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbmVNaW51c0FjY0JldGExID0gX3RoaXMub25lLnN1YihfdGhpcy5hY2NCZXRhMSk7XG4gICAgICAgICAgICB2YXIgbHIgPSBfdGhpcy5jLmRpdihfdGhpcy5vbmUuYWRkKF90aGlzLmRlY2F5U2NhbGFyLm11bChfdGhpcy5pdGVyYXRpb24pKSk7XG4gICAgICAgICAgICBmb3IgKHZhciB2YXJpYWJsZU5hbWUgaW4gdmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVt2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVt2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdmFyaWFibGVHcmFkaWVudHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RNb21lbnQgPSBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIHdlaWdodGVkSW5mTm9ybSA9IF90aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpcnN0TW9tZW50ID0gX3RoaXMuYmV0YTFTY2FsYXIubXVsKGZpcnN0TW9tZW50KVxuICAgICAgICAgICAgICAgICAgICAuYWRkKF90aGlzLm9uZU1pbnVzQmV0YTEubXVsKGdyYWRpZW50KSk7XG4gICAgICAgICAgICAgICAgdmFyIHV0MCA9IF90aGlzLmJldGEyU2NhbGFyLm11bCh3ZWlnaHRlZEluZk5vcm0pO1xuICAgICAgICAgICAgICAgIHZhciB1dDEgPSBncmFkaWVudC5hYnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3V2VpZ2h0ZWRJbmZOb3JtID0gdXQwLm1heGltdW0odXQxKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0ZpcnN0TW9tZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVt2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdXZWlnaHRlZEluZk5vcm0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGxyLmRpdihvbmVNaW51c0FjY0JldGExKVxuICAgICAgICAgICAgICAgICAgICAubXVsKG5ld0ZpcnN0TW9tZW50LmRpdihfdGhpcy5lcHNTY2FsYXIuYWRkKG5ld1dlaWdodGVkSW5mTm9ybSkpKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5hc3NpZ24obmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaXRlcmF0aW9uLmFzc2lnbihfdGhpcy5pdGVyYXRpb24uYWRkKF90aGlzLm9uZSkpO1xuICAgICAgICAgICAgX3RoaXMuYWNjQmV0YTEuYXNzaWduKF90aGlzLmFjY0JldGExLm11bChfdGhpcy5iZXRhMVNjYWxhcikpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5lcHNTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0JldGExLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iZXRhMVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYmV0YTJTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uZU1pbnVzQmV0YTEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmRlY2F5U2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uZS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0gIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhbWF4T3B0aW1pemVyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWFybmluZ1JhdGU6IHRoaXMubGVhcm5pbmdSYXRlLFxuICAgICAgICAgICAgYmV0YTE6IHRoaXMuYmV0YTEsXG4gICAgICAgICAgICBiZXRhMjogdGhpcy5iZXRhMixcbiAgICAgICAgICAgIGVwc2lsb246IHRoaXMuZXBzaWxvbixcbiAgICAgICAgICAgIGRlY2F5OiB0aGlzLmRlY2F5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBZGFtYXhPcHRpbWl6ZXIuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNscyhjb25maWcubGVhcm5pbmdSYXRlLCBjb25maWcuYmV0YTEsIGNvbmZpZy5iZXRhMiwgY29uZmlnLmVwc2lsb24sIGNvbmZpZy5kZWNheSk7XG4gICAgfTtcbiAgICBBZGFtYXhPcHRpbWl6ZXIuY2xhc3NOYW1lID0gJ0FkYW1heE9wdGltaXplcic7XG4gICAgcmV0dXJuIEFkYW1heE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYW1heE9wdGltaXplciA9IEFkYW1heE9wdGltaXplcjtcbnNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEFkYW1heE9wdGltaXplcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFtYXhfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zZXJpYWxpemF0aW9uXCIpO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NnZF9vcHRpbWl6ZXJcIik7XG52YXIgTW9tZW50dW1PcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb21lbnR1bU9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb21lbnR1bU9wdGltaXplcihsZWFybmluZ1JhdGUsIG1vbWVudHVtLCB1c2VOZXN0ZXJvdikge1xuICAgICAgICBpZiAodXNlTmVzdGVyb3YgPT09IHZvaWQgMCkgeyB1c2VOZXN0ZXJvdiA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5tb21lbnR1bSA9IG1vbWVudHVtO1xuICAgICAgICBfdGhpcy51c2VOZXN0ZXJvdiA9IHVzZU5lc3Rlcm92O1xuICAgICAgICBfdGhpcy5tID0gb3BzXzEuc2NhbGFyKF90aGlzLm1vbWVudHVtKTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0aW9ucyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICBpZiAodGhpc18xLmFjY3VtdWxhdGlvbnNbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZV8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRpb25zW3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGVfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0aW9uID0gdGhpc18xLmFjY3VtdWxhdGlvbnNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHZhcmlhYmxlR3JhZGllbnRzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRpb24gPSBfdGhpcy5tLm11bChhY2N1bXVsYXRpb24pLmFkZChncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVzZU5lc3Rlcm92KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmMubXVsKGdyYWRpZW50LmFkZChuZXdBY2N1bXVsYXRpb24ubXVsKF90aGlzLm0pKSkuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gX3RoaXMuYy5tdWwobmV3QWNjdW11bGF0aW9uKS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRpb25zW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGlvbik7XG4gICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgdmFyaWFibGVOYW1lIGluIHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgICAgICBfbG9vcF8xKHZhcmlhYmxlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5tLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2YXJpYWJsZU5hbWUgaW4gdGhpcy5hY2N1bXVsYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRpb25zW3ZhcmlhYmxlTmFtZV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuc2V0TW9tZW50dW0gPSBmdW5jdGlvbiAobW9tZW50dW0pIHtcbiAgICAgICAgdGhpcy5tb21lbnR1bSA9IG1vbWVudHVtO1xuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlYXJuaW5nUmF0ZTogdGhpcy5sZWFybmluZ1JhdGUsXG4gICAgICAgICAgICBtb21lbnR1bTogdGhpcy5tb21lbnR1bSxcbiAgICAgICAgICAgIHVzZU5lc3Rlcm92OiB0aGlzLnVzZU5lc3Rlcm92XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xzKGNvbmZpZy5sZWFybmluZ1JhdGUsIGNvbmZpZy5tb21lbnR1bSwgY29uZmlnLnVzZU5lc3Rlcm92KTtcbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLmNsYXNzTmFtZSA9ICdNb21lbnR1bU9wdGltaXplcic7XG4gICAgcmV0dXJuIE1vbWVudHVtT3B0aW1pemVyO1xufShzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyKSk7XG5leHBvcnRzLk1vbWVudHVtT3B0aW1pemVyID0gTW9tZW50dW1PcHRpbWl6ZXI7XG5zZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihNb21lbnR1bU9wdGltaXplcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb21lbnR1bV9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlcmlhbGl6YXRpb25cIik7XG52YXIgT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9wdGltaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPcHRpbWl6ZXIucHJvdG90eXBlLm1pbmltaXplID0gZnVuY3Rpb24gKGYsIHJldHVybkNvc3QsIHZhckxpc3QpIHtcbiAgICAgICAgaWYgKHJldHVybkNvc3QgPT09IHZvaWQgMCkgeyByZXR1cm5Db3N0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb21wdXRlR3JhZGllbnRzKGYsIHZhckxpc3QpLCB2YWx1ZSA9IF9hLnZhbHVlLCBncmFkcyA9IF9hLmdyYWRzO1xuICAgICAgICB0aGlzLmFwcGx5R3JhZGllbnRzKGdyYWRzKTtcbiAgICAgICAgdmFyIHZhck5hbWVzID0gT2JqZWN0LmtleXMoZ3JhZHMpO1xuICAgICAgICB2YXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7IHJldHVybiBncmFkc1t2YXJOYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICBpZiAocmV0dXJuQ29zdCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuY29tcHV0ZUdyYWRpZW50cyA9IGZ1bmN0aW9uIChmLCB2YXJMaXN0KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudmFyaWFibGVHcmFkcyhmLCB2YXJMaXN0KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnT3B0aW1pemVycycgfSlcbiAgICBdLCBPcHRpbWl6ZXIucHJvdG90eXBlLCBcIm1pbmltaXplXCIsIG51bGwpO1xuICAgIE9wdGltaXplciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIG5hbWVzcGFjZTogJ3RyYWluJyB9KVxuICAgIF0sIE9wdGltaXplcik7XG4gICAgcmV0dXJuIE9wdGltaXplcjtcbn0oc2VyaWFsaXphdGlvbl8xLlNlcmlhbGl6YWJsZSkpO1xuZXhwb3J0cy5PcHRpbWl6ZXIgPSBPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGFkYWRlbHRhX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vYWRhZGVsdGFfb3B0aW1pemVyXCIpO1xudmFyIGFkYWdyYWRfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9hZGFncmFkX29wdGltaXplclwiKTtcbnZhciBhZGFtX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vYWRhbV9vcHRpbWl6ZXJcIik7XG52YXIgYWRhbWF4X29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vYWRhbWF4X29wdGltaXplclwiKTtcbnZhciBtb21lbnR1bV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL21vbWVudHVtX29wdGltaXplclwiKTtcbnZhciBybXNwcm9wX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vcm1zcHJvcF9vcHRpbWl6ZXJcIik7XG52YXIgc2dkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vc2dkX29wdGltaXplclwiKTtcbnZhciBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wdGltaXplckNvbnN0cnVjdG9ycygpIHtcbiAgICB9XG4gICAgT3B0aW1pemVyQ29uc3RydWN0b3JzLnNnZCA9IGZ1bmN0aW9uIChsZWFybmluZ1JhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyKGxlYXJuaW5nUmF0ZSk7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMubW9tZW50dW0gPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlLCBtb21lbnR1bSwgdXNlTmVzdGVyb3YpIHtcbiAgICAgICAgaWYgKHVzZU5lc3Rlcm92ID09PSB2b2lkIDApIHsgdXNlTmVzdGVyb3YgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gbmV3IG1vbWVudHVtX29wdGltaXplcl8xLk1vbWVudHVtT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgbW9tZW50dW0sIHVzZU5lc3Rlcm92KTtcbiAgICB9O1xuICAgIE9wdGltaXplckNvbnN0cnVjdG9ycy5ybXNwcm9wID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgZGVjYXksIG1vbWVudHVtLCBlcHNpbG9uLCBjZW50ZXJlZCkge1xuICAgICAgICBpZiAoZGVjYXkgPT09IHZvaWQgMCkgeyBkZWNheSA9IC45OyB9XG4gICAgICAgIGlmIChtb21lbnR1bSA9PT0gdm9pZCAwKSB7IG1vbWVudHVtID0gMC4wOyB9XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgaWYgKGNlbnRlcmVkID09PSB2b2lkIDApIHsgY2VudGVyZWQgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gbmV3IHJtc3Byb3Bfb3B0aW1pemVyXzEuUk1TUHJvcE9wdGltaXplcihsZWFybmluZ1JhdGUsIGRlY2F5LCBtb21lbnR1bSwgZXBzaWxvbiwgY2VudGVyZWQpO1xuICAgIH07XG4gICAgT3B0aW1pemVyQ29uc3RydWN0b3JzLmFkYW0gPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIGVwc2lsb24pIHtcbiAgICAgICAgaWYgKGxlYXJuaW5nUmF0ZSA9PT0gdm9pZCAwKSB7IGxlYXJuaW5nUmF0ZSA9IDAuMDAxOyB9XG4gICAgICAgIGlmIChiZXRhMSA9PT0gdm9pZCAwKSB7IGJldGExID0gMC45OyB9XG4gICAgICAgIGlmIChiZXRhMiA9PT0gdm9pZCAwKSB7IGJldGEyID0gMC45OTk7IH1cbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICByZXR1cm4gbmV3IGFkYW1fb3B0aW1pemVyXzEuQWRhbU9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgZXBzaWxvbik7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhZGVsdGEgPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlLCByaG8sIGVwc2lsb24pIHtcbiAgICAgICAgaWYgKGxlYXJuaW5nUmF0ZSA9PT0gdm9pZCAwKSB7IGxlYXJuaW5nUmF0ZSA9IC4wMDE7IH1cbiAgICAgICAgaWYgKHJobyA9PT0gdm9pZCAwKSB7IHJobyA9IC45NTsgfVxuICAgICAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS04OyB9XG4gICAgICAgIHJldHVybiBuZXcgYWRhZGVsdGFfb3B0aW1pemVyXzEuQWRhZGVsdGFPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCByaG8sIGVwc2lsb24pO1xuICAgIH07XG4gICAgT3B0aW1pemVyQ29uc3RydWN0b3JzLmFkYW1heCA9IGZ1bmN0aW9uIChsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgZXBzaWxvbiwgZGVjYXkpIHtcbiAgICAgICAgaWYgKGxlYXJuaW5nUmF0ZSA9PT0gdm9pZCAwKSB7IGxlYXJuaW5nUmF0ZSA9IDAuMDAyOyB9XG4gICAgICAgIGlmIChiZXRhMSA9PT0gdm9pZCAwKSB7IGJldGExID0gMC45OyB9XG4gICAgICAgIGlmIChiZXRhMiA9PT0gdm9pZCAwKSB7IGJldGEyID0gMC45OTk7IH1cbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICBpZiAoZGVjYXkgPT09IHZvaWQgMCkgeyBkZWNheSA9IDAuMDsgfVxuICAgICAgICByZXR1cm4gbmV3IGFkYW1heF9vcHRpbWl6ZXJfMS5BZGFtYXhPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIGVwc2lsb24sIGRlY2F5KTtcbiAgICB9O1xuICAgIE9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFncmFkID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpIHtcbiAgICAgICAgaWYgKGluaXRpYWxBY2N1bXVsYXRvclZhbHVlID09PSB2b2lkIDApIHsgaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUgPSAwLjE7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBhZGFncmFkX29wdGltaXplcl8xLkFkYWdyYWRPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwic2dkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnT3B0aW1pemVycycsIG5hbWVzcGFjZTogJ3RyYWluJyB9KVxuICAgIF0sIE9wdGltaXplckNvbnN0cnVjdG9ycywgXCJtb21lbnR1bVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwicm1zcHJvcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwiYWRhbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwiYWRhZGVsdGFcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdPcHRpbWl6ZXJzJywgbmFtZXNwYWNlOiAndHJhaW4nIH0pXG4gICAgXSwgT3B0aW1pemVyQ29uc3RydWN0b3JzLCBcImFkYW1heFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwiYWRhZ3JhZFwiLCBudWxsKTtcbiAgICByZXR1cm4gT3B0aW1pemVyQ29uc3RydWN0b3JzO1xufSgpKTtcbmV4cG9ydHMuT3B0aW1pemVyQ29uc3RydWN0b3JzID0gT3B0aW1pemVyQ29uc3RydWN0b3JzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW1pemVyX2NvbnN0cnVjdG9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2VyaWFsaXphdGlvblwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBSTVNQcm9wT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUk1TUHJvcE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSTVNQcm9wT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgZGVjYXksIG1vbWVudHVtLCBlcHNpbG9uLCBjZW50ZXJlZCkge1xuICAgICAgICBpZiAoZGVjYXkgPT09IHZvaWQgMCkgeyBkZWNheSA9IDAuOTsgfVxuICAgICAgICBpZiAobW9tZW50dW0gPT09IHZvaWQgMCkgeyBtb21lbnR1bSA9IDAuMDsgfVxuICAgICAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS04OyB9XG4gICAgICAgIGlmIChjZW50ZXJlZCA9PT0gdm9pZCAwKSB7IGNlbnRlcmVkID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5kZWNheSA9IGRlY2F5O1xuICAgICAgICBfdGhpcy5tb21lbnR1bSA9IG1vbWVudHVtO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gZXBzaWxvbjtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyA9IHt9O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyA9IHt9O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1vbWVudHMgPSB7fTtcbiAgICAgICAgX3RoaXMuYyA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihsZWFybmluZ1JhdGUpKTtcbiAgICAgICAgX3RoaXMuZXBzaWxvblNjYWxhciA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihlcHNpbG9uKSk7XG4gICAgICAgIF90aGlzLmRlY2F5U2NhbGFyID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKGRlY2F5KSk7XG4gICAgICAgIF90aGlzLm1vbWVudHVtU2NhbGFyID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKG1vbWVudHVtKSk7XG4gICAgICAgIF90aGlzLm9uZU1pbnVzRGVjYXkgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSAtIGRlY2F5KSk7XG4gICAgICAgIF90aGlzLmNlbnRlcmVkID0gY2VudGVyZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUk1TUHJvcE9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAodmFyaWFibGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgaWYgKHRoaXNfMS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3ZhcmlhYmxlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGVfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1t2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNfMS5hY2N1bXVsYXRlZE1lYW5HcmFkc1t2YXJpYWJsZU5hbWVdID09IG51bGwgJiYgdGhpc18xLmNlbnRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZV8yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkc1t2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlXzIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNfMS5hY2N1bXVsYXRlZE1vbWVudHNbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZV8zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1vbWVudHNbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZV8zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZE1lYW5TcXVhcmUgPSB0aGlzXzEuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGVkTWVhbkdyYWQgPSB0aGlzXzEuYWNjdW11bGF0ZWRNZWFuR3JhZHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZE1vbWVudHMgPSB0aGlzXzEuYWNjdW11bGF0ZWRNb21lbnRzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSB2YXJpYWJsZUdyYWRpZW50c1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZE1lYW5TcXVhcmUgPSBfdGhpcy5kZWNheVNjYWxhci5tdWwoYWNjdW11bGF0ZWRNZWFuU3F1YXJlKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKF90aGlzLm9uZU1pbnVzRGVjYXkubXVsKGdyYWRpZW50LnNxdWFyZSgpKSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNlbnRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZE1lYW5HcmFkID0gX3RoaXMuZGVjYXlTY2FsYXIubXVsKGFjY3VtdWxhdGVkTWVhbkdyYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkKF90aGlzLm9uZU1pbnVzRGVjYXkubXVsKGdyYWRpZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZE1vbWVudHMgPSBfdGhpcy5tb21lbnR1bVNjYWxhci5tdWwoYWNjdW11bGF0ZWRNb21lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5jLm11bChncmFkaWVudCkuZGl2KG5ld0FjY3VtdWxhdGVkTWVhblNxdWFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1YihuZXdBY2N1bXVsYXRlZE1lYW5HcmFkLnNxdWFyZSgpLmFkZChfdGhpcy5lcHNpbG9uU2NhbGFyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcXJ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRlZE1lYW5TcXVhcmUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkc1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRlZE1lYW5HcmFkKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNb21lbnRzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkTW9tZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlLnN1YihuZXdBY2N1bXVsYXRlZE1vbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hc3NpZ24obmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0FjY3VtdWxhdGVkTWVhblNxdWFyZV8xID0gX3RoaXMuZGVjYXlTY2FsYXIubXVsKGFjY3VtdWxhdGVkTWVhblNxdWFyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQoX3RoaXMub25lTWludXNEZWNheS5tdWwoZ3JhZGllbnQuc3F1YXJlKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0FjY3VtdWxhdGVkTW9tZW50cyA9IF90aGlzLm1vbWVudHVtU2NhbGFyLm11bChhY2N1bXVsYXRlZE1vbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkKF90aGlzLmMubXVsKGdyYWRpZW50KS5kaXYobmV3QWNjdW11bGF0ZWRNZWFuU3F1YXJlXzEuYWRkKF90aGlzLmVwc2lsb25TY2FsYXIpLnNxcnQoKSkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkTWVhblNxdWFyZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNb21lbnRzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkTW9tZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlLnN1YihuZXdBY2N1bXVsYXRlZE1vbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hc3NpZ24obmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgdmFyaWFibGVOYW1lIGluIHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgICAgICBfbG9vcF8xKHZhcmlhYmxlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZXBzaWxvblNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZGVjYXlTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm1vbWVudHVtU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVNaW51c0RlY2F5LmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyAhPSBudWxsICYmIHRoaXMuY2VudGVyZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzW25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZE1vbWVudHNbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUk1TUHJvcE9wdGltaXplci5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVhcm5pbmdSYXRlOiB0aGlzLmxlYXJuaW5nUmF0ZSxcbiAgICAgICAgICAgIGRlY2F5OiB0aGlzLmRlY2F5LFxuICAgICAgICAgICAgbW9tZW50dW06IHRoaXMubW9tZW50dW0sXG4gICAgICAgICAgICBlcHNpbG9uOiB0aGlzLmVwc2lsb24sXG4gICAgICAgICAgICBjZW50ZXJlZDogdGhpcy5jZW50ZXJlZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUk1TUHJvcE9wdGltaXplci5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xzKGNvbmZpZy5sZWFybmluZ1JhdGUsIGNvbmZpZy5kZWNheSwgY29uZmlnLm1vbWVudHVtLCBjb25maWcuZXBzaWxvbiwgY29uZmlnLmNlbnRlcmVkKTtcbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIuY2xhc3NOYW1lID0gJ1JNU1Byb3BPcHRpbWl6ZXInO1xuICAgIHJldHVybiBSTVNQcm9wT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuUk1TUHJvcE9wdGltaXplciA9IFJNU1Byb3BPcHRpbWl6ZXI7XG5zZXJpYWxpemF0aW9uXzEuU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihSTVNQcm9wT3B0aW1pemVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJtc3Byb3Bfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zZXJpYWxpemF0aW9uXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIFNHRE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNHRE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTR0RPcHRpbWl6ZXIobGVhcm5pbmdSYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuc2V0TGVhcm5pbmdSYXRlKGxlYXJuaW5nUmF0ZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdmFyTmFtZXMgPSBPYmplY3Qua2V5cyh2YXJpYWJsZUdyYWRpZW50cyk7XG4gICAgICAgIHZhck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHZhcmlhYmxlR3JhZGllbnRzW3Zhck5hbWVdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyTmFtZV07XG4gICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuYy5tdWwoZ3JhZGllbnQpLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNHRE9wdGltaXplci5wcm90b3R5cGUuc2V0TGVhcm5pbmdSYXRlID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSkge1xuICAgICAgICB0aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgaWYgKHRoaXMuYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYyA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigtbGVhcm5pbmdSYXRlKSk7XG4gICAgfTtcbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgbGVhcm5pbmdSYXRlOiB0aGlzLmxlYXJuaW5nUmF0ZSB9O1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnLmxlYXJuaW5nUmF0ZSk7XG4gICAgfTtcbiAgICBTR0RPcHRpbWl6ZXIuY2xhc3NOYW1lID0gJ1NHRE9wdGltaXplcic7XG4gICAgcmV0dXJuIFNHRE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLlNHRE9wdGltaXplciA9IFNHRE9wdGltaXplcjtcbnNlcmlhbGl6YXRpb25fMS5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFNHRE9wdGltaXplcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZ2Rfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIFByb2ZpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9maWxlcihiYWNrZW5kVGltZXIsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmJhY2tlbmRUaW1lciA9IGJhY2tlbmRUaW1lcjtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIGlmIChsb2dnZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJvZmlsZXIucHJvdG90eXBlLnByb2ZpbGVLZXJuZWwgPSBmdW5jdGlvbiAobmFtZSwgZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaG9sZFJlc3VsdFdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGYoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRpbWVyID0gdGhpcy5iYWNrZW5kVGltZXIudGltZShob2xkUmVzdWx0V3JhcHBlckZuKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZGF0YVN5bmMoKTtcbiAgICAgICAgdXRpbC5jaGVja0Zvck5hTih2YWxzLCByZXN1bHQuZHR5cGUsIG5hbWUpO1xuICAgICAgICB0aW1lci50aGVuKGZ1bmN0aW9uICh0aW1pbmcpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2dLZXJuZWxQcm9maWxlKG5hbWUsIHJlc3VsdCwgdmFscywgdGltaW5nLmtlcm5lbE1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvZmlsZXI7XG59KCkpO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xudmFyIExvZ2dlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyKCkge1xuICAgIH1cbiAgICBMb2dnZXIucHJvdG90eXBlLmxvZ0tlcm5lbFByb2ZpbGUgPSBmdW5jdGlvbiAobmFtZSwgcmVzdWx0LCB2YWxzLCB0aW1lTXMpIHtcbiAgICAgICAgdmFyIHRpbWUgPSB1dGlsLnJpZ2h0UGFkKHRpbWVNcyArIFwibXNcIiwgOSk7XG4gICAgICAgIHZhciBwYWRkZWROYW1lID0gdXRpbC5yaWdodFBhZChuYW1lLCAyNSk7XG4gICAgICAgIHZhciByYW5rID0gcmVzdWx0LnJhbms7XG4gICAgICAgIHZhciBzaXplID0gcmVzdWx0LnNpemU7XG4gICAgICAgIHZhciBzaGFwZSA9IHV0aWwucmlnaHRQYWQocmVzdWx0LnNoYXBlLnRvU3RyaW5nKCksIDE0KTtcbiAgICAgICAgY29uc29sZS5sb2coXCIlY1wiICsgcGFkZGVkTmFtZSArIFwiXFx0JWNcIiArIHRpbWUgKyBcIlxcdCVjXCIgKyByYW5rICsgXCJEIFwiICsgc2hhcGUgKyBcIlxcdCVjXCIgKyBzaXplLCAnZm9udC13ZWlnaHQ6Ym9sZCcsICdjb2xvcjpyZWQnLCAnY29sb3I6Ymx1ZScsICdjb2xvcjogb3JhbmdlJyk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpKTtcbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvZmlsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU2VyaWFsaXphYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJpYWxpemFibGUoKSB7XG4gICAgfVxuICAgIFNlcmlhbGl6YWJsZS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgLmNsYXNzTmFtZTtcbiAgICB9O1xuICAgIFNlcmlhbGl6YWJsZS5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNscywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xzKGNvbmZpZyk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VyaWFsaXphYmxlO1xufSgpKTtcbmV4cG9ydHMuU2VyaWFsaXphYmxlID0gU2VyaWFsaXphYmxlO1xudmFyIFNlcmlhbGl6YXRpb25NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6YXRpb25NYXAoKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lTWFwID0ge307XG4gICAgfVxuICAgIFNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoU2VyaWFsaXphdGlvbk1hcC5pbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBTZXJpYWxpemF0aW9uTWFwLmluc3RhbmNlID0gbmV3IFNlcmlhbGl6YXRpb25NYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2VyaWFsaXphdGlvbk1hcC5pbnN0YW5jZTtcbiAgICB9O1xuICAgIFNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIgPSBmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIHRoaXMuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwW2Nscy5jbGFzc05hbWVdID0gW2NscywgY2xzLmZyb21Db25maWddO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcmlhbGl6YXRpb25NYXA7XG59KCkpO1xuZXhwb3J0cy5TZXJpYWxpemF0aW9uTWFwID0gU2VyaWFsaXphdGlvbk1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6YXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5mdW5jdGlvbiBnZXRGaWx0ZXJlZE5vZGVzWFRvWSh0YXBlLCB4cywgeSkge1xuICAgIHZhciB0ZW5zb3JzRnJvbVggPSB7fTtcbiAgICB2YXIgbm9kZXNGcm9tWCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGVuc29yc0Zyb21YW3hzW2ldLmlkXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRhcGVbaV07XG4gICAgICAgIHZhciBub2RlSW5wdXRzID0gbm9kZS5pbnB1dHM7XG4gICAgICAgIGZvciAodmFyIGlucHV0TmFtZSBpbiBub2RlSW5wdXRzKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBub2RlSW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgICAgICB2YXIgYW55SW5wdXRGcm9tWCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB4cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0ZW5zb3JzRnJvbVhbaW5wdXQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvcnNGcm9tWFtub2RlLm91dHB1dC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhbnlJbnB1dEZyb21YID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNGcm9tWFtub2RlLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbnlJbnB1dEZyb21YKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRlbnNvcnNMZWFkVG9ZID0ge307XG4gICAgdGVuc29yc0xlYWRUb1lbeS5pZF0gPSB0cnVlO1xuICAgIHZhciBub2Rlc1RvWSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSB0YXBlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBub2RlID0gdGFwZVtpXTtcbiAgICAgICAgdmFyIG5vZGVJbnB1dHMgPSBub2RlLmlucHV0cztcbiAgICAgICAgdmFyIG91dHB1dHMgPSBbXTtcbiAgICAgICAgb3V0cHV0cy5wdXNoKG5vZGUub3V0cHV0KTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRwdXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGVuc29yc0xlYWRUb1lbb3V0cHV0c1tqXS5pZF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbnB1dE5hbWUgaW4gbm9kZUlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzTGVhZFRvWVtub2RlSW5wdXRzW2lucHV0TmFtZV0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1lbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZmlsdGVyZWRUYXBlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGFwZVtpXTtcbiAgICAgICAgaWYgKG5vZGVzRnJvbVhbbm9kZS5pZF0gJiYgbm9kZXNUb1lbbm9kZS5pZF0pIHtcbiAgICAgICAgICAgIHZhciBwcnVuZWRJbnB1dHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0TmFtZSBpbiBub2RlLmlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlSW5wdXQgPSBub2RlLmlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0ZW5zb3JzRnJvbVhbbm9kZUlucHV0LmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBwcnVuZWRJbnB1dHNbaW5wdXROYW1lXSA9IG5vZGVJbnB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJ1bmVkTm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUpO1xuICAgICAgICAgICAgcHJ1bmVkTm9kZS5pbnB1dHMgPSBwcnVuZWRJbnB1dHM7XG4gICAgICAgICAgICBwcnVuZWROb2RlLm91dHB1dCA9IG5vZGUub3V0cHV0O1xuICAgICAgICAgICAgZmlsdGVyZWRUYXBlLnB1c2gocHJ1bmVkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkVGFwZTtcbn1cbmV4cG9ydHMuZ2V0RmlsdGVyZWROb2Rlc1hUb1kgPSBnZXRGaWx0ZXJlZE5vZGVzWFRvWTtcbmZ1bmN0aW9uIGJhY2twcm9wYWdhdGVHcmFkaWVudHModGVuc29yQWNjdW11bGF0ZWRHcmFkaWVudE1hcCwgZmlsdGVyZWRUYXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IGZpbHRlcmVkVGFwZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbm9kZSA9IGZpbHRlcmVkVGFwZVtpXTtcbiAgICAgICAgdmFyIGR5ID0gdGVuc29yQWNjdW11bGF0ZWRHcmFkaWVudE1hcFtub2RlLm91dHB1dC5pZF07XG4gICAgICAgIGlmIChub2RlLmdyYWRpZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50OiBncmFkaWVudCBmdW5jdGlvbiBub3QgZm91bmQgXCIgK1xuICAgICAgICAgICAgICAgIChcImZvciBcIiArIG5vZGUubmFtZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0R3JhZGllbnRzID0gbm9kZS5ncmFkaWVudChkeSk7XG4gICAgICAgIGZvciAodmFyIGlucHV0TmFtZSBpbiBub2RlLmlucHV0cykge1xuICAgICAgICAgICAgaWYgKCEoaW5wdXROYW1lIGluIGlucHV0R3JhZGllbnRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBiYWNrcHJvcCB0aHJvdWdoIGlucHV0IFwiICsgaW5wdXROYW1lICsgXCIuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiQXZhaWxhYmxlIGdyYWRpZW50cyBmb3VuZDogXCIgKyBPYmplY3Qua2V5cyhpbnB1dEdyYWRpZW50cykgKyBcIi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGR4ID0gaW5wdXRHcmFkaWVudHNbaW5wdXROYW1lXSgpO1xuICAgICAgICAgICAgdmFyIHggPSBub2RlLmlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGR4LnNoYXBlLCB4LnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIGdyYWRpZW50IGZvciBvcCBcIiArIG5vZGUubmFtZSArIFwiLiBUaGUgZ3JhZGllbnQgb2YgaW5wdXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCInXCIgKyBpbnB1dE5hbWUgKyBcIicgaGFzIHNoYXBlICdcIiArIGR4LnNoYXBlICsgXCInLCB3aGljaCBkb2VzIG5vdCBtYXRjaCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoXCJ0aGUgc2hhcGUgb2YgdGhlIGlucHV0ICdcIiArIHguc2hhcGUgKyBcIidcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF0gPSBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjdXJHcmFkaWVudCA9IHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF07XG4gICAgICAgICAgICAgICAgdGVuc29yQWNjdW11bGF0ZWRHcmFkaWVudE1hcFt4LmlkXSA9IGN1ckdyYWRpZW50LmFkZChkeCk7XG4gICAgICAgICAgICAgICAgY3VyR3JhZGllbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5iYWNrcHJvcGFnYXRlR3JhZGllbnRzID0gYmFja3Byb3BhZ2F0ZUdyYWRpZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi9vcHMvb3BzXCIpO1xudmFyIHRlbnNvcl91dGlsID0gcmVxdWlyZShcIi4vdGVuc29yX3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVGVuc29yQnVmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW5zb3JCdWZmZXIoc2hhcGUsIGR0eXBlLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5kdHlwZSA9IGR0eXBlO1xuICAgICAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KG4gPT09IHNpemUsIFwiTGVuZ3RoIG9mIHZhbHVlcyAnXCIgKyBuICsgXCInIGRvZXMgbm90IG1hdGNoIHRoZSBzaXplIFwiICtcbiAgICAgICAgICAgICAgICAoXCJpbmZlcnJlZCBieSB0aGUgc2hhcGUgJ1wiICsgc2l6ZSArIFwiJ1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMudmFsdWVzID1cbiAgICAgICAgICAgIHZhbHVlcyB8fCB1dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoZHR5cGUsIHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSkpO1xuICAgICAgICB0aGlzLnN0cmlkZXMgPSBjb21wdXRlU3RyaWRlcyhzaGFwZSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgfVxuICAgIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9jcyA9IFswXTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChsb2NzLmxlbmd0aCA9PT0gdGhpcy5yYW5rLCBcIlRoZSBudW1iZXIgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgKFwiICsgbG9jcy5sZW5ndGggKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCB0aGUgcmFuayAoXCIgKyB0aGlzLnJhbmsgKyBcIilcIikpO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxvY1RvSW5kZXgobG9jcyk7XG4gICAgICAgIHRoaXMudmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIH07XG4gICAgVGVuc29yQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2NzID0gWzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGxvY3NbbG9jcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdO1xuICAgIH07XG4gICAgVGVuc29yQnVmZmVyLnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jc1swXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgVGVuc29yQnVmZmVyLnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NzID0gbmV3IEFycmF5KHRoaXMuc2hhcGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgbG9jc1tpXSA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZXNbaV0pO1xuICAgICAgICAgICAgaW5kZXggLT0gbG9jc1tpXSAqIHRoaXMuc3RyaWRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBsb2NzW2xvY3MubGVuZ3RoIC0gMV0gPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIGxvY3M7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVuc29yQnVmZmVyLnByb3RvdHlwZSwgXCJyYW5rXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUudG9UZW5zb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBUZW5zb3IubWFrZSh0aGlzLnNoYXBlLCB7IHZhbHVlczogdGhpcy52YWx1ZXMgfSwgdGhpcy5kdHlwZSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgVGVuc29yQnVmZmVyLnByb3RvdHlwZSwgXCJzZXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUsIFwiZ2V0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBUZW5zb3JCdWZmZXIucHJvdG90eXBlLCBcInRvVGVuc29yXCIsIG51bGwpO1xuICAgIFRlbnNvckJ1ZmZlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvckJ1ZmZlcik7XG4gICAgcmV0dXJuIFRlbnNvckJ1ZmZlcjtcbn0oKSk7XG5leHBvcnRzLlRlbnNvckJ1ZmZlciA9IFRlbnNvckJ1ZmZlcjtcbnZhciBUZW5zb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbnNvcihzaGFwZSwgZHR5cGUsIHZhbHVlcywgZGF0YUlkKSB7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZEludGVybmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSB2YWx1ZXMubGVuZ3RoLCBcIkNvbnN0cnVjdGluZyB0ZW5zb3Igb2Ygc2hhcGUgKFwiICsgdGhpcy5zaXplICsgXCIpIHNob3VsZCBtYXRjaCB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIChcImxlbmd0aCBvZiB2YWx1ZXMgKFwiICsgdmFsdWVzLmxlbmd0aCArIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gICAgICAgIHRoaXMuc3RyaWRlcyA9IGNvbXB1dGVTdHJpZGVzKHNoYXBlKTtcbiAgICAgICAgdGhpcy5kYXRhSWQgPSBkYXRhSWQgIT0gbnVsbCA/IGRhdGFJZCA6IHt9O1xuICAgICAgICB0aGlzLmlkID0gVGVuc29yXzEubmV4dElkKys7XG4gICAgICAgIHRoaXMucmFua1R5cGUgPSAodGhpcy5yYW5rIDwgNSA/IHRoaXMucmFuay50b1N0cmluZygpIDogJ2hpZ2hlcicpO1xuICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJUZW5zb3IodGhpcyk7XG4gICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLndyaXRlKHRoaXMuZGF0YUlkLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRlbnNvcl8xID0gVGVuc29yO1xuICAgIFRlbnNvci5tYWtlID0gZnVuY3Rpb24gKHNoYXBlLCBkYXRhLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcl8xKHNoYXBlLCBkdHlwZSwgZGF0YS52YWx1ZXMsIGRhdGEuZGF0YUlkKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMxRCgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hc1NjYWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSAxLCAnVGhlIGFycmF5IG11c3QgaGF2ZSBvbmx5IDEgZWxlbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbXSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFzMUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3RoaXMuc2l6ZV0pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hczJEID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbcm93cywgY29sdW1uc10pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hczNEID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3Jvd3MsIGNvbHVtbnMsIGRlcHRoXSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFzNEQgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucywgZGVwdGgsIGRlcHRoMikge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtyb3dzLCBjb2x1bW5zLCBkZXB0aCwgZGVwdGgyXSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFzVHlwZSA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNhc3QodGhpcywgZHR5cGUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbnNvci5wcm90b3R5cGUsIFwicmFua1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxvY3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChsb2NzLmxlbmd0aCA9PT0gdGhpcy5yYW5rLCAnTnVtYmVyIG9mIGNvb3JkaW5hdGVzIGluIGdldCgpIG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIHRlbnNvcicpO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAobG9jcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvY3MgPSBbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTeW5jKClbaW5kZXhdO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5idWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvcHMuYnVmZmVyKHRoaXMuc2hhcGUsIHRoaXMuZHR5cGUsIHRoaXMuZGF0YVN5bmMoKSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlYWQodGhpcy5kYXRhSWQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZGF0YVN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVhZFN5bmModGhpcy5kYXRhSWQpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmRpc3Bvc2VUZW5zb3IodGhpcyk7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZEludGVybmFsID0gdHJ1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW5zb3IucHJvdG90eXBlLCBcImlzRGlzcG9zZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGVuc29yLnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciBpcyBkaXNwb3NlZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNUeXBlKCdmbG9hdDMyJyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1R5cGUoJ2ludDMyJyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRvQm9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNUeXBlKCdib29sJyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKHZlcmJvc2UpIHtcbiAgICAgICAgaWYgKHZlcmJvc2UgPT09IHZvaWQgMCkgeyB2ZXJib3NlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIG9wcy5wcmludCh0aGlzLCB2ZXJib3NlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uIChuZXdTaGFwZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnJlc2hhcGUodGhpcywgbmV3U2hhcGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5yZXNoYXBlQXMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKHguc2hhcGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5leHBhbmREaW1zID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICByZXR1cm4gb3BzLmV4cGFuZERpbXModGhpcywgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmN1bXN1bSA9IGZ1bmN0aW9uIChheGlzLCBleGNsdXNpdmUsIHJldmVyc2UpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICBpZiAoZXhjbHVzaXZlID09PSB2b2lkIDApIHsgZXhjbHVzaXZlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHJldmVyc2UgPT09IHZvaWQgMCkgeyByZXZlcnNlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIG9wcy5jdW1zdW0odGhpcywgYXhpcywgZXhjbHVzaXZlLCByZXZlcnNlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3F1ZWV6ZSA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc3F1ZWV6ZSh0aGlzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY2xvbmUodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHZlcmJvc2UpIHtcbiAgICAgICAgaWYgKHZlcmJvc2UgPT09IHZvaWQgMCkgeyB2ZXJib3NlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl91dGlsLnRlbnNvclRvU3RyaW5nKHRoaXMsIHZlcmJvc2UpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50aWxlID0gZnVuY3Rpb24gKHJlcHMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy50aWxlKHRoaXMsIHJlcHMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5nYXRoZXIgPSBmdW5jdGlvbiAoaW5kaWNlcywgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZ2F0aGVyKHRoaXMsIGluZGljZXMsIGF4aXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tYXRNdWwgPSBmdW5jdGlvbiAoYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQikge1xuICAgICAgICBpZiAodHJhbnNwb3NlQSA9PT0gdm9pZCAwKSB7IHRyYW5zcG9zZUEgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodHJhbnNwb3NlQiA9PT0gdm9pZCAwKSB7IHRyYW5zcG9zZUIgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1hdE11bCh0aGlzLCBiLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5kb3QodGhpcywgYik7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm5vcm0gPSBmdW5jdGlvbiAob3JkLCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAob3JkID09PSB2b2lkIDApIHsgb3JkID0gJ2V1Y2xpZGVhbic7IH1cbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubm9ybSh0aGlzLCBvcmQsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zbGljZSh0aGlzLCBiZWdpbiwgc2l6ZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnJldmVyc2UodGhpcywgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb25jYXQoW3RoaXMsIHhdLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3RhY2sgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHJldHVybiBvcHMuc3RhY2soW3RoaXMsIHhdLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudW5zdGFjayA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG9wcy51bnN0YWNrKHRoaXMsIGF4aXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiAocGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnN0YW50VmFsdWUgPT09IHZvaWQgMCkgeyBjb25zdGFudFZhbHVlID0gMDsgfVxuICAgICAgICByZXR1cm4gb3BzLnBhZCh0aGlzLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIChtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYmF0Y2hOb3JtYWxpemF0aW9uKHRoaXMsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2dTdW1FeHAgPSBmdW5jdGlvbiAoYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9nU3VtRXhwKHRoaXMsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnN1bSh0aGlzLCBheGlzLCBrZWVwRGltcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1lYW4gPSBmdW5jdGlvbiAoYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWVhbih0aGlzLCBheGlzLCBrZWVwRGltcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5taW4odGhpcywgYXhpcywga2VlcERpbXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWF4KHRoaXMsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXJnTWluID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFyZ01pbih0aGlzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXJnTWF4ID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFyZ01heCh0aGlzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNhc3QodGhpcywgZHR5cGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFkZCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYWRkU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hZGRTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc3ViKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zdWJTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnN1YlN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKGV4cCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnBvdyh0aGlzLCBleHApO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5wb3dTdHJpY3QgPSBmdW5jdGlvbiAoZXhwKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMucG93U3RyaWN0KHRoaXMsIGV4cCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubXVsKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tdWxTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm11bFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5kaXYodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmZsb29yRGl2ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5mbG9vckRpdih0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZGl2U3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5kaXZTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1pbmltdW0gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1pbmltdW0odGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1pbmltdW1TdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1pbmltdW1TdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1heGltdW0gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1heGltdW0odGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1heGltdW1TdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1heGltdW1TdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubW9kKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tb2RTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1vZFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNxdWFyZWREaWZmZXJlbmNlKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZVN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc3F1YXJlZERpZmZlcmVuY2VTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIChwZXJtKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMudHJhbnNwb3NlKHRoaXMsIHBlcm0pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5ub3RFcXVhbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubm90RXF1YWwodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm5vdEVxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ub3RFcXVhbFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubGVzcyh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubGVzc1N0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubGVzc1N0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmVxdWFsKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5lcXVhbFN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZXF1YWxTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxlc3NFcXVhbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubGVzc0VxdWFsKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sZXNzRXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxlc3NFcXVhbFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZ3JlYXRlciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZ3JlYXRlcih0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZ3JlYXRlclN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZ3JlYXRlclN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZ3JlYXRlckVxdWFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ncmVhdGVyRXF1YWwodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmdyZWF0ZXJFcXVhbFN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZ3JlYXRlckVxdWFsU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2dpY2FsQW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sb2dpY2FsQW5kKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2dpY2FsT3IgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxvZ2ljYWxPcih0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9naWNhbE5vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sb2dpY2FsTm90KHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2dpY2FsWG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sb2dpY2FsWG9yKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy53aGVyZShjb25kaXRpb24sIHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubmVnKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNlaWwodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmZsb29yKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNpZ24odGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5leHAodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmV4cG0xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmV4cG0xKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9nKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2cxcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sb2cxcCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zcXJ0KHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5yc3FydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5yc3FydCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNxdWFyZSh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucmVjaXByb2NhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5yZWNpcHJvY2FsKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYWJzKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jbGlwQnlWYWx1ZSA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNsaXBCeVZhbHVlKHRoaXMsIG1pbiwgbWF4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucmVsdSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5yZWx1KHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5lbHUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZWx1KHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zZWx1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNlbHUodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxlYWt5UmVsdSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMjsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxlYWt5UmVsdSh0aGlzLCBhbHBoYSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnByZWx1ID0gZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMucHJlbHUodGhpcywgYWxwaGEpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zaWdtb2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNpZ21vaWQodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxvZ1NpZ21vaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9nU2lnbW9pZCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc29mdHBsdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc29mdHBsdXModGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zaW4odGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb3ModGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy50YW4odGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFzaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYXNpbih0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYWNvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hY29zKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hdGFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmF0YW4odGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNpbmggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc2luaCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY29zaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb3NoKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50YW5oID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnRhbmgodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFzaW5oID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFzaW5oKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hY29zaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hY29zaCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXRhbmggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYXRhbmgodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmVyZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5lcmYodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnJvdW5kKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4wOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc3RlcCh0aGlzLCBhbHBoYSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNvZnRtYXggPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIGlmIChkaW0gPT09IHZvaWQgMCkgeyBkaW0gPSAtMTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNvZnRtYXgodGhpcywgZGltKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIgPSBmdW5jdGlvbiAobmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIGlmIChhbGlnbkNvcm5lcnMgPT09IHZvaWQgMCkgeyBhbGlnbkNvcm5lcnMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmltYWdlLnJlc2l6ZUJpbGluZWFyKHRoaXMsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvciA9IGZ1bmN0aW9uIChuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgaWYgKGFsaWduQ29ybmVycyA9PT0gdm9pZCAwKSB7IGFsaWduQ29ybmVycyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuaW1hZ2UucmVzaXplTmVhcmVzdE5laWdoYm9yKHRoaXMsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNvbnYxZCA9IGZ1bmN0aW9uIChmaWx0ZXIsIHN0cmlkZSwgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbiwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0YUZvcm1hdCA9ICdOV0MnOyB9XG4gICAgICAgIGlmIChkaWxhdGlvbiA9PT0gdm9pZCAwKSB7IGRpbGF0aW9uID0gMTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNvbnYxZCh0aGlzLCBmaWx0ZXIsIHN0cmlkZSwgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbiwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY29udjJkID0gZnVuY3Rpb24gKGZpbHRlciwgc3RyaWRlcywgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGFGb3JtYXQgPSAnTkhXQyc7IH1cbiAgICAgICAgaWYgKGRpbGF0aW9ucyA9PT0gdm9pZCAwKSB7IGRpbGF0aW9ucyA9IFsxLCAxXTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNvbnYyZCh0aGlzLCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGF0YUZvcm1hdCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2UgPSBmdW5jdGlvbiAoZmlsdGVyLCBvdXRwdXRTaGFwZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb252MmRUcmFuc3Bvc2UodGhpcywgZmlsdGVyLCBvdXRwdXRTaGFwZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQgPSBmdW5jdGlvbiAoZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRhdGFGb3JtYXQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0YUZvcm1hdCA9ICdOSFdDJzsgfVxuICAgICAgICBpZiAoZGlsYXRpb25zID09PSB2b2lkIDApIHsgZGlsYXRpb25zID0gWzEsIDFdOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZGVwdGh3aXNlQ29udjJkKHRoaXMsIGZpbHRlciwgc3RyaWRlcywgcGFkLCBkYXRhRm9ybWF0LCBkaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmF2Z1Bvb2wgPSBmdW5jdGlvbiAoZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hdmdQb29sKHRoaXMsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uIChmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1heFBvb2wodGhpcywgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIChyYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhKSB7XG4gICAgICAgIGlmIChyYWRpdXMgPT09IHZvaWQgMCkgeyByYWRpdXMgPSA1OyB9XG4gICAgICAgIGlmIChiaWFzID09PSB2b2lkIDApIHsgYmlhcyA9IDE7IH1cbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAxOyB9XG4gICAgICAgIGlmIChiZXRhID09PSB2b2lkIDApIHsgYmV0YSA9IDAuNTsgfVxuICAgICAgICByZXR1cm4gb3BzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uKHRoaXMsIHJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uICh0cmFpbmFibGUsIG5hbWUsIGR0eXBlKSB7XG4gICAgICAgIGlmICh0cmFpbmFibGUgPT09IHZvaWQgMCkgeyB0cmFpbmFibGUgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBWYXJpYWJsZS52YXJpYWJsZSh0aGlzLCB0cmFpbmFibGUsIG5hbWUsIGR0eXBlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtID0gZnVuY3Rpb24gKHNlZ21lbnRJZHMsIG51bVNlZ21lbnRzLCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy51bnNvcnRlZFNlZ21lbnRTdW0odGhpcywgc2VnbWVudElkcywgbnVtU2VnbWVudHMsIGF4aXMpO1xuICAgIH07XG4gICAgVGVuc29yLm5leHRJZCA9IDA7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJmbGF0dGVuXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiYXNTY2FsYXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJhczFEXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiYXMyRFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImFzM0RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJhczREXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiYXNUeXBlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiYnVmZmVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiZGF0YVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImRhdGFTeW5jXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiZGlzcG9zZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcInRvRmxvYXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJ0b0ludFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcInRvQm9vbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcInByaW50XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwicmVzaGFwZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcInJlc2hhcGVBc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImV4cGFuZERpbXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJjdW1zdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJzcXVlZXplXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiY2xvbmVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCBudWxsKTtcbiAgICBUZW5zb3IgPSBUZW5zb3JfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvcik7XG4gICAgcmV0dXJuIFRlbnNvcjtcbiAgICB2YXIgVGVuc29yXzE7XG59KCkpO1xuZXhwb3J0cy5UZW5zb3IgPSBUZW5zb3I7XG52YXIgVmFyaWFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYXJpYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWYXJpYWJsZShpbml0aWFsVmFsdWUsIHRyYWluYWJsZSwgbmFtZSkge1xuICAgICAgICBpZiAodHJhaW5hYmxlID09PSB2b2lkIDApIHsgdHJhaW5hYmxlID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsVmFsdWUuc2hhcGUsIGluaXRpYWxWYWx1ZS5kdHlwZSwgbnVsbCwgaW5pdGlhbFZhbHVlLmRhdGFJZCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHJhaW5hYmxlID0gdHJhaW5hYmxlO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKF90aGlzLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IFZhcmlhYmxlXzEubmV4dFZhcklkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBWYXJpYWJsZV8xLm5leHRWYXJJZCsrO1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlclZhcmlhYmxlKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWYXJpYWJsZV8xID0gVmFyaWFibGU7XG4gICAgVmFyaWFibGUudmFyaWFibGUgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlLCB0cmFpbmFibGUsIG5hbWUsIGR0eXBlKSB7XG4gICAgICAgIGlmICh0cmFpbmFibGUgPT09IHZvaWQgMCkgeyB0cmFpbmFibGUgPSB0cnVlOyB9XG4gICAgICAgIGlmIChkdHlwZSAhPSBudWxsICYmIGR0eXBlICE9PSBpbml0aWFsVmFsdWUuZHR5cGUpIHtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZS5hc1R5cGUoZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVfMShpbml0aWFsVmFsdWUsIHRyYWluYWJsZSwgbmFtZSk7XG4gICAgfTtcbiAgICBWYXJpYWJsZS5wcm90b3R5cGUuYXNzaWduID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZS5kdHlwZSAhPT0gdGhpcy5kdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHR5cGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIgKyBuZXdWYWx1ZS5kdHlwZSArIFwiKSBhbmQgXCIgK1xuICAgICAgICAgICAgICAgIChcInByZXZpb3VzIHZhbHVlIChcIiArIHRoaXMuZHR5cGUgKyBcIikgbXVzdCBtYXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKG5ld1ZhbHVlLnNoYXBlLCB0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIgKyBuZXdWYWx1ZS5zaGFwZSArIFwiKSBhbmQgXCIgK1xuICAgICAgICAgICAgICAgIChcInByZXZpb3VzIHZhbHVlIChcIiArIHRoaXMuc2hhcGUgKyBcIikgbXVzdCBtYXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmRpc3Bvc2VUZW5zb3IodGhpcyk7XG4gICAgICAgIHRoaXMuZGF0YUlkID0gbmV3VmFsdWUuZGF0YUlkO1xuICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJUZW5zb3IodGhpcyk7XG4gICAgfTtcbiAgICBWYXJpYWJsZS5uZXh0VmFySWQgPSAwO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFZhcmlhYmxlLnByb3RvdHlwZSwgXCJhc3NpZ25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIFZhcmlhYmxlLCBcInZhcmlhYmxlXCIsIG51bGwpO1xuICAgIFZhcmlhYmxlID0gVmFyaWFibGVfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFZhcmlhYmxlKTtcbiAgICByZXR1cm4gVmFyaWFibGU7XG4gICAgdmFyIFZhcmlhYmxlXzE7XG59KFRlbnNvcikpO1xuZXhwb3J0cy5WYXJpYWJsZSA9IFZhcmlhYmxlO1xudmFyIHZhcmlhYmxlID0gVmFyaWFibGUudmFyaWFibGU7XG5leHBvcnRzLnZhcmlhYmxlID0gdmFyaWFibGU7XG5mdW5jdGlvbiBjb21wdXRlU3RyaWRlcyhzaGFwZSkge1xuICAgIHZhciByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKHZhciBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIHNoYXBlW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlkZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgRk9STUFUX0xJTUlUX05VTV9WQUxTID0gMjA7XG52YXIgRk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFMgPSAzO1xudmFyIEZPUk1BVF9OVU1fU0lHX0RJR0lUUyA9IDc7XG5mdW5jdGlvbiB0ZW5zb3JUb1N0cmluZyh0LCB2ZXJib3NlKSB7XG4gICAgdmFyIHZhbHMgPSB0LmRhdGFTeW5jKCk7XG4gICAgdmFyIHBhZFBlckNvbCA9IGNvbXB1dGVNYXhTaXplUGVyQ29sdW1uKHQpO1xuICAgIHZhciB2YWxzTGluZXMgPSBzdWJUZW5zb3JUb1N0cmluZyh2YWxzLCB0LnNoYXBlLCB0LnN0cmlkZXMsIHBhZFBlckNvbCk7XG4gICAgdmFyIGxpbmVzID0gWydUZW5zb3InXTtcbiAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICBsaW5lcy5wdXNoKFwiICBkdHlwZTogXCIgKyB0LmR0eXBlKTtcbiAgICAgICAgbGluZXMucHVzaChcIiAgcmFuazogXCIgKyB0LnJhbmspO1xuICAgICAgICBsaW5lcy5wdXNoKFwiICBzaGFwZTogW1wiICsgdC5zaGFwZSArIFwiXVwiKTtcbiAgICAgICAgbGluZXMucHVzaChcIiAgdmFsdWVzOlwiKTtcbiAgICB9XG4gICAgbGluZXMucHVzaCh2YWxzTGluZXMubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiAnICAgICcgKyBsOyB9KS5qb2luKCdcXG4nKSk7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuZXhwb3J0cy50ZW5zb3JUb1N0cmluZyA9IHRlbnNvclRvU3RyaW5nO1xuZnVuY3Rpb24gY29tcHV0ZU1heFNpemVQZXJDb2x1bW4odCkge1xuICAgIHZhciB2YWxzID0gdC5kYXRhU3luYygpO1xuICAgIHZhciBuID0gdC5zaXplO1xuICAgIHZhciBudW1Db2xzID0gdC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcGFkUGVyQ29sID0gbmV3IEFycmF5KG51bUNvbHMpLmZpbGwoMCk7XG4gICAgaWYgKHQucmFuayA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbiAvIG51bUNvbHM7IHJvdysrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcm93ICogbnVtQ29scztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ29sczsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGFkUGVyQ29sW2pdID1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocGFkUGVyQ29sW2pdLCB2YWxUb1N0cmluZyh2YWxzW29mZnNldCArIGpdLCAwKS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWRQZXJDb2w7XG59XG5mdW5jdGlvbiB2YWxUb1N0cmluZyh2YWwsIHBhZCkge1xuICAgIHJldHVybiB1dGlsLnJpZ2h0UGFkKHBhcnNlRmxvYXQodmFsLnRvRml4ZWQoRk9STUFUX05VTV9TSUdfRElHSVRTKSkudG9TdHJpbmcoKSwgcGFkKTtcbn1cbmZ1bmN0aW9uIHN1YlRlbnNvclRvU3RyaW5nKHZhbHMsIHNoYXBlLCBzdHJpZGVzLCBwYWRQZXJDb2wsIGlzTGFzdCkge1xuICAgIGlmIChpc0xhc3QgPT09IHZvaWQgMCkgeyBpc0xhc3QgPSB0cnVlOyB9XG4gICAgdmFyIHNpemUgPSBzaGFwZVswXTtcbiAgICB2YXIgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW3ZhbHNbMF0udG9TdHJpbmcoKV07XG4gICAgfVxuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIGlmIChzaXplID4gRk9STUFUX0xJTUlUX05VTV9WQUxTKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RWYWxzID0gQXJyYXkuZnJvbSh2YWxzLnN1YmFycmF5KDAsIEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTKSk7XG4gICAgICAgICAgICB2YXIgbGFzdFZhbHMgPSBBcnJheS5mcm9tKHZhbHMuc3ViYXJyYXkoc2l6ZSAtIEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTLCBzaXplKSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdbJyArIGZpcnN0VmFscy5tYXAoZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuIHZhbFRvU3RyaW5nKHgsIHBhZFBlckNvbFtpXSk7IH0pLmpvaW4oJywgJykgK1xuICAgICAgICAgICAgICAgICAgICAnLCAuLi4sICcgK1xuICAgICAgICAgICAgICAgICAgICBsYXN0VmFsc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCwgaSkgeyByZXR1cm4gdmFsVG9TdHJpbmcoeCwgcGFkUGVyQ29sW3NpemUgLSBGT1JNQVRfTlVNX0ZJUlNUX0xBU1RfVkFMUyArIGldKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICAgICAgJ10nXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnWycgK1xuICAgICAgICAgICAgICAgIEFycmF5LmZyb20odmFscykubWFwKGZ1bmN0aW9uICh4LCBpKSB7IHJldHVybiB2YWxUb1N0cmluZyh4LCBwYWRQZXJDb2xbaV0pOyB9KS5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICAnXSdcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHN1YnNoYXBlID0gc2hhcGUuc2xpY2UoMSk7XG4gICAgdmFyIHN1YnN0cmlkZXMgPSBzdHJpZGVzLnNsaWNlKDEpO1xuICAgIHZhciBzdHJpZGUgPSBzdHJpZGVzWzBdO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIGlmIChzaXplID4gRk9STUFUX0xJTUlUX05VTV9WQUxTKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaSAqIHN0cmlkZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIHN0cmlkZTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIHN1YlRlbnNvclRvU3RyaW5nKHZhbHMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHN1YnNoYXBlLCBzdWJzdHJpZGVzLCBwYWRQZXJDb2wsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMucHVzaCgnLi4uJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gRk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFM7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGkgKiBzdHJpZGU7XG4gICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBzdHJpZGU7XG4gICAgICAgICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCBzdWJUZW5zb3JUb1N0cmluZyh2YWxzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLCBzdWJzaGFwZSwgc3Vic3RyaWRlcywgcGFkUGVyQ29sLCBpID09PSBzaXplIC0gMSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaSAqIHN0cmlkZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIHN0cmlkZTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIHN1YlRlbnNvclRvU3RyaW5nKHZhbHMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHN1YnNoYXBlLCBzdWJzdHJpZGVzLCBwYWRQZXJDb2wsIGkgPT09IHNpemUgLSAxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNlcCA9IHJhbmsgPT09IDIgPyAnLCcgOiAnJztcbiAgICBsaW5lc1swXSA9ICdbJyArIGxpbmVzWzBdICsgc2VwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gJyAnICsgbGluZXNbaV0gKyBzZXA7XG4gICAgfVxuICAgIHZhciBuZXdMaW5lU2VwID0gJyxcXG4nO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgICAgIG5ld0xpbmVTZXAgKz0gJ1xcbic7XG4gICAgfVxuICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID1cbiAgICAgICAgJyAnICsgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gKyAnXScgKyAoaXNMYXN0ID8gJycgOiBuZXdMaW5lU2VwKTtcbiAgICByZXR1cm4gbGluZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3JfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMuV0VCR0xfRU5WUyA9IHtcbiAgICAnQkFDS0VORCc6ICd0ZXN0LXdlYmdsJ1xufTtcbmV4cG9ydHMuQ1BVX0VOVlMgPSB7XG4gICAgJ0JBQ0tFTkQnOiAndGVzdC1jcHUnXG59O1xuZXhwb3J0cy5BTExfRU5WUyA9IHt9O1xuZXhwb3J0cy5URVNUX0VQU0lMT04gPSAxZS0zO1xuZnVuY3Rpb24gZXhwZWN0QXJyYXlzQ2xvc2UoYWN0dWFsLCBleHBlY3RlZCwgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IGV4cG9ydHMuVEVTVF9FUFNJTE9OOyB9XG4gICAgaWYgKCEoYWN0dWFsIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSAmJiAhKGV4cGVjdGVkIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSkge1xuICAgICAgICB2YXIgYVR5cGUgPSBhY3R1YWwuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdmFyIGJUeXBlID0gZXhwZWN0ZWQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgdHlwZSBhY3R1YWw6IFwiICsgYVR5cGUgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgKFwidnMgZXhwZWN0ZWQ6IFwiICsgYlR5cGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgaWYgKGFjdHVhbC5kdHlwZSAhPT0gZXhwZWN0ZWQuZHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUgYWN0dWFsOiBcIiArIGFjdHVhbC5kdHlwZSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ2cyBleHBlY3RlZDogXCIgKyBleHBlY3RlZC5kdHlwZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbC5zaGFwZSwgZXhwZWN0ZWQuc2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCBzaGFwZSBhY3R1YWw6IFwiICsgYWN0dWFsLnNoYXBlICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgIChcInZzIGV4cGVjdGVkOiBcIiArIGV4cGVjdGVkLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYWN0dWFsVmFsdWVzO1xuICAgIHZhciBleHBlY3RlZFZhbHVlcztcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgIGFjdHVhbFZhbHVlcyA9IGFjdHVhbC5kYXRhU3luYygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWN0dWFsVmFsdWVzID0gYWN0dWFsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgZXhwZWN0ZWRWYWx1ZXMgPSBleHBlY3RlZC5kYXRhU3luYygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhwZWN0ZWRWYWx1ZXMgPSBleHBlY3RlZDtcbiAgICB9XG4gICAgaWYgKGFjdHVhbFZhbHVlcy5sZW5ndGggIT09IGV4cGVjdGVkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyBhY3R1YWw6IFwiICsgYWN0dWFsVmFsdWVzLmxlbmd0aCArIFwiIHZzIFwiICtcbiAgICAgICAgICAgIChcImV4cGVjdGVkOiBcIiArIGV4cGVjdGVkVmFsdWVzLmxlbmd0aCArIFwiLlxcblwiKSArXG4gICAgICAgICAgICAoXCJBY3R1YWw6ICAgXCIgKyBhY3R1YWxWYWx1ZXMgKyBcIi5cXG5cIikgK1xuICAgICAgICAgICAgKFwiRXhwZWN0ZWQ6IFwiICsgZXhwZWN0ZWRWYWx1ZXMgKyBcIi5cIikpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBhID0gYWN0dWFsVmFsdWVzW2ldO1xuICAgICAgICB2YXIgZSA9IGV4cGVjdGVkVmFsdWVzW2ldO1xuICAgICAgICBpZiAoIWFyZUNsb3NlKGEsIE51bWJlcihlKSwgZXBzaWxvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5cyBkaWZmZXI6IGFjdHVhbFtcIiArIGkgKyBcIl0gPSBcIiArIGEgKyBcIiwgZXhwZWN0ZWRbXCIgKyBpICsgXCJdID0gXCIgKyBlICsgXCIuXFxuXCIgK1xuICAgICAgICAgICAgICAgIChcIkFjdHVhbDogICBcIiArIGFjdHVhbFZhbHVlcyArIFwiLlxcblwiKSArXG4gICAgICAgICAgICAgICAgKFwiRXhwZWN0ZWQ6IFwiICsgZXhwZWN0ZWRWYWx1ZXMgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5leHBlY3RBcnJheXNDbG9zZSA9IGV4cGVjdEFycmF5c0Nsb3NlO1xuZnVuY3Rpb24gZXhwZWN0UHJvbWlzZVRvRmFpbChmbiwgZG9uZSkge1xuICAgIGZuKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBkb25lLmZhaWwoKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9uZSgpOyB9KTtcbn1cbmV4cG9ydHMuZXhwZWN0UHJvbWlzZVRvRmFpbCA9IGV4cGVjdFByb21pc2VUb0ZhaWw7XG5mdW5jdGlvbiBleHBlY3RBcnJheXNFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGV4cGVjdEFycmF5c0Nsb3NlKGFjdHVhbCwgZXhwZWN0ZWQsIDApO1xufVxuZXhwb3J0cy5leHBlY3RBcnJheXNFcXVhbCA9IGV4cGVjdEFycmF5c0VxdWFsO1xuZnVuY3Rpb24gZXhwZWN0TnVtYmVyc0Nsb3NlKGEsIGUsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSBleHBvcnRzLlRFU1RfRVBTSUxPTjsgfVxuICAgIGlmICghYXJlQ2xvc2UoYSwgZSwgZXBzaWxvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVycyBkaWZmZXI6IGFjdHVhbCA9PT0gXCIgKyBhICsgXCIsIGV4cGVjdGVkID09PSBcIiArIGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0TnVtYmVyc0Nsb3NlID0gZXhwZWN0TnVtYmVyc0Nsb3NlO1xuZnVuY3Rpb24gYXJlQ2xvc2UoYSwgZSwgZXBzaWxvbikge1xuICAgIGlmIChpc05hTihhKSAmJiBpc05hTihlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGEpIHx8IGlzTmFOKGUpIHx8IE1hdGguYWJzKGEgLSBlKSA+IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGV4cGVjdFZhbHVlc0luUmFuZ2UoYWN0dWFsLCBsb3csIGhpZ2gpIHtcbiAgICB2YXIgYWN0dWFsVmFscztcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgIGFjdHVhbFZhbHMgPSBhY3R1YWwuZGF0YVN5bmMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjdHVhbFZhbHMgPSBhY3R1YWw7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsVmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYWN0dWFsVmFsc1tpXSA8IGxvdyB8fCBhY3R1YWxWYWxzW2ldID4gaGlnaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlOlwiICsgYWN0dWFsVmFsc1tpXSArIFwiIGxvdzogXCIgKyBsb3cgKyBcIiwgaGlnaDogXCIgKyBoaWdoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0VmFsdWVzSW5SYW5nZSA9IGV4cGVjdFZhbHVlc0luUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXN0X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVHJhY2tpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYWNraW5nKCkge1xuICAgIH1cbiAgICBUcmFja2luZy50aWR5ID0gZnVuY3Rpb24gKG5hbWVPckZuLCBmbiwgZ3JhZE1vZGUpIHtcbiAgICAgICAgaWYgKGdyYWRNb2RlID09PSB2b2lkIDApIHsgZ3JhZE1vZGUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgIGlmIChmbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVPckZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIHRpZHkoKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gPSBuYW1lT3JGbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZU9yRm4gIT09ICdzdHJpbmcnICYmICEobmFtZU9yRm4gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYXJndW1lbnQgJyArXG4gICAgICAgICAgICAgICAgICAgICd0byB0aWR5KCkgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIDJuZCBhcmd1bWVudCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvIHRpZHkoKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3JGbjtcbiAgICAgICAgfVxuICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuc3RhcnRTY29wZShuYW1lLCBncmFkTW9kZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmbigpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHJldHVybiBhIFByb21pc2UgaW5zaWRlIG9mIHRpZHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmVuZFNjb3BlKHJlc3VsdCwgZ3JhZE1vZGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgVHJhY2tpbmcuZGlzcG9zZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgdmFyIHRlbnNvcnMgPSB1dGlsXzEuZ2V0VGVuc29yc0luQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHRlbnNvcnMuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7IHJldHVybiB0ZW5zb3IuZGlzcG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIFRyYWNraW5nLmtlZXAgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUua2VlcChyZXN1bHQpO1xuICAgIH07XG4gICAgVHJhY2tpbmcudGltZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUudGltZShmKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnUGVyZm9ybWFuY2UnLCBzdWJoZWFkaW5nOiAnTWVtb3J5JyB9KVxuICAgIF0sIFRyYWNraW5nLCBcInRpZHlcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdQZXJmb3JtYW5jZScsIHN1YmhlYWRpbmc6ICdNZW1vcnknIH0pXG4gICAgXSwgVHJhY2tpbmcsIFwiZGlzcG9zZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1BlcmZvcm1hbmNlJywgc3ViaGVhZGluZzogJ01lbW9yeScgfSlcbiAgICBdLCBUcmFja2luZywgXCJrZWVwXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnUGVyZm9ybWFuY2UnLCBzdWJoZWFkaW5nOiAnVGltaW5nJyB9KVxuICAgIF0sIFRyYWNraW5nLCBcInRpbWVcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFRyYWNraW5nO1xufSgpKTtcbmV4cG9ydHMuVHJhY2tpbmcgPSBUcmFja2luZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNraW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFkYWRlbHRhX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9hZGFkZWx0YV9vcHRpbWl6ZXJcIik7XG52YXIgYWRhZ3JhZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXJcIik7XG52YXIgYWRhbV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvYWRhbV9vcHRpbWl6ZXJcIik7XG52YXIgYWRhbWF4X29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9hZGFtYXhfb3B0aW1pemVyXCIpO1xudmFyIG1vbWVudHVtX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9tb21lbnR1bV9vcHRpbWl6ZXJcIik7XG52YXIgb3B0aW1pemVyX2NvbnN0cnVjdG9yc18xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9vcHRpbWl6ZXJfY29uc3RydWN0b3JzXCIpO1xudmFyIHJtc3Byb3Bfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL3Jtc3Byb3Bfb3B0aW1pemVyXCIpO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvc2dkX29wdGltaXplclwiKTtcblttb21lbnR1bV9vcHRpbWl6ZXJfMS5Nb21lbnR1bU9wdGltaXplciwgc2dkX29wdGltaXplcl8xLlNHRE9wdGltaXplciwgYWRhZGVsdGFfb3B0aW1pemVyXzEuQWRhZGVsdGFPcHRpbWl6ZXIsIGFkYWdyYWRfb3B0aW1pemVyXzEuQWRhZ3JhZE9wdGltaXplcixcbiAgICBybXNwcm9wX29wdGltaXplcl8xLlJNU1Byb3BPcHRpbWl6ZXIsIGFkYW1heF9vcHRpbWl6ZXJfMS5BZGFtYXhPcHRpbWl6ZXIsIGFkYW1fb3B0aW1pemVyXzEuQWRhbU9wdGltaXplcl07XG5leHBvcnRzLnRyYWluID0ge1xuICAgIHNnZDogb3B0aW1pemVyX2NvbnN0cnVjdG9yc18xLk9wdGltaXplckNvbnN0cnVjdG9ycy5zZ2QsXG4gICAgbW9tZW50dW06IG9wdGltaXplcl9jb25zdHJ1Y3RvcnNfMS5PcHRpbWl6ZXJDb25zdHJ1Y3RvcnMubW9tZW50dW0sXG4gICAgYWRhZGVsdGE6IG9wdGltaXplcl9jb25zdHJ1Y3RvcnNfMS5PcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhZGVsdGEsXG4gICAgYWRhZ3JhZDogb3B0aW1pemVyX2NvbnN0cnVjdG9yc18xLk9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFncmFkLFxuICAgIHJtc3Byb3A6IG9wdGltaXplcl9jb25zdHJ1Y3RvcnNfMS5PcHRpbWl6ZXJDb25zdHJ1Y3RvcnMucm1zcHJvcCxcbiAgICBhZGFtYXg6IG9wdGltaXplcl9jb25zdHJ1Y3RvcnNfMS5PcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhbWF4LFxuICAgIGFkYW06IG9wdGltaXplcl9jb25zdHJ1Y3RvcnNfMS5PcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhbVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERUeXBlO1xuKGZ1bmN0aW9uIChEVHlwZSkge1xuICAgIERUeXBlW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIERUeXBlW1wiaW50MzJcIl0gPSBcImludDMyXCI7XG4gICAgRFR5cGVbXCJib29sXCJdID0gXCJib29sXCI7XG59KShEVHlwZSA9IGV4cG9ydHMuRFR5cGUgfHwgKGV4cG9ydHMuRFR5cGUgPSB7fSkpO1xudmFyIFJhbms7XG4oZnVuY3Rpb24gKFJhbmspIHtcbiAgICBSYW5rW1wiUjBcIl0gPSBcIlIwXCI7XG4gICAgUmFua1tcIlIxXCJdID0gXCJSMVwiO1xuICAgIFJhbmtbXCJSMlwiXSA9IFwiUjJcIjtcbiAgICBSYW5rW1wiUjNcIl0gPSBcIlIzXCI7XG4gICAgUmFua1tcIlI0XCJdID0gXCJSNFwiO1xuICAgIFJhbmtbXCJSNVwiXSA9IFwiUjVcIjtcbn0pKFJhbmsgPSBleHBvcnRzLlJhbmsgfHwgKGV4cG9ydHMuUmFuayA9IHt9KSk7XG52YXIgVXBjYXN0SW50MzJBbmRNYXA7XG4oZnVuY3Rpb24gKFVwY2FzdEludDMyQW5kTWFwKSB7XG4gICAgVXBjYXN0SW50MzJBbmRNYXBbXCJmbG9hdDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgVXBjYXN0SW50MzJBbmRNYXBbXCJpbnQzMlwiXSA9IFwiaW50MzJcIjtcbiAgICBVcGNhc3RJbnQzMkFuZE1hcFtcImJvb2xcIl0gPSBcImludDMyXCI7XG59KShVcGNhc3RJbnQzMkFuZE1hcCB8fCAoVXBjYXN0SW50MzJBbmRNYXAgPSB7fSkpO1xudmFyIFVwY2FzdEJvb2xBbmRNYXA7XG4oZnVuY3Rpb24gKFVwY2FzdEJvb2xBbmRNYXApIHtcbiAgICBVcGNhc3RCb29sQW5kTWFwW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFVwY2FzdEJvb2xBbmRNYXBbXCJpbnQzMlwiXSA9IFwiaW50MzJcIjtcbiAgICBVcGNhc3RCb29sQW5kTWFwW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xufSkoVXBjYXN0Qm9vbEFuZE1hcCB8fCAoVXBjYXN0Qm9vbEFuZE1hcCA9IHt9KSk7XG52YXIgVXBjYXN0RmxvYXQzMkFuZE1hcDtcbihmdW5jdGlvbiAoVXBjYXN0RmxvYXQzMkFuZE1hcCkge1xuICAgIFVwY2FzdEZsb2F0MzJBbmRNYXBbXCJmbG9hdDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgVXBjYXN0RmxvYXQzMkFuZE1hcFtcImludDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgVXBjYXN0RmxvYXQzMkFuZE1hcFtcImJvb2xcIl0gPSBcImZsb2F0MzJcIjtcbn0pKFVwY2FzdEZsb2F0MzJBbmRNYXAgfHwgKFVwY2FzdEZsb2F0MzJBbmRNYXAgPSB7fSkpO1xudmFyIHVwY2FzdFR5cGVNYXAgPSB7XG4gICAgZmxvYXQzMjogVXBjYXN0RmxvYXQzMkFuZE1hcCxcbiAgICBpbnQzMjogVXBjYXN0SW50MzJBbmRNYXAsXG4gICAgYm9vbDogVXBjYXN0Qm9vbEFuZE1hcFxufTtcbmZ1bmN0aW9uIHVwY2FzdFR5cGUodHlwZUEsIHR5cGVCKSB7XG4gICAgcmV0dXJuIHVwY2FzdFR5cGVNYXBbdHlwZUFdW3R5cGVCXTtcbn1cbmV4cG9ydHMudXBjYXN0VHlwZSA9IHVwY2FzdFR5cGU7XG5mdW5jdGlvbiBzdW1PdXRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gdXBjYXN0VHlwZSh0eXBlLCAnaW50MzInKTtcbn1cbmV4cG9ydHMuc3VtT3V0VHlwZSA9IHN1bU91dFR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuL3RlbnNvclwiKTtcbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50SXNUZW5zb3IoeCwgYXJnTmFtZSwgZnVuY3Rpb25OYW1lKSB7XG4gICAgYXNzZXJ0KHggaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsIFwiQXJndW1lbnQgJ1wiICsgYXJnTmFtZSArIFwiJyBwYXNzZWQgdG8gJ1wiICsgZnVuY3Rpb25OYW1lICsgXCInIG11c3QgYmUgYSBUZW5zb3IsIFwiICtcbiAgICAgICAgKFwiYnV0IGdvdCBcIiArIHR5cGVvZiB4ICsgXCIuXCIpKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnMoYXJncywgZnVuY3Rpb25OYW1lKSB7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoYXJnTmFtZSkge1xuICAgICAgICB2YXIgYXJnID0gYXJnc1thcmdOYW1lXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudElzVGVuc29yKHQsIGFyZ05hbWUgKyBcIltcIiArIGkgKyBcIl1cIiwgZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnRJc1RlbnNvcihhcmcsIGFyZ05hbWUsIGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGFyZ05hbWUgaW4gYXJncykge1xuICAgICAgICBfbG9vcF8xKGFyZ05hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0QXJndW1lbnRzQXJlVGVuc29ycyA9IGFzc2VydEFyZ3VtZW50c0FyZVRlbnNvcnM7XG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gICAgdmFyIGNvdW50ZXIgPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIHRlbXAgPSAwO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgIGluZGV4ID0gKE1hdGgucmFuZG9tKCkgKiBjb3VudGVyKSB8IDA7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgdGVtcCA9IGFycmF5W2NvdW50ZXJdO1xuICAgICAgICBhcnJheVtjb3VudGVyXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdGVtcDtcbiAgICB9XG59XG5leHBvcnRzLnNodWZmbGUgPSBzaHVmZmxlO1xuZnVuY3Rpb24gY2xhbXAobWluLCB4LCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih4LCBtYXgpKTtcbn1cbmV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcbmZ1bmN0aW9uIHJhbmRVbmlmb3JtKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChiIC0gYSkgKyBhO1xufVxuZXhwb3J0cy5yYW5kVW5pZm9ybSA9IHJhbmRVbmlmb3JtO1xuZnVuY3Rpb24gZGlzdFNxdWFyZWQoYSwgYikge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlmZiA9IE51bWJlcihhW2ldKSAtIE51bWJlcihiW2ldKTtcbiAgICAgICAgcmVzdWx0ICs9IGRpZmYgKiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kaXN0U3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuZnVuY3Rpb24gYXNzZXJ0KGV4cHIsIG1zZykge1xuICAgIGlmICghZXhwcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmZ1bmN0aW9uIGFzc2VydFNoYXBlc01hdGNoKHNoYXBlQSwgc2hhcGVCLCBlcnJvck1lc3NhZ2VQcmVmaXgpIHtcbiAgICBpZiAoZXJyb3JNZXNzYWdlUHJlZml4ID09PSB2b2lkIDApIHsgZXJyb3JNZXNzYWdlUHJlZml4ID0gJyc7IH1cbiAgICBhc3NlcnQoYXJyYXlzRXF1YWwoc2hhcGVBLCBzaGFwZUIpLCBlcnJvck1lc3NhZ2VQcmVmaXggKyAoXCIgU2hhcGVzIFwiICsgc2hhcGVBICsgXCIgYW5kIFwiICsgc2hhcGVCICsgXCIgbXVzdCBtYXRjaFwiKSk7XG59XG5leHBvcnRzLmFzc2VydFNoYXBlc01hdGNoID0gYXNzZXJ0U2hhcGVzTWF0Y2g7XG5mdW5jdGlvbiBhc3NlcnRUeXBlc01hdGNoKGEsIGIpIHtcbiAgICBhc3NlcnQoYS5kdHlwZSA9PT0gYi5kdHlwZSwgXCIgVGhlIGR0eXBlcyBvZiB0aGUgZmlyc3QoXCIgKyBhLmR0eXBlICsgXCIpIGFuZFwiICtcbiAgICAgICAgKFwiIHNlY29uZChcIiArIGIuZHR5cGUgKyBcIikgaW5wdXQgbXVzdCBtYXRjaFwiKSk7XG59XG5leHBvcnRzLmFzc2VydFR5cGVzTWF0Y2ggPSBhc3NlcnRUeXBlc01hdGNoO1xuZnVuY3Rpb24gZmxhdHRlbihhcnIsIHJldCkge1xuICAgIGlmIChyZXQgPT09IHZvaWQgMCkgeyByZXQgPSBbXTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGZsYXR0ZW4oYXJyW2ldLCByZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXQucHVzaChhcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbmZ1bmN0aW9uIGluZmVyU2hhcGUodmFsKSB7XG4gICAgaWYgKGlzVHlwZWRBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiBbdmFsLmxlbmd0aF07XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHNoYXBlID0gW107XG4gICAgd2hpbGUgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHNoYXBlLnB1c2godmFsLmxlbmd0aCk7XG4gICAgICAgIHZhbCA9IHZhbFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlO1xufVxuZXhwb3J0cy5pbmZlclNoYXBlID0gaW5mZXJTaGFwZTtcbmZ1bmN0aW9uIHNpemVGcm9tU2hhcGUoc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IHNoYXBlWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2l6ZSAqPSBzaGFwZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5leHBvcnRzLnNpemVGcm9tU2hhcGUgPSBzaXplRnJvbVNoYXBlO1xuZnVuY3Rpb24gaXNTY2FsYXJTaGFwZShzaGFwZSkge1xuICAgIHJldHVybiBzaGFwZS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzU2NhbGFyU2hhcGUgPSBpc1NjYWxhclNoYXBlO1xuZnVuY3Rpb24gYXJyYXlzRXF1YWwobjEsIG4yKSB7XG4gICAgaWYgKG4xLmxlbmd0aCAhPT0gbjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobjFbaV0gIT09IG4yW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmFycmF5c0VxdWFsID0gYXJyYXlzRXF1YWw7XG5mdW5jdGlvbiBpc0ludChhKSB7XG4gICAgcmV0dXJuIGEgJSAxID09PSAwO1xufVxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgaWYgKE1hdGgudGFuaCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnRhbmgoeCk7XG4gICAgfVxuICAgIGlmICh4ID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlMnggPSBNYXRoLmV4cCgyICogeCk7XG4gICAgICAgIHJldHVybiAoZTJ4IC0gMSkgLyAoZTJ4ICsgMSk7XG4gICAgfVxufVxuZXhwb3J0cy50YW5oID0gdGFuaDtcbmZ1bmN0aW9uIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSkge1xuICAgIGZvciAodmFyIGEgPSBNYXRoLmZsb29yKE1hdGguc3FydChzaXplKSk7IGEgPiAxOyAtLWEpIHtcbiAgICAgICAgaWYgKHNpemUgJSBhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2EsIHNpemUgLyBhXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWzEsIHNpemVdO1xufVxuZXhwb3J0cy5zaXplVG9TcXVhcmlzaFNoYXBlID0gc2l6ZVRvU3F1YXJpc2hTaGFwZTtcbmZ1bmN0aW9uIGNyZWF0ZVNodWZmbGVkSW5kaWNlcyhuKSB7XG4gICAgdmFyIHNodWZmbGVkSW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzaHVmZmxlZEluZGljZXNbaV0gPSBpO1xuICAgIH1cbiAgICBzaHVmZmxlKHNodWZmbGVkSW5kaWNlcyk7XG4gICAgcmV0dXJuIHNodWZmbGVkSW5kaWNlcztcbn1cbmV4cG9ydHMuY3JlYXRlU2h1ZmZsZWRJbmRpY2VzID0gY3JlYXRlU2h1ZmZsZWRJbmRpY2VzO1xuZnVuY3Rpb24gcmlnaHRQYWQoYSwgc2l6ZSkge1xuICAgIGlmIChzaXplIDw9IGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICByZXR1cm4gYSArICcgJy5yZXBlYXQoc2l6ZSAtIGEubGVuZ3RoKTtcbn1cbmV4cG9ydHMucmlnaHRQYWQgPSByaWdodFBhZDtcbmZ1bmN0aW9uIHJlcGVhdGVkVHJ5KGNoZWNrRm4sIGRlbGF5Rm4sIG1heENvdW50ZXIpIHtcbiAgICBpZiAoZGVsYXlGbiA9PT0gdm9pZCAwKSB7IGRlbGF5Rm4gPSBmdW5jdGlvbiAoY291bnRlcikgeyByZXR1cm4gMDsgfTsgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB0cnlDb3VudCA9IDA7XG4gICAgICAgIHZhciB0cnlGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjaGVja0ZuKCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5Q291bnQrKztcbiAgICAgICAgICAgIHZhciBuZXh0QmFja29mZiA9IGRlbGF5Rm4odHJ5Q291bnQpO1xuICAgICAgICAgICAgaWYgKG1heENvdW50ZXIgIT0gbnVsbCAmJiB0cnlDb3VudCA+PSBtYXhDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCh0cnlGbiwgbmV4dEJhY2tvZmYpO1xuICAgICAgICB9O1xuICAgICAgICB0cnlGbigpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZXBlYXRlZFRyeSA9IHJlcGVhdGVkVHJ5O1xuZnVuY3Rpb24gZ2V0UXVlcnlQYXJhbXMocXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgcXVlcnlTdHJpbmcucmVwbGFjZSgvWz8mXShbXj0/Jl0rKSg/Oj0oW14mXSopKT8vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHRbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUGFyYW0ocGFyYW1zLCB0WzBdLCB0WzFdKTtcbiAgICAgICAgcmV0dXJuIHQuam9pbignPScpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5leHBvcnRzLmdldFF1ZXJ5UGFyYW1zID0gZ2V0UXVlcnlQYXJhbXM7XG5mdW5jdGlvbiBkZWNvZGVQYXJhbShwYXJhbXMsIG5hbWUsIHZhbHVlKSB7XG4gICAgcGFyYW1zW2RlY29kZVVSSUNvbXBvbmVudChuYW1lKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUgfHwgJycpO1xufVxuZnVuY3Rpb24gaW5mZXJGcm9tSW1wbGljaXRTaGFwZShzaGFwZSwgc2l6ZSkge1xuICAgIHZhciBzaGFwZVByb2QgPSAxO1xuICAgIHZhciBpbXBsaWNpdElkeCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNoYXBlW2ldID4gMCkge1xuICAgICAgICAgICAgc2hhcGVQcm9kICo9IHNoYXBlW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlW2ldID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGltcGxpY2l0SWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBvbmx5IGhhdmUgMSBpbXBsaWNpdCBzaXplLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkZvdW5kIC0gMSBhdCBkaW0gXCIgKyBpbXBsaWNpdElkeCArIFwiIGFuZCBkaW0gXCIgKyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbXBsaWNpdElkeCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hhcGVbaV0gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG5vdCBiZSA8PSAwLiBGb3VuZCBcIiArIHNoYXBlW2ldICsgXCIgYXQgZGltIFwiICsgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGltcGxpY2l0SWR4ID09PSAtMSkge1xuICAgICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSAhPT0gc2hhcGVQcm9kKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNpemUoXCIgKyBzaXplICsgXCIpIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgXCIgKyBzaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cbiAgICBpZiAoc2l6ZSAlIHNoYXBlUHJvZCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBpbXBsaWNpdCBzaGFwZSBjYW4ndCBiZSBhIGZyYWN0aW9uYWwgbnVtYmVyLiBcIiArXG4gICAgICAgICAgICAoXCJHb3QgXCIgKyBzaXplICsgXCIgLyBcIiArIHNoYXBlUHJvZCkpO1xuICAgIH1cbiAgICB2YXIgbmV3U2hhcGUgPSBzaGFwZS5zbGljZSgpO1xuICAgIG5ld1NoYXBlW2ltcGxpY2l0SWR4XSA9IHNpemUgLyBzaGFwZVByb2Q7XG4gICAgcmV0dXJuIG5ld1NoYXBlO1xufVxuZXhwb3J0cy5pbmZlckZyb21JbXBsaWNpdFNoYXBlID0gaW5mZXJGcm9tSW1wbGljaXRTaGFwZTtcbmZ1bmN0aW9uIHNxdWVlemVTaGFwZShzaGFwZSwgYXhpcykge1xuICAgIHZhciBuZXdTaGFwZSA9IFtdO1xuICAgIHZhciBrZXB0RGltcyA9IFtdO1xuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChheGlzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChheGlzW2pdID09PSBpICYmIHNoYXBlW2ldID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHNxdWVlemUgYXhpcyBcIiArIGkgKyBcIiBzaW5jZSBpdHMgZGltICdcIiArIHNoYXBlW2ldICsgXCInIGlzIG5vdCAxXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChheGlzW2pdID09IG51bGwgfHwgYXhpc1tqXSA+IGkpICYmIHNoYXBlW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICAgICAgICAgICAga2VwdERpbXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChheGlzW2pdIDw9IGkpIHtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlW2ldID4gMSkge1xuICAgICAgICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICAgICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5ld1NoYXBlOiBuZXdTaGFwZSwga2VwdERpbXM6IGtlcHREaW1zIH07XG59XG5leHBvcnRzLnNxdWVlemVTaGFwZSA9IHNxdWVlemVTaGFwZTtcbmZ1bmN0aW9uIGdldFR5cGVkQXJyYXlGcm9tRFR5cGUoZHR5cGUsIHNpemUpIHtcbiAgICB2YXIgdmFsdWVzID0gbnVsbDtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5leHBvcnRzLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUgPSBnZXRUeXBlZEFycmF5RnJvbURUeXBlO1xuZnVuY3Rpb24gaXNUZW5zb3JJbkxpc3QodGVuc29yLCB0ZW5zb3JMaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW5zb3JMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZW5zb3JMaXN0W2ldLmlkID09PSB0ZW5zb3IuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNUZW5zb3JJbkxpc3QgPSBpc1RlbnNvckluTGlzdDtcbmZ1bmN0aW9uIGNoZWNrRm9yTmFOKHZhbHMsIGR0eXBlLCBuYW1lKSB7XG4gICAgaWYgKGR0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHNbaV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSByZXN1bHQgb2YgdGhlICdcIiArIG5hbWUgKyBcIicgaGFzIE5hTnMuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0Zvck5hTiA9IGNoZWNrRm9yTmFOO1xuZnVuY3Rpb24gZmxhdHRlbk5hbWVBcnJheU1hcChuYW1lQXJyYXlNYXAsIGtleXMpIHtcbiAgICB2YXIgeHMgPSBbXTtcbiAgICBpZiAobmFtZUFycmF5TWFwIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgIHhzLnB1c2gobmFtZUFycmF5TWFwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB4TWFwID0gbmFtZUFycmF5TWFwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHhzLnB1c2goeE1hcFtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhzO1xufVxuZXhwb3J0cy5mbGF0dGVuTmFtZUFycmF5TWFwID0gZmxhdHRlbk5hbWVBcnJheU1hcDtcbmZ1bmN0aW9uIHVuZmxhdHRlblRvTmFtZUFycmF5TWFwKGtleXMsIGZsYXRBcnJheXMpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IGZsYXRBcnJheXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1bmZsYXR0ZW4gVGVuc29yW10sIGtleXMgYW5kIGFycmF5cyBhcmUgbm90IG9mIHNhbWUgbGVuZ3RoLlwiKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRba2V5c1tpXV0gPSBmbGF0QXJyYXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy51bmZsYXR0ZW5Ub05hbWVBcnJheU1hcCA9IHVuZmxhdHRlblRvTmFtZUFycmF5TWFwO1xuZnVuY3Rpb24gaGFzRW5jb2RpbmdMb3NzKG9sZFR5cGUsIG5ld1R5cGUpIHtcbiAgICBpZiAobmV3VHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5ld1R5cGUgPT09ICdpbnQzMicgJiYgb2xkVHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5ld1R5cGUgPT09ICdib29sJyAmJiBvbGRUeXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaGFzRW5jb2RpbmdMb3NzID0gaGFzRW5jb2RpbmdMb3NzO1xuZnVuY3Rpb24gY29weVR5cGVkQXJyYXkoYXJyYXksIGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09IG51bGwgfHwgZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgdmFyIGJvb2wgPSBuZXcgVWludDhBcnJheShhcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2wubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLnJvdW5kKGFycmF5W2ldKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGJvb2xbaV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib29sO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5jb3B5VHlwZWRBcnJheSA9IGNvcHlUeXBlZEFycmF5O1xuZnVuY3Rpb24gaXNUeXBlZEFycmF5KGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCBhIGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuICAgICAgICBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuZnVuY3Rpb24gYnl0ZXNQZXJFbGVtZW50KGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicgfHwgZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuYnl0ZXNQZXJFbGVtZW50ID0gYnl0ZXNQZXJFbGVtZW50O1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuICEhKGYgJiYgZi5jb25zdHJ1Y3RvciAmJiBmLmNhbGwgJiYgZi5hcHBseSk7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZnVuY3Rpb24gZ2V0VGVuc29yc0luQ29udGFpbmVyKHJlc3VsdCkge1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgdmFyIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgd2Fsa1RlbnNvckNvbnRhaW5lcihyZXN1bHQsIGxpc3QsIHNlZW4pO1xuICAgIHJldHVybiBsaXN0O1xufVxuZXhwb3J0cy5nZXRUZW5zb3JzSW5Db250YWluZXIgPSBnZXRUZW5zb3JzSW5Db250YWluZXI7XG5mdW5jdGlvbiB3YWxrVGVuc29yQ29udGFpbmVyKGNvbnRhaW5lciwgbGlzdCwgc2Vlbikge1xuICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgbGlzdC5wdXNoKGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc0l0ZXJhYmxlKGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXRlcmFibGUgPSBjb250YWluZXI7XG4gICAgZm9yICh2YXIgayBpbiBpdGVyYWJsZSkge1xuICAgICAgICB2YXIgdmFsID0gaXRlcmFibGVba107XG4gICAgICAgIGlmICghc2Vlbi5oYXModmFsKSkge1xuICAgICAgICAgICAgc2Vlbi5hZGQodmFsKTtcbiAgICAgICAgICAgIHdhbGtUZW5zb3JDb250YWluZXIodmFsLCBsaXN0LCBzZWVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSXRlcmFibGUob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSB8fCB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmVyc2lvbiA9ICcwLjExLjYnO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL2tlcm5lbHMvd2ViZ2wvZ3BncHVfdXRpbFwiKTtcbmV4cG9ydHMuZ3BncHVfdXRpbCA9IGdwZ3B1X3V0aWw7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL2tlcm5lbHMvd2ViZ2wvd2ViZ2xfdXRpbFwiKTtcbmV4cG9ydHMud2ViZ2xfdXRpbCA9IHdlYmdsX3V0aWw7XG52YXIgYmFja2VuZF93ZWJnbF8xID0gcmVxdWlyZShcIi4va2VybmVscy9iYWNrZW5kX3dlYmdsXCIpO1xuZXhwb3J0cy5NYXRoQmFja2VuZFdlYkdMID0gYmFja2VuZF93ZWJnbF8xLk1hdGhCYWNrZW5kV2ViR0w7XG52YXIgZ3BncHVfY29udGV4dF8xID0gcmVxdWlyZShcIi4va2VybmVscy93ZWJnbC9ncGdwdV9jb250ZXh0XCIpO1xuZXhwb3J0cy5HUEdQVUNvbnRleHQgPSBncGdwdV9jb250ZXh0XzEuR1BHUFVDb250ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZ2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBBY3RpdmF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aXZhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3RpdmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEFjdGl2YXRpb24ucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGl2YXRpb247XG59KHRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKSk7XG5leHBvcnRzLkFjdGl2YXRpb24gPSBBY3RpdmF0aW9uO1xudmFyIEVsdSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsdSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbHUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRWx1LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDE7IH1cbiAgICAgICAgcmV0dXJuIEsuZWx1KHgsIGFscGhhKTtcbiAgICB9O1xuICAgIEVsdS5jbGFzc05hbWUgPSAnZWx1JztcbiAgICByZXR1cm4gRWx1O1xufShBY3RpdmF0aW9uKSk7XG5leHBvcnRzLkVsdSA9IEVsdTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihFbHUpO1xudmFyIFNlbHUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWx1LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlbHUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU2VsdS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGZjLnNlbHUoeCk7XG4gICAgfTtcbiAgICBTZWx1LmNsYXNzTmFtZSA9ICdzZWx1JztcbiAgICByZXR1cm4gU2VsdTtcbn0oQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5TZWx1ID0gU2VsdTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihTZWx1KTtcbnZhciBSZWx1ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVsdSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWx1KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlbHUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRmYy5yZWx1KHgpO1xuICAgIH07XG4gICAgUmVsdS5jbGFzc05hbWUgPSAncmVsdSc7XG4gICAgcmV0dXJuIFJlbHU7XG59KEFjdGl2YXRpb24pKTtcbmV4cG9ydHMuUmVsdSA9IFJlbHU7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoUmVsdSk7XG52YXIgUmVsdTYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWx1NiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWx1NigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZWx1Ni5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0ZmMubWluaW11bShLLmdldFNjYWxhcig2LjApLCB0ZmMucmVsdSh4KSk7IH0pO1xuICAgIH07XG4gICAgUmVsdTYuY2xhc3NOYW1lID0gJ3JlbHU2JztcbiAgICByZXR1cm4gUmVsdTY7XG59KEFjdGl2YXRpb24pKTtcbmV4cG9ydHMuUmVsdTYgPSBSZWx1NjtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihSZWx1Nik7XG52YXIgTGluZWFyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluZWFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmVhcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMaW5lYXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICBMaW5lYXIuY2xhc3NOYW1lID0gJ2xpbmVhcic7XG4gICAgcmV0dXJuIExpbmVhcjtcbn0oQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5MaW5lYXIgPSBMaW5lYXI7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTGluZWFyKTtcbnZhciBTaWdtb2lkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbW9pZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWdtb2lkKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNpZ21vaWQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRmYy5zaWdtb2lkKHgpO1xuICAgIH07XG4gICAgU2lnbW9pZC5jbGFzc05hbWUgPSAnc2lnbW9pZCc7XG4gICAgcmV0dXJuIFNpZ21vaWQ7XG59KEFjdGl2YXRpb24pKTtcbmV4cG9ydHMuU2lnbW9pZCA9IFNpZ21vaWQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoU2lnbW9pZCk7XG52YXIgSGFyZFNpZ21vaWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIYXJkU2lnbW9pZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIYXJkU2lnbW9pZCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBIYXJkU2lnbW9pZC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gSy5oYXJkU2lnbW9pZCh4KTtcbiAgICB9O1xuICAgIEhhcmRTaWdtb2lkLmNsYXNzTmFtZSA9ICdoYXJkU2lnbW9pZCc7XG4gICAgcmV0dXJuIEhhcmRTaWdtb2lkO1xufShBY3RpdmF0aW9uKSk7XG5leHBvcnRzLkhhcmRTaWdtb2lkID0gSGFyZFNpZ21vaWQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoSGFyZFNpZ21vaWQpO1xudmFyIFNvZnRwbHVzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU29mdHBsdXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdHBsdXMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU29mdHBsdXMucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRmYy5zb2Z0cGx1cyh4KTtcbiAgICB9O1xuICAgIFNvZnRwbHVzLmNsYXNzTmFtZSA9ICdzb2Z0cGx1cyc7XG4gICAgcmV0dXJuIFNvZnRwbHVzO1xufShBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlNvZnRwbHVzID0gU29mdHBsdXM7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoU29mdHBsdXMpO1xudmFyIFNvZnRzaWduID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU29mdHNpZ24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdHNpZ24oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU29mdHNpZ24ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIEsuc29mdHNpZ24oeCk7XG4gICAgfTtcbiAgICBTb2Z0c2lnbi5jbGFzc05hbWUgPSAnc29mdHNpZ24nO1xuICAgIHJldHVybiBTb2Z0c2lnbjtcbn0oQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5Tb2Z0c2lnbiA9IFNvZnRzaWduO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFNvZnRzaWduKTtcbnZhciBUYW5oID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFuaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYW5oKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhbmgucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRmYy50YW5oKHgpO1xuICAgIH07XG4gICAgVGFuaC5jbGFzc05hbWUgPSAndGFuaCc7XG4gICAgcmV0dXJuIFRhbmg7XG59KEFjdGl2YXRpb24pKTtcbmV4cG9ydHMuVGFuaCA9IFRhbmg7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoVGFuaCk7XG52YXIgU29mdG1heCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9ICgtMSk7IH1cbiAgICAgICAgcmV0dXJuIHRmYy5zb2Z0bWF4KHgsIGF4aXMpO1xuICAgIH07XG4gICAgU29mdG1heC5jbGFzc05hbWUgPSAnc29mdG1heCc7XG4gICAgcmV0dXJuIFNvZnRtYXg7XG59KEFjdGl2YXRpb24pKTtcbmV4cG9ydHMuU29mdG1heCA9IFNvZnRtYXg7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoU29mdG1heCk7XG5mdW5jdGlvbiBzZXJpYWxpemVBY3RpdmF0aW9uKGFjdGl2YXRpb24pIHtcbiAgICByZXR1cm4gYWN0aXZhdGlvbi5nZXRDbGFzc05hbWUoKTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplQWN0aXZhdGlvbiA9IHNlcmlhbGl6ZUFjdGl2YXRpb247XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUFjdGl2YXRpb24oY29uZmlnLCBjdXN0b21PYmplY3RzKSB7XG4gICAgaWYgKGN1c3RvbU9iamVjdHMgPT09IHZvaWQgMCkgeyBjdXN0b21PYmplY3RzID0ge307IH1cbiAgICByZXR1cm4gZ2VuZXJpY191dGlsc18xLmRlc2VyaWFsaXplS2VyYXNPYmplY3QoY29uZmlnLCB0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLCBjdXN0b21PYmplY3RzLCAnYWN0aXZhdGlvbicpO1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZUFjdGl2YXRpb24gPSBkZXNlcmlhbGl6ZUFjdGl2YXRpb247XG5mdW5jdGlvbiBnZXRBY3RpdmF0aW9uKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoaWRlbnRpZmllciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGNsYXNzTmFtZTogJ2xpbmVhcicsIGNvbmZpZzoge30gfTtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplQWN0aXZhdGlvbihjb25maWcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGNsYXNzTmFtZTogaWRlbnRpZmllciwgY29uZmlnOiB7fSB9O1xuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVBY3RpdmF0aW9uKGNvbmZpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlkZW50aWZpZXIgaW5zdGFuY2VvZiBBY3RpdmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplQWN0aXZhdGlvbihpZGVudGlmaWVyKTtcbiAgICB9XG59XG5leHBvcnRzLmdldEFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZhdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2Vwc2lsb24gPSAxZS03O1xuZnVuY3Rpb24gZXBzaWxvbigpIHtcbiAgICByZXR1cm4gX2Vwc2lsb247XG59XG5leHBvcnRzLmVwc2lsb24gPSBlcHNpbG9uO1xuZnVuY3Rpb24gc2V0RXBzaWxvbihlKSB7XG4gICAgX2Vwc2lsb24gPSBlO1xufVxuZXhwb3J0cy5zZXRFcHNpbG9uID0gc2V0RXBzaWxvbjtcbmZ1bmN0aW9uIGltYWdlRGF0YUZvcm1hdCgpIHtcbiAgICByZXR1cm4gJ2NoYW5uZWxzTGFzdCc7XG59XG5leHBvcnRzLmltYWdlRGF0YUZvcm1hdCA9IGltYWdlRGF0YUZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIG1hdGhfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWF0aF91dGlsc1wiKTtcbnZhciB2YXJpYWJsZXNfMSA9IHJlcXVpcmUoXCIuLi92YXJpYWJsZXNcIik7XG52YXIgY29tbW9uXzIgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG52YXIgY29tbW9uXzMgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG52YXIgYmFja2VuZCA9ICd3ZWJnbCc7XG52YXIgREVGQVVMVF9EVFlQRSA9ICdmbG9hdDMyJztcbmZ1bmN0aW9uIGRpc3Bvc2VTY2FsYXJDYWNoZSgpIHtcbiAgICBmb3IgKHZhciB0eXBlS2V5IGluIHNjYWxhckNhY2hlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzY2FsYXJDYWNoZVt0eXBlS2V5XSkge1xuICAgICAgICAgICAgc2NhbGFyQ2FjaGVbdHlwZUtleV1ba2V5XS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkZWxldGUgc2NhbGFyQ2FjaGVbdHlwZUtleV1ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGlzcG9zZVNjYWxhckNhY2hlID0gZGlzcG9zZVNjYWxhckNhY2hlO1xuZnVuY3Rpb24gc2V0QmFja2VuZChyZXF1ZXN0ZWRCYWNrZW5kKSB7XG4gICAgdGZjLnNldEJhY2tlbmQocmVxdWVzdGVkQmFja2VuZCk7XG4gICAgYmFja2VuZCA9IHJlcXVlc3RlZEJhY2tlbmQ7XG4gICAgZGlzcG9zZVNjYWxhckNhY2hlKCk7XG59XG5leHBvcnRzLnNldEJhY2tlbmQgPSBzZXRCYWNrZW5kO1xuZnVuY3Rpb24gZ2V0QmFja2VuZCgpIHtcbiAgICByZXR1cm4gYmFja2VuZDtcbn1cbmV4cG9ydHMuZ2V0QmFja2VuZCA9IGdldEJhY2tlbmQ7XG52YXIgc2NhbGFyQ2FjaGUgPSB7XG4gICAgZmxvYXQzMjoge30sXG4gICAgaW50MzI6IHt9XG59O1xuZnVuY3Rpb24gZ2V0U2NhbGFyKHZhbHVlLCBkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGR0eXBlID0gREVGQVVMVF9EVFlQRTtcbiAgICB9XG4gICAgaWYgKHNjYWxhckNhY2hlW2R0eXBlXVt2YWx1ZV0gPT0gbnVsbCkge1xuICAgICAgICBzY2FsYXJDYWNoZVtkdHlwZV1bdmFsdWVdID0gdGZqc19jb3JlXzEuc2NhbGFyKHZhbHVlLCBkdHlwZSk7XG4gICAgICAgIHRmYy5rZWVwKHNjYWxhckNhY2hlW2R0eXBlXVt2YWx1ZV0pO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGFyQ2FjaGVbZHR5cGVdW3ZhbHVlXTtcbn1cbmV4cG9ydHMuZ2V0U2NhbGFyID0gZ2V0U2NhbGFyO1xuZXhwb3J0cy5lcHNpbG9uID0gY29tbW9uXzIuZXBzaWxvbjtcbmZ1bmN0aW9uIGlzQmFja2VuZFN5bWJvbGljKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNCYWNrZW5kU3ltYm9saWMgPSBpc0JhY2tlbmRTeW1ib2xpYztcbmZ1bmN0aW9uIHNoYXBlKHgpIHtcbiAgICByZXR1cm4geC5zaGFwZTtcbn1cbmV4cG9ydHMuc2hhcGUgPSBzaGFwZTtcbmZ1bmN0aW9uIGludFNoYXBlKHgpIHtcbiAgICByZXR1cm4geC5zaGFwZTtcbn1cbmV4cG9ydHMuaW50U2hhcGUgPSBpbnRTaGFwZTtcbmZ1bmN0aW9uIGR0eXBlKHgpIHtcbiAgICByZXR1cm4gKHggaW5zdGFuY2VvZiB0ZmpzX2NvcmVfMS5UZW5zb3IpID8gREVGQVVMVF9EVFlQRSA6IHguZHR5cGU7XG59XG5leHBvcnRzLmR0eXBlID0gZHR5cGU7XG5mdW5jdGlvbiBjb3VudFBhcmFtcyh4KSB7XG4gICAgdmFyIHNoYXBlID0geC5zaGFwZTtcbiAgICBpZiAoc2hhcGUubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc2hhcGUucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICogYjsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59XG5leHBvcnRzLmNvdW50UGFyYW1zID0gY291bnRQYXJhbXM7XG5mdW5jdGlvbiBjYXN0KHgsIGR0eXBlKSB7XG4gICAgcmV0dXJuIHguYXNUeXBlKGR0eXBlKTtcbn1cbmV4cG9ydHMuY2FzdCA9IGNhc3Q7XG5mdW5jdGlvbiBleHBhbmREaW1zKHgsIGF4aXMpIHtcbiAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAtMTsgfVxuICAgIHZhciBvdXRTaGFwZSA9IHNoYXBlKHgpLnNsaWNlKCk7XG4gICAgaWYgKGF4aXMgPCAwKSB7XG4gICAgICAgIGF4aXMgPSBvdXRTaGFwZS5sZW5ndGggKyBheGlzICsgMTtcbiAgICB9XG4gICAgb3V0U2hhcGUuc3BsaWNlKGF4aXMsIDAsIDEpO1xuICAgIHJldHVybiB4LnJlc2hhcGUob3V0U2hhcGUpO1xufVxuZXhwb3J0cy5leHBhbmREaW1zID0gZXhwYW5kRGltcztcbmZ1bmN0aW9uIHJlcGVhdCh4LCBuKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeC5zaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwicmVwZWF0KCkgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCByZWNlaXZlZCBhIFwiICtcbiAgICAgICAgICAgICAgICAoXCJyYW5rLVwiICsgeC5zaGFwZS5sZW5ndGggKyBcIiB0ZW5zb3IuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeSA9IGV4cGFuZERpbXMoeCwgMSk7XG4gICAgICAgIHJldHVybiB0aWxlKHksIFsxLCBuLCAxXSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlcGVhdCA9IHJlcGVhdDtcbmZ1bmN0aW9uIGZsYXR0ZW4oeCkge1xuICAgIHZhciBuZXdTaGFwZSA9IFttYXRoX3V0aWxzLmFycmF5UHJvZCh4LnNoYXBlKV07XG4gICAgcmV0dXJuIHgucmVzaGFwZShuZXdTaGFwZSk7XG59XG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuZnVuY3Rpb24gYmF0Y2hGbGF0dGVuKHgpIHtcbiAgICBpZiAoeC5yYW5rIDw9IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJiYXRjaEZsYXR0ZW4gcmVxdWlyZXMgYSBtaW5pbXVtIHJhbmsgb2YgMi4gR290IHJhbms6IFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgIH1cbiAgICB2YXIgbmV3U2hhcGUgPSBbeC5zaGFwZVswXSwgbWF0aF91dGlscy5hcnJheVByb2QoeC5zaGFwZSwgMSldO1xuICAgIHJldHVybiB4LnJlc2hhcGUobmV3U2hhcGUpO1xufVxuZXhwb3J0cy5iYXRjaEZsYXR0ZW4gPSBiYXRjaEZsYXR0ZW47XG5mdW5jdGlvbiBzbGljZUFsb25nRmlyc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChhcnJheS5yYW5rKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTFkKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTJkKGFycmF5LCBbc3RhcnQsIDBdLCBbc2l6ZSwgYXJyYXkuc2hhcGVbMV1dKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZjLnNsaWNlM2QoYXJyYXksIFtzdGFydCwgMCwgMF0sIFtzaXplLCBhcnJheS5zaGFwZVsxXSwgYXJyYXkuc2hhcGVbMl1dKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZjLnNsaWNlNGQoYXJyYXksIFtzdGFydCwgMCwgMCwgMF0sIFtzaXplLCBhcnJheS5zaGFwZVsxXSwgYXJyYXkuc2hhcGVbMl0sIGFycmF5LnNoYXBlWzNdXSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwic2xpY2VBbG9uZ0ZpcnN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgYXJyYXkucmFuaykpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNsaWNlQWxvbmdGaXJzdEF4aXMgPSBzbGljZUFsb25nRmlyc3RBeGlzO1xuZnVuY3Rpb24gc2xpY2VBbG9uZ0xhc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChhcnJheS5yYW5rKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTFkKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTJkKGFycmF5LCBbMCwgc3RhcnRdLCBbYXJyYXkuc2hhcGVbMF0sIHNpemVdKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZjLnNsaWNlM2QoYXJyYXksIFswLCAwLCBzdGFydF0sIFthcnJheS5zaGFwZVswXSwgYXJyYXkuc2hhcGVbMV0sIHNpemVdKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZjLnNsaWNlNGQoYXJyYXksIFswLCAwLCAwLCBzdGFydF0sIFthcnJheS5zaGFwZVswXSwgYXJyYXkuc2hhcGVbMV0sIGFycmF5LnNoYXBlWzJdLCBzaXplXSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwic2xpY2VBbG9uZ0xhc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyBhcnJheS5yYW5rKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc2xpY2VBbG9uZ0xhc3RBeGlzID0gc2xpY2VBbG9uZ0xhc3RBeGlzO1xuZnVuY3Rpb24gc2xpY2VBbG9uZ0F4aXMoYXJyYXksIHN0YXJ0LCBzaXplLCBheGlzKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKGFycmF5LnJhbmspIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZjLnNsaWNlMWQoYXJyYXksIHN0YXJ0LCBzaXplKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoYXJyYXksIHN0YXJ0LCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlQWxvbmdMYXN0QXhpcyhhcnJheSwgc3RhcnQsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlwiICsgYXhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoYXJyYXksIHN0YXJ0LCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTNkKGFycmF5LCBbMCwgc3RhcnQsIDBdLCBbYXJyYXkuc2hhcGVbMF0sIHNpemUsIGFycmF5LnNoYXBlWzJdXSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZUFsb25nTGFzdEF4aXMoYXJyYXksIHN0YXJ0LCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcIiArIGF4aXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2U0ZChhcnJheSwgWzAsIHN0YXJ0LCAwLCAwXSwgW2FycmF5LnNoYXBlWzBdLCBzaXplLCBhcnJheS5zaGFwZVsyXSwgYXJyYXkuc2hhcGVbM11dKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTRkKGFycmF5LCBbMCwgMCwgc3RhcnQsIDBdLCBbYXJyYXkuc2hhcGVbMF0sIGFycmF5LnNoYXBlWzFdLCBzaXplLCBhcnJheS5zaGFwZVszXV0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2VBbG9uZ0xhc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyBheGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcInNsaWNlQWxvbmdMYXN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgYXJyYXkucmFuaykpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNsaWNlQWxvbmdBeGlzID0gc2xpY2VBbG9uZ0F4aXM7XG5mdW5jdGlvbiBjb25jYXRlbmF0ZSh0ZW5zb3JzLCBheGlzKSB7XG4gICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gLTE7IH1cbiAgICB2YXIgcmFuaztcbiAgICBpZiAoYXhpcyA8IDApIHtcbiAgICAgICAgcmFuayA9IHRlbnNvcnNbMF0ucmFuaztcbiAgICAgICAgaWYgKHJhbmsgIT09IDApIHtcbiAgICAgICAgICAgIGF4aXMgPSByYW5rO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXhpcyA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF4aXMgPT09IHRlbnNvcnNbMF0ucmFuaykge1xuICAgICAgICBheGlzID0gLTE7XG4gICAgfVxuICAgIHJldHVybiB0ZmMuY29uY2F0KHRlbnNvcnMsIGF4aXMpO1xufVxuZXhwb3J0cy5jb25jYXRlbmF0ZSA9IGNvbmNhdGVuYXRlO1xuZnVuY3Rpb24gY29uY2F0QWxvbmdGaXJzdEF4aXMoYSwgYikge1xuICAgIHN3aXRjaCAoYS5yYW5rKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiB0ZmMuY29uY2F0MWQoW2EsIGJdKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIHRmYy5jb25jYXQyZChbYSwgYl0sIDApO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdGZjLmNvbmNhdDNkKFthLCBiXSwgMCk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiB0ZmMuY29uY2F0NGQoW2EsIGJdLCAwKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdjb25jYXRBbG9uZ0ZpcnN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiAnICtcbiAgICAgICAgICAgICAgICBhLnJhbmspO1xuICAgIH1cbn1cbmV4cG9ydHMuY29uY2F0QWxvbmdGaXJzdEF4aXMgPSBjb25jYXRBbG9uZ0ZpcnN0QXhpcztcbmZ1bmN0aW9uIHRpbGUoeCwgbikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShuKSkge1xuICAgICAgICBuID0gW25dO1xuICAgIH1cbiAgICBpZiAoeC5yYW5rICE9PSBuLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSBsZW5ndGggb2YgaW5wdXQgbiAoXCIgKyBuLmxlbmd0aCArIFwiKSBkb2VzIG5vdCBtYXRjaCBcIiArXG4gICAgICAgICAgICAoXCJ0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gaW5wdXQgeCAoXCIgKyB4LnJhbmsgKyBcIilcIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGZjLnRpbGUoeCwgbik7XG59XG5leHBvcnRzLnRpbGUgPSB0aWxlO1xuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4LmNsb25lKCk7XG59XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5mdW5jdGlvbiBleWVWYXJpYWJsZShzaXplLCBkdHlwZSwgbmFtZSkge1xuICAgIHJldHVybiBuZXcgdmFyaWFibGVzXzEuTGF5ZXJWYXJpYWJsZSh0ZmMuZXllKHNpemUsIHNpemUsIG51bGwsIGR0eXBlKSwgZHR5cGUsIG5hbWUpO1xufVxuZXhwb3J0cy5leWVWYXJpYWJsZSA9IGV5ZVZhcmlhYmxlO1xuZnVuY3Rpb24gc2NhbGFyVGltZXNBcnJheShjLCB4KSB7XG4gICAgcmV0dXJuIHRmYy5tdWwoYywgeCk7XG59XG5leHBvcnRzLnNjYWxhclRpbWVzQXJyYXkgPSBzY2FsYXJUaW1lc0FycmF5O1xuZnVuY3Rpb24gc2NhbGFyUGx1c0FycmF5KGMsIHgpIHtcbiAgICByZXR1cm4gdGZjLmFkZChjLCB4KTtcbn1cbmV4cG9ydHMuc2NhbGFyUGx1c0FycmF5ID0gc2NhbGFyUGx1c0FycmF5O1xuZnVuY3Rpb24gcmFuZG9tTm9ybWFsKHNoYXBlLCBtZWFuLCBzdGRkZXYsIGR0eXBlLCBzZWVkKSB7XG4gICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMC4wOyB9XG4gICAgaWYgKHN0ZGRldiA9PT0gdm9pZCAwKSB7IHN0ZGRldiA9IDEuMDsgfVxuICAgIHJldHVybiB0ZmMucmFuZG9tTm9ybWFsKHNoYXBlLCBtZWFuLCBzdGRkZXYsIGR0eXBlLCBzZWVkKTtcbn1cbmV4cG9ydHMucmFuZG9tTm9ybWFsID0gcmFuZG9tTm9ybWFsO1xuZnVuY3Rpb24gZG90KHgsIHkpIHtcbiAgICBpZiAoeS5yYW5rICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiZG90IHN1cHBvcnQgZm9yIHkgb3RoZXIgdGhhbiByYW5rIDIgaXMgbm90IHlldCBpbXBsZW1lbnRlZDogXCIgK1xuICAgICAgICAgICAgKFwieSBzaGFwZSA9IFwiICsgc2hhcGUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZmMubWF0TXVsKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgdmFyIHhTaGFwZTAgPSB4LnNoYXBlWzBdO1xuICAgICAgICAgICAgdmFyIHhTaGFwZTEgPSB4LnNoYXBlWzFdO1xuICAgICAgICAgICAgdmFyIHhTaGFwZTIgPSB4LnNoYXBlWzJdO1xuICAgICAgICAgICAgeCA9IHgucmVzaGFwZShbeFNoYXBlMCAqIHhTaGFwZTEsIHhTaGFwZTJdKTtcbiAgICAgICAgICAgIHJldHVybiB0ZmMubWF0TXVsKHgsIHkpLnJlc2hhcGUoW1xuICAgICAgICAgICAgICAgIHhTaGFwZTAsIHhTaGFwZTEsIHkuc2hhcGVbMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJkb3Qgc3VwcG9ydCBmb3IgeCBvZiByYW5rIFwiICsgeC5yYW5rICsgXCIgaXMgbm90IHlldCBpbXBsZW1lbnRlZDogXCIgK1xuICAgICAgICAgICAgICAgIChcInggc2hhcGUgPSBcIiArIHNoYXBlKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRvdCA9IGRvdDtcbmZ1bmN0aW9uIHNpZ24oeCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHplcm9zTGlrZVggPSB0ZmpzX2NvcmVfMS56ZXJvc0xpa2UoeCk7XG4gICAgICAgIHZhciBvbmVzTGlrZVggPSB0ZmpzX2NvcmVfMS5vbmVzTGlrZSh4KTtcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLndoZXJlKHRmYy5lcXVhbCh4LCB6ZXJvc0xpa2VYKSwgemVyb3NMaWtlWCwgdGZqc19jb3JlXzEud2hlcmUodGZjLmdyZWF0ZXIoeCwgdGZqc19jb3JlXzEuemVyb3NMaWtlKHgpKSwgb25lc0xpa2VYLCBzY2FsYXJUaW1lc0FycmF5KGdldFNjYWxhcigtMSksIG9uZXNMaWtlWCkpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2lnbiA9IHNpZ247XG5mdW5jdGlvbiBxcih4KSB7XG4gICAgdmFyIF9hID0gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4LnNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJxcigpIHJlcXVpcmVzIGEgMkQgVGVuc29yLCBidXQgZ290IGEgXCIgKyB4LnNoYXBlLmxlbmd0aCArIFwiRCBUZW5zb3IuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4LnNoYXBlWzBdIDwgeC5zaGFwZVsxXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJxcigpIHJlcXVpcmVzIHguc2hhcGVbMF0gPj0geC5zaGFwZVsxXSwgYnV0IGdvdCBzaGFwZTogW1wiICsgeC5zaGFwZSArIFwiXVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbSA9IHguc2hhcGVbMF07XG4gICAgICAgIHZhciBuID0geC5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHEgPSB0ZmMuZXllKG0pO1xuICAgICAgICB2YXIgciA9IHguY2xvbmUoKTtcbiAgICAgICAgdmFyIG9uZTJEID0gdGZqc19jb3JlXzEudGVuc29yMmQoW1sxXV0sIFsxLCAxXSk7XG4gICAgICAgIHZhciB3ID0gb25lMkQuY2xvbmUoKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaikge1xuICAgICAgICAgICAgdmFyIHJUZW1wID0gcjtcbiAgICAgICAgICAgIHZhciB3VGVtcCA9IHc7XG4gICAgICAgICAgICB2YXIgcVRlbXAgPSBxO1xuICAgICAgICAgICAgX2EgPSB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmpFbmQxID0gci5zbGljZShbaiwgal0sIFttIC0gaiwgMV0pO1xuICAgICAgICAgICAgICAgIHZhciBub3JtWCA9IHRmYy5ub3JtKHJqRW5kMSk7XG4gICAgICAgICAgICAgICAgdmFyIHJqaiA9IHIuc2xpY2UoW2osIGpdLCBbMSwgMV0pO1xuICAgICAgICAgICAgICAgIHZhciBzID0gdGZjLm5lZyhzaWduKHJqaikpO1xuICAgICAgICAgICAgICAgIHZhciB1MSA9IHJqai5zdWIodGZjLm11bChzLCBub3JtWCkpO1xuICAgICAgICAgICAgICAgIHZhciB3UHJlID0gdGZjLmRpdihyakVuZDEsIHUxKTtcbiAgICAgICAgICAgICAgICBpZiAod1ByZS5zaGFwZVswXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB3ID0gb25lMkQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBvbmUyRC5jb25jYXQod1ByZS5zbGljZShbMSwgMF0sIFt3UHJlLnNoYXBlWzBdIC0gMSwgd1ByZS5zaGFwZVsxXV0pLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhdSA9IHRmYy5uZWcodGZjLmRpdih0ZmMubWF0TXVsKHMsIHUxKSwgbm9ybVgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmpFbmRBbGwgPSByLnNsaWNlKFtqLCAwXSwgW20gLSBqLCBuXSk7XG4gICAgICAgICAgICAgICAgdmFyIHRhdVRpbWVzVyA9IHRhdS5tdWwodyk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHJqRW5kQWxsLnN1Yih0YXVUaW1lc1cubWF0TXVsKHcudHJhbnNwb3NlKCkubWF0TXVsKHJqRW5kQWxsKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHIuc2xpY2UoWzAsIDBdLCBbaiwgbl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJqRW5kQWxsLnN1Yih0YXVUaW1lc1cubWF0TXVsKHcudHJhbnNwb3NlKCkubWF0TXVsKHJqRW5kQWxsKSkpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHFBbGxKRW5kID0gcS5zbGljZShbMCwgal0sIFttLCBxLnNoYXBlWzFdIC0gal0pO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxQWxsSkVuZC5zdWIocUFsbEpFbmQubWF0TXVsKHcpLm1hdE11bCh0YXVUaW1lc1cudHJhbnNwb3NlKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLnNsaWNlKFswLCAwXSwgW20sIGpdKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChxQWxsSkVuZC5zdWIocUFsbEpFbmQubWF0TXVsKHcpLm1hdE11bCh0YXVUaW1lc1cudHJhbnNwb3NlKCkpKSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdywgciwgcV07XG4gICAgICAgICAgICB9KSwgdyA9IF9hWzBdLCByID0gX2FbMV0sIHEgPSBfYVsyXTtcbiAgICAgICAgICAgIHRmanNfY29yZV8xLmRpc3Bvc2UoW3JUZW1wLCB3VGVtcCwgcVRlbXBdKTtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIF9sb29wXzEoaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtxLCByXTtcbiAgICB9KSwgcU91dGVyID0gX2FbMF0sIHJPdXRlciA9IF9hWzFdO1xuICAgIHJldHVybiBbcU91dGVyLCByT3V0ZXJdO1xufVxuZXhwb3J0cy5xciA9IHFyO1xuZnVuY3Rpb24gb25lSG90KGluZGljZXMsIG51bUNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbmRpY2VzLnJhbmsgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSAxRCBvbmUtaG90IHRlbnNvcnMgYXJlIHN1cHBvcnRlZCBpbiB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ2RlZXBsZWFybiBiYWNrZW5kLCBhdCBwcmVzZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIGluZGljZXMgPSBpbmRpY2VzLnRvSW50KCk7XG4gICAgICAgIHJldHVybiB0ZmMub25lSG90KGluZGljZXMsIG51bUNsYXNzZXMpLnRvRmxvYXQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMub25lSG90ID0gb25lSG90O1xuZnVuY3Rpb24gZ2F0aGVyKHJlZmVyZW5jZSwgaW5kaWNlcywgYXhpcykge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kaWNlcykpIHtcbiAgICAgICAgICAgIGluZGljZXMgPSB0ZmpzX2NvcmVfMS50ZW5zb3IxZChpbmRpY2VzLCAnaW50MzInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljZXMgPSBpbmRpY2VzLnRvSW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRmYy5nYXRoZXIocmVmZXJlbmNlLCBpbmRpY2VzLCBheGlzKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2F0aGVyID0gZ2F0aGVyO1xuZnVuY3Rpb24gc3F1YXJlKHgpIHtcbiAgICByZXR1cm4gdGZjLm11bFN0cmljdCh4LCB4KTtcbn1cbmV4cG9ydHMuc3F1YXJlID0gc3F1YXJlO1xuZnVuY3Rpb24gcG93KHgsIGEpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGEpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYSA9IHRmanNfY29yZV8xLnNjYWxhcihNYXRoLnJvdW5kKGEpLCAnaW50MzInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5kdHlwZSAhPT0gJ2ludDMyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJOb24taW50MzIgZHR5cGUgKFwiICsgYS5kdHlwZSArIFwiKSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHBvdygpIHlldFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGZjLnBvdyh4LCBhKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucG93ID0gcG93O1xuZnVuY3Rpb24gYmlhc0FkZCh4LCBiaWFzLCBkYXRhRm9ybWF0KSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhRm9ybWF0ID0gY29tbW9uXzMuaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uXzEuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgICAgICBpZiAoYmlhcy5yYW5rICE9PSAxICYmIGJpYXMucmFuayAhPT0geC5yYW5rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignVW5leHBlY3RlZCBiaWFzIGRpbWVuc2lvbnM6ICcgKyBiaWFzLnJhbmsgK1xuICAgICAgICAgICAgICAgICc7IGV4cGVjdGVkIGl0IHRvIGJlIDEgb3IgJyArIHgucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpYXNTaGFwZSA9IGJpYXMuc2hhcGU7XG4gICAgICAgIHZhciB5O1xuICAgICAgICBpZiAoeC5yYW5rID09PSA1KSB7XG4gICAgICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpYXNTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMucmVzaGFwZShbMSwgYmlhc1NoYXBlWzBdLCAxLCAxLCAxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMucmVzaGFwZShbMSwgYmlhc1NoYXBlWzNdLCBiaWFzU2hhcGVbMF0sIGJpYXNTaGFwZVsxXSwgYmlhc1NoYXBlWzJdXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpYXNTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMucmVzaGFwZShbMSwgMSwgMSwgMSwgYmlhc1NoYXBlWzBdXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMucmVzaGFwZShbMV0uY29uY2F0KGJpYXNTaGFwZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpYXNTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMucmVzaGFwZShbMSwgYmlhc1NoYXBlWzBdLCAxLCAxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMucmVzaGFwZShbMSwgYmlhc1NoYXBlWzJdLCBiaWFzU2hhcGVbMF0sIGJpYXNTaGFwZVsxXV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChiaWFzU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIDEsIDEsIGJpYXNTaGFwZVswXV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzFdLmNvbmNhdChiaWFzU2hhcGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChiaWFzU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIGJpYXNTaGFwZVswXSwgMV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB4LmFkZChiaWFzLnJlc2hhcGUoWzEsIGJpYXNTaGFwZVsxXSwgYmlhc1NoYXBlWzBdXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpYXNTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMucmVzaGFwZShbMSwgMSwgYmlhc1NoYXBlWzBdXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMucmVzaGFwZShbMV0uY29uY2F0KGJpYXNTaGFwZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rIDwgMykge1xuICAgICAgICAgICAgeSA9IHguYWRkKGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJVbnN1cHBvcnRlZCBpbnB1dCByYW5rIGJ5IGJpYXNBZGQ6IFwiICsgeC5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYmlhc0FkZCA9IGJpYXNBZGQ7XG5mdW5jdGlvbiBlbHUoeCwgYWxwaGEpIHtcbiAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDE7IH1cbiAgICBpZiAoYWxwaGEgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJTdXBwb3J0IGZvciBhbHBoYSB2YWx1ZXMgb3RoZXIgdGhhbiAxIChcIiArIGFscGhhICsgXCIpIGlzIG5vdCBpbXBsZW1lbnRlZCBcIiArXG4gICAgICAgICAgICBcInlldC5cIik7XG4gICAgfVxuICAgIHJldHVybiB0ZmMuZWx1KHgpO1xufVxuZXhwb3J0cy5lbHUgPSBlbHU7XG5mdW5jdGlvbiBzb2Z0c2lnbih4KSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZjLmRpdih4LCB0ZmMuYWRkKGdldFNjYWxhcigxKSwgdGZjLmFicyh4KSkpOyB9KTtcbn1cbmV4cG9ydHMuc29mdHNpZ24gPSBzb2Z0c2lnbjtcbmZ1bmN0aW9uIGRyb3BvdXQoeCwgbGV2ZWwsIG5vaXNlU2hhcGUsIHNlZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChub2lzZVNoYXBlICE9IG51bGwgJiYgIXRmanNfY29yZV8xLnV0aWwuYXJyYXlzRXF1YWwoeC5zaGFwZSwgbm9pc2VTaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdOb24tZGVmYXVsdCBub2lzZSBzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0OiAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShub2lzZVNoYXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ3NlZWQgaXMgbm90IGltcGxlbWVudGVkIGZvciBkcm9wb3V0IHlldC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXVsdGlwbGllciA9IHRmYy5zdGVwKHRmYy5hZGQodGZjLm5lZyhsZXZlbCksIHRmYy5yYW5kb21Vbmlmb3JtKHguc2hhcGUsIDAsIDEsICdmbG9hdDMyJykpKTtcbiAgICAgICAgbXVsdGlwbGllciA9IHRmYy5tdWwodGZjLmRpdihnZXRTY2FsYXIoMSksIHRmYy5zdWIoZ2V0U2NhbGFyKDEpLCBsZXZlbCkpLCBtdWx0aXBsaWVyKTtcbiAgICAgICAgcmV0dXJuIHRmYy5tdWwoeCwgbXVsdGlwbGllcik7XG4gICAgfSk7XG59XG5leHBvcnRzLmRyb3BvdXQgPSBkcm9wb3V0O1xuZnVuY3Rpb24gbmFtZVNjb3BlKG5hbWUsIGZuKSB7XG4gICAgcmV0dXJuIGNvbW1vbl8xLm5hbWVTY29wZShuYW1lLCBmbik7XG59XG5leHBvcnRzLm5hbWVTY29wZSA9IG5hbWVTY29wZTtcbmZ1bmN0aW9uIGZsb2F0eCgpIHtcbiAgICByZXR1cm4gJ2Zsb2F0MzInO1xufVxuZXhwb3J0cy5mbG9hdHggPSBmbG9hdHg7XG52YXIgX3VpZFByZWZpeGVzID0ge307XG5mdW5jdGlvbiBnZXRVaWQocHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7IHByZWZpeCA9ICcnOyB9XG4gICAgaWYgKCEocHJlZml4IGluIF91aWRQcmVmaXhlcykpIHtcbiAgICAgICAgX3VpZFByZWZpeGVzW3ByZWZpeF0gPSAwO1xuICAgIH1cbiAgICBfdWlkUHJlZml4ZXNbcHJlZml4XSArPSAxO1xuICAgIHJldHVybiBwcmVmaXggKyBfdWlkUHJlZml4ZXNbcHJlZml4XS50b1N0cmluZygpO1xufVxuZXhwb3J0cy5nZXRVaWQgPSBnZXRVaWQ7XG5mdW5jdGlvbiBoYXJkU2lnbW9pZCh4KSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHNjYWxhclBsdXNBcnJheShnZXRTY2FsYXIoMC41KSwgc2NhbGFyVGltZXNBcnJheShnZXRTY2FsYXIoMC4yKSwgeCkpO1xuICAgICAgICByZXR1cm4gdGZjLmNsaXBCeVZhbHVlKHksIDAsIDEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5oYXJkU2lnbW9pZCA9IGhhcmRTaWdtb2lkO1xuZnVuY3Rpb24gaW5UcmFpblBoYXNlKHgsIGFsdCwgdHJhaW5pbmcpIHtcbiAgICBpZiAodHJhaW5pbmcgPT09IHZvaWQgMCkgeyB0cmFpbmluZyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIHRyYWluaW5nID8geCgpIDogYWx0KCk7XG59XG5leHBvcnRzLmluVHJhaW5QaGFzZSA9IGluVHJhaW5QaGFzZTtcbmZ1bmN0aW9uIGdyYWRpZW50cyhsb3NzRm4sIHZhcmlhYmxlcykge1xuICAgIHZhciB2YXJpYWJsZUxpc3QgPSB2YXJpYWJsZXMubWFwKGZ1bmN0aW9uICh2YXJpYWJsZSkgeyByZXR1cm4gdmFyaWFibGUucmVhZCgpOyB9KTtcbiAgICB2YXIgdmFsdWRBbmRHcmFkcyA9IHRmanNfY29yZV8xLnZhcmlhYmxlR3JhZHMobG9zc0ZuLCB2YXJpYWJsZUxpc3QpO1xuICAgIHJldHVybiB2YXJpYWJsZXMubWFwKGZ1bmN0aW9uICh2YXJpYWJsZSkgeyByZXR1cm4gdmFsdWRBbmRHcmFkcy5ncmFkc1t2YXJpYWJsZS5uYW1lXTsgfSk7XG59XG5leHBvcnRzLmdyYWRpZW50cyA9IGdyYWRpZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmanNfYmFja2VuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBDYWxsYmFjayA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGlvbkRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICB9XG4gICAgQ2FsbGJhY2sucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfTtcbiAgICBDYWxsYmFjay5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH07XG4gICAgQ2FsbGJhY2sucHJvdG90eXBlLm9uRXBvY2hCZWdpbiA9IGZ1bmN0aW9uIChlcG9jaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIENhbGxiYWNrLnByb3RvdHlwZS5vbkVwb2NoRW5kID0gZnVuY3Rpb24gKGVwb2NoLCBsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgQ2FsbGJhY2sucHJvdG90eXBlLm9uQmF0Y2hCZWdpbiA9IGZ1bmN0aW9uIChiYXRjaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIENhbGxiYWNrLnByb3RvdHlwZS5vbkJhdGNoRW5kID0gZnVuY3Rpb24gKGJhdGNoLCBsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgQ2FsbGJhY2sucHJvdG90eXBlLm9uVHJhaW5CZWdpbiA9IGZ1bmN0aW9uIChsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgQ2FsbGJhY2sucHJvdG90eXBlLm9uVHJhaW5FbmQgPSBmdW5jdGlvbiAobG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxsYmFjaztcbn0oKSk7XG5leHBvcnRzLkNhbGxiYWNrID0gQ2FsbGJhY2s7XG52YXIgQ2FsbGJhY2tMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWxsYmFja0xpc3QoY2FsbGJhY2tzLCBxdWV1ZUxlbmd0aCkge1xuICAgICAgICBpZiAocXVldWVMZW5ndGggPT09IHZvaWQgMCkgeyBxdWV1ZUxlbmd0aCA9IDEwOyB9XG4gICAgICAgIGlmIChjYWxsYmFja3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgIHRoaXMucXVldWVMZW5ndGggPSBxdWV1ZUxlbmd0aDtcbiAgICB9XG4gICAgQ2FsbGJhY2tMaXN0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDYWxsYmFja0xpc3QucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2FsbGJhY2tzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgY2FsbGJhY2suc2V0UGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGxiYWNrTGlzdC5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2FsbGJhY2tzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgY2FsbGJhY2suc2V0TW9kZWwobW9kZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxsYmFja0xpc3QucHJvdG90eXBlLm9uRXBvY2hCZWdpbiA9IGZ1bmN0aW9uIChlcG9jaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2ksIF9hLCBjYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIF9hID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjYWxsYmFjay5vbkVwb2NoQmVnaW4oZXBvY2gsIGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGxiYWNrTGlzdC5wcm90b3R5cGUub25FcG9jaEVuZCA9IGZ1bmN0aW9uIChlcG9jaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2ksIF9hLCBjYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIF9hID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjYWxsYmFjay5vbkVwb2NoRW5kKGVwb2NoLCBsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxsYmFja0xpc3QucHJvdG90eXBlLm9uQmF0Y2hCZWdpbiA9IGZ1bmN0aW9uIChiYXRjaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2ksIF9hLCBjYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIF9hID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjYWxsYmFjay5vbkJhdGNoQmVnaW4oYmF0Y2gsIGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGxiYWNrTGlzdC5wcm90b3R5cGUub25CYXRjaEVuZCA9IGZ1bmN0aW9uIChiYXRjaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2ksIF9hLCBjYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIF9hID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjYWxsYmFjay5vbkJhdGNoRW5kKGJhdGNoLCBsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxsYmFja0xpc3QucHJvdG90eXBlLm9uVHJhaW5CZWdpbiA9IGZ1bmN0aW9uIChsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfaSwgX2EsIGNhbGxiYWNrO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgX2EgPSB0aGlzLmNhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBfYS5sZW5ndGgpKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGNhbGxiYWNrLm9uVHJhaW5CZWdpbihsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxsYmFja0xpc3QucHJvdG90eXBlLm9uVHJhaW5FbmQgPSBmdW5jdGlvbiAobG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2ksIF9hLCBjYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIF9hID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjYWxsYmFjay5vblRyYWluRW5kKGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxsYmFja0xpc3Q7XG59KCkpO1xuZXhwb3J0cy5DYWxsYmFja0xpc3QgPSBDYWxsYmFja0xpc3Q7XG52YXIgQmFzZUxvZ2dlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VMb2dnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzZUxvZ2dlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEJhc2VMb2dnZXIucHJvdG90eXBlLm9uRXBvY2hCZWdpbiA9IGZ1bmN0aW9uIChlcG9jaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWVuID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFscyA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlTG9nZ2VyLnByb3RvdHlwZS5vbkJhdGNoRW5kID0gZnVuY3Rpb24gKGJhdGNoLCBsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYmF0Y2hTaXplLCBfbG9vcF8xLCB0aGlzXzEsIGtleTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplID0gbG9nc1snc2l6ZSddID09IG51bGwgPyAwIDogbG9nc1snc2l6ZSddO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VlbiArPSBiYXRjaFNpemU7XG4gICAgICAgICAgICAgICAgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbG9nc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzXzEudG90YWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEudG90YWxzW2tleV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLnRvdGFsc1trZXldID0gdGhpc18xLnRvdGFsc1trZXldICsgdmFsdWUgKiBiYXRjaFNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkVG90YWxzVG9EaXNwb3NlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzXzEudG90YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVG90YWxzVG9EaXNwb3NlID0gdGhpc18xLnRvdGFsc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLnRvdGFsc1trZXldID0gSy5nZXRTY2FsYXIoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEudG90YWxzW2tleV0gPSB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIEsuc2NhbGFyUGx1c0FycmF5KF90aGlzLnRvdGFsc1trZXldLCB0ZmpzX2NvcmVfMS5tdWwodmFsdWUsIEsuZ2V0U2NhbGFyKGJhdGNoU2l6ZSkpKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkVG90YWxzVG9EaXNwb3NlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRUb3RhbHNUb0Rpc3Bvc2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGxvZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZUxvZ2dlci5wcm90b3R5cGUub25FcG9jaEVuZCA9IGZ1bmN0aW9uIChlcG9jaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9sb29wXzIsIHRoaXNfMiwgX2ksIF9hLCBrZXk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8yID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfMi50b3RhbHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc18yLnRvdGFsc1trZXldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3Nba2V5XSA9IHRoaXNfMi50b3RhbHNba2V5XSAvIHRoaXNfMi5zZWVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3Nba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBLLnNjYWxhclRpbWVzQXJyYXkodGZqc19jb3JlXzEuZGl2KEsuZ2V0U2NhbGFyKDEpLCBLLmdldFNjYWxhcihfdGhpcy5zZWVuKSksIF90aGlzLnRvdGFsc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG90YWxzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZmpzX2NvcmVfMS5rZWVwKGxvZ3Nba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfYSA9IHRoaXMucGFyYW1zWydtZXRyaWNzJ107IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8yKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlTG9nZ2VyO1xufShDYWxsYmFjaykpO1xuZXhwb3J0cy5CYXNlTG9nZ2VyID0gQmFzZUxvZ2dlcjtcbmZ1bmN0aW9uIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9taXNlcywga2V5cywga2V5LCB2YWx1ZSwgdmFsdWVTY2FsYXIsIHZhbHVlcywgaTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGxvZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbG9nc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNjYWxhciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godmFsdWVTY2FsYXIuZGF0YSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIFByb21pc2UuYWxsKHByb21pc2VzKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3Nba2V5c1tpXV0gPSB2YWx1ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlc29sdmVTY2FsYXJzSW5Mb2dzID0gcmVzb2x2ZVNjYWxhcnNJbkxvZ3M7XG5mdW5jdGlvbiBkaXNwb3NlVGVuc29yc0luTG9ncyhsb2dzKSB7XG4gICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBsb2dzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGxvZ3Nba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGlzcG9zZVRlbnNvcnNJbkxvZ3MgPSBkaXNwb3NlVGVuc29yc0luTG9ncztcbnZhciBIaXN0b3J5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGlzdG9yeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIaXN0b3J5KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEhpc3RvcnkucHJvdG90eXBlLm9uVHJhaW5CZWdpbiA9IGZ1bmN0aW9uIChsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVwb2NoID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5ID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhpc3RvcnkucHJvdG90eXBlLm9uRXBvY2hFbmQgPSBmdW5jdGlvbiAoZXBvY2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lcG9jaC5wdXNoKGVwb2NoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBsb2dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpc3Rvcnlba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3Rvcnlba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeVtrZXldLnB1c2gobG9nc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhpc3RvcnkucHJvdG90eXBlLnN5bmNEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMsIGtleXMsIGluZGljZXMsIGtleSwgdmFsdWVBcnJheSwgaSwgdmFsdWVTY2FsYXIsIHZhbHVlcywgbjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiB0aGlzLmhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUFycmF5ID0gdGhpcy5oaXN0b3J5W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZUFycmF5W2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTY2FsYXIgPSB2YWx1ZUFycmF5W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh2YWx1ZVNjYWxhci5kYXRhKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIFByb21pc2UuYWxsKHByb21pc2VzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCB2YWx1ZXMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3Rvcnlba2V5c1tuXV1baW5kaWNlc1tuXV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeVtrZXlzW25dXVtpbmRpY2VzW25dXSA9IHZhbHVlc1tuXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEhpc3Rvcnk7XG59KENhbGxiYWNrKSk7XG5leHBvcnRzLkhpc3RvcnkgPSBIaXN0b3J5O1xudmFyIEN1c3RvbUNhbGxiYWNrID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3VzdG9tQ2FsbGJhY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tQ2FsbGJhY2soY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRyYWluQmVnaW4gPSBjb25maWcub25UcmFpbkJlZ2luO1xuICAgICAgICBfdGhpcy50cmFpbkVuZCA9IGNvbmZpZy5vblRyYWluRW5kO1xuICAgICAgICBfdGhpcy5lcG9jaEJlZ2luID0gY29uZmlnLm9uRXBvY2hCZWdpbjtcbiAgICAgICAgX3RoaXMuZXBvY2hFbmQgPSBjb25maWcub25FcG9jaEVuZDtcbiAgICAgICAgX3RoaXMuYmF0Y2hCZWdpbiA9IGNvbmZpZy5vbkJhdGNoQmVnaW47XG4gICAgICAgIF90aGlzLmJhdGNoRW5kID0gY29uZmlnLm9uQmF0Y2hFbmQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ3VzdG9tQ2FsbGJhY2sucHJvdG90eXBlLm9uRXBvY2hCZWdpbiA9IGZ1bmN0aW9uIChlcG9jaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLmVwb2NoQmVnaW4gIT0gbnVsbCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmVwb2NoQmVnaW4oZXBvY2gsIGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ3VzdG9tQ2FsbGJhY2sucHJvdG90eXBlLm9uRXBvY2hFbmQgPSBmdW5jdGlvbiAoZXBvY2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5lcG9jaEVuZCAhPSBudWxsKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVzb2x2ZVNjYWxhcnNJbkxvZ3MobG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZXBvY2hFbmQoZXBvY2gsIGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ3VzdG9tQ2FsbGJhY2sucHJvdG90eXBlLm9uQmF0Y2hCZWdpbiA9IGZ1bmN0aW9uIChiYXRjaCwgbG9ncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLmJhdGNoQmVnaW4gIT0gbnVsbCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmJhdGNoQmVnaW4oYmF0Y2gsIGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ3VzdG9tQ2FsbGJhY2sucHJvdG90eXBlLm9uQmF0Y2hFbmQgPSBmdW5jdGlvbiAoYmF0Y2gsIGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5iYXRjaEVuZCAhPSBudWxsKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVzb2x2ZVNjYWxhcnNJbkxvZ3MobG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuYmF0Y2hFbmQoYmF0Y2gsIGxvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ3VzdG9tQ2FsbGJhY2sucHJvdG90eXBlLm9uVHJhaW5CZWdpbiA9IGZ1bmN0aW9uIChsb2dzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMudHJhaW5CZWdpbiAhPSBudWxsKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVzb2x2ZVNjYWxhcnNJbkxvZ3MobG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMudHJhaW5CZWdpbihsb2dzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEN1c3RvbUNhbGxiYWNrLnByb3RvdHlwZS5vblRyYWluRW5kID0gZnVuY3Rpb24gKGxvZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy50cmFpbkVuZCAhPSBudWxsKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgcmVzb2x2ZVNjYWxhcnNJbkxvZ3MobG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMudHJhaW5FbmQobG9ncyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tQ2FsbGJhY2s7XG59KENhbGxiYWNrKSk7XG5leHBvcnRzLkN1c3RvbUNhbGxiYWNrID0gQ3VzdG9tQ2FsbGJhY2s7XG5mdW5jdGlvbiBzdGFuZGFyZGl6ZUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgICBpZiAoY2FsbGJhY2tzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjYWxsYmFja3MgaW5zdGFuY2VvZiBDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gW2NhbGxiYWNrc107XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykgJiYgY2FsbGJhY2tzWzBdIGluc3RhbmNlb2YgQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrcztcbiAgICB9XG4gICAgdmFyIGNhbGxiYWNrQ29uZmlncyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIGNhbGxiYWNrQ29uZmlncy5tYXAoZnVuY3Rpb24gKGNhbGxiYWNrQ29uZmlnKSB7IHJldHVybiBuZXcgQ3VzdG9tQ2FsbGJhY2soY2FsbGJhY2tDb25maWcpOyB9KTtcbn1cbmV4cG9ydHMuc3RhbmRhcmRpemVDYWxsYmFja3MgPSBzdGFuZGFyZGl6ZUNhbGxiYWNrcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGxiYWNrcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnZW5lcmljX3V0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIG5hbWVNYXAgPSBuZXcgTWFwKCk7XG5leHBvcnRzLlZBTElEX0RBVEFfRk9STUFUX1ZBTFVFUyA9IFsnY2hhbm5lbHNGaXJzdCcsICdjaGFubmVsc0xhc3QnXTtcbmZ1bmN0aW9uIGNoZWNrRGF0YUZvcm1hdCh2YWx1ZSkge1xuICAgIGdlbmVyaWNfdXRpbHNfMS5jaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKGV4cG9ydHMuVkFMSURfREFUQV9GT1JNQVRfVkFMVUVTLCAnRGF0YUZvcm1hdCcsIHZhbHVlKTtcbn1cbmV4cG9ydHMuY2hlY2tEYXRhRm9ybWF0ID0gY2hlY2tEYXRhRm9ybWF0O1xuZXhwb3J0cy5WQUxJRF9QQURESU5HX01PREVfVkFMVUVTID0gWyd2YWxpZCcsICdzYW1lJywgJ2NhdXNhbCddO1xuZnVuY3Rpb24gY2hlY2tQYWRkaW5nTW9kZSh2YWx1ZSkge1xuICAgIGdlbmVyaWNfdXRpbHNfMS5jaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKGV4cG9ydHMuVkFMSURfUEFERElOR19NT0RFX1ZBTFVFUywgJ1BhZGRpbmdNb2RlJywgdmFsdWUpO1xufVxuZXhwb3J0cy5jaGVja1BhZGRpbmdNb2RlID0gY2hlY2tQYWRkaW5nTW9kZTtcbmV4cG9ydHMuVkFMSURfUE9PTF9NT0RFX1ZBTFVFUyA9IFsnbWF4JywgJ2F2ZyddO1xuZnVuY3Rpb24gY2hlY2tQb29sTW9kZSh2YWx1ZSkge1xuICAgIGdlbmVyaWNfdXRpbHNfMS5jaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKGV4cG9ydHMuVkFMSURfUE9PTF9NT0RFX1ZBTFVFUywgJ1Bvb2xNb2RlJywgdmFsdWUpO1xufVxuZXhwb3J0cy5jaGVja1Bvb2xNb2RlID0gY2hlY2tQb29sTW9kZTtcbnZhciBfbmFtZVNjb3BlU3RhY2sgPSBbXTtcbnZhciBfbmFtZVNjb3BlRGl2aWRlciA9ICcvJztcbmZ1bmN0aW9uIG5hbWVTY29wZShuYW1lLCBmbikge1xuICAgIF9uYW1lU2NvcGVTdGFjay5wdXNoKG5hbWUpO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWwgPSBmbigpO1xuICAgICAgICBfbmFtZVNjb3BlU3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIF9uYW1lU2NvcGVTdGFjay5wb3AoKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5leHBvcnRzLm5hbWVTY29wZSA9IG5hbWVTY29wZTtcbmZ1bmN0aW9uIGN1cnJlbnROYW1lU2NvcGVQcmVmaXgoKSB7XG4gICAgaWYgKF9uYW1lU2NvcGVTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9uYW1lU2NvcGVTdGFjay5qb2luKF9uYW1lU2NvcGVEaXZpZGVyKSArIF9uYW1lU2NvcGVEaXZpZGVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjb3BlZFRlbnNvck5hbWUodGVuc29yTmFtZSkge1xuICAgIGlmICghaXNWYWxpZFRlbnNvck5hbWUodGVuc29yTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCB0ZW5zb3IgbmFtZTogXFwnJyArIHRlbnNvck5hbWUgKyAnXFwnJyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50TmFtZVNjb3BlUHJlZml4KCkgKyB0ZW5zb3JOYW1lO1xufVxuZXhwb3J0cy5nZXRTY29wZWRUZW5zb3JOYW1lID0gZ2V0U2NvcGVkVGVuc29yTmFtZTtcbmZ1bmN0aW9uIGdldFVuaXF1ZVRlbnNvck5hbWUoc2NvcGVkTmFtZSkge1xuICAgIGlmICghaXNWYWxpZFRlbnNvck5hbWUoc2NvcGVkTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCB0ZW5zb3IgbmFtZTogXFwnJyArIHNjb3BlZE5hbWUgKyAnXFwnJyk7XG4gICAgfVxuICAgIGlmICghbmFtZU1hcC5oYXMoc2NvcGVkTmFtZSkpIHtcbiAgICAgICAgbmFtZU1hcC5zZXQoc2NvcGVkTmFtZSwgMCk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IG5hbWVNYXAuZ2V0KHNjb3BlZE5hbWUpO1xuICAgIG5hbWVNYXAuc2V0KHNjb3BlZE5hbWUsIG5hbWVNYXAuZ2V0KHNjb3BlZE5hbWUpICsgMSk7XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2NvcGVkTmFtZSArICdfJyArIGluZGV4O1xuICAgICAgICBuYW1lTWFwLnNldChyZXN1bHQsIDEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlZE5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRVbmlxdWVUZW5zb3JOYW1lID0gZ2V0VW5pcXVlVGVuc29yTmFtZTtcbnZhciB0ZW5zb3JOYW1lUmVnZXggPSBuZXcgUmVnRXhwKC9eW0EtWmEtel1bQS1aYS16MC05XFwuX1xcL10qJC8pO1xuZnVuY3Rpb24gaXNWYWxpZFRlbnNvck5hbWUobmFtZSkge1xuICAgIHJldHVybiBuYW1lLm1hdGNoKHRlbnNvck5hbWVSZWdleCkgPyB0cnVlIDogZmFsc2U7XG59XG5leHBvcnRzLmlzVmFsaWRUZW5zb3JOYW1lID0gaXNWYWxpZFRlbnNvck5hbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbmZ1bmN0aW9uIGNhbGNMMk5vcm1zKHcsIGF4aXMpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0ZmMuc3FydCh0ZmMuc3VtKEsuc3F1YXJlKHcpLCBheGlzLCB0cnVlKSk7IH0pO1xufVxudmFyIENvbnN0cmFpbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25zdHJhaW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnN0cmFpbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfTtcbiAgICBDb25zdHJhaW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdDb25zdHJhaW50cycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgbmFtZXNwYWNlOiAnY29uc3RyYWludHMnIH0pXG4gICAgXSwgQ29uc3RyYWludCk7XG4gICAgcmV0dXJuIENvbnN0cmFpbnQ7XG59KHRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKSk7XG5leHBvcnRzLkNvbnN0cmFpbnQgPSBDb25zdHJhaW50O1xudmFyIE1heE5vcm0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhOb3JtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heE5vcm0oY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlZmF1bHRNYXhWYWx1ZSA9IDI7XG4gICAgICAgIF90aGlzLmRlZmF1bHRBeGlzID0gMDtcbiAgICAgICAgX3RoaXMubWF4VmFsdWUgPVxuICAgICAgICAgICAgY29uZmlnLm1heFZhbHVlICE9IG51bGwgPyBjb25maWcubWF4VmFsdWUgOiBfdGhpcy5kZWZhdWx0TWF4VmFsdWU7XG4gICAgICAgIF90aGlzLmF4aXMgPSBjb25maWcuYXhpcyAhPSBudWxsID8gY29uZmlnLmF4aXMgOiBfdGhpcy5kZWZhdWx0QXhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXhOb3JtLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub3JtcyA9IGNhbGNMMk5vcm1zKHcsIF90aGlzLmF4aXMpO1xuICAgICAgICAgICAgdmFyIGRlc2lyZWQgPSB0ZmMuY2xpcEJ5VmFsdWUobm9ybXMsIDAsIF90aGlzLm1heFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0ZmMubXVsKHcsIHRmYy5kaXYoZGVzaXJlZCwgSy5zY2FsYXJQbHVzQXJyYXkoSy5nZXRTY2FsYXIoSy5lcHNpbG9uKCkpLCBub3JtcykpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXhOb3JtLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IG1heFZhbHVlOiB0aGlzLm1heFZhbHVlLCBheGlzOiB0aGlzLmF4aXMgfTtcbiAgICB9O1xuICAgIE1heE5vcm0uY2xhc3NOYW1lID0gJ01heE5vcm0nO1xuICAgIHJldHVybiBNYXhOb3JtO1xufShDb25zdHJhaW50KSk7XG5leHBvcnRzLk1heE5vcm0gPSBNYXhOb3JtO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKE1heE5vcm0pO1xudmFyIFVuaXROb3JtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5pdE5vcm0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5pdE5vcm0oY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlZmF1bHRBeGlzID0gMDtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGNvbmZpZy5heGlzICE9IG51bGwgPyBjb25maWcuYXhpcyA6IF90aGlzLmRlZmF1bHRBeGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFVuaXROb3JtLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmYy5kaXYodywgSy5zY2FsYXJQbHVzQXJyYXkoSy5nZXRTY2FsYXIoSy5lcHNpbG9uKCkpLCBjYWxjTDJOb3Jtcyh3LCBfdGhpcy5heGlzKSkpOyB9KTtcbiAgICB9O1xuICAgIFVuaXROb3JtLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGF4aXM6IHRoaXMuYXhpcyB9O1xuICAgIH07XG4gICAgVW5pdE5vcm0uY2xhc3NOYW1lID0gJ1VuaXROb3JtJztcbiAgICByZXR1cm4gVW5pdE5vcm07XG59KENvbnN0cmFpbnQpKTtcbmV4cG9ydHMuVW5pdE5vcm0gPSBVbml0Tm9ybTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihVbml0Tm9ybSk7XG52YXIgTm9uTmVnID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9uTmVnLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vbk5lZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOb25OZWcucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgcmV0dXJuIHRmYy5yZWx1KHcpO1xuICAgIH07XG4gICAgTm9uTmVnLmNsYXNzTmFtZSA9ICdOb25OZWcnO1xuICAgIHJldHVybiBOb25OZWc7XG59KENvbnN0cmFpbnQpKTtcbmV4cG9ydHMuTm9uTmVnID0gTm9uTmVnO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKE5vbk5lZyk7XG52YXIgTWluTWF4Tm9ybSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1pbk1heE5vcm0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWluTWF4Tm9ybShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVmYXVsdE1pblZhbHVlID0gMC4wO1xuICAgICAgICBfdGhpcy5kZWZhdWx0TWF4VmFsdWUgPSAxLjA7XG4gICAgICAgIF90aGlzLmRlZmF1bHRSYXRlID0gMS4wO1xuICAgICAgICBfdGhpcy5kZWZhdWx0QXhpcyA9IDA7XG4gICAgICAgIF90aGlzLm1pblZhbHVlID1cbiAgICAgICAgICAgIGNvbmZpZy5taW5WYWx1ZSAhPSBudWxsID8gY29uZmlnLm1pblZhbHVlIDogX3RoaXMuZGVmYXVsdE1pblZhbHVlO1xuICAgICAgICBfdGhpcy5tYXhWYWx1ZSA9XG4gICAgICAgICAgICBjb25maWcubWF4VmFsdWUgIT0gbnVsbCA/IGNvbmZpZy5tYXhWYWx1ZSA6IF90aGlzLmRlZmF1bHRNYXhWYWx1ZTtcbiAgICAgICAgX3RoaXMucmF0ZSA9IGNvbmZpZy5yYXRlICE9IG51bGwgPyBjb25maWcucmF0ZSA6IF90aGlzLmRlZmF1bHRSYXRlO1xuICAgICAgICBfdGhpcy5heGlzID0gY29uZmlnLmF4aXMgIT0gbnVsbCA/IGNvbmZpZy5heGlzIDogX3RoaXMuZGVmYXVsdEF4aXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWluTWF4Tm9ybS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAodykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9ybXMgPSBjYWxjTDJOb3Jtcyh3LCBfdGhpcy5heGlzKTtcbiAgICAgICAgICAgIHZhciBkZXNpcmVkID0gdGZjLmFkZChLLnNjYWxhclRpbWVzQXJyYXkoSy5nZXRTY2FsYXIoX3RoaXMucmF0ZSksIHRmYy5jbGlwQnlWYWx1ZShub3JtcywgX3RoaXMubWluVmFsdWUsIF90aGlzLm1heFZhbHVlKSksIEsuc2NhbGFyVGltZXNBcnJheShLLmdldFNjYWxhcigxLjAgLSBfdGhpcy5yYXRlKSwgbm9ybXMpKTtcbiAgICAgICAgICAgIHJldHVybiB0ZmMubXVsKHcsIHRmYy5kaXYoZGVzaXJlZCwgSy5zY2FsYXJQbHVzQXJyYXkoSy5nZXRTY2FsYXIoSy5lcHNpbG9uKCkpLCBub3JtcykpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNaW5NYXhOb3JtLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5WYWx1ZTogdGhpcy5taW5WYWx1ZSxcbiAgICAgICAgICAgIG1heFZhbHVlOiB0aGlzLm1heFZhbHVlLFxuICAgICAgICAgICAgcmF0ZTogdGhpcy5yYXRlLFxuICAgICAgICAgICAgYXhpczogdGhpcy5heGlzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNaW5NYXhOb3JtLmNsYXNzTmFtZSA9ICdNaW5NYXhOb3JtJztcbiAgICByZXR1cm4gTWluTWF4Tm9ybTtcbn0oQ29uc3RyYWludCkpO1xuZXhwb3J0cy5NaW5NYXhOb3JtID0gTWluTWF4Tm9ybTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihNaW5NYXhOb3JtKTtcbmV4cG9ydHMuQ09OU1RSQUlOVF9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVAgPSB7XG4gICAgJ21heE5vcm0nOiAnTWF4Tm9ybScsXG4gICAgJ21pbk1heE5vcm0nOiAnTWluTWF4Tm9ybScsXG4gICAgJ25vbk5lZyc6ICdOb25OZWcnLFxuICAgICd1bml0Tm9ybSc6ICdVbml0Tm9ybSdcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVDb25zdHJhaW50KGNvbnN0cmFpbnQpIHtcbiAgICByZXR1cm4gZ2VuZXJpY191dGlsc18xLnNlcmlhbGl6ZUtlcmFzT2JqZWN0KGNvbnN0cmFpbnQpO1xufVxuZXhwb3J0cy5zZXJpYWxpemVDb25zdHJhaW50ID0gc2VyaWFsaXplQ29uc3RyYWludDtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplQ29uc3RyYWludChjb25maWcsIGN1c3RvbU9iamVjdHMpIHtcbiAgICBpZiAoY3VzdG9tT2JqZWN0cyA9PT0gdm9pZCAwKSB7IGN1c3RvbU9iamVjdHMgPSB7fTsgfVxuICAgIHJldHVybiBnZW5lcmljX3V0aWxzXzEuZGVzZXJpYWxpemVLZXJhc09iamVjdChjb25maWcsIHRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsIGN1c3RvbU9iamVjdHMsICdjb25zdHJhaW50Jyk7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplQ29uc3RyYWludCA9IGRlc2VyaWFsaXplQ29uc3RyYWludDtcbmZ1bmN0aW9uIGdldENvbnN0cmFpbnQoaWRlbnRpZmllcikge1xuICAgIGlmIChpZGVudGlmaWVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGlkZW50aWZpZXIgaW4gZXhwb3J0cy5DT05TVFJBSU5UX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUCA/XG4gICAgICAgICAgICBleHBvcnRzLkNPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQW2lkZW50aWZpZXJdIDpcbiAgICAgICAgICAgIGlkZW50aWZpZXI7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBjb25maWc6IHt9IH07XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZUNvbnN0cmFpbnQoY29uZmlnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaWRlbnRpZmllciBpbnN0YW5jZW9mIENvbnN0cmFpbnQpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVDb25zdHJhaW50KGlkZW50aWZpZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Q29uc3RyYWludCA9IGdldENvbnN0cmFpbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdHJhaW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuL3RvcG9sb2d5XCIpO1xuZnVuY3Rpb24gYXNzZXJ0RmVlZENvbXBhdGliaWxpdHkoa2V5LCB2YWwpIHtcbiAgICBpZiAoa2V5LmR0eXBlICE9IG51bGwgJiYga2V5LmR0eXBlICE9PSB2YWwuZHR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgZHR5cGUgb2YgdGhlIGZlZWQgKFwiICsgdmFsLmR0eXBlICsgXCIpIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoYXQgb2YgXCIgK1xuICAgICAgICAgICAgKFwidGhlIGtleSAnXCIgKyBrZXkubmFtZSArIFwiJyAoXCIgKyBrZXkuZHR5cGUgKyBcIikuXCIpKTtcbiAgICB9XG4gICAgaWYgKGtleS5zaGFwZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChrZXkuc2hhcGUubGVuZ3RoICE9PSB2YWwuc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSByYW5rIG9mIGZlZWQgKFwiICsgdmFsLnNoYXBlLmxlbmd0aCArIFwiKSBkb2VzIG5vdCBtYXRjaCB0aGUgcmFuayBvZiBcIiArXG4gICAgICAgICAgICAgICAgKFwidGhlIGtleSAoXCIgKyBrZXkuc2hhcGUubGVuZ3RoICsgXCIpLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkuc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChrZXkuc2hhcGVbaV0gIT0gbnVsbCAmJiBrZXkuc2hhcGVbaV0gIT09IHZhbC5zaGFwZVtpXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIFwiICsgaSArIFwiLXRoIGRpbWVuc2lvbiBvZiB0aGUgZmVlZCAoXCIgKyB2YWwuc2hhcGVbaV0gKyBcIikgaXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJpbmNvbXBhdGlibGUgd2l0aCB0aGF0IG9mIHRoZSBrZXkgKFwiICsga2V5LnNoYXBlW2ldICsgXCIpLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgRmVlZERpY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZlZWREaWN0KGZlZWRzKSB7XG4gICAgICAgIHRoaXMuaWQyVmFsdWUgPSB7fTtcbiAgICAgICAgaWYgKGZlZWRzIGluc3RhbmNlb2YgRmVlZERpY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGZlZWRzLmlkMlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZDJWYWx1ZVtpZF0gPSBmZWVkcy5pZDJWYWx1ZVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmVlZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZmVlZHNfMSA9IGZlZWRzOyBfaSA8IGZlZWRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlZWQgPSBmZWVkc18xW19pXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChmZWVkLmtleSwgZmVlZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgRmVlZERpY3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5pZDJWYWx1ZVtrZXkuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQyVmFsdWVba2V5LmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJEdXBsaWNhdGUga2V5OiBuYW1lPVwiICsga2V5Lm5hbWUgKyBcIiwgaWQ9XCIgKyBrZXkuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRmVlZERpY3QucHJvdG90eXBlLmFkZEZlZWQgPSBmdW5jdGlvbiAoZmVlZCkge1xuICAgICAgICB0aGlzLmFkZChmZWVkLmtleSwgZmVlZC52YWx1ZSk7XG4gICAgfTtcbiAgICBGZWVkRGljdC5wcm90b3R5cGUuaGFzS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDJWYWx1ZVtrZXkuaWRdICE9IG51bGw7XG4gICAgfTtcbiAgICBGZWVkRGljdC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmlkMlZhbHVlW2tleS5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJOb25leGlzdGVudCBrZXk6IFwiICsgSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDJWYWx1ZVtrZXkuaWRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmVlZERpY3Q7XG59KCkpO1xuZXhwb3J0cy5GZWVkRGljdCA9IEZlZWREaWN0O1xuZnVuY3Rpb24gZXhlY3V0ZShmZXRjaGVzLCBmZWVkRGljdCwga3dhcmdzKSB7XG4gICAgdmFyIGFycmF5RmV0Y2hlcyA9IEFycmF5LmlzQXJyYXkoZmV0Y2hlcyk7XG4gICAgdmFyIGZldGNoQXJyYXkgPSBhcnJheUZldGNoZXMgPyBmZXRjaGVzIDogW2ZldGNoZXNdO1xuICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgdmFyIGludGVybmFsRmVlZERpY3QgPSBuZXcgRmVlZERpY3QoZmVlZERpY3QpO1xuICAgIGZvciAodmFyIF9pID0gMCwgZmV0Y2hBcnJheV8xID0gZmV0Y2hBcnJheTsgX2kgPCBmZXRjaEFycmF5XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBmZXRjaF8xID0gZmV0Y2hBcnJheV8xW19pXTtcbiAgICAgICAgb3V0cHV0cy5wdXNoKGV4ZWN1dGVJbnRlcm5hbChmZXRjaF8xLCBpbnRlcm5hbEZlZWREaWN0LCBrd2FyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5RmV0Y2hlcyA/IG91dHB1dHMgOiBvdXRwdXRzWzBdO1xufVxuZXhwb3J0cy5leGVjdXRlID0gZXhlY3V0ZTtcbmZ1bmN0aW9uIGV4ZWN1dGVJbnRlcm5hbChmZXRjaCwgaW50ZXJuYWxGZWVkRGljdCwga3dhcmdzKSB7XG4gICAgaWYgKGludGVybmFsRmVlZERpY3QuaGFzS2V5KGZldGNoKSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxGZWVkRGljdC5nZXRWYWx1ZShmZXRjaCk7XG4gICAgfVxuICAgIGlmIChmZXRjaC5zb3VyY2VMYXllciBpbnN0YW5jZW9mIHRvcG9sb2d5XzEuSW5wdXRMYXllcikge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIk1pc3NpbmcgYSBmZWVkIHZhbHVlIGZvciBTeW1ib2xpY1RlbnNvciBmcm9tIElucHV0TGF5ZXIgXCIgK1xuICAgICAgICAgICAgKFwiJ1wiICsgdG9wb2xvZ3lfMS5JbnB1dExheWVyLm5hbWUgKyBcIidcIikpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRzID0gZmV0Y2guaW5wdXRzO1xuICAgIHZhciBpbnB1dFZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRzXzEgPSBpbnB1dHM7IF9pIDwgaW5wdXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGlucHV0c18xW19pXTtcbiAgICAgICAgdmFyIGlucHV0VmFsID0gZXhlY3V0ZUludGVybmFsKGlucHV0LCBpbnRlcm5hbEZlZWREaWN0LCBrd2FyZ3MpO1xuICAgICAgICBpbnB1dFZhbHVlcy5wdXNoKGlucHV0VmFsKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGZldGNoLnNvdXJjZUxheWVyLmFwcGx5KGlucHV0VmFsdWVzLCBrd2FyZ3MpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvdXRwdXQpKSB7XG4gICAgICAgIG91dHB1dCA9IFtvdXRwdXRdO1xuICAgIH1cbiAgICB2YXIgbGF5ZXJPdXRwdXRzID0gZ2V0Tm9kZU91dHB1dHMoZmV0Y2gpO1xuICAgIHZhciBvdXRwdXRTeW1ib2xpY1RlbnNvcnMgPSBBcnJheS5pc0FycmF5KGxheWVyT3V0cHV0cykgPyBsYXllck91dHB1dHMgOiBbbGF5ZXJPdXRwdXRzXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFN5bWJvbGljVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnRlcm5hbEZlZWREaWN0LmFkZChvdXRwdXRTeW1ib2xpY1RlbnNvcnNbaV0sIG91dHB1dFtpXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID09PSAxID8gb3V0cHV0WzBdIDogb3V0cHV0W2ZldGNoLm91dHB1dFRlbnNvckluZGV4XTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVPdXRwdXRzKGZldGNoKSB7XG4gICAgdmFyIGxheWVyT3V0cHV0cztcbiAgICBpZiAoZmV0Y2guc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBsYXllck91dHB1dHMgPSBmZXRjaC5zb3VyY2VMYXllci5vdXRwdXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZXRjaC5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBmZXRjaC5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXNbaV1cbiAgICAgICAgICAgICAgICAub3V0cHV0VGVuc29yczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0VGVuc29yID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRUZW5zb3IuaWQgPT09IGZldGNoLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXllck91dHB1dHMgPSBmZXRjaC5zb3VyY2VMYXllci5nZXRPdXRwdXRBdChub2RlSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJPdXRwdXRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhlY3V0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgc2VyaWFsaXphdGlvbl8xID0gcmVxdWlyZShcIi4uL2xheWVycy9zZXJpYWxpemF0aW9uXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIHNlcmlhbGl6YXRpb25fdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zZXJpYWxpemF0aW9uX3V0aWxzXCIpO1xudmFyIHZhcmlhYmxlc18xID0gcmVxdWlyZShcIi4uL3ZhcmlhYmxlc1wiKTtcbnZhciB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi4vdmVyc2lvblwiKTtcbnZhciBJbnB1dFNwZWMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElucHV0U3BlYyhjb25maWcpIHtcbiAgICAgICAgdGhpcy5kdHlwZSA9IGNvbmZpZy5kdHlwZTtcbiAgICAgICAgdGhpcy5zaGFwZSA9IGNvbmZpZy5zaGFwZTtcbiAgICAgICAgaWYgKGNvbmZpZy5zaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5kaW0gPSBjb25maWcuc2hhcGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZGltID0gY29uZmlnLm5kaW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXhORGltID0gY29uZmlnLm1heE5EaW07XG4gICAgICAgIHRoaXMubWluTkRpbSA9IGNvbmZpZy5taW5ORGltO1xuICAgICAgICB0aGlzLmF4ZXMgPSBjb25maWcuYXhlcyB8fCB7fTtcbiAgICB9XG4gICAgcmV0dXJuIElucHV0U3BlYztcbn0oKSk7XG5leHBvcnRzLklucHV0U3BlYyA9IElucHV0U3BlYztcbnZhciBfbmV4dE5vZGVJRCA9IDA7XG52YXIgTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShjb25maWcsIGNhbGxBcmdzKSB7XG4gICAgICAgIHRoaXMuY2FsbEFyZ3MgPSBjYWxsQXJncztcbiAgICAgICAgdGhpcy5pZCA9IF9uZXh0Tm9kZUlEKys7XG4gICAgICAgIHRoaXMub3V0Ym91bmRMYXllciA9IGNvbmZpZy5vdXRib3VuZExheWVyO1xuICAgICAgICB0aGlzLmluYm91bmRMYXllcnMgPSBjb25maWcuaW5ib3VuZExheWVycztcbiAgICAgICAgdGhpcy5ub2RlSW5kaWNlcyA9IGNvbmZpZy5ub2RlSW5kaWNlcztcbiAgICAgICAgdGhpcy50ZW5zb3JJbmRpY2VzID0gY29uZmlnLnRlbnNvckluZGljZXM7XG4gICAgICAgIHRoaXMuaW5wdXRUZW5zb3JzID0gY29uZmlnLmlucHV0VGVuc29ycztcbiAgICAgICAgdGhpcy5vdXRwdXRUZW5zb3JzID0gY29uZmlnLm91dHB1dFRlbnNvcnM7XG4gICAgICAgIHRoaXMuaW5wdXRNYXNrcyA9IGNvbmZpZy5pbnB1dE1hc2tzO1xuICAgICAgICB0aGlzLm91dHB1dE1hc2tzID0gY29uZmlnLm91dHB1dE1hc2tzO1xuICAgICAgICB0aGlzLmlucHV0U2hhcGVzID0gY29uZmlnLmlucHV0U2hhcGVzO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlcyA9IGNvbmZpZy5vdXRwdXRTaGFwZXM7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb25maWcuaW5ib3VuZExheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChsYXllciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIub3V0Ym91bmROb2Rlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5vdXRib3VuZExheWVyLmluYm91bmROb2Rlcy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBOb2RlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmJvdW5kTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuaW5ib3VuZExheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChsYXllciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5ib3VuZE5hbWVzLnB1c2gobGF5ZXIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmJvdW5kTmFtZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3V0Ym91bmRMYXllcjogdGhpcy5vdXRib3VuZExheWVyID8gdGhpcy5vdXRib3VuZExheWVyLm5hbWUgOiBudWxsLFxuICAgICAgICAgICAgaW5ib3VuZExheWVyczogaW5ib3VuZE5hbWVzLFxuICAgICAgICAgICAgbm9kZUluZGljZXM6IHRoaXMubm9kZUluZGljZXMsXG4gICAgICAgICAgICB0ZW5zb3JJbmRpY2VzOiB0aGlzLnRlbnNvckluZGljZXNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG52YXIgX25leHRMYXllcklEID0gMDtcbnZhciBMYXllciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExheWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExheWVyKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY2FsbEhvb2sgPSBudWxsO1xuICAgICAgICBfdGhpcy5fYWRkZWRXZWlnaHROYW1lcyA9IFtdO1xuICAgICAgICBfdGhpcy5fc3RhdGVmdWwgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaWQgPSBfbmV4dExheWVySUQrKztcbiAgICAgICAgX3RoaXMuYWN0aXZpdHlSZWd1bGFyaXplciA9IG51bGw7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IG51bGw7XG4gICAgICAgIF90aGlzLnN1cHBvcnRzTWFza2luZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fdHJhaW5hYmxlV2VpZ2h0cyA9IFtdO1xuICAgICAgICBfdGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cyA9IFtdO1xuICAgICAgICBfdGhpcy5fbG9zc2VzID0gW107XG4gICAgICAgIF90aGlzLl91cGRhdGVzID0gW107XG4gICAgICAgIF90aGlzLl9idWlsdCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pbmJvdW5kTm9kZXMgPSBbXTtcbiAgICAgICAgX3RoaXMub3V0Ym91bmROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgbmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBfdGhpcy5nZXRDbGFzc05hbWUoKTtcbiAgICAgICAgICAgIG5hbWUgPSBnZW5lcmljX3V0aWxzLnRvU25ha2VDYXNlKHByZWZpeCkgKyAnXycgKyBLLmdldFVpZChwcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy50cmFpbmFibGUgPSBjb25maWcudHJhaW5hYmxlID09IG51bGwgPyB0cnVlIDogY29uZmlnLnRyYWluYWJsZTtcbiAgICAgICAgX3RoaXMudXBkYXRhYmxlID0gY29uZmlnLnVwZGF0YWJsZSA9PSBudWxsID8gdHJ1ZSA6IGNvbmZpZy51cGRhdGFibGU7XG4gICAgICAgIGlmIChjb25maWcuaW5wdXRTaGFwZSAhPSBudWxsIHx8IGNvbmZpZy5iYXRjaElucHV0U2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJhdGNoSW5wdXRTaGFwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChjb25maWcuYmF0Y2hJbnB1dFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBiYXRjaElucHV0U2hhcGUgPSBjb25maWcuYmF0Y2hJbnB1dFNoYXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmlucHV0U2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuYmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplID0gY29uZmlnLmJhdGNoU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmF0Y2hJbnB1dFNoYXBlID0gW2JhdGNoU2l6ZV0uY29uY2F0KGNvbmZpZy5pbnB1dFNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmJhdGNoSW5wdXRTaGFwZSA9IGJhdGNoSW5wdXRTaGFwZTtcbiAgICAgICAgICAgIHZhciBkdHlwZSA9IGNvbmZpZy5kdHlwZTtcbiAgICAgICAgICAgIGlmIChkdHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZHR5cGUgPSBjb25maWcuaW5wdXREVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkdHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZHR5cGUgPSBLLmZsb2F0eCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZHR5cGUgPSBkdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLndlaWdodHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMuaW5pdGlhbFdlaWdodHMgPSBjb25maWcud2VpZ2h0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmluaXRpYWxXZWlnaHRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExheWVyLm5vZGVLZXkgPSBmdW5jdGlvbiAobGF5ZXIsIG5vZGVJbmRleCkge1xuICAgICAgICByZXR1cm4gbGF5ZXIubmFtZSArICdfaWItJyArIG5vZGVJbmRleC50b1N0cmluZygpO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmdldE5vZGVBdEluZGV4ID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgYXR0ck5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJ1bnRpbWVFcnJvcignVGhlIGxheWVyIGhhcyBuZXZlciBiZWVuIGNhbGxlZCAnICtcbiAgICAgICAgICAgICAgICAoXCJhbmQgdGh1cyBoYXMgbm8gZGVmaW5lZCBcIiArIGF0dHJOYW1lICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoIDw9IG5vZGVJbmRleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJBc2tlZCB0byBnZXQgXCIgKyBhdHRyTmFtZSArIFwiIGF0IG5vZGUgXCIgKyBub2RlSW5kZXggKyBcIiwgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCB0aGUgbGF5ZXIgaGFzIG9ubHkgXCIgKyB0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggKyBcIiBpbmJvdW5kIG5vZGVzLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5ib3VuZE5vZGVzW25vZGVJbmRleF07XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuZ2V0SW5wdXRBdCA9IGZ1bmN0aW9uIChub2RlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KG5vZGVJbmRleCwgJ2lucHV0JykuaW5wdXRUZW5zb3JzKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5nZXRPdXRwdXRBdCA9IGZ1bmN0aW9uIChub2RlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KG5vZGVJbmRleCwgJ291dHB1dCcpLm91dHB1dFRlbnNvcnMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheWVyLnByb3RvdHlwZSwgXCJpbnB1dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIiArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMsICcgK1xuICAgICAgICAgICAgICAgICAgICAnaGVuY2UgdGhlIG5vdGlvbiBvZiBcImxheWVyIGlucHV0XCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdpcyBpbGwtZGVmaW5lZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgYGdldElucHV0QXQobm9kZUluZGV4KWAgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdHRyaWJ1dGVFcnJvcihcIkxheWVyIFwiICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJyBpcyBub3QgY29ubmVjdGVkLCBubyBpbnB1dCB0byByZXR1cm4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoMCwgJ2lucHV0JykuaW5wdXRUZW5zb3JzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheWVyLnByb3RvdHlwZSwgXCJvdXRwdXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIiArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcgaGFzIG5vIGluYm91bmQgbm9kZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdHRyaWJ1dGVFcnJvcihcIkxheWVyIFwiICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJyBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcywgJyArXG4gICAgICAgICAgICAgICAgICAgICdoZW5jZSB0aGUgbm90aW9uIG9mIFwibGF5ZXIgb3V0cHV0XCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdpcyBpbGwtZGVmaW5lZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgYGdldE91dHB1dEF0KG5vZGVJbmRleClgIGluc3RlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoMCwgJ291dHB1dCcpLm91dHB1dFRlbnNvcnMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5ZXIucHJvdG90eXBlLCBcImxvc3Nlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvc3NlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGF5ZXIucHJvdG90eXBlLmNhbGN1bGF0ZUxvc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc2VzLm1hcChmdW5jdGlvbiAobG9zc0ZuKSB7IHJldHVybiBsb3NzRm4oKTsgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5ZXIucHJvdG90eXBlLCBcInVwZGF0ZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5ZXIucHJvdG90eXBlLCBcImJ1aWx0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGJ1aWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9idWlsdCA9IGJ1aWx0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5ZXIucHJvdG90eXBlLCBcInRyYWluYWJsZVdlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWluYWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFpbmFibGVXZWlnaHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFpbmFibGVXZWlnaHRzID0gd2VpZ2h0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheWVyLnByb3RvdHlwZSwgXCJub25UcmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhaW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vblRyYWluYWJsZVdlaWdodHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHdlaWdodHMpIHtcbiAgICAgICAgICAgIHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMgPSB3ZWlnaHRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5ZXIucHJvdG90eXBlLCBcIndlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMubm9uVHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXllci5wcm90b3R5cGUsIFwic3RhdGVmdWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZWZ1bDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGF5ZXIucHJvdG90eXBlLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eSA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgaW5wdXRzID0gZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRzKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRTcGVjID09IG51bGwgfHwgdGhpcy5pbnB1dFNwZWMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0U3BlYyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KHRoaXMuaW5wdXRTcGVjKTtcbiAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IGlucHV0U3BlYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiTGF5ZXIgXCIgKyB0aGlzLm5hbWUgKyBcIiBleHBlY3RzIFwiICsgaW5wdXRTcGVjLmxlbmd0aCArIFwiIGlucHV0cywgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBpdCByZWNlaXZlZCBcIiArIGlucHV0cy5sZW5ndGggKyBcIiBpbnB1dCB0ZW5zb3JzLiBcIikgK1xuICAgICAgICAgICAgICAgIChcIklucHV0IHJlY2VpdmVkOiBcIiArIGlucHV0cykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGlucHV0SW5kZXggPSAwOyBpbnB1dEluZGV4IDwgaW5wdXRzLmxlbmd0aDsgaW5wdXRJbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGlucHV0c1tpbnB1dEluZGV4XTtcbiAgICAgICAgICAgIHZhciBzcGVjID0gaW5wdXRTcGVjW2lucHV0SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNwZWMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5kaW0gPSB4LnJhbms7XG4gICAgICAgICAgICBpZiAoc3BlYy5uZGltICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobmRpbSAhPT0gc3BlYy5uZGltKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW5wdXQgXCIgKyBpbnB1dEluZGV4ICsgXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIgKyB0aGlzLm5hbWUgKyBcIjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiZXhwZWN0ZWQgbmRpbT1cIiArIHNwZWMubmRpbSArIFwiLCBmb3VuZCBuZGltPVwiICsgbmRpbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGVjLm1heE5EaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChuZGltID4gc3BlYy5tYXhORGltKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW5wdXQgXCIgKyBpbnB1dEluZGV4ICsgXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiOiBleHBlY3RlZCBtYXhfbmRpbT1cIiArIHNwZWMubWF4TkRpbSArIFwiLCBmb3VuZCBuZGltPVwiICsgbmRpbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGVjLm1pbk5EaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChuZGltIDwgc3BlYy5taW5ORGltKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW5wdXQgXCIgKyBpbnB1dEluZGV4ICsgXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiOiBleHBlY3RlZCBtaW5fbmRpbT1cIiArIHNwZWMubWluTkRpbSArIFwiLCBmb3VuZCBuZGltPVwiICsgbmRpbSArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwZWMuZHR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChLLmR0eXBlKHgpICE9PSBzcGVjLmR0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4RFR5cGUgPSBLLmR0eXBlKHgpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklucHV0IFwiICsgaW5wdXRJbmRleCArIFwiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiICsgdGhpcy5uYW1lICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiOiBleHBlY3RlZCBkdHlwZT1cIiArIHNwZWMuZHR5cGUgKyBcIiwgZm91bmQgZHR5cGU9XCIgKyB4RFR5cGUgKyBcIi5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGVjLmF4ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgeFNoYXBlID0gSy5pbnRTaGFwZSh4KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3BlYy5heGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gTnVtYmVyKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNwZWMuYXhlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFNoYXBlQXRBeGlzID0gYXhpcyA+PSAwID8geFNoYXBlW2F4aXNdIDogeFNoYXBlW3hTaGFwZS5sZW5ndGggKyBheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgW3ZhbHVlLCBudWxsXS5pbmRleE9mKHhTaGFwZUF0QXhpcykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklucHV0IFwiICsgaW5wdXRJbmRleCArIFwiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5uYW1lICsgXCI6IGV4cGVjdGVkIGF4aXMgXCIgKyBheGlzICsgXCIgb2YgaW5wdXQgc2hhcGUgdG8gXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJoYXZlIHZhbHVlIFwiICsgdmFsdWUgKyBcIiBidXQgZ290IHNoYXBlIFwiICsgeFNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGVjLnNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgeFNoYXBlID0gSy5pbnRTaGFwZSh4KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWMuc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwZWNEaW0gPSBzcGVjLnNoYXBlW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltID0geFNoYXBlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY0RpbSAhPSBudWxsICYmIGRpbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY0RpbSAhPT0gZGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbnB1dCBcIiArIGlucHV0SW5kZXggKyBcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm5hbWUgKyBcIjogZXhwZWN0ZWQgc2hhcGU9XCIgKyBzcGVjLnNoYXBlICsgXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmb3VuZCBzaGFwZT0ke3hTaGFwZX0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuaW52b2tlQ2FsbEhvb2sgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxIb29rICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLnNldENhbGxIb29rID0gZnVuY3Rpb24gKGNhbGxIb29rKSB7XG4gICAgICAgIHRoaXMuX2NhbGxIb29rID0gY2FsbEhvb2s7XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuY2xlYXJDYWxsSG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2sgPSBudWxsO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGt3YXJncyA9IGt3YXJncyB8fCB7fTtcbiAgICAgICAgdmFyIGlucHV0c0xpc3QgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpO1xuICAgICAgICB2YXIgYWxsQXJlU3ltYm9saWMgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c0xpc3RfMSA9IGlucHV0c0xpc3Q7IF9pIDwgaW5wdXRzTGlzdF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzTGlzdF8xW19pXTtcbiAgICAgICAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgdHlwZXNfMS5TeW1ib2xpY1RlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBhbGxBcmVTeW1ib2xpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBub25lQXJlU3ltYm9saWMgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGlucHV0c0xpc3RfMiA9IGlucHV0c0xpc3Q7IF9hIDwgaW5wdXRzTGlzdF8yLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzTGlzdF8yW19hXTtcbiAgICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIHR5cGVzXzEuU3ltYm9saWNUZW5zb3IpIHtcbiAgICAgICAgICAgICAgICBub25lQXJlU3ltYm9saWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsQXJlU3ltYm9saWMgPT09IG5vbmVBcmVTeW1ib2xpYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0FyZ3VtZW50cyB0byBhcHBseSgpIG11c3QgYmUgYWxsICcgK1xuICAgICAgICAgICAgICAgICdTeW1ib2xpY1RlbnNvcnMgb3IgYWxsIFRlbnNvcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSy5uYW1lU2NvcGUodGhpcy5uYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmJ1aWx0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5KGlucHV0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0U2hhcGVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0cyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4RWxlbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRTaGFwZXMucHVzaChLLmludFNoYXBlKHhFbGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmJ1aWxkKGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShpbnB1dFNoYXBlcykpO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaW5pdGlhbFdlaWdodHMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0V2VpZ2h0cyhfdGhpcy5pbml0aWFsV2VpZ2h0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5KGlucHV0cyk7XG4gICAgICAgICAgICBpZiAobm9uZUFyZVN5bWJvbGljKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IF90aGlzLmNhbGwoaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRMaXN0ID0gZ2VuZXJpY191dGlscy50b0xpc3Qob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0TGlzdENvcHkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIG91dHB1dExpc3RfMSA9IG91dHB1dExpc3Q7IF9iIDwgb3V0cHV0TGlzdF8xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IG91dHB1dExpc3RfMVtfYl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHNMaXN0LmluZGV4T2YoeCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gSy5pZGVudGl0eSh4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRMaXN0Q29weS5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkob3V0cHV0TGlzdENvcHkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ0xheWVyIGludm9jYXRpb24gaW4gdGhlIHByZXNlbmNlIG9mIGFjdGl2aXR5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZ3VsYXJpemVyKHMpIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0U2hhcGUgPSBjb2xsZWN0SW5wdXRTaGFwZShpbnB1dHMpO1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IF90aGlzLmNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXREVHlwZV8xID0gZ3Vlc3NPdXRwdXREVHlwZShpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRTaGFwZSAhPSBudWxsICYmIG91dHB1dFNoYXBlLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvdXRwdXRTaGFwZVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNoYXBlLCBpbmRleCkgeyByZXR1cm4gbmV3IHR5cGVzXzEuU3ltYm9saWNUZW5zb3Iob3V0cHV0RFR5cGVfMSwgc2hhcGUsIF90aGlzLCBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpLCBrd2FyZ3MsIF90aGlzLm5hbWUsIGluZGV4KTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBuZXcgdHlwZXNfMS5TeW1ib2xpY1RlbnNvcihvdXRwdXREVHlwZV8xLCBvdXRwdXRTaGFwZSwgX3RoaXMsIGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0cyksIGt3YXJncywgX3RoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmFkZEluYm91bmROb2RlKGlucHV0cywgb3V0cHV0LCBudWxsLCBudWxsLCBpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSwga3dhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWN0aXZpdHlSZWd1bGFyaXplciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5nZXRXZWlnaHRzID0gZnVuY3Rpb24gKHRyYWluYWJsZU9ubHkpIHtcbiAgICAgICAgaWYgKHRyYWluYWJsZU9ubHkgPT09IHZvaWQgMCkgeyB0cmFpbmFibGVPbmx5ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlc18xLmJhdGNoR2V0VmFsdWUodHJhaW5hYmxlT25seSA/IHRoaXMudHJhaW5hYmxlV2VpZ2h0cyA6IHRoaXMud2VpZ2h0cyk7XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuc2V0V2VpZ2h0cyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IF90aGlzLndlaWdodHM7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gd2VpZ2h0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIllvdSBjYWxsZWQgc2V0V2VpZ2h0cyh3ZWlnaHRzKSBvbiBsYXllciBcXFwiXCIgKyBfdGhpcy5uYW1lICsgXCJcXFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwid2l0aCBhIHdlaWdodCBsaXN0IG9mIGxlbmd0aCBcIiArIHdlaWdodHMubGVuZ3RoICsgXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChcImJ1dCB0aGUgbGF5ZXIgd2FzIGV4cGVjdGluZyBcIiArIHBhcmFtcy5sZW5ndGggKyBcIiB3ZWlnaHRzLiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoXCJQcm92aWRlZCB3ZWlnaHRzOiBcIiArIHdlaWdodHMgKyBcIi4uLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3ZWlnaHRWYWx1ZVR1cGxlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHBhcmFtVmFsdWVzID0gdmFyaWFibGVzXzEuYmF0Y2hHZXRWYWx1ZShwYXJhbXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbVZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwdiA9IHBhcmFtVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBwID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgIHZhciB3ID0gd2VpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRmanNfY29yZV8xLnV0aWwuYXJyYXlzRXF1YWwocHYuc2hhcGUsIHcuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiTGF5ZXIgd2VpZ2h0IHNoYXBlIFwiICsgcHYuc2hhcGUgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJub3QgY29tcGF0aWJsZSB3aXRoIHByb3ZpZGVkIHdlaWdodCBzaGFwZSBcIiArIHcuc2hhcGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2VpZ2h0VmFsdWVUdXBsZXMucHVzaChbcCwgd10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyaWFibGVzXzEuYmF0Y2hTZXRWYWx1ZSh3ZWlnaHRWYWx1ZVR1cGxlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmFkZFdlaWdodCA9IGZ1bmN0aW9uIChuYW1lLCBzaGFwZSwgZHR5cGUsIGluaXRpYWxpemVyLCByZWd1bGFyaXplciwgdHJhaW5hYmxlLCBjb25zdHJhaW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9hZGRlZFdlaWdodE5hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSB3ZWlnaHQgbmFtZSBcIiArIG5hbWUgKyBcIiBmb3IgbGF5ZXIgXCIgKyB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZGVkV2VpZ2h0TmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgaWYgKGR0eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIGR0eXBlID0gSy5mbG9hdHgoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2VpZ2h0ID0gbmV3IHZhcmlhYmxlc18xLkxheWVyVmFyaWFibGUoaW5pdGlhbGl6ZXIuYXBwbHkoc2hhcGUsIGR0eXBlKSwgZHR5cGUsIG5hbWUsIHRyYWluYWJsZSwgY29uc3RyYWludCk7XG4gICAgICAgIGlmIChyZWd1bGFyaXplciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZExvc3MoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVndWxhcml6ZXIuYXBwbHkod2VpZ2h0LnJlYWQoKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFpbmFibGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhaW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhaW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFpbmFibGVXZWlnaHRzLnB1c2god2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMucHVzaCh3ZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWlnaHQ7XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuYWRkTG9zcyA9IGZ1bmN0aW9uIChsb3NzZXMpIHtcbiAgICAgICAgaWYgKGxvc3NlcyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobG9zc2VzKSAmJiBsb3NzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9zc2VzID0gZ2VuZXJpY191dGlscy50b0xpc3QobG9zc2VzKTtcbiAgICAgICAgaWYgKHRoaXMuX2xvc3NlcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2xvc3NlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5sb3NzZXMpLnB1c2guYXBwbHkoX2EsIGxvc3Nlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dFNoYXBlO1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmNvbXB1dGVNYXNrID0gZnVuY3Rpb24gKGlucHV0cywgbWFzaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNNYXNraW5nKSB7XG4gICAgICAgICAgICBpZiAobWFzayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFzaykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFzay5mb3JFYWNoKGZ1bmN0aW9uIChtYXNrRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGF5ZXIgXCIgKyBfdGhpcy5uYW1lICsgXCIgZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nLFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2J1dCB3YXMgcGFzc2VkIGFuIGlucHV0TWFzay4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGF5ZXIgXCIgKyB0aGlzLm5hbWUgKyBcIiBkb2VzIG5vdCBzdXBwb3J0IG1hc2tpbmcsXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1dCB3YXMgcGFzc2VkIGFuIGlucHV0TWFzay4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFzaztcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5hZGRJbmJvdW5kTm9kZSA9IGZ1bmN0aW9uIChpbnB1dFRlbnNvcnMsIG91dHB1dFRlbnNvcnMsIGlucHV0TWFza3MsIG91dHB1dE1hc2tzLCBpbnB1dFNoYXBlcywgb3V0cHV0U2hhcGVzLCBrd2FyZ3MpIHtcbiAgICAgICAgaWYgKGt3YXJncyA9PT0gdm9pZCAwKSB7IGt3YXJncyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGlucHV0VGVuc29yTGlzdCA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0VGVuc29ycyk7XG4gICAgICAgIG91dHB1dFRlbnNvcnMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChvdXRwdXRUZW5zb3JzKTtcbiAgICAgICAgaW5wdXRNYXNrcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0TWFza3MpO1xuICAgICAgICBvdXRwdXRNYXNrcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KG91dHB1dE1hc2tzKTtcbiAgICAgICAgaW5wdXRTaGFwZXMgPSBnZW5lcmljX3V0aWxzLm5vcm1hbGl6ZVNoYXBlTGlzdChpbnB1dFNoYXBlcyk7XG4gICAgICAgIG91dHB1dFNoYXBlcyA9IGdlbmVyaWNfdXRpbHMubm9ybWFsaXplU2hhcGVMaXN0KG91dHB1dFNoYXBlcyk7XG4gICAgICAgIHZhciBpbmJvdW5kTGF5ZXJzID0gW107XG4gICAgICAgIHZhciBub2RlSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgdGVuc29ySW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0VGVuc29yTGlzdF8xID0gaW5wdXRUZW5zb3JMaXN0OyBfaSA8IGlucHV0VGVuc29yTGlzdF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHggPSBpbnB1dFRlbnNvckxpc3RfMVtfaV07XG4gICAgICAgICAgICBpbmJvdW5kTGF5ZXJzLnB1c2goeC5zb3VyY2VMYXllcik7XG4gICAgICAgICAgICBub2RlSW5kaWNlcy5wdXNoKHgubm9kZUluZGV4KTtcbiAgICAgICAgICAgIHRlbnNvckluZGljZXMucHVzaCh4LnRlbnNvckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBuZXcgTm9kZSh7XG4gICAgICAgICAgICBvdXRib3VuZExheWVyOiB0aGlzLFxuICAgICAgICAgICAgaW5ib3VuZExheWVyczogaW5ib3VuZExheWVycyxcbiAgICAgICAgICAgIG5vZGVJbmRpY2VzOiBub2RlSW5kaWNlcyxcbiAgICAgICAgICAgIHRlbnNvckluZGljZXM6IHRlbnNvckluZGljZXMsXG4gICAgICAgICAgICBpbnB1dFRlbnNvcnM6IGlucHV0VGVuc29yTGlzdCxcbiAgICAgICAgICAgIG91dHB1dFRlbnNvcnM6IG91dHB1dFRlbnNvcnMsXG4gICAgICAgICAgICBpbnB1dE1hc2tzOiBpbnB1dE1hc2tzLFxuICAgICAgICAgICAgb3V0cHV0TWFza3M6IG91dHB1dE1hc2tzLFxuICAgICAgICAgICAgaW5wdXRTaGFwZXM6IGlucHV0U2hhcGVzLFxuICAgICAgICAgICAgb3V0cHV0U2hhcGVzOiBvdXRwdXRTaGFwZXNcbiAgICAgICAgfSwga3dhcmdzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRUZW5zb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLnNvdXJjZUxheWVyID0gdGhpcztcbiAgICAgICAgICAgIG91dHB1dFRlbnNvcnNbaV0ubm9kZUluZGV4ID0gdGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIG91dHB1dFRlbnNvcnNbaV0udGVuc29ySW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXllci5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0geyBuYW1lOiB0aGlzLm5hbWUsIHRyYWluYWJsZTogdGhpcy50cmFpbmFibGUgfTtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hJbnB1dFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZ1snYmF0Y2hJbnB1dFNoYXBlJ10gPSB0aGlzLmJhdGNoSW5wdXRTaGFwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kdHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWdbJ2R0eXBlJ10gPSB0aGlzLmR0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsICdzdWJoZWFkaW5nJzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgTGF5ZXIucHJvdG90eXBlLCBcImFwcGx5XCIsIG51bGwpO1xuICAgIExheWVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdMYXllcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIG5hbWVzcGFjZTogJ2xheWVycycgfSlcbiAgICBdLCBMYXllcik7XG4gICAgcmV0dXJuIExheWVyO1xufSh0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSkpO1xuZXhwb3J0cy5MYXllciA9IExheWVyO1xuZnVuY3Rpb24gY29sbGVjdElucHV0U2hhcGUoaW5wdXRUZW5zb3JzKSB7XG4gICAgaW5wdXRUZW5zb3JzID1cbiAgICAgICAgZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRUZW5zb3JzKTtcbiAgICB2YXIgc2hhcGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dFRlbnNvcnNfMSA9IGlucHV0VGVuc29yczsgX2kgPCBpbnB1dFRlbnNvcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHggPSBpbnB1dFRlbnNvcnNfMVtfaV07XG4gICAgICAgIHNoYXBlcy5wdXNoKEsuaW50U2hhcGUoeCkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KHNoYXBlcyk7XG59XG5mdW5jdGlvbiBndWVzc091dHB1dERUeXBlKGlucHV0VGVuc29ycykge1xuICAgIHJldHVybiAnZmxvYXQzMic7XG59XG52YXIgSW5wdXRMYXllciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElucHV0TGF5ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5wdXRMYXllcihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZHR5cGU6IGNvbmZpZy5kdHlwZSxcbiAgICAgICAgICAgIG5hbWU6IGNvbmZpZy5uYW1lICE9IG51bGwgPyBjb25maWcubmFtZSA6IEsuZ2V0VWlkKCdpbnB1dCcpLnRvU3RyaW5nKClcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZy5iYXRjaFNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLmJhdGNoU2l6ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5zcGFyc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLnNwYXJzZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnRyYWluYWJsZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5idWlsdCA9IHRydWU7XG4gICAgICAgIF90aGlzLnNwYXJzZSA9IGNvbmZpZy5zcGFyc2U7XG4gICAgICAgIGlmIChjb25maWcuaW5wdXRTaGFwZSAhPSBudWxsICYmIGNvbmZpZy5iYXRjaElucHV0U2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ09ubHkgcHJvdmlkZSB0aGUgaW5wdXRTaGFwZSBPUiAnICtcbiAgICAgICAgICAgICAgICAnYmF0Y2hJbnB1dFNoYXBlIGFyZ3VtZW50IHRvIGlucHV0TGF5ZXIsIG5vdCBib3RoIGF0IHRoZSBzYW1lIHRpbWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhdGNoSW5wdXRTaGFwZSA9IGNvbmZpZy5iYXRjaElucHV0U2hhcGU7XG4gICAgICAgIGlmIChiYXRjaElucHV0U2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5pbnB1dFNoYXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQW4gSW5wdXRMYXllciBzaG91bGQgYmUgcGFzc2VkIGVpdGhlciBhICcgK1xuICAgICAgICAgICAgICAgICAgICAnYGJhdGNoSW5wdXRTaGFwZWAgb3IgYW4gYGlucHV0U2hhcGVgLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hJbnB1dFNoYXBlID0gW2NvbmZpZy5iYXRjaFNpemVdLmNvbmNhdChjb25maWcuaW5wdXRTaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmJhdGNoU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0Nhbm5vdCBzcGVjaWZ5IGJhdGNoU2l6ZSBpZiBiYXRjaElucHV0U2hhcGUgaXMnICtcbiAgICAgICAgICAgICAgICAgICAgJ3NwZWNpZmllZCB3aGVuIGNyZWF0aW5nIGFuIElucHV0TGF5ZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR0eXBlID0gY29uZmlnLmR0eXBlIHx8IEsuZmxvYXR4KCk7XG4gICAgICAgIF90aGlzLmJhdGNoSW5wdXRTaGFwZSA9IGJhdGNoSW5wdXRTaGFwZTtcbiAgICAgICAgX3RoaXMuZHR5cGUgPSBkdHlwZTtcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW3sgc2hhcGU6IGJhdGNoSW5wdXRTaGFwZSB9XTtcbiAgICAgICAgdmFyIGlucHV0VGVuc29yID0gbmV3IHR5cGVzXzEuU3ltYm9saWNUZW5zb3IoX3RoaXMuZHR5cGUsIF90aGlzLmJhdGNoSW5wdXRTaGFwZSwgX3RoaXMsIFtdLCB7fSwgX3RoaXMubmFtZSk7XG4gICAgICAgIGlucHV0VGVuc29yLm5vZGVJbmRleCA9IDA7XG4gICAgICAgIGlucHV0VGVuc29yLnRlbnNvckluZGV4ID0gMDtcbiAgICAgICAgbmV3IE5vZGUoe1xuICAgICAgICAgICAgb3V0Ym91bmRMYXllcjogX3RoaXMsXG4gICAgICAgICAgICBpbmJvdW5kTGF5ZXJzOiBbXSxcbiAgICAgICAgICAgIG5vZGVJbmRpY2VzOiBbXSxcbiAgICAgICAgICAgIHRlbnNvckluZGljZXM6IFtdLFxuICAgICAgICAgICAgaW5wdXRUZW5zb3JzOiBbaW5wdXRUZW5zb3JdLFxuICAgICAgICAgICAgb3V0cHV0VGVuc29yczogW2lucHV0VGVuc29yXSxcbiAgICAgICAgICAgIGlucHV0TWFza3M6IFtudWxsXSxcbiAgICAgICAgICAgIG91dHB1dE1hc2tzOiBbbnVsbF0sXG4gICAgICAgICAgICBpbnB1dFNoYXBlczogW2JhdGNoSW5wdXRTaGFwZV0sXG4gICAgICAgICAgICBvdXRwdXRTaGFwZXM6IFtiYXRjaElucHV0U2hhcGVdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIElucHV0TGF5ZXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdDYW5ub3QgcGFzcyBhbnkgaW5wdXQgdG8gYW4gJyArXG4gICAgICAgICAgICAoXCJJbnB1dExheWVyJ3MgYXBwbHkoKSBtZXRob2QuIElucHV0TGF5ZXIgbmFtZTogXCIgKyB0aGlzLm5hbWUpKTtcbiAgICB9O1xuICAgIElucHV0TGF5ZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhdGNoSW5wdXRTaGFwZTogdGhpcy5iYXRjaElucHV0U2hhcGUsXG4gICAgICAgICAgICBkdHlwZTogdGhpcy5kdHlwZSxcbiAgICAgICAgICAgIHNwYXJzZTogdGhpcy5zcGFyc2UsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIElucHV0TGF5ZXIuY2xhc3NOYW1lID0gJ0lucHV0TGF5ZXInO1xuICAgIHJldHVybiBJbnB1dExheWVyO1xufShMYXllcikpO1xuZXhwb3J0cy5JbnB1dExheWVyID0gSW5wdXRMYXllcjtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihJbnB1dExheWVyKTtcbmZ1bmN0aW9uIElucHV0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcuYmF0Y2hTaGFwZSA9PSBudWxsICYmIGNvbmZpZy5zaGFwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgdG8gSW5wdXQgZWl0aGVyIGEgYHNoYXBlYCcgK1xuICAgICAgICAgICAgJyBvciBhIGBiYXRjaFNoYXBlYCBhcmd1bWVudC4gTm90ZSB0aGF0ICcgK1xuICAgICAgICAgICAgJ2BzaGFwZWAgZG9lcyBub3QgaW5jbHVkZSB0aGUgYmF0Y2ggJyArXG4gICAgICAgICAgICAnZGltZW5zaW9uLicpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmJhdGNoU2hhcGUgIT0gbnVsbCAmJiBjb25maWcuc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHNoYXBlYCBvciBgYmF0Y2hTaGFwZWAgJyArXG4gICAgICAgICAgICAnYXJndW1lbnQgdG8gSW5wdXQsIGJ1dCBub3QgYm90aC4nKTtcbiAgICB9XG4gICAgdmFyIGJhdGNoU2hhcGUgPSBjb25maWcuYmF0Y2hTaGFwZTtcbiAgICBpZiAoY29uZmlnLnNoYXBlICE9IG51bGwgJiYgYmF0Y2hTaGFwZSA9PSBudWxsKSB7XG4gICAgICAgIGJhdGNoU2hhcGUgPSBbbnVsbF0uY29uY2F0KGNvbmZpZy5zaGFwZSk7XG4gICAgfVxuICAgIHZhciBkdHlwZSA9IGNvbmZpZy5kdHlwZTtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCkge1xuICAgICAgICBkdHlwZSA9IEsuZmxvYXR4KCk7XG4gICAgfVxuICAgIHZhciBpbnB1dExheWVyID0gbmV3IElucHV0TGF5ZXIoe1xuICAgICAgICBiYXRjaElucHV0U2hhcGU6IGJhdGNoU2hhcGUsXG4gICAgICAgIG5hbWU6IGNvbmZpZy5uYW1lLFxuICAgICAgICBkdHlwZTogZHR5cGUsXG4gICAgICAgIHNwYXJzZTogY29uZmlnLnNwYXJzZVxuICAgIH0pO1xuICAgIHZhciBvdXRwdXRzID0gaW5wdXRMYXllci5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycztcbiAgICByZXR1cm4gb3V0cHV0c1swXTtcbn1cbmV4cG9ydHMuSW5wdXQgPSBJbnB1dDtcbnZhciBDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250YWluZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7fSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29udGFpbmVyTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgaWYgKF90aGlzLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IF90aGlzLmdldENsYXNzTmFtZSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gSy5nZXRVaWQocHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zdXBwb3J0c01hc2tpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMudHJhaW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudXBkYXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmlucHV0cykpIHtcbiAgICAgICAgICAgIF90aGlzLmlucHV0cyA9IGNvbmZpZy5pbnB1dHMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmlucHV0cyA9IFtjb25maWcuaW5wdXRzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcub3V0cHV0cykpIHtcbiAgICAgICAgICAgIF90aGlzLm91dHB1dHMgPSBjb25maWcub3V0cHV0cy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMub3V0cHV0cyA9IFtjb25maWcub3V0cHV0c107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVyaWNfdXRpbHMudW5pcXVlKF90aGlzLmlucHV0cykubGVuZ3RoICE9PSBfdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignVGhlIGxpc3Qgb2YgaW5wdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgJyArXG4gICAgICAgICAgICAgICAgJ3JlZHVuZGFudC4gQWxsIGlucHV0cyBzaG91bGQgb25seSBhcHBlYXIgb25jZS4gRm91bmQ6ICcgK1xuICAgICAgICAgICAgICAgIF90aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubmFtZTsgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmljX3V0aWxzLnVuaXF1ZShfdGhpcy5vdXRwdXRzKS5sZW5ndGggIT09IF90aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBsaXN0IG9mIG91dHB1dHMgcGFzc2VkIHRvIHRoZSBtb2RlbCBpcyByZWR1bmRhbnQuICcgK1xuICAgICAgICAgICAgICAgICdBbGwgb3V0cHV0cyBzaG91bGQgb25seSBhcHBlYXIgb25jZS4gRm91bmQ6ICcgK1xuICAgICAgICAgICAgICAgIF90aGlzLm91dHB1dHMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWU7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pbnB1dExheWVycyA9IFtdO1xuICAgICAgICBfdGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzID0gW107XG4gICAgICAgIF90aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcyA9IFtdO1xuICAgICAgICBfdGhpcy5vdXRwdXRMYXllcnMgPSBbXTtcbiAgICAgICAgX3RoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMgPSBbXTtcbiAgICAgICAgX3RoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcyA9IFtdO1xuICAgICAgICBfdGhpcy5sYXllcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF90aGlzLm91dHB1dHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHguc291cmNlTGF5ZXI7XG4gICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0geC5ub2RlSW5kZXg7XG4gICAgICAgICAgICB2YXIgdGVuc29ySW5kZXggPSB4LnRlbnNvckluZGV4O1xuICAgICAgICAgICAgX3RoaXMub3V0cHV0TGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgX3RoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMucHVzaChub2RlSW5kZXgpO1xuICAgICAgICAgICAgX3RoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcy5wdXNoKHRlbnNvckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gX3RoaXMuaW5wdXRzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIHggPSBfY1tfYl07XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB4LnNvdXJjZUxheWVyO1xuICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHgubm9kZUluZGV4O1xuICAgICAgICAgICAgdmFyIHRlbnNvckluZGV4ID0geC50ZW5zb3JJbmRleDtcbiAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KG5vZGVJbmRleCA9PT0gMCwgJ2lucHV0IGxheWVyIGhhcyA+MSBub2RlcycpO1xuICAgICAgICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQodGVuc29ySW5kZXggPT09IDAsICdpbnB1dCBsYXllciBoYXMgPjEgdGVuc29ycycpO1xuICAgICAgICAgICAgX3RoaXMuaW5wdXRMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgICBfdGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzLnB1c2gobm9kZUluZGV4KTtcbiAgICAgICAgICAgIF90aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcy5wdXNoKHRlbnNvckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pbnB1dE5hbWVzID0gW107XG4gICAgICAgIF90aGlzLm91dHB1dE5hbWVzID0gW107XG4gICAgICAgIF90aGlzLmZlZWRJbnB1dFNoYXBlcyA9IFtdO1xuICAgICAgICBfdGhpcy5mZWVkSW5wdXROYW1lcyA9IFtdO1xuICAgICAgICBfdGhpcy5mZWVkT3V0cHV0TmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5pbnB1dExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gX3RoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICAgICAgICBpZiAoIShsYXllciBpbnN0YW5jZW9mIElucHV0TGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgbGF5ZXJzIHRvIGEgTW9kZWwgbXVzdCBiZSBJbnB1dExheWVyIG9iamVjdHMuICcgK1xuICAgICAgICAgICAgICAgICAgICAoXCJSZWNlaXZlZCBpbnB1dHM6IFwiICsgY29uZmlnLmlucHV0cyArIFwiLiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoXCJJbnB1dCBcIiArIGkgKyBcIiAoMC1iYXNlZCkgb3JpZ2luYXRlcyBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoXCJmcm9tIGxheWVyIHR5cGUgXCIgKyBsYXllci5nZXRDbGFzc05hbWUoKSArIFwiLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5pbnB1dE5hbWVzLnB1c2gobGF5ZXIubmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5mZWVkSW5wdXRTaGFwZXMucHVzaChsYXllci5iYXRjaElucHV0U2hhcGUpO1xuICAgICAgICAgICAgX3RoaXMuZmVlZElucHV0TmFtZXMucHVzaChsYXllci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gX3RoaXMub3V0cHV0TGF5ZXJzOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gX2VbX2RdO1xuICAgICAgICAgICAgX3RoaXMub3V0cHV0TmFtZXMucHVzaChsYXllci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pbnRlcm5hbElucHV0U2hhcGVzID0gX3RoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZTsgfSk7XG4gICAgICAgIF90aGlzLmludGVybmFsT3V0cHV0U2hhcGVzID0gX3RoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGU7IH0pO1xuICAgICAgICB2YXIgbm9kZXNEZXB0aHMgPSB7fTtcbiAgICAgICAgdmFyIG5vZGVJRFRvTm9kZSA9IHt9O1xuICAgICAgICB2YXIgbGF5ZXJzRGVwdGhzID0ge307XG4gICAgICAgIHZhciBsYXllcklEVG9MYXllciA9IHt9O1xuICAgICAgICB2YXIgbGF5ZXJJbmRpY2VzID0ge307XG4gICAgICAgIHZhciBub2Rlc0luRGVjcmVhc2luZ0RlcHRoID0gW107XG4gICAgICAgIHZhciBidWlsZE1hcE9mR3JhcGggPSBmdW5jdGlvbiAodGVuc29yLCBmaW5pc2hlZE5vZGVzLCBub2Rlc0luUHJvZ3Jlc3MsIGxheWVyLCBub2RlSW5kZXgsIHRlbnNvckluZGV4KSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIgPT0gbnVsbCB8fCBub2RlSW5kZXggPT0gbnVsbCB8fCB0ZW5zb3JJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0ZW5zb3Iuc291cmNlTGF5ZXI7XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gdGVuc29yLm5vZGVJbmRleDtcbiAgICAgICAgICAgICAgICB0ZW5zb3JJbmRleCA9IHRlbnNvci50ZW5zb3JJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gbGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF07XG4gICAgICAgICAgICBpZiAobm9kZXNJblByb2dyZXNzLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJ1bnRpbWVFcnJvcihcIlRoZSB0ZW5zb3IgXCIgKyB0ZW5zb3IubmFtZSArIFwiIGF0IGxheWVyIFxcXCJcIiArIGxheWVyLm5hbWUgKyBcIlxcXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAnaXMgcGFydCBvZiBhIGN5Y2xlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkTm9kZXMuaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jb250YWluZXJOb2Rlcy5hZGQoQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG5vZGVJbmRleCkpO1xuICAgICAgICAgICAgaWYgKCEobGF5ZXIuaWQgaW4gbGF5ZXJJbmRpY2VzKSkge1xuICAgICAgICAgICAgICAgIGxheWVySW5kaWNlc1tsYXllci5pZF0gPSBPYmplY3Qua2V5cyhsYXllckluZGljZXMpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2Rlc0luUHJvZ3Jlc3MuaW5kZXhPZihub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBub2Rlc0luUHJvZ3Jlc3MucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1JbmJvdW5kTGF5ZXJzID0gbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtSW5ib3VuZExheWVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBub2RlLmlucHV0VGVuc29yc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJfMSA9IG5vZGUuaW5ib3VuZExheWVyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4XzEgPSBub2RlLm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0ZW5zb3JJbmRleF8xID0gbm9kZS50ZW5zb3JJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIGJ1aWxkTWFwT2ZHcmFwaCh4LCBmaW5pc2hlZE5vZGVzLCBub2Rlc0luUHJvZ3Jlc3MsIGxheWVyXzEsIG5vZGVJbmRleF8xLCB0ZW5zb3JJbmRleF8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmlzaGVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIHdoaWxlIChub2Rlc0luUHJvZ3Jlc3MuaW5kZXhPZihub2RlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNJblByb2dyZXNzLnNwbGljZShub2Rlc0luUHJvZ3Jlc3MuaW5kZXhPZihub2RlKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlc0luRGVjcmVhc2luZ0RlcHRoLnB1c2gobm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmaW5pc2hlZE5vZGVzID0gW107XG4gICAgICAgIHZhciBub2Rlc0luUHJvZ3Jlc3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2YgPSAwLCBfZyA9IF90aGlzLm91dHB1dHM7IF9mIDwgX2cubGVuZ3RoOyBfZisrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IF9nW19mXTtcbiAgICAgICAgICAgIGJ1aWxkTWFwT2ZHcmFwaCh4LCBmaW5pc2hlZE5vZGVzLCBub2Rlc0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXZlcnNlZE5vZGVzSW5EZWNyZWFzaW5nRGVwdGggPSBub2Rlc0luRGVjcmVhc2luZ0RlcHRoLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICBmb3IgKHZhciBfaCA9IDAsIHJldmVyc2VkTm9kZXNJbkRlY3JlYXNpbmdEZXB0aF8xID0gcmV2ZXJzZWROb2Rlc0luRGVjcmVhc2luZ0RlcHRoOyBfaCA8IHJldmVyc2VkTm9kZXNJbkRlY3JlYXNpbmdEZXB0aF8xLmxlbmd0aDsgX2grKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSByZXZlcnNlZE5vZGVzSW5EZWNyZWFzaW5nRGVwdGhfMVtfaF07XG4gICAgICAgICAgICBub2RlSURUb05vZGVbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAgICAgaWYgKCEobm9kZS5pZCBpbiBub2Rlc0RlcHRocykpIHtcbiAgICAgICAgICAgICAgICBub2Rlc0RlcHRoc1tub2RlLmlkXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBub2Rlc0RlcHRoc1tub2RlLmlkXTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0RlcHRoID0gKGxheWVyc0RlcHRoc1tub2RlLm91dGJvdW5kTGF5ZXIuaWRdID09IG51bGwgP1xuICAgICAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgICAgIGxheWVyc0RlcHRoc1tub2RlLm91dGJvdW5kTGF5ZXIuaWRdKTtcbiAgICAgICAgICAgIGRlcHRoID0gTWF0aC5tYXgoZGVwdGgsIHByZXZpb3VzRGVwdGgpO1xuICAgICAgICAgICAgbGF5ZXJzRGVwdGhzW25vZGUub3V0Ym91bmRMYXllci5pZF0gPSBkZXB0aDtcbiAgICAgICAgICAgIGxheWVySURUb0xheWVyW25vZGUub3V0Ym91bmRMYXllci5pZF0gPSBub2RlLm91dGJvdW5kTGF5ZXI7XG4gICAgICAgICAgICBub2Rlc0RlcHRoc1tub2RlLmlkXSA9IGRlcHRoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmluYm91bmRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5ib3VuZExheWVyID0gbm9kZS5pbmJvdW5kTGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBub2RlLm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBpbmJvdW5kTm9kZSA9IGluYm91bmRMYXllci5pbmJvdW5kTm9kZXNbbm9kZUluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNEZXB0aF8xID0gKG5vZGVzRGVwdGhzW2luYm91bmROb2RlLmlkXSA9PSBudWxsID8gMCA6XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzRGVwdGhzW2luYm91bmROb2RlLmlkXSk7XG4gICAgICAgICAgICAgICAgbm9kZXNEZXB0aHNbaW5ib3VuZE5vZGUuaWRdID0gTWF0aC5tYXgoZGVwdGggKyAxLCBwcmV2aW91c0RlcHRoXzEpO1xuICAgICAgICAgICAgICAgIG5vZGVJRFRvTm9kZVtpbmJvdW5kTm9kZS5pZF0gPSBpbmJvdW5kTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZXNCeURlcHRoID0ge307XG4gICAgICAgIGZvciAodmFyIG5vZGVJRCBpbiBub2Rlc0RlcHRocykge1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gbm9kZXNEZXB0aHNbbm9kZUlEXTtcbiAgICAgICAgICAgIGlmICghKGRlcHRoIGluIG5vZGVzQnlEZXB0aCkpIHtcbiAgICAgICAgICAgICAgICBub2Rlc0J5RGVwdGhbZGVwdGhdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlc0J5RGVwdGhbZGVwdGhdLnB1c2gobm9kZUlEVG9Ob2RlW25vZGVJRF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXllcnNCeURlcHRoID0ge307XG4gICAgICAgIGZvciAodmFyIGxheWVySUQgaW4gbGF5ZXJzRGVwdGhzKSB7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBsYXllcnNEZXB0aHNbbGF5ZXJJRF07XG4gICAgICAgICAgICBpZiAoIShkZXB0aCBpbiBsYXllcnNCeURlcHRoKSkge1xuICAgICAgICAgICAgICAgIGxheWVyc0J5RGVwdGhbZGVwdGhdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllcnNCeURlcHRoW2RlcHRoXS5wdXNoKGxheWVySURUb0xheWVyW2xheWVySURdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVwdGhLZXlzID0gT2JqZWN0LmtleXMobGF5ZXJzQnlEZXB0aClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTsgfSlcbiAgICAgICAgICAgIC5zb3J0KGdlbmVyaWNfdXRpbHMucmV2ZXJzZU51bWJlckNvbXBhcmUpO1xuICAgICAgICBfdGhpcy5sYXllcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBkZXB0aEtleXNfMSA9IGRlcHRoS2V5czsgX2ogPCBkZXB0aEtleXNfMS5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGRlcHRoS2V5c18xW19qXTtcbiAgICAgICAgICAgIHZhciBsYXllcnNGb3JEZXB0aCA9IGxheWVyc0J5RGVwdGhbZGVwdGhdO1xuICAgICAgICAgICAgbGF5ZXJzRm9yRGVwdGguc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhSW5kZXggPSBsYXllckluZGljZXNbYS5pZF07XG4gICAgICAgICAgICAgICAgdmFyIGJJbmRleCA9IGxheWVySW5kaWNlc1tiLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoYUluZGV4IDwgYkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFJbmRleCA+IGJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIF9rID0gMCwgbGF5ZXJzRm9yRGVwdGhfMSA9IGxheWVyc0ZvckRlcHRoOyBfayA8IGxheWVyc0ZvckRlcHRoXzEubGVuZ3RoOyBfaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzRm9yRGVwdGhfMVtfa107XG4gICAgICAgICAgICAgICAgX3RoaXMubGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLmxheWVyc0J5RGVwdGggPSBsYXllcnNCeURlcHRoO1xuICAgICAgICBkZXB0aEtleXMgPSBPYmplY3Qua2V5cyhub2Rlc0J5RGVwdGgpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwYXJzZUludCh4LCAxMCk7IH0pXG4gICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcbiAgICAgICAgdmFyIGNvbXB1dGFibGVUZW5zb3JzID0gX3RoaXMuaW5wdXRzLnNsaWNlKCk7XG4gICAgICAgIHZhciBsYXllcnNXaXRoQ29tcGxldGVJbnB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfbCA9IDAsIGRlcHRoS2V5c18yID0gZGVwdGhLZXlzOyBfbCA8IGRlcHRoS2V5c18yLmxlbmd0aDsgX2wrKykge1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gZGVwdGhLZXlzXzJbX2xdO1xuICAgICAgICAgICAgZm9yICh2YXIgX20gPSAwLCBfbyA9IG5vZGVzQnlEZXB0aFtkZXB0aF07IF9tIDwgX28ubGVuZ3RoOyBfbSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfb1tfbV07XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gbm9kZS5vdXRib3VuZExheWVyO1xuICAgICAgICAgICAgICAgIGlmIChsYXllciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9wID0gMCwgX3EgPSBub2RlLmlucHV0VGVuc29yczsgX3AgPCBfcS5sZW5ndGg7IF9wKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gX3FbX3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGFibGVUZW5zb3JzLmluZGV4T2YoeCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJ1bnRpbWVFcnJvcihcIkdyYXBoIGRpc2Nvbm5lY3RlZDogY2Fubm90IG9idGFpbiB2YWx1ZSBmb3IgdGVuc29yIFwiICsgeCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIiBhdCBsYXllciBcXFwiXCIgKyBsYXllci5uYW1lICsgXCJcXFwiLiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIGZvbGxvd2luZyBwcmV2aW91cyBsYXllcnMgd2VyZSBhY2Nlc3NlZCB3aXRob3V0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJpc3N1ZTogXCIgKyBsYXllcnNXaXRoQ29tcGxldGVJbnB1dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9yID0gMCwgX3MgPSBub2RlLm91dHB1dFRlbnNvcnM7IF9yIDwgX3MubGVuZ3RoOyBfcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IF9zW19yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGFibGVUZW5zb3JzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzV2l0aENvbXBsZXRlSW5wdXQucHVzaChsYXllci5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubm9kZXNCeURlcHRoID0gbm9kZXNCeURlcHRoO1xuICAgICAgICB2YXIgYWxsTmFtZXMgPSBfdGhpcy5sYXllcnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWU7IH0pO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChuYW1lXzEpIHtcbiAgICAgICAgICAgIHZhciBudW1PY2N1cnJlbmNlcyA9IGFsbE5hbWVzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gbmFtZV8xOyB9KS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobnVtT2NjdXJyZW5jZXMgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUnVudGltZUVycm9yKFwiVGhlIG5hbWUgXFxcIlwiICsgbmFtZV8xICsgXCJcXFwiIGlzIHVzZWQgXCIgKyBudW1PY2N1cnJlbmNlcyArIFwiIHRpbWVzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgJ2luIHRoZSBtb2RlbC4gQWxsIGxheWVyIG5hbWVzIHNob3VsZCBiZSB1bmlxdWUuIExheWVyIG5hbWVzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoYWxsTmFtZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwLCBhbGxOYW1lc18xID0gYWxsTmFtZXM7IF90IDwgYWxsTmFtZXNfMS5sZW5ndGg7IF90KyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBhbGxOYW1lc18xW190XTtcbiAgICAgICAgICAgIF9sb29wXzEobmFtZV8xKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5vdXRib3VuZE5vZGVzID0gW107XG4gICAgICAgIF90aGlzLmluYm91bmROb2RlcyA9IFtdO1xuICAgICAgICBuZXcgTm9kZSh7XG4gICAgICAgICAgICBvdXRib3VuZExheWVyOiBfdGhpcyxcbiAgICAgICAgICAgIGluYm91bmRMYXllcnM6IFtdLFxuICAgICAgICAgICAgbm9kZUluZGljZXM6IFtdLFxuICAgICAgICAgICAgdGVuc29ySW5kaWNlczogW10sXG4gICAgICAgICAgICBpbnB1dFRlbnNvcnM6IF90aGlzLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dFRlbnNvcnM6IF90aGlzLm91dHB1dHMsXG4gICAgICAgICAgICBpbnB1dE1hc2tzOiBfdGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBudWxsOyB9KSxcbiAgICAgICAgICAgIG91dHB1dE1hc2tzOiBfdGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gbnVsbDsgfSksXG4gICAgICAgICAgICBpbnB1dFNoYXBlczogX3RoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZTsgfSksXG4gICAgICAgICAgICBvdXRwdXRTaGFwZXM6IF90aGlzLm91dHB1dHMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNoYXBlOyB9KVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuYnVpbHQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcInRyYWluYWJsZVdlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFpbmFibGVXZWlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQ29udGFpbmVyIGluc3RhbmNlIHVuZXhwZWN0ZWRseSBjb250YWlucyBfdHJhaW5hYmxlV2VpZ2h0cy4nICtcbiAgICAgICAgICAgICAgICAgICAgJ1RoZSB0cmFpbmFibGUgd2VpZ2h0cyBvZiBhIENvbnRhaW5lciBhcmUgYSB1bmlvbiBvZiB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICd0cmFpbmFibGUgd2VpZ2h0cyBvZiBpdHMgY29uc2l0dWVudCBMYXllcnMuIEl0cyBvd24gJyArXG4gICAgICAgICAgICAgICAgICAgICdfdHJhaW5hYmxlV2VpZ2h0cyBtdXN0IHJlbWFpbiBhbiBlbXB0eSBBcnJheS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy50cmFpbmFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd2VpZ2h0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGF5ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzID0gd2VpZ2h0cy5jb25jYXQobGF5ZXIudHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdlaWdodHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmxheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cy5wdXNoLmFwcGx5KHdlaWdodHMsIGxheWVyLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGVXZWlnaHRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMubGF5ZXJzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgIHRyYWluYWJsZVdlaWdodHMucHVzaC5hcHBseSh0cmFpbmFibGVXZWlnaHRzLCBsYXllci50cmFpbmFibGVXZWlnaHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWluYWJsZVdlaWdodHMuY29uY2F0KHdlaWdodHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdlaWdodHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcIndlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMubm9uVHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUubG9hZFdlaWdodHMgPSBmdW5jdGlvbiAod2VpZ2h0c0pTT04sIHNraXBNaXNtYXRjaCwgaXNOYW1lZFRlbnNvck1hcCkge1xuICAgICAgICBpZiAoc2tpcE1pc21hdGNoID09PSB2b2lkIDApIHsgc2tpcE1pc21hdGNoID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGlzTmFtZWRUZW5zb3JNYXAgPT09IHZvaWQgMCkgeyBpc05hbWVkVGVuc29yTWFwID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGlzTmFtZWRUZW5zb3JNYXApIHtcbiAgICAgICAgICAgIGxvYWRXZWlnaHRzRnJvbU5hbWVkVGVuc29yTWFwKHdlaWdodHNKU09OLCB0aGlzLmxheWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2FkV2VpZ2h0c0Zyb21Kc29uKHdlaWdodHNKU09OLCB0aGlzLmxheWVycywgc2tpcE1pc21hdGNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVkQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhlQ29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgdmFyIG1vZGVsQ29uZmlnID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmdldENsYXNzTmFtZSgpLFxuICAgICAgICAgICAgY29uZmlnOiB0aGVDb25maWcsXG4gICAgICAgICAgICBrZXJhc1ZlcnNpb246IFwidGZqcy1sYXllcnMgXCIgKyB2ZXJzaW9uXzEudmVyc2lvbixcbiAgICAgICAgICAgIGJhY2tlbmQ6ICdUZW5zb3JGbG93LmpzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW9kZWxDb25maWc7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICh1bnVzZWQsIHJldHVyblN0cmluZykge1xuICAgICAgICBpZiAocmV0dXJuU3RyaW5nID09PSB2b2lkIDApIHsgcmV0dXJuU3RyaW5nID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgbW9kZWxDb25maWcgPSBzZXJpYWxpemF0aW9uX3V0aWxzXzEuY29udmVydFRzVG9QeXRob25pYyh0aGlzLnVwZGF0ZWRDb25maWcoKSk7XG4gICAgICAgIHJldHVybiByZXR1cm5TdHJpbmcgPyBKU09OLnN0cmluZ2lmeShtb2RlbENvbmZpZykgOiBtb2RlbENvbmZpZztcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIG1hc2tzO1xuICAgICAgICAgICAgaWYgKCdtYXNrJyBpbiBrd2FyZ3MpIHtcbiAgICAgICAgICAgICAgICBtYXNrcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGt3YXJnc1snbWFzayddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hc2tzID0gZ2VuZXJpY191dGlscy5weUxpc3RSZXBlYXQobnVsbCwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucnVuSW50ZXJuYWxHcmFwaChpbnB1dHMsIG1hc2tzKVswXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmNvbXB1dGVNYXNrID0gZnVuY3Rpb24gKGlucHV0cywgbWFzaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIG1hc2tzO1xuICAgICAgICAgICAgaWYgKG1hc2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1hc2tzID0gZ2VuZXJpY191dGlscy5weUxpc3RSZXBlYXQobnVsbCwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXNrcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KG1hc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJ1bkludGVybmFsR3JhcGgoaW5wdXRzLCBtYXNrcylbMV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICB2YXIgaW5wdXRTaGFwZXMgPSBnZW5lcmljX3V0aWxzLm5vcm1hbGl6ZVNoYXBlTGlzdChpbnB1dFNoYXBlKTtcbiAgICAgICAgaWYgKGlucHV0U2hhcGVzLmxlbmd0aCAhPT0gdGhpcy5pbnB1dExheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW52YWxpZCBpbnB1dFNoYXBlIGFyZ3VtZW50IFwiICsgaW5wdXRTaGFwZSArIFwiOiBcIiArXG4gICAgICAgICAgICAgICAgKFwibW9kZWwgaGFzIFwiICsgdGhpcy5pbnB1dExheWVycy5sZW5ndGggKyBcIiB0ZW5zb3IgaW5wdXRzLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheWVyc1RvT3V0cHV0U2hhcGVzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRTaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICAgICAgICB2YXIgaW5wdXRTaGFwZV8xID0gaW5wdXRTaGFwZXNbaV07XG4gICAgICAgICAgICB2YXIgc2hhcGVLZXkgPSBsYXllci5uYW1lICsgJ18wXzAnO1xuICAgICAgICAgICAgbGF5ZXJzVG9PdXRwdXRTaGFwZXNbc2hhcGVLZXldID0gaW5wdXRTaGFwZV8xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXB0aEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTsgfSlcbiAgICAgICAgICAgIC5zb3J0KGdlbmVyaWNfdXRpbHMucmV2ZXJzZU51bWJlckNvbXBhcmUpO1xuICAgICAgICBpZiAoZGVwdGhLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZGVwdGhLZXlzXzMgPSBkZXB0aEtleXM7IF9pIDwgZGVwdGhLZXlzXzMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gZGVwdGhLZXlzXzNbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXNCeURlcHRoW2RlcHRoXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIG5vZGVzXzEgPSBub2RlczsgX2EgPCBub2Rlc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzFbX2FdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBub2RlLm91dGJvdW5kTGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0TGF5ZXJzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSkuaW5kZXhPZihsYXllci5pZCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRTaGFwZXNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluYm91bmRMYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXhfMiA9IG5vZGUubm9kZUluZGljZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVuc29ySW5kZXggPSBub2RlLnRlbnNvckluZGljZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGVLZXkgPSBpbmJvdW5kTGF5ZXIubmFtZSArIFwiX1wiICsgbm9kZUluZGV4XzIgKyBcIl9cIiArIHRlbnNvckluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0U2hhcGVfMiA9IGxheWVyc1RvT3V0cHV0U2hhcGVzW3NoYXBlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U2hhcGVzXzEucHVzaChpbnB1dFNoYXBlXzIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IGxheWVyLmNvbXB1dGVPdXRwdXRTaGFwZShnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkoaW5wdXRTaGFwZXNfMSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0U2hhcGVzXzEgPSBnZW5lcmljX3V0aWxzLm5vcm1hbGl6ZVNoYXBlTGlzdChvdXRwdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBsYXllci5pbmJvdW5kTm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRwdXRTaGFwZXNfMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlS2V5ID0gbGF5ZXIubmFtZSArIFwiX1wiICsgbm9kZUluZGV4ICsgXCJfXCIgKyBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzVG9PdXRwdXRTaGFwZXNbc2hhcGVLZXldID0gb3V0cHV0U2hhcGVzXzFbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dFNoYXBlcyA9IFtdO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGVLZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMub3V0cHV0TGF5ZXJzW2ldO1xuICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbaV07XG4gICAgICAgICAgICB2YXIgdGVuc29ySW5kZXggPSB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbaV07XG4gICAgICAgICAgICB2YXIgc2hhcGVLZXkgPSBsYXllci5uYW1lICsgXCJfXCIgKyBub2RlSW5kZXggKyBcIl9cIiArIHRlbnNvckluZGV4O1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVLZXlzLnB1c2goc2hhcGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0U2hhcGVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gb3V0cHV0U2hhcGVLZXlzW2ldO1xuICAgICAgICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQoa2V5IGluIGxheWVyc1RvT3V0cHV0U2hhcGVzKTtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlcy5wdXNoKGxheWVyc1RvT3V0cHV0U2hhcGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkob3V0cHV0U2hhcGVzKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUucnVuSW50ZXJuYWxHcmFwaCA9IGZ1bmN0aW9uIChpbnB1dHMsIG1hc2tzKSB7XG4gICAgICAgIGlmIChtYXNrcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrcyA9IGdlbmVyaWNfdXRpbHMucHlMaXN0UmVwZWF0KG51bGwsIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW5zb3JNYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmlucHV0c1tpXTtcbiAgICAgICAgICAgIHZhciB5ID0gaW5wdXRzW2ldO1xuICAgICAgICAgICAgdmFyIG1hc2sgPSBtYXNrc1tpXTtcbiAgICAgICAgICAgIHRlbnNvck1hcFt4LmlkXSA9IFt5LCBtYXNrXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVwdGhLZXlzID0gT2JqZWN0LmtleXModGhpcy5ub2Rlc0J5RGVwdGgpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwYXJzZUludCh4LCAxMCk7IH0pXG4gICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkZXB0aEtleXNfNCA9IGRlcHRoS2V5czsgX2kgPCBkZXB0aEtleXNfNC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGRlcHRoS2V5c180W19pXTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXNCeURlcHRoW2RlcHRoXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgbm9kZXNfMiA9IG5vZGVzOyBfYSA8IG5vZGVzXzIubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18yW19hXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBub2RlLm91dGJvdW5kTGF5ZXI7XG4gICAgICAgICAgICAgICAgdmFyIHJlZmVyZW5jZUlucHV0VGVuc29ycyA9IG5vZGUuaW5wdXRUZW5zb3JzO1xuICAgICAgICAgICAgICAgIHZhciByZWZlcmVuY2VPdXRwdXRUZW5zb3JzID0gbm9kZS5vdXRwdXRUZW5zb3JzO1xuICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZERhdGEgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIHJlZmVyZW5jZUlucHV0VGVuc29yc18xID0gcmVmZXJlbmNlSW5wdXRUZW5zb3JzOyBfYiA8IHJlZmVyZW5jZUlucHV0VGVuc29yc18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHJlZmVyZW5jZUlucHV0VGVuc29yc18xW19iXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHguaWQgaW4gdGVuc29yTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZERhdGEucHVzaCh0ZW5zb3JNYXBbeC5pZF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZERhdGEubGVuZ3RoID09PSByZWZlcmVuY2VJbnB1dFRlbnNvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrd2FyZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkVGVuc29ycyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkTWFza3MgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRUZW5zb3JzXzEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRNYXNrc18xID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5jYWxsQXJncyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrd2FyZ3MgPSBub2RlLmNhbGxBcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZERhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBjb21wdXRlZERhdGFbMF0sIGNvbXB1dGVkVGVuc29yID0gX2NbMF0sIGNvbXB1dGVkTWFzayA9IF9jWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGt3YXJncy5tYXNrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrd2FyZ3NbJ21hc2snXSA9IGNvbXB1dGVkTWFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFRlbnNvcnNfMSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY191dGlscy50b0xpc3QobGF5ZXIuY2FsbChjb21wdXRlZFRlbnNvciwga3dhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRNYXNrc18xID0gZ2VuZXJpY191dGlscy50b0xpc3QobGF5ZXIuY29tcHV0ZU1hc2soY29tcHV0ZWRUZW5zb3IsIGNvbXB1dGVkTWFzaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRUZW5zb3JzID0gW2NvbXB1dGVkVGVuc29yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkTWFza3MgPSBbY29tcHV0ZWRNYXNrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkVGVuc29ycyA9IGNvbXB1dGVkRGF0YS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHhbMF07IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRNYXNrcyA9IGNvbXB1dGVkRGF0YS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHhbMV07IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGt3YXJncy5tYXNrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrd2FyZ3NbJ21hc2snXSA9IGNvbXB1dGVkTWFza3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRUZW5zb3JzXzEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMudG9MaXN0KGxheWVyLmNhbGwoY29tcHV0ZWRUZW5zb3JzLCBrd2FyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dE1hc2tzXzEgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChsYXllci5jb21wdXRlTWFzayhjb21wdXRlZFRlbnNvcnMsIGNvbXB1dGVkTWFza3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIuYWN0aXZpdHlSZWd1bGFyaXplcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ01vZGVsIGludm9jYXRpb24gd2l0aCBjb25jcmV0ZSBUZW5zb3IgdmFsdWUocykgaW4gdGhlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZmVyZW5jZU91dHB1dFRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcmVmZXJlbmNlT3V0cHV0VGVuc29yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gb3V0cHV0VGVuc29yc18xW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSBvdXRwdXRNYXNrc18xW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yTWFwW3guaWRdID0gW3ksIG1hc2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRUZW5zb3JzID0gW107XG4gICAgICAgIHZhciBvdXRwdXRNYXNrcyA9IFtdO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSB0aGlzLm91dHB1dHM7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IF9lW19kXTtcbiAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KHguaWQgaW4gdGVuc29yTWFwLCBcIkNvdWxkIG5vdCBjb21wdXRlIG91dHB1dCBcIiArIHgubmFtZSArIFwiIDogXCIgKyB4LmlkKTtcbiAgICAgICAgICAgIHZhciBfZiA9IHRlbnNvck1hcFt4LmlkXSwgdGVuc29yID0gX2ZbMF0sIG1hc2sgPSBfZlsxXTtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlcy5wdXNoKHRlbnNvci5zaGFwZSk7XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzLnB1c2godGVuc29yKTtcbiAgICAgICAgICAgIG91dHB1dE1hc2tzLnB1c2gobWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtvdXRwdXRUZW5zb3JzLCBvdXRwdXRNYXNrcywgb3V0cHV0U2hhcGVzXTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuYnVpbGROb2RlQ29udmVyc2lvbk1hcCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcbiAgICAgICAgdmFyIG5vZGVDb252ZXJzaW9uTWFwID0ge307XG4gICAgICAgIHZhciBrZXB0Tm9kZXM7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmxheWVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgIGtlcHROb2RlcyA9IGxheWVyIGluc3RhbmNlb2YgQ29udGFpbmVyID8gMSA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBvcmlnaW5hbE5vZGVJbmRleCA9IDA7IG9yaWdpbmFsTm9kZUluZGV4IDwgbGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aDsgb3JpZ2luYWxOb2RlSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG9yaWdpbmFsTm9kZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZUtleSBpbiB0aGlzLmNvbnRhaW5lck5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVDb252ZXJzaW9uTWFwW25vZGVLZXldID0ga2VwdE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICBrZXB0Tm9kZXMgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVDb252ZXJzaW9uTWFwO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiV2FzIGFza2VkIHRvIHJldHJpZXZlIGxheWVyIGF0IGluZGV4IFwiICsgaW5kZXggKyBcIiwgYnV0IG1vZGVsIG9ubHkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJoYXMgXCIgKyB0aGlzLmxheWVycy5sZW5ndGggKyBcIiBsYXllcihzKS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignUHJvdmlkZSBlaXRoZXIgYSBsYXllciBuYW1lIG9yIGxheWVyIGluZGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGF5ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKGxheWVyLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJObyBzdWNoIGxheWVyOiBcIiArIG5hbWUpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5jYWxjdWxhdGVMb3NzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsb3NzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5sYXllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5vZGVJbmRleCA9IDA7IG5vZGVJbmRleCA8IGxheWVyLmluYm91bmROb2Rlcy5sZW5ndGg7ICsrbm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG5vZGVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvc3Nlcy5wdXNoLmFwcGx5KGxvc3NlcywgbGF5ZXIuY2FsY3VsYXRlTG9zc2VzKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvc3NlcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgbmFtZTogdGhpcy5uYW1lIH07XG4gICAgICAgIHZhciBub2RlQ29udmVyc2lvbk1hcCA9IHRoaXMuYnVpbGROb2RlQ29udmVyc2lvbk1hcCh0aGlzLmxheWVycyk7XG4gICAgICAgIHZhciBsYXllckNvbmZpZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGF5ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGxheWVyQ2xhc3NOYW1lID0gbGF5ZXIuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgICAgICAgICB2YXIgbGF5ZXJDb25maWcgPSBsYXllci5nZXRDb25maWcoKTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEluYm91bmROb2RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgb3JpZ2luYWxOb2RlSW5kZXggPSAwOyBvcmlnaW5hbE5vZGVJbmRleCA8IGxheWVyLmluYm91bmROb2Rlcy5sZW5ndGg7IG9yaWdpbmFsTm9kZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGxheWVyLmluYm91bmROb2Rlc1tvcmlnaW5hbE5vZGVJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVLZXkgPSBDb250YWluZXIubm9kZUtleShsYXllciwgb3JpZ2luYWxOb2RlSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBrd2FyZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2FsbEFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0U3RyaW5nID0gSlNPTi5zdHJpbmdpZnkobm9kZS5jYWxsQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVzdFN0cmluZy5pbmRleE9mKCd1bmRlZmluZWQnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrd2FyZ3MgPSBub2RlLmNhbGxBcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTGF5ZXIgXCIgKyBsYXllci5uYW1lICsgXCIgd2FzIHBhc3NlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm9uLXNlcmlhbGl6YWJsZSBrZXl3b3JkIGFyZ3VtZW50czogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZS5jYWxsQXJncyArIFwiLiBUaGV5IHdpbGwgbm90IGJlIGluY2x1ZGVkIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW4gdGhlIHNlcmlhbGl6ZWQgbW9kZWwgKGFuZCB0aHVzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pc3NpbmcgYXQgZGVzZXJpYWxpemF0aW9uIHRpbWUpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrd2FyZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmluYm91bmRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5ib3VuZExheWVyID0gbm9kZS5pbmJvdW5kTGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBub2RlLm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW5zb3JJbmRleCA9IG5vZGUudGVuc29ySW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUtleV8xID0gQ29udGFpbmVyLm5vZGVLZXkoaW5ib3VuZExheWVyLCBub2RlSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlSW5kZXggPSBub2RlQ29udmVyc2lvbk1hcFtub2RlS2V5XzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlSW5kZXggPT09IG51bGwgfHwgbmV3Tm9kZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZURhdGEucHVzaChbaW5ib3VuZExheWVyLm5hbWUsIG5ld05vZGVJbmRleCwgdGVuc29ySW5kZXgsIGt3YXJnc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRJbmJvdW5kTm9kZXMucHVzaChub2RlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllckNvbmZpZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogbGF5ZXJDb25maWcsXG4gICAgICAgICAgICAgICAgaW5ib3VuZE5vZGVzOiBmaWx0ZXJlZEluYm91bmROb2Rlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnWydsYXllcnMnXSA9IGxheWVyQ29uZmlncztcbiAgICAgICAgdmFyIG1vZGVsSW5wdXRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5pbnB1dExheWVyc1tpXTtcbiAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZUtleSA9IENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBub2RlSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhub2RlS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld05vZGVJbmRleCA9IG5vZGVDb252ZXJzaW9uTWFwW25vZGVLZXldO1xuICAgICAgICAgICAgaWYgKG5ld05vZGVJbmRleCA9PT0gbnVsbCB8fCBuZXdOb2RlSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld05vZGVJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGVuc29ySW5kZXggPSB0aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tpXTtcbiAgICAgICAgICAgIG1vZGVsSW5wdXRzLnB1c2goW2xheWVyLm5hbWUsIG5ld05vZGVJbmRleCwgdGVuc29ySW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWdbJ2lucHV0TGF5ZXJzJ10gPSBtb2RlbElucHV0cztcbiAgICAgICAgdmFyIG1vZGVsT3V0cHV0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLm91dHB1dExheWVyc1tpXTtcbiAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIG5vZGVLZXkgPSBDb250YWluZXIubm9kZUtleShsYXllciwgbm9kZUluZGV4KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdOb2RlSW5kZXggPSBub2RlQ29udmVyc2lvbk1hcFtub2RlS2V5XTtcbiAgICAgICAgICAgIGlmIChuZXdOb2RlSW5kZXggPT09IG51bGwgfHwgbmV3Tm9kZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlSW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRlbnNvckluZGV4ID0gdGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzW2ldO1xuICAgICAgICAgICAgbW9kZWxPdXRwdXRzLnB1c2goW2xheWVyLm5hbWUsIG5ld05vZGVJbmRleCwgdGVuc29ySW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWdbJ291dHB1dExheWVycyddID0gbW9kZWxPdXRwdXRzO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgQ29udGFpbmVyLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgdmFyIGNyZWF0ZWRMYXllcnMgPSB7fTtcbiAgICAgICAgdmFyIHVucHJvY2Vzc2VkTm9kZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gYWRkVW5wcm9jZXNzZWROb2RlKGxheWVyLCBub2RlRGF0YSkge1xuICAgICAgICAgICAgaWYgKCEobGF5ZXIubmFtZSBpbiB1bnByb2Nlc3NlZE5vZGVzKSkge1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkTm9kZXNbbGF5ZXIubmFtZV0gPSBbbm9kZURhdGFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWROb2Rlc1tsYXllci5uYW1lXS5wdXNoKG5vZGVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShsYXllciwgbm9kZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBrd2FyZ3M7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5vZGVEYXRhXzEgPSBub2RlRGF0YTsgX2kgPCBub2RlRGF0YV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dERhdGEgPSBub2RlRGF0YV8xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5ib3VuZExheWVyTmFtZSA9IGlucHV0RGF0YVswXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5ib3VuZE5vZGVJbmRleCA9IGlucHV0RGF0YVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5ib3VuZFRlbnNvckluZGV4ID0gaW5wdXREYXRhWzJdO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dERhdGEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGt3YXJncyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnB1dERhdGEubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGt3YXJncyA9IGlucHV0RGF0YVszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW1wcm9wZXJseSBmb3JtYXR0ZWQgbW9kZWwgY29uZmlnIGZvciBsYXllciBcIiArIEpTT04uc3RyaW5naWZ5KGxheWVyKSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0RGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShpbmJvdW5kTGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFVucHJvY2Vzc2VkTm9kZShsYXllciwgbm9kZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmJvdW5kTGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2luYm91bmRMYXllck5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChpbmJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCA8PSBpbmJvdW5kTm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFVucHJvY2Vzc2VkTm9kZShsYXllciwgbm9kZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmJvdW5kTm9kZSA9IGluYm91bmRMYXllci5pbmJvdW5kTm9kZXNbaW5ib3VuZE5vZGVJbmRleF07XG4gICAgICAgICAgICAgICAgaW5wdXRUZW5zb3JzLnB1c2goaW5ib3VuZE5vZGUub3V0cHV0VGVuc29yc1tpbmJvdW5kVGVuc29ySW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dFRlbnNvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxheWVyLmFwcGx5KGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShpbnB1dFRlbnNvcnMpLCBrd2FyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NMYXllcihsYXllckRhdGEpIHtcbiAgICAgICAgICAgIHZhciBsYXllck5hbWUgPSBsYXllckRhdGEubmFtZTtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHNlcmlhbGl6YXRpb25fMS5kZXNlcmlhbGl6ZShsYXllckRhdGEsIGNvbmZpZy5jdXN0b21PYmplY3RzICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGNvbmZpZy5jdXN0b21PYmplY3RzIDpcbiAgICAgICAgICAgICAgICB7fSk7XG4gICAgICAgICAgICBjcmVhdGVkTGF5ZXJzW2xheWVyTmFtZV0gPSBsYXllcjtcbiAgICAgICAgICAgIHZhciBpbmJvdW5kTm9kZXNEYXRhID0gbGF5ZXJEYXRhLmluYm91bmROb2RlcztcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5ib3VuZE5vZGVzRGF0YV8xID0gaW5ib3VuZE5vZGVzRGF0YTsgX2kgPCBpbmJvdW5kTm9kZXNEYXRhXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVEYXRhID0gaW5ib3VuZE5vZGVzRGF0YV8xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIShub2RlRGF0YSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkNvcnJ1cHRlZCBjb25maWd1cmF0aW9uLCBleHBlY3RlZCBhcnJheSBmb3Igbm9kZURhdGE6IFwiICsgbm9kZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRVbnByb2Nlc3NlZE5vZGUobGF5ZXIsIG5vZGVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICB2YXIgbGF5ZXJzRnJvbUNvbmZpZyA9IGNvbmZpZy5sYXllcnM7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbGF5ZXJzRnJvbUNvbmZpZ18xID0gbGF5ZXJzRnJvbUNvbmZpZzsgX2kgPCBsYXllcnNGcm9tQ29uZmlnXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJEYXRhID0gbGF5ZXJzRnJvbUNvbmZpZ18xW19pXTtcbiAgICAgICAgICAgIHByb2Nlc3NMYXllcihsYXllckRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICghZ2VuZXJpY191dGlscy5pc09iamVjdEVtcHR5KHVucHJvY2Vzc2VkTm9kZXMpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGxheWVyc0Zyb21Db25maWdfMiA9IGxheWVyc0Zyb21Db25maWc7IF9hIDwgbGF5ZXJzRnJvbUNvbmZpZ18yLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckRhdGEgPSBsYXllcnNGcm9tQ29uZmlnXzJbX2FdO1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGNyZWF0ZWRMYXllcnNbbGF5ZXJEYXRhLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5uYW1lIGluIHVucHJvY2Vzc2VkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHVucHJvY2Vzc2VkTm9kZXNbbGF5ZXIubmFtZV07IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZURhdGEgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTm9kZShsYXllciwgbm9kZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB1bnByb2Nlc3NlZE5vZGVzW2xheWVyLm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRUZW5zb3JzID0gW107XG4gICAgICAgIHZhciBvdXRwdXRUZW5zb3JzID0gW107XG4gICAgICAgIHZhciBpbnB1dExheWVyc0Zyb21Db25maWcgPSBjb25maWcuaW5wdXRMYXllcnM7XG4gICAgICAgIGZvciAodmFyIF9kID0gMCwgaW5wdXRMYXllcnNGcm9tQ29uZmlnXzEgPSBpbnB1dExheWVyc0Zyb21Db25maWc7IF9kIDwgaW5wdXRMYXllcnNGcm9tQ29uZmlnXzEubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJEYXRhID0gaW5wdXRMYXllcnNGcm9tQ29uZmlnXzFbX2RdO1xuICAgICAgICAgICAgdmFyIGxheWVyTmFtZSA9IGxheWVyRGF0YVswXTtcbiAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBsYXllckRhdGFbMV07XG4gICAgICAgICAgICB2YXIgdGVuc29ySW5kZXggPSBsYXllckRhdGFbMl07XG4gICAgICAgICAgICBnZW5lcmljX3V0aWxzLmFzc2VydChsYXllck5hbWUgaW4gY3JlYXRlZExheWVycyk7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICAgICAgICB2YXIgbGF5ZXJPdXRwdXRUZW5zb3JzID0gbGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF0ub3V0cHV0VGVuc29ycztcbiAgICAgICAgICAgIGlucHV0VGVuc29ycy5wdXNoKGxheWVyT3V0cHV0VGVuc29yc1t0ZW5zb3JJbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRMYXllcnNGcm9tQ29uZmlnID0gY29uZmlnLm91dHB1dExheWVycztcbiAgICAgICAgZm9yICh2YXIgX2UgPSAwLCBvdXRwdXRMYXllcnNGcm9tQ29uZmlnXzEgPSBvdXRwdXRMYXllcnNGcm9tQ29uZmlnOyBfZSA8IG91dHB1dExheWVyc0Zyb21Db25maWdfMS5sZW5ndGg7IF9lKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllckRhdGEgPSBvdXRwdXRMYXllcnNGcm9tQ29uZmlnXzFbX2VdO1xuICAgICAgICAgICAgdmFyIGxheWVyTmFtZSA9IGxheWVyRGF0YVswXTtcbiAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBsYXllckRhdGFbMV07XG4gICAgICAgICAgICB2YXIgdGVuc29ySW5kZXggPSBsYXllckRhdGFbMl07XG4gICAgICAgICAgICBnZW5lcmljX3V0aWxzLmFzc2VydChsYXllck5hbWUgaW4gY3JlYXRlZExheWVycyk7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICAgICAgICB2YXIgbGF5ZXJPdXRwdXRUZW5zb3JzID0gbGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF0ub3V0cHV0VGVuc29ycztcbiAgICAgICAgICAgIG91dHB1dFRlbnNvcnMucHVzaChsYXllck91dHB1dFRlbnNvcnNbdGVuc29ySW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNscyh7IGlucHV0czogaW5wdXRUZW5zb3JzLCBvdXRwdXRzOiBvdXRwdXRUZW5zb3JzLCBuYW1lOiBuYW1lIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwic3RhdGVmdWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZWZ1bCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdDb250YWluZXIgaW5zdGFuY2UgdW5leHBlY3RlZGx5IGhhcyBfc3RhdGVmdWwgPSB0cnVlLiBUaGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdzdGF0ZWZ1bG5lc3Mgb2YgYSBDb250YWluZXIgaXMgZGV0ZXJtaW5lZCBieSB0aGUgTGF5ZXJzIGl0ICcgK1xuICAgICAgICAgICAgICAgICAgICAnY29udGFpbnMuIEl0cyBfc3RhdGVmdWwgcHJvcGVydHkgbXVzdCByZW1haW4gdGhlIGRlZmF1bHQgZmFsc2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5sYXllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5zdGF0ZWZ1bCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgc3ViY2xhc3NlczogWydNb2RlbCddXG4gICAgICAgIH0pXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJnZXRMYXllclwiLCBudWxsKTtcbiAgICByZXR1cm4gQ29udGFpbmVyO1xufShMYXllcikpO1xuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXI7XG5mdW5jdGlvbiBnZXRTb3VyY2VJbnB1dHModGVuc29yLCBsYXllciwgbm9kZUluZGV4KSB7XG4gICAgaWYgKGxheWVyID09IG51bGwgfHwgKG5vZGVJbmRleCAhPSBudWxsICYmIG5vZGVJbmRleCA+IDApKSB7XG4gICAgICAgIGxheWVyID0gdGVuc29yLnNvdXJjZUxheWVyO1xuICAgICAgICBub2RlSW5kZXggPSB0ZW5zb3Iubm9kZUluZGV4O1xuICAgIH1cbiAgICBpZiAobGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW3RlbnNvcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbm9kZSA9IGxheWVyLmluYm91bmROb2Rlc1tub2RlSW5kZXhdO1xuICAgICAgICBpZiAobm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuaW5wdXRUZW5zb3JzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNvdXJjZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBub2RlLmlucHV0VGVuc29yc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJfMiA9IG5vZGUuaW5ib3VuZExheWVyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4XzMgPSBub2RlLm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1NvdXJjZXMgPSBnZXRTb3VyY2VJbnB1dHMoeCwgbGF5ZXJfMiwgbm9kZUluZGV4XzMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcHJldmlvdXNTb3VyY2VzXzEgPSBwcmV2aW91c1NvdXJjZXM7IF9pIDwgcHJldmlvdXNTb3VyY2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4XzEgPSBwcmV2aW91c1NvdXJjZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VUZW5zb3JzLmluZGV4T2YoeF8xKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVRlbnNvcnMucHVzaCh4XzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVRlbnNvcnM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmdldFNvdXJjZUlucHV0cyA9IGdldFNvdXJjZUlucHV0cztcbmZ1bmN0aW9uIGxvYWRUZW5zb3IoZHR5cGUsIHNoYXBlLCB2YWx1ZSkge1xuICAgIHZhciBkYXRhVHlwZSA9IGdlbmVyaWNfdXRpbHMuc3RyaW5nVG9EVHlwZShkdHlwZSk7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLlRlbnNvci5tYWtlKHNoYXBlLCB7IHZhbHVlczogc2hhcGUubGVuZ3RoID09PSAwID8gdmFsdWUgOiB0ZmpzX2NvcmVfMS51dGlsLmZsYXR0ZW4odmFsdWUpIH0sIGRhdGFUeXBlKTtcbn1cbmZ1bmN0aW9uIHByZXByb2Nlc3NXZWlnaHRzRm9yTG9hZGluZyhsYXllciwgd2VpZ2h0cywgb3JpZ2luYWxLZXJhc1ZlcnNpb24sIG9yaWdpbmFsQmFja2VuZCkge1xuICAgIGlmICghb3JpZ2luYWxLZXJhc1ZlcnNpb24uc3RhcnRzV2l0aCgnMi4nKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignVW5zdXBwb3J0ZWQgS2VyYXMgdmVyc2lvbiBpbiB3ZWlnaHRzIGJlaW5nIGxvYWRlZDogJyArXG4gICAgICAgICAgICBvcmlnaW5hbEtlcmFzVmVyc2lvbik7XG4gICAgfVxuICAgIHJldHVybiB3ZWlnaHRzO1xufVxuZnVuY3Rpb24gbG9hZFdlaWdodHNGcm9tTmFtZWRUZW5zb3JNYXAod2VpZ2h0cywgbGF5ZXJzKSB7XG4gICAgdmFyIG5hbWVUb1dlaWdodCA9IHt9O1xuICAgIHZhciB0b3RhbFdlaWdodHNDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBsYXllcnNfMSA9IGxheWVyczsgX2kgPCBsYXllcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzXzFbX2ldO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gbGF5ZXIud2VpZ2h0czsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBfYltfYV07XG4gICAgICAgICAgICBpZiAobmFtZVRvV2VpZ2h0W3dlaWdodC5vcmlnaW5hbE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSB3ZWlnaHQgbmFtZTogXCIgKyB3ZWlnaHQub3JpZ2luYWxOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWVUb1dlaWdodFt3ZWlnaHQub3JpZ2luYWxOYW1lXSA9IHdlaWdodDtcbiAgICAgICAgICAgIHRvdGFsV2VpZ2h0c0NvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHdlaWdodFZhbHVlVHVwbGVzID0gW107XG4gICAgZm9yICh2YXIgbmFtZV8yIGluIHdlaWdodHMpIHtcbiAgICAgICAgd2VpZ2h0VmFsdWVUdXBsZXMucHVzaChbbmFtZVRvV2VpZ2h0W25hbWVfMl0sIHdlaWdodHNbbmFtZV8yXV0pO1xuICAgICAgICBkZWxldGUgbmFtZVRvV2VpZ2h0W25hbWVfMl07XG4gICAgfVxuICAgIHZhciB1bnNldE5hbWVzID0gW107XG4gICAgZm9yICh2YXIgbmFtZV8zIGluIG5hbWVUb1dlaWdodCkge1xuICAgICAgICB1bnNldE5hbWVzLnB1c2gobmFtZV8zKTtcbiAgICB9XG4gICAgaWYgKHVuc2V0TmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcih1bnNldE5hbWVzLmxlbmd0aCArIFwiIG9mIFwiICsgdG90YWxXZWlnaHRzQ291bnQgKyBcIiB3ZWlnaHRzIGFyZSBub3Qgc2V0OiBcIiArXG4gICAgICAgICAgICAoXCJcIiArIHVuc2V0TmFtZXMpKTtcbiAgICB9XG4gICAgdmFyaWFibGVzXzEuYmF0Y2hTZXRWYWx1ZSh3ZWlnaHRWYWx1ZVR1cGxlcyk7XG59XG5leHBvcnRzLmxvYWRXZWlnaHRzRnJvbU5hbWVkVGVuc29yTWFwID0gbG9hZFdlaWdodHNGcm9tTmFtZWRUZW5zb3JNYXA7XG5mdW5jdGlvbiBsb2FkV2VpZ2h0c0Zyb21Kc29uKHdlaWdodHNKU09OLCBsYXllcnMsIHNraXBNaXNtYXRjaCkge1xuICAgIGlmIChza2lwTWlzbWF0Y2ggPT09IHZvaWQgMCkgeyBza2lwTWlzbWF0Y2ggPSBmYWxzZTsgfVxuICAgIHZhciBvcmlnaW5hbEtlcmFzVmVyc2lvbiA9IHdlaWdodHNKU09OWydrZXJhc192ZXJzaW9uJ107XG4gICAgdmFyIG9yaWdpbmFsQmFja2VuZCA9IHdlaWdodHNKU09OWydiYWNrZW5kJ107XG4gICAgdmFyIGxheWVyTmFtZXMgPSBsYXllcnMubWFwKGZ1bmN0aW9uIChsYXllcikgeyByZXR1cm4gbGF5ZXIubmFtZTsgfSk7XG4gICAgdmFyIGluZGV4ID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBsYXllcnNfMiA9IGxheWVyczsgX2kgPCBsYXllcnNfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzXzJbX2ldO1xuICAgICAgICBpZiAobGF5ZXIubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhbbGF5ZXIubmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4W2xheWVyLm5hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleFtsYXllci5uYW1lXS5wdXNoKGxheWVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmFtZVRvV2VpZ2h0cyA9IHdlaWdodHNKU09OWyd3ZWlnaHRzJ107XG4gICAgdmFyIHdlaWdodFZhbHVlVHVwbGVzID0gW107XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYXllck5hbWVzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIHZhciBuYW1lXzQgPSBsYXllck5hbWVzW2tdO1xuICAgICAgICB2YXIgbGF5ZXJXZWlnaHRzID0gbmFtZVRvV2VpZ2h0c1tuYW1lXzRdO1xuICAgICAgICBpZiAobGF5ZXJXZWlnaHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIGxheWVyV2VpZ2h0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWlnaHRWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBsYXllcldlaWdodHMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRFbnRyeSA9IGxheWVyV2VpZ2h0c1tuXTtcbiAgICAgICAgICAgIHdlaWdodFZhbHVlcy5wdXNoKG5ldyB2YXJpYWJsZXNfMS5MYXllclZhcmlhYmxlKGxvYWRUZW5zb3Iod2VpZ2h0RW50cnlbJ2R0eXBlJ10sIHdlaWdodEVudHJ5WydzaGFwZSddLCB3ZWlnaHRFbnRyeVsndmFsdWUnXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gaW5kZXhbbmFtZV80XTsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9iW19hXTtcbiAgICAgICAgICAgIHZhciBzeW1ib2xpY1dlaWdodHMgPSBsYXllci53ZWlnaHRzO1xuICAgICAgICAgICAgd2VpZ2h0VmFsdWVzID0gcHJlcHJvY2Vzc1dlaWdodHNGb3JMb2FkaW5nKGxheWVyLCB3ZWlnaHRWYWx1ZXMsIG9yaWdpbmFsS2VyYXNWZXJzaW9uLCBvcmlnaW5hbEJhY2tlbmQpO1xuICAgICAgICAgICAgaWYgKHdlaWdodFZhbHVlcy5sZW5ndGggIT09IHN5bWJvbGljV2VpZ2h0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcE1pc21hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNraXBwaW5nIGxvYWRpbmcgb2Ygd2VpZ2h0cyBvZiBsYXllciBcIiArIGxheWVyLm5hbWUgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJkdWUgdG8gbWlzbWF0Y2ggaW4gbnVtYmVyIG9mIHdlaWdodHM6IChcIiArIHdlaWdodFZhbHVlcy5sZW5ndGggKyBcIiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwidnMgXCIgKyBzeW1ib2xpY1dlaWdodHMubGVuZ3RoICsgXCIpLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkxheWVyICNcIiArIGsgKyBcIiAobmFtZWQgXFxcIlwiICsgbGF5ZXIubmFtZSArIFwiXFxcIikgZXhwZWN0cyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3ltYm9saWNXZWlnaHRzLmxlbmd0aCArIFwiIHdlaWdodChzKSwgYnV0IHRoZSBzYXZlZCB3ZWlnaHRzIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJoYXZlIFwiICsgd2VpZ2h0VmFsdWVzLmxlbmd0aCArIFwiIGVsZW1lbnQocykuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdlaWdodFZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChza2lwTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZmpzX2NvcmVfMS51dGlsLmFycmF5c0VxdWFsKHN5bWJvbGljV2VpZ2h0c1tpXS5zaGFwZSwgd2VpZ2h0VmFsdWVzW2ldLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU2tpcHBpbmcgbG9hZGluZyBvZiB3ZWlnaHRzIGZvciBsYXllciBcIiArIGxheWVyLm5hbWUgKyBcIiBkdWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInRvIG1pc21hdGNoIGluIHNoYXBlIChcIiArIHN5bWJvbGljV2VpZ2h0c1tpXS5zaGFwZSArIFwiIHZzIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdlaWdodFZhbHVlc1tpXS5zaGFwZSArIFwiKVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3ZWlnaHRWYWx1ZVR1cGxlcy5wdXNoKFtzeW1ib2xpY1dlaWdodHNbaV0sIHdlaWdodFZhbHVlc1tpXS5yZWFkKCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXJpYWJsZXNfMS5iYXRjaFNldFZhbHVlKHdlaWdodFZhbHVlVHVwbGVzKTtcbn1cbmV4cG9ydHMubG9hZFdlaWdodHNGcm9tSnNvbiA9IGxvYWRXZWlnaHRzRnJvbUpzb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3BvbG9neS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBjYWxsYmFja3NfMSA9IHJlcXVpcmUoXCIuLi9jYWxsYmFja3NcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGxvc3NlcyA9IHJlcXVpcmUoXCIuLi9sb3NzZXNcIik7XG52YXIgTWV0cmljcyA9IHJlcXVpcmUoXCIuLi9tZXRyaWNzXCIpO1xudmFyIG9wdGltaXplcnMgPSByZXF1aXJlKFwiLi4vb3B0aW1pemVyc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBtYXRoX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWF0aF91dGlsc1wiKTtcbnZhciBleGVjdXRvcl8xID0gcmVxdWlyZShcIi4vZXhlY3V0b3JcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuL3RvcG9sb2d5XCIpO1xuZnVuY3Rpb24gaXNEYXRhVGVuc29yKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIHRmanNfY29yZV8xLlRlbnNvcjtcbn1cbmV4cG9ydHMuaXNEYXRhVGVuc29yID0gaXNEYXRhVGVuc29yO1xuZnVuY3Rpb24gaXNEYXRhQXJyYXkoeCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpO1xufVxuZXhwb3J0cy5pc0RhdGFBcnJheSA9IGlzRGF0YUFycmF5O1xuZnVuY3Rpb24gaXNEYXRhRGljdCh4KSB7XG4gICAgcmV0dXJuICFpc0RhdGFUZW5zb3IoeCkgJiYgIWlzRGF0YUFycmF5KHgpO1xufVxuZXhwb3J0cy5pc0RhdGFEaWN0ID0gaXNEYXRhRGljdDtcbmZ1bmN0aW9uIHN0YW5kYXJkaXplSW5wdXREYXRhKGRhdGEsIG5hbWVzLCBzaGFwZXMsIGNoZWNrQmF0Y2hBeGlzLCBleGNlcHRpb25QcmVmaXgpIHtcbiAgICBpZiAoY2hlY2tCYXRjaEF4aXMgPT09IHZvaWQgMCkgeyBjaGVja0JhdGNoQXhpcyA9IHRydWU7IH1cbiAgICBpZiAoZXhjZXB0aW9uUHJlZml4ID09PSB2b2lkIDApIHsgZXhjZXB0aW9uUHJlZml4ID0gJyc7IH1cbiAgICBpZiAobmFtZXMgPT0gbnVsbCB8fCBuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGdvdFVuZXhwZWN0ZWREYXRhID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaXNEYXRhQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZ290VW5leHBlY3RlZERhdGEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEYXRhRGljdChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdFVuZXhwZWN0ZWREYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ290VW5leHBlY3RlZERhdGEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvdFVuZXhwZWN0ZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsIFwiICsgZXhjZXB0aW9uUHJlZml4ICsgXCIgZXhwZWN0ZWQgbm8gZGF0YSwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJidXQgZ290IFwiICsgZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBudWxsOyB9KTtcbiAgICB9XG4gICAgdmFyIGFycmF5cztcbiAgICBpZiAoaXNEYXRhRGljdChkYXRhKSkge1xuICAgICAgICBkYXRhID0gZGF0YTtcbiAgICAgICAgYXJyYXlzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbmFtZXNfMSA9IG5hbWVzOyBfaSA8IG5hbWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gbmFtZXNfMVtfaV07XG4gICAgICAgICAgICBpZiAoZGF0YVtuYW1lXzFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIk5vIGRhdGEgcHJvdmlkZWQgZm9yIFxcXCJcIiArIG5hbWVfMSArIFwiXFxcIi4gTmVlZCBkYXRhIGZvciBlYWNoIGtleSBpbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIG5hbWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnJheXMucHVzaChkYXRhW25hbWVfMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGF0YUFycmF5KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsIFwiICsgZXhjZXB0aW9uUHJlZml4ICsgXCI6IHRoZSBBcnJheSBvZiBcIiArXG4gICAgICAgICAgICAgICAgXCJUZW5zb3JzIHRoYXQgeW91IGFyZSBwYXNzaW5nIHRvIHlvdXIgbW9kZWwgaXMgbm90IHRoZSBzaXplIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgKFwibW9kZWwgZXhwZWN0ZWQuIEV4cGVjdGVkIHRvIHNlZSBcIiArIG5hbWVzLmxlbmd0aCArIFwiIFRlbnNvcihzKSwgYnV0IFwiKSArXG4gICAgICAgICAgICAgICAgKFwiaW5zdGVhZCBnb3QgdGhlIGZvbGxvd2luZyBsaXN0IG9mIFRlbnNvcihzKTogXCIgKyBkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlzID0gZGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgbW9kZWwgXCIgKyBleGNlcHRpb25QcmVmaXggKyBcIiBleHBlY3RzIFwiICsgbmFtZXMubGVuZ3RoICsgXCIgVGVuc29yKHMpLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiYnV0IG9ubHkgcmVjZWl2ZWQgb25lIFRlbnNvci4gRm91bmQ6IFRlbnNvciB3aXRoIHNoYXBlIFwiICsgZGF0YS5zaGFwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5cyA9IFtkYXRhXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaV07XG4gICAgICAgIGlmIChhcnJheS5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGFycmF5c1tpXSA9IEsuZXhwYW5kRGltcyhhcnJheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzaGFwZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2ldO1xuICAgICAgICAgICAgaWYgKGFycmF5LnNoYXBlLmxlbmd0aCAhPT0gc2hhcGVzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIiArIGV4Y2VwdGlvblByZWZpeCArIFwiOiBleHBlY3RlZCBcIiArIG5hbWVzW2ldICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJ0byBoYXZlIFwiICsgc2hhcGVzW2ldLmxlbmd0aCArIFwiIGRpbWVuc2lvbihzKS4gYnV0IGdvdCBhcnJheSB3aXRoIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChcInNoYXBlIFwiICsgYXJyYXkuc2hhcGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhcGVzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgIWNoZWNrQmF0Y2hBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGltID0gYXJyYXkuc2hhcGVbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlZkRpbSA9IHNoYXBlc1tpXVtqXTtcbiAgICAgICAgICAgICAgICBpZiAocmVmRGltICE9IG51bGwgJiYgcmVmRGltID49IDAgJiYgZGltICE9PSByZWZEaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIFwiICsgZXhjZXB0aW9uUHJlZml4ICsgXCI6IGV4cGVjdGVkIFwiICsgbmFtZXNbaV0gKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJ0byBoYXZlIHNoYXBlIFtcIiArIHNoYXBlc1tpXSArIFwiXSwgYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJbXCIgKyBhcnJheS5zaGFwZSArIFwiXS5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlzO1xufVxuZXhwb3J0cy5zdGFuZGFyZGl6ZUlucHV0RGF0YSA9IHN0YW5kYXJkaXplSW5wdXREYXRhO1xuZnVuY3Rpb24gY2hlY2tBcnJheUxlbmd0aHMoaW5wdXRzLCB0YXJnZXRzLCB3ZWlnaHRzKSB7XG4gICAgdmFyIHNldFggPSBnZW5lcmljX3V0aWxzXzEudW5pcXVlKGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5zaGFwZVswXTsgfSkpO1xuICAgIHNldFguc29ydCgpO1xuICAgIHZhciBzZXRZID0gZ2VuZXJpY191dGlsc18xLnVuaXF1ZSh0YXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQuc2hhcGVbMF07IH0pKTtcbiAgICBzZXRZLnNvcnQoKTtcbiAgICBpZiAoc2V0WC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiQWxsIGlucHV0IFRlbnNvcnMgKHgpIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzLiBcIiArXG4gICAgICAgICAgICBcIkdvdCBhcnJheSBzaGFwZXM6IFwiICtcbiAgICAgICAgICAgIChcIlwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0LnNoYXBlOyB9KSkpKTtcbiAgICB9XG4gICAgaWYgKHNldFkubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkFsbCB0YXJnZXQgVGVuc29ycyAoeSkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMuIFwiICtcbiAgICAgICAgICAgIFwiR290IGFycmF5IHNoYXBlczogXCIgK1xuICAgICAgICAgICAgKFwiXCIgKyBKU09OLnN0cmluZ2lmeSh0YXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQuc2hhcGU7IH0pKSkpO1xuICAgIH1cbiAgICBpZiAoc2V0WC5sZW5ndGggPiAwICYmIHNldFkubGVuZ3RoID4gMCAmJiAhdGZqc19jb3JlXzEudXRpbC5hcnJheXNFcXVhbChzZXRYLCBzZXRZKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklucHV0IFRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMgYXMgdGFyZ2V0IFwiICtcbiAgICAgICAgICAgIChcIlRlbnNvcnMuIEZvdW5kIFwiICsgc2V0WFswXSArIFwiIGlucHV0IHNhbXBsZShzKSBhbmQgXCIgKyBzZXRZWzBdICsgXCIgdGFyZ2V0IFwiKSArXG4gICAgICAgICAgICBcInNhbXBsZShzKS5cIik7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0FycmF5TGVuZ3RocyA9IGNoZWNrQXJyYXlMZW5ndGhzO1xuZnVuY3Rpb24gY2hlY2tMb3NzQW5kVGFyZ2V0Q29tcGF0aWJpbGl0eSh0YXJnZXRzLCBsb3NzRm5zLCBvdXRwdXRTaGFwZXMpIHtcbiAgICB2YXIga2V5TG9zc2VzID0gW1xuICAgICAgICBsb3NzZXMubWVhblNxdWFyZWRFcnJvciwgbG9zc2VzLmJpbmFyeUNyb3NzZW50cm9weSxcbiAgICAgICAgbG9zc2VzLmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5XG4gICAgXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgbG9zcyA9IGxvc3NGbnNbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IG91dHB1dFNoYXBlc1tpXTtcbiAgICAgICAgaWYgKGxvc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvc3MgPT09IGxvc3Nlcy5jYXRlZ29yaWNhbENyb3NzZW50cm9weSkge1xuICAgICAgICAgICAgaWYgKHkuc2hhcGVbeS5zaGFwZS5sZW5ndGggLSAxXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiWW91IGFyZSBwYXNzaW5nIGEgdGFyZ2V0IGFycmF5IG9mIHNoYXBlIFwiICsgeS5zaGFwZSArIFwiIHdoaWxlIHVzaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhIGxvc3MgJ2NhdGVnb3JpY2FsX2Nyb3NzZW50cm9weScuICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImV4cGVjdHMgdGFyZ2V0cyB0byBiZSBiaW5hcnkgbWF0cmljZXMgKDFzIGFuZCAwcykgb2Ygc2hhcGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIltzYW1wbGVzLCBjbGFzc2VzXS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUxvc3Nlcy5pbmRleE9mKGxvc3MpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIHNsaWNlZFlTaGFwZSA9IHkuc2hhcGUuc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgc2xpY2VkU2hhcGUgPSBzaGFwZS5zbGljZSgxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2xpY2VkWVNoYXBlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldERpbSA9IHNsaWNlZFlTaGFwZVtqXTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0RGltID0gc2xpY2VkU2hhcGVbal07XG4gICAgICAgICAgICAgICAgaWYgKG91dERpbSAhPSBudWxsICYmIHRhcmdldERpbSAhPT0gb3V0RGltKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiQSB0YXJnZXQgVGVuc29yIHdpdGggc2hhcGUgXCIgKyB5LnNoYXBlICsgXCIgd2FzIHBhc3NlZCBmb3IgYW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwib3V0cHV0IG9mIHNoYXBlIFwiICsgc2hhcGUgKyBcIiwgd2hpbGUgdXNpbmcgYSBsb3NzIGZ1bmN0aW9uIHRoYXQgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0cyB0YXJnZXRzIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGUgYXMgdGhlIG91dHB1dC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUJhdGNoZXMoc2l6ZSwgYmF0Y2hTaXplKSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHZhciBiYXRjaFN0YXJ0ID0gMDtcbiAgICB2YXIgYmF0Y2hFbmQgPSBudWxsO1xuICAgIHdoaWxlIChiYXRjaFN0YXJ0IDwgc2l6ZSkge1xuICAgICAgICBiYXRjaEVuZCA9IGJhdGNoU3RhcnQgKyBiYXRjaFNpemU7XG4gICAgICAgIGlmIChiYXRjaEVuZCA+PSBzaXplKSB7XG4gICAgICAgICAgICBiYXRjaEVuZCA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2goW2JhdGNoU3RhcnQsIGJhdGNoRW5kXSk7XG4gICAgICAgIGJhdGNoU3RhcnQgPSBiYXRjaEVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmV4cG9ydHMubWFrZUJhdGNoZXMgPSBtYWtlQmF0Y2hlcztcbmZ1bmN0aW9uIHNsaWNlQXJyYXlzKGFycmF5cywgc3RhcnQsIHN0b3ApIHtcbiAgICBpZiAoYXJyYXlzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheXMpKSB7XG4gICAgICAgIHJldHVybiBhcnJheXMubWFwKGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gSy5zbGljZUFsb25nRmlyc3RBeGlzKGFycmF5LCBzdGFydCwgc3RvcCAtIHN0YXJ0KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gSy5zbGljZUFsb25nRmlyc3RBeGlzKGFycmF5cywgc3RhcnQsIHN0b3AgLSBzdGFydCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2xpY2VBcnJheXNCeUluZGljZXMoYXJyYXlzLCBpbmRpY2VzKSB7XG4gICAgcmV0dXJuIHRmYy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGFycmF5cyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5cykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheXMubWFwKGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gc2xpY2VBcnJheXNCeUluZGljZXMoYXJyYXksIGluZGljZXMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBLLmdhdGhlcihhcnJheXMsIGluZGljZXMuZHR5cGUgPT09ICdpbnQzMicgPyBpbmRpY2VzIDogaW5kaWNlcy50b0ludCgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zbGljZUFycmF5c0J5SW5kaWNlcyA9IHNsaWNlQXJyYXlzQnlJbmRpY2VzO1xuZnVuY3Rpb24gY2hlY2tJbnB1dERhdGEoZGF0YSwgbmFtZXMsIHNoYXBlcywgY2hlY2tCYXRjaEF4aXMsIGV4Y2VwdGlvblByZWZpeCkge1xuICAgIGlmIChjaGVja0JhdGNoQXhpcyA9PT0gdm9pZCAwKSB7IGNoZWNrQmF0Y2hBeGlzID0gdHJ1ZTsgfVxuICAgIGlmIChleGNlcHRpb25QcmVmaXggPT09IHZvaWQgMCkgeyBleGNlcHRpb25QcmVmaXggPSAnJzsgfVxuICAgIHZhciBhcnJheXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCBcIiArIGV4Y2VwdGlvblByZWZpeCArIFwiOiB0aGUgQXJyYXkgb2YgXCIgK1xuICAgICAgICAgICAgICAgIFwiVGVuc29ycyB0aGF0IHlvdSBhcmUgcGFzc2luZyB0byB5b3VyIG1vZGVsIGlzIG5vdCB0aGUgc2l6ZSB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIChcInRoZSBtb2RlbCBleHBlY3RlZC4gRXhwZWN0ZWQgdG8gc2VlIFwiICsgbmFtZXMubGVuZ3RoICsgXCIgVGVuc29yKHMpLFwiKSArXG4gICAgICAgICAgICAgICAgKFwiIGJ1dCBpbnN0ZWFkIGdvdCBcIiArIGRhdGEubGVuZ3RoICsgXCIgVGVuc29ycyhzKS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5cyA9IGRhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgbW9kZWwgZXhwZWN0cyBcIiArIG5hbWVzLmxlbmd0aCArIFwiIFwiICsgZXhjZXB0aW9uUHJlZml4ICsgXCIgVGVuc29ycywgXCIgK1xuICAgICAgICAgICAgICAgIFwiYnV0IG9ubHkgcmVjZWl2ZWQgb25lIFRlbnNvci4gRm91bmQ6IGFycmF5IHdpdGggc2hhcGUgXCIgK1xuICAgICAgICAgICAgICAgIChKU09OLnN0cmluZ2lmeShkYXRhLnNoYXBlKSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlzID0gW2RhdGFdO1xuICAgIH1cbiAgICBpZiAoc2hhcGVzICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHNoYXBlc1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaV07XG4gICAgICAgICAgICBpZiAoYXJyYXkuc2hhcGUubGVuZ3RoICE9PSBzaGFwZXNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIFwiICsgZXhjZXB0aW9uUHJlZml4ICsgXCI6IGV4cGVjdGVkIFwiICsgbmFtZXNbaV0gKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcInRvIGhhdmUgXCIgKyBzaGFwZXNbaV0ubGVuZ3RoICsgXCIgZGltZW5zaW9uKHMpLCBidXQgZ290IGFycmF5IHdpdGggXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwic2hhcGUgXCIgKyBKU09OLnN0cmluZ2lmeShhcnJheS5zaGFwZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhcGVzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgJiYgIWNoZWNrQmF0Y2hBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGltID0gYXJyYXkuc2hhcGVbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlZkRpbSA9IHNoYXBlc1tpXVtqXTtcbiAgICAgICAgICAgICAgICBpZiAocmVmRGltICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkRpbSAhPT0gZGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIgKyBleGNlcHRpb25QcmVmaXggKyBcIjogZXhwZWN0ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lc1tpXSArIFwiIHRvIGhhdmUgc2hhcGUgXCIgKyBKU09OLnN0cmluZ2lmeShzaGFwZXNbaV0pICsgXCIgYnV0IFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiZ290IGFycmF5IHdpdGggc2hhcGUgXCIgKyBKU09OLnN0cmluZ2lmeShhcnJheS5zaGFwZSkgKyBcIi5cIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdE1ldHJpY3MobWV0cmljcywgb3V0cHV0TmFtZXMpIHtcbiAgICBpZiAobWV0cmljcyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobWV0cmljcykgJiYgbWV0cmljcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW107IH0pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRyaWNzKSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0TmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtZXRyaWNzOyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0cmljcyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuZXN0ZWRNZXRyaWNzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgb3V0cHV0TmFtZXNfMSA9IG91dHB1dE5hbWVzOyBfaSA8IG91dHB1dE5hbWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8yID0gb3V0cHV0TmFtZXNfMVtfaV07XG4gICAgICAgICAgICB2YXIgb3V0cHV0TWV0cmljcyA9IG1ldHJpY3MuaGFzT3duUHJvcGVydHkobmFtZV8yKSA/IG1ldHJpY3NbbmFtZV8yXSA6IFtdO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG91dHB1dE1ldHJpY3MpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0TWV0cmljcyA9IFtvdXRwdXRNZXRyaWNzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lc3RlZE1ldHJpY3MucHVzaChvdXRwdXRNZXRyaWNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkTWV0cmljcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGUgb2YgbWV0cmljcyBhcmd1bWVudCBub3QgdW5kZXJzdG9vZC4gRXhwZWN0ZWQgYW4gQXJyYXkgb3IgJyArXG4gICAgICAgICAgICAnT2JqZWN0LCBmb3VuZDogJyArIG1ldHJpY3MpO1xuICAgIH1cbn1cbnZhciBNb2RlbExvZ2dpbmdWZXJib3NpdHk7XG4oZnVuY3Rpb24gKE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eSkge1xuICAgIE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eVtNb2RlbExvZ2dpbmdWZXJib3NpdHlbXCJTSUxFTlRcIl0gPSAwXSA9IFwiU0lMRU5UXCI7XG4gICAgTW9kZWxMb2dnaW5nVmVyYm9zaXR5W01vZGVsTG9nZ2luZ1ZlcmJvc2l0eVtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xufSkoTW9kZWxMb2dnaW5nVmVyYm9zaXR5ID0gZXhwb3J0cy5Nb2RlbExvZ2dpbmdWZXJib3NpdHkgfHwgKGV4cG9ydHMuTW9kZWxMb2dnaW5nVmVyYm9zaXR5ID0ge30pKTtcbnZhciBNb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vZGVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vZGVsKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNb2RlbC5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZy5sb3NzID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sb3NzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb3NzID0gY29uZmlnLmxvc3M7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLm9wdGltaXplciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW1pemVyID0gb3B0aW1pemVycy5nZXRPcHRpbWl6ZXIoY29uZmlnLm9wdGltaXplcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShjb25maWcub3B0aW1pemVyIGluc3RhbmNlb2YgdGZqc19jb3JlXzEuT3B0aW1pemVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVXNlci1kZWZpbmVkIG9wdGltaXplciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHRmLk9wdGltaXplci5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wdGltaXplciA9IGNvbmZpZy5vcHRpbWl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvc3NGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5sb3NzKSAmJiB0eXBlb2YgY29uZmlnLmxvc3MgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnLmxvc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sb3NzID0gY29uZmlnLmxvc3M7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gY29uZmlnLmxvc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWVfMykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVW5rbm93biBlbnRyeSBpbiBsb3NzIGRpY3Rpb25hcnk6IFxcXCJcIiArIG5hbWVfMyArIFwiXFxcIi4gT25seSBleHBlY3QgdGhlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImZvbGxvd2luZyBrZXlzOiBcIiArIHRoaXMub3V0cHV0TmFtZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzQgaW4gdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9zc1tuYW1lXzRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiT3V0cHV0IFxcXCJcIiArIG5hbWVfNCArIFwiXFxcIiBpcyBtaXNzaW5nIGZyb20gbG9zcyBkaWN0aW9uYXJ5LiBXZSBhc3N1bWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGlzIHdhcyBkb25lIG9uIHB1cnBvc2UsIGFuZCB3ZSB3aWxsIG5vdCBiZSBleHBlY3RpbmcgZGF0YSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJ0byBiZSBwYXNzZWQgdG8gXCIgKyBuYW1lXzQgKyBcIiBkdXJpbmcgdHJhaW5pbmdcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb3NzRnVuY3Rpb25zLnB1c2gobG9zc2VzLmdldChjb25maWcubG9zc1tuYW1lXzRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb25maWcubG9zcykpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcubG9zcy5sZW5ndGggIT09IHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIldoZW4gcGFzc2luZyBhbiBBcnJheSBhcyBsb3NzLCBpdCBzaG91bGQgaGF2ZSBvbmUgZW50cnkgcGVyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwibW9kZWwgb3V0cHV0LiBUaGUgbW9kZWwgaGFzIFwiICsgdGhpcy5vdXRwdXRzLmxlbmd0aCArIFwiIG91dHB1dChzKSwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwiYnV0IHlvdSBwYXNzZWQgbG9zcz1cIiArIGNvbmZpZy5sb3NzICsgXCIuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aGVMb3NzZXMgPSBjb25maWcubG9zcztcbiAgICAgICAgICAgIGxvc3NGdW5jdGlvbnMgPSB0aGVMb3NzZXMubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsb3NzZXMuZ2V0KGwpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsb3NzRnVuY3Rpb25fMSA9IGxvc3Nlcy5nZXQoY29uZmlnLmxvc3MpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsb3NzRnVuY3Rpb25zLnB1c2gobG9zc0Z1bmN0aW9uXzEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb3NzRnVuY3Rpb25zID0gbG9zc0Z1bmN0aW9ucztcbiAgICAgICAgdGhpcy5mZWVkT3V0cHV0TmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mZWVkT3V0cHV0U2hhcGVzID0gW107XG4gICAgICAgIHRoaXMuZmVlZExvc3NGbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXNbaV07XG4gICAgICAgICAgICB2YXIgbmFtZV81ID0gdGhpcy5vdXRwdXROYW1lc1tpXTtcbiAgICAgICAgICAgIHRoaXMuZmVlZE91dHB1dE5hbWVzLnB1c2gobmFtZV81KTtcbiAgICAgICAgICAgIHRoaXMuZmVlZE91dHB1dFNoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMuZmVlZExvc3NGbnMucHVzaCh0aGlzLmxvc3NGdW5jdGlvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBza2lwVGFyZ2V0SW5kaWNlcyA9IFtdO1xuICAgICAgICB0aGlzLm1ldHJpY3MgPSBjb25maWcubWV0cmljcztcbiAgICAgICAgdGhpcy5tZXRyaWNzTmFtZXMgPSBbJ2xvc3MnXTtcbiAgICAgICAgdGhpcy5tZXRyaWNzVGVuc29ycyA9IFtdO1xuICAgICAgICBLLm5hbWVTY29wZSgnbG9zcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMub3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChza2lwVGFyZ2V0SW5kaWNlcy5pbmRleE9mKGkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHdlaWdodGVkTG9zcyA9IF90aGlzLmxvc3NGdW5jdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm91dHB1dHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXRyaWNzVGVuc29ycy5wdXNoKFt3ZWlnaHRlZExvc3MsIGldKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWV0cmljc05hbWVzLnB1c2goX3RoaXMub3V0cHV0TmFtZXNbaV0gKyAnX2xvc3MnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmVzdGVkTWV0cmljcyA9IGNvbGxlY3RNZXRyaWNzKGNvbmZpZy5tZXRyaWNzLCB0aGlzLm91dHB1dE5hbWVzKTtcbiAgICAgICAgdmFyIGFwcGVuZE1ldHJpYyA9IGZ1bmN0aW9uIChvdXRwdXRJbmRleCwgbWV0cmljTmFtZSwgbWV0cmljVGVuc29yKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3V0cHV0TmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIG1ldHJpY05hbWUgPSBfdGhpcy5vdXRwdXROYW1lc1tvdXRwdXRJbmRleF0gKyAnXycgKyBtZXRyaWNOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMubWV0cmljc05hbWVzLnB1c2gobWV0cmljTmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5tZXRyaWNzVGVuc29ycy5wdXNoKFttZXRyaWNUZW5zb3IsIG91dHB1dEluZGV4XSk7XG4gICAgICAgIH07XG4gICAgICAgIEsubmFtZVNjb3BlKCdtZXRyaWMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBUYXJnZXRJbmRpY2VzLmluZGV4T2YoaSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRNZXRyaWNzID0gbmVzdGVkTWV0cmljc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlTWV0cmljcyA9IGZ1bmN0aW9uIChtZXRyaWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRyaWNOYW1lUHJlZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRyaWNOYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWNjRm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRlZE1ldHJpY0ZuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbJ2FjY3VyYWN5JywgJ2FjYycsICdjcm9zc2VudHJvcHknLCAnY2UnXS5pbmRleE9mKG1ldHJpYykgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBfdGhpcy5pbnRlcm5hbE91dHB1dFNoYXBlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV0gPT09IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9zc0Z1bmN0aW9uc1tpXSA9PT0gbG9zc2VzLmJpbmFyeUNyb3NzZW50cm9weSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoWydhY2N1cmFjeScsICdhY2MnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NGbiA9IE1ldHJpY3MuYmluYXJ5QWNjdXJhY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoWydjcm9zc2VudHJvcHknLCAnY2UnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NGbiA9IE1ldHJpY3MuYmluYXJ5Q3Jvc3NlbnRyb3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmxvc3NGdW5jdGlvbnNbaV0gPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvc3Nlcy5zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoWydhY2N1cmFjeScsICdhY2MnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NGbiA9IE1ldHJpY3Muc3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChbJ2Nyb3NzZW50cm9weScsICdjZSddLmluZGV4T2YobWV0cmljKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY0ZuID0gTWV0cmljcy5zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFsnYWNjdXJhY3knLCAnYWNjJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjRm4gPSBNZXRyaWNzLmNhdGVnb3JpY2FsQWNjdXJhY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoWydjcm9zc2VudHJvcHknLCAnY2UnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NGbiA9IE1ldHJpY3MuY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoWydhY2N1cmFjeScsICdhY2MnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICdhY2MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChbJ2Nyb3NzZW50cm9weScsICdjZSddLmluZGV4T2YobWV0cmljKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gJ2NlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ZWRNZXRyaWNGbiA9IGFjY0ZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY05hbWUgPSBtZXRyaWNOYW1lUHJlZml4ICsgc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldHJpY0ZuID0gTWV0cmljcy5nZXQobWV0cmljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZE1ldHJpY0ZuID0gbWV0cmljRm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljTmFtZSA9IG1ldHJpY05hbWVQcmVmaXggKyBtZXRyaWM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0cmljUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgSy5uYW1lU2NvcGUobWV0cmljTmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY1Jlc3VsdCA9IHdlaWdodGVkTWV0cmljRm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZE1ldHJpYyhpLCBtZXRyaWNOYW1lLCBtZXRyaWNSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1ldHJpY3NfMSA9IG1ldHJpY3M7IF9pIDwgbWV0cmljc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldHJpYyA9IG1ldHJpY3NfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8yKG1ldHJpYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGhhbmRsZU1ldHJpY3Mob3V0cHV0TWV0cmljcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cyA9IHRoaXMudHJhaW5hYmxlV2VpZ2h0cztcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jaGVja1RyYWluYWJsZVdlaWdodHNDb25zaXN0ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5sZW5ndGggIT09XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rpc2NyZXBhbmN5IGJldHdlZW4gdHJhaW5hYmxld2VpZ2h0cyBhbmQgY29sbGVjdGVkIHRyYWluYWJsZSAnICtcbiAgICAgICAgICAgICAgICAnd2VpZ2h0cy4gRGlkIHlvdSBzZXQgYG1vZGVsLnRyYWluYWJsZWAgd2l0aG91dCBjYWxsaW5nICcgK1xuICAgICAgICAgICAgICAgICdgbW9kZWwuY29tcGlsZSgpYCBhZnRlcndhcmRzPycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoeCwgeSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29uZmlnLmJhdGNoU2l6ZSA9PSBudWxsID8gMzIgOiBjb25maWcuYmF0Y2hTaXplO1xuICAgICAgICB2YXIgc3RhbmRhcmRpemVkT3V0cyA9IHRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YSh4LCB5LCB0cnVlLCBiYXRjaFNpemUpO1xuICAgICAgICB2YXIgaW5zID0gc3RhbmRhcmRpemVkT3V0c1swXS5jb25jYXQoc3RhbmRhcmRpemVkT3V0c1sxXSk7XG4gICAgICAgIHRoaXMubWFrZVRlc3RGdW5jdGlvbigpO1xuICAgICAgICB2YXIgZiA9IHRoaXMudGVzdEZ1bmN0aW9uO1xuICAgICAgICB2YXIgdGVzdE91dHMgPSB0aGlzLnRlc3RMb29wKGYsIGlucywgYmF0Y2hTaXplLCBjb25maWcudmVyYm9zZSwgY29uZmlnLnN0ZXBzKTtcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHNfMS5zaW5nbGV0b25PckFycmF5KHRlc3RPdXRzKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jaGVja051bVNhbXBsZXMgPSBmdW5jdGlvbiAoaW5zLCBiYXRjaFNpemUsIHN0ZXBzLCBzdGVwc05hbWUpIHtcbiAgICAgICAgaWYgKHN0ZXBzTmFtZSA9PT0gdm9pZCAwKSB7IHN0ZXBzTmFtZSA9ICdzdGVwcyc7IH1cbiAgICAgICAgdmFyIG51bVNhbXBsZXM7XG4gICAgICAgIGlmIChzdGVwcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBudW1TYW1wbGVzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChiYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSWYgXCIgKyBzdGVwc05hbWUgKyBcIiBpcyBzZXQsIGJhdGNoU2l6ZSBtdXN0IGJlIG51bGwgb3IgdW5kZWZpbmVkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiR290IGJhdGNoU2l6ZSA9IFwiICsgYmF0Y2hTaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucykpIHtcbiAgICAgICAgICAgICAgICBudW1TYW1wbGVzID0gaW5zWzBdLnNoYXBlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtU2FtcGxlcyA9IGlucy5zaGFwZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRWl0aGVyIHRoZSBpbnB1dCBkYXRhIHNob3VsZCBoYXZlIGEgZGVmaW5lZCBzaGFwZSwgb3IgXCIgK1xuICAgICAgICAgICAgICAgIChzdGVwc05hbWUgKyBcIiBzaG91ZCBiZSBzcGVjaWZpZWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtU2FtcGxlcztcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5wcmVkaWN0TG9vcCA9IGZ1bmN0aW9uIChpbnMsIGJhdGNoU2l6ZSwgdmVyYm9zZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYmF0Y2hTaXplID09PSB2b2lkIDApIHsgYmF0Y2hTaXplID0gMzI7IH1cbiAgICAgICAgaWYgKHZlcmJvc2UgPT09IHZvaWQgMCkgeyB2ZXJib3NlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG51bVNhbXBsZXMgPSB0aGlzLmNoZWNrTnVtU2FtcGxlcyhpbnMpO1xuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ1ZlcmJvc2UgcHJlZGljdExvb3AoKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXRjaGVzID0gbWFrZUJhdGNoZXMobnVtU2FtcGxlcywgYmF0Y2hTaXplKTtcbiAgICAgICAgdmFyIG91dHMgPSBbXTtcbiAgICAgICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAoYmF0Y2hJbmRleCkge1xuICAgICAgICAgICAgdmFyIGJhdGNoT3V0cyA9IHRmYy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hTdGFydCA9IGJhdGNoZXNbYmF0Y2hJbmRleF1bMF07XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoRW5kID0gYmF0Y2hlc1tiYXRjaEluZGV4XVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zQmF0Y2ggPSBzbGljZUFycmF5cyhpbnMsIGJhdGNoU3RhcnQsIGJhdGNoRW5kKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVlZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnNCYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNCYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVlZHMucHVzaCh7IGtleTogX3RoaXMuaW5wdXRzW2ldLCB2YWx1ZTogaW5zQmF0Y2hbaV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWRzLnB1c2goeyBrZXk6IF90aGlzLmlucHV0c1swXSwgdmFsdWU6IGluc0JhdGNoIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmVlZERpY3QgPSBuZXcgZXhlY3V0b3JfMS5GZWVkRGljdChmZWVkcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dG9yXzEuZXhlY3V0ZShfdGhpcy5vdXRwdXRzLCBmZWVkRGljdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChiYXRjaEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBiYXRjaE91dHNfMSA9IGJhdGNoT3V0czsgX2kgPCBiYXRjaE91dHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoT3V0ID0gYmF0Y2hPdXRzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBvdXRzLnB1c2goYmF0Y2hPdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hPdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHNbaV0gPSBLLmNvbmNhdEFsb25nRmlyc3RBeGlzKG91dHNbaV0sIGJhdGNoT3V0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBiYXRjaEluZGV4ID0gMDsgYmF0Y2hJbmRleCA8IGJhdGNoZXMubGVuZ3RoOyArK2JhdGNoSW5kZXgpIHtcbiAgICAgICAgICAgIF9sb29wXzMoYmF0Y2hJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHNfMS5zaW5nbGV0b25PckFycmF5KG91dHMpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiAoeCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICBjaGVja0lucHV0RGF0YSh4LCB0aGlzLmlucHV0TmFtZXMsIHRoaXMuZmVlZElucHV0U2hhcGVzLCBmYWxzZSk7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBjb25maWcuYmF0Y2hTaXplID09IG51bGwgPyAzMiA6IGNvbmZpZy5iYXRjaFNpemU7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWRpY3RMb29wKHgsIGJhdGNoU2l6ZSk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUucHJlZGljdE9uQmF0Y2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBjaGVja0lucHV0RGF0YSh4LCB0aGlzLmlucHV0TmFtZXMsIHRoaXMuZmVlZElucHV0U2hhcGVzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZGljdExvb3AoeCwgeC5zaGFwZVswXSk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RhbmRhcmRpemVVc2VyRGF0YSA9IGZ1bmN0aW9uICh4LCB5LCBjaGVja0JhdGNoQXhpcywgYmF0Y2hTaXplKSB7XG4gICAgICAgIGlmIChjaGVja0JhdGNoQXhpcyA9PT0gdm9pZCAwKSB7IGNoZWNrQmF0Y2hBeGlzID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGhpcy5vcHRpbWl6ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJ1bnRpbWVFcnJvcignWW91IG11c3QgY29tcGlsZSBhIG1vZGVsIGJlZm9yZSB0cmFpbmluZy90ZXN0aW5nLiBVc2UgJyArXG4gICAgICAgICAgICAgICAgJ01vZGVsLmNvbXBpbGUobW9kZWxDb21waWxlQ29uZmlnKS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0U2hhcGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mZWVkT3V0cHV0U2hhcGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSB0aGlzLmZlZWRPdXRwdXRTaGFwZXNbaV07XG4gICAgICAgICAgICB2YXIgbG9zc0ZuID0gdGhpcy5mZWVkTG9zc0Zuc1tpXTtcbiAgICAgICAgICAgIGlmIChsb3NzRm4gPT09IGxvc3Nlcy5zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlcy5wdXNoKG91dHB1dFNoYXBlLnNsaWNlKDAsIG91dHB1dFNoYXBlLmxlbmd0aCAtIDEpLmNvbmNhdChbMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlcy5wdXNoKG91dHB1dFNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4ID0gc3RhbmRhcmRpemVJbnB1dERhdGEoeCwgdGhpcy5mZWVkSW5wdXROYW1lcywgdGhpcy5mZWVkSW5wdXRTaGFwZXMsIGZhbHNlLCAnaW5wdXQnKTtcbiAgICAgICAgeSA9IHN0YW5kYXJkaXplSW5wdXREYXRhKHksIHRoaXMuZmVlZE91dHB1dE5hbWVzLCBvdXRwdXRTaGFwZXMsIGZhbHNlLCAndGFyZ2V0Jyk7XG4gICAgICAgIGNoZWNrQXJyYXlMZW5ndGhzKHgsIHksIG51bGwpO1xuICAgICAgICBjaGVja0xvc3NBbmRUYXJnZXRDb21wYXRpYmlsaXR5KHksIHRoaXMuZmVlZExvc3NGbnMsIHRoaXMuZmVlZE91dHB1dFNoYXBlcyk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlZnVsICYmIGJhdGNoU2l6ZSAhPSBudWxsICYmIGJhdGNoU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGlmICh4WzBdLnNoYXBlWzBdICUgYmF0Y2hTaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbiBhIHN0YXRlZnVsIG5ldHdvcmssIHlvdSBzaG91bGQgb25seSBwYXNzIGlucHV0cyB3aXRoIGEgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIm51bWJlciBvZiBzYW1wbGVzIHRoYXQgaXMgZGl2aXNpYmxlIGJ5IHRoZSBiYXRjaCBzaXplIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGJhdGNoU2l6ZSArIFwiLiBGb3VuZDogXCIgKyB4WzBdLnNoYXBlWzBdICsgXCIgc2FtcGxlKHMpLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCBudWxsXTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5maXRMb29wID0gZnVuY3Rpb24gKGYsIGlucywgb3V0TGFiZWxzLCBiYXRjaFNpemUsIGVwb2NocywgdmVyYm9zZSwgY2FsbGJhY2tzLCB2YWxGLCB2YWxJbnMsIHNodWZmbGUsIGNhbGxiYWNrTWV0cmljcywgaW5pdGlhbEVwb2NoLCBzdGVwc1BlckVwb2NoLCB2YWxpZGF0aW9uU3RlcHMpIHtcbiAgICAgICAgaWYgKGluaXRpYWxFcG9jaCA9PT0gdm9pZCAwKSB7IGluaXRpYWxFcG9jaCA9IDA7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkb1ZhbGlkYXRpb24sIG51bVRyYWluU2FtcGxlcywgaW5kZXhBcnJheSwgY2FsbGJhY2tMaXN0LCBfbG9vcF80LCB0aGlzXzEsIGVwb2NoLCBzdGF0ZV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoU2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplID0gMzI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXBvY2hzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcG9jaHMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNodWZmbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNodWZmbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxFcG9jaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEVwb2NoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbEYgIT0gbnVsbCAmJiB2YWxJbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblN0ZXBzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwc1BlckVwb2NoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0NhbiBvbmx5IHVzZSBgdmFsaWRhdGlvblN0ZXBzYCB3aGVuIGRvaW5nIHN0ZXAtd2lzZSB0cmFpbmluZywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaS5lLiwgYHN0ZXBzUGVyRXBvY2hgIG11c3QgYmUgc2V0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRyYWluU2FtcGxlcyA9IHRoaXMuY2hlY2tOdW1TYW1wbGVzKGlucywgYmF0Y2hTaXplLCBzdGVwc1BlckVwb2NoLCAnc3RlcHNfcGVyX2Vwb2NoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtVHJhaW5TYW1wbGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEFycmF5ID0gbWF0aF91dGlsc18xLnJhbmdlKDAsIG51bVRyYWluU2FtcGxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgY2FsbGJhY2tzXzEuSGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gW25ldyBjYWxsYmFja3NfMS5CYXNlTG9nZ2VyKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gW25ldyBjYWxsYmFja3NfMS5CYXNlTG9nZ2VyKCldLmNvbmNhdChjYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvbmNhdChbdGhpcy5oaXN0b3J5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignVmVyYm9zZSBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0xpc3QgPSBuZXcgY2FsbGJhY2tzXzEuQ2FsbGJhY2tMaXN0KGNhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0xpc3Quc2V0TW9kZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0xpc3Quc2V0UGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcG9jaHM6IGVwb2NocyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwczogc3RlcHNQZXJFcG9jaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJib3NlOiB2ZXJib3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVmFsaWRhdGlvbjogZG9WYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY3M6IGNhbGxiYWNrTWV0cmljcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjYWxsYmFja0xpc3Qub25UcmFpbkJlZ2luKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BUcmFpbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfNCA9IGZ1bmN0aW9uIChlcG9jaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcG9jaExvZ3MsIGVwb2NoSW5kZXhBcnJheTFEXzEsIGJhdGNoZXNfMSwgX2xvb3BfNSwgYmF0Y2hJbmRleCwgc3RhdGVfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBjYWxsYmFja0xpc3Qub25FcG9jaEJlZ2luKGVwb2NoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwb2NoTG9ncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHN0ZXBzUGVyRXBvY2ggIT0gbnVsbCkpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ3N0ZXBzUGVyRXBvY2ggbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaHVmZmxlID09PSAnYmF0Y2gnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdiYXRjaCBzaHVmZmxpbmcgaXMgbm90IGltcGxlbW5ldGVkIHlldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaHVmZmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmanNfY29yZV8xLnV0aWwuc2h1ZmZsZShpbmRleEFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBvY2hJbmRleEFycmF5MURfMSA9IHRmanNfY29yZV8xLnRlbnNvcjFkKGluZGV4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoZXNfMSA9IG1ha2VCYXRjaGVzKG51bVRyYWluU2FtcGxlcywgYmF0Y2hTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF81ID0gZnVuY3Rpb24gKGJhdGNoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoTG9ncztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hMb2dzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2FsbGJhY2tMaXN0Lm9uQmF0Y2hCZWdpbihiYXRjaEluZGV4LCBiYXRjaExvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGZjLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoU3RhcnQgPSBiYXRjaGVzXzFbYmF0Y2hJbmRleF1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2hFbmQgPSBiYXRjaGVzXzFbYmF0Y2hJbmRleF1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2hJZHMgPSBLLnNsaWNlQWxvbmdGaXJzdEF4aXMoZXBvY2hJbmRleEFycmF5MURfMSwgYmF0Y2hTdGFydCwgYmF0Y2hFbmQgLSBiYXRjaFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoTG9nc1snYmF0Y2gnXSA9IGJhdGNoSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaExvZ3NbJ3NpemUnXSA9IGJhdGNoRW5kIC0gYmF0Y2hTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnNCYXRjaCA9IHNsaWNlQXJyYXlzQnlJbmRpY2VzKGlucywgYmF0Y2hJZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHMgPSBmKGluc0JhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gb3V0TGFiZWxzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBvdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoTG9nc1tsYWJlbF0gPSBvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGZjLmtlZXAob3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaEluZGV4ID09PSBiYXRjaGVzXzEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbE91dHMgPSBfdGhpcy50ZXN0TG9vcCh2YWxGLCB2YWxJbnMsIGJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBvdXRMYWJlbHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gdmFsT3V0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmYy5rZWVwKG91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcG9jaExvZ3NbJ3ZhbF8nICsgbGFiZWxdID0gb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjYWxsYmFja0xpc3Qub25CYXRjaEVuZChiYXRjaEluZGV4LCBiYXRjaExvZ3MpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzXzEuZGlzcG9zZVRlbnNvcnNJbkxvZ3MoYmF0Y2hMb2dzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfMS5zdG9wVHJhaW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgXCJicmVha1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXRjaEluZGV4IDwgYmF0Y2hlc18xLmxlbmd0aCkpIHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs1LCBfbG9vcF81KGJhdGNoSW5kZXgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZV8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZV8yID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrYmF0Y2hJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwb2NoSW5kZXhBcnJheTFEXzEuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFs0LCBjYWxsYmFja0xpc3Qub25FcG9jaEVuZChlcG9jaCwgZXBvY2hMb2dzKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzXzEuc3RvcFRyYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgXCJicmVha1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcG9jaCA9IGluaXRpYWxFcG9jaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXBvY2ggPCBlcG9jaHMpKSByZXR1cm4gWzMsIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs1LCBfbG9vcF80KGVwb2NoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICsrZXBvY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCwgY2FsbGJhY2tMaXN0Lm9uVHJhaW5FbmQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5oaXN0b3J5LnN5bmNEYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuaGlzdG9yeV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnRlc3RMb29wID0gZnVuY3Rpb24gKGYsIGlucywgYmF0Y2hTaXplLCB2ZXJib3NlLCBzdGVwcykge1xuICAgICAgICBpZiAodmVyYm9zZSA9PT0gdm9pZCAwKSB7IHZlcmJvc2UgPSAwOyB9XG4gICAgICAgIHZhciBudW1TYW1wbGVzID0gdGhpcy5jaGVja051bVNhbXBsZXMoaW5zLCBiYXRjaFNpemUsIHN0ZXBzLCAnc3RlcHMnKTtcbiAgICAgICAgdmFyIG91dHMgPSBbXTtcbiAgICAgICAgaWYgKHZlcmJvc2UgPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdWZXJib3NlIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RlcHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ3N0ZXBzIG1vZGUgaW4gdGVzdExvb3AoKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmF0Y2hlcyA9IG1ha2VCYXRjaGVzKG51bVNhbXBsZXMsIGJhdGNoU2l6ZSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhBcnJheSA9IHRmanNfY29yZV8xLnRlbnNvcjFkKG1hdGhfdXRpbHNfMS5yYW5nZSgwLCBudW1TYW1wbGVzKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBiYXRjaEluZGV4ID0gMDsgYmF0Y2hJbmRleCA8IGJhdGNoZXMubGVuZ3RoOyArK2JhdGNoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hTdGFydCA9IGJhdGNoZXNbYmF0Y2hJbmRleF1bMF07XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoRW5kID0gYmF0Y2hlc1tiYXRjaEluZGV4XVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hJZHMgPSBLLnNsaWNlQWxvbmdGaXJzdEF4aXMoaW5kZXhBcnJheSwgYmF0Y2hTdGFydCwgYmF0Y2hFbmQgLSBiYXRjaFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zQmF0Y2ggPSBzbGljZUFycmF5c0J5SW5kaWNlcyhpbnMsIGJhdGNoSWRzKTtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hPdXRzID0gZihpbnNCYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKGJhdGNoSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaE91dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHMucHVzaChLLmdldFNjYWxhcigwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaE91dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoT3V0ID0gYmF0Y2hPdXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBvdXRzW2ldID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRmYy5hZGQob3V0c1tpXSwgSy5zY2FsYXJUaW1lc0FycmF5KEsuZ2V0U2NhbGFyKGJhdGNoRW5kIC0gYmF0Y2hTdGFydCksIGJhdGNoT3V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgb3V0c1tpXSA9IHRmYy5kaXYob3V0c1tpXSwgSy5nZXRTY2FsYXIobnVtU2FtcGxlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRzO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmdldERlZHVwZWRNZXRyaWNzTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXRMYWJlbHMgPSB0aGlzLm1ldHJpY3NOYW1lcztcbiAgICAgICAgdmFyIGRlZHVwZWRPdXRMYWJlbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IG91dExhYmVsc1tpXTtcbiAgICAgICAgICAgIHZhciBuZXdMYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgaWYgKGdlbmVyaWNfdXRpbHNfMS5jb3VudChvdXRMYWJlbHMsIGxhYmVsKSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHVwSW5kZXggPSBnZW5lcmljX3V0aWxzXzEuY291bnQob3V0TGFiZWxzLnNsaWNlKDAsIGkpLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgbmV3TGFiZWwgKz0gXCJfXCIgKyBkdXBJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZHVwZWRPdXRMYWJlbHMucHVzaChuZXdMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZHVwZWRPdXRMYWJlbHM7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUubWFrZVRlc3RGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50ZXN0RnVuY3Rpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRmYy50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsT3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbExvc3M7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0cyA9IGRhdGEuc2xpY2UoMCwgX3RoaXMuaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBkYXRhLnNsaWNlKF90aGlzLmlucHV0cy5sZW5ndGgsIF90aGlzLmlucHV0cy5sZW5ndGggKyBfdGhpcy5vdXRwdXRzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGZlZWRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZHMucHVzaCh7IGtleTogX3RoaXMuaW5wdXRzW2ldLCB2YWx1ZTogaW5wdXRzW2ldIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmVlZERpY3QgPSBuZXcgZXhlY3V0b3JfMS5GZWVkRGljdChmZWVkcyk7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dHMgPSBleGVjdXRvcl8xLmV4ZWN1dGUoX3RoaXMub3V0cHV0cywgZmVlZERpY3QpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubG9zc0Z1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9zc0Z1bmN0aW9uID0gX3RoaXMubG9zc0Z1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvc3MgPSB0ZmMubWVhbihsb3NzRnVuY3Rpb24odGFyZ2V0c1tpXSwgb3V0cHV0c1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMb3NzID0gbG9zcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTG9zcyA9IHRmYy5hZGQodG90YWxMb3NzLCBsb3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWxPdXRwdXRzLnB1c2godG90YWxMb3NzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5tZXRyaWNzVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0cmljID0gX3RoaXMubWV0cmljc1RlbnNvcnNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRJbmRleCA9IF90aGlzLm1ldHJpY3NUZW5zb3JzW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVhbk1ldHJpYyA9IHRmYy5tZWFuKG1ldHJpYyh0YXJnZXRzW291dHB1dEluZGV4XSwgb3V0cHV0c1tvdXRwdXRJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsT3V0cHV0cy5wdXNoKG1lYW5NZXRyaWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsT3V0cHV0cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uICh4LCB5LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYmF0Y2hTaXplLCBzdGFuZGFyZGl6ZWRPdXRzLCBpbnB1dHMsIHRhcmdldHMsIGRvVmFsaWRhdGlvbiwgdmFsWCwgdmFsWSwgdmFsSW5zLCBuZWVkVmFsaWRhdGlvbkRpc3Bvc2FsLCB2YWxTdGFuZGFyZGl6ZWQsIHNwbGl0QXQsIG9yaWdpbmFsQmF0Y2hTaXplLCBpbnMsIHRyYWluRnVuY3Rpb24sIG91dExhYmVscywgdmFsRnVuY3Rpb24sIGNhbGxiYWNrTWV0cmljcywgY2FsbGJhY2tzLCBvdXQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemUgPSBjb25maWcuYmF0Y2hTaXplID09IG51bGwgPyAzMiA6IGNvbmZpZy5iYXRjaFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZWRPdXRzID0gdGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhKHgsIHksIGZhbHNlLCBiYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzID0gc3RhbmRhcmRpemVkT3V0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHMgPSBzdGFuZGFyZGl6ZWRPdXRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9WYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkVmFsaWRhdGlvbkRpc3Bvc2FsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnZhbGlkYXRpb25EYXRhICE9IG51bGwgJiYgY29uZmlnLnZhbGlkYXRpb25EYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcudmFsaWRhdGlvbkRhdGEubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFggPSBjb25maWcudmFsaWRhdGlvbkRhdGFbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFkgPSBjb25maWcudmFsaWRhdGlvbkRhdGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy52YWxpZGF0aW9uRGF0YS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ3ZhbGlkYXRpb25EYXRhIGluY2x1ZGluZyBzYW1wbGUgd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiV2hlbiBwYXNzaW5nIHZhbGlkYXRpb24gZGF0YSwgaXQgbXVzdCBjb250YWluIDIgKHZhbFgsIHZhbFkpIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3IgMyAodmFsWCwgdmFsWSwgdmFsU2FtcGxlV2VpZ2h0KSBpdGVtczsgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmZpZy52YWxpZGF0aW9uRGF0YSArIFwiIGlzIGludmFsaWQuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsU3RhbmRhcmRpemVkID0gdGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhKHZhbFgsIHZhbFksIHRydWUsIGJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsWCA9IHZhbFN0YW5kYXJkaXplZFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxZID0gdmFsU3RhbmRhcmRpemVkWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbElucyA9IHZhbFguY29uY2F0KHZhbFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLnZhbGlkYXRpb25TcGxpdCAhPSBudWxsICYmIGNvbmZpZy52YWxpZGF0aW9uU3BsaXQgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnZhbGlkYXRpb25TcGxpdCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0QXQgPSBNYXRoLmZsb29yKGlucHV0c1swXS5zaGFwZVswXSAqICgxIC0gY29uZmlnLnZhbGlkYXRpb25TcGxpdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQmF0Y2hTaXplID0gaW5wdXRzWzBdLnNoYXBlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFggPSBzbGljZUFycmF5cyhpbnB1dHMsIHNwbGl0QXQsIG9yaWdpbmFsQmF0Y2hTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMgPSBzbGljZUFycmF5cyhpbnB1dHMsIDAsIHNwbGl0QXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFkgPSBzbGljZUFycmF5cyh0YXJnZXRzLCBzcGxpdEF0LCBvcmlnaW5hbEJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cyA9IHNsaWNlQXJyYXlzKHRhcmdldHMsIDAsIHNwbGl0QXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRWYWxpZGF0aW9uRGlzcG9zYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbElucyA9IHZhbFguY29uY2F0KHZhbFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLnZhbGlkYXRpb25TdGVwcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9WYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucyA9IGlucHV0cy5jb25jYXQodGFyZ2V0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbkZ1bmN0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9zc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvc3NWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRzID0gZGF0YS5zbGljZSgwLCBfdGhpcy5pbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGRhdGEuc2xpY2UoX3RoaXMuaW5wdXRzLmxlbmd0aCwgX3RoaXMuaW5wdXRzLmxlbmd0aCArIF90aGlzLm91dHB1dHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0cmljc1ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbExvc3NGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZlZWRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWVkcy5wdXNoKHsga2V5OiBfdGhpcy5pbnB1dHNbaV0sIHZhbHVlOiBpbnB1dHNbaV0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZlZWREaWN0ID0gbmV3IGV4ZWN1dG9yXzEuRmVlZERpY3QoZmVlZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0cyA9IGV4ZWN1dG9yXzEuZXhlY3V0ZShfdGhpcy5vdXRwdXRzLCBmZWVkRGljdCwgeyAndHJhaW5pbmcnOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxMb3NzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmxvc3NGdW5jdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb3NzRnVuY3Rpb24gPSBfdGhpcy5sb3NzRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvc3MgPSBsb3NzRnVuY3Rpb24odGFyZ2V0c1tpXSwgb3V0cHV0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3NzZXMucHVzaChsb3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZWFuTG9zcyA9IHRmYy5tZWFuKGxvc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9zc1ZhbHVlcy5wdXNoKG1lYW5Mb3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMb3NzID0gbG9zcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTG9zcyA9IHRmYy5hZGQodG90YWxMb3NzLCBsb3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLm1ldHJpY3NUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0cmljID0gX3RoaXMubWV0cmljc1RlbnNvcnNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSBfdGhpcy5tZXRyaWNzVGVuc29yc1tpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZWFuTWV0cmljID0gdGZjLm1lYW4obWV0cmljKHRhcmdldHNbb3V0cHV0SW5kZXhdLCBvdXRwdXRzW291dHB1dEluZGV4XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGZjLmtlZXAobWVhbk1ldHJpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzVmFsdWVzLnB1c2gobWVhbk1ldHJpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMb3NzID0gdGZjLm1lYW4odG90YWxMb3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsY3VsYXRlTG9zc2VzKCkuZm9yRWFjaChmdW5jdGlvbiAocmVndWxhcml6ZXJMb3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbExvc3MgPSB0ZmMuYWRkKHRvdGFsTG9zcywgcmVndWxhcml6ZXJMb3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbExvc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVzID0gX3RoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5yZWFkKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5Db3N0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxMb3NzVmFsdWUgPSBfdGhpcy5vcHRpbWl6ZXIubWluaW1pemUodG90YWxMb3NzRnVuY3Rpb24sIHJldHVybkNvc3QsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0b3RhbExvc3NWYWx1ZV0uY29uY2F0KG1ldHJpY3NWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dExhYmVscyA9IHRoaXMuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVRlc3RGdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbEZ1bmN0aW9uID0gdGhpcy50ZXN0RnVuY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNZXRyaWNzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0TGFiZWxzLnNsaWNlKCkuY29uY2F0KG91dExhYmVscy5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuICd2YWxfJyArIG47IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbEZ1bmN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxJbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01ldHJpY3MgPSBvdXRMYWJlbHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrc18xLnN0YW5kYXJkaXplQ2FsbGJhY2tzKGNvbmZpZy5jYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLmZpdExvb3AodHJhaW5GdW5jdGlvbiwgaW5zLCBvdXRMYWJlbHMsIGJhdGNoU2l6ZSwgY29uZmlnLmVwb2NocywgY29uZmlnLnZlcmJvc2UsIGNhbGxiYWNrcywgdmFsRnVuY3Rpb24sIHZhbElucywgY29uZmlnLnNodWZmbGUsIGNhbGxiYWNrTWV0cmljcywgbnVsbCwgbnVsbCwgbnVsbCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFZhbGlkYXRpb25EaXNwb3NhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbElucy5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3IpIHsgcmV0dXJuIHRlbnNvci5kaXNwb3NlKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3IpIHsgcmV0dXJuIHRlbnNvci5kaXNwb3NlKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7IHJldHVybiB0ZW5zb3IuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgb3V0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0TmFtZWRXZWlnaHRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgbmFtZWRXZWlnaHRzID0ge307XG4gICAgICAgIHZhciB0cmFpbmFibGVPbmx5ID0gY29uZmlnICE9IG51bGwgJiYgY29uZmlnLnRyYWluYWJsZU9ubHk7XG4gICAgICAgIHZhciB3ZWlnaHRzID0gdHJhaW5hYmxlT25seSA/IHRoaXMudHJhaW5hYmxlV2VpZ2h0cyA6IHRoaXMud2VpZ2h0cztcbiAgICAgICAgdmFyIHdlaWdodFZhbHVlcyA9IHRoaXMuZ2V0V2VpZ2h0cyh0cmFpbmFibGVPbmx5KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHJhaW5hYmxlT25seSAmJiAhd2VpZ2h0c1tpXS50cmFpbmFibGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWVkV2VpZ2h0c1t3ZWlnaHRzW2ldLm9yaWdpbmFsTmFtZV0gPSB3ZWlnaHRWYWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVkV2VpZ2h0cztcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGhhbmRsZXJPclVSTCwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVycywgd2VpZ2h0RGF0YUFuZFNwZWNzLCByZXR1cm5TdHJpbmcsIHVudXNlZEFyZywgbW9kZWxDb25maWc7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXJPclVSTCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IHRmanNfY29yZV8xLmlvLmdldFNhdmVIYW5kbGVycyhoYW5kbGVyT3JVUkwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJDYW5ub3QgZmluZCBhbnkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICdcIiArIGhhbmRsZXJPclVSTCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkZvdW5kIG1vcmUgdGhhbiBvbmUgKFwiICsgaGFuZGxlcnMubGVuZ3RoICsgXCIpIHNhdmUgaGFuZGxlcnMgZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlVSTCAnXCIgKyBoYW5kbGVyT3JVUkwgKyBcIidcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyT3JVUkwgPSBoYW5kbGVyc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyT3JVUkwuc2F2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ01vZGVsLnNhdmUoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBoYXZlIHRoZSBgc2F2ZWAgYXR0cmlidXRlIGRlZmluZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRmanNfY29yZV8xLmlvLmVuY29kZVdlaWdodHModGhpcy5nZXROYW1lZFdlaWdodHMoY29uZmlnKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHREYXRhQW5kU3BlY3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5TdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVudXNlZEFyZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbENvbmZpZyA9IHRoaXMudG9KU09OKHVudXNlZEFyZywgcmV0dXJuU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgaGFuZGxlck9yVVJMLnNhdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFRvcG9sb2d5OiBtb2RlbENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0RGF0YTogd2VpZ2h0RGF0YUFuZFNwZWNzLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodFNwZWNzOiB3ZWlnaHREYXRhQW5kU3BlY3Muc3BlY3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTW9kZWwuY2xhc3NOYW1lID0gJ01vZGVsJztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF0gfSlcbiAgICBdLCBNb2RlbC5wcm90b3R5cGUsIFwiY29tcGlsZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgY29uZmlnUGFyYW1JbmRpY2VzOiBbMl0gfSlcbiAgICBdLCBNb2RlbC5wcm90b3R5cGUsIFwiZXZhbHVhdGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGNvbmZpZ1BhcmFtSW5kaWNlczogWzFdIH0pXG4gICAgXSwgTW9kZWwucHJvdG90eXBlLCBcInByZWRpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBNb2RlbC5wcm90b3R5cGUsIFwicHJlZGljdE9uQmF0Y2hcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGNvbmZpZ1BhcmFtSW5kaWNlczogWzJdIH0pXG4gICAgXSwgTW9kZWwucHJvdG90eXBlLCBcImZpdFwiLCBudWxsKTtcbiAgICBNb2RlbCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgTW9kZWwpO1xuICAgIHJldHVybiBNb2RlbDtcbn0odG9wb2xvZ3lfMS5Db250YWluZXIpKTtcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihNb2RlbCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFpbmluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEF0dHJpYnV0ZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXR0cmlidXRlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXR0cmlidXRlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEF0dHJpYnV0ZUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEF0dHJpYnV0ZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5BdHRyaWJ1dGVFcnJvciA9IEF0dHJpYnV0ZUVycm9yO1xudmFyIFJ1bnRpbWVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJ1bnRpbWVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSdW50aW1lRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFJ1bnRpbWVFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSdW50aW1lRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlJ1bnRpbWVFcnJvciA9IFJ1bnRpbWVFcnJvcjtcbnZhciBWYWx1ZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsdWVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWYWx1ZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBWYWx1ZUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFZhbHVlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlZhbHVlRXJyb3IgPSBWYWx1ZUVycm9yO1xudmFyIE5vdEltcGxlbWVudGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RJbXBsZW1lbnRlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vdEltcGxlbWVudGVkRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE5vdEltcGxlbWVudGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTm90SW1wbGVtZW50ZWRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuTm90SW1wbGVtZW50ZWRFcnJvciA9IE5vdEltcGxlbWVudGVkRXJyb3I7XG52YXIgQXNzZXJ0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3NlcnRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG52YXIgSW5kZXhFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZGV4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5kZXhFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgSW5kZXhFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbmRleEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5JbmRleEVycm9yID0gSW5kZXhFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgY29uc3RyYWludHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRzXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgdHJhaW5pbmdfMSA9IHJlcXVpcmUoXCIuL2VuZ2luZS90cmFpbmluZ1wiKTtcbnZhciBpbml0aWFsaXplcnNfMSA9IHJlcXVpcmUoXCIuL2luaXRpYWxpemVyc1wiKTtcbnZhciBhZHZhbmNlZF9hY3RpdmF0aW9uc18xID0gcmVxdWlyZShcIi4vbGF5ZXJzL2FkdmFuY2VkX2FjdGl2YXRpb25zXCIpO1xudmFyIGNvbnZvbHV0aW9uYWxfMSA9IHJlcXVpcmUoXCIuL2xheWVycy9jb252b2x1dGlvbmFsXCIpO1xudmFyIGNvbnZvbHV0aW9uYWxfZGVwdGh3aXNlXzEgPSByZXF1aXJlKFwiLi9sYXllcnMvY29udm9sdXRpb25hbF9kZXB0aHdpc2VcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vbGF5ZXJzL2NvcmVcIik7XG52YXIgZW1iZWRkaW5nc18xID0gcmVxdWlyZShcIi4vbGF5ZXJzL2VtYmVkZGluZ3NcIik7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoXCIuL2xheWVycy9tZXJnZVwiKTtcbnZhciBub3JtYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi9sYXllcnMvbm9ybWFsaXphdGlvblwiKTtcbnZhciBwYWRkaW5nXzEgPSByZXF1aXJlKFwiLi9sYXllcnMvcGFkZGluZ1wiKTtcbnZhciBwb29saW5nXzEgPSByZXF1aXJlKFwiLi9sYXllcnMvcG9vbGluZ1wiKTtcbnZhciByZWN1cnJlbnRfMSA9IHJlcXVpcmUoXCIuL2xheWVycy9yZWN1cnJlbnRcIik7XG52YXIgd3JhcHBlcnNfMSA9IHJlcXVpcmUoXCIuL2xheWVycy93cmFwcGVyc1wiKTtcbnZhciBsb3NzZXNfMSA9IHJlcXVpcmUoXCIuL2xvc3Nlc1wiKTtcbnZhciBtZXRyaWNzXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzXCIpO1xudmFyIG1vZGVsc18xID0gcmVxdWlyZShcIi4vbW9kZWxzXCIpO1xudmFyIHJlZ3VsYXJpemVyc18xID0gcmVxdWlyZShcIi4vcmVndWxhcml6ZXJzXCIpO1xudmFyIE1vZGVsRXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kZWxFeHBvcnRzKCkge1xuICAgIH1cbiAgICBNb2RlbEV4cG9ydHMubW9kZWwgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJhaW5pbmdfMS5Nb2RlbChjb25maWcpO1xuICAgIH07XG4gICAgTW9kZWxFeHBvcnRzLnNlcXVlbnRpYWwgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgbW9kZWxzXzEuU2VxdWVudGlhbChjb25maWcpO1xuICAgIH07XG4gICAgTW9kZWxFeHBvcnRzLmxvYWRNb2RlbCA9IGZ1bmN0aW9uIChwYXRoT3JJT0hhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsc18xLmxvYWRNb2RlbEludGVybmFsKHBhdGhPcklPSGFuZGxlcik7XG4gICAgfTtcbiAgICBNb2RlbEV4cG9ydHMuaW5wdXQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0b3BvbG9neV8xLklucHV0KGNvbmZpZyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicsIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdIH0pXG4gICAgXSwgTW9kZWxFeHBvcnRzLCBcIm1vZGVsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJywgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF0gfSlcbiAgICBdLCBNb2RlbEV4cG9ydHMsIFwic2VxdWVudGlhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdNb2RlbHMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0xvYWRpbmcnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdsb2FkTW9kZWxJbnRlcm5hbCdcbiAgICAgICAgfSlcbiAgICBdLCBNb2RlbEV4cG9ydHMsIFwibG9hZE1vZGVsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ01vZGVscycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnSW5wdXRzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnSW5wdXQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBNb2RlbEV4cG9ydHMsIFwiaW5wdXRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIE1vZGVsRXhwb3J0cztcbn0oKSk7XG5leHBvcnRzLk1vZGVsRXhwb3J0cyA9IE1vZGVsRXhwb3J0cztcbnZhciBMYXllckV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExheWVyRXhwb3J0cygpIHtcbiAgICB9XG4gICAgTGF5ZXJFeHBvcnRzLmlucHV0TGF5ZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgdG9wb2xvZ3lfMS5JbnB1dExheWVyKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuZWx1ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGFkdmFuY2VkX2FjdGl2YXRpb25zXzEuRUxVKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMubGVha3lSZUxVID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGFkdmFuY2VkX2FjdGl2YXRpb25zXzEuTGVha3lSZUxVKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuc29mdG1heCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhZHZhbmNlZF9hY3RpdmF0aW9uc18xLlNvZnRtYXgoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy50aHJlc2hvbGRlZFJlTFUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgYWR2YW5jZWRfYWN0aXZhdGlvbnNfMS5UaHJlc2hvbGRlZFJlTFUoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5jb252MWQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29udm9sdXRpb25hbF8xLkNvbnYxRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmNvbnYyZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb252b2x1dGlvbmFsXzEuQ29udjJEKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuY29udjJkVHJhbnNwb3NlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvbnZvbHV0aW9uYWxfMS5Db252MkRUcmFuc3Bvc2UoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5zZXBhcmFibGVDb252MmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29udm9sdXRpb25hbF8xLlNlcGFyYWJsZUNvbnYyRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmNyb3BwaW5nMkQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29udm9sdXRpb25hbF8xLkNyb3BwaW5nMkQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy51cFNhbXBsaW5nMmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29udm9sdXRpb25hbF8xLlVwU2FtcGxpbmcyRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmRlcHRod2lzZUNvbnYyZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb252b2x1dGlvbmFsX2RlcHRod2lzZV8xLkRlcHRod2lzZUNvbnYyRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmFjdGl2YXRpb24gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29yZV8xLkFjdGl2YXRpb24oY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5kZW5zZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlXzEuRGVuc2UoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5kcm9wb3V0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNvcmVfMS5Ecm9wb3V0KGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlXzEuRmxhdHRlbihjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLnJlcGVhdFZlY3RvciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlXzEuUmVwZWF0VmVjdG9yKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMucmVzaGFwZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlXzEuUmVzaGFwZShjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmVtYmVkZGluZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlbWJlZGRpbmdzXzEuRW1iZWRkaW5nKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuYWRkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IG1lcmdlXzEuQWRkKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuYXZlcmFnZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXJnZV8xLkF2ZXJhZ2UoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5jb25jYXRlbmF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXJnZV8xLkNvbmNhdGVuYXRlKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMubWF4aW11bSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXJnZV8xLk1heGltdW0oY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5taW5pbXVtID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IG1lcmdlXzEuTWluaW11bShjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLm11bHRpcGx5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IG1lcmdlXzEuTXVsdGlwbHkoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5iYXRjaE5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgbm9ybWFsaXphdGlvbl8xLkJhdGNoTm9ybWFsaXphdGlvbihjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLnplcm9QYWRkaW5nMmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcGFkZGluZ18xLlplcm9QYWRkaW5nMkQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5hdmVyYWdlUG9vbGluZzFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHBvb2xpbmdfMS5BdmVyYWdlUG9vbGluZzFEKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuYXZnUG9vbDFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gTGF5ZXJFeHBvcnRzLmF2ZXJhZ2VQb29saW5nMWQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5hdmdQb29saW5nMWQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBMYXllckV4cG9ydHMuYXZlcmFnZVBvb2xpbmcxZChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmF2ZXJhZ2VQb29saW5nMmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9vbGluZ18xLkF2ZXJhZ2VQb29saW5nMkQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5hdmdQb29sMmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBMYXllckV4cG9ydHMuYXZlcmFnZVBvb2xpbmcyZChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmF2Z1Bvb2xpbmcyZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIExheWVyRXhwb3J0cy5hdmVyYWdlUG9vbGluZzJkKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuZ2xvYmFsQXZlcmFnZVBvb2xpbmcxZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwb29saW5nXzEuR2xvYmFsQXZlcmFnZVBvb2xpbmcxRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmdsb2JhbEF2ZXJhZ2VQb29saW5nMmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9vbGluZ18xLkdsb2JhbEF2ZXJhZ2VQb29saW5nMkQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5nbG9iYWxNYXhQb29saW5nMWQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9vbGluZ18xLkdsb2JhbE1heFBvb2xpbmcxRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmdsb2JhbE1heFBvb2xpbmcyZCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwb29saW5nXzEuR2xvYmFsTWF4UG9vbGluZzJEKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMubWF4UG9vbGluZzFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHBvb2xpbmdfMS5NYXhQb29saW5nMUQoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5tYXhQb29saW5nMmQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9vbGluZ18xLk1heFBvb2xpbmcyRChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmdydSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWN1cnJlbnRfMS5HUlUoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5ncnVDZWxsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHJlY3VycmVudF8xLkdSVUNlbGwoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5sc3RtID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHJlY3VycmVudF8xLkxTVE0oY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5sc3RtQ2VsbCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWN1cnJlbnRfMS5MU1RNQ2VsbChjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLnNpbXBsZVJOTiA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWN1cnJlbnRfMS5TaW1wbGVSTk4oY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5zaW1wbGVSTk5DZWxsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHJlY3VycmVudF8xLlNpbXBsZVJOTkNlbGwoY29uZmlnKTtcbiAgICB9O1xuICAgIExheWVyRXhwb3J0cy5ybm4gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVjdXJyZW50XzEuUk5OKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuc3RhY2tlZFJOTkNlbGxzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHJlY3VycmVudF8xLlN0YWNrZWRSTk5DZWxscyhjb25maWcpO1xuICAgIH07XG4gICAgTGF5ZXJFeHBvcnRzLmJpZGlyZWN0aW9uYWwgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfMS5CaWRpcmVjdGlvbmFsKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMudGltZURpc3RyaWJ1dGVkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IHdyYXBwZXJzXzEuVGltZURpc3RyaWJ1dGVkKGNvbmZpZyk7XG4gICAgfTtcbiAgICBMYXllckV4cG9ydHMuTGF5ZXIgPSB0b3BvbG9neV8xLkxheWVyO1xuICAgIExheWVyRXhwb3J0cy5STk4gPSByZWN1cnJlbnRfMS5STk47XG4gICAgTGF5ZXJFeHBvcnRzLlJOTkNlbGwgPSByZWN1cnJlbnRfMS5STk5DZWxsO1xuICAgIExheWVyRXhwb3J0cy5pbnB1dCA9IE1vZGVsRXhwb3J0cy5pbnB1dDtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0lucHV0cycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdJbnB1dExheWVyJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImlucHV0TGF5ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdBZHZhbmNlZCBBY3RpdmF0aW9uJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0VMVScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdBZHZhbmNlZCBBY3RpdmF0aW9uJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0xlYWt5UmVMVScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJsZWFreVJlTFVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdBZHZhbmNlZCBBY3RpdmF0aW9uJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1NvZnRtYXgnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwic29mdG1heFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0FkdmFuY2VkIEFjdGl2YXRpb24nLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnVGhyZXNob2xkZWRSZUxVJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInRocmVzaG9sZGVkUmVMVVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uYWwnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQ29udjFEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImNvbnYxZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uYWwnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQ29udjJEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImNvbnYyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uYWwnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQ29udjJEVHJhbnNwb3NlJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImNvbnYyZFRyYW5zcG9zZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uYWwnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnU2VwYXJhYmxlQ29udjJEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInNlcGFyYWJsZUNvbnYyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uYWwnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQ3JvcHBpbmcyRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJjcm9wcGluZzJEXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQ29udm9sdXRpb25hbCcsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdVcFNhbXBsaW5nMkQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwidXBTYW1wbGluZzJkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQ29udm9sdXRpb25hbCcsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdEZXB0aHdpc2VDb252MkQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiZGVwdGh3aXNlQ29udjJkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQmFzaWMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQWN0aXZhdGlvbicsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJhY3RpdmF0aW9uXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQmFzaWMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnRGVuc2UnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiZGVuc2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdCYXNpYycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdEcm9wb3V0JyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImRyb3BvdXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdCYXNpYycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdGbGF0dGVuJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImZsYXR0ZW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdCYXNpYycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdSZXBlYXRWZWN0b3InLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwicmVwZWF0VmVjdG9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQmFzaWMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnUmVzaGFwZScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJyZXNoYXBlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnQmFzaWMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnRW1iZWRkaW5nJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImVtYmVkZGluZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ01lcmdlJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0FkZCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJhZGRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdNZXJnZScsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdBdmVyYWdlJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImF2ZXJhZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdNZXJnZScsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdDb25jYXRlbmF0ZScsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJjb25jYXRlbmF0ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ01lcmdlJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ01heGltdW0nLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwibWF4aW11bVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ01lcmdlJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ01pbmltdW0nLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwibWluaW11bVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ01lcmdlJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ011bHRpcGx5JyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcIm11bHRpcGx5XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnTm9ybWFsaXphdGlvbicsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdCYXRjaE5vcm1hbGl6YXRpb24nLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnUGFkZGluZycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdaZXJvUGFkZGluZzJEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInplcm9QYWRkaW5nMmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdQb29saW5nJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0F2ZXJhZ2VQb29saW5nMUQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiYXZlcmFnZVBvb2xpbmcxZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1Bvb2xpbmcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnQXZlcmFnZVBvb2xpbmcyRCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJhdmVyYWdlUG9vbGluZzJkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnUG9vbGluZycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdHbG9iYWxBdmVyYWdlUG9vbGluZzFEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImdsb2JhbEF2ZXJhZ2VQb29saW5nMWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdQb29saW5nJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0dsb2JhbEF2ZXJhZ2VQb29saW5nMkQnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiZ2xvYmFsQXZlcmFnZVBvb2xpbmcyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1Bvb2xpbmcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnR2xvYmFsTWF4UG9vbGluZzFEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImdsb2JhbE1heFBvb2xpbmcxZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1Bvb2xpbmcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnR2xvYmFsTWF4UG9vbGluZzJEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImdsb2JhbE1heFBvb2xpbmcyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1Bvb2xpbmcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnTWF4UG9vbGluZzFEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcIm1heFBvb2xpbmcxZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1Bvb2xpbmcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnTWF4UG9vbGluZzJEJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcIm1heFBvb2xpbmcyZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1JlY3VycmVudCcsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdHUlUnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiZ3J1XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnUmVjdXJyZW50JyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0dSVUNlbGwnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwiZ3J1Q2VsbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1JlY3VycmVudCcsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdMU1RNJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImxzdG1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdSZWN1cnJlbnQnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnTFNUTUNlbGwnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwibHN0bUNlbGxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdSZWN1cnJlbnQnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnU2ltcGxlUk5OJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInNpbXBsZVJOTlwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1JlY3VycmVudCcsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdTaW1wbGVSTk5DZWxsJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInNpbXBsZVJOTkNlbGxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdSZWN1cnJlbnQnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnUk5OJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcInJublwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdMYXllcnMnLFxuICAgICAgICAgICAgc3ViaGVhZGluZzogJ1JlY3VycmVudCcsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdSTk4nLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBMYXllckV4cG9ydHMsIFwic3RhY2tlZFJOTkNlbGxzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0xheWVycycsXG4gICAgICAgICAgICBzdWJoZWFkaW5nOiAnV3JhcHBlcicsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdCaWRpcmVjdGlvbmFsJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgTGF5ZXJFeHBvcnRzLCBcImJpZGlyZWN0aW9uYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICAgICAgICAgIHN1YmhlYWRpbmc6ICdXcmFwcGVyJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2xheWVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1RpbWVEaXN0cmlidXRlZCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIExheWVyRXhwb3J0cywgXCJ0aW1lRGlzdHJpYnV0ZWRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIExheWVyRXhwb3J0cztcbn0oKSk7XG5leHBvcnRzLkxheWVyRXhwb3J0cyA9IExheWVyRXhwb3J0cztcbnZhciBDb25zdHJhaW50RXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uc3RyYWludEV4cG9ydHMoKSB7XG4gICAgfVxuICAgIENvbnN0cmFpbnRFeHBvcnRzLm1heE5vcm0gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29uc3RyYWludHNfMS5NYXhOb3JtKGNvbmZpZyk7XG4gICAgfTtcbiAgICBDb25zdHJhaW50RXhwb3J0cy51bml0Tm9ybSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJhaW50c18xLlVuaXROb3JtKGNvbmZpZyk7XG4gICAgfTtcbiAgICBDb25zdHJhaW50RXhwb3J0cy5ub25OZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29uc3RyYWludHNfMS5Ob25OZWcoKTtcbiAgICB9O1xuICAgIENvbnN0cmFpbnRFeHBvcnRzLm1pbk1heE5vcm0gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29uc3RyYWludHNfMS5NaW5NYXhOb3JtKGNvbmZpZyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdDb25zdHJhaW50cycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdjb25zdHJhaW50cycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ01heE5vcm0nLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBDb25zdHJhaW50RXhwb3J0cywgXCJtYXhOb3JtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0NvbnN0cmFpbnRzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2NvbnN0cmFpbnRzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnVW5pdE5vcm0nLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBDb25zdHJhaW50RXhwb3J0cywgXCJ1bml0Tm9ybVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ0NvbnN0cmFpbnRzJywgbmFtZXNwYWNlOiAnY29uc3RyYWludHMnLCB1c2VEb2NzRnJvbTogJ05vbk5lZycgfSlcbiAgICBdLCBDb25zdHJhaW50RXhwb3J0cywgXCJub25OZWdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnQ29uc3RyYWludHMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnY29uc3RyYWludHMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdNaW5NYXhOb3JtQ29uZmlnJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgQ29uc3RyYWludEV4cG9ydHMsIFwibWluTWF4Tm9ybVwiLCBudWxsKTtcbiAgICByZXR1cm4gQ29uc3RyYWludEV4cG9ydHM7XG59KCkpO1xuZXhwb3J0cy5Db25zdHJhaW50RXhwb3J0cyA9IENvbnN0cmFpbnRFeHBvcnRzO1xudmFyIEluaXRpYWxpemVyRXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6ZXJFeHBvcnRzKCkge1xuICAgIH1cbiAgICBJbml0aWFsaXplckV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuWmVyb3MoKTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyRXhwb3J0cy5vbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLk9uZXMoKTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyRXhwb3J0cy5jb25zdGFudCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbml0aWFsaXplcnNfMS5Db25zdGFudChjb25maWcpO1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXJFeHBvcnRzLnJhbmRvbVVuaWZvcm0gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuUmFuZG9tVW5pZm9ybShjb25maWcpO1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXJFeHBvcnRzLnJhbmRvbU5vcm1hbCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbml0aWFsaXplcnNfMS5SYW5kb21Ob3JtYWwoY29uZmlnKTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyRXhwb3J0cy50cnVuY2F0ZWROb3JtYWwgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuVHJ1bmNhdGVkTm9ybWFsKGNvbmZpZyk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMuaWRlbnRpdHkgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuSWRlbnRpdHkoY29uZmlnKTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyRXhwb3J0cy52YXJpYW5jZVNjYWxpbmcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuVmFyaWFuY2VTY2FsaW5nKGNvbmZpZyk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMuZ2xvcm90VW5pZm9ybSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbml0aWFsaXplcnNfMS5HbG9yb3RVbmlmb3JtKGNvbmZpZyk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMuZ2xvcm90Tm9ybWFsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLkdsb3JvdE5vcm1hbChjb25maWcpO1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXJFeHBvcnRzLmhlTm9ybWFsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLkhlTm9ybWFsKGNvbmZpZyk7XG4gICAgfTtcbiAgICBJbml0aWFsaXplckV4cG9ydHMubGVDdW5Ob3JtYWwgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5pdGlhbGl6ZXJzXzEuTGVDdW5Ob3JtYWwoY29uZmlnKTtcbiAgICB9O1xuICAgIEluaXRpYWxpemVyRXhwb3J0cy5vcnRob2dvbmFsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGluaXRpYWxpemVyc18xLk9ydGhvZ29uYWwoY29uZmlnKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdaZXJvcydcbiAgICAgICAgfSlcbiAgICBdLCBJbml0aWFsaXplckV4cG9ydHMsIFwiemVyb3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdJbml0aWFsaXplcnMnLCBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLCB1c2VEb2NzRnJvbTogJ09uZXMnIH0pXG4gICAgXSwgSW5pdGlhbGl6ZXJFeHBvcnRzLCBcIm9uZXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnSW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2luaXRpYWxpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0NvbnN0YW50JyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgSW5pdGlhbGl6ZXJFeHBvcnRzLCBcImNvbnN0YW50XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdSYW5kb21Vbmlmb3JtJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgSW5pdGlhbGl6ZXJFeHBvcnRzLCBcInJhbmRvbVVuaWZvcm1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnSW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2luaXRpYWxpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1JhbmRvbU5vcm1hbCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJyYW5kb21Ob3JtYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnSW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2luaXRpYWxpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ1RydW5jYXRlZE5vcm1hbCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJ0cnVuY2F0ZWROb3JtYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnSW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2luaXRpYWxpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0lkZW50aXR5JyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgSW5pdGlhbGl6ZXJFeHBvcnRzLCBcImlkZW50aXR5XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdWYXJpYW5jZVNjYWxpbmcnLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBJbml0aWFsaXplckV4cG9ydHMsIFwidmFyaWFuY2VTY2FsaW5nXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdHbG9yb3RVbmlmb3JtJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgSW5pdGlhbGl6ZXJFeHBvcnRzLCBcImdsb3JvdFVuaWZvcm1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnSW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2luaXRpYWxpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0dsb3JvdE5vcm1hbCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJnbG9yb3ROb3JtYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnSW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ2luaXRpYWxpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0hlTm9ybWFsJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgSW5pdGlhbGl6ZXJFeHBvcnRzLCBcImhlTm9ybWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdpbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdMZUN1bk5vcm1hbCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJsZUN1bk5vcm1hbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdJbml0aWFsaXplcnMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnT3J0aG9nb25hbCcsXG4gICAgICAgICAgICBjb25maWdQYXJhbUluZGljZXM6IFswXVxuICAgICAgICB9KVxuICAgIF0sIEluaXRpYWxpemVyRXhwb3J0cywgXCJvcnRob2dvbmFsXCIsIG51bGwpO1xuICAgIHJldHVybiBJbml0aWFsaXplckV4cG9ydHM7XG59KCkpO1xuZXhwb3J0cy5Jbml0aWFsaXplckV4cG9ydHMgPSBJbml0aWFsaXplckV4cG9ydHM7XG52YXIgTWV0cmljRXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWV0cmljRXhwb3J0cygpIHtcbiAgICB9XG4gICAgTWV0cmljRXhwb3J0cy5iaW5hcnlBY2N1cmFjeSA9IGZ1bmN0aW9uICh5VHJ1ZSwgeVByZWQpIHtcbiAgICAgICAgcmV0dXJuIG1ldHJpY3NfMS5iaW5hcnlBY2N1cmFjeSh5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5iaW5hcnlDcm9zc2VudHJvcHkgPSBmdW5jdGlvbiAoeVRydWUsIHlQcmVkKSB7XG4gICAgICAgIHJldHVybiBtZXRyaWNzXzEuYmluYXJ5Q3Jvc3NlbnRyb3B5KHlUcnVlLCB5UHJlZCk7XG4gICAgfTtcbiAgICBNZXRyaWNFeHBvcnRzLmNhdGVnb3JpY2FsQWNjdXJhY3kgPSBmdW5jdGlvbiAoeVRydWUsIHlQcmVkKSB7XG4gICAgICAgIHJldHVybiBtZXRyaWNzXzEuY2F0ZWdvcmljYWxBY2N1cmFjeSh5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5jYXRlZ29yaWNhbENyb3NzZW50cm9weSA9IGZ1bmN0aW9uICh5VHJ1ZSwgeVByZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvc3Nlc18xLmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KHlUcnVlLCB5UHJlZCk7XG4gICAgfTtcbiAgICBNZXRyaWNFeHBvcnRzLmNvc2luZVByb3hpbWl0eSA9IGZ1bmN0aW9uICh5VHJ1ZSwgeVByZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvc3Nlc18xLmNvc2luZVByb3hpbWl0eSh5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5wcm90b3R5cGUubWVhbkFic29sdXRlRXJyb3IgPSBmdW5jdGlvbiAoeVRydWUsIHlQcmVkKSB7XG4gICAgICAgIHJldHVybiBsb3NzZXNfMS5tZWFuQWJzb2x1dGVFcnJvcih5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgTWV0cmljRXhwb3J0cy5wcm90b3R5cGUubWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yID0gZnVuY3Rpb24gKHlUcnVlLCB5UHJlZCkge1xuICAgICAgICByZXR1cm4gbG9zc2VzXzEubWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKHlUcnVlLCB5UHJlZCk7XG4gICAgfTtcbiAgICBNZXRyaWNFeHBvcnRzLnByb3RvdHlwZS5NQVBFID0gZnVuY3Rpb24gKHlUcnVlLCB5UHJlZCkge1xuICAgICAgICByZXR1cm4gbG9zc2VzXzEubWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKHlUcnVlLCB5UHJlZCk7XG4gICAgfTtcbiAgICBNZXRyaWNFeHBvcnRzLnByb3RvdHlwZS5tYXBlID0gZnVuY3Rpb24gKHlUcnVlLCB5UHJlZCkge1xuICAgICAgICByZXR1cm4gbG9zc2VzXzEubWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKHlUcnVlLCB5UHJlZCk7XG4gICAgfTtcbiAgICBNZXRyaWNFeHBvcnRzLm1lYW5TcXVhcmVkRXJyb3IgPSBmdW5jdGlvbiAoeVRydWUsIHlQcmVkKSB7XG4gICAgICAgIHJldHVybiBsb3NzZXNfMS5tZWFuU3F1YXJlZEVycm9yKHlUcnVlLCB5UHJlZCk7XG4gICAgfTtcbiAgICBNZXRyaWNFeHBvcnRzLk1TRSA9IGZ1bmN0aW9uICh5VHJ1ZSwgeVByZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvc3Nlc18xLm1lYW5TcXVhcmVkRXJyb3IoeVRydWUsIHlQcmVkKTtcbiAgICB9O1xuICAgIE1ldHJpY0V4cG9ydHMubXNlID0gZnVuY3Rpb24gKHlUcnVlLCB5UHJlZCkge1xuICAgICAgICByZXR1cm4gbG9zc2VzXzEubWVhblNxdWFyZWRFcnJvcih5VHJ1ZSwgeVByZWQpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTWV0cmljcycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdtZXRyaWNzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnbWVhbkFic29sdXRlRXJyb3InXG4gICAgICAgIH0pXG4gICAgXSwgTWV0cmljRXhwb3J0cy5wcm90b3R5cGUsIFwibWVhbkFic29sdXRlRXJyb3JcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnTWV0cmljcycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdtZXRyaWNzJyxcbiAgICAgICAgICAgIHVzZURvY3NGcm9tOiAnbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yJ1xuICAgICAgICB9KVxuICAgIF0sIE1ldHJpY0V4cG9ydHMucHJvdG90eXBlLCBcIm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01ldHJpY3MnLCBuYW1lc3BhY2U6ICdtZXRyaWNzJywgdXNlRG9jc0Zyb206ICdiaW5hcnlBY2N1cmFjeScgfSlcbiAgICBdLCBNZXRyaWNFeHBvcnRzLCBcImJpbmFyeUFjY3VyYWN5XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ01ldHJpY3MnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbWV0cmljcycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ2JpbmFyeUNyb3NzZW50cm9weSdcbiAgICAgICAgfSlcbiAgICBdLCBNZXRyaWNFeHBvcnRzLCBcImJpbmFyeUNyb3NzZW50cm9weVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdNZXRyaWNzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ21ldHJpY3MnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdjYXRlZ29yaWNhbEFjY3VyYWN5J1xuICAgICAgICB9KVxuICAgIF0sIE1ldHJpY0V4cG9ydHMsIFwiY2F0ZWdvcmljYWxBY2N1cmFjeVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdNZXRyaWNzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ21ldHJpY3MnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdjYXRlZ29yaWNhbENyb3NzZW50cm9weSdcbiAgICAgICAgfSlcbiAgICBdLCBNZXRyaWNFeHBvcnRzLCBcImNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ01ldHJpY3MnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiAnbWV0cmljcycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ2Nvc2luZVByb3hpbWl0eSdcbiAgICAgICAgfSlcbiAgICBdLCBNZXRyaWNFeHBvcnRzLCBcImNvc2luZVByb3hpbWl0eVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHtcbiAgICAgICAgICAgIGhlYWRpbmc6ICdNZXRyaWNzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ21ldHJpY3MnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdtZWFuU3F1YXJlZEVycm9yJ1xuICAgICAgICB9KVxuICAgIF0sIE1ldHJpY0V4cG9ydHMsIFwibWVhblNxdWFyZWRFcnJvclwiLCBudWxsKTtcbiAgICByZXR1cm4gTWV0cmljRXhwb3J0cztcbn0oKSk7XG5leHBvcnRzLk1ldHJpY0V4cG9ydHMgPSBNZXRyaWNFeHBvcnRzO1xudmFyIFJlZ3VsYXJpemVyRXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVndWxhcml6ZXJFeHBvcnRzKCkge1xuICAgIH1cbiAgICBSZWd1bGFyaXplckV4cG9ydHMubDFsMiA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWd1bGFyaXplcnNfMS5MMUwyKGNvbmZpZyk7XG4gICAgfTtcbiAgICBSZWd1bGFyaXplckV4cG9ydHMubDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiByZWd1bGFyaXplcnNfMS5sMShjb25maWcpO1xuICAgIH07XG4gICAgUmVndWxhcml6ZXJFeHBvcnRzLmwyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gcmVndWxhcml6ZXJzXzEubDIoY29uZmlnKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2Moe1xuICAgICAgICAgICAgaGVhZGluZzogJ1JlZ3VsYXJpemVycycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6ICdyZWd1bGFyaXplcnMnLFxuICAgICAgICAgICAgdXNlRG9jc0Zyb206ICdMMUwyJyxcbiAgICAgICAgICAgIGNvbmZpZ1BhcmFtSW5kaWNlczogWzBdXG4gICAgICAgIH0pXG4gICAgXSwgUmVndWxhcml6ZXJFeHBvcnRzLCBcImwxbDJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnUmVndWxhcml6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ3JlZ3VsYXJpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0wxTDInLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBSZWd1bGFyaXplckV4cG9ydHMsIFwibDFcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7XG4gICAgICAgICAgICBoZWFkaW5nOiAnUmVndWxhcml6ZXJzJyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogJ3JlZ3VsYXJpemVycycsXG4gICAgICAgICAgICB1c2VEb2NzRnJvbTogJ0wxTDInLFxuICAgICAgICAgICAgY29uZmlnUGFyYW1JbmRpY2VzOiBbMF1cbiAgICAgICAgfSlcbiAgICBdLCBSZWd1bGFyaXplckV4cG9ydHMsIFwibDJcIiwgbnVsbCk7XG4gICAgcmV0dXJuIFJlZ3VsYXJpemVyRXhwb3J0cztcbn0oKSk7XG5leHBvcnRzLlJlZ3VsYXJpemVyRXhwb3J0cyA9IFJlZ3VsYXJpemVyRXhwb3J0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cG9ydHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXhwb3J0c18xID0gcmVxdWlyZShcIi4vZXhwb3J0c1wiKTtcbnZhciBjYWxsYmFja3NfMSA9IHJlcXVpcmUoXCIuL2NhbGxiYWNrc1wiKTtcbmV4cG9ydHMuQ2FsbGJhY2sgPSBjYWxsYmFja3NfMS5DYWxsYmFjaztcbmV4cG9ydHMuQ2FsbGJhY2tMaXN0ID0gY2FsbGJhY2tzXzEuQ2FsbGJhY2tMaXN0O1xuZXhwb3J0cy5DdXN0b21DYWxsYmFjayA9IGNhbGxiYWNrc18xLkN1c3RvbUNhbGxiYWNrO1xudmFyIHRyYWluaW5nXzEgPSByZXF1aXJlKFwiLi9lbmdpbmUvdHJhaW5pbmdcIik7XG5leHBvcnRzLk1vZGVsID0gdHJhaW5pbmdfMS5Nb2RlbDtcbnZhciByZWN1cnJlbnRfMSA9IHJlcXVpcmUoXCIuL2xheWVycy9yZWN1cnJlbnRcIik7XG5leHBvcnRzLlJOTiA9IHJlY3VycmVudF8xLlJOTjtcbnZhciBtb2RlbHNfMSA9IHJlcXVpcmUoXCIuL21vZGVsc1wiKTtcbmV4cG9ydHMuU2VxdWVudGlhbCA9IG1vZGVsc18xLlNlcXVlbnRpYWw7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuZXhwb3J0cy5TeW1ib2xpY1RlbnNvciA9IHR5cGVzXzEuU3ltYm9saWNUZW5zb3I7XG52YXIgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmV4cG9ydHMudmVyc2lvbl9sYXllcnMgPSB2ZXJzaW9uXzEudmVyc2lvbjtcbmV4cG9ydHMubW9kZWwgPSBleHBvcnRzXzEuTW9kZWxFeHBvcnRzLm1vZGVsO1xuZXhwb3J0cy5zZXF1ZW50aWFsID0gZXhwb3J0c18xLk1vZGVsRXhwb3J0cy5zZXF1ZW50aWFsO1xuZXhwb3J0cy5sb2FkTW9kZWwgPSBleHBvcnRzXzEuTW9kZWxFeHBvcnRzLmxvYWRNb2RlbDtcbmV4cG9ydHMuaW5wdXQgPSBleHBvcnRzXzEuTW9kZWxFeHBvcnRzLmlucHV0O1xuZXhwb3J0cy5sYXllcnMgPSBleHBvcnRzXzEuTGF5ZXJFeHBvcnRzO1xuZXhwb3J0cy5jb25zdHJhaW50cyA9IGV4cG9ydHNfMS5Db25zdHJhaW50RXhwb3J0cztcbmV4cG9ydHMuaW5pdGlhbGl6ZXJzID0gZXhwb3J0c18xLkluaXRpYWxpemVyRXhwb3J0cztcbmV4cG9ydHMubWV0cmljcyA9IGV4cG9ydHNfMS5NZXRyaWNFeHBvcnRzO1xuZXhwb3J0cy5yZWd1bGFyaXplcnMgPSBleHBvcnRzXzEuUmVndWxhcml6ZXJFeHBvcnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgbWF0aF91dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvbWF0aF91dGlsc1wiKTtcbmV4cG9ydHMuVkFMSURfRkFOX01PREVfVkFMVUVTID0gWydmYW5JbicsICdmYW5PdXQnLCAnZmFuQXZnJ107XG5mdW5jdGlvbiBjaGVja0Zhbk1vZGUodmFsdWUpIHtcbiAgICBnZW5lcmljX3V0aWxzXzEuY2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShleHBvcnRzLlZBTElEX0ZBTl9NT0RFX1ZBTFVFUywgJ0Zhbk1vZGUnLCB2YWx1ZSk7XG59XG5leHBvcnRzLmNoZWNrRmFuTW9kZSA9IGNoZWNrRmFuTW9kZTtcbmV4cG9ydHMuVkFMSURfRElTVFJJQlVUSU9OX1ZBTFVFUyA9IFsnbm9ybWFsJywgJ3VuaWZvcm0nXTtcbmZ1bmN0aW9uIGNoZWNrRGlzdHJpYnV0aW9uKHZhbHVlKSB7XG4gICAgZ2VuZXJpY191dGlsc18xLmNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoZXhwb3J0cy5WQUxJRF9ESVNUUklCVVRJT05fVkFMVUVTLCAnRGlzdHJpYnV0aW9uJywgdmFsdWUpO1xufVxuZXhwb3J0cy5jaGVja0Rpc3RyaWJ1dGlvbiA9IGNoZWNrRGlzdHJpYnV0aW9uO1xudmFyIEluaXRpYWxpemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5pdGlhbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5pdGlhbGl6ZXIucHJvdG90eXBlLmZyb21Db25maWdVc2VzQ3VzdG9tT2JqZWN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG4gICAgSW5pdGlhbGl6ZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ0luaXRpYWxpemVycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJyB9KVxuICAgIF0sIEluaXRpYWxpemVyKTtcbiAgICByZXR1cm4gSW5pdGlhbGl6ZXI7XG59KHRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKSk7XG5leHBvcnRzLkluaXRpYWxpemVyID0gSW5pdGlhbGl6ZXI7XG52YXIgWmVyb3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaZXJvcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaZXJvcygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBaZXJvcy5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS56ZXJvcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgWmVyb3MuY2xhc3NOYW1lID0gJ1plcm9zJztcbiAgICByZXR1cm4gWmVyb3M7XG59KEluaXRpYWxpemVyKSk7XG5leHBvcnRzLlplcm9zID0gWmVyb3M7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoWmVyb3MpO1xudmFyIE9uZXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPbmVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9uZXMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT25lcy5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS5vbmVzKHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBPbmVzLmNsYXNzTmFtZSA9ICdPbmVzJztcbiAgICByZXR1cm4gT25lcztcbn0oSW5pdGlhbGl6ZXIpKTtcbmV4cG9ydHMuT25lcyA9IE9uZXM7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoT25lcyk7XG52YXIgQ29uc3RhbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25zdGFudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdGFudChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSBjb25maWcudmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uc3RhbnQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBLLnNjYWxhclRpbWVzQXJyYXkodGZqc19jb3JlXzEuc2NhbGFyKF90aGlzLnZhbHVlKSwgdGZqc19jb3JlXzEub25lcyhzaGFwZSwgZHR5cGUpKTsgfSk7XG4gICAgfTtcbiAgICBDb25zdGFudC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb25zdGFudC5jbGFzc05hbWUgPSAnQ29uc3RhbnQnO1xuICAgIHJldHVybiBDb25zdGFudDtcbn0oSW5pdGlhbGl6ZXIpKTtcbmV4cG9ydHMuQ29uc3RhbnQgPSBDb25zdGFudDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihDb25zdGFudCk7XG52YXIgUmFuZG9tVW5pZm9ybSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhbmRvbVVuaWZvcm0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFuZG9tVW5pZm9ybShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9NSU5WQUwgPSAtMC4wNTtcbiAgICAgICAgX3RoaXMuREVGQVVMVF9NQVhWQUwgPSAwLjA1O1xuICAgICAgICBfdGhpcy5taW52YWwgPSBjb25maWcubWludmFsIHx8IF90aGlzLkRFRkFVTFRfTUlOVkFMO1xuICAgICAgICBfdGhpcy5tYXh2YWwgPSBjb25maWcubWF4dmFsIHx8IF90aGlzLkRFRkFVTFRfTUFYVkFMO1xuICAgICAgICBfdGhpcy5zZWVkID0gY29uZmlnLnNlZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmFuZG9tVW5pZm9ybS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS5yYW5kb21Vbmlmb3JtKHNoYXBlLCB0aGlzLm1pbnZhbCwgdGhpcy5tYXh2YWwsIGR0eXBlKTtcbiAgICB9O1xuICAgIFJhbmRvbVVuaWZvcm0ucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgbWludmFsOiB0aGlzLm1pbnZhbCwgbWF4dmFsOiB0aGlzLm1heHZhbCwgc2VlZDogdGhpcy5zZWVkIH07XG4gICAgfTtcbiAgICBSYW5kb21Vbmlmb3JtLmNsYXNzTmFtZSA9ICdSYW5kb21Vbmlmb3JtJztcbiAgICByZXR1cm4gUmFuZG9tVW5pZm9ybTtcbn0oSW5pdGlhbGl6ZXIpKTtcbmV4cG9ydHMuUmFuZG9tVW5pZm9ybSA9IFJhbmRvbVVuaWZvcm07XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoUmFuZG9tVW5pZm9ybSk7XG52YXIgUmFuZG9tTm9ybWFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFuZG9tTm9ybWFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhbmRvbU5vcm1hbChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9NRUFOID0gMC47XG4gICAgICAgIF90aGlzLkRFRkFVTFRfU1REREVWID0gMC4wNTtcbiAgICAgICAgX3RoaXMubWVhbiA9IGNvbmZpZy5tZWFuIHx8IF90aGlzLkRFRkFVTFRfTUVBTjtcbiAgICAgICAgX3RoaXMuc3RkZGV2ID0gY29uZmlnLnN0ZGRldiB8fCBfdGhpcy5ERUZBVUxUX1NURERFVjtcbiAgICAgICAgX3RoaXMuc2VlZCA9IGNvbmZpZy5zZWVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJhbmRvbU5vcm1hbC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoc2hhcGUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcihcInJhbmRvbU5vcm1hbCBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIGJvb2wuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBLLnJhbmRvbU5vcm1hbChzaGFwZSwgdGhpcy5tZWFuLCB0aGlzLnN0ZGRldiwgZHR5cGUsIHRoaXMuc2VlZCk7XG4gICAgfTtcbiAgICBSYW5kb21Ob3JtYWwucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVhbjogdGhpcy5tZWFuLCBzdGRkZXY6IHRoaXMuc3RkZGV2LCBzZWVkOiB0aGlzLnNlZWQgfTtcbiAgICB9O1xuICAgIFJhbmRvbU5vcm1hbC5jbGFzc05hbWUgPSAnUmFuZG9tTm9ybWFsJztcbiAgICByZXR1cm4gUmFuZG9tTm9ybWFsO1xufShJbml0aWFsaXplcikpO1xuZXhwb3J0cy5SYW5kb21Ob3JtYWwgPSBSYW5kb21Ob3JtYWw7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoUmFuZG9tTm9ybWFsKTtcbnZhciBUcnVuY2F0ZWROb3JtYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcnVuY2F0ZWROb3JtYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJ1bmNhdGVkTm9ybWFsKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX01FQU4gPSAwLjtcbiAgICAgICAgX3RoaXMuREVGQVVMVF9TVERERVYgPSAwLjA1O1xuICAgICAgICBfdGhpcy5tZWFuID0gY29uZmlnLm1lYW4gfHwgX3RoaXMuREVGQVVMVF9NRUFOO1xuICAgICAgICBfdGhpcy5zdGRkZXYgPSBjb25maWcuc3RkZGV2IHx8IF90aGlzLkRFRkFVTFRfU1REREVWO1xuICAgICAgICBfdGhpcy5zZWVkID0gY29uZmlnLnNlZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVHJ1bmNhdGVkTm9ybWFsLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKFwidHJ1bmNhdGVkTm9ybWFsIGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgYm9vbC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRydW5jYXRlZE5vcm1hbChzaGFwZSwgdGhpcy5tZWFuLCB0aGlzLnN0ZGRldiwgZHR5cGUsIHRoaXMuc2VlZCk7XG4gICAgfTtcbiAgICBUcnVuY2F0ZWROb3JtYWwucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVhbjogdGhpcy5tZWFuLCBzdGRkZXY6IHRoaXMuc3RkZGV2LCBzZWVkOiB0aGlzLnNlZWQgfTtcbiAgICB9O1xuICAgIFRydW5jYXRlZE5vcm1hbC5jbGFzc05hbWUgPSAnVHJ1bmNhdGVkTm9ybWFsJztcbiAgICByZXR1cm4gVHJ1bmNhdGVkTm9ybWFsO1xufShJbml0aWFsaXplcikpO1xuZXhwb3J0cy5UcnVuY2F0ZWROb3JtYWwgPSBUcnVuY2F0ZWROb3JtYWw7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoVHJ1bmNhdGVkTm9ybWFsKTtcbnZhciBJZGVudGl0eSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElkZW50aXR5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElkZW50aXR5KGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5nYWluID0gY29uZmlnLmdhaW4gIT0gbnVsbCA/IHRmanNfY29yZV8xLnNjYWxhcihjb25maWcuZ2FpbikgOiBLLmdldFNjYWxhcigxLjApO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIElkZW50aXR5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNoYXBlLmxlbmd0aCAhPT0gMiB8fCBzaGFwZVswXSAhPT0gc2hhcGVbMV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignSWRlbnRpdHkgbWF0cml4IGluaXRpYWxpemVyIGNhbiBvbmx5IGJlIHVzZWQgZm9yJyArXG4gICAgICAgICAgICAgICAgICAgICcgMkQgc3F1YXJlIG1hdHJpY2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEsuc2NhbGFyVGltZXNBcnJheShfdGhpcy5nYWluLCB0ZmpzX2NvcmVfMS5leWUoc2hhcGVbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJZGVudGl0eS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBnYWluOiB0aGlzLmdhaW4uZ2V0KCkgfTtcbiAgICB9O1xuICAgIElkZW50aXR5LmNsYXNzTmFtZSA9ICdJZGVudGl0eSc7XG4gICAgcmV0dXJuIElkZW50aXR5O1xufShJbml0aWFsaXplcikpO1xuZXhwb3J0cy5JZGVudGl0eSA9IElkZW50aXR5O1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKElkZW50aXR5KTtcbmZ1bmN0aW9uIGNvbXB1dGVGYW5zKHNoYXBlLCBkYXRhRm9ybWF0KSB7XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRhRm9ybWF0ID0gJ2NoYW5uZWxzTGFzdCc7IH1cbiAgICB2YXIgZmFuSW47XG4gICAgdmFyIGZhbk91dDtcbiAgICBjb21tb25fMS5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBmYW5JbiA9IHNoYXBlWzBdO1xuICAgICAgICBmYW5PdXQgPSBzaGFwZVsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoWzMsIDQsIDVdLmluZGV4T2Yoc2hhcGUubGVuZ3RoKSAhPT0gLTEpIHtcbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgdmFyIHJlY2VwdGl2ZUZpZWxkU2l6ZSA9IG1hdGhfdXRpbHNfMS5hcnJheVByb2Qoc2hhcGUsIDIpO1xuICAgICAgICAgICAgZmFuSW4gPSBzaGFwZVsxXSAqIHJlY2VwdGl2ZUZpZWxkU2l6ZTtcbiAgICAgICAgICAgIGZhbk91dCA9IHNoYXBlWzBdICogcmVjZXB0aXZlRmllbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgICAgICB2YXIgcmVjZXB0aXZlRmllbGRTaXplID0gbWF0aF91dGlsc18xLmFycmF5UHJvZChzaGFwZSwgMCwgc2hhcGUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICBmYW5JbiA9IHNoYXBlW3NoYXBlLmxlbmd0aCAtIDJdICogcmVjZXB0aXZlRmllbGRTaXplO1xuICAgICAgICAgICAgZmFuT3V0ID0gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV0gKiByZWNlcHRpdmVGaWVsZFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBzaGFwZVByb2QgPSBtYXRoX3V0aWxzXzEuYXJyYXlQcm9kKHNoYXBlKTtcbiAgICAgICAgZmFuSW4gPSBNYXRoLnNxcnQoc2hhcGVQcm9kKTtcbiAgICAgICAgZmFuT3V0ID0gTWF0aC5zcXJ0KHNoYXBlUHJvZCk7XG4gICAgfVxuICAgIHJldHVybiBbZmFuSW4sIGZhbk91dF07XG59XG52YXIgVmFyaWFuY2VTY2FsaW5nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFyaWFuY2VTY2FsaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZhcmlhbmNlU2NhbGluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZy5zY2FsZSA8IDAuMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJzY2FsZSBtdXN0IGJlIGEgcG9zaXRpdmUgZmxvYXQuIEdvdDogXCIgKyBjb25maWcuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnNjYWxlID0gY29uZmlnLnNjYWxlID09IG51bGwgPyAxLjAgOiBjb25maWcuc2NhbGU7XG4gICAgICAgIF90aGlzLm1vZGUgPSBjb25maWcubW9kZTtcbiAgICAgICAgY2hlY2tGYW5Nb2RlKF90aGlzLm1vZGUpO1xuICAgICAgICBfdGhpcy5kaXN0cmlidXRpb24gPSBjb25maWcuZGlzdHJpYnV0aW9uO1xuICAgICAgICBjaGVja0Rpc3RyaWJ1dGlvbihfdGhpcy5kaXN0cmlidXRpb24pO1xuICAgICAgICBfdGhpcy5zZWVkID0gY29uZmlnLnNlZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmFyaWFuY2VTY2FsaW5nLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIGZhbnMgPSBjb21wdXRlRmFucyhzaGFwZSk7XG4gICAgICAgIHZhciBmYW5JbiA9IGZhbnNbMF07XG4gICAgICAgIHZhciBmYW5PdXQgPSBmYW5zWzFdO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZmFuSW4nKSB7XG4gICAgICAgICAgICBzY2FsZSAvPSBNYXRoLm1heCgxLCBmYW5Jbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSAnZmFuT3V0Jykge1xuICAgICAgICAgICAgc2NhbGUgLz0gTWF0aC5tYXgoMSwgZmFuT3V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYWxlIC89IE1hdGgubWF4KDEsIChmYW5JbiArIGZhbk91dCkgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICB2YXIgc3RkZGV2ID0gTWF0aC5zcXJ0KHNjYWxlKTtcbiAgICAgICAgICAgIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IodGhpcy5nZXRDbGFzc05hbWUoKSArIFwiIGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgYm9vbC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudHJ1bmNhdGVkTm9ybWFsKHNoYXBlLCAwLCBzdGRkZXYsIGR0eXBlLCB0aGlzLnNlZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxpbWl0ID0gTWF0aC5zcXJ0KDMgKiBzY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEucmFuZG9tVW5pZm9ybShzaGFwZSwgLWxpbWl0LCBsaW1pdCwgZHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWYXJpYW5jZVNjYWxpbmcucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgZGlzdHJpYnV0aW9uOiB0aGlzLmRpc3RyaWJ1dGlvbixcbiAgICAgICAgICAgIHNlZWQ6IHRoaXMuc2VlZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZSA9ICdWYXJpYW5jZVNjYWxpbmcnO1xuICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmc7XG59KEluaXRpYWxpemVyKSk7XG5leHBvcnRzLlZhcmlhbmNlU2NhbGluZyA9IFZhcmlhbmNlU2NhbGluZztcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihWYXJpYW5jZVNjYWxpbmcpO1xudmFyIEdsb3JvdFVuaWZvcm0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHbG9yb3RVbmlmb3JtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdsb3JvdFVuaWZvcm0oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBzY2FsZTogMS4wLFxuICAgICAgICAgICAgbW9kZTogJ2ZhbkF2ZycsXG4gICAgICAgICAgICBkaXN0cmlidXRpb246ICd1bmlmb3JtJyxcbiAgICAgICAgICAgIHNlZWQ6IGNvbmZpZyA9PSBudWxsID8gbnVsbCA6IGNvbmZpZy5zZWVkXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgfVxuICAgIEdsb3JvdFVuaWZvcm0ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gR2xvcm90VW5pZm9ybTtcbn0oVmFyaWFuY2VTY2FsaW5nKSk7XG5leHBvcnRzLkdsb3JvdFVuaWZvcm0gPSBHbG9yb3RVbmlmb3JtO1xudmFyIEdsb3JvdE5vcm1hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdsb3JvdE5vcm1hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHbG9yb3ROb3JtYWwoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBzY2FsZTogMS4wLFxuICAgICAgICAgICAgbW9kZTogJ2ZhbkF2ZycsXG4gICAgICAgICAgICBkaXN0cmlidXRpb246ICdub3JtYWwnLFxuICAgICAgICAgICAgc2VlZDogY29uZmlnID09IG51bGwgPyBudWxsIDogY29uZmlnLnNlZWRcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICB9XG4gICAgR2xvcm90Tm9ybWFsLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb3JvdE5vcm1hbDtcbn0oVmFyaWFuY2VTY2FsaW5nKSk7XG5leHBvcnRzLkdsb3JvdE5vcm1hbCA9IEdsb3JvdE5vcm1hbDtcbnZhciBIZU5vcm1hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlTm9ybWFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlTm9ybWFsKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgc2NhbGU6IDIuMCxcbiAgICAgICAgICAgIG1vZGU6ICdmYW5JbicsXG4gICAgICAgICAgICBkaXN0cmlidXRpb246ICdub3JtYWwnLFxuICAgICAgICAgICAgc2VlZDogY29uZmlnID09IG51bGwgPyBudWxsIDogY29uZmlnLnNlZWRcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICB9XG4gICAgSGVOb3JtYWwucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gSGVOb3JtYWw7XG59KFZhcmlhbmNlU2NhbGluZykpO1xuZXhwb3J0cy5IZU5vcm1hbCA9IEhlTm9ybWFsO1xudmFyIExlQ3VuTm9ybWFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGVDdW5Ob3JtYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVDdW5Ob3JtYWwoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBzY2FsZTogMS4wLFxuICAgICAgICAgICAgbW9kZTogJ2ZhbkluJyxcbiAgICAgICAgICAgIGRpc3RyaWJ1dGlvbjogJ25vcm1hbCcsXG4gICAgICAgICAgICBzZWVkOiBjb25maWcgPT0gbnVsbCA/IG51bGwgOiBjb25maWcuc2VlZFxuICAgICAgICB9KSB8fCB0aGlzO1xuICAgIH1cbiAgICBMZUN1bk5vcm1hbC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBMZUN1bk5vcm1hbDtcbn0oVmFyaWFuY2VTY2FsaW5nKSk7XG5leHBvcnRzLkxlQ3VuTm9ybWFsID0gTGVDdW5Ob3JtYWw7XG52YXIgT3J0aG9nb25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9ydGhvZ29uYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3J0aG9nb25hbChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9HQUlOID0gMTtcbiAgICAgICAgX3RoaXMuZ2FpbiA9IGNvbmZpZy5nYWluID09IG51bGwgPyBfdGhpcy5ERUZBVUxUX0dBSU4gOiBjb25maWcuZ2FpbjtcbiAgICAgICAgX3RoaXMuc2VlZCA9IGNvbmZpZy5zZWVkO1xuICAgICAgICBpZiAoX3RoaXMuc2VlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignUmFuZG9tIHNlZWQgaXMgbm90IGltcGxlbWVudGVkIGZvciBPcnRob2dvbmFsIEluaXRpYWxpemVyIHlldC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9ydGhvZ29uYWwucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ1RoZSBPcnRob2dvbmFsIEluaXRpYWxpemVyIGRvZXMgbm90IHN1cHBvcnQgbm9uLTJEIHNoYXBlcyB5ZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hhcGVbMF0gKiBzaGFwZVsxXSA+IDIwMDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJPcnRob2dvbmFsIGluaXRpYWxpemVyIGlzIGJlaW5nIGNhbGxlZCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJ0aGFuIDIwMDAgKFwiICsgc2hhcGVbMF0gKiBzaGFwZVsxXSArIFwiKSBlbGVtZW50czogXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJTbG93bmVzcyBtYXkgcmVzdWx0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkU2hhcGUgPSBzaGFwZVswXSA+IHNoYXBlWzFdID8gW3NoYXBlWzFdLCBzaGFwZVswXV0gOiBzaGFwZTtcbiAgICAgICAgICAgIHZhciBhID0gSy5yYW5kb21Ob3JtYWwobm9ybWFsaXplZFNoYXBlLCAwLCAxLCAnZmxvYXQzMicpO1xuICAgICAgICAgICAgdmFyIHEgPSB0ZmpzX2NvcmVfMS5saW5hbGcuZ3JhbVNjaG1pZHQoYSk7XG4gICAgICAgICAgICBpZiAoc2hhcGVbMF0gPiBzaGFwZVsxXSkge1xuICAgICAgICAgICAgICAgIHEgPSBxLnRyYW5zcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEsuc2NhbGFyVGltZXNBcnJheShLLmdldFNjYWxhcihfdGhpcy5nYWluKSwgcSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3J0aG9nb25hbC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2FpbjogdGhpcy5nYWluLFxuICAgICAgICAgICAgc2VlZDogdGhpcy5zZWVkLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgT3J0aG9nb25hbC5jbGFzc05hbWUgPSAnT3J0aG9nb25hbCc7XG4gICAgcmV0dXJuIE9ydGhvZ29uYWw7XG59KEluaXRpYWxpemVyKSk7XG5leHBvcnRzLk9ydGhvZ29uYWwgPSBPcnRob2dvbmFsO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKE9ydGhvZ29uYWwpO1xuZXhwb3J0cy5JTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVAgPSB7XG4gICAgJ2NvbnN0YW50JzogJ0NvbnN0YW50JyxcbiAgICAnZ2xvcm90Tm9ybWFsJzogJ0dsb3JvdE5vcm1hbCcsXG4gICAgJ2dsb3JvdFVuaWZvcm0nOiAnR2xvcm90VW5pZm9ybScsXG4gICAgJ2hlTm9ybWFsJzogJ0hlTm9ybWFsJyxcbiAgICAnaWRlbnRpdHknOiAnSWRlbnRpdHknLFxuICAgICdsZUN1bk5vcm1hbCc6ICdMZUN1bk5vcm1hbCcsXG4gICAgJ29uZXMnOiAnT25lcycsXG4gICAgJ29ydGhvZ29uYWwnOiAnT3J0aG9nb25hbCcsXG4gICAgJ3JhbmRvbU5vcm1hbCc6ICdSYW5kb21Ob3JtYWwnLFxuICAgICdyYW5kb21Vbmlmb3JtJzogJ1JhbmRvbVVuaWZvcm0nLFxuICAgICd0cnVuY2F0ZWROb3JtYWwnOiAnVHJ1bmNhdGVkTm9ybWFsJyxcbiAgICAndmFyaWFuY2VTY2FsaW5nJzogJ1ZhcmlhbmNlU2NhbGluZycsXG4gICAgJ3plcm9zJzogJ1plcm9zJ1xufTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplSW5pdGlhbGl6ZXIoY29uZmlnLCBjdXN0b21PYmplY3RzKSB7XG4gICAgaWYgKGN1c3RvbU9iamVjdHMgPT09IHZvaWQgMCkgeyBjdXN0b21PYmplY3RzID0ge307IH1cbiAgICByZXR1cm4gZ2VuZXJpY191dGlsc18xLmRlc2VyaWFsaXplS2VyYXNPYmplY3QoY29uZmlnLCB0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLCBjdXN0b21PYmplY3RzLCAnaW5pdGlhbGl6ZXInKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUluaXRpYWxpemVyKGluaXRpYWxpemVyKSB7XG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHNfMS5zZXJpYWxpemVLZXJhc09iamVjdChpbml0aWFsaXplcik7XG59XG5leHBvcnRzLnNlcmlhbGl6ZUluaXRpYWxpemVyID0gc2VyaWFsaXplSW5pdGlhbGl6ZXI7XG5mdW5jdGlvbiBnZXRJbml0aWFsaXplcihpZGVudGlmaWVyKSB7XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gaWRlbnRpZmllciBpbiBleHBvcnRzLklOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUCA/XG4gICAgICAgICAgICBleHBvcnRzLklOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUFtpZGVudGlmaWVyXSA6XG4gICAgICAgICAgICBpZGVudGlmaWVyO1xuICAgICAgICBpZiAoY2xhc3NOYW1lID09PSAnR2xvcm90VW5pZm9ybScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2xvcm90VW5pZm9ybSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gJ0dsb3JvdE5vcm1hbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2xvcm90Tm9ybWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSAnSGVOb3JtYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlTm9ybWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSAnTGVDdW5Ob3JtYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExlQ3VuTm9ybWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0geyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgY29uZmlnOiB7fSB9O1xuICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplSW5pdGlhbGl6ZXIoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpZGVudGlmaWVyIGluc3RhbmNlb2YgSW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVJbml0aWFsaXplcihpZGVudGlmaWVyKTtcbiAgICB9XG59XG5leHBvcnRzLmdldEluaXRpYWxpemVyID0gZ2V0SW5pdGlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0aWFsaXplcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgYWN0aXZhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9hY3RpdmF0aW9uc1wiKTtcbnZhciB0ZmpzX2JhY2tlbmRfMSA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciB0ZmpzX2JhY2tlbmRfMiA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4uL2VuZ2luZS90b3BvbG9neVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIExlYWt5UmVMVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlYWt5UmVMVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMZWFreVJlTFUoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZyA9PSBudWxsID8ge30gOiBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQUxQSEEgPSAwLjM7XG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYWxwaGEgPSBjb25maWcuYWxwaGEgPT0gbnVsbCA/IF90aGlzLkRFRkFVTFRfQUxQSEEgOiBjb25maWcuYWxwaGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGVha3lSZUxVLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciB4ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS5sZWFreVJlbHUoeCwgdGhpcy5hbHBoYSk7XG4gICAgfTtcbiAgICBMZWFreVJlTFUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dFNoYXBlO1xuICAgIH07XG4gICAgTGVha3lSZUxVLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IGFscGhhOiB0aGlzLmFscGhhIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgTGVha3lSZUxVLmNsYXNzTmFtZSA9ICdMZWFreVJlTFUnO1xuICAgIHJldHVybiBMZWFreVJlTFU7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuTGVha3lSZUxVID0gTGVha3lSZUxVO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKExlYWt5UmVMVSk7XG52YXIgRUxVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRUxVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVMVShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnID09IG51bGwgPyB7fSA6IGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9BTFBIQSA9IDEuMDtcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmFscGhhICE9IG51bGwgJiYgY29uZmlnLmFscGhhICE9PSBfdGhpcy5ERUZBVUxUX0FMUEhBKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vbi1kZWZhdWx0IGFscGhhIHZhbHVlIChcIiArIGNvbmZpZy5hbHBoYSArIFwiKSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBcIiArXG4gICAgICAgICAgICAgICAgXCJFTFUgbGF5ZXIgeWV0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5hbHBoYSA9IGNvbmZpZy5hbHBoYSA9PSBudWxsID8gX3RoaXMuREVGQVVMVF9BTFBIQSA6IGNvbmZpZy5hbHBoYTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFTFUucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIHggPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLmVsdSh4KTtcbiAgICB9O1xuICAgIEVMVS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0U2hhcGU7XG4gICAgfTtcbiAgICBFTFUucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgYWxwaGE6IHRoaXMuYWxwaGEgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBFTFUuY2xhc3NOYW1lID0gJ0VMVSc7XG4gICAgcmV0dXJuIEVMVTtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5FTFUgPSBFTFU7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoRUxVKTtcbnZhciBUaHJlc2hvbGRlZFJlTFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJlc2hvbGRlZFJlTFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGhyZXNob2xkZWRSZUxVKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcgPT0gbnVsbCA/IHt9IDogY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX1RIRVRBID0gMS4wO1xuICAgICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnRoZXRhID0gY29uZmlnLnRoZXRhID09IG51bGwgPyBfdGhpcy5ERUZBVUxUX1RIRVRBIDogY29uZmlnLnRoZXRhO1xuICAgICAgICBfdGhpcy50aGV0YVRlbnNvciA9IHRmanNfYmFja2VuZF8yLmdldFNjYWxhcihfdGhpcy50aGV0YSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGhyZXNob2xkZWRSZUxVLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciB4ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgIHJldHVybiB4Lm11bCh0ZmpzX2JhY2tlbmRfMS5jYXN0KHguZ3JlYXRlcih0aGlzLnRoZXRhVGVuc29yKSwgJ2Zsb2F0MzInKSk7XG4gICAgfTtcbiAgICBUaHJlc2hvbGRlZFJlTFUucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dFNoYXBlO1xuICAgIH07XG4gICAgVGhyZXNob2xkZWRSZUxVLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7IHRoZXRhOiB0aGlzLnRoZXRhIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgVGhyZXNob2xkZWRSZUxVLmNsYXNzTmFtZSA9ICdUaHJlc2hvbGRlZFJlTFUnO1xuICAgIHJldHVybiBUaHJlc2hvbGRlZFJlTFU7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuVGhyZXNob2xkZWRSZUxVID0gVGhyZXNob2xkZWRSZUxVO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFRocmVzaG9sZGVkUmVMVSk7XG52YXIgU29mdG1heCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnID09IG51bGwgPyB7fSA6IGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9BWElTID0gMS4wO1xuICAgICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnNvZnRtYXggPSBuZXcgYWN0aXZhdGlvbnNfMS5Tb2Z0bWF4KCkuYXBwbHk7XG4gICAgICAgIF90aGlzLmF4aXMgPSBjb25maWcuYXhpcyA9PSBudWxsID8gX3RoaXMuREVGQVVMVF9BWElTIDogY29uZmlnLmF4aXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgeCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5zb2Z0bWF4KHgsIHRoaXMuYXhpcyk7XG4gICAgfTtcbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXRTaGFwZTtcbiAgICB9O1xuICAgIFNvZnRtYXgucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgYXhpczogdGhpcy5heGlzIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgU29mdG1heC5jbGFzc05hbWUgPSAnU29mdG1heCc7XG4gICAgcmV0dXJuIFNvZnRtYXg7XG59KHRvcG9sb2d5XzEuTGF5ZXIpKTtcbmV4cG9ydHMuU29mdG1heCA9IFNvZnRtYXg7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoU29mdG1heCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZHZhbmNlZF9hY3RpdmF0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIGFjdGl2YXRpb25zXzEgPSByZXF1aXJlKFwiLi4vYWN0aXZhdGlvbnNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vYmFja2VuZC9jb21tb25cIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBjb21tb25fMiA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgY29uc3RyYWludHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHJhaW50c1wiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4uL2VuZ2luZS90b3BvbG9neVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi4vaW5pdGlhbGl6ZXJzXCIpO1xudmFyIHJlZ3VsYXJpemVyc18xID0gcmVxdWlyZShcIi4uL3JlZ3VsYXJpemVyc1wiKTtcbnZhciBjb252X3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29udl91dGlsc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG5mdW5jdGlvbiBwcmVwcm9jZXNzQ29udjJESW5wdXQoeCwgZGF0YUZvcm1hdCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGZjLnRyYW5zcG9zZSh4LCBbMCwgMiwgMywgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMucHJlcHJvY2Vzc0NvbnYyRElucHV0ID0gcHJlcHJvY2Vzc0NvbnYyRElucHV0O1xuZnVuY3Rpb24gY29udjFkV2l0aEJpYXMoeCwga2VybmVsLCBiaWFzLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCBkaWxhdGlvblJhdGUpIHtcbiAgICBpZiAoc3RyaWRlcyA9PT0gdm9pZCAwKSB7IHN0cmlkZXMgPSAxOyB9XG4gICAgaWYgKHBhZGRpbmcgPT09IHZvaWQgMCkgeyBwYWRkaW5nID0gJ3ZhbGlkJzsgfVxuICAgIGlmIChkaWxhdGlvblJhdGUgPT09IHZvaWQgMCkgeyBkaWxhdGlvblJhdGUgPSAxOyB9XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhRm9ybWF0ID0gY29tbW9uXzEuaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uXzIuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgICAgICBpZiAoeC5zaGFwZS5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIGlucHV0IG9mIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAzLCBidXQgaXMgXCIgK1xuICAgICAgICAgICAgICAgICh4LnNoYXBlLmxlbmd0aCArIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VybmVsLnNoYXBlLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUga2VybmVsIGZvciBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMywgYnV0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAoa2VybmVsLnNoYXBlLmxlbmd0aCArIFwiIGluc3RlYWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaWFzICE9IG51bGwgJiYgYmlhcy5zaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVGhlIGJpYXMgZm9yIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAxLCBidXQgaXMgXCIgK1xuICAgICAgICAgICAgICAgIChrZXJuZWwuc2hhcGUubGVuZ3RoICsgXCIgaW5zdGVhZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgeCA9IHRmYy50cmFuc3Bvc2UoeCwgWzAsIDIsIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGluZyA9PT0gJ2NhdXNhbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252MWRXaXRoQmlhcyBpcyBub3QgJyArXG4gICAgICAgICAgICAgICAgJ2ltcGxlbWVudGVkIHlldC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeSA9IHRmYy5jb252MWQoeCwga2VybmVsLCBzdHJpZGVzLCBwYWRkaW5nID09PSAnc2FtZScgPyAnc2FtZScgOiAndmFsaWQnLCAnTldDJywgZGlsYXRpb25SYXRlKTtcbiAgICAgICAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgeSA9IEsuYmlhc0FkZCh5LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29udjFkV2l0aEJpYXMgPSBjb252MWRXaXRoQmlhcztcbmZ1bmN0aW9uIGNvbnYxZCh4LCBrZXJuZWwsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsIGRpbGF0aW9uUmF0ZSkge1xuICAgIGlmIChzdHJpZGVzID09PSB2b2lkIDApIHsgc3RyaWRlcyA9IDE7IH1cbiAgICBpZiAocGFkZGluZyA9PT0gdm9pZCAwKSB7IHBhZGRpbmcgPSAndmFsaWQnOyB9XG4gICAgaWYgKGRpbGF0aW9uUmF0ZSA9PT0gdm9pZCAwKSB7IGRpbGF0aW9uUmF0ZSA9IDE7IH1cbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIGNvbnYxZFdpdGhCaWFzKHgsIGtlcm5lbCwgbnVsbCwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgZGlsYXRpb25SYXRlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29udjFkID0gY29udjFkO1xuZnVuY3Rpb24gY29udjJkKHgsIGtlcm5lbCwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgZGlsYXRpb25SYXRlKSB7XG4gICAgaWYgKHN0cmlkZXMgPT09IHZvaWQgMCkgeyBzdHJpZGVzID0gWzEsIDFdOyB9XG4gICAgaWYgKHBhZGRpbmcgPT09IHZvaWQgMCkgeyBwYWRkaW5nID0gJ3ZhbGlkJzsgfVxuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgICAgICByZXR1cm4gY29udjJkV2l0aEJpYXMoeCwga2VybmVsLCBudWxsLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCBkaWxhdGlvblJhdGUpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jb252MmQgPSBjb252MmQ7XG5mdW5jdGlvbiBjb252MmRXaXRoQmlhcyh4LCBrZXJuZWwsIGJpYXMsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsIGRpbGF0aW9uUmF0ZSkge1xuICAgIGlmIChzdHJpZGVzID09PSB2b2lkIDApIHsgc3RyaWRlcyA9IFsxLCAxXTsgfVxuICAgIGlmIChwYWRkaW5nID09PSB2b2lkIDApIHsgcGFkZGluZyA9ICd2YWxpZCc7IH1cbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFGb3JtYXQgPSBjb21tb25fMS5pbWFnZURhdGFGb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgICAgIGlmICh4LnJhbmsgIT09IDMgJiYgeC5yYW5rICE9PSA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcImNvbnYyZFdpdGhCaWFzIGV4cGVjdHMgaW5wdXQgdG8gYmUgb2YgcmFuayAzIG9yIDQsIGJ1dCByZWNlaXZlZCBcIiArXG4gICAgICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlcm5lbC5yYW5rICE9PSAzICYmIGtlcm5lbC5yYW5rICE9PSA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcImNvbnYyZFdpdGhCaWFzIGV4cGVjdHMga2VybmVsIHRvIGJlIG9mIHJhbmsgMyBvciA0LCBidXQgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gcHJlcHJvY2Vzc0NvbnYyRElucHV0KHgsIGRhdGFGb3JtYXQpO1xuICAgICAgICBpZiAocGFkZGluZyA9PT0gJ2NhdXNhbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252MWRXaXRoQmlhcyBpcyBub3QgJyArXG4gICAgICAgICAgICAgICAgJ2ltcGxlbWVudGVkIHlldC4nKTtcbiAgICAgICAgfVxuICAgICAgICB5ID0gdGZjLmNvbnYyZCh5LCBrZXJuZWwsIHN0cmlkZXMsIHBhZGRpbmcgPT09ICdzYW1lJyA/ICdzYW1lJyA6ICd2YWxpZCcsICdOSFdDJywgZGlsYXRpb25SYXRlKTtcbiAgICAgICAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgeSA9IEsuYmlhc0FkZCh5LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICB5ID0gdGZjLnRyYW5zcG9zZSh5LCBbMCwgMywgMSwgMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH0pO1xufVxuZXhwb3J0cy5jb252MmRXaXRoQmlhcyA9IGNvbnYyZFdpdGhCaWFzO1xudmFyIENvbnYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb252LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnYocmFuaywgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMua2VybmVsID0gbnVsbDtcbiAgICAgICAgX3RoaXMuYmlhcyA9IG51bGw7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSID0gJ2dsb3JvdE5vcm1hbCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiA9ICd6ZXJvcyc7XG4gICAgICAgIF90aGlzLnJhbmsgPSByYW5rO1xuICAgICAgICBpZiAoX3RoaXMucmFuayAhPT0gMSAmJiBfdGhpcy5yYW5rICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcihcIkNvbnZvbHV0aW9uIGxheWVyIGZvciByYW5rIG90aGVyIHRoYW4gMSBvciAyIChcIiArIF90aGlzLnJhbmsgKyBcIikgaXMgXCIgK1xuICAgICAgICAgICAgICAgIFwibm90IGltcGxlbWVudGVkIHlldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZmlsdGVycyA9IGNvbmZpZy5maWx0ZXJzO1xuICAgICAgICBfdGhpcy5rZXJuZWxTaXplID0gY29udl91dGlsc18xLm5vcm1hbGl6ZUFycmF5KGNvbmZpZy5rZXJuZWxTaXplLCByYW5rLCAna2VybmVsU2l6ZScpO1xuICAgICAgICBfdGhpcy5zdHJpZGVzID0gY29udl91dGlsc18xLm5vcm1hbGl6ZUFycmF5KGNvbmZpZy5zdHJpZGVzID09IG51bGwgPyAxIDogY29uZmlnLnN0cmlkZXMsIHJhbmssICdzdHJpZGVzJyk7XG4gICAgICAgIF90aGlzLnBhZGRpbmcgPSBjb25maWcucGFkZGluZyA9PSBudWxsID8gJ3ZhbGlkJyA6IGNvbmZpZy5wYWRkaW5nO1xuICAgICAgICBjb21tb25fMi5jaGVja1BhZGRpbmdNb2RlKF90aGlzLnBhZGRpbmcpO1xuICAgICAgICBfdGhpcy5kYXRhRm9ybWF0ID1cbiAgICAgICAgICAgIGNvbmZpZy5kYXRhRm9ybWF0ID09IG51bGwgPyAnY2hhbm5lbHNMYXN0JyA6IGNvbmZpZy5kYXRhRm9ybWF0O1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoX3RoaXMuZGF0YUZvcm1hdCk7XG4gICAgICAgIF90aGlzLmRpbGF0aW9uUmF0ZSA9IGNvbmZpZy5kaWxhdGlvblJhdGUgPT0gbnVsbCA/IDEgOiBjb25maWcuZGlsYXRpb25SYXRlO1xuICAgICAgICBpZiAoX3RoaXMucmFuayA9PT0gMSAmJlxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoX3RoaXMuZGlsYXRpb25SYXRlKSAmJlxuICAgICAgICAgICAgICAgIF90aGlzLmRpbGF0aW9uUmF0ZS5sZW5ndGggIT09IDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcImRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGEgc2luZ2xlIG51bWJlciBcIiArXG4gICAgICAgICAgICAgICAgXCJmb3IgMUQgY29udm9sdXRpb24sIGJ1dCByZWNlaXZlZCBcIiArXG4gICAgICAgICAgICAgICAgKFwiXCIgKyBKU09OLnN0cmluZ2lmeShfdGhpcy5kaWxhdGlvblJhdGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMuZGlsYXRpb25SYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpbGF0aW9uUmF0ZSA9IFtfdGhpcy5kaWxhdGlvblJhdGUsIF90aGlzLmRpbGF0aW9uUmF0ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5kaWxhdGlvblJhdGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJkaWxhdGlvblJhdGUgbXVzdCBiZSBhIG51bWJlciBvciBhcnJheSBvZiB0d28gbnVtYmVycyBmb3IgMkQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJjb252b2x1dGlvbiwgYnV0IHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoX3RoaXMuZGlsYXRpb25SYXRlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb24gPSBhY3RpdmF0aW9uc18xLmdldEFjdGl2YXRpb24oY29uZmlnLmFjdGl2YXRpb24pO1xuICAgICAgICBfdGhpcy51c2VCaWFzID0gY29uZmlnLnVzZUJpYXMgPT0gbnVsbCA/IHRydWUgOiBjb25maWcudXNlQmlhcztcbiAgICAgICAgX3RoaXMua2VybmVsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcua2VybmVsSW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy5iaWFzSW5pdGlhbGl6ZXIgPVxuICAgICAgICAgICAgaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmJpYXNJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy5rZXJuZWxDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMuYmlhc0NvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLmJpYXNDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMua2VybmVsUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcua2VybmVsUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5iaWFzUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcuYmlhc1JlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMuYWN0aXZpdHlSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5hY3Rpdml0eVJlZ3VsYXJpemVyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb252LnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIGNoYW5uZWxBeGlzID0gdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyAxIDogaW5wdXRTaGFwZS5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5wdXRTaGFwZVtjaGFubmVsQXhpc10gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0IHNob3VsZCBiZSBkZWZpbmVkLiBcIiArXG4gICAgICAgICAgICAgICAgKFwiRm91bmQgXCIgKyBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dERpbSA9IGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdO1xuICAgICAgICB2YXIga2VybmVsU2hhcGUgPSB0aGlzLmtlcm5lbFNpemUuY29uY2F0KFtpbnB1dERpbSwgdGhpcy5maWx0ZXJzXSk7XG4gICAgICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ2tlcm5lbCcsIGtlcm5lbFNoYXBlLCBudWxsLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLCB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLmJpYXMgPSB0aGlzLmFkZFdlaWdodCgnYmlhcycsIFt0aGlzLmZpbHRlcnNdLCBudWxsLCB0aGlzLmJpYXNJbml0aWFsaXplciwgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRTcGVjID0gW3sgbmRpbTogdGhpcy5yYW5rICsgMiwgYXhlczogKF9hID0ge30sIF9hW2NoYW5uZWxBeGlzXSA9IGlucHV0RGltLCBfYSkgfV07XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBDb252LnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIG91dHB1dHM7XG4gICAgICAgICAgICB2YXIgYmlhc1ZhbHVlID0gX3RoaXMuYmlhcyA9PSBudWxsID8gbnVsbCA6IF90aGlzLmJpYXMucmVhZCgpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29udjFkV2l0aEJpYXMoaW5wdXRzLCBfdGhpcy5rZXJuZWwucmVhZCgpLCBiaWFzVmFsdWUsIF90aGlzLnN0cmlkZXNbMF0sIF90aGlzLnBhZGRpbmcsIF90aGlzLmRhdGFGb3JtYXQsIF90aGlzLmRpbGF0aW9uUmF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yYW5rID09PSAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IGNvbnYyZFdpdGhCaWFzKGlucHV0cywgX3RoaXMua2VybmVsLnJlYWQoKSwgYmlhc1ZhbHVlLCBfdGhpcy5zdHJpZGVzLCBfdGhpcy5wYWRkaW5nLCBfdGhpcy5kYXRhRm9ybWF0LCBfdGhpcy5kaWxhdGlvblJhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCczRCBjb252b2x1dGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmFjdGl2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBfdGhpcy5hY3RpdmF0aW9uLmFwcGx5KG91dHB1dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udi5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgbmV3U3BhY2UgPSBbXTtcbiAgICAgICAgdmFyIHNwYWNlID0gKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpID9cbiAgICAgICAgICAgIGlucHV0U2hhcGUuc2xpY2UoMSwgaW5wdXRTaGFwZS5sZW5ndGggLSAxKSA6XG4gICAgICAgICAgICBpbnB1dFNoYXBlLnNsaWNlKDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGltID0gY29udl91dGlsc18xLmNvbnZPdXRwdXRMZW5ndGgoc3BhY2VbaV0sIHRoaXMua2VybmVsU2l6ZVtpXSwgdGhpcy5wYWRkaW5nLCB0aGlzLnN0cmlkZXNbaV0sIHR5cGVvZiB0aGlzLmRpbGF0aW9uUmF0ZSA9PT0gJ251bWJlcicgPyB0aGlzLmRpbGF0aW9uUmF0ZSA6XG4gICAgICAgICAgICAgICAgdGhpcy5kaWxhdGlvblJhdGVbaV0pO1xuICAgICAgICAgICAgbmV3U3BhY2UucHVzaChuZXdEaW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IFtpbnB1dFNoYXBlWzBdXTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUuY29uY2F0KG5ld1NwYWNlKTtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2godGhpcy5maWx0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2godGhpcy5maWx0ZXJzKTtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUuY29uY2F0KG5ld1NwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgfTtcbiAgICBDb252LnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICByYW5rOiB0aGlzLnJhbmssXG4gICAgICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgICAgICBrZXJuZWxTaXplOiB0aGlzLmtlcm5lbFNpemUsXG4gICAgICAgICAgICBzdHJpZGVzOiB0aGlzLnN0cmlkZXMsXG4gICAgICAgICAgICBwYWRkaW5nOiB0aGlzLnBhZGRpbmcsXG4gICAgICAgICAgICBkYXRhRm9ybWF0OiB0aGlzLmRhdGFGb3JtYXQsXG4gICAgICAgICAgICBkaWxhdGlvblJhdGU6IHRoaXMuZGlsYXRpb25SYXRlLFxuICAgICAgICAgICAgYWN0aXZhdGlvbjogYWN0aXZhdGlvbnNfMS5zZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksXG4gICAgICAgICAgICB1c2VCaWFzOiB0aGlzLnVzZUJpYXMsXG4gICAgICAgICAgICBrZXJuZWxJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplciksXG4gICAgICAgICAgICBiaWFzSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGJpYXNSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYWN0aXZpdHlSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgYmlhc0NvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIHJldHVybiBDb252O1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLkNvbnYgPSBDb252O1xudmFyIENvbnYyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnYyRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252MkQoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAyLCBjb25maWcpIHx8IHRoaXM7XG4gICAgfVxuICAgIENvbnYyRC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZ1sncmFuayddO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgQ29udjJELmNsYXNzTmFtZSA9ICdDb252MkQnO1xuICAgIHJldHVybiBDb252MkQ7XG59KENvbnYpKTtcbmV4cG9ydHMuQ29udjJEID0gQ29udjJEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKENvbnYyRCk7XG52YXIgQ29udjJEVHJhbnNwb3NlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udjJEVHJhbnNwb3NlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnYyRFRyYW5zcG9zZShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbbmV3IHRvcG9sb2d5XzEuSW5wdXRTcGVjKHsgbmRpbTogNCB9KV07XG4gICAgICAgIGlmIChfdGhpcy5wYWRkaW5nICE9PSAnc2FtZScgJiYgX3RoaXMucGFkZGluZyAhPT0gJ3ZhbGlkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJDb252MkRUcmFuc3Bvc2UgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlcyAnc2FtZScgXCIgK1xuICAgICAgICAgICAgICAgIChcImFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgcGFkZGluZyBtb2RlIFwiICsgX3RoaXMucGFkZGluZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udjJEVHJhbnNwb3NlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignSW5wdXQgc2hvdWxkIGhhdmUgcmFuayA0OyBSZWNlaXZlZCBpbnB1dCBzaGFwZTogJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFubmVsQXhpcyA9IHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gMSA6IGlucHV0U2hhcGUubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyBzaG91bGQgYmUgZGVmaW5lZC4gJyArXG4gICAgICAgICAgICAgICAgJ0ZvdW5kIGBOb25lYC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXTtcbiAgICAgICAgdmFyIGtlcm5lbFNoYXBlID0gdGhpcy5rZXJuZWxTaXplLmNvbmNhdChbdGhpcy5maWx0ZXJzLCBpbnB1dERpbV0pO1xuICAgICAgICB0aGlzLmtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KCdrZXJuZWwnLCBrZXJuZWxTaGFwZSwgJ2Zsb2F0MzInLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLCB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLmJpYXMgPSB0aGlzLmFkZFdlaWdodCgnYmlhcycsIFt0aGlzLmZpbHRlcnNdLCAnZmxvYXQzMicsIHRoaXMuYmlhc0luaXRpYWxpemVyLCB0aGlzLmJpYXNSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dFNwZWMgPVxuICAgICAgICAgICAgW25ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IG5kaW06IDQsIGF4ZXM6IChfYSA9IHt9LCBfYVtjaGFubmVsQXhpc10gPSBpbnB1dERpbSwgX2EpIH0pXTtcbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENvbnYyRFRyYW5zcG9zZS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZjLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc2hhcGUubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJDb252MkRUcmFuc3Bvc2UuY2FsbCgpIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIHJhbmstNCwgYnV0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwicmVjZWl2ZWQgYSB0ZW5zb3Igb2YgcmFuay1cIiArIGlucHV0LnNoYXBlLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlucHV0U2hhcGUgPSBpbnB1dC5zaGFwZTtcbiAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuICAgICAgICAgICAgdmFyIGhBeGlzO1xuICAgICAgICAgICAgdmFyIHdBeGlzO1xuICAgICAgICAgICAgaWYgKF90aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgICAgIGhBeGlzID0gMjtcbiAgICAgICAgICAgICAgICB3QXhpcyA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoQXhpcyA9IDE7XG4gICAgICAgICAgICAgICAgd0F4aXMgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGlucHV0U2hhcGVbaEF4aXNdO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaW5wdXRTaGFwZVt3QXhpc107XG4gICAgICAgICAgICB2YXIga2VybmVsSCA9IF90aGlzLmtlcm5lbFNpemVbMF07XG4gICAgICAgICAgICB2YXIga2VybmVsVyA9IF90aGlzLmtlcm5lbFNpemVbMV07XG4gICAgICAgICAgICB2YXIgc3RyaWRlSCA9IF90aGlzLnN0cmlkZXNbMF07XG4gICAgICAgICAgICB2YXIgc3RyaWRlVyA9IF90aGlzLnN0cmlkZXNbMV07XG4gICAgICAgICAgICB2YXIgb3V0SGVpZ2h0ID0gY29udl91dGlsc18xLmRlY29udkxlbmd0aChoZWlnaHQsIHN0cmlkZUgsIGtlcm5lbEgsIF90aGlzLnBhZGRpbmcpO1xuICAgICAgICAgICAgdmFyIG91dFdpZHRoID0gY29udl91dGlsc18xLmRlY29udkxlbmd0aCh3aWR0aCwgc3RyaWRlVywga2VybmVsVywgX3RoaXMucGFkZGluZyk7XG4gICAgICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRIZWlnaHQsIG91dFdpZHRoLCBfdGhpcy5maWx0ZXJzXTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kYXRhRm9ybWF0ICE9PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gdGZjLnRyYW5zcG9zZShpbnB1dCwgWzAsIDIsIDMsIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRwdXRzID0gdGZjLmNvbnYyZFRyYW5zcG9zZShpbnB1dCwgX3RoaXMua2VybmVsLnJlYWQoKSwgb3V0cHV0U2hhcGUsIF90aGlzLnN0cmlkZXMsIF90aGlzLnBhZGRpbmcpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmRhdGFGb3JtYXQgIT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cyA9IHRmYy50cmFuc3Bvc2Uob3V0cHV0cywgWzAsIDMsIDEsIDJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5iaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID1cbiAgICAgICAgICAgICAgICAgICAgSy5iaWFzQWRkKG91dHB1dHMsIF90aGlzLmJpYXMucmVhZCgpLCBfdGhpcy5kYXRhRm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gX3RoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnYyRFRyYW5zcG9zZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHZhciBjaGFubmVsQXhpcztcbiAgICAgICAgdmFyIGhlaWdodEF4aXM7XG4gICAgICAgIHZhciB3aWR0aEF4aXM7XG4gICAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgICAgY2hhbm5lbEF4aXMgPSAxO1xuICAgICAgICAgICAgaGVpZ2h0QXhpcyA9IDI7XG4gICAgICAgICAgICB3aWR0aEF4aXMgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbm5lbEF4aXMgPSAzO1xuICAgICAgICAgICAgaGVpZ2h0QXhpcyA9IDE7XG4gICAgICAgICAgICB3aWR0aEF4aXMgPSAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXJuZWxIID0gdGhpcy5rZXJuZWxTaXplWzBdO1xuICAgICAgICB2YXIga2VybmVsVyA9IHRoaXMua2VybmVsU2l6ZVsxXTtcbiAgICAgICAgdmFyIHN0cmlkZUggPSB0aGlzLnN0cmlkZXNbMF07XG4gICAgICAgIHZhciBzdHJpZGVXID0gdGhpcy5zdHJpZGVzWzFdO1xuICAgICAgICBvdXRwdXRTaGFwZVtjaGFubmVsQXhpc10gPSB0aGlzLmZpbHRlcnM7XG4gICAgICAgIG91dHB1dFNoYXBlW2hlaWdodEF4aXNdID1cbiAgICAgICAgICAgIGNvbnZfdXRpbHNfMS5kZWNvbnZMZW5ndGgob3V0cHV0U2hhcGVbaGVpZ2h0QXhpc10sIHN0cmlkZUgsIGtlcm5lbEgsIHRoaXMucGFkZGluZyk7XG4gICAgICAgIG91dHB1dFNoYXBlW3dpZHRoQXhpc10gPVxuICAgICAgICAgICAgY29udl91dGlsc18xLmRlY29udkxlbmd0aChvdXRwdXRTaGFwZVt3aWR0aEF4aXNdLCBzdHJpZGVXLCBrZXJuZWxXLCB0aGlzLnBhZGRpbmcpO1xuICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgfTtcbiAgICBDb252MkRUcmFuc3Bvc2UucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ2RpbGF0aW9uUmF0ZSddO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgQ29udjJEVHJhbnNwb3NlLmNsYXNzTmFtZSA9ICdDb252MkRUcmFuc3Bvc2UnO1xuICAgIHJldHVybiBDb252MkRUcmFuc3Bvc2U7XG59KENvbnYyRCkpO1xuZXhwb3J0cy5Db252MkRUcmFuc3Bvc2UgPSBDb252MkRUcmFuc3Bvc2U7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoQ29udjJEVHJhbnNwb3NlKTtcbnZhciBTZXBhcmFibGVDb252ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VwYXJhYmxlQ29udiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXBhcmFibGVDb252KHJhbmssIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByYW5rLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSID0gJ2dsb3JvdFVuaWZvcm0nO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX1BPSU5UV0lTRV9JTklUSUFMSVpFUiA9ICdnbG9yb3RVbmlmb3JtJztcbiAgICAgICAgX3RoaXMuZGVwdGh3aXNlS2VybmVsID0gbnVsbDtcbiAgICAgICAgX3RoaXMucG9pbnR3aXNlS2VybmVsID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbmZpZy5maWx0ZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdUaGUgYGZpbHRlcnNgIGNvbmZpZ3VyYXRpb24gZmllbGQgaXMgcmVxdWlyZWQgYnkgU2VwYXJhYmxlQ29udiwgJyArXG4gICAgICAgICAgICAgICAgJ2J1dCBpcyB1bnNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmtlcm5lbEluaXRpYWxpemVyICE9IG51bGwgfHwgY29uZmlnLmtlcm5lbFJlZ3VsYXJpemVyICE9IG51bGwgfHxcbiAgICAgICAgICAgIGNvbmZpZy5rZXJuZWxDb25zdHJhaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdGaWVsZHMga2VybmVsSW5pdGlhbGl6ZXIsIGtlcm5lbFJlZ3VsYXJpemVyIGFuZCBrZXJuZWxDb25zdHJhaW50ICcgK1xuICAgICAgICAgICAgICAgICdhcmUgaW52YWxpZCBmb3IgU2VwYXJhYmxlQ29udjJELiBVc2UgZGVwdGh3aXNlSW5pdGlhbGl6ZXIsICcgK1xuICAgICAgICAgICAgICAgICdkZXB0aHdpc2VSZWd1bGFyaXplciwgZGVwdGh3aXNlQ29uc3RyYWludCwgcG9pbnR3aXNlSW5pdGlhbGl6ZXIsICcgK1xuICAgICAgICAgICAgICAgICdwb2ludHdpc2VSZWd1bGFyaXplciBhbmQgcG9pbnR3aXNlQ29uc3RyYWludCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcucGFkZGluZyAhPSBudWxsICYmIGNvbmZpZy5wYWRkaW5nICE9PSAnc2FtZScgJiZcbiAgICAgICAgICAgIGNvbmZpZy5wYWRkaW5nICE9PSAndmFsaWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlNlcGFyYWJsZUNvbnZcIiArIF90aGlzLnJhbmsgKyBcIkQgc3VwcG9ydHMgb25seSBwYWRkaW5nIG1vZGVzOiBcIiArXG4gICAgICAgICAgICAgICAgKFwiJ3NhbWUnIGFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeShjb25maWcucGFkZGluZykpKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5kZXB0aE11bHRpcGxpZXIgPVxuICAgICAgICAgICAgY29uZmlnLmRlcHRoTXVsdGlwbGllciA9PSBudWxsID8gMSA6IGNvbmZpZy5kZXB0aE11bHRpcGxpZXI7XG4gICAgICAgIF90aGlzLmRlcHRod2lzZUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmRlcHRod2lzZUluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcuZGVwdGh3aXNlUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5kZXB0aHdpc2VDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMucG9pbnR3aXNlSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcuZGVwdGh3aXNlSW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9QT0lOVFdJU0VfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy5wb2ludHdpc2VSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5wb2ludHdpc2VSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLnBvaW50d2lzZUNvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLnBvaW50d2lzZUNvbnN0cmFpbnQpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlcGFyYWJsZUNvbnYucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPCB0aGlzLnJhbmsgKyAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIklucHV0cyB0byBTZXBhcmFibGVDb252XCIgKyB0aGlzLnJhbmsgKyBcIkQgc2hvdWxkIGhhdmUgcmFuayBcIiArXG4gICAgICAgICAgICAgICAgKHRoaXMucmFuayArIDIgKyBcIiwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIikgK1xuICAgICAgICAgICAgICAgIChcIlwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbEF4aXMgPSB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IDEgOiBpbnB1dFNoYXBlLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSA9PSBudWxsIHx8IGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyBzaG91bGQgYmUgZGVmaW5lZCwgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBmb3VuZCBcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dERpbSA9IGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdO1xuICAgICAgICB2YXIgZGVwdGh3aXNlS2VybmVsU2hhcGUgPSB0aGlzLmtlcm5lbFNpemUuY29uY2F0KFtpbnB1dERpbSwgdGhpcy5kZXB0aE11bHRpcGxpZXJdKTtcbiAgICAgICAgdmFyIHBvaW50d2lzZUtlcm5lbFNoYXBlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5rOyArK2kpIHtcbiAgICAgICAgICAgIHBvaW50d2lzZUtlcm5lbFNoYXBlLnB1c2goMSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnR3aXNlS2VybmVsU2hhcGUucHVzaChpbnB1dERpbSAqIHRoaXMuZGVwdGhNdWx0aXBsaWVyLCB0aGlzLmZpbHRlcnMpO1xuICAgICAgICB2YXIgdHJhaW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZXB0aHdpc2VLZXJuZWwgPSB0aGlzLmFkZFdlaWdodCgnZGVwdGh3aXNlX2tlcm5lbCcsIGRlcHRod2lzZUtlcm5lbFNoYXBlLCAnZmxvYXQzMicsIHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIsIHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIsIHRyYWluYWJsZSwgdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy5wb2ludHdpc2VLZXJuZWwgPSB0aGlzLmFkZFdlaWdodCgncG9pbnR3aXNlX2tlcm5lbCcsIHBvaW50d2lzZUtlcm5lbFNoYXBlLCAnZmxvYXQzMicsIHRoaXMucG9pbnR3aXNlSW5pdGlhbGl6ZXIsIHRoaXMucG9pbnR3aXNlUmVndWxhcml6ZXIsIHRyYWluYWJsZSwgdGhpcy5wb2ludHdpc2VDb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoJ2JpYXMnLCBbdGhpcy5maWx0ZXJzXSwgJ2Zsb2F0MzInLCB0aGlzLmJpYXNJbml0aWFsaXplciwgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRyYWluYWJsZSwgdGhpcy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpYXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRTcGVjID1cbiAgICAgICAgICAgIFtuZXcgdG9wb2xvZ3lfMS5JbnB1dFNwZWMoeyBuZGltOiB0aGlzLnJhbmsgKyAyLCBheGVzOiAoX2EgPSB7fSwgX2FbY2hhbm5lbEF4aXNdID0gaW5wdXREaW0sIF9hKSB9KV07XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBTZXBhcmFibGVDb252LnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJzFEIHNlcGFyYWJsZSBjb252b2x1dGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzID0gdGZjLnRyYW5zcG9zZShpbnB1dHMsIFswLCAyLCAzLCAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRmYy5zZXBhcmFibGVDb252MmQoaW5wdXRzLCBfdGhpcy5kZXB0aHdpc2VLZXJuZWwucmVhZCgpLCBfdGhpcy5wb2ludHdpc2VLZXJuZWwucmVhZCgpLCBfdGhpcy5zdHJpZGVzLCBfdGhpcy5wYWRkaW5nLCBfdGhpcy5kaWxhdGlvblJhdGUsICdOSFdDJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IEsuYmlhc0FkZChvdXRwdXQsIF90aGlzLmJpYXMucmVhZCgpLCBfdGhpcy5kYXRhRm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBfdGhpcy5hY3RpdmF0aW9uLmFwcGx5KG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGZjLnRyYW5zcG9zZShvdXRwdXQsIFswLCAzLCAxLCAyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlcGFyYWJsZUNvbnYucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ3JhbmsnXTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZ1sna2VybmVsSW5pdGlhbGl6ZXInXTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZ1sna2VybmVsUmVndWxhcml6ZXInXTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZ1sna2VybmVsQ29uc3RyYWludCddO1xuICAgICAgICBjb25maWdbJ2RlcHRod2lzZUluaXRpYWxpemVyJ10gPVxuICAgICAgICAgICAgaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcik7XG4gICAgICAgIGNvbmZpZ1sncG9pbnR3aXNlSW5pdGlhbGl6ZXInXSA9XG4gICAgICAgICAgICBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnBvaW50d2lzZUluaXRpYWxpemVyKTtcbiAgICAgICAgY29uZmlnWydkZXB0aHdpc2VSZWd1bGFyaXplciddID1cbiAgICAgICAgICAgIHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIpO1xuICAgICAgICBjb25maWdbJ3BvaW50d2lzZVJlZ3VsYXJpemVyJ10gPVxuICAgICAgICAgICAgcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5wb2ludHdpc2VSZWd1bGFyaXplcik7XG4gICAgICAgIGNvbmZpZ1snZGVwdGh3aXNlQ29uc3RyYWludCddID1cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQpO1xuICAgICAgICBjb25maWdbJ3BvaW50d2lzZUNvbnN0cmFpbnQnXSA9XG4gICAgICAgICAgICBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5wb2ludHdpc2VDb25zdHJhaW50KTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIFNlcGFyYWJsZUNvbnYuY2xhc3NOYW1lID0gJ1NlcGFyYWJsZUNvbnYnO1xuICAgIHJldHVybiBTZXBhcmFibGVDb252O1xufShDb252KSk7XG5leHBvcnRzLlNlcGFyYWJsZUNvbnYgPSBTZXBhcmFibGVDb252O1xudmFyIFNlcGFyYWJsZUNvbnYyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcGFyYWJsZUNvbnYyRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXBhcmFibGVDb252MkQoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCAyLCBjb25maWcpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNlcGFyYWJsZUNvbnYyRC5jbGFzc05hbWUgPSAnU2VwYXJhYmxlQ29udjJEJztcbiAgICByZXR1cm4gU2VwYXJhYmxlQ29udjJEO1xufShTZXBhcmFibGVDb252KSk7XG5leHBvcnRzLlNlcGFyYWJsZUNvbnYyRCA9IFNlcGFyYWJsZUNvbnYyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihTZXBhcmFibGVDb252MkQpO1xudmFyIENvbnYxRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnYxRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252MUQoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDEsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW3sgbmRpbTogMyB9XTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb252MUQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ3JhbmsnXTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZ1snZGF0YUZvcm1hdCddO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgQ29udjFELmNsYXNzTmFtZSA9ICdDb252MUQnO1xuICAgIHJldHVybiBDb252MUQ7XG59KENvbnYpKTtcbmV4cG9ydHMuQ29udjFEID0gQ29udjFEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKENvbnYxRCk7XG52YXIgQ3JvcHBpbmcyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENyb3BwaW5nMkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3JvcHBpbmcyRChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5jcm9wcGluZyA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBfdGhpcy5jcm9wcGluZyA9IFtcbiAgICAgICAgICAgICAgICBbY29uZmlnLmNyb3BwaW5nLCBjb25maWcuY3JvcHBpbmddLCBbY29uZmlnLmNyb3BwaW5nLCBjb25maWcuY3JvcHBpbmddXG4gICAgICAgICAgICBdO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlnLmNyb3BwaW5nWzBdID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIF90aGlzLmNyb3BwaW5nID0gW1xuICAgICAgICAgICAgICAgIFtjb25maWcuY3JvcHBpbmdbMF0sIGNvbmZpZy5jcm9wcGluZ1swXV0sXG4gICAgICAgICAgICAgICAgW2NvbmZpZy5jcm9wcGluZ1sxXSwgY29uZmlnLmNyb3BwaW5nWzFdXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgX3RoaXMuY3JvcHBpbmcgPSBjb25maWcuY3JvcHBpbmc7XG4gICAgICAgIF90aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICAgICAgY29uZmlnLmRhdGFGb3JtYXQgPT09IHVuZGVmaW5lZCA/ICdjaGFubmVsc0xhc3QnIDogY29uZmlnLmRhdGFGb3JtYXQ7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFt7IG5kaW06IDQgfV07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ3JvcHBpbmcyRC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlWzBdLCBpbnB1dFNoYXBlWzFdLFxuICAgICAgICAgICAgICAgIGlucHV0U2hhcGVbMl0gLSB0aGlzLmNyb3BwaW5nWzBdWzBdIC0gdGhpcy5jcm9wcGluZ1swXVsxXSxcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlWzJdIC0gdGhpcy5jcm9wcGluZ1sxXVswXSAtIHRoaXMuY3JvcHBpbmdbMV1bMV1cbiAgICAgICAgICAgIF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZVswXSxcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlWzFdIC0gdGhpcy5jcm9wcGluZ1swXVswXSAtIHRoaXMuY3JvcHBpbmdbMF1bMV0sXG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZVsyXSAtIHRoaXMuY3JvcHBpbmdbMV1bMF0gLSB0aGlzLmNyb3BwaW5nWzFdWzFdLCBpbnB1dFNoYXBlWzNdXG4gICAgICAgICAgICBdO1xuICAgIH07XG4gICAgQ3JvcHBpbmcyRC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICAgICAgICAgIHZhciBoU2xpY2VkID0gSy5zbGljZUFsb25nQXhpcyhpbnB1dHMsIF90aGlzLmNyb3BwaW5nWzBdWzBdLCBpbnB1dHMuc2hhcGVbMV0gLSBfdGhpcy5jcm9wcGluZ1swXVswXSAtIF90aGlzLmNyb3BwaW5nWzBdWzFdLCAyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSy5zbGljZUFsb25nQXhpcyhoU2xpY2VkLCBfdGhpcy5jcm9wcGluZ1sxXVswXSwgaW5wdXRzLnNoYXBlWzJdIC0gX3RoaXMuY3JvcHBpbmdbMV1bMV0gLSBfdGhpcy5jcm9wcGluZ1sxXVswXSwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaFNsaWNlZCA9IEsuc2xpY2VBbG9uZ0F4aXMoaW5wdXRzLCBfdGhpcy5jcm9wcGluZ1swXVswXSwgaW5wdXRzLnNoYXBlWzJdIC0gX3RoaXMuY3JvcHBpbmdbMF1bMF0gLSBfdGhpcy5jcm9wcGluZ1swXVsxXSwgMyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEsuc2xpY2VBbG9uZ0F4aXMoaFNsaWNlZCwgX3RoaXMuY3JvcHBpbmdbMV1bMF0sIGlucHV0cy5zaGFwZVszXSAtIF90aGlzLmNyb3BwaW5nWzFdWzFdIC0gX3RoaXMuY3JvcHBpbmdbMV1bMF0sIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENyb3BwaW5nMkQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgY3JvcHBpbmc6IHRoaXMuY3JvcHBpbmcsIGRhdGFGb3JtYXQ6IHRoaXMuZGF0YUZvcm1hdCB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIENyb3BwaW5nMkQuY2xhc3NOYW1lID0gJ0Nyb3BwaW5nMkQnO1xuICAgIHJldHVybiBDcm9wcGluZzJEO1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLkNyb3BwaW5nMkQgPSBDcm9wcGluZzJEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKENyb3BwaW5nMkQpO1xudmFyIFVwU2FtcGxpbmcyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVwU2FtcGxpbmcyRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVcFNhbXBsaW5nMkQoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9TSVpFID0gWzIsIDJdO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbeyBuZGltOiA0IH1dO1xuICAgICAgICBfdGhpcy5zaXplID0gY29uZmlnLnNpemUgPT09IHVuZGVmaW5lZCA/IF90aGlzLkRFRkFVTFRfU0laRSA6IGNvbmZpZy5zaXplO1xuICAgICAgICBfdGhpcy5kYXRhRm9ybWF0ID1cbiAgICAgICAgICAgIGNvbmZpZy5kYXRhRm9ybWF0ID09PSB1bmRlZmluZWQgPyAnY2hhbm5lbHNMYXN0JyA6IGNvbmZpZy5kYXRhRm9ybWF0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFVwU2FtcGxpbmcyRC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5zaXplWzBdICogaW5wdXRTaGFwZVsyXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuc2l6ZVsxXSAqIGlucHV0U2hhcGVbM107XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGlucHV0U2hhcGVbMV0sIGhlaWdodCwgd2lkdGhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuc2l6ZVswXSAqIGlucHV0U2hhcGVbMV07XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnNpemVbMV0gKiBpbnB1dFNoYXBlWzJdO1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBoZWlnaHQsIHdpZHRoLCBpbnB1dFNoYXBlWzNdXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXBTYW1wbGluZzJELnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmMudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIHZhciBpbnB1dFNoYXBlID0gaW5wdXQuc2hhcGU7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSB0ZmMudHJhbnNwb3NlKGlucHV0LCBbMCwgMiwgMywgMV0pO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBfdGhpcy5zaXplWzBdICogaW5wdXRTaGFwZVsyXTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfdGhpcy5zaXplWzFdICogaW5wdXRTaGFwZVszXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzaXplZCA9IGlucHV0LnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihbaGVpZ2h0LCB3aWR0aF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZmMudHJhbnNwb3NlKHJlc2l6ZWQsIFswLCAzLCAxLCAyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX3RoaXMuc2l6ZVswXSAqIGlucHV0U2hhcGVbMV07XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX3RoaXMuc2l6ZVsxXSAqIGlucHV0U2hhcGVbMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihbaGVpZ2h0LCB3aWR0aF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVwU2FtcGxpbmcyRC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0geyBzaXplOiB0aGlzLnNpemUsIGRhdGFGb3JtYXQ6IHRoaXMuZGF0YUZvcm1hdCB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIFVwU2FtcGxpbmcyRC5jbGFzc05hbWUgPSAnVXBTYW1wbGluZzJEJztcbiAgICByZXR1cm4gVXBTYW1wbGluZzJEO1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLlVwU2FtcGxpbmcyRCA9IFVwU2FtcGxpbmcyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihVcFNhbXBsaW5nMkQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udm9sdXRpb25hbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvY29tbW9uXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgY29tbW9uXzIgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIGNvbnN0cmFpbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RyYWludHNcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGluaXRpYWxpemVyc18xID0gcmVxdWlyZShcIi4uL2luaXRpYWxpemVyc1wiKTtcbnZhciByZWd1bGFyaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9yZWd1bGFyaXplcnNcIik7XG52YXIgY29udl91dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbnZfdXRpbHNcIik7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgY29udm9sdXRpb25hbF8xID0gcmVxdWlyZShcIi4vY29udm9sdXRpb25hbFwiKTtcbmZ1bmN0aW9uIGRlcHRod2lzZUNvbnYyZCh4LCBkZXB0aHdpc2VLZXJuZWwsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsIGRpbGF0aW9uUmF0ZSkge1xuICAgIGlmIChzdHJpZGVzID09PSB2b2lkIDApIHsgc3RyaWRlcyA9IFsxLCAxXTsgfVxuICAgIGlmIChwYWRkaW5nID09PSB2b2lkIDApIHsgcGFkZGluZyA9ICd2YWxpZCc7IH1cbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFGb3JtYXQgPSBjb21tb25fMS5pbWFnZURhdGFGb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgICAgIHZhciB5ID0gY29udm9sdXRpb25hbF8xLnByZXByb2Nlc3NDb252MkRJbnB1dCh4LCBkYXRhRm9ybWF0KTtcbiAgICAgICAgaWYgKHgucmFuayAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbnB1dCBmb3IgZGVwdGh3aXNlQ29udjJkIGlzIHJlcXVpcmVkIHRvIGJlIDQtRCwgYnV0IGlzIGluc3RlYWQgXCIgK1xuICAgICAgICAgICAgICAgICh4LnJhbmsgKyBcIi1EXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwdGh3aXNlS2VybmVsLnJhbmsgIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiZGVwdGh3aXNlS2VybmVsIGlzIHJlcXVpcmVkIHRvIGJlIDQtRCwgYnV0IGlzIGluc3RlYWQgXCIgK1xuICAgICAgICAgICAgICAgIChkZXB0aHdpc2VLZXJuZWwucmFuayArIFwiLURcIikpO1xuICAgICAgICB9XG4gICAgICAgIHkgPSB0ZmMuZGVwdGh3aXNlQ29udjJkKHksIGRlcHRod2lzZUtlcm5lbCwgc3RyaWRlcywgcGFkZGluZyA9PT0gJ3NhbWUnID8gJ3NhbWUnIDogJ3ZhbGlkJywgJ05IV0MnLCBkaWxhdGlvblJhdGUpO1xuICAgICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICB5ID0gdGZjLnRyYW5zcG9zZSh5LCBbMCwgMywgMSwgMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZXB0aHdpc2VDb252MmQgPSBkZXB0aHdpc2VDb252MmQ7XG52YXIgRGVwdGh3aXNlQ29udjJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVwdGh3aXNlQ29udjJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlcHRod2lzZUNvbnYyRChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZXB0aHdpc2VLZXJuZWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5kZXB0aE11bHRpcGxpZXIgPVxuICAgICAgICAgICAgY29uZmlnLmRlcHRoTXVsdGlwbGllciA9PSBudWxsID8gMSA6IGNvbmZpZy5kZXB0aE11bHRpcGxpZXI7XG4gICAgICAgIF90aGlzLmRlcHRod2lzZUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmRlcHRod2lzZUluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMuZGVwdGh3aXNlQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcuZGVwdGh3aXNlQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmRlcHRod2lzZVJlZ3VsYXJpemVyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEZXB0aHdpc2VDb252MkQucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHNfMS5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgaGF2ZSByYW5rIDQuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJSZWNlaXZlZCBpbnB1dCBzaGFwZTogXCIgKyBKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5uZWxBeGlzID0gdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyAxIDogMztcbiAgICAgICAgaWYgKGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdID09IG51bGwgfHwgaW5wdXRTaGFwZVtjaGFubmVsQXhpc10gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgdG8gRGVwdGh3aXNlQ29udjJEIHNob3VsZCAnICtcbiAgICAgICAgICAgICAgICAoXCJiZSBkZWZpbmVkLCBidXQgaXMgbm90IChcIiArIGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdICsgXCIpLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0RGltID0gaW5wdXRTaGFwZVtjaGFubmVsQXhpc107XG4gICAgICAgIHZhciBkZXB0aHdpc2VLZXJuZWxTaGFwZSA9IFtcbiAgICAgICAgICAgIHRoaXMua2VybmVsU2l6ZVswXSwgdGhpcy5rZXJuZWxTaXplWzFdLCBpbnB1dERpbSwgdGhpcy5kZXB0aE11bHRpcGxpZXJcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5kZXB0aHdpc2VLZXJuZWwgPSB0aGlzLmFkZFdlaWdodCgnZGVwdGh3aXNlX2tlcm5lbCcsIGRlcHRod2lzZUtlcm5lbFNoYXBlLCBudWxsLCB0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyLCB0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQpO1xuICAgICAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLmJpYXMgPSB0aGlzLmFkZFdlaWdodCgnYmlhcycsIFtpbnB1dERpbSAqIHRoaXMuZGVwdGhNdWx0aXBsaWVyXSwgbnVsbCwgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmlhcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgfTtcbiAgICBEZXB0aHdpc2VDb252MkQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5wdXRzID0gZ2VuZXJpY191dGlsc18xLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRzID0gZGVwdGh3aXNlQ29udjJkKGlucHV0cywgX3RoaXMuZGVwdGh3aXNlS2VybmVsLnJlYWQoKSwgX3RoaXMuc3RyaWRlcywgX3RoaXMucGFkZGluZywgX3RoaXMuZGF0YUZvcm1hdCwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBLLmJpYXNBZGQob3V0cHV0cywgX3RoaXMuYmlhcy5yZWFkKCksIF90aGlzLmRhdGFGb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmFjdGl2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBfdGhpcy5hY3RpdmF0aW9uLmFwcGx5KG91dHB1dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGVwdGh3aXNlQ29udjJELnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlsc18xLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IGlucHV0U2hhcGVbMl0gOiBpbnB1dFNoYXBlWzFdO1xuICAgICAgICB2YXIgY29scyA9IHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gaW5wdXRTaGFwZVszXSA6IGlucHV0U2hhcGVbMl07XG4gICAgICAgIHZhciBvdXRGaWx0ZXJzID0gdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgP1xuICAgICAgICAgICAgaW5wdXRTaGFwZVsxXSAqIHRoaXMuZGVwdGhNdWx0aXBsaWVyIDpcbiAgICAgICAgICAgIGlucHV0U2hhcGVbM10gKiB0aGlzLmRlcHRoTXVsdGlwbGllcjtcbiAgICAgICAgdmFyIG91dFJvd3MgPSBjb252X3V0aWxzXzEuY29udk91dHB1dExlbmd0aChyb3dzLCB0aGlzLmtlcm5lbFNpemVbMF0sIHRoaXMucGFkZGluZywgdGhpcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgdmFyIG91dENvbHMgPSBjb252X3V0aWxzXzEuY29udk91dHB1dExlbmd0aChjb2xzLCB0aGlzLmtlcm5lbFNpemVbMV0sIHRoaXMucGFkZGluZywgdGhpcy5zdHJpZGVzWzFdKTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIG91dEZpbHRlcnMsIG91dFJvd3MsIG91dENvbHNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBvdXRSb3dzLCBvdXRDb2xzLCBvdXRGaWx0ZXJzXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVwdGh3aXNlQ29udjJELmNsYXNzTmFtZSA9ICdEZXB0aHdpc2VDb252MkQnO1xuICAgIHJldHVybiBEZXB0aHdpc2VDb252MkQ7XG59KGNvbnZvbHV0aW9uYWxfMS5Db252MkQpKTtcbmV4cG9ydHMuRGVwdGh3aXNlQ29udjJEID0gRGVwdGh3aXNlQ29udjJEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKERlcHRod2lzZUNvbnYyRCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252b2x1dGlvbmFsX2RlcHRod2lzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBhY3RpdmF0aW9uc18xID0gcmVxdWlyZShcIi4uL2FjdGl2YXRpb25zXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgY29uc3RyYWludHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHJhaW50c1wiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4uL2VuZ2luZS90b3BvbG9neVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi4vaW5pdGlhbGl6ZXJzXCIpO1xudmFyIHJlZ3VsYXJpemVyc18xID0gcmVxdWlyZShcIi4uL3JlZ3VsYXJpemVyc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgbWF0aF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9tYXRoX3V0aWxzXCIpO1xudmFyIERyb3BvdXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcm9wb3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyb3BvdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmF0ZSA9IE1hdGgubWF4KE1hdGgubWluKGNvbmZpZy5yYXRlLCAxKSwgMCk7XG4gICAgICAgIF90aGlzLnJhdGVTY2FsYXIgPSBLLmdldFNjYWxhcihfdGhpcy5yYXRlKTtcbiAgICAgICAgX3RoaXMubm9pc2VTaGFwZSA9IGNvbmZpZy5ub2lzZVNoYXBlO1xuICAgICAgICBfdGhpcy5zZWVkID0gY29uZmlnLnNlZWQ7XG4gICAgICAgIGlmIChfdGhpcy5zZWVkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdOb24tZGVmYXVsdCBzZWVkIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBEcm9wb3V0IGxheWVyIHlldDogJyArXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VlZCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3VwcG9ydHNNYXNraW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEcm9wb3V0LnByb3RvdHlwZS5nZXROb2lzZVNoYXBlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLm5vaXNlU2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9pc2VTaGFwZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICAgICAgICB2YXIgbm9pc2VTaGFwZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm9pc2VTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbm9pc2VTaGFwZS5wdXNoKHRoaXMubm9pc2VTaGFwZVtpXSA9PSBudWxsID8gaW5wdXRTaGFwZVtpXSA6IHRoaXMubm9pc2VTaGFwZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vaXNlU2hhcGU7XG4gICAgfTtcbiAgICBEcm9wb3V0LnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgaWYgKF90aGlzLm5vaXNlU2hhcGUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICF0ZmpzX2NvcmVfMS51dGlsLmFycmF5c0VxdWFsKGlucHV0LnNoYXBlLCBfdGhpcy5ub2lzZVNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdOb24tZGVmYXVsdCBub2lzZSBzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gRHJvcG91dCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xheWVyIHlldDogJyArIEpTT04uc3RyaW5naWZ5KF90aGlzLm5vaXNlU2hhcGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgwIDwgX3RoaXMucmF0ZSAmJiBfdGhpcy5yYXRlIDwgMSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmluZyA9IGt3YXJnc1sndHJhaW5pbmcnXSA9PSBudWxsID8gZmFsc2UgOiBrd2FyZ3NbJ3RyYWluaW5nJ107XG4gICAgICAgICAgICAgICAgdmFyIG5vaXNlU2hhcGVfMSA9IF90aGlzLmdldE5vaXNlU2hhcGUoaW5wdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBLLmluVHJhaW5QaGFzZShmdW5jdGlvbiAoKSB7IHJldHVybiBLLmRyb3BvdXQoaW5wdXQsIF90aGlzLnJhdGVTY2FsYXIsIG5vaXNlU2hhcGVfMSwgX3RoaXMuc2VlZCk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0OyB9LCB0cmFpbmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRHJvcG91dC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgcmF0ZTogdGhpcy5yYXRlLFxuICAgICAgICAgICAgbm9pc2VTaGFwZTogdGhpcy5ub2lzZVNoYXBlLFxuICAgICAgICAgICAgc2VlZDogdGhpcy5zZWVkLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIERyb3BvdXQuY2xhc3NOYW1lID0gJ0Ryb3BvdXQnO1xuICAgIHJldHVybiBEcm9wb3V0O1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLkRyb3BvdXQgPSBEcm9wb3V0O1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKERyb3BvdXQpO1xudmFyIERlbnNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVuc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVuc2UoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWN0aXZhdGlvbiA9IG51bGw7XG4gICAgICAgIF90aGlzLnVzZUJpYXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5rZXJuZWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5iaWFzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIgPSAnZ2xvcm90Tm9ybWFsJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSID0gJ3plcm9zJztcbiAgICAgICAgaWYgKGNvbmZpZy5iYXRjaElucHV0U2hhcGUgPT0gbnVsbCAmJiBjb25maWcuaW5wdXRTaGFwZSA9PSBudWxsICYmXG4gICAgICAgICAgICBjb25maWcuaW5wdXREaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmJhdGNoU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplID0gY29uZmlnLmJhdGNoU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmJhdGNoSW5wdXRTaGFwZSA9IFtiYXRjaFNpemUsIGNvbmZpZy5pbnB1dERpbV07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMudW5pdHMgPSBjb25maWcudW5pdHM7XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb24gPSBhY3RpdmF0aW9uc18xLmdldEFjdGl2YXRpb24oY29uZmlnLmFjdGl2YXRpb24pO1xuICAgICAgICBpZiAoY29uZmlnLnVzZUJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMudXNlQmlhcyA9IGNvbmZpZy51c2VCaWFzO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmtlcm5lbEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmtlcm5lbEluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMuYmlhc0luaXRpYWxpemVyID1cbiAgICAgICAgICAgIGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5iaWFzSW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMua2VybmVsQ29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcua2VybmVsQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmJpYXNDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmtlcm5lbFJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmtlcm5lbFJlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMuYmlhc1JlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmJpYXNSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcuYWN0aXZpdHlSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFt7IG1pbk5EaW06IDIgfV07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGVuc2UucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgaW5wdXRMYXN0RGltID0gaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5rZXJuZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5rZXJuZWwgPSB0aGlzLmFkZFdlaWdodCgna2VybmVsJywgW2lucHV0TGFzdERpbSwgdGhpcy51bml0c10sIG51bGwsIHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsIHRoaXMua2VybmVsUmVndWxhcml6ZXIsIHRydWUsIHRoaXMua2VybmVsQ29uc3RyYWludCk7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoJ2JpYXMnLCBbdGhpcy51bml0c10sIG51bGwsIHRoaXMuYmlhc0luaXRpYWxpemVyLCB0aGlzLmJpYXNSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dFNwZWMgPSBbeyBtaW5ORGltOiAyLCBheGVzOiAoX2EgPSB7fSwgX2FbLTFdID0gaW5wdXRMYXN0RGltLCBfYSkgfV07XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBEZW5zZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XG4gICAgICAgIG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDFdID0gdGhpcy51bml0cztcbiAgICAgICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICAgIH07XG4gICAgRGVuc2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gSy5kb3QoaW5wdXQsIF90aGlzLmtlcm5lbC5yZWFkKCkpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IEsuYmlhc0FkZChvdXRwdXQsIF90aGlzLmJpYXMucmVhZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBfdGhpcy5hY3RpdmF0aW9uLmFwcGx5KG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERlbnNlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICB1bml0czogdGhpcy51bml0cyxcbiAgICAgICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25zXzEuc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAgICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICAgICAgICBrZXJuZWxSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiaWFzUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICAgICAgICBrZXJuZWxDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGJpYXNDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBEZW5zZS5jbGFzc05hbWUgPSAnRGVuc2UnO1xuICAgIHJldHVybiBEZW5zZTtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5EZW5zZSA9IERlbnNlO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKERlbnNlKTtcbnZhciBGbGF0dGVuID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxhdHRlbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGbGF0dGVuKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcgfHwge30pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFt7IG1pbk5EaW06IDMgfV07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmxhdHRlbi5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gaW5wdXRTaGFwZS5zbGljZSgxKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBkaW0gPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoZGltID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgdG8gXFxcIkZsYXR0ZW5cXFwiIGlzIG5vdCBmdWxseSBkZWZpbmVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiKGdvdCBcIiArIGlucHV0U2hhcGUuc2xpY2UoMSkgKyBcIikuIE1ha2Ugc3VyZSB0byBwYXNzIGEgY29tcGxldGUgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXFwiaW5wdXRfc2hhcGVcXFwiIG9yIFxcXCJiYXRjaF9pbnB1dF9zaGFwZVxcXCIgYXJndW1lbnQgdG8gdGhlIGZpcnN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJsYXllciBpbiB5b3VyIG1vZGVsLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIG1hdGhfdXRpbHMuYXJyYXlQcm9kKGlucHV0U2hhcGUsIDEpXTtcbiAgICB9O1xuICAgIEZsYXR0ZW4ucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIEsuYmF0Y2hGbGF0dGVuKGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGbGF0dGVuLmNsYXNzTmFtZSA9ICdGbGF0dGVuJztcbiAgICByZXR1cm4gRmxhdHRlbjtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5GbGF0dGVuID0gRmxhdHRlbjtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihGbGF0dGVuKTtcbnZhciBBY3RpdmF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aXZhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3RpdmF0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2YXRpb24gPSBhY3RpdmF0aW9uc18xLmdldEFjdGl2YXRpb24oY29uZmlnLmFjdGl2YXRpb24pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFjdGl2YXRpb24ucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYWN0aXZhdGlvbi5hcHBseShpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWN0aXZhdGlvbi5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0geyBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uc18xLnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIEFjdGl2YXRpb24uY2xhc3NOYW1lID0gJ0FjdGl2YXRpb24nO1xuICAgIHJldHVybiBBY3RpdmF0aW9uO1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLkFjdGl2YXRpb24gPSBBY3RpdmF0aW9uO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEFjdGl2YXRpb24pO1xudmFyIFJlcGVhdFZlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGVhdFZlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBlYXRWZWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubiA9IGNvbmZpZy5uO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbeyBuZGltOiAyIH1dO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlcGVhdFZlY3Rvci5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCB0aGlzLm4sIGlucHV0U2hhcGVbMV1dO1xuICAgIH07XG4gICAgUmVwZWF0VmVjdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGdlbmVyaWNfdXRpbHNfMS5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICByZXR1cm4gSy5yZXBlYXQoaW5wdXRzLCBfdGhpcy5uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXBlYXRWZWN0b3IucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG46IHRoaXMubixcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBSZXBlYXRWZWN0b3IuY2xhc3NOYW1lID0gJ1JlcGVhdFZlY3Rvcic7XG4gICAgcmV0dXJuIFJlcGVhdFZlY3Rvcjtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5SZXBlYXRWZWN0b3IgPSBSZXBlYXRWZWN0b3I7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoUmVwZWF0VmVjdG9yKTtcbnZhciBSZXNoYXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaGFwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXNoYXBlKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhcmdldFNoYXBlID0gY29uZmlnLnRhcmdldFNoYXBlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnRhcmdldFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNVbmtub3duKF90aGlzLnRhcmdldFNoYXBlW2ldKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRhcmdldFNoYXBlW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc2hhcGUucHJvdG90eXBlLmlzVW5rbm93biA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgcmV0dXJuIGRpbSA8IDAgfHwgZGltID09IG51bGw7XG4gICAgfTtcbiAgICBSZXNoYXBlLnByb3RvdHlwZS5maXhVbmtub3duRGltZW5zaW9uID0gZnVuY3Rpb24gKGlucHV0U2hhcGUsIG91dHB1dFNoYXBlKSB7XG4gICAgICAgIHZhciBlcnJvck1zZyA9ICdUb3RhbCBzaXplIG9mIG5ldyBhcnJheSBtdXN0IGJlIHVuY2hhbmdlZC4nO1xuICAgICAgICB2YXIgZmluYWxTaGFwZSA9IG91dHB1dFNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHZhciBrbm93biA9IDE7XG4gICAgICAgIHZhciB1bmtub3duID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZGltID0gZmluYWxTaGFwZVtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVW5rbm93bihkaW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVua25vd24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93biA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQ2FuIG9ubHkgc3BlY2lmaXkgb25lIHVua25vd24gZGltZW5zaW9uLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtub3duICo9IGRpbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWxTaXplID0gbWF0aF91dGlscy5hcnJheVByb2QoaW5wdXRTaGFwZSk7XG4gICAgICAgIGlmICh1bmtub3duICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa25vd24gPT09IDAgfHwgb3JpZ2luYWxTaXplICUga25vd24gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihlcnJvck1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbFNoYXBlW3Vua25vd25dID0gb3JpZ2luYWxTaXplIC8ga25vd247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3JpZ2luYWxTaXplICE9PSBrbm93bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbFNoYXBlO1xuICAgIH07XG4gICAgUmVzaGFwZS5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgdmFyIGFueVVua25vd25EaW1zID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVbmtub3duKGlucHV0U2hhcGVbaV0pKSB7XG4gICAgICAgICAgICAgICAgYW55VW5rbm93bkRpbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlVbmtub3duRGltcykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0U2hhcGUuc2xpY2UoMCwgMSkuY29uY2F0KHRoaXMudGFyZ2V0U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0U2hhcGUuc2xpY2UoMCwgMSkuY29uY2F0KHRoaXMuZml4VW5rbm93bkRpbWVuc2lvbihpbnB1dFNoYXBlLnNsaWNlKDEpLCB0aGlzLnRhcmdldFNoYXBlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc2hhcGUucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IEsuc2hhcGUoaW5wdXQpO1xuICAgICAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwLCAxKS5jb25jYXQoX3RoaXMuZml4VW5rbm93bkRpbWVuc2lvbihpbnB1dFNoYXBlLnNsaWNlKDEpLCBfdGhpcy50YXJnZXRTaGFwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlc2hhcGUob3V0cHV0U2hhcGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc2hhcGUucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhcmdldFNoYXBlOiB0aGlzLnRhcmdldFNoYXBlLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIFJlc2hhcGUuY2xhc3NOYW1lID0gJ1Jlc2hhcGUnO1xuICAgIHJldHVybiBSZXNoYXBlO1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLlJlc2hhcGUgPSBSZXNoYXBlO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFJlc2hhcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGNvbnN0cmFpbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RyYWludHNcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGluaXRpYWxpemVyc18xID0gcmVxdWlyZShcIi4uL2luaXRpYWxpemVyc1wiKTtcbnZhciByZWd1bGFyaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9yZWd1bGFyaXplcnNcIik7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIEVtYmVkZGluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtYmVkZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbWJlZGRpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZW1iZWRkaW5ncyA9IG51bGw7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfRU1CRURESU5HU19JTklUSUFMSVpFUiA9ICdyYW5kb21Vbmlmb3JtJztcbiAgICAgICAgaWYgKGNvbmZpZy5iYXRjaElucHV0U2hhcGUgPT0gbnVsbCAmJiBjb25maWcuaW5wdXRTaGFwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25maWcuYmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBiYXRjaFNpemUgPSBjb25maWcuYmF0Y2hTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5pbnB1dExlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmF0Y2hJbnB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5iYXRjaElucHV0U2hhcGUgPVxuICAgICAgICAgICAgICAgICAgICBbYmF0Y2hTaXplXS5jb25jYXQoZ2VuZXJpY191dGlscy50b0xpc3QoY29uZmlnLmlucHV0TGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuaW5wdXREaW0gPSBjb25maWcuaW5wdXREaW07XG4gICAgICAgIF90aGlzLm91dHB1dERpbSA9IGNvbmZpZy5vdXRwdXREaW07XG4gICAgICAgIF90aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9FTUJFRERJTkdTX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMuZW1iZWRkaW5nc1JlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmVtYmVkZGluZ3NSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcuYWN0aXZpdHlSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5lbWJlZGRpbmdzQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLm1hc2taZXJvID0gY29uZmlnLm1hc2taZXJvO1xuICAgICAgICBfdGhpcy5pbnB1dExlbmd0aCA9IGNvbmZpZy5pbnB1dExlbmd0aDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbWJlZGRpbmcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgdGhpcy5lbWJlZGRpbmdzID0gdGhpcy5hZGRXZWlnaHQoJ2VtYmVkZGluZ3MnLCBbdGhpcy5pbnB1dERpbSwgdGhpcy5vdXRwdXREaW1dLCB0aGlzLmR0eXBlLCB0aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplciwgdGhpcy5lbWJlZGRpbmdzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuZW1iZWRkaW5nc0NvbnN0cmFpbnQpO1xuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIEVtYmVkZGluZy5wcm90b3R5cGUuY29tcHV0ZU1hc2sgPSBmdW5jdGlvbiAoaW5wdXRzLCBtYXNrKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdjb21wdXRlTWFzayBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIEVtYmVkZGluZyB5ZXQnKTtcbiAgICB9O1xuICAgIEVtYmVkZGluZy5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dExlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRTaGFwZS5jb25jYXQoW3RoaXMub3V0cHV0RGltXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluTGVucyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KHRoaXMuaW5wdXRMZW5ndGgpO1xuICAgICAgICBpZiAoaW5MZW5zLmxlbmd0aCAhPT0gaW5wdXRTaGFwZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlxcXCJpbnB1dExlbmd0aFxcXCIgaXMgXCIgKyB0aGlzLmlucHV0TGVuZ3RoICsgXCIsIGJ1dCByZWNlaXZlZCBcIiArXG4gICAgICAgICAgICAgICAgKFwiaW5wdXQgc2hhcGUgaGFzIHNoYXBlIFwiICsgaW5wdXRTaGFwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbkxlbnMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgICAgICB2YXIgczEgPSBpbkxlbnNba107XG4gICAgICAgICAgICAgICAgdmFyIHMyID0gaW5wdXRTaGFwZVtrICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKChzMSAhPSBudWxsKSAmJiAoczIgIT0gbnVsbCkgJiYgKHMxICE9PSBzMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJcXFwiaW5wdXRMZW5ndGhcXFwiIGlzIFwiICsgdGhpcy5pbnB1dExlbmd0aCArIFwiLCBidXQgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiaW5wdXQgc2hhcGUgaGFzIHNoYXBlIFwiICsgaW5wdXRTaGFwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzMSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGluTGVuc1tpXSA9IHMyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdXS5jb25jYXQoaW5MZW5zLCBbdGhpcy5vdXRwdXREaW1dKTtcbiAgICB9O1xuICAgIEVtYmVkZGluZy5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnZva2VDYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIGlmIChLLmR0eXBlKGlucHV0KSAhPT0gJ2ludDMyJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gSy5jYXN0KGlucHV0LCAnaW50MzInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBLLmdhdGhlcihfdGhpcy5lbWJlZGRpbmdzLnJlYWQoKSwgaW5wdXQuYXMxRCgpKTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQucmVzaGFwZShnZW5lcmljX3V0aWxzXzEuZ2V0RXhhY3RseU9uZVNoYXBlKF90aGlzLmNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dC5zaGFwZSkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbWJlZGRpbmcucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGlucHV0RGltOiB0aGlzLmlucHV0RGltLFxuICAgICAgICAgICAgb3V0cHV0RGltOiB0aGlzLm91dHB1dERpbSxcbiAgICAgICAgICAgIGVtYmVkZGluZ3NJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgZW1iZWRkaW5nc1JlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplciksXG4gICAgICAgICAgICBhY3Rpdml0eVJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgZW1iZWRkaW5nc0NvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50KSxcbiAgICAgICAgICAgIG1hc2taZXJvOiB0aGlzLm1hc2taZXJvLFxuICAgICAgICAgICAgaW5wdXRMZW5ndGg6IHRoaXMuaW5wdXRMZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBFbWJlZGRpbmcuY2xhc3NOYW1lID0gJ0VtYmVkZGluZyc7XG4gICAgcmV0dXJuIEVtYmVkZGluZztcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5FbWJlZGRpbmcgPSBFbWJlZGRpbmc7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoRW1iZWRkaW5nKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmVkZGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgbWF0aFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL21hdGhfdXRpbHNcIik7XG52YXIgTWVyZ2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXJnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnIHx8IHt9KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1lcmdlLnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH07XG4gICAgTWVyZ2UucHJvdG90eXBlLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoc2hhcGUxLCBzaGFwZTIpIHtcbiAgICAgICAgaWYgKHNoYXBlMSA9PSBudWxsIHx8IHNoYXBlMiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGFwZTEubGVuZ3RoIDwgc2hhcGUyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZShzaGFwZTIsIHNoYXBlMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hhcGUyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBzaGFwZTEuc2xpY2UoMCwgc2hhcGUxLmxlbmd0aCAtIHNoYXBlMi5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNoYXBlMi5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgdmFyIGkgPSBzaGFwZTFbc2hhcGUxLmxlbmd0aCAtIHNoYXBlMi5sZW5ndGggKyBrXTtcbiAgICAgICAgICAgIHZhciBqID0gc2hhcGUyW2tdO1xuICAgICAgICAgICAgaWYgKGkgPT0gbnVsbCB8fCBqID09IG51bGwgfHwgaSA8IDAgfHwgaiA8IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2goaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0U2hhcGUucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2hhcGUxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KHNoYXBlMikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0U2hhcGUpICYmICFBcnJheS5pc0FycmF5KGlucHV0U2hhcGVbMF0pKSB7XG4gICAgICAgICAgICBpbnB1dFNoYXBlID0gW2dlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpXTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0EgbWVyZ2UgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhbiBBcnJheSBvZiBhdCBsZWFzdCAyIGlucHV0cy4nICtcbiAgICAgICAgICAgICAgICAoXCIgR290IFwiICsgaW5wdXRTaGFwZS5sZW5ndGggKyBcIiBpbnB1dChzKS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXRjaFNpemVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRTaGFwZV8xID0gaW5wdXRTaGFwZTsgX2kgPCBpbnB1dFNoYXBlXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBpbnB1dFNoYXBlXzFbX2ldO1xuICAgICAgICAgICAgaWYgKHNoYXBlICE9IG51bGwgJiYgc2hhcGVbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBiYXRjaFNpemVzLnB1c2goc2hhcGVbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJhdGNoU2l6ZXMgPSBnZW5lcmljX3V0aWxzLnVuaXF1ZShiYXRjaFNpemVzKTtcbiAgICAgICAgaWYgKGJhdGNoU2l6ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJDYW4gbm90IG1lcmdlIHRlbnNvcnMgd2l0aCBkaWZmZXJlbnQgYmF0Y2ggc2l6ZXMuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJHb3QgdGVuc29ycyB3aXRoIHNoYXBlczogXCIgKyBKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZVswXSA9PSBudWxsID8gbnVsbCA6IGlucHV0U2hhcGVbMF0uc2xpY2UoMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gaW5wdXRTaGFwZVtpXSA9PSBudWxsID8gbnVsbCA6IGlucHV0U2hhcGVbaV0uc2xpY2UoMSk7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IHRoaXMuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZShvdXRwdXRTaGFwZSwgc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxSYW5rcyA9IGlucHV0U2hhcGUubWFwKGZ1bmN0aW9uIChzaGFwZSkgeyByZXR1cm4gc2hhcGUubGVuZ3RoOyB9KTtcbiAgICAgICAgaWYgKGlucHV0U2hhcGUuaW5kZXhPZihudWxsKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMudW5pcXVlKGFsbFJhbmtzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaGFwZVJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2hhcGVSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXNoYXBlUmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzaGFwZWRJbnB1dHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXREaW1zID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0LnJhbms7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dERpbXMuaW5kZXhPZihudWxsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heE5EaW0gPSBtYXRoVXRpbHMubWF4KGlucHV0RGltcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRzXzEgPSBpbnB1dHM7IF9pIDwgaW5wdXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGlucHV0c18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4TkRpbSA9IHgucmFuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWF4TkRpbSAtIHhORGltOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gSy5leHBhbmREaW1zKHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaGFwZWRJbnB1dHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWVyZ2VGdW5jdGlvbihyZXNoYXBlZElucHV0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNwb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGlucHV0c18yID0gaW5wdXRzOyBfYSA8IGlucHV0c18yLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBpbnB1dHNfMltfYV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeE5EaW0gPSB4LnJhbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeE5EaW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4U2hhcGUgPSBLLnNoYXBlKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSB4U2hhcGVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0geFNoYXBlLnNsaWNlKDEpLmNvbmNhdChbYmF0Y2hTaXplXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhUcmFuc3Bvc2VkID0geC5yZXNoYXBlKFtiYXRjaFNpemVdLmNvbmNhdChtYXRoVXRpbHMuYXJyYXlQcm9kKHhTaGFwZS5zbGljZSgxKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4VHJhbnNwb3NlZCA9IHRmYy50cmFuc3Bvc2UoeFRyYW5zcG9zZWQsIFsxLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFRyYW5zcG9zZWQgPSB4VHJhbnNwb3NlZC5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNoYXBlZElucHV0cy5wdXNoKHhUcmFuc3Bvc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhORGltID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaW1zID0gbWF0aFV0aWxzLnJhbmdlKDEsIHhORGltKS5jb25jYXQoWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNoYXBlZElucHV0cy5wdXNoKHRmYy50cmFuc3Bvc2UoeCwgZGltcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaGFwZWRJbnB1dHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IF90aGlzLm1lcmdlRnVuY3Rpb24ocmVzaGFwZWRJbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeU5EaW0gPSB5LnJhbms7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeU5EaW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5U2hhcGUgPSBLLnNoYXBlKHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5TkRpbV8xID0geVNoYXBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2hTaXplID0geVNoYXBlW3lORGltXzEgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBbYmF0Y2hTaXplXS5jb25jYXQoeVNoYXBlLnNsaWNlKDAsIHlTaGFwZS5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRmYy50cmFuc3Bvc2UoeS5yZXNoYXBlKFstMSwgYmF0Y2hTaXplXSksIFsxLCAwXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeU5EaW0gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbXMgPSBbeU5EaW0gLSAxXS5jb25jYXQobWF0aFV0aWxzLnJhbmdlKDAsIHlORGltIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0ZmMudHJhbnNwb3NlKHksIGRpbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tZXJnZUZ1bmN0aW9uKGlucHV0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWVyZ2UucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGU7XG4gICAgICAgIGlmIChpbnB1dFNoYXBlWzBdID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZVswXS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGlucHV0U2hhcGVbaV0gPT0gbnVsbCA/IG51bGwgOiBpbnB1dFNoYXBlW2ldLnNsaWNlKDEpO1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSB0aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUob3V0cHV0U2hhcGUsIHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmF0Y2hTaXplcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0U2hhcGVfMiA9IGlucHV0U2hhcGU7IF9pIDwgaW5wdXRTaGFwZV8yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gaW5wdXRTaGFwZV8yW19pXTtcbiAgICAgICAgICAgIGlmIChzaGFwZSAhPSBudWxsICYmIHNoYXBlWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplcy5wdXNoKHNoYXBlWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiYXRjaFNpemVzID0gZ2VuZXJpY191dGlscy51bmlxdWUoYmF0Y2hTaXplcyk7XG4gICAgICAgIGlmIChiYXRjaFNpemVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSBiYXRjaFNpemVzLmNvbmNhdChvdXRwdXRTaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IFtudWxsXS5jb25jYXQob3V0cHV0U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJnZTtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5NZXJnZSA9IE1lcmdlO1xudmFyIEFkZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGQoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgfVxuICAgIEFkZC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRmYy56ZXJvcyhpbnB1dHNbMF0uc2hhcGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dHNfMyA9IGlucHV0czsgX2kgPCBpbnB1dHNfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfM1tfaV07XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGZjLmFkZChvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWRkLmNsYXNzTmFtZSA9ICdBZGQnO1xuICAgIHJldHVybiBBZGQ7XG59KE1lcmdlKSk7XG5leHBvcnRzLkFkZCA9IEFkZDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihBZGQpO1xuZnVuY3Rpb24gYWRkKGNvbmZpZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbmV3IEFkZCh7fSk7XG4gICAgICAgIHJldHVybiBsYXllci5hcHBseShjb25maWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGQoY29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLmFkZCA9IGFkZDtcbnZhciBNdWx0aXBseSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11bHRpcGx5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11bHRpcGx5KGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNdWx0aXBseS5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRmYy5vbmVzKGlucHV0c1swXS5zaGFwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c180ID0gaW5wdXRzOyBfaSA8IGlucHV0c180Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c180W19pXTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0ZmMubXVsKG91dHB1dCwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNdWx0aXBseS5jbGFzc05hbWUgPSAnTXVsdGlwbHknO1xuICAgIHJldHVybiBNdWx0aXBseTtcbn0oTWVyZ2UpKTtcbmV4cG9ydHMuTXVsdGlwbHkgPSBNdWx0aXBseTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihNdWx0aXBseSk7XG5mdW5jdGlvbiBtdWx0aXBseShjb25maWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBNdWx0aXBseSh7fSk7XG4gICAgICAgIHJldHVybiBsYXllci5hcHBseShjb25maWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aXBseShjb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbnZhciBBdmVyYWdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXZlcmFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdmVyYWdlKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBdmVyYWdlLnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGZjLnplcm9zKGlucHV0c1swXS5zaGFwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c181ID0gaW5wdXRzOyBfaSA8IGlucHV0c181Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c181W19pXTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0ZmMuYWRkKG91dHB1dCwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEsuc2NhbGFyVGltZXNBcnJheShLLmdldFNjYWxhcigxIC8gaW5wdXRzLmxlbmd0aCksIG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXZlcmFnZS5jbGFzc05hbWUgPSAnQXZlcmFnZSc7XG4gICAgcmV0dXJuIEF2ZXJhZ2U7XG59KE1lcmdlKSk7XG5leHBvcnRzLkF2ZXJhZ2UgPSBBdmVyYWdlO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEF2ZXJhZ2UpO1xuZnVuY3Rpb24gYXZlcmFnZShjb25maWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBBdmVyYWdlKHt9KTtcbiAgICAgICAgcmV0dXJuIGxheWVyLmFwcGx5KGNvbmZpZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEF2ZXJhZ2UoY29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLmF2ZXJhZ2UgPSBhdmVyYWdlO1xudmFyIE1heGltdW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhpbXVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heGltdW0oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1heGltdW0ucHJvdG90eXBlLm1lcmdlRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBpbnB1dHNbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRmYy5tYXhpbXVtKG91dHB1dCwgaW5wdXRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF4aW11bS5jbGFzc05hbWUgPSAnTWF4aW11bSc7XG4gICAgcmV0dXJuIE1heGltdW07XG59KE1lcmdlKSk7XG5leHBvcnRzLk1heGltdW0gPSBNYXhpbXVtO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKE1heGltdW0pO1xuZnVuY3Rpb24gbWF4aW11bShjb25maWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBNYXhpbXVtKHt9KTtcbiAgICAgICAgcmV0dXJuIGxheWVyLmFwcGx5KGNvbmZpZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IE1heGltdW0oY29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLm1heGltdW0gPSBtYXhpbXVtO1xudmFyIE1pbmltdW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNaW5pbXVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1pbmltdW0oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1pbmltdW0ucHJvdG90eXBlLm1lcmdlRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBpbnB1dHNbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRmYy5taW5pbXVtKG91dHB1dCwgaW5wdXRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWluaW11bS5jbGFzc05hbWUgPSAnTWluaW11bSc7XG4gICAgcmV0dXJuIE1pbmltdW07XG59KE1lcmdlKSk7XG5leHBvcnRzLk1pbmltdW0gPSBNaW5pbXVtO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKE1pbmltdW0pO1xuZnVuY3Rpb24gbWluaW11bShjb25maWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBNaW5pbXVtKHt9KTtcbiAgICAgICAgcmV0dXJuIGxheWVyLmFwcGx5KGNvbmZpZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IE1pbmltdW0oY29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLm1pbmltdW0gPSBtaW5pbXVtO1xudmFyIENvbmNhdGVuYXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2F0ZW5hdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uY2F0ZW5hdGUoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9BWElTID0gLTE7XG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYXhpcyA9IGNvbmZpZy5heGlzID09IG51bGwgPyBfdGhpcy5ERUZBVUxUX0FYSVMgOiBjb25maWcuYXhpcztcbiAgICAgICAgX3RoaXMuc3VwcG9ydHNNYXNraW5nID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucmVzaGFwZVJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0ZW5hdGUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlKSAmJiBBcnJheS5pc0FycmF5KGlucHV0U2hhcGVbMF0pKSB8fFxuICAgICAgICAgICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgYXQgbGVhc3QgMiAnICtcbiAgICAgICAgICAgICAgICAnaW5wdXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgICAgIHZhciBhbGxOb25lU2hhcGUgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0U2hhcGVfMyA9IGlucHV0U2hhcGU7IF9pIDwgaW5wdXRTaGFwZV8zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gaW5wdXRTaGFwZV8zW19pXTtcbiAgICAgICAgICAgIGlmIChzaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsTm9uZVNoYXBlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbE5vbmVTaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFwZVNldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZVdpdGhvdXRDb25jYXRBeGlzID0gaW5wdXRTaGFwZVtpXS5zbGljZSgpO1xuICAgICAgICAgICAgc2hhcGVXaXRob3V0Q29uY2F0QXhpcy5zcGxpY2UodGhpcy5heGlzLCAxKTtcbiAgICAgICAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgc2hhcGVTZXRfMSA9IHNoYXBlU2V0OyBfYSA8IHNoYXBlU2V0XzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVTZXRfMVtfYV07XG4gICAgICAgICAgICAgICAgaWYgKHRmanNfY29yZV8xLnV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHNoYXBlV2l0aG91dENvbmNhdEF4aXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVTZXQucHVzaChzaGFwZVdpdGhvdXRDb25jYXRBeGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVTZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0EgYENvbmNhdGVuYXRlYCBsYXllciByZXF1aXJlcyBpbnB1dHMgd2l0aCBtYXRjaGluZyBzaGFwZXMgJyArXG4gICAgICAgICAgICAgICAgJ2V4Y2VwdCBmb3IgdGhlIGNvbmNhdCBheGlzLiBHb3QgaW5wdXQgc2hhcGVzOiAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbmNhdGVuYXRlLnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSy5jb25jYXRlbmF0ZShpbnB1dHMsIF90aGlzLmF4aXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbmNhdGVuYXRlLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGlucHV0U2hhcGUpICYmIEFycmF5LmlzQXJyYXkoaW5wdXRTaGFwZVswXSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGlucHV0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRTaGFwZXMgPSBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlc1swXS5zbGljZSgpO1xuICAgICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyA8IDAgPyBvdXRwdXRTaGFwZS5sZW5ndGggKyB0aGlzLmF4aXMgOiB0aGlzLmF4aXM7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBpbnB1dFNoYXBlcy5zbGljZSgxKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChvdXRwdXRTaGFwZVtheGlzXSA9PSBudWxsIHx8IHNoYXBlW2F4aXNdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtheGlzXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtheGlzXSArPSBzaGFwZVtheGlzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgfTtcbiAgICBDb25jYXRlbmF0ZS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgJ2F4aXMnOiB0aGlzLmF4aXMsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgQ29uY2F0ZW5hdGUuY2xhc3NOYW1lID0gJ0NvbmNhdGVuYXRlJztcbiAgICByZXR1cm4gQ29uY2F0ZW5hdGU7XG59KE1lcmdlKSk7XG5leHBvcnRzLkNvbmNhdGVuYXRlID0gQ29uY2F0ZW5hdGU7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoQ29uY2F0ZW5hdGUpO1xuZnVuY3Rpb24gY29uY2F0ZW5hdGUoY29uZmlnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgQ29uY2F0ZW5hdGUoe30pO1xuICAgICAgICByZXR1cm4gbGF5ZXIuYXBwbHkoY29uZmlnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uY2F0ZW5hdGUoY29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbmNhdGVuYXRlID0gY29uY2F0ZW5hdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgY29uc3RyYWludHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHJhaW50c1wiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4uL2VuZ2luZS90b3BvbG9neVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi4vaW5pdGlhbGl6ZXJzXCIpO1xudmFyIHJlZ3VsYXJpemVyc18xID0gcmVxdWlyZShcIi4uL3JlZ3VsYXJpemVyc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgbWF0aF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9tYXRoX3V0aWxzXCIpO1xuZnVuY3Rpb24gYmF0Y2hOb3JtYWxpemF0aW9uKHgsIG1lYW4sIHZhcmlhbmNlLCBiZXRhLCBnYW1tYSwgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTM7IH1cbiAgICB2YXIgb3V0O1xuICAgIGlmICh4LnJhbmsgPT09IDIpIHtcbiAgICAgICAgb3V0ID0gdGZjLmJhdGNoTm9ybWFsaXphdGlvbjJkKHgsIG1lYW4sIHZhcmlhbmNlLCBlcHNpbG9uLCBnYW1tYSwgYmV0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICBvdXQgPSB0ZmMuYmF0Y2hOb3JtYWxpemF0aW9uM2QoeCwgbWVhbiwgdmFyaWFuY2UsIGVwc2lsb24sIGdhbW1hLCBiZXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeC5yYW5rID09PSA0KSB7XG4gICAgICAgIG91dCA9IHRmYy5iYXRjaE5vcm1hbGl6YXRpb240ZCh4LCBtZWFuLCB2YXJpYW5jZSwgZXBzaWxvbiwgZ2FtbWEsIGJldGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJiYXRjaE5vcm1hbGl6YXRpb24gaXMgbm90IGltcGxlbWVtbnRlZCBmb3IgYXJyYXkgb2YgcmFuayBcIiArIHgucmFuayArIFwiIFwiICtcbiAgICAgICAgICAgIFwieWV0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy5iYXRjaE5vcm1hbGl6YXRpb24gPSBiYXRjaE5vcm1hbGl6YXRpb247XG5mdW5jdGlvbiByZWd1bGFyTm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKHgsIGdhbW1hLCBiZXRhLCByZWR1Y3Rpb25BeGVzLCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtMzsgfVxuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lYW5BbmRWYXJpYW5jZSA9IHRmYy5tb21lbnRzKHgsIHJlZHVjdGlvbkF4ZXMpO1xuICAgICAgICB2YXIgbWVhbiA9IG1lYW5BbmRWYXJpYW5jZS5tZWFuO1xuICAgICAgICB2YXIgdmFyaWFuY2UgPSBtZWFuQW5kVmFyaWFuY2UudmFyaWFuY2U7XG4gICAgICAgIHZhciBub3JtZWQgPSBiYXRjaE5vcm1hbGl6YXRpb24oeCwgbWVhbiwgdmFyaWFuY2UsIGJldGEsIGdhbW1hLCBlcHNpbG9uKTtcbiAgICAgICAgcmV0dXJuIFtub3JtZWQsIG1lYW4sIHZhcmlhbmNlXTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJyb2FkY2FzdE5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyh4LCBnYW1tYSwgYmV0YSwgcmVkdWN0aW9uQXhlcywgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTM7IH1cbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWFuQW5kVmFyaWFuY2UgPSB0ZmMubW9tZW50cyh4LCByZWR1Y3Rpb25BeGVzKTtcbiAgICAgICAgdmFyIG1lYW4gPSBtZWFuQW5kVmFyaWFuY2UubWVhbjtcbiAgICAgICAgdmFyIHZhcmlhbmNlID0gbWVhbkFuZFZhcmlhbmNlLnZhcmlhbmNlO1xuICAgICAgICB2YXIgdGFyZ2V0U2hhcGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG1hdGhfdXRpbHMucmFuZ2UoMCwgeC5yYW5rKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKHJlZHVjdGlvbkF4ZXMuaW5kZXhPZihheGlzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTaGFwZS5wdXNoKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2hhcGUucHVzaCh4LnNoYXBlW2F4aXNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYnJvYWRjYXN0TWVhbiA9IG1lYW4ucmVzaGFwZSh0YXJnZXRTaGFwZSk7XG4gICAgICAgIHZhciBicm9hZGNhc3RWYXJpYW5jZSA9IHZhcmlhbmNlLnJlc2hhcGUodGFyZ2V0U2hhcGUpO1xuICAgICAgICB2YXIgYnJvYWRjYXN0R2FtbWEgPSBnYW1tYSA9PSBudWxsID8gbnVsbCA6IGdhbW1hLnJlc2hhcGUodGFyZ2V0U2hhcGUpO1xuICAgICAgICB2YXIgYnJvYWRjYXN0QmV0YSA9IGJldGEgPT0gbnVsbCA/IG51bGwgOiBiZXRhLnJlc2hhcGUodGFyZ2V0U2hhcGUpO1xuICAgICAgICB2YXIgbm9ybWVkID0gYmF0Y2hOb3JtYWxpemF0aW9uKHgsIGJyb2FkY2FzdE1lYW4sIGJyb2FkY2FzdFZhcmlhbmNlLCBicm9hZGNhc3RCZXRhLCBicm9hZGNhc3RHYW1tYSwgZXBzaWxvbik7XG4gICAgICAgIHJldHVybiBbbm9ybWVkLCBtZWFuLCB2YXJpYW5jZV07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVCYXRjaEluVHJhaW5pbmcoeCwgZ2FtbWEsIGJldGEsIHJlZHVjdGlvbkF4ZXMsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS0zOyB9XG4gICAgaWYgKHRmanNfY29yZV8xLnV0aWwuYXJyYXlzRXF1YWwocmVkdWN0aW9uQXhlcy5zbGljZSgpLnNvcnQoKSwgbWF0aF91dGlscy5yYW5nZSgwLCB4LnJhbmsgLSAxKSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZ3VsYXJOb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoeCwgZ2FtbWEsIGJldGEsIHJlZHVjdGlvbkF4ZXMsIGVwc2lsb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJyb2FkY2FzdE5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyh4LCBnYW1tYSwgYmV0YSwgcmVkdWN0aW9uQXhlcywgZXBzaWxvbik7XG4gICAgfVxufVxuZXhwb3J0cy5ub3JtYWxpemVCYXRjaEluVHJhaW5pbmcgPSBub3JtYWxpemVCYXRjaEluVHJhaW5pbmc7XG52YXIgQmF0Y2hOb3JtYWxpemF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmF0Y2hOb3JtYWxpemF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhdGNoTm9ybWFsaXphdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5heGlzID0gY29uZmlnLmF4aXMgPT0gbnVsbCA/IC0xIDogY29uZmlnLmF4aXM7XG4gICAgICAgIF90aGlzLm1vbWVudHVtID0gY29uZmlnLm1vbWVudHVtID09IG51bGwgPyAwLjk5IDogY29uZmlnLm1vbWVudHVtO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gY29uZmlnLmVwc2lsb24gPT0gbnVsbCA/IDFlLTMgOiBjb25maWcuZXBzaWxvbjtcbiAgICAgICAgX3RoaXMuY2VudGVyID0gY29uZmlnLmNlbnRlciA9PSBudWxsID8gdHJ1ZSA6IGNvbmZpZy5jZW50ZXI7XG4gICAgICAgIF90aGlzLnNjYWxlID0gY29uZmlnLnNjYWxlID09IG51bGwgPyB0cnVlIDogY29uZmlnLnNjYWxlO1xuICAgICAgICBfdGhpcy5iZXRhSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcuYmV0YUluaXRpYWxpemVyIHx8ICd6ZXJvcycpO1xuICAgICAgICBfdGhpcy5nYW1tYUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmdhbW1hSW5pdGlhbGl6ZXIgfHwgJ29uZXMnKTtcbiAgICAgICAgX3RoaXMubW92aW5nTWVhbkluaXRpYWxpemVyID1cbiAgICAgICAgICAgIGluaXRpYWxpemVyc18xLmdldEluaXRpYWxpemVyKGNvbmZpZy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIgfHwgJ3plcm9zJyk7XG4gICAgICAgIF90aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIgPVxuICAgICAgICAgICAgaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIgfHwgJ29uZXMnKTtcbiAgICAgICAgX3RoaXMuYmV0YUNvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLmJldGFDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMuZ2FtbWFDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5nYW1tYUNvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5iZXRhUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcuYmV0YVJlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMuZ2FtbWFSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5nYW1tYVJlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMuc3RlcENvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCYXRjaE5vcm1hbGl6YXRpb24ucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyA+PSAwID8gdGhpcy5heGlzIDogKHRoaXMuYXhpcyArIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgICAgdmFyIGRpbSA9IGlucHV0U2hhcGVbYXhpc107XG4gICAgICAgIGlmIChkaW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJBeGlzIFwiICsgYXhpcyArIFwiIG9mIGlucHV0IHRlbnNvciBzaG91bGQgaGF2ZSBhIGRlZmluZWQgZGltZW5zaW9uIGJ1dCBcIiArXG4gICAgICAgICAgICAgICAgXCJ0aGUgbGF5ZXIgcmVjZWl2ZWQgYW4gaW5wdXQgd2l0aCBzaGFwZSBcIiArXG4gICAgICAgICAgICAgICAgKEpTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0U3BlYyA9XG4gICAgICAgICAgICBbbmV3IHRvcG9sb2d5XzEuSW5wdXRTcGVjKHsgbmRpbTogaW5wdXRTaGFwZS5sZW5ndGgsIGF4ZXM6IChfYSA9IHt9LCBfYVtheGlzXSA9IGRpbSwgX2EpIH0pXTtcbiAgICAgICAgdmFyIHNoYXBlID0gW2RpbV07XG4gICAgICAgIGlmICh0aGlzLnNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmdhbW1hID0gdGhpcy5hZGRXZWlnaHQoJ2dhbW1hJywgc2hhcGUsIG51bGwsIHRoaXMuZ2FtbWFJbml0aWFsaXplciwgdGhpcy5nYW1tYVJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmdhbW1hQ29uc3RyYWludCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICB0aGlzLmJldGEgPSB0aGlzLmFkZFdlaWdodCgnYmV0YScsIHNoYXBlLCBudWxsLCB0aGlzLmJldGFJbml0aWFsaXplciwgdGhpcy5iZXRhUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmV0YUNvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92aW5nTWVhbiA9IHRoaXMuYWRkV2VpZ2h0KCdtb3ZpbmdfbWVhbicsIHNoYXBlLCBudWxsLCB0aGlzLm1vdmluZ01lYW5Jbml0aWFsaXplciwgbnVsbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1vdmluZ1ZhcmlhbmNlID0gdGhpcy5hZGRXZWlnaHQoJ21vdmluZ192YXJpYW5jZScsIHNoYXBlLCBudWxsLCB0aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIEJhdGNoTm9ybWFsaXphdGlvbi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHJhaW5pbmcgPSBrd2FyZ3NbJ3RyYWluaW5nJ10gPT0gbnVsbCA/IGZhbHNlIDoga3dhcmdzWyd0cmFpbmluZyddO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IEsuc2hhcGUoaW5wdXQpO1xuICAgICAgICAgICAgdmFyIG5kaW0gPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciByZWR1Y3Rpb25BeGVzID0gbWF0aF91dGlscy5yYW5nZSgwLCBuZGltKTtcbiAgICAgICAgICAgIHZhciBheGlzID0gX3RoaXMuYXhpcyA+PSAwID8gX3RoaXMuYXhpcyA6IChfdGhpcy5heGlzICsgbmRpbSk7XG4gICAgICAgICAgICByZWR1Y3Rpb25BeGVzLnNwbGljZShheGlzLCAxKTtcbiAgICAgICAgICAgIHZhciBicm9hZGNhc3RTaGFwZSA9IGdlbmVyaWNfdXRpbHMucHlMaXN0UmVwZWF0KDEsIG5kaW0pO1xuICAgICAgICAgICAgYnJvYWRjYXN0U2hhcGVbYXhpc10gPSBpbnB1dFNoYXBlW2F4aXNdO1xuICAgICAgICAgICAgdmFyIHNvcnRlZFJlZHVjdGlvbkF4ZXMgPSByZWR1Y3Rpb25BeGVzLnNsaWNlKCk7XG4gICAgICAgICAgICBzb3J0ZWRSZWR1Y3Rpb25BeGVzLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciBuZWVkc0Jyb2FkY2FzdGluZyA9ICF0ZmpzX2NvcmVfMS51dGlsLmFycmF5c0VxdWFsKHNvcnRlZFJlZHVjdGlvbkF4ZXMsIG1hdGhfdXRpbHMucmFuZ2UoMCwgbmRpbSkuc2xpY2UoMCwgbmRpbSAtIDEpKTtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVJbmZlcmVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzQnJvYWRjYXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBicm9hZGNhc3RNb3ZpbmdNZWFuID0gX3RoaXMubW92aW5nTWVhbi5yZWFkKCkucmVzaGFwZShicm9hZGNhc3RTaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBicm9hZGNhc3RNb3ZpbmdWYXJpYW5jZSA9IF90aGlzLm1vdmluZ1ZhcmlhbmNlLnJlYWQoKS5yZXNoYXBlKGJyb2FkY2FzdFNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJyb2FkY2FzdEJldGEgPSBfdGhpcy5jZW50ZXIgPyBfdGhpcy5iZXRhLnJlYWQoKS5yZXNoYXBlKGJyb2FkY2FzdFNoYXBlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBicm9hZGNhc3RHYW1tYSA9IF90aGlzLnNjYWxlID8gX3RoaXMuZ2FtbWEucmVhZCgpLnJlc2hhcGUoYnJvYWRjYXN0U2hhcGUpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoTm9ybWFsaXphdGlvbihpbnB1dCwgYnJvYWRjYXN0TW92aW5nTWVhbiwgYnJvYWRjYXN0TW92aW5nVmFyaWFuY2UsIGJyb2FkY2FzdEJldGEsIGJyb2FkY2FzdEdhbW1hLCBfdGhpcy5lcHNpbG9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaE5vcm1hbGl6YXRpb24oaW5wdXQsIF90aGlzLm1vdmluZ01lYW4ucmVhZCgpLCBfdGhpcy5tb3ZpbmdWYXJpYW5jZS5yZWFkKCksIF90aGlzLmJldGEgPT0gbnVsbCA/IG51bGwgOiBfdGhpcy5iZXRhLnJlYWQoKSwgX3RoaXMuZ2FtbWEgPT0gbnVsbCA/IG51bGwgOiBfdGhpcy5nYW1tYS5yZWFkKCksIF90aGlzLmVwc2lsb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRyYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUluZmVyZW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gbm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGlucHV0LCBfdGhpcy5nYW1tYS5yZWFkKCksIF90aGlzLmJldGEucmVhZCgpLCByZWR1Y3Rpb25BeGVzLCBfdGhpcy5lcHNpbG9uKSwgbm9ybWVkVHJhaW5pbmcgPSBfYVswXSwgbWVhbiA9IF9hWzFdLCB2YXJpYW5jZSA9IF9hWzJdO1xuICAgICAgICAgICAgdmFyIHNhbXBsZVNpemUgPSBtYXRoX3V0aWxzLmFycmF5UHJvZChyZWR1Y3Rpb25BeGVzLm1hcChmdW5jdGlvbiAoYXhpcykgeyByZXR1cm4gaW5wdXQuc2hhcGVbYXhpc107IH0pKTtcbiAgICAgICAgICAgIHZhciB2YXJpYW5jZURlYmlhc2VkID0gdmFyaWFuY2UubXVsKEsuZ2V0U2NhbGFyKHNhbXBsZVNpemUgLyAoc2FtcGxlU2l6ZSAtICgxICsgX3RoaXMuZXBzaWxvbikpKSk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlTW92aW5nTWVhbkFuZFZhcmlhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0ZXBDb3VudCsrO1xuICAgICAgICAgICAgICAgIHZhciBuZXdNb3ZpbmdNZWFuID0gdGZjLm1vdmluZ0F2ZXJhZ2UoX3RoaXMubW92aW5nTWVhbi5yZWFkKCksIG1lYW4sIF90aGlzLm1vbWVudHVtLCBfdGhpcy5zdGVwQ291bnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLm1vdmluZ01lYW4ud3JpdGUobmV3TW92aW5nTWVhbik7XG4gICAgICAgICAgICAgICAgdmFyIG5ld01vdmluZ1ZhcmlhbmNlID0gdGZjLm1vdmluZ0F2ZXJhZ2UoX3RoaXMubW92aW5nVmFyaWFuY2UucmVhZCgpLCB2YXJpYW5jZURlYmlhc2VkLCBfdGhpcy5tb21lbnR1bSwgX3RoaXMuc3RlcENvdW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3ZpbmdWYXJpYW5jZS53cml0ZShuZXdNb3ZpbmdWYXJpYW5jZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXBkYXRlTW92aW5nTWVhbkFuZFZhcmlhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWVkVHJhaW5pbmc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmF0Y2hOb3JtYWxpemF0aW9uLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBheGlzOiB0aGlzLmF4aXMsXG4gICAgICAgICAgICBtb21lbnR1bTogdGhpcy5tb21lbnR1bSxcbiAgICAgICAgICAgIGVwc2lsb246IHRoaXMuZXBzaWxvbixcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXIsXG4gICAgICAgICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgICAgICAgIGJldGFJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iZXRhSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgZ2FtbWFJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5nYW1tYUluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIG1vdmluZ01lYW5Jbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgbW92aW5nVmFyaWFuY2VJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGJldGFSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iZXRhUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgZ2FtbWFSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5nYW1tYVJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGJldGFDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iZXRhQ29uc3RyYWludCksXG4gICAgICAgICAgICBnYW1tYUNvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmdhbW1hQ29uc3RyYWludClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBCYXRjaE5vcm1hbGl6YXRpb24uY2xhc3NOYW1lID0gJ0JhdGNoTm9ybWFsaXphdGlvbic7XG4gICAgcmV0dXJuIEJhdGNoTm9ybWFsaXphdGlvbjtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5CYXRjaE5vcm1hbGl6YXRpb24gPSBCYXRjaE5vcm1hbGl6YXRpb247XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoQmF0Y2hOb3JtYWxpemF0aW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6YXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9iYWNrZW5kL2NvbW1vblwiKTtcbnZhciB0b3BvbG9neV8xID0gcmVxdWlyZShcIi4uL2VuZ2luZS90b3BvbG9neVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG5mdW5jdGlvbiB0ZW1wb3JhbFBhZGRpbmcoeCwgcGFkZGluZykge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHgucmFuayAhPT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJ0ZW1wb3JhbFBhZGRpbmcgZXhwZWN0cyBpbnB1dCB0ZW5zb3IgdG8gYmUgMy1ELCBidXQgcmVjZWl2ZWQgYSBcIiArXG4gICAgICAgICAgICAgICAgKHgucmFuayArIFwiLUQgdGVuc29yLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFkZGluZyA9IFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGluZy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwidGVtcG9yYWxQYWRkaW5nIGV4cGVjdHMgaW5wdXQgcGFkZGluZyBwYXR0ZXJuIHRvIGJlIGEgbGVuZ3RoLTIgXCIgK1xuICAgICAgICAgICAgICAgIChcImFycmF5LCBidXQgcmVjZWl2ZWQgYSBsZW5ndGgtXCIgKyBwYWRkaW5nLmxlbmd0aCArIFwiIGFycmF5LlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdHRlcm4gPSBbWzAsIDBdLCBwYWRkaW5nLCBbMCwgMF1dO1xuICAgICAgICByZXR1cm4gdGZjLnBhZCh4LCBwYXR0ZXJuKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMudGVtcG9yYWxQYWRkaW5nID0gdGVtcG9yYWxQYWRkaW5nO1xuZnVuY3Rpb24gc3BhdGlhbDJkUGFkZGluZyh4LCBwYWRkaW5nLCBkYXRhRm9ybWF0KSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeC5yYW5rICE9PSA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcInRlbXBvcmFsUGFkZGluZyBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSA0LUQsIGJ1dCByZWNlaXZlZCBhIFwiICtcbiAgICAgICAgICAgICAgICAoeC5yYW5rICsgXCItRCB0ZW5zb3IuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gW1sxLCAxXSwgWzEsIDFdXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGluZy5sZW5ndGggIT09IDIgfHwgcGFkZGluZ1swXS5sZW5ndGggIT09IDIgfHxcbiAgICAgICAgICAgIHBhZGRpbmdbMV0ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignc3BhdGlhbDJkUGFkZGluZyBleHBlY3RzIGBwYWRkaW5nYCB0byBiZSBhbiBBcnJheSBvZiB0d28gQXJyYXlzLCAnICtcbiAgICAgICAgICAgICAgICAnZWFjaCBvZiB3aGljaCBpcyBhbiBBcnJheSBvZiB0d28gaW50ZWdlcnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YUZvcm1hdCA9IGNvbW1vbl8xLmltYWdlRGF0YUZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ICE9PSAnY2hhbm5lbHNMYXN0JyAmJiBkYXRhRm9ybWF0ICE9PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVW5rbm93biBkYXRhIGZvcm1hdDogXCIgKyBkYXRhRm9ybWF0ICsgXCIuIFwiICtcbiAgICAgICAgICAgICAgICBcIlN1cHBvcnRlZCBkYXRhIGZvcm1hdHMgYXJlICdjaGFubmVsc0xhc3QnIGFuZCAnY2hhbm5lbHNGaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdHRlcm47XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBbWzAsIDBdLCBbMCwgMF0sIHBhZGRpbmdbMF0sIHBhZGRpbmdbMV1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0dGVybiA9IFtbMCwgMF0sIHBhZGRpbmdbMF0sIHBhZGRpbmdbMV0sIFswLCAwXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRmYy5wYWQoeCwgcGF0dGVybik7XG4gICAgfSk7XG59XG5leHBvcnRzLnNwYXRpYWwyZFBhZGRpbmcgPSBzcGF0aWFsMmRQYWRkaW5nO1xudmFyIFplcm9QYWRkaW5nMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaZXJvUGFkZGluZzJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFplcm9QYWRkaW5nMkQoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICAgICAgY29uZmlnLmRhdGFGb3JtYXQgPT0gbnVsbCA/IGNvbW1vbl8xLmltYWdlRGF0YUZvcm1hdCgpIDogY29uZmlnLmRhdGFGb3JtYXQ7XG4gICAgICAgIGlmIChjb25maWcucGFkZGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5wYWRkaW5nID0gW1sxLCAxXSwgWzEsIDFdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlnLnBhZGRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBfdGhpcy5wYWRkaW5nID1cbiAgICAgICAgICAgICAgICBbW2NvbmZpZy5wYWRkaW5nLCBjb25maWcucGFkZGluZ10sIFtjb25maWcucGFkZGluZywgY29uZmlnLnBhZGRpbmddXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5wYWRkaW5nID0gY29uZmlnLnBhZGRpbmc7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnBhZGRpbmcubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJaZXJvUGFkZGluZzJEIGV4cGVjdHMgcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBidXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJyZWNlaXZlZCBhIGxlbmd0aC1cIiArIGNvbmZpZy5wYWRkaW5nLmxlbmd0aCArIFwiIGFycmF5LlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGVpZ2h0UGFkZGluZyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciB3aWR0aFBhZGRpbmcgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5wYWRkaW5nWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGhlaWdodFBhZGRpbmcgPVxuICAgICAgICAgICAgICAgICAgICBbY29uZmlnLnBhZGRpbmdbMF0sIGNvbmZpZy5wYWRkaW5nWzBdXTtcbiAgICAgICAgICAgICAgICB3aWR0aFBhZGRpbmcgPVxuICAgICAgICAgICAgICAgICAgICBbY29uZmlnLnBhZGRpbmdbMV0sIGNvbmZpZy5wYWRkaW5nWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wYWRkaW5nID0gY29uZmlnLnBhZGRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5wYWRkaW5nWzBdLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlplcm9QYWRkaW5nMkQgZXhwZWN0cyBoZWlnaHQgcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJidXQgcmVjZWl2ZWQgYSBsZW5ndGgtXCIgKyBjb25maWcucGFkZGluZ1swXS5sZW5ndGggKyBcIiBhcnJheS5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZWlnaHRQYWRkaW5nID0gY29uZmlnLnBhZGRpbmdbMF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5wYWRkaW5nWzFdLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlplcm9QYWRkaW5nMkQgZXhwZWN0cyB3aWR0aCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIiArIGNvbmZpZy5wYWRkaW5nWzFdLmxlbmd0aCArIFwiIGFycmF5LlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpZHRoUGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucGFkZGluZyA9IFtoZWlnaHRQYWRkaW5nLCB3aWR0aFBhZGRpbmddO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFtuZXcgdG9wb2xvZ3lfMS5JbnB1dFNwZWMoeyBuZGltOiA0IH0pXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBaZXJvUGFkZGluZzJELnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlsc18xLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgdmFyIHJvd3M7XG4gICAgICAgIHZhciBjb2xzO1xuICAgICAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dFNoYXBlWzJdICE9IG51bGwgJiYgaW5wdXRTaGFwZVsyXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcm93cyA9IGlucHV0U2hhcGVbMl0gKyB0aGlzLnBhZGRpbmdbMF1bMF0gKyB0aGlzLnBhZGRpbmdbMF1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3dzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dFNoYXBlWzNdICE9IG51bGwgJiYgaW5wdXRTaGFwZVszXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29scyA9IGlucHV0U2hhcGVbM10gKyB0aGlzLnBhZGRpbmdbMV1bMF0gKyB0aGlzLnBhZGRpbmdbMV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsxXSwgcm93cywgY29sc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW5wdXRTaGFwZVsxXSAhPSBudWxsICYmIGlucHV0U2hhcGVbMV0gPj0gMCkge1xuICAgICAgICAgICAgICAgIHJvd3MgPSBpbnB1dFNoYXBlWzFdICsgdGhpcy5wYWRkaW5nWzBdWzBdICsgdGhpcy5wYWRkaW5nWzBdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRTaGFwZVsyXSAhPSBudWxsICYmIGlucHV0U2hhcGVbMl0gPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbHMgPSBpbnB1dFNoYXBlWzJdICsgdGhpcy5wYWRkaW5nWzFdWzBdICsgdGhpcy5wYWRkaW5nWzFdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29scyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIHJvd3MsIGNvbHMsIGlucHV0U2hhcGVbM11dO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaZXJvUGFkZGluZzJELnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwYXRpYWwyZFBhZGRpbmcoZ2VuZXJpY191dGlsc18xLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKSwgX3RoaXMucGFkZGluZywgX3RoaXMuZGF0YUZvcm1hdCk7IH0pO1xuICAgIH07XG4gICAgWmVyb1BhZGRpbmcyRC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxuICAgICAgICAgICAgZGF0YUZvcm1hdDogdGhpcy5kYXRhRm9ybWF0LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIFplcm9QYWRkaW5nMkQuY2xhc3NOYW1lID0gJ1plcm9QYWRkaW5nMkQnO1xuICAgIHJldHVybiBaZXJvUGFkZGluZzJEO1xufSh0b3BvbG9neV8xLkxheWVyKSk7XG5leHBvcnRzLlplcm9QYWRkaW5nMkQgPSBaZXJvUGFkZGluZzJEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFplcm9QYWRkaW5nMkQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFkZGluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvY29tbW9uXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgY29tbW9uXzIgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIHRvcG9sb2d5XzIgPSByZXF1aXJlKFwiLi4vZW5naW5lL3RvcG9sb2d5XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbnZhciBjb252X3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29udl91dGlsc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgY29udm9sdXRpb25hbF8xID0gcmVxdWlyZShcIi4vY29udm9sdXRpb25hbFwiKTtcbmZ1bmN0aW9uIHBvb2wyZCh4LCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgcG9vbE1vZGUpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tQb29sTW9kZShwb29sTW9kZSk7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrUGFkZGluZ01vZGUocGFkZGluZyk7XG4gICAgICAgIGlmIChzdHJpZGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0cmlkZXMgPSBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFkZGluZyA9ICd2YWxpZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YUZvcm1hdCA9IGNvbW1vbl8xLmltYWdlRGF0YUZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb29sTW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb29sTW9kZSA9ICdtYXgnO1xuICAgICAgICB9XG4gICAgICAgIHggPSBjb252b2x1dGlvbmFsXzEucHJlcHJvY2Vzc0NvbnYyRElucHV0KHgsIGRhdGFGb3JtYXQpO1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgdmFyIHBhZGRpbmdTdHJpbmcgPSAocGFkZGluZyA9PT0gJ3NhbWUnKSA/ICdzYW1lJyA6ICd2YWxpZCc7XG4gICAgICAgIGlmIChwb29sTW9kZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgIHkgPSB0ZmMubWF4UG9vbCh4LCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZ1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0gdGZjLmF2Z1Bvb2woeCwgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmdTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgIHkgPSB0ZmMudHJhbnNwb3NlKHksIFswLCAzLCAxLCAyXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfSk7XG59XG5leHBvcnRzLnBvb2wyZCA9IHBvb2wyZDtcbnZhciBQb29saW5nMUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb29saW5nMUQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9vbGluZzFEKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnLnBvb2xTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5wb29sU2l6ZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnBvb2xTaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgX3RoaXMucG9vbFNpemUgPSBbY29uZmlnLnBvb2xTaXplXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5wb29sU2l6ZSkgJiZcbiAgICAgICAgICAgIGNvbmZpZy5wb29sU2l6ZS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWcucG9vbFNpemVbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBfdGhpcy5wb29sU2l6ZSA9IGNvbmZpZy5wb29sU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwicG9vbFNpemUgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBcIiArXG4gICAgICAgICAgICAgICAgXCJBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCBcIiArXG4gICAgICAgICAgICAgICAgKFwiXCIgKyBKU09OLnN0cmluZ2lmeShjb25maWcucG9vbFNpemUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpZGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLnN0cmlkZXMgPSBfdGhpcy5wb29sU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnN0cmlkZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RyaWRlcyA9IFtjb25maWcuc3RyaWRlc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5zdHJpZGVzKSAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5zdHJpZGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25maWcuc3RyaWRlc1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHJpZGVzID0gY29uZmlnLnN0cmlkZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcInN0cmlkZXMgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiQXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyLCBidXQgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIEpTT04uc3RyaW5naWZ5KGNvbmZpZy5zdHJpZGVzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLnBhZGRpbmcgPSBjb25maWcucGFkZGluZyA9PSBudWxsID8gJ3ZhbGlkJyA6IGNvbmZpZy5wYWRkaW5nO1xuICAgICAgICBjb21tb25fMi5jaGVja1BhZGRpbmdNb2RlKF90aGlzLnBhZGRpbmcpO1xuICAgICAgICBfdGhpcy5pbnB1dFNwZWMgPSBbbmV3IHRvcG9sb2d5XzEuSW5wdXRTcGVjKHsgbmRpbTogMyB9KV07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUG9vbGluZzFELnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb252X3V0aWxzXzEuY29udk91dHB1dExlbmd0aChpbnB1dFNoYXBlWzFdLCB0aGlzLnBvb2xTaXplWzBdLCB0aGlzLnBhZGRpbmcsIHRoaXMuc3RyaWRlc1swXSk7XG4gICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgbGVuZ3RoLCBpbnB1dFNoYXBlWzJdXTtcbiAgICB9O1xuICAgIFBvb2xpbmcxRC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnZva2VDYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgICAgICBpbnB1dHMgPSBLLmV4cGFuZERpbXMoZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyksIDIpO1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IF90aGlzLnBvb2xpbmdGdW5jdGlvbihnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKSwgW190aGlzLnBvb2xTaXplWzBdLCAxXSwgW190aGlzLnN0cmlkZXNbMF0sIDFdLCBfdGhpcy5wYWRkaW5nLCAnY2hhbm5lbHNMYXN0Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGZjLnNxdWVlemUob3V0cHV0LCBbMl0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvb2xpbmcxRC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgcG9vbFNpemU6IHRoaXMucG9vbFNpemUsXG4gICAgICAgICAgICBwYWRkaW5nOiB0aGlzLnBhZGRpbmcsXG4gICAgICAgICAgICBzdHJpZGVzOiB0aGlzLnN0cmlkZXMsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgcmV0dXJuIFBvb2xpbmcxRDtcbn0odG9wb2xvZ3lfMi5MYXllcikpO1xuZXhwb3J0cy5Qb29saW5nMUQgPSBQb29saW5nMUQ7XG52YXIgTWF4UG9vbGluZzFEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4UG9vbGluZzFELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heFBvb2xpbmcxRChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICB9XG4gICAgTWF4UG9vbGluZzFELnByb3RvdHlwZS5wb29saW5nRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCkge1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrUGFkZGluZ01vZGUocGFkZGluZyk7XG4gICAgICAgIHJldHVybiBwb29sMmQoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgJ21heCcpO1xuICAgIH07XG4gICAgTWF4UG9vbGluZzFELmNsYXNzTmFtZSA9ICdNYXhQb29saW5nMUQnO1xuICAgIHJldHVybiBNYXhQb29saW5nMUQ7XG59KFBvb2xpbmcxRCkpO1xuZXhwb3J0cy5NYXhQb29saW5nMUQgPSBNYXhQb29saW5nMUQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTWF4UG9vbGluZzFEKTtcbnZhciBBdmVyYWdlUG9vbGluZzFEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXZlcmFnZVBvb2xpbmcxRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdmVyYWdlUG9vbGluZzFEKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBdmVyYWdlUG9vbGluZzFELnByb3RvdHlwZS5wb29saW5nRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCkge1xuICAgICAgICBjb21tb25fMi5jaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrUGFkZGluZ01vZGUocGFkZGluZyk7XG4gICAgICAgIHJldHVybiBwb29sMmQoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgJ2F2ZycpO1xuICAgIH07XG4gICAgQXZlcmFnZVBvb2xpbmcxRC5jbGFzc05hbWUgPSAnQXZlcmFnZVBvb2xpbmcxRCc7XG4gICAgcmV0dXJuIEF2ZXJhZ2VQb29saW5nMUQ7XG59KFBvb2xpbmcxRCkpO1xuZXhwb3J0cy5BdmVyYWdlUG9vbGluZzFEID0gQXZlcmFnZVBvb2xpbmcxRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihBdmVyYWdlUG9vbGluZzFEKTtcbnZhciBQb29saW5nMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb29saW5nMkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9vbGluZzJEKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnLnBvb2xTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5wb29sU2l6ZSA9IFsyLCAyXTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucG9vbFNpemUgPSBBcnJheS5pc0FycmF5KGNvbmZpZy5wb29sU2l6ZSkgP1xuICAgICAgICAgICAgY29uZmlnLnBvb2xTaXplIDpcbiAgICAgICAgICAgIFtjb25maWcucG9vbFNpemUsIGNvbmZpZy5wb29sU2l6ZV07XG4gICAgICAgIF90aGlzLnN0cmlkZXMgPSBjb25maWcuc3RyaWRlcyA9PSBudWxsID8gX3RoaXMucG9vbFNpemUgOiBjb25maWcuc3RyaWRlcztcbiAgICAgICAgX3RoaXMucGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nID09IG51bGwgPyAndmFsaWQnIDogY29uZmlnLnBhZGRpbmc7XG4gICAgICAgIF90aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICAgICAgY29uZmlnLmRhdGFGb3JtYXQgPT0gbnVsbCA/ICdjaGFubmVsc0xhc3QnIDogY29uZmlnLmRhdGFGb3JtYXQ7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChfdGhpcy5kYXRhRm9ybWF0KTtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tQYWRkaW5nTW9kZShfdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW25ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IG5kaW06IDQgfSldO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvb2xpbmcyRC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gaW5wdXRTaGFwZVsyXSA6IGlucHV0U2hhcGVbMV07XG4gICAgICAgIHZhciBjb2xzID0gdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyBpbnB1dFNoYXBlWzNdIDogaW5wdXRTaGFwZVsyXTtcbiAgICAgICAgcm93cyA9XG4gICAgICAgICAgICBjb252X3V0aWxzXzEuY29udk91dHB1dExlbmd0aChyb3dzLCB0aGlzLnBvb2xTaXplWzBdLCB0aGlzLnBhZGRpbmcsIHRoaXMuc3RyaWRlc1swXSk7XG4gICAgICAgIGNvbHMgPVxuICAgICAgICAgICAgY29udl91dGlsc18xLmNvbnZPdXRwdXRMZW5ndGgoY29scywgdGhpcy5wb29sU2l6ZVsxXSwgdGhpcy5wYWRkaW5nLCB0aGlzLnN0cmlkZXNbMV0pO1xuICAgICAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsxXSwgcm93cywgY29sc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIHJvd3MsIGNvbHMsIGlucHV0U2hhcGVbM11dO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb29saW5nMkQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvb2xpbmdGdW5jdGlvbihnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKSwgX3RoaXMucG9vbFNpemUsIF90aGlzLnN0cmlkZXMsIF90aGlzLnBhZGRpbmcsIF90aGlzLmRhdGFGb3JtYXQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvb2xpbmcyRC5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgcG9vbFNpemU6IHRoaXMucG9vbFNpemUsXG4gICAgICAgICAgICBwYWRkaW5nOiB0aGlzLnBhZGRpbmcsXG4gICAgICAgICAgICBzdHJpZGVzOiB0aGlzLnN0cmlkZXMsXG4gICAgICAgICAgICBkYXRhRm9ybWF0OiB0aGlzLmRhdGFGb3JtYXRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICByZXR1cm4gUG9vbGluZzJEO1xufSh0b3BvbG9neV8yLkxheWVyKSk7XG5leHBvcnRzLlBvb2xpbmcyRCA9IFBvb2xpbmcyRDtcbnZhciBNYXhQb29saW5nMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhQb29saW5nMkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4UG9vbGluZzJEKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNYXhQb29saW5nMkQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMsIHBvb2xTaXplLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0KSB7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tQYWRkaW5nTW9kZShwYWRkaW5nKTtcbiAgICAgICAgcmV0dXJuIHBvb2wyZChpbnB1dHMsIHBvb2xTaXplLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCAnbWF4Jyk7XG4gICAgfTtcbiAgICBNYXhQb29saW5nMkQuY2xhc3NOYW1lID0gJ01heFBvb2xpbmcyRCc7XG4gICAgcmV0dXJuIE1heFBvb2xpbmcyRDtcbn0oUG9vbGluZzJEKSk7XG5leHBvcnRzLk1heFBvb2xpbmcyRCA9IE1heFBvb2xpbmcyRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihNYXhQb29saW5nMkQpO1xudmFyIEF2ZXJhZ2VQb29saW5nMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdmVyYWdlUG9vbGluZzJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF2ZXJhZ2VQb29saW5nMkQoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgfVxuICAgIEF2ZXJhZ2VQb29saW5nMkQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbnB1dHMsIHBvb2xTaXplLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0KSB7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAgICAgY29tbW9uXzIuY2hlY2tQYWRkaW5nTW9kZShwYWRkaW5nKTtcbiAgICAgICAgcmV0dXJuIHBvb2wyZChpbnB1dHMsIHBvb2xTaXplLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCAnYXZnJyk7XG4gICAgfTtcbiAgICBBdmVyYWdlUG9vbGluZzJELmNsYXNzTmFtZSA9ICdBdmVyYWdlUG9vbGluZzJEJztcbiAgICByZXR1cm4gQXZlcmFnZVBvb2xpbmcyRDtcbn0oUG9vbGluZzJEKSk7XG5leHBvcnRzLkF2ZXJhZ2VQb29saW5nMkQgPSBBdmVyYWdlUG9vbGluZzJEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEF2ZXJhZ2VQb29saW5nMkQpO1xudmFyIEdsb2JhbFBvb2xpbmcxRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdsb2JhbFBvb2xpbmcxRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHbG9iYWxQb29saW5nMUQoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW25ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IG5kaW06IDMgfSldO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdsb2JhbFBvb2xpbmcxRC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBpbnB1dFNoYXBlWzJdXTtcbiAgICB9O1xuICAgIEdsb2JhbFBvb2xpbmcxRC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb2JhbFBvb2xpbmcxRDtcbn0odG9wb2xvZ3lfMi5MYXllcikpO1xuZXhwb3J0cy5HbG9iYWxQb29saW5nMUQgPSBHbG9iYWxQb29saW5nMUQ7XG52YXIgR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2xvYmFsQXZlcmFnZVBvb2xpbmcxRChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICB9XG4gICAgR2xvYmFsQXZlcmFnZVBvb2xpbmcxRC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIHJldHVybiB0ZmMubWVhbihpbnB1dCwgMSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR2xvYmFsQXZlcmFnZVBvb2xpbmcxRC5jbGFzc05hbWUgPSAnR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCc7XG4gICAgcmV0dXJuIEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQ7XG59KEdsb2JhbFBvb2xpbmcxRCkpO1xuZXhwb3J0cy5HbG9iYWxBdmVyYWdlUG9vbGluZzFEID0gR2xvYmFsQXZlcmFnZVBvb2xpbmcxRDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihHbG9iYWxBdmVyYWdlUG9vbGluZzFEKTtcbnZhciBHbG9iYWxNYXhQb29saW5nMUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHbG9iYWxNYXhQb29saW5nMUQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2xvYmFsTWF4UG9vbGluZzFEKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgIH1cbiAgICBHbG9iYWxNYXhQb29saW5nMUQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGZjLm1heChpbnB1dCwgMSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR2xvYmFsTWF4UG9vbGluZzFELmNsYXNzTmFtZSA9ICdHbG9iYWxNYXhQb29saW5nMUQnO1xuICAgIHJldHVybiBHbG9iYWxNYXhQb29saW5nMUQ7XG59KEdsb2JhbFBvb2xpbmcxRCkpO1xuZXhwb3J0cy5HbG9iYWxNYXhQb29saW5nMUQgPSBHbG9iYWxNYXhQb29saW5nMUQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoR2xvYmFsTWF4UG9vbGluZzFEKTtcbnZhciBHbG9iYWxQb29saW5nMkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHbG9iYWxQb29saW5nMkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2xvYmFsUG9vbGluZzJEKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICAgICAgY29uZmlnLmRhdGFGb3JtYXQgPT0gbnVsbCA/ICdjaGFubmVsc0xhc3QnIDogY29uZmlnLmRhdGFGb3JtYXQ7XG4gICAgICAgIGNvbW1vbl8yLmNoZWNrRGF0YUZvcm1hdChfdGhpcy5kYXRhRm9ybWF0KTtcbiAgICAgICAgX3RoaXMuaW5wdXRTcGVjID0gW25ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IG5kaW06IDQgfSldO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdsb2JhbFBvb2xpbmcyRC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGlucHV0U2hhcGVbM11dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBpbnB1dFNoYXBlWzFdXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR2xvYmFsUG9vbGluZzJELnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gICAgfTtcbiAgICBHbG9iYWxQb29saW5nMkQucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgZGF0YUZvcm1hdDogdGhpcy5kYXRhRm9ybWF0IH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb2JhbFBvb2xpbmcyRDtcbn0odG9wb2xvZ3lfMi5MYXllcikpO1xuZXhwb3J0cy5HbG9iYWxQb29saW5nMkQgPSBHbG9iYWxQb29saW5nMkQ7XG52YXIgR2xvYmFsQXZlcmFnZVBvb2xpbmcyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2xvYmFsQXZlcmFnZVBvb2xpbmcyRCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBHbG9iYWxBdmVyYWdlUG9vbGluZzJELnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5tZWFuKGlucHV0LCBbMSwgMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRmYy5tZWFuKGlucHV0LCBbMiwgM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQuY2xhc3NOYW1lID0gJ0dsb2JhbEF2ZXJhZ2VQb29saW5nMkQnO1xuICAgIHJldHVybiBHbG9iYWxBdmVyYWdlUG9vbGluZzJEO1xufShHbG9iYWxQb29saW5nMkQpKTtcbmV4cG9ydHMuR2xvYmFsQXZlcmFnZVBvb2xpbmcyRCA9IEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoR2xvYmFsQXZlcmFnZVBvb2xpbmcyRCk7XG52YXIgR2xvYmFsTWF4UG9vbGluZzJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2xvYmFsTWF4UG9vbGluZzJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdsb2JhbE1heFBvb2xpbmcyRCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBHbG9iYWxNYXhQb29saW5nMkQucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGZjLm1heChpbnB1dCwgWzEsIDJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZmMubWF4KGlucHV0LCBbMiwgM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdsb2JhbE1heFBvb2xpbmcyRC5jbGFzc05hbWUgPSAnR2xvYmFsTWF4UG9vbGluZzJEJztcbiAgICByZXR1cm4gR2xvYmFsTWF4UG9vbGluZzJEO1xufShHbG9iYWxQb29saW5nMkQpKTtcbmV4cG9ydHMuR2xvYmFsTWF4UG9vbGluZzJEID0gR2xvYmFsTWF4UG9vbGluZzJEO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEdsb2JhbE1heFBvb2xpbmcyRCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb29saW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgYWN0aXZhdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9hY3RpdmF0aW9uc1wiKTtcbnZhciBLID0gcmVxdWlyZShcIi4uL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGNvbnN0cmFpbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RyYWludHNcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgdG9wb2xvZ3lfMiA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGluaXRpYWxpemVyc18xID0gcmVxdWlyZShcIi4uL2luaXRpYWxpemVyc1wiKTtcbnZhciByZWd1bGFyaXplcnNfMSA9IHJlcXVpcmUoXCIuLi9yZWd1bGFyaXplcnNcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgbWF0aF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9tYXRoX3V0aWxzXCIpO1xudmFyIHZhcmlhYmxlc18xID0gcmVxdWlyZShcIi4uL3ZhcmlhYmxlc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemF0aW9uXCIpO1xuZnVuY3Rpb24gcm5uKHN0ZXBGdW5jdGlvbiwgaW5wdXRzLCBpbml0aWFsU3RhdGVzLCBnb0JhY2t3YXJkcywgbWFzaywgY29uc3RhbnRzLCB1bnJvbGwsIGlucHV0TGVuZ3RoKSB7XG4gICAgaWYgKGdvQmFja3dhcmRzID09PSB2b2lkIDApIHsgZ29CYWNrd2FyZHMgPSBmYWxzZTsgfVxuICAgIGlmICh1bnJvbGwgPT09IHZvaWQgMCkgeyB1bnJvbGwgPSBmYWxzZTsgfVxuICAgIHZhciBuZGltID0gaW5wdXRzLnNoYXBlLmxlbmd0aDtcbiAgICBpZiAobmRpbSA8IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbnB1dCBzaG91bGQgYmUgYXQgbGVhc3QgM0QsIGJ1dCBpcyBcIiArIG5kaW0gKyBcIkQuXCIpO1xuICAgIH1cbiAgICB2YXIgYXhlcyA9IFsxLCAwXS5jb25jYXQobWF0aF91dGlscy5yYW5nZSgyLCBuZGltKSk7XG4gICAgaW5wdXRzID0gdGZjLnRyYW5zcG9zZShpbnB1dHMsIGF4ZXMpO1xuICAgIGlmIChtYXNrICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ1RoZSBybm4oKSBmdW5jdGlvbiBvZiB0aGUgZGVlcGxlYXJuLmpzIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCAnICtcbiAgICAgICAgICAgICdtYXNraW5nIHlldC4nKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0YW50cyAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdUaGUgcm5uKCkgZnVuY3RvaW4gb2YgdGhlIGRlZXBsZWFybi5qcyBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgJyArXG4gICAgICAgICAgICAnY29uc3RhbnRzIHlldC4nKTtcbiAgICB9XG4gICAgaWYgKHVucm9sbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0JhY2tlbmQgcm5uKCk6IHRoZSB1bnJvbGwgPSB0cnVlIG9wdGlvbiBpcyBub3QgYXBwbGljYWJsZSB0byB0aGUgJyArXG4gICAgICAgICAgICAnaW1wZXJhdGl2ZSBkZWVwbGVhcm4uanMgYmFja2VuZC4nKTtcbiAgICB9XG4gICAgaWYgKGdvQmFja3dhcmRzKSB7XG4gICAgICAgIGlucHV0cyA9IHRmYy5yZXZlcnNlKGlucHV0cywgMCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXRzO1xuICAgIHZhciBsYXN0T3V0cHV0O1xuICAgIHZhciBzdGF0ZXMgPSBpbml0aWFsU3RhdGVzO1xuICAgIHZhciB0aW1lU3RlcHMgPSBpbnB1dHMuc2hhcGVbMF07XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aW1lU3RlcHM7ICsrdCkge1xuICAgICAgICB2YXIgY3VycmVudElucHV0ID0gSy5zbGljZUFsb25nRmlyc3RBeGlzKGlucHV0cywgdCwgMSk7XG4gICAgICAgIGN1cnJlbnRJbnB1dCA9IGN1cnJlbnRJbnB1dC5yZXNoYXBlKGN1cnJlbnRJbnB1dC5zaGFwZS5zbGljZSgxKSk7XG4gICAgICAgIHZhciBzdGVwT3V0cHV0cyA9IHN0ZXBGdW5jdGlvbihjdXJyZW50SW5wdXQsIHN0YXRlcyk7XG4gICAgICAgIGxhc3RPdXRwdXQgPSBzdGVwT3V0cHV0c1swXTtcbiAgICAgICAgaWYgKHQgPT09IDApIHtcbiAgICAgICAgICAgIG91dHB1dHMgPSBsYXN0T3V0cHV0LnJlc2hhcGUoWzFdLmNvbmNhdChsYXN0T3V0cHV0LnNoYXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRzID0gSy5jb25jYXRBbG9uZ0ZpcnN0QXhpcyhvdXRwdXRzLCBsYXN0T3V0cHV0LnJlc2hhcGUoWzFdLmNvbmNhdChsYXN0T3V0cHV0LnNoYXBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlcyA9IHN0ZXBPdXRwdXRzWzFdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBsYXN0T3V0cHV0LFxuICAgICAgICB0ZmMudHJhbnNwb3NlKG91dHB1dHMsIFsxLCAwXS5jb25jYXQobWF0aF91dGlscy5yYW5nZSgyLCBvdXRwdXRzLnNoYXBlLmxlbmd0aCkpKSxcbiAgICAgICAgc3RhdGVzXG4gICAgXTtcbn1cbmV4cG9ydHMucm5uID0gcm5uO1xudmFyIFJOTiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJOTiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSTk4oY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgdmFyIGNlbGw7XG4gICAgICAgIGlmIChjb25maWcuY2VsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignY2VsbCBwcm9wZXJ0eSBpcyBtaXNzaW5nIGZvciB0aGUgY29uc3RydWN0b3Igb2YgUk5OLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmNlbGwpKSB7XG4gICAgICAgICAgICBjZWxsID0gbmV3IFN0YWNrZWRSTk5DZWxscyh7IGNlbGxzOiBjb25maWcuY2VsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNlbGwgPSBjb25maWcuY2VsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbC5zdGF0ZVNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ1RoZSBSTk4gY2VsbCBzaG91bGQgaGF2ZSBhbiBhdHRyaWJ1dGUgYHN0YXRlU2l6ZWAgKHR1cGxlIG9mICcgK1xuICAgICAgICAgICAgICAgICdpbnRlZ2Vycywgb25lIGludGVnZXIgcGVyIFJOTiBzdGF0ZSkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY2VsbCA9IGNlbGw7XG4gICAgICAgIF90aGlzLnJldHVyblNlcXVlbmNlcyA9XG4gICAgICAgICAgICBjb25maWcucmV0dXJuU2VxdWVuY2VzID09IG51bGwgPyBmYWxzZSA6IGNvbmZpZy5yZXR1cm5TZXF1ZW5jZXM7XG4gICAgICAgIF90aGlzLnJldHVyblN0YXRlID0gY29uZmlnLnJldHVyblN0YXRlID09IG51bGwgPyBmYWxzZSA6IGNvbmZpZy5yZXR1cm5TdGF0ZTtcbiAgICAgICAgX3RoaXMuZ29CYWNrd2FyZHMgPSBjb25maWcuZ29CYWNrd2FyZHMgPT0gbnVsbCA/IGZhbHNlIDogY29uZmlnLmdvQmFja3dhcmRzO1xuICAgICAgICBfdGhpcy5fc3RhdGVmdWwgPSBjb25maWcuc3RhdGVmdWwgPT0gbnVsbCA/IGZhbHNlIDogY29uZmlnLnN0YXRlZnVsO1xuICAgICAgICBfdGhpcy51bnJvbGwgPSBjb25maWcudW5yb2xsID09IG51bGwgPyBmYWxzZSA6IGNvbmZpZy51bnJvbGw7XG4gICAgICAgIF90aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IFtuZXcgdG9wb2xvZ3lfMS5JbnB1dFNwZWMoeyBuZGltOiAzIH0pXTtcbiAgICAgICAgX3RoaXMuc3RhdGVTcGVjID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc3RhdGVzID0gbnVsbDtcbiAgICAgICAgX3RoaXMubnVtQ29uc3RhbnRzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSTk4ucHJvdG90eXBlLmdldFN0YXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBudW1TdGF0ZXMgPSBBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpID8gdGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGggOiAxO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhfdXRpbHMucmFuZ2UoMCwgbnVtU3RhdGVzKS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIG51bGw7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSTk4ucHJvdG90eXBlLnNldFN0YXRlcyA9IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgfTtcbiAgICBSTk4ucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZSA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlmIChnZW5lcmljX3V0aWxzLmlzQXJyYXlPZlNoYXBlcyhpbnB1dFNoYXBlKSkge1xuICAgICAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgICAgIHZhciBzdGF0ZVNpemUgPSB0aGlzLmNlbGwuc3RhdGVTaXplO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGVTaXplKSkge1xuICAgICAgICAgICAgc3RhdGVTaXplID0gW3N0YXRlU2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dERpbSA9IHN0YXRlU2l6ZVswXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlO1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5TZXF1ZW5jZXMpIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlID0gW2lucHV0U2hhcGVbMF0sIGlucHV0U2hhcGVbMV0sIG91dHB1dERpbV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IFtpbnB1dFNoYXBlWzBdLCBvdXRwdXREaW1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldHVyblN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVTaGFwZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdGF0ZVNpemVfMSA9IHN0YXRlU2l6ZTsgX2kgPCBzdGF0ZVNpemVfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGltID0gc3RhdGVTaXplXzFbX2ldO1xuICAgICAgICAgICAgICAgIHN0YXRlU2hhcGUucHVzaChbaW5wdXRTaGFwZVswXSwgZGltXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW291dHB1dFNoYXBlXS5jb25jYXQoc3RhdGVTaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJOTi5wcm90b3R5cGUuY29tcHV0ZU1hc2sgPSBmdW5jdGlvbiAoaW5wdXRzLCBtYXNrKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdjb21wdXRlTWFzayBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIFJOTiB5ZXQnKTtcbiAgICB9O1xuICAgIFJOTi5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICB2YXIgY29uc3RhbnRTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm51bUNvbnN0YW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignQ29uc3RhbnRzIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkIGluIFJOTiB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVyaWNfdXRpbHMuaXNBcnJheU9mU2hhcGVzKGlucHV0U2hhcGUpKSB7XG4gICAgICAgICAgICBpbnB1dFNoYXBlID0gaW5wdXRTaGFwZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHRoaXMuc3RhdGVmdWwgPyBpbnB1dFNoYXBlWzBdIDogbnVsbDtcbiAgICAgICAgdmFyIGlucHV0RGltID0gaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmlucHV0U3BlY1swXSA9IG5ldyB0b3BvbG9neV8xLklucHV0U3BlYyh7IHNoYXBlOiBbYmF0Y2hTaXplLCBudWxsLCBpbnB1dERpbV0gfSk7XG4gICAgICAgIHZhciBzdGVwSW5wdXRTaGFwZSA9IFtpbnB1dFNoYXBlWzBdXS5jb25jYXQoaW5wdXRTaGFwZS5zbGljZSgyKSk7XG4gICAgICAgIGlmIChjb25zdGFudFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdDb25zdGFudHMgc3VwcG9ydCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gUk5OIHlldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbC5idWlsZChzdGVwSW5wdXRTaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlU2l6ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICAgIHN0YXRlU2l6ZSA9IHRoaXMuY2VsbC5zdGF0ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZVNpemUgPSBbdGhpcy5jZWxsLnN0YXRlU2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGVTcGVjICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGZqc19jb3JlXzEudXRpbC5hcnJheXNFcXVhbCh0aGlzLnN0YXRlU3BlYy5tYXAoZnVuY3Rpb24gKHNwZWMpIHsgcmV0dXJuIHNwZWMuc2hhcGVbc3BlYy5zaGFwZS5sZW5ndGggLSAxXTsgfSksIHN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIkFuIGluaXRpYWxTdGF0ZSB3YXMgcGFzc2VkIHRoYXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcImNlbGwuc3RhdGVTaXplLiBSZWNlaXZlZCBzdGF0ZVNwZWM9XCIgKyB0aGlzLnN0YXRlU3BlYyArIFwiOyBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoXCJIb3dldmVyIGNlbGwuc3RhdGVTaXplIGlzIFwiICsgdGhpcy5jZWxsLnN0YXRlU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVNwZWMgPVxuICAgICAgICAgICAgICAgIHN0YXRlU2l6ZS5tYXAoZnVuY3Rpb24gKGRpbSkgeyByZXR1cm4gbmV3IHRvcG9sb2d5XzEuSW5wdXRTcGVjKHsgc2hhcGU6IFtudWxsLCBkaW1dIH0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZWZ1bCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ3N0YXRlZnVsIFJOTiBsYXllciBpcyBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJOTi5wcm90b3R5cGUucmVzZXRTdGF0ZXMgPSBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zdGF0ZWZ1bCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdHRyaWJ1dGVFcnJvcignQ2Fubm90IGNhbGwgcmVzZXRTdGF0ZSgpIG9uIGFuIFJOTiBMYXllciB0aGF0IGlzIG5vdCBzdGF0ZWZ1bC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSBfdGhpcy5pbnB1dFNwZWNbMF0uc2hhcGVbMF07XG4gICAgICAgICAgICBpZiAoYmF0Y2hTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignSWYgYW4gUk5OIGlzIHN0YXRlZnVsLCBpdCBuZWVkcyB0byBrbm93IGl0cyBiYXRjaCBzaXplLiBTcGVjaWZ5ICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhlIGJhdGNoIHNpemUgb2YgeW91ciBpbnB1dCB0ZW5zb3JzOiBcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgJy0gSWYgdXNpbmcgYSBTZXF1ZW50aWFsIG1vZGVsLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICAncGFzc2luZyBhIGBiYXRjaElucHV0U2hhcGVgIG9wdGlvbiB0byB5b3VyIGZpcnN0IGxheWVyLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnLSBJZiB1c2luZyB0aGUgZnVuY3Rpb25hbCBBUEksIHNwZWNpZnkgdGhlIGJhdGNoIHNpemUgYnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdwYXNzaW5nIGEgYGJhdGNoU2hhcGVgIG9wdGlvbiB0byB5b3VyIElucHV0IGxheWVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3RoaXMuY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jZWxsLnN0YXRlU2l6ZS5tYXAoZnVuY3Rpb24gKGRpbSkgeyByZXR1cm4gdGZjLnplcm9zKFtiYXRjaFNpemUsIGRpbV0pOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlcyA9IFt0ZmMuemVyb3MoW2JhdGNoU2l6ZSwgX3RoaXMuY2VsbC5zdGF0ZVNpemVdKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShfdGhpcy5jZWxsLnN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNlbGwuc3RhdGVTaXplLm1hcChmdW5jdGlvbiAoZGltKSB7IHJldHVybiB0ZmMuemVyb3MoW2JhdGNoU2l6ZSwgZGltXSk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVzWzBdID0gdGZjLnplcm9zKFtiYXRjaFNpemUsIF90aGlzLmNlbGwuc3RhdGVTaXplXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVzID0gW3N0YXRlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZXMubGVuZ3RoICE9PSBfdGhpcy5zdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiTGF5ZXIgXCIgKyBfdGhpcy5uYW1lICsgXCIgZXhwZWN0cyBcIiArIF90aGlzLnN0YXRlcy5sZW5ndGggKyBcIiBzdGF0ZShzKSwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnV0IGl0IHJlY2VpdmVkIFwiICsgc3RhdGVzLmxlbmd0aCArIFwiIHN0YXRlIHZhbHVlKHMpLiBJbnB1dCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwicmVjZWl2ZWQ6IFwiICsgc3RhdGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBfdGhpcy5zdGF0ZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW0gPSBBcnJheS5pc0FycmF5KF90aGlzLmNlbGwuc3RhdGVTaXplKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jZWxsLnN0YXRlU2l6ZVtpbmRleF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2VsbC5zdGF0ZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZFNoYXBlID0gW2JhdGNoU2l6ZSwgZGltXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZmpzX2NvcmVfMS51dGlsLmFycmF5c0VxdWFsKHZhbHVlLnNoYXBlLCBleHBlY3RlZFNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJTdGF0ZSBcIiArIGluZGV4ICsgXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIgKyBfdGhpcy5uYW1lICsgXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJleHBlY3RlZCBzaGFwZT1cIiArIGV4cGVjdGVkU2hhcGUgKyBcIiwgcmVjZWl2ZWQgc2hhcGU9XCIgKyB2YWx1ZS5zaGFwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUk5OLnByb3RvdHlwZS5zdGFuZGFyZGl6ZUFyZ3MgPSBmdW5jdGlvbiAoaW5wdXRzLCBpbml0aWFsU3RhdGUsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlICE9IG51bGwgfHwgY29uc3RhbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignV2hlbiBpbnB1dHMgaXMgYW4gYXJyYXksIG5laXRoZXIgaW5pdGlhbFN0YXRlIG9yIGNvbnN0YW50cyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCBiZSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubnVtQ29uc3RhbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdGFudHMgPVxuICAgICAgICAgICAgICAgICAgICBpbnB1dHMuc2xpY2UoaW5wdXRzLmxlbmd0aCAtIHRoaXMubnVtQ29uc3RhbnRzLCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHMuc2xpY2UoMCwgaW5wdXRzLmxlbmd0aCAtIHRoaXMubnVtQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IGlucHV0cy5zbGljZSgxLCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0cyA9IGlucHV0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0xpc3RPck51bGwoeCkge1xuICAgICAgICAgICAgaWYgKHggPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3hdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IHRvTGlzdE9yTnVsbChpbml0aWFsU3RhdGUpO1xuICAgICAgICBjb25zdGFudHMgPSB0b0xpc3RPck51bGwoY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHsgaW5wdXRzOiBpbnB1dHMsIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlLCBjb25zdGFudHM6IGNvbnN0YW50cyB9O1xuICAgIH07XG4gICAgUk5OLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydpbml0aWFsU3RhdGUnXTtcbiAgICAgICAgdmFyIGNvbnN0YW50cyA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snY29uc3RhbnRzJ107XG4gICAgICAgIGlmIChrd2FyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAga3dhcmdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YW5kYXJkaXplZCA9IHRoaXMuc3RhbmRhcmRpemVBcmdzKGlucHV0cywgaW5pdGlhbFN0YXRlLCBjb25zdGFudHMpO1xuICAgICAgICBpbnB1dHMgPSBzdGFuZGFyZGl6ZWQuaW5wdXRzO1xuICAgICAgICBpbml0aWFsU3RhdGUgPSBzdGFuZGFyZGl6ZWQuaW5pdGlhbFN0YXRlO1xuICAgICAgICBjb25zdGFudHMgPSBzdGFuZGFyZGl6ZWQuY29uc3RhbnRzO1xuICAgICAgICB2YXIgYWRkaXRpb25hbElucHV0cyA9IFtdO1xuICAgICAgICB2YXIgYWRkaXRpb25hbFNwZWNzID0gW107XG4gICAgICAgIGlmIChpbml0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAga3dhcmdzWydpbml0aWFsU3RhdGUnXSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxJbnB1dHMgPSBhZGRpdGlvbmFsSW5wdXRzLmNvbmNhdChpbml0aWFsU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVNwZWMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5pdGlhbFN0YXRlXzEgPSBpbml0aWFsU3RhdGU7IF9pIDwgaW5pdGlhbFN0YXRlXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaW5pdGlhbFN0YXRlXzFbX2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVTcGVjLnB1c2gobmV3IHRvcG9sb2d5XzEuSW5wdXRTcGVjKHsgc2hhcGU6IHN0YXRlLnNoYXBlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZGl0aW9uYWxTcGVjcyA9IGFkZGl0aW9uYWxTcGVjcy5jb25jYXQodGhpcy5zdGF0ZVNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdGFudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAga3dhcmdzWydjb25zdGFudHMnXSA9IGNvbnN0YW50cztcbiAgICAgICAgICAgIGFkZGl0aW9uYWxJbnB1dHMgPSBhZGRpdGlvbmFsSW5wdXRzLmNvbmNhdChjb25zdGFudHMpO1xuICAgICAgICAgICAgdGhpcy5udW1Db25zdGFudHMgPSBjb25zdGFudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc1RlbnNvciA9IGFkZGl0aW9uYWxJbnB1dHNbMF0gaW5zdGFuY2VvZiB0eXBlc18xLlN5bWJvbGljVGVuc29yO1xuICAgICAgICBpZiAoaXNUZW5zb3IpIHtcbiAgICAgICAgICAgIHZhciBmdWxsSW5wdXQgPSBbaW5wdXRzXS5jb25jYXQoYWRkaXRpb25hbElucHV0cyk7XG4gICAgICAgICAgICB2YXIgZnVsbElucHV0U3BlYyA9IHRoaXMuaW5wdXRTcGVjLmNvbmNhdChhZGRpdGlvbmFsU3BlY3MpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsSW5wdXRTcGVjID0gdGhpcy5pbnB1dFNwZWM7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3BlYyA9IGZ1bGxJbnB1dFNwZWM7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gX3N1cGVyLnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMsIGZ1bGxJbnB1dCwga3dhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTcGVjID0gb3JpZ2luYWxJbnB1dFNwZWM7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLCBpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJOTi5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFzayA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snbWFzayddO1xuICAgICAgICAgICAgdmFyIHRyYWluaW5nID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWyd0cmFpbmluZyddO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snaW5pdGlhbFN0YXRlJ107XG4gICAgICAgICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZWZ1bCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignc3RhdGVmdWwgUk5OIGxheWVyIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsU3RhdGUgPSBfdGhpcy5nZXRJbml0aWFsU3RhdGUoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFzayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ01hc2tpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBSTk4geWV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtU3RhdGVzID0gQXJyYXkuaXNBcnJheShfdGhpcy5jZWxsLnN0YXRlU2l6ZSkgPyBfdGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGggOiAxO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxTdGF0ZS5sZW5ndGggIT09IG51bVN0YXRlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiUk5OIExheWVyIGhhcyBcIiArIG51bVN0YXRlcyArIFwiIHN0YXRlKHMpIGJ1dCB3YXMgcGFzc2VkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxTdGF0ZS5sZW5ndGggKyBcIiBpbml0aWFsIHN0YXRlKHMpLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IGlucHV0cy5zaGFwZTtcbiAgICAgICAgICAgIHZhciB0aW1lc3RlcHMgPSBpbnB1dFNoYXBlWzFdO1xuICAgICAgICAgICAgaWYgKF90aGlzLnVucm9sbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSWdub3JpbmcgdW5yb2xsID0gdHJ1ZSBmb3IgUk5OIGxheWVyLCBkdWUgdG8gaW1wZXJhdGl2ZSBiYWNrZW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNlbGxDYWxsS3dhcmdzID0geyB0cmFpbmluZzogdHJhaW5pbmcgfTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKGlucHV0cywgc3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dHMgPSBfdGhpcy5jZWxsLmNhbGwoW2lucHV0c10uY29uY2F0KHN0YXRlcyksIGNlbGxDYWxsS3dhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW291dHB1dHNbMF0sIG91dHB1dHMuc2xpY2UoMSldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBybm5PdXRwdXRzID0gcm5uKHN0ZXAsIGlucHV0cywgaW5pdGlhbFN0YXRlLCBfdGhpcy5nb0JhY2t3YXJkcywgbnVsbCwgbnVsbCwgX3RoaXMudW5yb2xsLCB0aW1lc3RlcHMpO1xuICAgICAgICAgICAgdmFyIGxhc3RPdXRwdXQgPSBybm5PdXRwdXRzWzBdO1xuICAgICAgICAgICAgdmFyIG91dHB1dHMgPSBybm5PdXRwdXRzWzFdO1xuICAgICAgICAgICAgdmFyIHN0YXRlcyA9IHJubk91dHB1dHNbMl07XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGVmdWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignc3RhdGVmdWwgUk5OIGxheWVyIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBfdGhpcy5yZXR1cm5TZXF1ZW5jZXMgPyBvdXRwdXRzIDogbGFzdE91dHB1dDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXR1cm5TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbb3V0cHV0XS5jb25jYXQoc3RhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUk5OLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0ZmMuemVyb3MoaW5wdXRzLnNoYXBlKTtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IHRmYy5zdW0oaW5pdGlhbFN0YXRlLCBbMSwgMl0pO1xuICAgICAgICAgICAgaW5pdGlhbFN0YXRlID0gSy5leHBhbmREaW1zKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShfdGhpcy5jZWxsLnN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2VsbC5zdGF0ZVNpemUubWFwKGZ1bmN0aW9uIChkaW0pIHsgcmV0dXJuIGRpbSA+IDEgPyBLLnRpbGUoaW5pdGlhbFN0YXRlLCBbMSwgZGltXSkgOiBpbml0aWFsU3RhdGU7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNlbGwuc3RhdGVTaXplID4gMSA/XG4gICAgICAgICAgICAgICAgICAgIFtLLnRpbGUoaW5pdGlhbFN0YXRlLCBbMSwgX3RoaXMuY2VsbC5zdGF0ZVNpemVdKV0gOlxuICAgICAgICAgICAgICAgICAgICBbaW5pdGlhbFN0YXRlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUk5OLnByb3RvdHlwZSwgXCJ0cmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhaW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC50cmFpbmFibGVXZWlnaHRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUk5OLnByb3RvdHlwZSwgXCJub25UcmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhaW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC53ZWlnaHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5ub25UcmFpbmFibGVXZWlnaHRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSTk4ucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHJldHVyblNlcXVlbmNlczogdGhpcy5yZXR1cm5TZXF1ZW5jZXMsXG4gICAgICAgICAgICByZXR1cm5TdGF0ZTogdGhpcy5yZXR1cm5TdGF0ZSxcbiAgICAgICAgICAgIGdvQmFja3dhcmRzOiB0aGlzLmdvQmFja3dhcmRzLFxuICAgICAgICAgICAgc3RhdGVmdWw6IHRoaXMuc3RhdGVmdWwsXG4gICAgICAgICAgICB1bnJvbGw6IHRoaXMudW5yb2xsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5udW1Db25zdGFudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLm51bUNvbnN0YW50cyA9IHRoaXMubnVtQ29uc3RhbnRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZWxsQ29uZmlnID0gdGhpcy5jZWxsLmdldENvbmZpZygpO1xuICAgICAgICBjb25maWcuY2VsbCA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jZWxsLmdldENsYXNzTmFtZSgpLFxuICAgICAgICAgICAgY29uZmlnOiBjZWxsQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIFJOTi5jbGFzc05hbWUgPSAnUk5OJztcbiAgICByZXR1cm4gUk5OO1xufSh0b3BvbG9neV8yLkxheWVyKSk7XG5leHBvcnRzLlJOTiA9IFJOTjtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihSTk4pO1xudmFyIFJOTkNlbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSTk5DZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJOTkNlbGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUk5OQ2VsbCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTGF5ZXJzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgUk5OQ2VsbCk7XG4gICAgcmV0dXJuIFJOTkNlbGw7XG59KHRvcG9sb2d5XzIuTGF5ZXIpKTtcbmV4cG9ydHMuUk5OQ2VsbCA9IFJOTkNlbGw7XG52YXIgU2ltcGxlUk5OQ2VsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpbXBsZVJOTkNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2ltcGxlUk5OQ2VsbChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0FDVElWQVRJT04gPSAndGFuaCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSID0gJ2dsb3JvdE5vcm1hbCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSID0gJ29ydGhvZ29uYWwnO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIgPSAnemVyb3MnO1xuICAgICAgICBfdGhpcy51bml0cyA9IGNvbmZpZy51bml0cztcbiAgICAgICAgX3RoaXMuYWN0aXZhdGlvbiA9IGFjdGl2YXRpb25zXzEuZ2V0QWN0aXZhdGlvbihjb25maWcuYWN0aXZhdGlvbiA9PSBudWxsID8gX3RoaXMuREVGQVVMVF9BQ1RJVkFUSU9OIDpcbiAgICAgICAgICAgIGNvbmZpZy5hY3RpdmF0aW9uKTtcbiAgICAgICAgX3RoaXMudXNlQmlhcyA9IGNvbmZpZy51c2VCaWFzID09IG51bGwgPyB0cnVlIDogY29uZmlnLnVzZUJpYXM7XG4gICAgICAgIF90aGlzLmtlcm5lbEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmtlcm5lbEluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcucmVjdXJyZW50SW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy5iaWFzSW5pdGlhbGl6ZXIgPVxuICAgICAgICAgICAgaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmJpYXNJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy5rZXJuZWxSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5rZXJuZWxSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLnJlY3VycmVudFJlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMuYmlhc1JlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmJpYXNSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmtlcm5lbENvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5yZWN1cnJlbnRDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMuYmlhc0NvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLmJpYXNDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMuZHJvcG91dCA9IG1hdGhfdXRpbHMubWluKFsxLCBtYXRoX3V0aWxzLm1heChbMCwgY29uZmlnLmRyb3BvdXQgPT0gbnVsbCA/IDAgOiBjb25maWcuZHJvcG91dF0pXSk7XG4gICAgICAgIF90aGlzLnJlY3VycmVudERyb3BvdXQgPSBtYXRoX3V0aWxzLm1pbihbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgbWF0aF91dGlscy5tYXgoWzAsIGNvbmZpZy5yZWN1cnJlbnREcm9wb3V0ID09IG51bGwgPyAwIDogY29uZmlnLnJlY3VycmVudERyb3BvdXRdKVxuICAgICAgICBdKTtcbiAgICAgICAgX3RoaXMuc3RhdGVTaXplID0gX3RoaXMudW5pdHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2ltcGxlUk5OQ2VsbC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ2tlcm5lbCcsIFtpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV0sIHRoaXMudW5pdHNdLCBudWxsLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLCB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICB0aGlzLnJlY3VycmVudEtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KCdyZWN1cnJlbnRfa2VybmVsJywgW3RoaXMudW5pdHMsIHRoaXMudW5pdHNdLCBudWxsLCB0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLCB0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpO1xuICAgICAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLmJpYXMgPSB0aGlzLmFkZFdlaWdodCgnYmlhcycsIFt0aGlzLnVuaXRzXSwgbnVsbCwgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmlhcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgfTtcbiAgICBTaW1wbGVSTk5DZWxsLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJTaW1wbGVSTk5DZWxsIGV4cGVjdHMgMiBpbnB1dCBUZW5zb3JzLCBnb3QgXCIgKyBpbnB1dHMubGVuZ3RoICsgXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZPdXRwdXQgPSBpbnB1dHNbMV07XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHNbMF07XG4gICAgICAgICAgICBpZiAoX3RoaXMuZHJvcG91dCAhPT0gMCB8fCBfdGhpcy5yZWN1cnJlbnREcm9wb3V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ0Ryb3BvdXQgaXMgbm90IGltcGxlbWVudGVkIGZvciBTaW1wbGVSTk5DZWxsIHlldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGggPSBLLmRvdChpbnB1dHMsIF90aGlzLmtlcm5lbC5yZWFkKCkpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGggPSBLLmJpYXNBZGQoaCwgX3RoaXMuYmlhcy5yZWFkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRmYy5hZGQoaCwgSy5kb3QocHJldk91dHB1dCwgX3RoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSkpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmFjdGl2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IF90aGlzLmFjdGl2YXRpb24uYXBwbHkob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbb3V0cHV0LCBvdXRwdXRdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpbXBsZVJOTkNlbGwucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHVuaXRzOiB0aGlzLnVuaXRzLFxuICAgICAgICAgICAgYWN0aXZhdGlvbjogYWN0aXZhdGlvbnNfMS5zZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksXG4gICAgICAgICAgICB1c2VCaWFzOiB0aGlzLnVzZUJpYXMsXG4gICAgICAgICAgICBrZXJuZWxJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksXG4gICAgICAgICAgICBiaWFzSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIHJlY3VycmVudFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGJpYXNSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYWN0aXZpdHlSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgcmVjdXJyZW50Q29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksXG4gICAgICAgICAgICBiaWFzQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLFxuICAgICAgICAgICAgZHJvcG91dDogdGhpcy5kcm9wb3V0LFxuICAgICAgICAgICAgcmVjdXJyZW50RHJvcG91dDogdGhpcy5yZWN1cnJlbnREcm9wb3V0LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIFNpbXBsZVJOTkNlbGwuY2xhc3NOYW1lID0gJ1NpbXBsZVJOTkNlbGwnO1xuICAgIHJldHVybiBTaW1wbGVSTk5DZWxsO1xufShSTk5DZWxsKSk7XG5leHBvcnRzLlNpbXBsZVJOTkNlbGwgPSBTaW1wbGVSTk5DZWxsO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFNpbXBsZVJOTkNlbGwpO1xudmFyIFNpbXBsZVJOTiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpbXBsZVJOTiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaW1wbGVSTk4oY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbmZpZy5jZWxsID0gbmV3IFNpbXBsZVJOTkNlbGwoY29uZmlnKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2ltcGxlUk5OLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXNrID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydtYXNrJ107XG4gICAgICAgICAgICB2YXIgdHJhaW5pbmcgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ3RyYWluaW5nJ107XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydpbml0aWFsU3RhdGUnXTtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNhbGwuY2FsbChfdGhpcywgaW5wdXRzLCB7IG1hc2s6IG1hc2ssIHRyYWluaW5nOiB0cmFpbmluZywgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwidW5pdHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwudW5pdHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcImFjdGl2YXRpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwidXNlQmlhc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC51c2VCaWFzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJrZXJuZWxJbml0aWFsaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxJbml0aWFsaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwicmVjdXJyZW50SW5pdGlhbGl6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcImJpYXNJbml0aWFsaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5iaWFzSW5pdGlhbGl6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcImtlcm5lbFJlZ3VsYXJpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmtlcm5lbFJlZ3VsYXJpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJyZWN1cnJlbnRSZWd1bGFyaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRSZWd1bGFyaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwiYmlhc1JlZ3VsYXJpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmJpYXNSZWd1bGFyaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVJOTi5wcm90b3R5cGUsIFwia2VybmVsQ29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxDb25zdHJhaW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJyZWN1cnJlbnRDb25zdHJhaW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudENvbnN0cmFpbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcImJpYXNDb25zdHJhaW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmJpYXNDb25zdHJhaW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlUk5OLnByb3RvdHlwZSwgXCJkcm9wb3V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmRyb3BvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVSTk4ucHJvdG90eXBlLCBcInJlY3VycmVudERyb3BvdXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2ltcGxlUk5OLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICB1bml0czogdGhpcy51bml0cyxcbiAgICAgICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25zXzEuc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAgICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgcmVjdXJyZW50SW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICAgICAgICBrZXJuZWxSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiaWFzUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICAgICAgICBrZXJuZWxDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgICAgICAgIHJlY3VycmVudENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgYmlhc0NvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGRyb3BvdXQ6IHRoaXMuZHJvcG91dCxcbiAgICAgICAgICAgIHJlY3VycmVudERyb3BvdXQ6IHRoaXMucmVjdXJyZW50RHJvcG91dCxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBkZWxldGUgYmFzZUNvbmZpZ1snY2VsbCddO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBTaW1wbGVSTk4uY2xhc3NOYW1lID0gJ1NpbXBsZVJOTic7XG4gICAgcmV0dXJuIFNpbXBsZVJOTjtcbn0oUk5OKSk7XG5leHBvcnRzLlNpbXBsZVJOTiA9IFNpbXBsZVJOTjtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihTaW1wbGVSTk4pO1xudmFyIEdSVUNlbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHUlVDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdSVUNlbGwoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9BQ1RJVkFUSU9OID0gJ3RhbmgnO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OID0gJ2hhcmRTaWdtb2lkJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIgPSAnZ2xvcm90Tm9ybWFsJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIgPSAnb3J0aG9nb25hbCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiA9ICd6ZXJvcyc7XG4gICAgICAgIF90aGlzLnVuaXRzID0gY29uZmlnLnVuaXRzO1xuICAgICAgICBfdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbnNfMS5nZXRBY3RpdmF0aW9uKGNvbmZpZy5hY3RpdmF0aW9uID09PSB1bmRlZmluZWQgPyBfdGhpcy5ERUZBVUxUX0FDVElWQVRJT04gOlxuICAgICAgICAgICAgY29uZmlnLmFjdGl2YXRpb24pO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uID0gYWN0aXZhdGlvbnNfMS5nZXRBY3RpdmF0aW9uKGNvbmZpZy5hY3RpdmF0aW9uID09PSB1bmRlZmluZWQgPyBfdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OIDpcbiAgICAgICAgICAgIGNvbmZpZy5yZWN1cnJlbnRBY3RpdmF0aW9uKTtcbiAgICAgICAgX3RoaXMudXNlQmlhcyA9IGNvbmZpZy51c2VCaWFzID09IG51bGwgPyB0cnVlIDogY29uZmlnLnVzZUJpYXM7XG4gICAgICAgIF90aGlzLmtlcm5lbEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmtlcm5lbEluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcucmVjdXJyZW50SW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy5iaWFzSW5pdGlhbGl6ZXIgPVxuICAgICAgICAgICAgaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmJpYXNJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy5rZXJuZWxSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5rZXJuZWxSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLnJlY3VycmVudFJlZ3VsYXJpemVyKTtcbiAgICAgICAgX3RoaXMuYmlhc1JlZ3VsYXJpemVyID0gcmVndWxhcml6ZXJzXzEuZ2V0UmVndWxhcml6ZXIoY29uZmlnLmJpYXNSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmtlcm5lbENvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5yZWN1cnJlbnRDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMuYmlhc0NvbnN0cmFpbnQgPSBjb25zdHJhaW50c18xLmdldENvbnN0cmFpbnQoY29uZmlnLmJpYXNDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMuZHJvcG91dCA9IG1hdGhfdXRpbHMubWluKFsxLCBtYXRoX3V0aWxzLm1heChbMCwgY29uZmlnLmRyb3BvdXQgPT0gbnVsbCA/IDAgOiBjb25maWcuZHJvcG91dF0pXSk7XG4gICAgICAgIF90aGlzLnJlY3VycmVudERyb3BvdXQgPSBtYXRoX3V0aWxzLm1pbihbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgbWF0aF91dGlscy5tYXgoWzAsIGNvbmZpZy5yZWN1cnJlbnREcm9wb3V0ID09IG51bGwgPyAwIDogY29uZmlnLnJlY3VycmVudERyb3BvdXRdKVxuICAgICAgICBdKTtcbiAgICAgICAgX3RoaXMuaW1wbGVtZW50YXRpb24gPSBjb25maWcuaW1wbGVtZW50YXRpb247XG4gICAgICAgIF90aGlzLnN0YXRlU2l6ZSA9IF90aGlzLnVuaXRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdSVUNlbGwucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGlucHV0U2hhcGUpIHtcbiAgICAgICAgaW5wdXRTaGFwZSA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICB2YXIgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ2tlcm5lbCcsIFtpbnB1dERpbSwgdGhpcy51bml0cyAqIDNdLCBudWxsLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLCB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgICAgICB0aGlzLnJlY3VycmVudEtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KCdyZWN1cnJlbnRfa2VybmVsJywgW3RoaXMudW5pdHMsIHRoaXMudW5pdHMgKiAzXSwgbnVsbCwgdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciwgdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KTtcbiAgICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoJ2JpYXMnLCBbdGhpcy51bml0cyAqIDNdLCBudWxsLCB0aGlzLmJpYXNJbml0aWFsaXplciwgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIEdSVUNlbGwucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmRyb3BvdXQgIT09IDAgfHwgX3RoaXMucmVjdXJyZW50RHJvcG91dCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdEcm9wb3V0IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgR1JVQ2VsbCB5ZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJHUlVDZWxsIGV4cGVjdHMgMiBpbnB1dCBUZW5zb3JzIChpbnB1dHMsIGgsIGMpLCBnb3QgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5wdXRzLmxlbmd0aCArIFwiLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaFRNaW51czEgPSBpbnB1dHNbMV07XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHNbMF07XG4gICAgICAgICAgICB2YXIgejtcbiAgICAgICAgICAgIHZhciByO1xuICAgICAgICAgICAgdmFyIGhoO1xuICAgICAgICAgICAgaWYgKF90aGlzLmltcGxlbWVudGF0aW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtlcm5lbFogPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5rZXJuZWwucmVhZCgpLCAwLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGtlcm5lbFIgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5rZXJuZWwucmVhZCgpLCBfdGhpcy51bml0cywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciBrZXJuZWxIID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMua2VybmVsLnJlYWQoKSwgX3RoaXMudW5pdHMgKiAyLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VycmVudEtlcm5lbFogPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLCAwLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VycmVudEtlcm5lbFIgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLCBfdGhpcy51bml0cywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciByZWN1cnJlbnRLZXJuZWxIID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSwgX3RoaXMudW5pdHMgKiAyLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0c1ogPSBpbnB1dHM7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0c1IgPSBpbnB1dHM7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0c0ggPSBpbnB1dHM7XG4gICAgICAgICAgICAgICAgdmFyIHhaID0gSy5kb3QoaW5wdXRzWiwga2VybmVsWik7XG4gICAgICAgICAgICAgICAgdmFyIHhSID0gSy5kb3QoaW5wdXRzUiwga2VybmVsUik7XG4gICAgICAgICAgICAgICAgdmFyIHhIID0gSy5kb3QoaW5wdXRzSCwga2VybmVsSCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVzZUJpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpYXNaID0gSy5zbGljZUFsb25nRmlyc3RBeGlzKF90aGlzLmJpYXMucmVhZCgpLCAwLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaWFzUiA9IEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhfdGhpcy5iaWFzLnJlYWQoKSwgX3RoaXMudW5pdHMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpYXNIID0gSy5zbGljZUFsb25nRmlyc3RBeGlzKF90aGlzLmJpYXMucmVhZCgpLCBfdGhpcy51bml0cyAqIDIsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgeFogPSBLLmJpYXNBZGQoeFosIGJpYXNaKTtcbiAgICAgICAgICAgICAgICAgICAgeFIgPSBLLmJpYXNBZGQoeFIsIGJpYXNSKTtcbiAgICAgICAgICAgICAgICAgICAgeEggPSBLLmJpYXNBZGQoeEgsIGJpYXNIKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhUTWludXMxWiA9IGhUTWludXMxO1xuICAgICAgICAgICAgICAgIHZhciBoVE1pbnVzMVIgPSBoVE1pbnVzMTtcbiAgICAgICAgICAgICAgICB2YXIgaFRNaW51czFIID0gaFRNaW51czE7XG4gICAgICAgICAgICAgICAgeiA9IF90aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4WiwgSy5kb3QoaFRNaW51czFaLCByZWN1cnJlbnRLZXJuZWxaKSkpO1xuICAgICAgICAgICAgICAgIHIgPSBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeFIsIEsuZG90KGhUTWludXMxUiwgcmVjdXJyZW50S2VybmVsUikpKTtcbiAgICAgICAgICAgICAgICBoaCA9IF90aGlzLmFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4SCwgSy5kb3QodGZjLm11bChyLCBoVE1pbnVzMUgpLCByZWN1cnJlbnRLZXJuZWxIKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeFggPSBLLmRvdChpbnB1dHMsIF90aGlzLmtlcm5lbC5yZWFkKCkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeFggPSBLLmJpYXNBZGQobWF0cml4WCwgX3RoaXMuYmlhcy5yZWFkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWF0cml4SW5uZXIgPSBLLmRvdChoVE1pbnVzMSwgSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSwgMCwgMiAqIF90aGlzLnVuaXRzKSk7XG4gICAgICAgICAgICAgICAgdmFyIHhaID0gSy5zbGljZUFsb25nTGFzdEF4aXMobWF0cml4WCwgMCwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciB4UiA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKG1hdHJpeFgsIF90aGlzLnVuaXRzLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VycmVudFogPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhtYXRyaXhJbm5lciwgMCwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciByZWN1cnJlbnRSID0gSy5zbGljZUFsb25nTGFzdEF4aXMobWF0cml4SW5uZXIsIF90aGlzLnVuaXRzLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgeiA9IF90aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4WiwgcmVjdXJyZW50WikpO1xuICAgICAgICAgICAgICAgIHIgPSBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeFIsIHJlY3VycmVudFIpKTtcbiAgICAgICAgICAgICAgICB2YXIgeEggPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhtYXRyaXhYLCAyICogX3RoaXMudW5pdHMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXJyZW50SCA9IEsuZG90KHRmYy5tdWwociwgaFRNaW51czEpLCBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLCAyICogX3RoaXMudW5pdHMsIF90aGlzLnVuaXRzKSk7XG4gICAgICAgICAgICAgICAgaGggPSBfdGhpcy5hY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeEgsIHJlY3VycmVudEgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoID0gdGZjLmFkZCh0ZmMubXVsKHosIGhUTWludXMxKSwgdGZjLm11bChLLnNjYWxhclBsdXNBcnJheShLLmdldFNjYWxhcigxKSwgdGZjLm5lZyh6KSksIGhoKSk7XG4gICAgICAgICAgICByZXR1cm4gW2gsIGhdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdSVUNlbGwucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHVuaXRzOiB0aGlzLnVuaXRzLFxuICAgICAgICAgICAgYWN0aXZhdGlvbjogYWN0aXZhdGlvbnNfMS5zZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksXG4gICAgICAgICAgICB1c2VCaWFzOiB0aGlzLnVzZUJpYXMsXG4gICAgICAgICAgICBrZXJuZWxJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksXG4gICAgICAgICAgICBiaWFzSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIHJlY3VycmVudFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGJpYXNSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYWN0aXZpdHlSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgcmVjdXJyZW50Q29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksXG4gICAgICAgICAgICBiaWFzQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLFxuICAgICAgICAgICAgZHJvcG91dDogdGhpcy5kcm9wb3V0LFxuICAgICAgICAgICAgcmVjdXJyZW50RHJvcG91dDogdGhpcy5yZWN1cnJlbnREcm9wb3V0LFxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb246IHRoaXMuaW1wbGVtZW50YXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgR1JVQ2VsbC5jbGFzc05hbWUgPSAnR1JVQ2VsbCc7XG4gICAgcmV0dXJuIEdSVUNlbGw7XG59KFJOTkNlbGwpKTtcbmV4cG9ydHMuR1JVQ2VsbCA9IEdSVUNlbGw7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoR1JVQ2VsbCk7XG52YXIgR1JVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR1JVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdSVShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZy5pbXBsZW1lbnRhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdgaW1wbGVtZW50YXRpb249MGAgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIG5vdyBkZWZhdWx0cyB0byAnICtcbiAgICAgICAgICAgICAgICAnYGltcGxlbWVudGF0aW9uPTFgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbGF5ZXIgY2FsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuY2VsbCA9IG5ldyBHUlVDZWxsKGNvbmZpZyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdSVS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFzayA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snbWFzayddO1xuICAgICAgICAgICAgdmFyIHRyYWluaW5nID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWyd0cmFpbmluZyddO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snaW5pdGlhbFN0YXRlJ107XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jYWxsLmNhbGwoX3RoaXMsIGlucHV0cywgeyBtYXNrOiBtYXNrLCB0cmFpbmluZzogdHJhaW5pbmcsIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcInVuaXRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnVuaXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJhY3RpdmF0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmFjdGl2YXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcInVzZUJpYXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwudXNlQmlhcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwia2VybmVsSW5pdGlhbGl6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwua2VybmVsSW5pdGlhbGl6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcInJlY3VycmVudEluaXRpYWxpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudEluaXRpYWxpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJiaWFzSW5pdGlhbGl6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJrZXJuZWxSZWd1bGFyaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxSZWd1bGFyaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwicmVjdXJyZW50UmVndWxhcml6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwucmVjdXJyZW50UmVndWxhcml6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcImJpYXNSZWd1bGFyaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5iaWFzUmVndWxhcml6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcImtlcm5lbENvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwua2VybmVsQ29uc3RyYWludDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwicmVjdXJyZW50Q29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRDb25zdHJhaW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJiaWFzQ29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5iaWFzQ29uc3RyYWludDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdSVS5wcm90b3R5cGUsIFwiZHJvcG91dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5kcm9wb3V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR1JVLnByb3RvdHlwZSwgXCJyZWN1cnJlbnREcm9wb3V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUlUucHJvdG90eXBlLCBcImltcGxlbWVudGF0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmltcGxlbWVudGF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBHUlUucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHVuaXRzOiB0aGlzLnVuaXRzLFxuICAgICAgICAgICAgYWN0aXZhdGlvbjogYWN0aXZhdGlvbnNfMS5zZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksXG4gICAgICAgICAgICB1c2VCaWFzOiB0aGlzLnVzZUJpYXMsXG4gICAgICAgICAgICBrZXJuZWxJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksXG4gICAgICAgICAgICBiaWFzSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIHJlY3VycmVudFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGJpYXNSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYWN0aXZpdHlSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgcmVjdXJyZW50Q29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksXG4gICAgICAgICAgICBiaWFzQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLFxuICAgICAgICAgICAgZHJvcG91dDogdGhpcy5kcm9wb3V0LFxuICAgICAgICAgICAgcmVjdXJyZW50RHJvcG91dDogdGhpcy5yZWN1cnJlbnREcm9wb3V0LFxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb246IHRoaXMuaW1wbGVtZW50YXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgZGVsZXRlIGJhc2VDb25maWdbJ2NlbGwnXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgR1JVLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1snaW1wbG1lbnRhdGlvbiddID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWdbJ2ltcGxlbWVudGF0aW9uJ10gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY2xzKGNvbmZpZyk7XG4gICAgfTtcbiAgICBHUlUuY2xhc3NOYW1lID0gJ0dSVSc7XG4gICAgcmV0dXJuIEdSVTtcbn0oUk5OKSk7XG5leHBvcnRzLkdSVSA9IEdSVTtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihHUlUpO1xudmFyIExTVE1DZWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTFNUTUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTFNUTUNlbGwoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9BQ1RJVkFUSU9OID0gJ3RhbmgnO1xuICAgICAgICBfdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OID0gJ2hhcmRTaWdtb2lkJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIgPSAnZ2xvcm90Tm9ybWFsJztcbiAgICAgICAgX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIgPSAnb3J0aG9nb25hbCc7XG4gICAgICAgIF90aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiA9ICd6ZXJvcyc7XG4gICAgICAgIF90aGlzLnVuaXRzID0gY29uZmlnLnVuaXRzO1xuICAgICAgICBfdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbnNfMS5nZXRBY3RpdmF0aW9uKGNvbmZpZy5hY3RpdmF0aW9uID09PSB1bmRlZmluZWQgPyBfdGhpcy5ERUZBVUxUX0FDVElWQVRJT04gOlxuICAgICAgICAgICAgY29uZmlnLmFjdGl2YXRpb24pO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uID0gYWN0aXZhdGlvbnNfMS5nZXRBY3RpdmF0aW9uKGNvbmZpZy5hY3RpdmF0aW9uID09PSB1bmRlZmluZWQgPyBfdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OIDpcbiAgICAgICAgICAgIGNvbmZpZy5yZWN1cnJlbnRBY3RpdmF0aW9uKTtcbiAgICAgICAgX3RoaXMudXNlQmlhcyA9IGNvbmZpZy51c2VCaWFzID09IG51bGwgPyB0cnVlIDogY29uZmlnLnVzZUJpYXM7XG4gICAgICAgIF90aGlzLmtlcm5lbEluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmtlcm5lbEluaXRpYWxpemVyIHx8IF90aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5nZXRJbml0aWFsaXplcihjb25maWcucmVjdXJyZW50SW5pdGlhbGl6ZXIgfHwgX3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy5iaWFzSW5pdGlhbGl6ZXIgPVxuICAgICAgICAgICAgaW5pdGlhbGl6ZXJzXzEuZ2V0SW5pdGlhbGl6ZXIoY29uZmlnLmJpYXNJbml0aWFsaXplciB8fCBfdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpO1xuICAgICAgICBfdGhpcy51bml0Rm9yZ2V0QmlhcyA9IGNvbmZpZy51bml0Rm9yZ2V0QmlhcztcbiAgICAgICAgX3RoaXMua2VybmVsUmVndWxhcml6ZXIgPSByZWd1bGFyaXplcnNfMS5nZXRSZWd1bGFyaXplcihjb25maWcua2VybmVsUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5yZWN1cnJlbnRSZWd1bGFyaXplcik7XG4gICAgICAgIF90aGlzLmJpYXNSZWd1bGFyaXplciA9IHJlZ3VsYXJpemVyc18xLmdldFJlZ3VsYXJpemVyKGNvbmZpZy5iaWFzUmVndWxhcml6ZXIpO1xuICAgICAgICBfdGhpcy5rZXJuZWxDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICAgICAgX3RoaXMucmVjdXJyZW50Q29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzEuZ2V0Q29uc3RyYWludChjb25maWcucmVjdXJyZW50Q29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmJpYXNDb25zdHJhaW50ID0gY29uc3RyYWludHNfMS5nZXRDb25zdHJhaW50KGNvbmZpZy5iaWFzQ29uc3RyYWludCk7XG4gICAgICAgIF90aGlzLmRyb3BvdXQgPSBtYXRoX3V0aWxzLm1pbihbMSwgbWF0aF91dGlscy5tYXgoWzAsIGNvbmZpZy5kcm9wb3V0ID09IG51bGwgPyAwIDogY29uZmlnLmRyb3BvdXRdKV0pO1xuICAgICAgICBfdGhpcy5yZWN1cnJlbnREcm9wb3V0ID0gbWF0aF91dGlscy5taW4oW1xuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIG1hdGhfdXRpbHMubWF4KFswLCBjb25maWcucmVjdXJyZW50RHJvcG91dCA9PSBudWxsID8gMCA6IGNvbmZpZy5yZWN1cnJlbnREcm9wb3V0XSlcbiAgICAgICAgXSk7XG4gICAgICAgIF90aGlzLmltcGxlbWVudGF0aW9uID0gY29uZmlnLmltcGxlbWVudGF0aW9uO1xuICAgICAgICBfdGhpcy5zdGF0ZVNpemUgPSBbX3RoaXMudW5pdHMsIF90aGlzLnVuaXRzXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMU1RNQ2VsbC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIHZhciBpbnB1dERpbSA9IGlucHV0U2hhcGVbaW5wdXRTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5rZXJuZWwgPSB0aGlzLmFkZFdlaWdodCgna2VybmVsJywgW2lucHV0RGltLCB0aGlzLnVuaXRzICogNF0sIG51bGwsIHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsIHRoaXMua2VybmVsUmVndWxhcml6ZXIsIHRydWUsIHRoaXMua2VybmVsQ29uc3RyYWludCk7XG4gICAgICAgIHRoaXMucmVjdXJyZW50S2VybmVsID0gdGhpcy5hZGRXZWlnaHQoJ3JlY3VycmVudF9rZXJuZWwnLCBbdGhpcy51bml0cywgdGhpcy51bml0cyAqIDRdLCBudWxsLCB0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLCB0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpO1xuICAgICAgICB2YXIgYmlhc0luaXRpYWxpemVyO1xuICAgICAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51bml0Rm9yZ2V0Qmlhcykge1xuICAgICAgICAgICAgICAgIHZhciBjYXB0dXJlZEJpYXNJbml0XzEgPSB0aGlzLmJpYXNJbml0aWFsaXplcjtcbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZWRVbml0c18xID0gdGhpcy51bml0cztcbiAgICAgICAgICAgICAgICBiaWFzSW5pdGlhbGl6ZXIgPSBuZXcgKF9hID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhDdXN0b21Jbml0LCBfc3VwZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gQ3VzdG9tSW5pdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBDdXN0b21Jbml0LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYkkgPSBjYXB0dXJlZEJpYXNJbml0XzEuYXBwbHkoW2NhcHR1cmVkVW5pdHNfMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiRiA9IChuZXcgaW5pdGlhbGl6ZXJzXzEuT25lcygpKS5hcHBseShbY2FwdHVyZWRVbml0c18xXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJDQW5kSCA9IGNhcHR1cmVkQmlhc0luaXRfMS5hcHBseShbY2FwdHVyZWRVbml0c18xICogMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBLLmNvbmNhdEFsb25nRmlyc3RBeGlzKEsuY29uY2F0QWxvbmdGaXJzdEF4aXMoYkksIGJGKSwgYkNBbmRIKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3VzdG9tSW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfShpbml0aWFsaXplcnNfMS5Jbml0aWFsaXplcikpLFxuICAgICAgICAgICAgICAgICAgICBfYS5jbGFzc05hbWUgPSAnQ3VzdG9tSW5pdCcsXG4gICAgICAgICAgICAgICAgICAgIF9hKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyID0gdGhpcy5iaWFzSW5pdGlhbGl6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJpYXMgPSB0aGlzLmFkZFdlaWdodCgnYmlhcycsIFt0aGlzLnVuaXRzICogNF0sIG51bGwsIGJpYXNJbml0aWFsaXplciwgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaWFzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgTFNUTUNlbGwucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmRyb3BvdXQgIT09IDAgfHwgX3RoaXMucmVjdXJyZW50RHJvcG91dCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCdEcm9wb3V0IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgTFNUTUNlbGwgeWV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiTFNUTUNlbGwgZXhwZWN0cyAzIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCBcIiArXG4gICAgICAgICAgICAgICAgICAgIChpbnB1dHMubGVuZ3RoICsgXCIuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoVE1pbnVzMSA9IGlucHV0c1sxXTtcbiAgICAgICAgICAgIHZhciBjVE1pbnVzMSA9IGlucHV0c1syXTtcbiAgICAgICAgICAgIGlucHV0cyA9IGlucHV0c1swXTtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICB2YXIgYztcbiAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgaWYgKF90aGlzLmltcGxlbWVudGF0aW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtlcm5lbEkgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5rZXJuZWwucmVhZCgpLCAwLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGtlcm5lbEYgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5rZXJuZWwucmVhZCgpLCBfdGhpcy51bml0cywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciBrZXJuZWxDID0gSy5zbGljZUFsb25nTGFzdEF4aXMoX3RoaXMua2VybmVsLnJlYWQoKSwgX3RoaXMudW5pdHMgKiAyLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGtlcm5lbE8gPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5rZXJuZWwucmVhZCgpLCBfdGhpcy51bml0cyAqIDMsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXJyZW50S2VybmVsSSA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKF90aGlzLnJlY3VycmVudEtlcm5lbC5yZWFkKCksIDAsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXJyZW50S2VybmVsRiA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKF90aGlzLnJlY3VycmVudEtlcm5lbC5yZWFkKCksIF90aGlzLnVuaXRzLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3VycmVudEtlcm5lbEMgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyhfdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLCBfdGhpcy51bml0cyAqIDIsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdXJyZW50S2VybmVsTyA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKF90aGlzLnJlY3VycmVudEtlcm5lbC5yZWFkKCksIF90aGlzLnVuaXRzICogMywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHNJID0gaW5wdXRzO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHNGID0gaW5wdXRzO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHNDID0gaW5wdXRzO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dHNPID0gaW5wdXRzO1xuICAgICAgICAgICAgICAgIHZhciB4SSA9IEsuZG90KGlucHV0c0ksIGtlcm5lbEkpO1xuICAgICAgICAgICAgICAgIHZhciB4RiA9IEsuZG90KGlucHV0c0YsIGtlcm5lbEYpO1xuICAgICAgICAgICAgICAgIHZhciB4QyA9IEsuZG90KGlucHV0c0MsIGtlcm5lbEMpO1xuICAgICAgICAgICAgICAgIHZhciB4TyA9IEsuZG90KGlucHV0c08sIGtlcm5lbE8pO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51c2VCaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaWFzSSA9IEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhfdGhpcy5iaWFzLnJlYWQoKSwgMCwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmlhc0YgPSBLLnNsaWNlQWxvbmdGaXJzdEF4aXMoX3RoaXMuYmlhcy5yZWFkKCksIF90aGlzLnVuaXRzLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaWFzQyA9IEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhfdGhpcy5iaWFzLnJlYWQoKSwgX3RoaXMudW5pdHMgKiAyLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaWFzTyA9IEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhfdGhpcy5iaWFzLnJlYWQoKSwgX3RoaXMudW5pdHMgKiAzLCBfdGhpcy51bml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHhJID0gSy5iaWFzQWRkKHhJLCBiaWFzSSk7XG4gICAgICAgICAgICAgICAgICAgIHhGID0gSy5iaWFzQWRkKHhGLCBiaWFzRik7XG4gICAgICAgICAgICAgICAgICAgIHhDID0gSy5iaWFzQWRkKHhDLCBiaWFzQyk7XG4gICAgICAgICAgICAgICAgICAgIHhPID0gSy5iaWFzQWRkKHhPLCBiaWFzTyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBoVE1pbnVzMUkgPSBoVE1pbnVzMTtcbiAgICAgICAgICAgICAgICB2YXIgaFRNaW51czFGID0gaFRNaW51czE7XG4gICAgICAgICAgICAgICAgdmFyIGhUTWludXMxQyA9IGhUTWludXMxO1xuICAgICAgICAgICAgICAgIHZhciBoVE1pbnVzMU8gPSBoVE1pbnVzMTtcbiAgICAgICAgICAgICAgICBpID0gX3RoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh0ZmMuYWRkKHhJLCBLLmRvdChoVE1pbnVzMUksIHJlY3VycmVudEtlcm5lbEkpKSk7XG4gICAgICAgICAgICAgICAgZiA9IF90aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4RiwgSy5kb3QoaFRNaW51czFGLCByZWN1cnJlbnRLZXJuZWxGKSkpO1xuICAgICAgICAgICAgICAgIGMgPSB0ZmMuYWRkKHRmYy5tdWwoZiwgY1RNaW51czEpLCB0ZmMubXVsKGksIF90aGlzLmFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4QywgSy5kb3QoaFRNaW51czFDLCByZWN1cnJlbnRLZXJuZWxDKSkpKSk7XG4gICAgICAgICAgICAgICAgbyA9IF90aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4TywgSy5kb3QoaFRNaW51czFPLCByZWN1cnJlbnRLZXJuZWxPKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHogPSBLLmRvdChpbnB1dHMsIF90aGlzLmtlcm5lbC5yZWFkKCkpO1xuICAgICAgICAgICAgICAgIHogPSB0ZmMuYWRkKHosIEsuZG90KGhUTWludXMxLCBfdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpKSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVzZUJpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgeiA9IEsuYmlhc0FkZCh6LCBfdGhpcy5iaWFzLnJlYWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB6MCA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKHosIDAsIF90aGlzLnVuaXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgejEgPSBLLnNsaWNlQWxvbmdMYXN0QXhpcyh6LCBfdGhpcy51bml0cywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciB6MiA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKHosIF90aGlzLnVuaXRzICogMiwgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIHZhciB6MyA9IEsuc2xpY2VBbG9uZ0xhc3RBeGlzKHosIF90aGlzLnVuaXRzICogMywgX3RoaXMudW5pdHMpO1xuICAgICAgICAgICAgICAgIGkgPSBfdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHowKTtcbiAgICAgICAgICAgICAgICBmID0gX3RoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh6MSk7XG4gICAgICAgICAgICAgICAgYyA9IHRmYy5hZGQodGZjLm11bChmLCBjVE1pbnVzMSksIHRmYy5tdWwoaSwgX3RoaXMuYWN0aXZhdGlvbi5hcHBseSh6MikpKTtcbiAgICAgICAgICAgICAgICBvID0gX3RoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh6Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaCA9IHRmYy5tdWwobywgX3RoaXMuYWN0aXZhdGlvbi5hcHBseShjKSk7XG4gICAgICAgICAgICByZXR1cm4gW2gsIGgsIGNdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExTVE1DZWxsLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICB1bml0czogdGhpcy51bml0cyxcbiAgICAgICAgICAgIGFjdGl2YXRpb246IGFjdGl2YXRpb25zXzEuc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAgICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgcmVjdXJyZW50SW5pdGlhbGl6ZXI6IGluaXRpYWxpemVyc18xLnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgYmlhc0luaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICAgICAgICB1bml0Rm9yZ2V0QmlhczogdGhpcy51bml0Rm9yZ2V0QmlhcyxcbiAgICAgICAgICAgIGtlcm5lbFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIHJlY3VycmVudFJlZ3VsYXJpemVyOiByZWd1bGFyaXplcnNfMS5zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGJpYXNSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLFxuICAgICAgICAgICAgYWN0aXZpdHlSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGtlcm5lbENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgcmVjdXJyZW50Q29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksXG4gICAgICAgICAgICBiaWFzQ29uc3RyYWludDogY29uc3RyYWludHNfMS5zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLFxuICAgICAgICAgICAgZHJvcG91dDogdGhpcy5kcm9wb3V0LFxuICAgICAgICAgICAgcmVjdXJyZW50RHJvcG91dDogdGhpcy5yZWN1cnJlbnREcm9wb3V0LFxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb246IHRoaXMuaW1wbGVtZW50YXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlQ29uZmlnID0gX3N1cGVyLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgTFNUTUNlbGwuY2xhc3NOYW1lID0gJ0xTVE1DZWxsJztcbiAgICByZXR1cm4gTFNUTUNlbGw7XG59KFJOTkNlbGwpKTtcbmV4cG9ydHMuTFNUTUNlbGwgPSBMU1RNQ2VsbDtcbnRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5yZWdpc3RlcihMU1RNQ2VsbCk7XG52YXIgTFNUTSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExTVE0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTFNUTShjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZy5pbXBsZW1lbnRhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdgaW1wbGVtZW50YXRpb249MGAgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIG5vdyBkZWZhdWx0cyB0byAnICtcbiAgICAgICAgICAgICAgICAnYGltcGxlbWVudGF0aW9uPTFgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbGF5ZXIgY2FsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuY2VsbCA9IG5ldyBMU1RNQ2VsbChjb25maWcpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMU1RNLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXNrID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydtYXNrJ107XG4gICAgICAgICAgICB2YXIgdHJhaW5pbmcgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ3RyYWluaW5nJ107XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydpbml0aWFsU3RhdGUnXTtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNhbGwuY2FsbChfdGhpcywgaW5wdXRzLCB7IG1hc2s6IG1hc2ssIHRyYWluaW5nOiB0cmFpbmluZywgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcInVuaXRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnVuaXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwiYWN0aXZhdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5hY3RpdmF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwidXNlQmlhc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC51c2VCaWFzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwia2VybmVsSW5pdGlhbGl6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwua2VybmVsSW5pdGlhbGl6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJyZWN1cnJlbnRJbml0aWFsaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRJbml0aWFsaXplcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcImJpYXNJbml0aWFsaXplclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5iaWFzSW5pdGlhbGl6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJ1bml0Rm9yZ2V0Qmlhc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC51bml0Rm9yZ2V0QmlhcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExTVE0ucHJvdG90eXBlLCBcImtlcm5lbFJlZ3VsYXJpemVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmtlcm5lbFJlZ3VsYXJpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwicmVjdXJyZW50UmVndWxhcml6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwucmVjdXJyZW50UmVndWxhcml6ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJiaWFzUmVndWxhcml6ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYmlhc1JlZ3VsYXJpemVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwia2VybmVsQ29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxDb25zdHJhaW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwicmVjdXJyZW50Q29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRDb25zdHJhaW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFNUTS5wcm90b3R5cGUsIFwiYmlhc0NvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGwuYmlhc0NvbnN0cmFpbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJkcm9wb3V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLmRyb3BvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJyZWN1cnJlbnREcm9wb3V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMU1RNLnByb3RvdHlwZSwgXCJpbXBsZW1lbnRhdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5pbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTFNUTS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgdW5pdHM6IHRoaXMudW5pdHMsXG4gICAgICAgICAgICBhY3RpdmF0aW9uOiBhY3RpdmF0aW9uc18xLnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxcbiAgICAgICAgICAgIHVzZUJpYXM6IHRoaXMudXNlQmlhcyxcbiAgICAgICAgICAgIGtlcm5lbEluaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIHJlY3VycmVudEluaXRpYWxpemVyOiBpbml0aWFsaXplcnNfMS5zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxcbiAgICAgICAgICAgIGJpYXNJbml0aWFsaXplcjogaW5pdGlhbGl6ZXJzXzEuc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLFxuICAgICAgICAgICAgdW5pdEZvcmdldEJpYXM6IHRoaXMudW5pdEZvcmdldEJpYXMsXG4gICAgICAgICAgICBrZXJuZWxSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICAgICAgICByZWN1cnJlbnRSZWd1bGFyaXplcjogcmVndWxhcml6ZXJzXzEuc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksXG4gICAgICAgICAgICBiaWFzUmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgICAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHJlZ3VsYXJpemVyc18xLnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICAgICAgICBrZXJuZWxDb25zdHJhaW50OiBjb25zdHJhaW50c18xLnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgICAgICAgIHJlY3VycmVudENvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLFxuICAgICAgICAgICAgYmlhc0NvbnN0cmFpbnQ6IGNvbnN0cmFpbnRzXzEuc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxcbiAgICAgICAgICAgIGRyb3BvdXQ6IHRoaXMuZHJvcG91dCxcbiAgICAgICAgICAgIHJlY3VycmVudERyb3BvdXQ6IHRoaXMucmVjdXJyZW50RHJvcG91dCxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiB0aGlzLmltcGxlbWVudGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7XG4gICAgICAgIGRlbGV0ZSBiYXNlQ29uZmlnWydjZWxsJ107XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuICAgIExTVE0uZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnWydpbXBsbWVudGF0aW9uJ10gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZ1snaW1wbGVtZW50YXRpb24nXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnKTtcbiAgICB9O1xuICAgIExTVE0uY2xhc3NOYW1lID0gJ0xTVE0nO1xuICAgIHJldHVybiBMU1RNO1xufShSTk4pKTtcbmV4cG9ydHMuTFNUTSA9IExTVE07XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoTFNUTSk7XG52YXIgU3RhY2tlZFJOTkNlbGxzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhY2tlZFJOTkNlbGxzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWNrZWRSTk5DZWxscyhjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jZWxscyA9IGNvbmZpZy5jZWxscztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhY2tlZFJOTkNlbGxzLnByb3RvdHlwZSwgXCJzdGF0ZVNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZVNpemUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNlbGxzLnNsaWNlKCkucmV2ZXJzZSgpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNlbGwuc3RhdGVTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVNpemUucHVzaC5hcHBseShzdGF0ZVNpemUsIGNlbGwuc3RhdGVTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU2l6ZS5wdXNoKGNlbGwuc3RhdGVTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVTaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdGFja2VkUk5OQ2VsbHMucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgICAgdmFyIHN0YXRlcyA9IGlucHV0cy5zbGljZSgxKTtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5jZWxscy5zbGljZSgpLnJldmVyc2UoKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjZWxsLnN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkU3RhdGVzLnB1c2goc3RhdGVzLnNwbGljZSgwLCBjZWxsLnN0YXRlU2l6ZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZFN0YXRlcy5wdXNoKHN0YXRlcy5zcGxpY2UoMCwgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lc3RlZFN0YXRlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB2YXIgbmV3TmVzdGVkU3RhdGVzID0gW107XG4gICAgICAgICAgICB2YXIgY2FsbElucHV0cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuY2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IF90aGlzLmNlbGxzW2ldO1xuICAgICAgICAgICAgICAgIHN0YXRlcyA9IG5lc3RlZFN0YXRlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSW5wdXRzID0gW2lucHV0c1swXV0uY29uY2F0KHN0YXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSW5wdXRzID0gW2NhbGxJbnB1dHNbMF1dLmNvbmNhdChzdGF0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsSW5wdXRzID0gY2VsbC5jYWxsKGNhbGxJbnB1dHMsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgbmV3TmVzdGVkU3RhdGVzLnB1c2goY2FsbElucHV0cy5zbGljZSgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBuZXdOZXN0ZWRTdGF0ZXMuc2xpY2UoKS5yZXZlcnNlKCk7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxTdGF0ZXMgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgc3RhdGVzLnB1c2guYXBwbHkoc3RhdGVzLCBjZWxsU3RhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbY2FsbElucHV0c1swXV0uY29uY2F0KHN0YXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RhY2tlZFJOTkNlbGxzLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlmIChnZW5lcmljX3V0aWxzLmlzQXJyYXlPZlNoYXBlcyhpbnB1dFNoYXBlKSkge1xuICAgICAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgICAgIHZhciBvdXRwdXREaW07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNlbGxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBfYVtfaV07XG4gICAgICAgICAgICBjZWxsLmJ1aWxkKGlucHV0U2hhcGUpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0RGltID0gY2VsbC5zdGF0ZVNpemVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXREaW0gPSBjZWxsLnN0YXRlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXSwgb3V0cHV0RGltXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YWNrZWRSTk5DZWxscy5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VsbENvbmZpZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2VsbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IF9hW19pXTtcbiAgICAgICAgICAgIGNlbGxDb25maWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICdjbGFzc05hbWUnOiB0aGlzLmdldENsYXNzTmFtZSgpLFxuICAgICAgICAgICAgICAgICdjb25maWcnOiBjZWxsLmdldENvbmZpZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgJ2NlbGxzJzogY2VsbENvbmZpZ3MgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBTdGFja2VkUk5OQ2VsbHMuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZywgY3VzdG9tT2JqZWN0cykge1xuICAgICAgICBpZiAoY3VzdG9tT2JqZWN0cyA9PT0gdm9pZCAwKSB7IGN1c3RvbU9iamVjdHMgPSB7fTsgfVxuICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbmZpZ1snY2VsbHMnXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjZWxsQ29uZmlnID0gX2FbX2ldO1xuICAgICAgICAgICAgY2VsbHMucHVzaChzZXJpYWxpemF0aW9uXzEuZGVzZXJpYWxpemUoY2VsbENvbmZpZywgY3VzdG9tT2JqZWN0cykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY2xzKHsgY2VsbHM6IGNlbGxzIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YWNrZWRSTk5DZWxscy5wcm90b3R5cGUsIFwidHJhaW5hYmxlV2VpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3ZWlnaHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jZWxsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzLnB1c2guYXBwbHkod2VpZ2h0cywgY2VsbC50cmFpbmFibGVXZWlnaHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3ZWlnaHRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhY2tlZFJOTkNlbGxzLnByb3RvdHlwZSwgXCJub25UcmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2VsbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cy5wdXNoLmFwcGx5KHdlaWdodHMsIGNlbGwubm9uVHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhaW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZVdlaWdodHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy5jZWxsczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgIHRyYWluYWJsZVdlaWdodHMucHVzaC5hcHBseSh0cmFpbmFibGVXZWlnaHRzLCBjZWxsLnRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQod2VpZ2h0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RhY2tlZFJOTkNlbGxzLnByb3RvdHlwZS5nZXRXZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2VpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jZWxsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gX2FbX2ldO1xuICAgICAgICAgICAgd2VpZ2h0cy5wdXNoLmFwcGx5KHdlaWdodHMsIGNlbGwud2VpZ2h0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlc18xLmJhdGNoR2V0VmFsdWUod2VpZ2h0cyk7XG4gICAgfTtcbiAgICBTdGFja2VkUk5OQ2VsbHMucHJvdG90eXBlLnNldFdlaWdodHMgPSBmdW5jdGlvbiAod2VpZ2h0cykge1xuICAgICAgICB2YXIgdHVwbGVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNlbGxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgbnVtUGFyYW1zID0gY2VsbC53ZWlnaHRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpbnB1dFdlaWdodHMgPSB3ZWlnaHRzLnNwbGljZShudW1QYXJhbXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxsLndlaWdodHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0dXBsZXMucHVzaChbY2VsbC53ZWlnaHRzW2ldLCBpbnB1dFdlaWdodHNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXJpYWJsZXNfMS5iYXRjaFNldFZhbHVlKHR1cGxlcyk7XG4gICAgfTtcbiAgICBTdGFja2VkUk5OQ2VsbHMuY2xhc3NOYW1lID0gJ1N0YWNrZWRSTk5DZWxscyc7XG4gICAgcmV0dXJuIFN0YWNrZWRSTk5DZWxscztcbn0oUk5OQ2VsbCkpO1xuZXhwb3J0cy5TdGFja2VkUk5OQ2VsbHMgPSBTdGFja2VkUk5OQ2VsbHM7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoU3RhY2tlZFJOTkNlbGxzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY3VycmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgZ2VuZXJpY191dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2dlbmVyaWNfdXRpbHNcIik7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShjb25maWcsIGN1c3RvbU9iamVjdHMpIHtcbiAgICBpZiAoY3VzdG9tT2JqZWN0cyA9PT0gdm9pZCAwKSB7IGN1c3RvbU9iamVjdHMgPSB7fTsgfVxuICAgIHJldHVybiBnZW5lcmljX3V0aWxzXzEuZGVzZXJpYWxpemVLZXJhc09iamVjdChjb25maWcsIHRmanNfY29yZV8xLnNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsIGN1c3RvbU9iamVjdHMsICdsYXllcicpO1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXphdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgdG9wb2xvZ3lfMSA9IHJlcXVpcmUoXCIuLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciByZWN1cnJlbnRfMSA9IHJlcXVpcmUoXCIuL3JlY3VycmVudFwiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemF0aW9uXCIpO1xudmFyIFdyYXBwZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcmFwcGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdyYXBwZXIoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGF5ZXIgPSBjb25maWcubGF5ZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV3JhcHBlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVyLnByb3RvdHlwZSwgXCJ0cmFpbmFibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllci50cmFpbmFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXllciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci50cmFpbmFibGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZXIucHJvdG90eXBlLCBcInRyYWluYWJsZVdlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVyLnRyYWluYWJsZVdlaWdodHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVyLnByb3RvdHlwZSwgXCJub25UcmFpbmFibGVXZWlnaHRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllci5ub25UcmFpbmFibGVXZWlnaHRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlci5wcm90b3R5cGUsIFwidXBkYXRlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIuX3VwZGF0ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVyLnByb3RvdHlwZSwgXCJsb3NzZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVyLmxvc3NlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgV3JhcHBlci5wcm90b3R5cGUuZ2V0V2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIuZ2V0V2VpZ2h0cygpO1xuICAgIH07XG4gICAgV3JhcHBlci5wcm90b3R5cGUuc2V0V2VpZ2h0cyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XG4gICAgICAgIHRoaXMubGF5ZXIuc2V0V2VpZ2h0cyh3ZWlnaHRzKTtcbiAgICB9O1xuICAgIFdyYXBwZXIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICdsYXllcic6IHtcbiAgICAgICAgICAgICAgICAnY2xhc3NOYW1lJzogdGhpcy5sYXllci5nZXRDbGFzc05hbWUoKSxcbiAgICAgICAgICAgICAgICAnY29uZmlnJzogdGhpcy5sYXllci5nZXRDb25maWcoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBXcmFwcGVyLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcsIGN1c3RvbU9iamVjdHMpIHtcbiAgICAgICAgaWYgKGN1c3RvbU9iamVjdHMgPT09IHZvaWQgMCkgeyBjdXN0b21PYmplY3RzID0ge307IH1cbiAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gY29uZmlnWydsYXllciddO1xuICAgICAgICB2YXIgbGF5ZXIgPSBzZXJpYWxpemF0aW9uXzEuZGVzZXJpYWxpemUobGF5ZXJDb25maWcsIGN1c3RvbU9iamVjdHMpO1xuICAgICAgICBkZWxldGUgY29uZmlnWydsYXllciddO1xuICAgICAgICB2YXIgbmV3Q29uZmlnID0geyBsYXllcjogbGF5ZXIgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBuZXcgY2xzKG5ld0NvbmZpZyk7XG4gICAgfTtcbiAgICByZXR1cm4gV3JhcHBlcjtcbn0odG9wb2xvZ3lfMS5MYXllcikpO1xuZXhwb3J0cy5XcmFwcGVyID0gV3JhcHBlcjtcbnZhciBUaW1lRGlzdHJpYnV0ZWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lRGlzdHJpYnV0ZWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZURpc3RyaWJ1dGVkKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGltZURpc3RyaWJ1dGVkLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIGlucHV0U2hhcGUgPSBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaW1lRGlzdHJpYnV0ZWQgbGF5ZXIgZXhwZWN0cyBhbiBpbnB1dCBzaGFwZSA+PSAzRCwgYnV0IHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAoXCJpbnB1dCBzaGFwZSBcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dFNwZWMgPSBbeyBzaGFwZTogaW5wdXRTaGFwZSB9XTtcbiAgICAgICAgdmFyIGNoaWxkSW5wdXRTaGFwZSA9IFtpbnB1dFNoYXBlWzBdXS5jb25jYXQoaW5wdXRTaGFwZS5zbGljZSgyKSk7XG4gICAgICAgIGlmICghdGhpcy5sYXllci5idWlsdCkge1xuICAgICAgICAgICAgdGhpcy5sYXllci5idWlsZChjaGlsZElucHV0U2hhcGUpO1xuICAgICAgICAgICAgdGhpcy5sYXllci5idWlsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5idWlsZC5jYWxsKHRoaXMsIGlucHV0U2hhcGUpO1xuICAgIH07XG4gICAgVGltZURpc3RyaWJ1dGVkLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBpbnB1dFNoYXBlID0gZ2VuZXJpY191dGlscy5nZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIHZhciBjaGlsZElucHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXV0uY29uY2F0KGlucHV0U2hhcGUuc2xpY2UoMikpO1xuICAgICAgICB2YXIgY2hpbGRPdXRwdXRTaGFwZSA9IHRoaXMubGF5ZXIuY29tcHV0ZU91dHB1dFNoYXBlKGNoaWxkSW5wdXRTaGFwZSk7XG4gICAgICAgIHZhciB0aW1lc3RlcHMgPSBpbnB1dFNoYXBlWzFdO1xuICAgICAgICByZXR1cm4gW2NoaWxkT3V0cHV0U2hhcGVbMF0sIHRpbWVzdGVwc10uY29uY2F0KGNoaWxkT3V0cHV0U2hhcGUuc2xpY2UoMSkpO1xuICAgIH07XG4gICAgVGltZURpc3RyaWJ1dGVkLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKGlucHV0cywga3dhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IGdlbmVyaWNfdXRpbHMuZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5wdXRzLCBzdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gX3RoaXMubGF5ZXIuY2FsbChpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXQsIFtdXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcm5uT3V0cHV0cyA9IHJlY3VycmVudF8xLnJubihzdGVwLCBpbnB1dHMsIFtdLCBmYWxzZSwgbnVsbCwgbnVsbCwgZmFsc2UsIGlucHV0cy5zaGFwZVsxXSk7XG4gICAgICAgICAgICB2YXIgeSA9IHJubk91dHB1dHNbMV07XG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUaW1lRGlzdHJpYnV0ZWQuY2xhc3NOYW1lID0gJ1RpbWVEaXN0cmlidXRlZCc7XG4gICAgcmV0dXJuIFRpbWVEaXN0cmlidXRlZDtcbn0oV3JhcHBlcikpO1xuZXhwb3J0cy5UaW1lRGlzdHJpYnV0ZWQgPSBUaW1lRGlzdHJpYnV0ZWQ7XG50ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAucmVnaXN0ZXIoVGltZURpc3RyaWJ1dGVkKTtcbmV4cG9ydHMuVkFMSURfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFUyA9IFsnc3VtJywgJ211bCcsICdjb25jYXQnLCAnYXZlJ107XG5mdW5jdGlvbiBjaGVja0JpZGlyZWN0aW9uYWxNZXJnZU1vZGUodmFsdWUpIHtcbiAgICBnZW5lcmljX3V0aWxzLmNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoZXhwb3J0cy5WQUxJRF9CSURJUkVDVElPTkFMX01FUkdFX01PREVTLCAnQmlkaXJlY3Rpb25hbE1lcmdlTW9kZScsIHZhbHVlKTtcbn1cbmV4cG9ydHMuY2hlY2tCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlID0gY2hlY2tCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlO1xudmFyIEJpZGlyZWN0aW9uYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaWRpcmVjdGlvbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpZGlyZWN0aW9uYWwoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gY29uZmlnLmxheWVyLmdldENvbmZpZygpO1xuICAgICAgICBfdGhpcy5mb3J3YXJkTGF5ZXIgPVxuICAgICAgICAgICAgc2VyaWFsaXphdGlvbl8xLmRlc2VyaWFsaXplKHsgY2xhc3NOYW1lOiBjb25maWcubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksIGNvbmZpZzogbGF5ZXJDb25maWcgfSk7XG4gICAgICAgIGxheWVyQ29uZmlnWydnb0JhY2t3YXJkcyddID1cbiAgICAgICAgICAgIGxheWVyQ29uZmlnWydnb0JhY2t3YXJkcyddID09PSB0cnVlID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICBfdGhpcy5iYWNrd2FyZExheWVyID1cbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25fMS5kZXNlcmlhbGl6ZSh7IGNsYXNzTmFtZTogY29uZmlnLmxheWVyLmdldENsYXNzTmFtZSgpLCBjb25maWc6IGxheWVyQ29uZmlnIH0pO1xuICAgICAgICBfdGhpcy5mb3J3YXJkTGF5ZXIubmFtZSA9ICdmb3J3YXJkXycgKyBfdGhpcy5mb3J3YXJkTGF5ZXIubmFtZTtcbiAgICAgICAgX3RoaXMuYmFja3dhcmRMYXllci5uYW1lID0gJ2JhY2t3YXJkXycgKyBfdGhpcy5iYWNrd2FyZExheWVyLm5hbWU7XG4gICAgICAgIGNoZWNrQmlkaXJlY3Rpb25hbE1lcmdlTW9kZShjb25maWcubWVyZ2VNb2RlKTtcbiAgICAgICAgX3RoaXMubWVyZ2VNb2RlID0gY29uZmlnLm1lcmdlTW9kZTtcbiAgICAgICAgaWYgKGNvbmZpZy53ZWlnaHRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignd2VpZ2h0cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQmlkaXJlY3Rpb25hbCBsYXllciB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX3N0YXRlZnVsID0gY29uZmlnLmxheWVyLnN0YXRlZnVsO1xuICAgICAgICBfdGhpcy5yZXR1cm5TZXF1ZW5jZXMgPSBjb25maWcubGF5ZXIucmV0dXJuU2VxdWVuY2VzO1xuICAgICAgICBfdGhpcy5yZXR1cm5TdGF0ZSA9IGNvbmZpZy5sYXllci5yZXR1cm5TdGF0ZTtcbiAgICAgICAgX3RoaXMuc3VwcG9ydHNNYXNraW5nID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX3RyYWluYWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzLmlucHV0U3BlYyA9IGNvbmZpZy5sYXllci5pbnB1dFNwZWM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpZGlyZWN0aW9uYWwucHJvdG90eXBlLCBcInRyYWluYWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWluYWJsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWluYWJsZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9yd2FyZExheWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmRMYXllci50cmFpbmFibGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2t3YXJkTGF5ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMYXllci50cmFpbmFibGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmlkaXJlY3Rpb25hbC5wcm90b3R5cGUuZ2V0V2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLmdldFdlaWdodHMoKS5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLmdldFdlaWdodHMoKSk7XG4gICAgfTtcbiAgICBCaWRpcmVjdGlvbmFsLnByb3RvdHlwZS5zZXRXZWlnaHRzID0gZnVuY3Rpb24gKHdlaWdodHMpIHtcbiAgICAgICAgdmFyIG51bVdlaWdodHMgPSB3ZWlnaHRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG51bWVpZ2h0c092ZXIyID0gTWF0aC5mbG9vcihudW1XZWlnaHRzIC8gMik7XG4gICAgICAgIHRoaXMuZm9yd2FyZExheWVyLnNldFdlaWdodHMod2VpZ2h0cy5zbGljZSgwLCBudW1laWdodHNPdmVyMikpO1xuICAgICAgICB0aGlzLmJhY2t3YXJkTGF5ZXIuc2V0V2VpZ2h0cyh3ZWlnaHRzLnNsaWNlKG51bWVpZ2h0c092ZXIyKSk7XG4gICAgfTtcbiAgICBCaWRpcmVjdGlvbmFsLnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGUgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICB2YXIgbGF5ZXJTaGFwZXMgPSB0aGlzLmZvcndhcmRMYXllci5jb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkobGF5ZXJTaGFwZXMpICYmIEFycmF5LmlzQXJyYXkobGF5ZXJTaGFwZXNbMF0pKSkge1xuICAgICAgICAgICAgbGF5ZXJTaGFwZXMgPSBbbGF5ZXJTaGFwZXNdO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyU2hhcGVzID0gbGF5ZXJTaGFwZXM7XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlcztcbiAgICAgICAgdmFyIHN0YXRlU2hhcGU7XG4gICAgICAgIGlmICh0aGlzLnJldHVyblN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZVNoYXBlID0gbGF5ZXJTaGFwZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZSA9IGxheWVyU2hhcGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSBsYXllclNoYXBlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgICAgICBpZiAodGhpcy5tZXJnZU1vZGUgPT09ICdjb25jYXQnKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXSAqPSAyO1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVzID0gW291dHB1dFNoYXBlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1lcmdlTW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZXMgPSBbb3V0cHV0U2hhcGUsIG91dHB1dFNoYXBlLnNsaWNlKCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVzID0gW291dHB1dFNoYXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXR1cm5TdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVyZ2VNb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGVzLmNvbmNhdChzdGF0ZVNoYXBlKS5jb25jYXQoc3RhdGVTaGFwZS5zbGljZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbb3V0cHV0U2hhcGVdLmNvbmNhdChzdGF0ZVNoYXBlKS5jb25jYXQoc3RhdGVTaGFwZS5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KG91dHB1dFNoYXBlcyk7XG4gICAgfTtcbiAgICBCaWRpcmVjdGlvbmFsLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChpbnB1dHMsIGt3YXJncykge1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKGt3YXJncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbml0aWFsU3RhdGUgPSBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IGlucHV0cy5zbGljZSgxKTtcbiAgICAgICAgICAgIGlucHV0cyA9IGlucHV0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFN0YXRlID09IG51bGwgfHwgaW5pdGlhbFN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGFwcGx5T3V0cHV0cyA9IF9zdXBlci5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLCBpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlPdXRwdXRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ1RoZSBzdXBwb3J0IGZvciBpbml0aWFsIHN0YXRlcyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yICcgK1xuICAgICAgICAgICAgICAgICdCaWRpcmVjdGlvbmFsIGxheWVycyB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpZGlyZWN0aW9uYWwucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGt3YXJnc1snbWFzayddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignVGhlIHN1cHBvcnQgZm9yIG1hc2tpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciAnICtcbiAgICAgICAgICAgICAgICAgICAgJ0JpZGlyZWN0aW9uYWwgbGF5ZXJzIHlldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcignVGhlIHN1cHBvcnQgZm9yIGluaXRpYWwgc3RhdGVzIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICdCaWRpcmVjdGlvbmFsIGxheWVycyB5ZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeSA9IF90aGlzLmZvcndhcmRMYXllci5jYWxsKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgIHZhciB5UmV2ID0gX3RoaXMuYmFja3dhcmRMYXllci5jYWxsKGlucHV0cywga3dhcmdzKTtcbiAgICAgICAgICAgIHZhciBzdGF0ZXM7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh5KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSB5LnNsaWNlKDEpLmNvbmNhdCh5UmV2LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkgPSB5WzBdO1xuICAgICAgICAgICAgICAgIHlSZXYgPSB5UmV2WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnJldHVyblNlcXVlbmNlcykge1xuICAgICAgICAgICAgICAgIHlSZXYgPSB0ZmMucmV2ZXJzZSh5UmV2LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMubWVyZ2VNb2RlID09PSAnY29uY2F0Jykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IEsuY29uY2F0ZW5hdGUoW3ksIHlSZXZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm1lcmdlTW9kZSA9PT0gJ3N1bScpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0ZmMuYWRkKHksIHlSZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMubWVyZ2VNb2RlID09PSAnYXZlJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IEsuc2NhbGFyVGltZXNBcnJheShLLmdldFNjYWxhcigwLjUpLCB0ZmMuYWRkKHksIHlSZXYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm1lcmdlTW9kZSA9PT0gJ211bCcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0ZmMubXVsKHksIHlSZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMubWVyZ2VNb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBbeSwgeVJldl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubWVyZ2VNb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5jb25jYXQoc3RhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXRdLmNvbmNhdChzdGF0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCaWRpcmVjdGlvbmFsLnByb3RvdHlwZS5yZXNldFN0YXRlcyA9IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkTGF5ZXIucmVzZXRTdGF0ZXMoKTtcbiAgICAgICAgdGhpcy5iYWNrd2FyZExheWVyLnJlc2V0U3RhdGVzKCk7XG4gICAgfTtcbiAgICBCaWRpcmVjdGlvbmFsLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChpbnB1dFNoYXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIEsubmFtZVNjb3BlKHRoaXMuZm9yd2FyZExheWVyLm5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmZvcndhcmRMYXllci5idWlsZChpbnB1dFNoYXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEsubmFtZVNjb3BlKHRoaXMuYmFja3dhcmRMYXllci5uYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5iYWNrd2FyZExheWVyLmJ1aWxkKGlucHV0U2hhcGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmlkaXJlY3Rpb25hbC5wcm90b3R5cGUsIFwidHJhaW5hYmxlV2VpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuYmFja3dhcmRMYXllci50cmFpbmFibGVXZWlnaHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpZGlyZWN0aW9uYWwucHJvdG90eXBlLCBcIm5vblRyYWluYWJsZVdlaWdodHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcndhcmRMYXllci5ub25UcmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJpZGlyZWN0aW9uYWwucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICdtZXJnZU1vZGUnOiB0aGlzLm1lcmdlTW9kZSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VDb25maWcgPSBfc3VwZXIucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBCaWRpcmVjdGlvbmFsLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY2xzLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHJubkxheWVyID0gc2VyaWFsaXphdGlvbl8xLmRlc2VyaWFsaXplKGNvbmZpZ1snbGF5ZXInXSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWdbJ2xheWVyJ107XG4gICAgICAgIGlmIChjb25maWdbJ251bUNvbnN0YW50cyddICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiRGVzZXJpYWxpemF0aW9uIG9mIGEgQmlkaXJlY3Rpb25hbCBsYXllciB3aXRoIG51bUNvbnN0YW50cyBcIiArXG4gICAgICAgICAgICAgICAgXCJwcmVzZW50IGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICAgICAgICBuZXdDb25maWdbJ2xheWVyJ10gPSBybm5MYXllcjtcbiAgICAgICAgcmV0dXJuIG5ldyBjbHMobmV3Q29uZmlnKTtcbiAgICB9O1xuICAgIEJpZGlyZWN0aW9uYWwuY2xhc3NOYW1lID0gJ0JpZGlyZWN0aW9uYWwnO1xuICAgIHJldHVybiBCaWRpcmVjdGlvbmFsO1xufShXcmFwcGVyKSk7XG5leHBvcnRzLkJpZGlyZWN0aW9uYWwgPSBCaWRpcmVjdGlvbmFsO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEJpZGlyZWN0aW9uYWwpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcHBlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZjID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuZnVuY3Rpb24gbDJOb3JtYWxpemUoeCwgYXhpcykge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNxdWFyZVN1bSA9IHRmYy5zdW0oSy5zcXVhcmUoeCksIGF4aXMsIHRydWUpO1xuICAgICAgICB2YXIgZXBzaWxvblRlbnNvciA9IEsuc2NhbGFyVGltZXNBcnJheSh0ZmpzX2NvcmVfMS5zY2FsYXIoSy5lcHNpbG9uKCkpLCB0ZmMub25lc0xpa2UoeCkpO1xuICAgICAgICB2YXIgbm9ybSA9IHRmYy5zcXJ0KHRmYy5tYXhpbXVtKHNxdWFyZVN1bSwgZXBzaWxvblRlbnNvcikpO1xuICAgICAgICByZXR1cm4gdGZjLmRpdih4LCBub3JtKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubDJOb3JtYWxpemUgPSBsMk5vcm1hbGl6ZTtcbmZ1bmN0aW9uIG1lYW5TcXVhcmVkRXJyb3IoeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZjLm1lYW4oSy5zcXVhcmUodGZjLnN1Yih5UHJlZCwgeVRydWUpKSwgLTEpOyB9KTtcbn1cbmV4cG9ydHMubWVhblNxdWFyZWRFcnJvciA9IG1lYW5TcXVhcmVkRXJyb3I7XG5mdW5jdGlvbiBtZWFuQWJzb2x1dGVFcnJvcih5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0ZmMubWVhbih0ZmMuYWJzKHRmYy5zdWIoeVByZWQsIHlUcnVlKSksIC0xKTsgfSk7XG59XG5leHBvcnRzLm1lYW5BYnNvbHV0ZUVycm9yID0gbWVhbkFic29sdXRlRXJyb3I7XG5mdW5jdGlvbiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IoeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlmZiA9IHRmYy5zdWIoeVRydWUsIHlQcmVkKTtcbiAgICAgICAgdmFyIGNsaXBwZWRUcnVlID0gdGZjLmNsaXBCeVZhbHVlKHRmYy5hYnMoeVRydWUpLCBLLmVwc2lsb24oKSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHZhciBhYnNSZXN1bHQgPSB0ZmMuYWJzKHRmYy5kaXYoZGlmZiwgY2xpcHBlZFRydWUpKTtcbiAgICAgICAgcmV0dXJuIEsuc2NhbGFyVGltZXNBcnJheShLLmdldFNjYWxhcigxMDAuMCksIHRmYy5tZWFuKGFic1Jlc3VsdCwgLTEpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yID0gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yO1xuZnVuY3Rpb24gbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yKHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9uZSA9IEsuZ2V0U2NhbGFyKDEuMCk7XG4gICAgICAgIHZhciBjbGlwcGVkUHJlZCA9IHRmYy5jbGlwQnlWYWx1ZSh5UHJlZCwgSy5lcHNpbG9uKCksIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICB2YXIgZmlyc3RMb2cgPSB0ZmMubG9nKEsuc2NhbGFyUGx1c0FycmF5KG9uZSwgY2xpcHBlZFByZWQpKTtcbiAgICAgICAgdmFyIGNsaXBwZWRUcnVlID0gdGZjLmNsaXBCeVZhbHVlKHlUcnVlLCBLLmVwc2lsb24oKSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHZhciBzZWNvbmRMb2cgPSB0ZmMubG9nKEsuc2NhbGFyUGx1c0FycmF5KG9uZSwgY2xpcHBlZFRydWUpKTtcbiAgICAgICAgcmV0dXJuIHRmYy5tZWFuKEsuc3F1YXJlKHRmYy5zdWIoZmlyc3RMb2csIHNlY29uZExvZykpLCAtMSk7XG4gICAgfSk7XG59XG5leHBvcnRzLm1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvciA9IG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcjtcbmZ1bmN0aW9uIHNxdWFyZWRIaW5nZSh5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB6ZXJvVGVuc29yID0gSy5nZXRTY2FsYXIoMC4wKTtcbiAgICAgICAgdmFyIG9uZSA9IEsuZ2V0U2NhbGFyKDEuMCk7XG4gICAgICAgIHZhciBtYXhSZXN1bHQgPSB0ZmMubWF4aW11bSh6ZXJvVGVuc29yLCB0ZmMuc3ViKG9uZSwgdGZjLm11bCh5VHJ1ZSwgeVByZWQpKSk7XG4gICAgICAgIHJldHVybiB0ZmMubWVhbihLLnNxdWFyZShtYXhSZXN1bHQpLCAtMSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnNxdWFyZWRIaW5nZSA9IHNxdWFyZWRIaW5nZTtcbmZ1bmN0aW9uIGhpbmdlKHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHplcm9UZW5zb3IgPSBLLmdldFNjYWxhcigwLjApO1xuICAgICAgICB2YXIgb25lID0gSy5nZXRTY2FsYXIoMS4wKTtcbiAgICAgICAgdmFyIG1heFJlc3VsdCA9IHRmYy5tYXhpbXVtKHplcm9UZW5zb3IsIHRmYy5zdWIob25lLCB0ZmMubXVsKHlUcnVlLCB5UHJlZCkpKTtcbiAgICAgICAgcmV0dXJuIHRmYy5tZWFuKG1heFJlc3VsdCwgLTEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5oaW5nZSA9IGhpbmdlO1xuZnVuY3Rpb24gY2F0ZWdvcmljYWxIaW5nZSh5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB6ZXJvVGVuc29yID0gSy5nZXRTY2FsYXIoMC4wKTtcbiAgICAgICAgdmFyIG9uZSA9IEsuZ2V0U2NhbGFyKDEuMCk7XG4gICAgICAgIHZhciBwb3MgPSB0ZmMuc3VtKHRmYy5tdWwoeVRydWUsIHlQcmVkKSwgLTEpO1xuICAgICAgICB2YXIgbmVnID0gdGZjLm1heCh0ZmMubXVsKHRmYy5zdWIob25lLCB5VHJ1ZSksIHlQcmVkKSwgLTEpO1xuICAgICAgICByZXR1cm4gdGZjLm1heGltdW0oemVyb1RlbnNvciwgSy5zY2FsYXJQbHVzQXJyYXkob25lLCB0ZmMuc3ViKG5lZywgcG9zKSkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jYXRlZ29yaWNhbEhpbmdlID0gY2F0ZWdvcmljYWxIaW5nZTtcbmZ1bmN0aW9uIGxvZ2Nvc2goeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nMiA9IEsuZ2V0U2NhbGFyKE1hdGgubG9nKDIuMCkpO1xuICAgICAgICB2YXIgcHJlZGljdGlvbkRpZmYgPSB0ZmMuc3ViKHlQcmVkLCB5VHJ1ZSk7XG4gICAgICAgIHZhciBsb2djb3NoUmVzdWx0ID0gdGZjLnN1Yih0ZmMuYWRkKHByZWRpY3Rpb25EaWZmLCB0ZmMuc29mdHBsdXMoSy5zY2FsYXJUaW1lc0FycmF5KEsuZ2V0U2NhbGFyKC0yLjApLCBwcmVkaWN0aW9uRGlmZikpKSwgbG9nMik7XG4gICAgICAgIHJldHVybiB0ZmMubWVhbihsb2djb3NoUmVzdWx0LCAtMSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvZ2Nvc2ggPSBsb2djb3NoO1xuZnVuY3Rpb24gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkodGFyZ2V0LCBvdXRwdXQsIGZyb21Mb2dpdHMpIHtcbiAgICBpZiAoZnJvbUxvZ2l0cyA9PT0gdm9pZCAwKSB7IGZyb21Mb2dpdHMgPSBmYWxzZTsgfVxuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZyb21Mb2dpdHMpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHRmYy5zb2Z0bWF4KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0U3VtID0gdGZjLnN1bShvdXRwdXQsIEsuc2hhcGUob3V0cHV0KS5sZW5ndGggLSAxLCB0cnVlKTtcbiAgICAgICAgICAgIG91dHB1dCA9IHRmYy5kaXYob3V0cHV0LCBvdXRwdXRTdW0pO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCA9IHRmYy5jbGlwQnlWYWx1ZShvdXRwdXQsIEsuZXBzaWxvbigpLCAxIC0gSy5lcHNpbG9uKCkpO1xuICAgICAgICByZXR1cm4gdGZjLm5lZyh0ZmMuc3VtKHRmYy5tdWwodGFyZ2V0LnRvRmxvYXQoKSwgdGZjLmxvZyhvdXRwdXQpKSwgSy5zaGFwZShvdXRwdXQpLmxlbmd0aCAtIDEpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkgPSBjYXRlZ29yaWNhbENyb3NzZW50cm9weTtcbmZ1bmN0aW9uIHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KHRhcmdldCwgb3V0cHV0LCBmcm9tTG9naXRzKSB7XG4gICAgaWYgKGZyb21Mb2dpdHMgPT09IHZvaWQgMCkgeyBmcm9tTG9naXRzID0gZmFsc2U7IH1cbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbGF0VGFyZ2V0ID0gdGZjLmZsb29yKEsuZmxhdHRlbih0YXJnZXQpKS50b0ludCgpO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBLLnNoYXBlKG91dHB1dCk7XG4gICAgICAgIHZhciBvbmVIb3RUYXJnZXQgPSB0ZmMub25lSG90KGZsYXRUYXJnZXQsIG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgLnJlc2hhcGUob3V0cHV0U2hhcGUpO1xuICAgICAgICByZXR1cm4gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkob25lSG90VGFyZ2V0LCBvdXRwdXQsIGZyb21Mb2dpdHMpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSA9IHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5O1xuZnVuY3Rpb24gc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHModGFyZ2V0LCBvdXRwdXQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXhPdXRwdXQgPSB0ZmMubWF4aW11bShvdXRwdXQsIHRmYy56ZXJvc0xpa2Uob3V0cHV0KSk7XG4gICAgICAgIHZhciBvdXRwdXRYVGFyZ2V0ID0gdGZjLm11bChvdXRwdXQsIHRhcmdldCk7XG4gICAgICAgIHZhciBzaWdtb2lkT3V0cHV0ID0gdGZjLmxvZyh0ZmMuYWRkKEsuZ2V0U2NhbGFyKDEpLCB0ZmMuZXhwKHRmYy5uZWcodGZjLmFicyhvdXRwdXQpKSkpKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRmYy5hZGQodGZjLnN1YihtYXhPdXRwdXQsIG91dHB1dFhUYXJnZXQpLCBzaWdtb2lkT3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHMgPSBzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0cztcbmZ1bmN0aW9uIGJpbmFyeUNyb3NzZW50cm9weSh5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5O1xuICAgICAgICB5ID0gdGZjLmNsaXBCeVZhbHVlKHlQcmVkLCBLLmVwc2lsb24oKSwgMSAtIEsuZXBzaWxvbigpKTtcbiAgICAgICAgeSA9IHRmYy5sb2codGZjLmRpdih5LCB0ZmMuc3ViKHRmYy5vbmVzTGlrZSh5KSwgeSkpKTtcbiAgICAgICAgcmV0dXJuIHRmYy5tZWFuKHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKHlUcnVlLCB5KSwgLTEpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5iaW5hcnlDcm9zc2VudHJvcHkgPSBiaW5hcnlDcm9zc2VudHJvcHk7XG5mdW5jdGlvbiBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlKHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsaXBwZWRUcnVlID0gdGZjLmNsaXBCeVZhbHVlKHlUcnVlLCBLLmVwc2lsb24oKSwgMSk7XG4gICAgICAgIHZhciBjbGlwcGVkUHJlZCA9IHRmYy5jbGlwQnlWYWx1ZSh5UHJlZCwgSy5lcHNpbG9uKCksIDEpO1xuICAgICAgICByZXR1cm4gdGZjLnN1bSh0ZmMubXVsKHlUcnVlLCB0ZmMubG9nKHRmYy5kaXYoY2xpcHBlZFRydWUsIGNsaXBwZWRQcmVkKSkpLCAtMSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2UgPSBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlO1xuZnVuY3Rpb24gcG9pc3Nvbih5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2dQcmVkID0gdGZjLmxvZyhLLnNjYWxhclBsdXNBcnJheShLLmdldFNjYWxhcihLLmVwc2lsb24oKSksIHlQcmVkKSk7XG4gICAgICAgIHJldHVybiB0ZmMubWVhbih0ZmMuc3ViKHlQcmVkLCB0ZmMubXVsKHlUcnVlLCBsb2dQcmVkKSksIC0xKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucG9pc3NvbiA9IHBvaXNzb247XG5mdW5jdGlvbiBjb3NpbmVQcm94aW1pdHkoeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJ1ZU5vcm1hbGl6ZWQgPSBsMk5vcm1hbGl6ZSh5VHJ1ZSwgLTEpO1xuICAgICAgICB2YXIgcHJlZE5vcm1hbGl6ZWQgPSBsMk5vcm1hbGl6ZSh5UHJlZCwgLTEpO1xuICAgICAgICB2YXIgdHJ1ZVhQcmVkID0gdGZjLm11bCh0cnVlTm9ybWFsaXplZCwgcHJlZE5vcm1hbGl6ZWQpO1xuICAgICAgICByZXR1cm4gdGZjLm5lZyh0ZmMuc3VtKHRydWVYUHJlZCwgLTEpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29zaW5lUHJveGltaXR5ID0gY29zaW5lUHJveGltaXR5O1xuZXhwb3J0cy5tc2UgPSBtZWFuU3F1YXJlZEVycm9yO1xuZXhwb3J0cy5NU0UgPSBtZWFuU3F1YXJlZEVycm9yO1xuZXhwb3J0cy5tYWUgPSBtZWFuQWJzb2x1dGVFcnJvcjtcbmV4cG9ydHMuTUFFID0gbWVhbkFic29sdXRlRXJyb3I7XG5leHBvcnRzLm1hcGUgPSBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I7XG5leHBvcnRzLk1BUEUgPSBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I7XG5leHBvcnRzLm1zbGUgPSBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3I7XG5leHBvcnRzLk1TTEUgPSBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3I7XG5leHBvcnRzLmtsZCA9IGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2U7XG5leHBvcnRzLktMRCA9IGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2U7XG5leHBvcnRzLmNvc2luZSA9IGNvc2luZVByb3hpbWl0eTtcbmZ1bmN0aW9uIGdldChpZGVudGlmaWVyT3JGbikge1xuICAgIHZhciBsb3NzZXNNYXAgPSB7XG4gICAgICAgIG1lYW5TcXVhcmVkRXJyb3I6IG1lYW5TcXVhcmVkRXJyb3IsXG4gICAgICAgIG1lYW5BYnNvbHV0ZUVycm9yOiBtZWFuQWJzb2x1dGVFcnJvcixcbiAgICAgICAgbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yOiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IsXG4gICAgICAgIG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcjogbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yLFxuICAgICAgICBzcXVhcmVkSGluZ2U6IHNxdWFyZWRIaW5nZSxcbiAgICAgICAgaGluZ2U6IGhpbmdlLFxuICAgICAgICBjYXRlZ29yaWNhbEhpbmdlOiBjYXRlZ29yaWNhbEhpbmdlLFxuICAgICAgICBsb2djb3NoOiBsb2djb3NoLFxuICAgICAgICBjYXRlZ29yaWNhbENyb3NzZW50cm9weTogY2F0ZWdvcmljYWxDcm9zc2VudHJvcHksXG4gICAgICAgIHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OiBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSxcbiAgICAgICAgYmluYXJ5Q3Jvc3NlbnRyb3B5OiBiaW5hcnlDcm9zc2VudHJvcHksXG4gICAgICAgIGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2U6IGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2UsXG4gICAgICAgIHBvaXNzb246IHBvaXNzb24sXG4gICAgICAgIGNvc2luZVByb3hpbWl0eTogY29zaW5lUHJveGltaXR5XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXJPckZuID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaWRlbnRpZmllck9yRm4gaW4gbG9zc2VzTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9zc2VzTWFwW2lkZW50aWZpZXJPckZuXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlVua25vd24gbG9zcyBcIiArIGlkZW50aWZpZXJPckZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyT3JGbjtcbiAgICB9XG59XG5leHBvcnRzLmdldCA9IGdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvc3Nlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmMgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgbG9zc2VzXzEgPSByZXF1aXJlKFwiLi9sb3NzZXNcIik7XG52YXIgbG9zc2VzXzIgPSByZXF1aXJlKFwiLi9sb3NzZXNcIik7XG5mdW5jdGlvbiBiaW5hcnlBY2N1cmFjeSh5VHJ1ZSwgeVByZWQpIHtcbiAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSBLLnNjYWxhclRpbWVzQXJyYXkoSy5nZXRTY2FsYXIoMC41KSwgdGZjLm9uZXNMaWtlKHlQcmVkKSk7XG4gICAgICAgIHZhciB5UHJlZFRocmVzaG9sZGVkID0gSy5jYXN0KHRmYy5ncmVhdGVyKHlQcmVkLCB0aHJlc2hvbGQpLCB5VHJ1ZS5kdHlwZSk7XG4gICAgICAgIHJldHVybiB0ZmMubWVhbih0ZmMuZXF1YWwoeVRydWUsIHlQcmVkVGhyZXNob2xkZWQpLCAtMSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmJpbmFyeUFjY3VyYWN5ID0gYmluYXJ5QWNjdXJhY3k7XG5mdW5jdGlvbiBjYXRlZ29yaWNhbEFjY3VyYWN5KHlUcnVlLCB5UHJlZCkge1xuICAgIHJldHVybiB0ZmpzX2NvcmVfMS50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIEsuY2FzdCh0ZmMuZXF1YWwodGZjLmFyZ01heCh5VHJ1ZSwgLTEpLCB0ZmMuYXJnTWF4KHlQcmVkLCAtMSkpLCAnZmxvYXQzMicpOyB9KTtcbn1cbmV4cG9ydHMuY2F0ZWdvcmljYWxBY2N1cmFjeSA9IGNhdGVnb3JpY2FsQWNjdXJhY3k7XG5mdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkoeVRydWUsIHlQcmVkKSB7XG4gICAgcmV0dXJuIGxvc3Nlc18yLmJpbmFyeUNyb3NzZW50cm9weSh5VHJ1ZSwgeVByZWQpO1xufVxuZXhwb3J0cy5iaW5hcnlDcm9zc2VudHJvcHkgPSBiaW5hcnlDcm9zc2VudHJvcHk7XG5mdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5KHlUcnVlLCB5UHJlZCkge1xuICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCk7XG59XG5leHBvcnRzLnNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3kgPSBzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5O1xuZnVuY3Rpb24gdG9wS0NhdGVnb3JpY2FsQWNjdXJhY3koeVRydWUsIHlQcmVkKSB7XG4gICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoKTtcbn1cbmV4cG9ydHMudG9wS0NhdGVnb3JpY2FsQWNjdXJhY3kgPSB0b3BLQ2F0ZWdvcmljYWxBY2N1cmFjeTtcbmZ1bmN0aW9uIHNwYXJzZVRvcEtDYXRlZ29yaWNhbEFjY3VyYWN5KHlUcnVlLCB5UHJlZCkge1xuICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RJbXBsZW1lbnRlZEVycm9yKCk7XG59XG5leHBvcnRzLnNwYXJzZVRvcEtDYXRlZ29yaWNhbEFjY3VyYWN5ID0gc3BhcnNlVG9wS0NhdGVnb3JpY2FsQWNjdXJhY3k7XG5leHBvcnRzLm1zZSA9IGxvc3Nlc18xLm1lYW5TcXVhcmVkRXJyb3I7XG5leHBvcnRzLk1TRSA9IGxvc3Nlc18xLm1lYW5TcXVhcmVkRXJyb3I7XG5leHBvcnRzLm1hZSA9IGxvc3Nlc18xLm1lYW5BYnNvbHV0ZUVycm9yO1xuZXhwb3J0cy5NQUUgPSBsb3NzZXNfMS5tZWFuQWJzb2x1dGVFcnJvcjtcbmV4cG9ydHMubWFwZSA9IGxvc3Nlc18xLm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjtcbmV4cG9ydHMuTUFQRSA9IGxvc3Nlc18xLm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjtcbmV4cG9ydHMuY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkgPSBsb3NzZXNfMS5jYXRlZ29yaWNhbENyb3NzZW50cm9weTtcbmV4cG9ydHMuY29zaW5lID0gbG9zc2VzXzEuY29zaW5lUHJveGltaXR5O1xuZXhwb3J0cy5zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSA9IGxvc3Nlc18xLnNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5O1xuZnVuY3Rpb24gZ2V0KGlkZW50aWZpZXIpIHtcbiAgICB2YXIgbWV0cmljc01hcCA9IHtcbiAgICAgICAgYmluYXJ5QWNjdXJhY3k6IGJpbmFyeUFjY3VyYWN5LFxuICAgICAgICBjYXRlZ29yaWNhbEFjY3VyYWN5OiBjYXRlZ29yaWNhbEFjY3VyYWN5LFxuICAgICAgICBjYXRlZ29yaWNhbENyb3NzZW50cm9weTogZXhwb3J0cy5jYXRlZ29yaWNhbENyb3NzZW50cm9weSxcbiAgICAgICAgc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6IGV4cG9ydHMuc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHksXG4gICAgICAgIG1zZTogZXhwb3J0cy5tc2UsXG4gICAgICAgIE1TRTogZXhwb3J0cy5NU0UsXG4gICAgICAgIG1hZTogZXhwb3J0cy5tYWUsXG4gICAgICAgIE1BRTogZXhwb3J0cy5NQUUsXG4gICAgICAgIG1hcGU6IGV4cG9ydHMubWFwZSxcbiAgICAgICAgTUFQRTogZXhwb3J0cy5NQVBFLFxuICAgICAgICBjb3NpbmU6IGV4cG9ydHMuY29zaW5lLFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAnc3RyaW5nJyAmJiBpZGVudGlmaWVyIGluIG1ldHJpY3NNYXApIHtcbiAgICAgICAgcmV0dXJuIG1ldHJpY3NNYXBbaWRlbnRpZmllcl07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpZGVudGlmaWVyICE9PSAnc3RyaW5nJyAmJiBpZGVudGlmaWVyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlVua25vd24gbWV0cmljIFwiICsgaWRlbnRpZmllcik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXQgPSBnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZmpzX2NvcmVfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgSyA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvdGZqc19iYWNrZW5kXCIpO1xudmFyIHRvcG9sb2d5XzEgPSByZXF1aXJlKFwiLi9lbmdpbmUvdG9wb2xvZ3lcIik7XG52YXIgdHJhaW5pbmdfMSA9IHJlcXVpcmUoXCIuL2VuZ2luZS90cmFpbmluZ1wiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi9sYXllcnMvc2VyaWFsaXphdGlvblwiKTtcbnZhciBnZW5lcmljX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvZ2VuZXJpY191dGlsc1wiKTtcbnZhciBzZXJpYWxpemF0aW9uX3V0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlscy9zZXJpYWxpemF0aW9uX3V0aWxzXCIpO1xuZnVuY3Rpb24gbW9kZWxGcm9tSlNPTihtb2RlbEFuZFdlaWdodHNDb25maWcsIGN1c3RvbU9iamVjdHMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2RlbFRvcG9sb2d5LCB0c0NvbmZpZywgbW9kZWwsIHdlaWdodFZhbHVlcywgdW5pcXVlV2VpZ2h0VmFsdWVzLCBfaSwgX2EsIHdlaWdodCwgc2tpcE1pc21hdGNoZXMsIGlzTmFtZWRUZW5zb3JNYXA7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9wb2xvZ3kgPSBtb2RlbEFuZFdlaWdodHNDb25maWcubW9kZWxUb3BvbG9neTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsVG9wb2xvZ3lbJ21vZGVsX2NvbmZpZyddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVG9wb2xvZ3kgPSBtb2RlbFRvcG9sb2d5Wydtb2RlbF9jb25maWcnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0c0NvbmZpZyA9IHNlcmlhbGl6YXRpb25fdXRpbHNfMS5jb252ZXJ0UHl0aG9uaWNUb1RzKG1vZGVsVG9wb2xvZ3kpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IHNlcmlhbGl6YXRpb25fMS5kZXNlcmlhbGl6ZSh0c0NvbmZpZywgY3VzdG9tT2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1vZGVsQW5kV2VpZ2h0c0NvbmZpZy53ZWlnaHRzTWFuaWZlc3QgIT0gbnVsbCkpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGZqc19jb3JlXzEuaW8ubG9hZFdlaWdodHMobW9kZWxBbmRXZWlnaHRzQ29uZmlnLndlaWdodHNNYW5pZmVzdCwgbW9kZWxBbmRXZWlnaHRzQ29uZmlnLnBhdGhQcmVmaXgsIG1vZGVsLndlaWdodHMubWFwKGZ1bmN0aW9uICh3ZWlnaHQpIHsgcmV0dXJuIHdlaWdodC5vcmlnaW5hbE5hbWU7IH0pKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRWYWx1ZXMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZVdlaWdodFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2EgPSBtb2RlbC53ZWlnaHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlV2VpZ2h0VmFsdWVzW3dlaWdodC5vcmlnaW5hbE5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRWYWx1ZXNbd2VpZ2h0Lm9yaWdpbmFsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2tpcE1pc21hdGNoZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpc05hbWVkVGVuc29yTWFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwubG9hZFdlaWdodHModW5pcXVlV2VpZ2h0VmFsdWVzLCBza2lwTWlzbWF0Y2hlcywgaXNOYW1lZFRlbnNvck1hcCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiwgbW9kZWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubW9kZWxGcm9tSlNPTiA9IG1vZGVsRnJvbUpTT047XG5mdW5jdGlvbiBsb2FkTW9kZWxJbnRlcm5hbChwYXRoT3JJT0hhbmRsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVycztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoT3JJT0hhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMgPSB0ZmpzX2NvcmVfMS5pby5nZXRMb2FkSGFuZGxlcnMocGF0aE9ySU9IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2godGZqc19jb3JlXzEuaW8uYnJvd3NlckhUVFBSZXF1ZXN0KHBhdGhPcklPSGFuZGxlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSAoXCIgKyBoYW5kbGVycy5sZW5ndGggKyBcIikgbG9hZCBoYW5kbGVycyBmb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwiVVJMICdcIiArIHBhdGhPcklPSGFuZGxlciArIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGhPcklPSGFuZGxlciA9IGhhbmRsZXJzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyLCBsb2FkTW9kZWxGcm9tSU9IYW5kbGVyKHBhdGhPcklPSGFuZGxlcildO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZE1vZGVsSW50ZXJuYWwgPSBsb2FkTW9kZWxJbnRlcm5hbDtcbmZ1bmN0aW9uIGxvYWRNb2RlbEZyb21JT0hhbmRsZXIoaGFuZGxlciwgY3VzdG9tT2JqZWN0cykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFydGlmYWN0cywgbW9kZWxUb3BvbG9neSwgbW9kZWwsIHNraXBNaXNtYXRjaCwgaXNOYW1lZFRlbnNvck1hcDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIubG9hZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQ2Fubm90IHByb2NlZWQgd2l0aCBtb2RlbCBsb2FkaW5nIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZG9lcyBub3QgaGF2ZSB0aGUgYGxvYWRgIG1ldGhvZCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGhhbmRsZXIubG9hZCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFydGlmYWN0cyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb3BvbG9neSA9IGFydGlmYWN0cy5tb2RlbFRvcG9sb2d5O1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxUb3BvbG9neVsnbW9kZWxfY29uZmlnJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxUb3BvbG9neSA9IG1vZGVsVG9wb2xvZ3lbJ21vZGVsX2NvbmZpZyddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gc2VyaWFsaXphdGlvbl8xLmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb25fdXRpbHNfMS5jb252ZXJ0UHl0aG9uaWNUb1RzKG1vZGVsVG9wb2xvZ3kpLCBjdXN0b21PYmplY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFydGlmYWN0cy53ZWlnaHREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnRpZmFjdHMud2VpZ2h0U3BlY3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdNb2RlbCBhcnRpZmFjdHMgY29udGFpbnMgd2VpZ2h0IGRhdGEsIGJ1dCBub3Qgd2VpZ2h0IHNwZWNzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZXJlZm9yZSBsb2FkaW5nIG9mIHdlaWdodHMgY2Fubm90IHByb2NlZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmFtZWRUZW5zb3JNYXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwubG9hZFdlaWdodHModGZqc19jb3JlXzEuaW8uZGVjb2RlV2VpZ2h0cyhhcnRpZmFjdHMud2VpZ2h0RGF0YSwgYXJ0aWZhY3RzLndlaWdodFNwZWNzKSwgc2tpcE1pc21hdGNoLCBpc05hbWVkVGVuc29yTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG1vZGVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRNb2RlbEZyb21JT0hhbmRsZXIgPSBsb2FkTW9kZWxGcm9tSU9IYW5kbGVyO1xudmFyIFNlcXVlbnRpYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXF1ZW50aWFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcXVlbnRpYWwoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHsgaW5wdXRzOiBbXSwgb3V0cHV0czogW10gfSkgfHwgdGhpcztcbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBfdGhpcy50cmFpbmFibGUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5fdXBkYXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuYnVpbHQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubmFtZSA9IChjb25maWcubmFtZSAhPSBudWxsKSA/IGNvbmZpZy5uYW1lIDogSy5nZXRVaWQoJ3NlcXVlbnRpYWxfJyk7XG4gICAgICAgIGlmIChjb25maWcubGF5ZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb25maWcubGF5ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGQobGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2VxdWVudGlhbF8xID0gU2VxdWVudGlhbDtcbiAgICBTZXF1ZW50aWFsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgdmFyIGlzTGF5ZXJNb2RlbEluc3RhbmNlID0gbGF5ZXIgaW5zdGFuY2VvZiBTZXF1ZW50aWFsXzEgfHwgbGF5ZXIgaW5zdGFuY2VvZiB0cmFpbmluZ18xLk1vZGVsO1xuICAgICAgICB2YXIgbW9kZWxMYXllcjtcbiAgICAgICAgaWYgKGlzTGF5ZXJNb2RlbEluc3RhbmNlKSB7XG4gICAgICAgICAgICBtb2RlbExheWVyID0gbGF5ZXI7XG4gICAgICAgICAgICBpZiAobW9kZWxMYXllci5vdXRwdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuICcgK1xuICAgICAgICAgICAgICAgICAgICAnRm9yIG11bHRpLW91dHB1dCBsYXllcnMsICcgK1xuICAgICAgICAgICAgICAgICAgICAndXNlIHRoZSBmdW5jdGlvbmFsIEFQSS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlbExheWVyLmlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICdzaG91bGQgaGF2ZSBhIHNpbmdsZSBpbnB1dCB0ZW5zb3IuICcgK1xuICAgICAgICAgICAgICAgICAgICAnRm9yIG11bHRpLWlucHV0IGxheWVycywgJyArXG4gICAgICAgICAgICAgICAgICAgICd1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5iYXRjaElucHV0U2hhcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignVGhlIGZpcnN0IGxheWVyIGluIGEgU2VxdWVudGlhbCBtb2RlbCBtdXN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldCBhbiBgaW5wdXRTaGFwZWAgb3IgYGJhdGNoSW5wdXRTaGFwZWAgYXJndW1lbnQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB4ID0gdG9wb2xvZ3lfMS5JbnB1dCh7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoU2hhcGU6IGxheWVyLmJhdGNoSW5wdXRTaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgZHR5cGU6IGxheWVyLmR0eXBlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYXllci5uYW1lICsgJ19pbnB1dCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsYXllci5hcHBseSh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0xheWVyTW9kZWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0cyA9IG1vZGVsTGF5ZXIub3V0cHV0cztcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0cyA9IG1vZGVsTGF5ZXIuaW5wdXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmluYm91bmROb2Rlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoJ0EgbGF5ZXIgYWRkZWQgdG8gYSBTZXF1ZW50aWFsIG1vZGVsIG11c3Qgbm90IGFscmVhZHkgYmUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJjb25uZWN0ZWQgc29tZXdoZXJlIGVsc2UuIE1vZGVsIHJlY2VpdmVkIGxheWVyIFwiICsgbGF5ZXIubmFtZSArIFwiIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJ3aGljaCBoYXMgXCIgKyBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoICsgXCIgcHJlLWV4aXN0aW5nIGluYm91bmQgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25uZWN0aW9ucy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcignQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnRm9yIG11bHRpLW91dHB1dCBsYXllcnMsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSB0aGUgZnVuY3Rpb25hbCBBUEkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0cyA9IFtsYXllci5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29yc1swXV07XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSB0b3BvbG9neV8xLmdldFNvdXJjZUlucHV0cyh0aGlzLm91dHB1dHNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3IHRvcG9sb2d5XzEuTm9kZSh7XG4gICAgICAgICAgICAgICAgb3V0Ym91bmRMYXllcjogdGhpcyxcbiAgICAgICAgICAgICAgICBpbmJvdW5kTGF5ZXJzOiBbXSxcbiAgICAgICAgICAgICAgICBub2RlSW5kaWNlczogW10sXG4gICAgICAgICAgICAgICAgdGVuc29ySW5kaWNlczogW10sXG4gICAgICAgICAgICAgICAgaW5wdXRUZW5zb3JzOiB0aGlzLmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRUZW5zb3JzOiB0aGlzLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgaW5wdXRNYXNrczogZ2VuZXJpY191dGlscy5weUxpc3RSZXBlYXQobnVsbCwgdGhpcy5pbnB1dHMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRNYXNrczogW251bGxdLFxuICAgICAgICAgICAgICAgIGlucHV0U2hhcGVzOiB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGU7IH0pLFxuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlczogdGhpcy5vdXRwdXRzWzBdLnNoYXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRUZW5zb3IgPSBsYXllci5hcHBseSh0aGlzLm91dHB1dHNbMF0pO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0VGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsICcgK1xuICAgICAgICAgICAgICAgICAgICAnc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gJyArXG4gICAgICAgICAgICAgICAgICAgICdGb3IgbXVsdGktb3V0cHV0IGxheWVycywgJyArXG4gICAgICAgICAgICAgICAgICAgICd1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzID0gW291dHB1dFRlbnNvcl07XG4gICAgICAgICAgICB0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzID0gdGhpcy5vdXRwdXRzO1xuICAgICAgICAgICAgdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzID0gW3RoaXMub3V0cHV0c1swXS5zaGFwZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgIHRoaXMuYnVpbHQgPSBmYWxzZTtcbiAgICB9O1xuICAgIFNlcXVlbnRpYWwucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlcmUgYXJlIG5vIGxheWVycyBpbiB0aGUgbW9kZWwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllcnMucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbmJvdW5kTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMub3V0Ym91bmROb2RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxhc3RMYXllckluZGV4ID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xhc3RMYXllckluZGV4XS5vdXRib3VuZE5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLm91dHB1dHMgPSBbdGhpcy5sYXllcnNbbGFzdExheWVySW5kZXhdLm91dHB1dF07XG4gICAgICAgICAgICB0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzID0gdGhpcy5vdXRwdXRzO1xuICAgICAgICAgICAgdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzID0gW3RoaXMub3V0cHV0c1swXS5zaGFwZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlcXVlbnRpYWwucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoaW5wdXRzLCBrd2FyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNhbGwoaW5wdXRzLCBrd2FyZ3MpO1xuICAgIH07XG4gICAgU2VxdWVudGlhbC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoaW5wdXRTaGFwZSkge1xuICAgICAgICBnZW5lcmljX3V0aWxzLmdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLm91dHB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZXF1ZW50aWFsIG1vZGVsIGNhbm5vdCBiZSBidWlsdDogbW9kZWwgaXMgZW1wdHkuJyArXG4gICAgICAgICAgICAgICAgJyBBZGQgc29tZSBsYXllcnMgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyB0cmFpbmluZ18xLk1vZGVsKHtcbiAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHNbMF0sXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgKyAnX21vZGVsJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbC50cmFpbmFibGUgPSB0aGlzLnRyYWluYWJsZTtcbiAgICAgICAgdGhpcy5tb2RlbC51cGRhdGFibGUgPSB0aGlzLnVwZGF0YWJsZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0aGlzLm1vZGVsLnN1cHBvcnRzTWFza2luZztcbiAgICAgICAgdGhpcy5pbnB1dExheWVycyA9IHRoaXMubW9kZWwuaW5wdXRMYXllcnM7XG4gICAgICAgIHRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcyA9IHRoaXMubW9kZWwuaW5wdXRMYXllcnNOb2RlSW5kaWNlcztcbiAgICAgICAgdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXMgPSB0aGlzLm1vZGVsLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcztcbiAgICAgICAgdGhpcy5vdXRwdXRMYXllcnMgPSB0aGlzLm1vZGVsLm91dHB1dExheWVycztcbiAgICAgICAgdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcyA9IHRoaXMubW9kZWwub3V0cHV0TGF5ZXJzTm9kZUluZGljZXM7XG4gICAgICAgIHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcyA9IHRoaXMubW9kZWwub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcztcbiAgICAgICAgdGhpcy5ub2Rlc0J5RGVwdGggPSB0aGlzLm1vZGVsLm5vZGVzQnlEZXB0aDtcbiAgICAgICAgdGhpcy5jb250YWluZXJOb2RlcyA9IHRoaXMubW9kZWwuY29udGFpbmVyTm9kZXM7XG4gICAgICAgIHRoaXMub3V0cHV0TmFtZXMgPSB0aGlzLm1vZGVsLm91dHB1dE5hbWVzO1xuICAgICAgICB0aGlzLmlucHV0TmFtZXMgPSB0aGlzLm1vZGVsLmlucHV0TmFtZXM7XG4gICAgICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgIH07XG4gICAgU2VxdWVudGlhbC5wcm90b3R5cGUuc2V0V2VpZ2h0cyA9IGZ1bmN0aW9uICh3ZWlnaHRzKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLnNldFdlaWdodHMod2VpZ2h0cyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VxdWVudGlhbC5wcm90b3R5cGUsIFwidXBkYXRhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRhYmxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnVwZGF0YWJsZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRhYmxlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNlcXVlbnRpYWwucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHgsIHksIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgaWYgKCF0aGlzLmJ1aWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUnVudGltZUVycm9yKCdUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZXZhbHVhdGUoeCwgeSwgY29uZmlnKTtcbiAgICB9O1xuICAgIFNlcXVlbnRpYWwucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiAoeCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwucHJlZGljdCh4LCBjb25maWcpO1xuICAgIH07XG4gICAgU2VxdWVudGlhbC5wcm90b3R5cGUucHJlZGljdE9uQmF0Y2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwucHJlZGljdE9uQmF0Y2goeCk7XG4gICAgfTtcbiAgICBTZXF1ZW50aWFsLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIHRoaXMubW9kZWwuY29tcGlsZShjb25maWcpO1xuICAgICAgICB0aGlzLm9wdGltaXplciA9IHRoaXMubW9kZWwub3B0aW1pemVyO1xuICAgICAgICB0aGlzLmxvc3MgPSB0aGlzLm1vZGVsLmxvc3M7XG4gICAgICAgIHRoaXMubWV0cmljcyA9IHRoaXMubW9kZWwubWV0cmljcztcbiAgICAgICAgdGhpcy5tZXRyaWNzVGVuc29ycyA9IHRoaXMubW9kZWwubWV0cmljc1RlbnNvcnM7XG4gICAgICAgIHRoaXMubWV0cmljc05hbWVzID0gdGhpcy5tb2RlbC5tZXRyaWNzTmFtZXM7XG4gICAgfTtcbiAgICBTZXF1ZW50aWFsLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoeCwgeSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJ1aWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SdW50aW1lRXJyb3IoJ1RoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmVpbmcgdXNlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLm1vZGVsLmZpdCh4LCB5LCBjb25maWcpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlcXVlbnRpYWwuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZykge1xuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgY2xzKHt9KTtcbiAgICAgICAgaWYgKCEobW9kZWwgaW5zdGFuY2VvZiBTZXF1ZW50aWFsXzEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlNlcXVlbnRpYWwuZnJvbUNvbmZpZyBjYWxsZWQgb24gbm9uLVNlcXVlbnRpYWwgaW5wdXQ6IFwiICsgbW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJTZXF1ZW50aWFsLmZyb21Db25maWcgY2FsbGVkIHdpdGhvdXQgYW4gYXJyYXkgb2YgY29uZmlnc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjb25maWdbMF0uY2xhc3NOYW1lICE9IG51bGwpIHx8IGNvbmZpZ1swXVsnY2xhc3NOYW1lJ10gPT09ICdNZXJnZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKCdMZWdhY3kgc2VyaWFsaXphdGlvbiBmb3JtYXQgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbmZpZzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjb25mID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGxheWVyID0gc2VyaWFsaXphdGlvbl8xLmRlc2VyaWFsaXplKGNvbmYpO1xuICAgICAgICAgICAgbW9kZWwuYWRkKGxheWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfTtcbiAgICBTZXF1ZW50aWFsLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGF5ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gX2FbX2ldO1xuICAgICAgICAgICAgY29uZmlnLnB1c2goe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbGF5ZXIuZ2V0Q2xhc3NOYW1lKCksXG4gICAgICAgICAgICAgICAgY29uZmlnOiBsYXllci5nZXRDb25maWcoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBTZXF1ZW50aWFsLmNsYXNzTmFtZSA9ICdTZXF1ZW50aWFsJztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFNlcXVlbnRpYWwucHJvdG90eXBlLCBcImFkZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgY29uZmlnUGFyYW1JbmRpY2VzOiBbMl0gfSlcbiAgICBdLCBTZXF1ZW50aWFsLnByb3RvdHlwZSwgXCJldmFsdWF0ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgdGZqc19jb3JlXzEuZG9jKHsgaGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgY29uZmlnUGFyYW1JbmRpY2VzOiBbMV0gfSlcbiAgICBdLCBTZXF1ZW50aWFsLnByb3RvdHlwZSwgXCJwcmVkaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICB0ZmpzX2NvcmVfMS5kb2MoeyBoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnLCBjb25maWdQYXJhbUluZGljZXM6IFsyXSB9KVxuICAgIF0sIFNlcXVlbnRpYWwucHJvdG90eXBlLCBcImZpdFwiLCBudWxsKTtcbiAgICBTZXF1ZW50aWFsID0gU2VxdWVudGlhbF8xID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBTZXF1ZW50aWFsKTtcbiAgICByZXR1cm4gU2VxdWVudGlhbDtcbiAgICB2YXIgU2VxdWVudGlhbF8xO1xufSh0cmFpbmluZ18xLk1vZGVsKSk7XG5leHBvcnRzLlNlcXVlbnRpYWwgPSBTZXF1ZW50aWFsO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKFNlcXVlbnRpYWwpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBLID0gcmVxdWlyZShcIi4vYmFja2VuZC90ZmpzX2JhY2tlbmRcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBnZXRPcHRpbWl6ZXIoaWRlbnRpZmllcikge1xuICAgIHZhciBvcHRpbWl6ZXJNYXAgPSB7XG4gICAgICAgICdBZGFncmFkJzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZqc19jb3JlXzEudHJhaW4uYWRhZ3JhZCguMDEpOyB9LFxuICAgICAgICAnQWRhbSc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmanNfY29yZV8xLnRyYWluLmFkYW0oLjAwMSwgLjksIC45OTksIEsuZXBzaWxvbigpKTsgfSxcbiAgICAgICAgJ1JNU1Byb3AnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZmpzX2NvcmVfMS50cmFpbi5ybXNwcm9wKC4wMDEsIC45LCBudWxsLCBLLmVwc2lsb24oKSk7IH0sXG4gICAgICAgICdTR0QnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZmpzX2NvcmVfMS50cmFpbi5zZ2QoLjAxKTsgfVxuICAgIH07XG4gICAgb3B0aW1pemVyTWFwWydhZGFncmFkJ10gPSBvcHRpbWl6ZXJNYXBbJ0FkYWdyYWQnXTtcbiAgICBvcHRpbWl6ZXJNYXBbJ2FkYW0nXSA9IG9wdGltaXplck1hcFsnQWRhbSddO1xuICAgIG9wdGltaXplck1hcFsncm1zcHJvcCddID0gb3B0aW1pemVyTWFwWydSTVNQcm9wJ107XG4gICAgb3B0aW1pemVyTWFwWydzZ2QnXSA9IG9wdGltaXplck1hcFsnU0dEJ107XG4gICAgaWYgKGlkZW50aWZpZXIgaW4gb3B0aW1pemVyTWFwKSB7XG4gICAgICAgIHJldHVybiBvcHRpbWl6ZXJNYXBbaWRlbnRpZmllcl0oKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJVbmtub3duIE9wdGltaXplciBcIiArIGlkZW50aWZpZXIpO1xufVxuZXhwb3J0cy5nZXRPcHRpbWl6ZXIgPSBnZXRPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpbWl6ZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIEsgPSByZXF1aXJlKFwiLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBnZW5lcmljX3V0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xudmFyIFJlZ3VsYXJpemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVndWxhcml6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVndWxhcml6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlZ3VsYXJpemVyO1xufSh0ZmpzX2NvcmVfMS5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSkpO1xuZXhwb3J0cy5SZWd1bGFyaXplciA9IFJlZ3VsYXJpemVyO1xudmFyIEwxTDIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMMUwyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEwxTDIoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBsMSA9IGNvbmZpZyA9PSBudWxsIHx8IGNvbmZpZy5sMSA9PSBudWxsID8gMC4wMSA6IGNvbmZpZy5sMTtcbiAgICAgICAgdmFyIGwyID0gY29uZmlnID09IG51bGwgfHwgY29uZmlnLmwyID09IG51bGwgPyAwLjAxIDogY29uZmlnLmwyO1xuICAgICAgICBfdGhpcy5oYXNMMSA9IGwxICE9PSAwO1xuICAgICAgICBfdGhpcy5oYXNMMiA9IGwyICE9PSAwO1xuICAgICAgICBfdGhpcy5sMSA9IEsuZ2V0U2NhbGFyKGwxKTtcbiAgICAgICAgX3RoaXMubDIgPSBLLmdldFNjYWxhcihsMik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTDFMMi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGZqc19jb3JlXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVndWxhcml6YXRpb24gPSB0ZmpzX2NvcmVfMS56ZXJvcyhbMV0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLmhhc0wxKSB7XG4gICAgICAgICAgICAgICAgcmVndWxhcml6YXRpb24gPVxuICAgICAgICAgICAgICAgICAgICB0ZmpzX2NvcmVfMS5hZGQocmVndWxhcml6YXRpb24sIHRmanNfY29yZV8xLnN1bShLLnNjYWxhclRpbWVzQXJyYXkoX3RoaXMubDEsIHRmanNfY29yZV8xLmFicyh4KSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5oYXNMMikge1xuICAgICAgICAgICAgICAgIHJlZ3VsYXJpemF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdGZqc19jb3JlXzEuYWRkKHJlZ3VsYXJpemF0aW9uLCB0ZmpzX2NvcmVfMS5zdW0oSy5zY2FsYXJUaW1lc0FycmF5KF90aGlzLmwyLCBLLnNxdWFyZSh4KSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWd1bGFyaXphdGlvbi5hc1NjYWxhcigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEwxTDIucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgJ2wxJzogdGhpcy5sMS5kYXRhU3luYygpWzBdLCAnbDInOiB0aGlzLmwyLmRhdGFTeW5jKClbMF0gfTtcbiAgICB9O1xuICAgIEwxTDIuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjbHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IGNscyh7IGwxOiBjb25maWcubDEsIGwyOiBjb25maWcubDIgfSk7XG4gICAgfTtcbiAgICBMMUwyLmNsYXNzTmFtZSA9ICdMMUwyJztcbiAgICBMMUwyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdSZWd1bGFyaXplcnMnLCBuYW1lc3BhY2U6ICdyZWd1bGFyaXplcnMnIH0pXG4gICAgXSwgTDFMMik7XG4gICAgcmV0dXJuIEwxTDI7XG59KFJlZ3VsYXJpemVyKSk7XG5leHBvcnRzLkwxTDIgPSBMMUwyO1xudGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLnJlZ2lzdGVyKEwxTDIpO1xuZnVuY3Rpb24gbDEoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBMMUwyKHsgbDE6IGNvbmZpZyAhPSBudWxsID8gY29uZmlnLmwxIDogbnVsbCwgbDI6IDAgfSk7XG59XG5leHBvcnRzLmwxID0gbDE7XG5mdW5jdGlvbiBsMihjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IEwxTDIoeyBsMjogY29uZmlnICE9IG51bGwgPyBjb25maWcubDIgOiBudWxsLCBsMTogMCB9KTtcbn1cbmV4cG9ydHMubDIgPSBsMjtcbmV4cG9ydHMuUkVHVUxBUklaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQID0ge1xuICAgICdsMWwyJzogJ0wxTDInXG59O1xuZnVuY3Rpb24gc2VyaWFsaXplUmVndWxhcml6ZXIoY29uc3RyYWludCkge1xuICAgIHJldHVybiBnZW5lcmljX3V0aWxzXzEuc2VyaWFsaXplS2VyYXNPYmplY3QoY29uc3RyYWludCk7XG59XG5leHBvcnRzLnNlcmlhbGl6ZVJlZ3VsYXJpemVyID0gc2VyaWFsaXplUmVndWxhcml6ZXI7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKGNvbmZpZywgY3VzdG9tT2JqZWN0cykge1xuICAgIGlmIChjdXN0b21PYmplY3RzID09PSB2b2lkIDApIHsgY3VzdG9tT2JqZWN0cyA9IHt9OyB9XG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHNfMS5kZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGNvbmZpZywgdGZqc19jb3JlXzEuc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCwgY3VzdG9tT2JqZWN0cywgJ3JlZ3VsYXJpemVyJyk7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplUmVndWxhcml6ZXIgPSBkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyO1xuZnVuY3Rpb24gZ2V0UmVndWxhcml6ZXIoaWRlbnRpZmllcikge1xuICAgIGlmIChpZGVudGlmaWVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGlkZW50aWZpZXIgaW4gZXhwb3J0cy5SRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVAgP1xuICAgICAgICAgICAgZXhwb3J0cy5SRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbaWRlbnRpZmllcl0gOlxuICAgICAgICAgICAgaWRlbnRpZmllcjtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGNvbmZpZzoge30gfTtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplUmVndWxhcml6ZXIoY29uZmlnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaWRlbnRpZmllciBpbnN0YW5jZW9mIFJlZ3VsYXJpemVyKSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplUmVndWxhcml6ZXIoaWRlbnRpZmllcik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVndWxhcml6ZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmanNfY29yZV8xID0gcmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBfbmV4dFVuaXF1ZVRlbnNvcklkID0gMDtcbmZ1bmN0aW9uIGdldE5leHRVbmlxdWVUZW5zb3JJZCgpIHtcbiAgICByZXR1cm4gX25leHRVbmlxdWVUZW5zb3JJZCsrO1xufVxuZXhwb3J0cy5nZXROZXh0VW5pcXVlVGVuc29ySWQgPSBnZXROZXh0VW5pcXVlVGVuc29ySWQ7XG52YXIgU3ltYm9saWNUZW5zb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN5bWJvbGljVGVuc29yKGR0eXBlLCBzaGFwZSwgc291cmNlTGF5ZXIsIGlucHV0cywgY2FsbEFyZ3MsIG5hbWUsIG91dHB1dFRlbnNvckluZGV4KSB7XG4gICAgICAgIHRoaXMuZHR5cGUgPSBkdHlwZTtcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICB0aGlzLnNvdXJjZUxheWVyID0gc291cmNlTGF5ZXI7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLmNhbGxBcmdzID0gY2FsbEFyZ3M7XG4gICAgICAgIHRoaXMub3V0cHV0VGVuc29ySW5kZXggPSBvdXRwdXRUZW5zb3JJbmRleDtcbiAgICAgICAgdGhpcy5pZCA9IGdldE5leHRVbmlxdWVUZW5zb3JJZCgpO1xuICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsTmFtZSA9IGNvbW1vbl8xLmdldFNjb3BlZFRlbnNvck5hbWUobmFtZSk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBjb21tb25fMS5nZXRVbmlxdWVUZW5zb3JOYW1lKHRoaXMub3JpZ2luYWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgfVxuICAgIFN5bWJvbGljVGVuc29yID0gX19kZWNvcmF0ZShbXG4gICAgICAgIHRmanNfY29yZV8xLmRvYyh7IGhlYWRpbmc6ICdNb2RlbHMnLCAnc3ViaGVhZGluZyc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFN5bWJvbGljVGVuc29yKTtcbiAgICByZXR1cm4gU3ltYm9saWNUZW5zb3I7XG59KCkpO1xuZXhwb3J0cy5TeW1ib2xpY1RlbnNvciA9IFN5bWJvbGljVGVuc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xudmFyIGdlbmVyaWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2dlbmVyaWNfdXRpbHNcIik7XG52YXIgbWF0aF91dGlsc18xID0gcmVxdWlyZShcIi4vbWF0aF91dGlsc1wiKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHZhbHVlLCBuLCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHNfMS5weUxpc3RSZXBlYXQodmFsdWUsIG4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJUaGUgXCIgKyBuYW1lICsgXCIgYXJndW1lbnQgbXVzdCBiZSBhIHR1cGxlIG9mIFwiICsgbiArIFwiIGludGVnZXJzLiBSZWNlaXZlZDogXCIgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5sZW5ndGggKyBcIiBlbGVtZW50cy5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2luZ2xlVmFsdWUgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGlmICghbWF0aF91dGlsc18xLmlzSW50ZWdlcihzaW5nbGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsdWVFcnJvcihcIlRoZSBcIiArIG5hbWUgKyBcIiBhcmd1bWVudCBtdXN0IGJlIGEgdHVwbGUgb2YgXCIgKyBuICsgXCIgaW50ZWdlcnMuIFJlY2VpdmVkOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyBcIiBpbmNsdWRpbmcgYSBub24taW50ZWdlciBudW1iZXIgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwiXCIgKyBzaW5nbGVWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLm5vcm1hbGl6ZUFycmF5ID0gbm9ybWFsaXplQXJyYXk7XG5mdW5jdGlvbiBjb252T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoLCBmaWx0ZXJTaXplLCBwYWRkaW5nLCBzdHJpZGUsIGRpbGF0aW9uKSB7XG4gICAgaWYgKGRpbGF0aW9uID09PSB2b2lkIDApIHsgZGlsYXRpb24gPSAxOyB9XG4gICAgaWYgKGlucHV0TGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0TGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgZGlsYXRlZEZpbHRlclNpemUgPSBmaWx0ZXJTaXplICsgKGZpbHRlclNpemUgLSAxKSAqIChkaWxhdGlvbiAtIDEpO1xuICAgIHZhciBvdXRwdXRMZW5ndGg7XG4gICAgaWYgKHBhZGRpbmcgPT09ICdzYW1lJykge1xuICAgICAgICBvdXRwdXRMZW5ndGggPSBpbnB1dExlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dHB1dExlbmd0aCA9IGlucHV0TGVuZ3RoIC0gZGlsYXRlZEZpbHRlclNpemUgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcigob3V0cHV0TGVuZ3RoICsgc3RyaWRlIC0gMSkgLyBzdHJpZGUpO1xufVxuZXhwb3J0cy5jb252T3V0cHV0TGVuZ3RoID0gY29udk91dHB1dExlbmd0aDtcbmZ1bmN0aW9uIGRlY29udkxlbmd0aChkaW1TaXplLCBzdHJpZGVTaXplLCBrZXJuZWxTaXplLCBwYWRkaW5nKSB7XG4gICAgaWYgKGRpbVNpemUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBhZGRpbmcgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgZGltU2l6ZSA9IGRpbVNpemUgKiBzdHJpZGVTaXplICsgbWF0aF91dGlsc18xLm1heChba2VybmVsU2l6ZSAtIHN0cmlkZVNpemUsIDBdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFkZGluZyA9PT0gJ3NhbWUnKSB7XG4gICAgICAgIGRpbVNpemUgPSBkaW1TaXplICogc3RyaWRlU2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiVW5zdXBwb3J0IHBhZGRpbmcgbW9kZTogXCIgKyBwYWRkaW5nICsgXCIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGltU2l6ZTtcbn1cbmV4cG9ydHMuZGVjb252TGVuZ3RoID0gZGVjb252TGVuZ3RoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl91dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIHB5TGlzdFJlcGVhdCh2YWx1ZSwgbnVtVmFsdWVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhciBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICBuZXdBcnJheSA9IG5ld0FycmF5LmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG51bVZhbHVlcyk7XG4gICAgICAgIG5ld0FycmF5LmZpbGwodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgfVxufVxuZXhwb3J0cy5weUxpc3RSZXBlYXQgPSBweUxpc3RSZXBlYXQ7XG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtZXNzYWdlKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZnVuY3Rpb24gY291bnQoYXJyYXksIHJlZmVybmNlKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIGZvciAodmFyIF9pID0gMCwgYXJyYXlfMSA9IGFycmF5OyBfaSA8IGFycmF5XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJyYXlfMVtfaV07XG4gICAgICAgIGlmIChpdGVtID09PSByZWZlcm5jZSkge1xuICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVyO1xufVxuZXhwb3J0cy5jb3VudCA9IGNvdW50O1xuZnVuY3Rpb24gc2luZ2xldG9uT3JBcnJheSh4cykge1xuICAgIGlmICh4cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHhzWzBdO1xuICAgIH1cbiAgICByZXR1cm4geHM7XG59XG5leHBvcnRzLnNpbmdsZXRvbk9yQXJyYXkgPSBzaW5nbGV0b25PckFycmF5O1xuZnVuY3Rpb24gdG9MaXN0KHgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgcmV0dXJuIFt4XTtcbn1cbmV4cG9ydHMudG9MaXN0ID0gdG9MaXN0O1xuZnVuY3Rpb24gb2JqZWN0TGlzdFVpZChvYmpzKSB7XG4gICAgdmFyIG9iamVjdExpc3QgPSB0b0xpc3Qob2Jqcyk7XG4gICAgdmFyIHJldFZhbCA9ICcnO1xuICAgIGZvciAodmFyIF9pID0gMCwgb2JqZWN0TGlzdF8xID0gb2JqZWN0TGlzdDsgX2kgPCBvYmplY3RMaXN0XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBvYmplY3RMaXN0XzFbX2ldO1xuICAgICAgICBpZiAob2JqLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiT2JqZWN0IFwiICsgb2JqICsgXCIgcGFzc2VkIHRvIG9iamVjdExpc3RVaWQgd2l0aG91dCBhbiBpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0VmFsICE9PSAnJykge1xuICAgICAgICAgICAgcmV0VmFsID0gcmV0VmFsICsgJywgJztcbiAgICAgICAgfVxuICAgICAgICByZXRWYWwgPSByZXRWYWwgKyBNYXRoLmFicyhvYmouaWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0VmFsO1xufVxuZXhwb3J0cy5vYmplY3RMaXN0VWlkID0gb2JqZWN0TGlzdFVpZDtcbmZ1bmN0aW9uIGlzQXJyYXlPZlNoYXBlcyh4KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgJiYgQXJyYXkuaXNBcnJheSh4WzBdKTtcbn1cbmV4cG9ydHMuaXNBcnJheU9mU2hhcGVzID0gaXNBcnJheU9mU2hhcGVzO1xuZnVuY3Rpb24gbm9ybWFsaXplU2hhcGVMaXN0KHgpIHtcbiAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoeFswXSkpIHtcbiAgICAgICAgcmV0dXJuIFt4XTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZVNoYXBlTGlzdCA9IG5vcm1hbGl6ZVNoYXBlTGlzdDtcbmZ1bmN0aW9uIHRvU25ha2VDYXNlKG5hbWUpIHtcbiAgICB2YXIgaW50ZXJtZWRpYXRlID0gbmFtZS5yZXBsYWNlKC8oLikoW0EtWl1bYS16MC05XSspL2csICckMV8kMicpO1xuICAgIHZhciBpbnNlY3VyZSA9IGludGVybWVkaWF0ZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDFfJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpbnNlY3VyZVswXSAhPT0gJ18nKSB7XG4gICAgICAgIHJldHVybiBpbnNlY3VyZTtcbiAgICB9XG4gICAgcmV0dXJuICdwcml2YXRlJyArIGluc2VjdXJlO1xufVxuZXhwb3J0cy50b1NuYWtlQ2FzZSA9IHRvU25ha2VDYXNlO1xuZnVuY3Rpb24gdG9DYW1lbENhc2UoaWRlbnRpZmllcikge1xuICAgIGlmIChpZGVudGlmaWVyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCdfJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH1cbiAgICByZXR1cm4gaWRlbnRpZmllci5yZXBsYWNlKC9bX10rKFxcd3wkKS9nLCBmdW5jdGlvbiAobSwgcDEpIHsgcmV0dXJuIHAxLnRvVXBwZXJDYXNlKCk7IH0pO1xufVxuZXhwb3J0cy50b0NhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlO1xudmFyIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMgPSB7fTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUtlcmFzT2JqZWN0KGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlID09PSBudWxsIHx8IGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IGNsYXNzTmFtZTogaW5zdGFuY2UuZ2V0Q2xhc3NOYW1lKCksIGNvbmZpZzogaW5zdGFuY2UuZ2V0Q29uZmlnKCkgfTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplS2VyYXNPYmplY3QgPSBzZXJpYWxpemVLZXJhc09iamVjdDtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplS2VyYXNPYmplY3QoaWRlbnRpZmllciwgbW9kdWxlT2JqZWN0cywgY3VzdG9tT2JqZWN0cywgcHJpbnRhYmxlTW9kdWxlTmFtZSkge1xuICAgIGlmIChtb2R1bGVPYmplY3RzID09PSB2b2lkIDApIHsgbW9kdWxlT2JqZWN0cyA9IHt9OyB9XG4gICAgaWYgKGN1c3RvbU9iamVjdHMgPT09IHZvaWQgMCkgeyBjdXN0b21PYmplY3RzID0ge307IH1cbiAgICBpZiAocHJpbnRhYmxlTW9kdWxlTmFtZSA9PT0gdm9pZCAwKSB7IHByaW50YWJsZU1vZHVsZU5hbWUgPSAnb2JqZWN0JzsgfVxuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlkZW50aWZpZXI7XG4gICAgICAgIHZhciBmbiA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSBpbiBjdXN0b21PYmplY3RzKSB7XG4gICAgICAgICAgICBmbiA9IGN1c3RvbU9iamVjdHNbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmdW5jdGlvbk5hbWUgaW4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUykge1xuICAgICAgICAgICAgZm4gPSBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbiA9IG1vZHVsZU9iamVjdHNbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgICAgIGlmIChmbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJVbmtub3duIFwiICsgcHJpbnRhYmxlTW9kdWxlTmFtZSArIFwiOiBcIiArIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjb25maWcgPSBpZGVudGlmaWVyO1xuICAgICAgICBpZiAoY29uZmlnLmNsYXNzTmFtZSA9PSBudWxsIHx8IGNvbmZpZy5jb25maWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IocHJpbnRhYmxlTW9kdWxlTmFtZSArIFwiOiBJbXByb3BlciBjb25maWcgZm9ybWF0OiBcIiArXG4gICAgICAgICAgICAgICAgKEpTT04uc3RyaW5naWZ5KGNvbmZpZykgKyBcIi5cXG5cIikgK1xuICAgICAgICAgICAgICAgIFwiJ2NsYXNzTmFtZScgYW5kICdjb25maWcnIG11c3Qgc2V0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gY29uZmlnLmNsYXNzTmFtZTtcbiAgICAgICAgdmFyIGNscyA9IHZvaWQgMCwgZnJvbUNvbmZpZyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSBpbiBjdXN0b21PYmplY3RzKSB7XG4gICAgICAgICAgICBfYSA9IGN1c3RvbU9iamVjdHMuZ2V0KGNsYXNzTmFtZSksIGNscyA9IF9hWzBdLCBmcm9tQ29uZmlnID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lIGluIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpIHtcbiAgICAgICAgICAgIF9iID0gX0dMT0JBTF9DVVNUT01fT0JKRUNUUy5jbGFzc05hbWUsIGNscyA9IF9iWzBdLCBmcm9tQ29uZmlnID0gX2JbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lIGluIG1vZHVsZU9iamVjdHMpIHtcbiAgICAgICAgICAgIF9jID0gbW9kdWxlT2JqZWN0c1tjbGFzc05hbWVdLCBjbHMgPSBfY1swXSwgZnJvbUNvbmZpZyA9IF9jWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJVbmtub3duIFwiICsgcHJpbnRhYmxlTW9kdWxlTmFtZSArIFwiOiBcIiArIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1c3RvbU9iamVjdHNDb21iaW5lZCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfZCA9IE9iamVjdC5rZXlzKF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpOyBfaSA8IF9kLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfZFtfaV07XG4gICAgICAgICAgICAgICAgY3VzdG9tT2JqZWN0c0NvbWJpbmVkW2tleV0gPSBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IDAsIF9mID0gT2JqZWN0LmtleXMoY3VzdG9tT2JqZWN0cyk7IF9lIDwgX2YubGVuZ3RoOyBfZSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9mW19lXTtcbiAgICAgICAgICAgICAgICBjdXN0b21PYmplY3RzQ29tYmluZWRba2V5XSA9IGN1c3RvbU9iamVjdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXN0ZWRDb25maWcgPSBjb25maWcuY29uZmlnO1xuICAgICAgICAgICAgbmVzdGVkQ29uZmlnLmN1c3RvbU9iamVjdHMgPSBjdXN0b21PYmplY3RzQ29tYmluZWQ7XG4gICAgICAgICAgICB2YXIgYmFja3VwQ3VzdG9tT2JqZWN0cyA9IF9fYXNzaWduKHt9LCBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9nID0gMCwgX2ggPSBPYmplY3Qua2V5cyhjdXN0b21PYmplY3RzKTsgX2cgPCBfaC5sZW5ndGg7IF9nKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2hbX2ddO1xuICAgICAgICAgICAgICAgIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFNba2V5XSA9IGN1c3RvbU9iamVjdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXR1cm5PYmogPSBmcm9tQ29uZmlnKGNscywgY29uZmlnLmNvbmZpZyk7XG4gICAgICAgICAgICBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTID0gX19hc3NpZ24oe30sIGJhY2t1cEN1c3RvbU9iamVjdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybk9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiYWNrdXBDdXN0b21PYmplY3RzID0gX19hc3NpZ24oe30sIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IE9iamVjdC5rZXlzKGN1c3RvbU9iamVjdHMpOyBfaiA8IF9rLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfa1tfal07XG4gICAgICAgICAgICAgICAgX0dMT0JBTF9DVVNUT01fT0JKRUNUU1trZXldID0gY3VzdG9tT2JqZWN0c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJldHVybk9iaiA9IG5ldyBjbHMoY29uZmlnLmNvbmZpZyk7XG4gICAgICAgICAgICBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTID0gX19hc3NpZ24oe30sIGJhY2t1cEN1c3RvbU9iamVjdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybk9iajtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX2EsIF9iLCBfYztcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVLZXJhc09iamVjdCA9IGRlc2VyaWFsaXplS2VyYXNPYmplY3Q7XG5mdW5jdGlvbiBnZXRFeGFjdGx5T25lVGVuc29yKHhzKSB7XG4gICAgdmFyIHg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGlmICh4cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiRXhwZWN0ZWQgVGVuc29yIGxlbmd0aCB0byBiZSAxOyBnb3QgXCIgKyB4cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHggPSB4c1swXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHggPSB4cztcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5leHBvcnRzLmdldEV4YWN0bHlPbmVUZW5zb3IgPSBnZXRFeGFjdGx5T25lVGVuc29yO1xuZnVuY3Rpb24gZ2V0RXhhY3RseU9uZVNoYXBlKHNoYXBlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNoYXBlcykgJiYgQXJyYXkuaXNBcnJheShzaGFwZXNbMF0pKSB7XG4gICAgICAgIGlmIChzaGFwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBzaGFwZXMgPSBzaGFwZXM7XG4gICAgICAgICAgICByZXR1cm4gc2hhcGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJFeHBlY3RlZCBleGFjdGx5IDEgU2hhcGU7IGdvdCBcIiArIHNoYXBlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2hhcGVzO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RXhhY3RseU9uZVNoYXBlID0gZ2V0RXhhY3RseU9uZVNoYXBlO1xuZnVuY3Rpb24gbnVtYmVyQ29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIChhIDwgYikgPyAtMSA6ICgoYSA+IGIpID8gMSA6IDApO1xufVxuZXhwb3J0cy5udW1iZXJDb21wYXJlID0gbnVtYmVyQ29tcGFyZTtcbmZ1bmN0aW9uIHJldmVyc2VOdW1iZXJDb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gLTEgKiBudW1iZXJDb21wYXJlKGEsIGIpO1xufVxuZXhwb3J0cy5yZXZlcnNlTnVtYmVyQ29tcGFyZSA9IHJldmVyc2VOdW1iZXJDb21wYXJlO1xuZnVuY3Rpb24gc3RyaW5nVG9EVHlwZShkdHlwZSkge1xuICAgIHN3aXRjaCAoZHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IoXCJJbnZhbGlkIGR0eXBlOiBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLnN0cmluZ1RvRFR5cGUgPSBzdHJpbmdUb0RUeXBlO1xuZnVuY3Rpb24gc3RyaW5nc0VxdWFsKHhzLCB5cykge1xuICAgIGlmICh4cyA9PSBudWxsIHx8IHlzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHhzID09PSB5cztcbiAgICB9XG4gICAgaWYgKHhzLmxlbmd0aCAhPT0geXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoeHNbaV0gIT09IHlzW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnN0cmluZ3NFcXVhbCA9IHN0cmluZ3NFcXVhbDtcbmZ1bmN0aW9uIHVuaXF1ZSh4cykge1xuICAgIGlmICh4cyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB4cztcbiAgICB9XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgeHNfMSA9IHhzOyBfaSA8IHhzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB4ID0geHNfMVtfaV07XG4gICAgICAgIGlmIChvdXQuaW5kZXhPZih4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnVuaXF1ZSA9IHVuaXF1ZTtcbmZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiSW52YWxpZCB2YWx1ZSBpbiBvYmo6IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzT2JqZWN0RW1wdHkgPSBpc09iamVjdEVtcHR5O1xuZnVuY3Rpb24gY2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZSh2YWx1ZXMsIGxhYmVsLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlcy5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbHVlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgYSB2YWxpZCBcIiArIGxhYmVsICsgXCIuICBWYWxpZCB2YWx1ZXMgYXJlIFwiICsgdmFsdWVzICsgXCIgb3IgbnVsbC91bmRlZmluZWQuXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZSA9IGNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmljX3V0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIGlzSW50ZWdlcih4KSB7XG4gICAgcmV0dXJuIHggPT09IHBhcnNlSW50KHgudG9TdHJpbmcoKSwgMTApO1xufVxuZXhwb3J0cy5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG5mdW5jdGlvbiBhcnJheVByb2QoYXJyYXksIGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoYmVnaW4gPT0gbnVsbCkge1xuICAgICAgICBiZWdpbiA9IDA7XG4gICAgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBwcm9kID0gMTtcbiAgICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICBwcm9kICo9IGFycmF5W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZDtcbn1cbmV4cG9ydHMuYXJyYXlQcm9kID0gYXJyYXlQcm9kO1xuZnVuY3Rpb24gdG9BcnJheTFEKGFycmF5KSB7XG4gICAgYXJyYXkgPSBBcnJheS5pc0FycmF5KGFycmF5KSA/IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpIDogYXJyYXk7XG4gICAgcmV0dXJuIHRmanNfY29yZV8xLnRlbnNvcjFkKGFycmF5KTtcbn1cbmZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgIHJldHVybiB0ZmMubWluKHRvQXJyYXkxRChhcnJheSkpLmRhdGFTeW5jKClbMF07XG59XG5leHBvcnRzLm1pbiA9IG1pbjtcbmZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgIHJldHVybiB0ZmMubWF4KHRvQXJyYXkxRChhcnJheSkpLmRhdGFTeW5jKClbMF07XG59XG5leHBvcnRzLm1heCA9IG1heDtcbmZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgIHJldHVybiB0ZmMuc3VtKHRvQXJyYXkxRChhcnJheSkpLmRhdGFTeW5jKClbMF07XG59XG5leHBvcnRzLnN1bSA9IHN1bTtcbmZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICByZXR1cm4gc3VtKGFycmF5KSAvIGFycmF5Lmxlbmd0aDtcbn1cbmV4cG9ydHMubWVhbiA9IG1lYW47XG5mdW5jdGlvbiB2YXJpYW5jZShhcnJheSkge1xuICAgIHZhciBkZW1lYW5lZCA9IHRmYy5zdWIodG9BcnJheTFEKGFycmF5KSwgdGZqc19jb3JlXzEuc2NhbGFyKG1lYW4oYXJyYXkpKSk7XG4gICAgdmFyIHN1bVNxdWFyZSA9IHRmYy5zdW0odGZjLm11bFN0cmljdChkZW1lYW5lZCwgZGVtZWFuZWQpKS5kYXRhU3luYygpWzBdO1xuICAgIHJldHVybiBzdW1TcXVhcmUgLyBhcnJheS5sZW5ndGg7XG59XG5leHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG5mdW5jdGlvbiBtZWRpYW4oYXJyYXkpIHtcbiAgICB2YXIgYXJyYXlTb3J0ZWQgPSBhcnJheS5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICB2YXIgbG93SWR4ID0gTWF0aC5mbG9vcigoYXJyYXlTb3J0ZWQubGVuZ3RoIC0gMSkgLyAyKTtcbiAgICB2YXIgaGlnaElkeCA9IE1hdGguY2VpbCgoYXJyYXlTb3J0ZWQubGVuZ3RoIC0gMSkgLyAyKTtcbiAgICBpZiAobG93SWR4ID09PSBoaWdoSWR4KSB7XG4gICAgICAgIHJldHVybiBhcnJheVNvcnRlZFtsb3dJZHhdO1xuICAgIH1cbiAgICByZXR1cm4gKGFycmF5U29ydGVkW2xvd0lkeF0gKyBhcnJheVNvcnRlZFtoaWdoSWR4XSkgLyAyO1xufVxuZXhwb3J0cy5tZWRpYW4gPSBtZWRpYW47XG5mdW5jdGlvbiByYW5nZShiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8IGJlZ2luKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWx1ZUVycm9yKFwiZW5kIChcIiArIGVuZCArIFwiKSA8IGJlZ2luIChcIiArIGJlZ2luICsgXCIpIGlzIGZvcmJpZGRlbi5cIik7XG4gICAgfVxuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICBvdXQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMucmFuZ2UgPSByYW5nZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhfdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2VuZXJpY191dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nZW5lcmljX3V0aWxzXCIpO1xuZnVuY3Rpb24gaXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZShrZXksIGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiAoa2V5ID09PSAnaW5ib3VuZE5vZGVzJyB8fCBrZXkgPT09ICdvdXRwdXRMYXllcnMnIHx8XG4gICAgICAgIGtleSA9PT0gJ2lucHV0TGF5ZXJzJykgJiZcbiAgICAgICAgaW5kZXggPT09IDAgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQeXRob25pY1RvVHMocHl0aG9uaWNDb25maWcsIGtleSkge1xuICAgIGlmIChweXRob25pY0NvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHB5dGhvbmljQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZ2VuZXJpY191dGlscy50b0NhbWVsQ2FzZShweXRob25pY0NvbmZpZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCh0eXBlb2YgcHl0aG9uaWNDb25maWcgPT09ICdudW1iZXInKSB8fFxuICAgICAgICAodHlwZW9mIHB5dGhvbmljQ29uZmlnID09PSAnYm9vbGVhbicpKSB7XG4gICAgICAgIHJldHVybiBweXRob25pY0NvbmZpZztcbiAgICB9XG4gICAgZWxzZSBpZiAocHl0aG9uaWNDb25maWcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgdHNBcnJheSA9IFtdO1xuICAgICAgICB2YXIgYXJyYXlMZW5ndGggPSBweXRob25pY0NvbmZpZy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBweXRob25pY0NvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5SXRlbUlucHV0T3JPdXRwdXROYW1lKGtleSwgaSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0c0FycmF5LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0c0FycmF5LnB1c2goY29udmVydFB5dGhvbmljVG9UcyhpdGVtLCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHNBcnJheTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB0c0RpY3QgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHB5dGhvbmljQ29uZmlnKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBweXRob25pY0tleSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBweXRob25pY1ZhbHVlID0gcHl0aG9uaWNDb25maWdbcHl0aG9uaWNLZXldO1xuICAgICAgICAgICAgaWYgKHB5dGhvbmljS2V5ID09PSAnbmFtZScgJiYgdHlwZW9mIHB5dGhvbmljVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdHNEaWN0W3B5dGhvbmljS2V5XSA9IHB5dGhvbmljVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdHNLZXkgPSBnZW5lcmljX3V0aWxzLnRvQ2FtZWxDYXNlKHB5dGhvbmljS2V5KTtcbiAgICAgICAgICAgICAgICB0c0RpY3RbdHNLZXldID0gY29udmVydFB5dGhvbmljVG9UcyhweXRob25pY1ZhbHVlLCB0c0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzRGljdDtcbiAgICB9XG59XG5leHBvcnRzLmNvbnZlcnRQeXRob25pY1RvVHMgPSBjb252ZXJ0UHl0aG9uaWNUb1RzO1xuZnVuY3Rpb24gY29udmVydFRzVG9QeXRob25pYyh0c0NvbmZpZywga2V5KSB7XG4gICAgaWYgKHRzQ29uZmlnID09PSBudWxsIHx8IHRzQ29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0c0NvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMudG9TbmFrZUNhc2UodHNDb25maWcpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZW9mIHRzQ29uZmlnID09PSAnbnVtYmVyJykgfHwgKHR5cGVvZiB0c0NvbmZpZyA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICByZXR1cm4gdHNDb25maWc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRzQ29uZmlnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFyIHB5QXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGFycmF5TGVuZ3RoID0gdHNDb25maWcubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5TGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdHNDb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZShrZXksIGksIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcHlBcnJheS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHlBcnJheS5wdXNoKGNvbnZlcnRUc1RvUHl0aG9uaWMoaXRlbSwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB5QXJyYXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcHlEaWN0ID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyh0c0NvbmZpZyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHNLZXkgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgdHNWYWx1ZSA9IHRzQ29uZmlnW3RzS2V5XTtcbiAgICAgICAgICAgIHZhciBweUtleSA9IGdlbmVyaWNfdXRpbHMudG9TbmFrZUNhc2UodHNLZXkpO1xuICAgICAgICAgICAgaWYgKCh0c0tleSA9PT0gJ25hbWUnIHx8IHRzS2V5ID09PSAnY2xhc3NOYW1lJykgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdHNWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBweURpY3RbcHlLZXldID0gdHNWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB5RGljdFtweUtleV0gPSBjb252ZXJ0VHNUb1B5dGhvbmljKHRzVmFsdWUsIHRzS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHlEaWN0O1xuICAgIH1cbn1cbmV4cG9ydHMuY29udmVydFRzVG9QeXRob25pYyA9IGNvbnZlcnRUc1RvUHl0aG9uaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemF0aW9uX3V0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRmYyA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIik7XG52YXIgdGZqc19iYWNrZW5kXzEgPSByZXF1aXJlKFwiLi9iYWNrZW5kL3RmanNfYmFja2VuZFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG52YXIgREVGQVVMVF9WQVJJQUJMRV9OQU1FX1BSRUZJWCA9ICdWYXJpYWJsZSc7XG52YXIgTGF5ZXJWYXJpYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGF5ZXJWYXJpYWJsZSh2YWwsIGR0eXBlLCBuYW1lLCB0cmFpbmFibGUsIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gREVGQVVMVF9WQVJJQUJMRV9OQU1FX1BSRUZJWDsgfVxuICAgICAgICBpZiAodHJhaW5hYmxlID09PSB2b2lkIDApIHsgdHJhaW5hYmxlID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY29uc3RyYWludCA9PT0gdm9pZCAwKSB7IGNvbnN0cmFpbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZHR5cGUgPSBkdHlwZSA9PSBudWxsID8gJ2Zsb2F0MzInIDogZHR5cGU7XG4gICAgICAgIHRoaXMuc2hhcGUgPSB2YWwuc2hhcGU7XG4gICAgICAgIHRoaXMuaWQgPSB0eXBlc18xLmdldE5leHRVbmlxdWVUZW5zb3JJZCgpO1xuICAgICAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gREVGQVVMVF9WQVJJQUJMRV9OQU1FX1BSRUZJWCA6IG5hbWU7XG4gICAgICAgIHRoaXMub3JpZ2luYWxOYW1lID0gY29tbW9uXzEuZ2V0U2NvcGVkVGVuc29yTmFtZShuYW1lKTtcbiAgICAgICAgdGhpcy5uYW1lID0gY29tbW9uXzEuZ2V0VW5pcXVlVGVuc29yTmFtZSh0aGlzLm9yaWdpbmFsTmFtZSk7XG4gICAgICAgIHRoaXMudHJhaW5hYmxlID0gdHJhaW5hYmxlO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xuICAgICAgICB0aGlzLnZhbCA9IHRmYy52YXJpYWJsZSh2YWwsIHRoaXMudHJhaW5hYmxlLCB0aGlzLm5hbWUsIHRoaXMuZHR5cGUpO1xuICAgIH1cbiAgICBMYXllclZhcmlhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWw7XG4gICAgfTtcbiAgICBMYXllclZhcmlhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgY2hlY2tTaGFwZXNNYXRjaCh0aGlzLnZhbCwgbmV3VmFsKTtcbiAgICAgICAgdGhpcy52YWwuYXNzaWduKG5ld1ZhbCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52YWwuYXNzaWduKHRoaXMuY29uc3RyYWludC5hcHBseSh0aGlzLnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIExheWVyVmFyaWFibGU7XG59KCkpO1xuZXhwb3J0cy5MYXllclZhcmlhYmxlID0gTGF5ZXJWYXJpYWJsZTtcbmZ1bmN0aW9uIGNoZWNrU2hhcGVzTWF0Y2goeCwgeSkge1xuICAgIGlmICh4LnNoYXBlLnRvU3RyaW5nKCkgIT09IHkuc2hhcGUudG9TdHJpbmcoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG1pc21hdGNoOiAnICsgSlNPTi5zdHJpbmdpZnkoeC5zaGFwZSkgKyAnIHZzLiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHkuc2hhcGUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YXJpYWJsZSh4LCBkdHlwZSwgbmFtZSwgY29uc3RyYWludCkge1xuICAgIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZSh4LCBkdHlwZSwgbmFtZSwgdHJ1ZSwgY29uc3RyYWludCk7XG59XG5leHBvcnRzLnZhcmlhYmxlID0gdmFyaWFibGU7XG5mdW5jdGlvbiB6ZXJvc1ZhcmlhYmxlKHNoYXBlLCBkdHlwZSwgbmFtZSkge1xuICAgIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZSh0ZmMuemVyb3Moc2hhcGUpLCBkdHlwZSwgbmFtZSk7XG59XG5leHBvcnRzLnplcm9zVmFyaWFibGUgPSB6ZXJvc1ZhcmlhYmxlO1xuZnVuY3Rpb24gemVyb3NMaWtlKHgsIGR0eXBlLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKHRmYy56ZXJvc0xpa2UoeCksIGR0eXBlLCBuYW1lKTtcbn1cbmV4cG9ydHMuemVyb3NMaWtlID0gemVyb3NMaWtlO1xuZnVuY3Rpb24gb25lc1ZhcmlhYmxlKHNoYXBlLCBkdHlwZSwgbmFtZSkge1xuICAgIHZhciBhbGxvY2F0ZWQgPSB0ZmMub25lcyhzaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKGFsbG9jYXRlZCwgZHR5cGUsIG5hbWUpO1xufVxuZXhwb3J0cy5vbmVzVmFyaWFibGUgPSBvbmVzVmFyaWFibGU7XG5mdW5jdGlvbiBvbmVzTGlrZSh4LCBkdHlwZSwgbmFtZSkge1xuICAgIHZhciBhbGxvY2F0ZWQgPSB0ZmMub25lc0xpa2UoeCk7XG4gICAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKGFsbG9jYXRlZCwgZHR5cGUsIG5hbWUpO1xufVxuZXhwb3J0cy5vbmVzTGlrZSA9IG9uZXNMaWtlO1xuZnVuY3Rpb24gZXllVmFyaWFibGUoc2l6ZSwgZHR5cGUsIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IExheWVyVmFyaWFibGUodGZjLmV5ZShzaXplKSwgZHR5cGUsIG5hbWUpO1xufVxuZXhwb3J0cy5leWVWYXJpYWJsZSA9IGV5ZVZhcmlhYmxlO1xuZnVuY3Rpb24gcmFuZG9tVW5pZm9ybVZhcmlhYmxlKHNoYXBlLCBtaW52YWwsIG1heHZhbCwgZHR5cGUsIHNlZWQsIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAncmFuZG9tVW5pZm9ybSc7IH1cbiAgICByZXR1cm4gbmV3IExheWVyVmFyaWFibGUodGZjLnJhbmRvbVVuaWZvcm0oc2hhcGUsIG1pbnZhbCwgbWF4dmFsLCBkdHlwZSksIGR0eXBlLCBuYW1lKTtcbn1cbmV4cG9ydHMucmFuZG9tVW5pZm9ybVZhcmlhYmxlID0gcmFuZG9tVW5pZm9ybVZhcmlhYmxlO1xuZnVuY3Rpb24gdHJ1bmNhdGVkTm9ybWFsVmFyaWFibGUoc2hhcGUsIG1lYW4sIHN0ZGRldiwgZHR5cGUsIHNlZWQsIG5hbWUpIHtcbiAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwLjA7IH1cbiAgICBpZiAoc3RkZGV2ID09PSB2b2lkIDApIHsgc3RkZGV2ID0gMS4wOyB9XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gJ3RydW5jYXRlZE5vcm1hbCc7IH1cbiAgICBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90SW1wbGVtZW50ZWRFcnJvcihcInJhbmRvbU5vcm1hbCBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIGJvb2wuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExheWVyVmFyaWFibGUodGZjLnRydW5jYXRlZE5vcm1hbChzaGFwZSwgbWVhbiwgc3RkZGV2LCBkdHlwZSwgc2VlZCksIGR0eXBlLCBuYW1lKTtcbn1cbmV4cG9ydHMudHJ1bmNhdGVkTm9ybWFsVmFyaWFibGUgPSB0cnVuY2F0ZWROb3JtYWxWYXJpYWJsZTtcbmZ1bmN0aW9uIHJhbmRvbU5vcm1hbFZhcmlhYmxlKHNoYXBlLCBtZWFuLCBzdGRkZXYsIGR0eXBlLCBzZWVkLCBuYW1lKSB7XG4gICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMC4wOyB9XG4gICAgaWYgKHN0ZGRldiA9PT0gdm9pZCAwKSB7IHN0ZGRldiA9IDEuMDsgfVxuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9ICdyYW5kb21Ob3JtYWwnOyB9XG4gICAgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoXCJyYW5kb21Ob3JtYWxWYXJpYWJsZSBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIGJvb2wuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExheWVyVmFyaWFibGUodGZqc19iYWNrZW5kXzEucmFuZG9tTm9ybWFsKHNoYXBlLCBtZWFuLCBzdGRkZXYsIGR0eXBlLCBzZWVkKSwgZHR5cGUsIG5hbWUpO1xufVxuZXhwb3J0cy5yYW5kb21Ob3JtYWxWYXJpYWJsZSA9IHJhbmRvbU5vcm1hbFZhcmlhYmxlO1xuZnVuY3Rpb24gdXBkYXRlKHgsIHhOZXcpIHtcbiAgICByZXR1cm4geC53cml0ZSh4TmV3KTtcbn1cbmV4cG9ydHMudXBkYXRlID0gdXBkYXRlO1xuZnVuY3Rpb24gdXBkYXRlQWRkKHgsIGluY3JlbWVudCkge1xuICAgIHJldHVybiB4LndyaXRlKHRmYy5hZGQoeC5yZWFkKCksIGluY3JlbWVudCkpO1xufVxuZXhwb3J0cy51cGRhdGVBZGQgPSB1cGRhdGVBZGQ7XG5mdW5jdGlvbiB1cGRhdGVTdWIoeCwgZGVjcmVtZW50KSB7XG4gICAgcmV0dXJuIHgud3JpdGUodGZjLnN1Yih4LnJlYWQoKSwgZGVjcmVtZW50KSk7XG59XG5leHBvcnRzLnVwZGF0ZVN1YiA9IHVwZGF0ZVN1YjtcbmZ1bmN0aW9uIGJhdGNoR2V0VmFsdWUoeHMpIHtcbiAgICByZXR1cm4geHMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnJlYWQoKTsgfSk7XG59XG5leHBvcnRzLmJhdGNoR2V0VmFsdWUgPSBiYXRjaEdldFZhbHVlO1xuZnVuY3Rpb24gYmF0Y2hTZXRWYWx1ZSh2YXJpYWJsZXNBbmRWYWx1ZXMpIHtcbiAgICB2YXJpYWJsZXNBbmRWYWx1ZXMubWFwKGZ1bmN0aW9uICh2YXJpYWJsZUFuZFZhbHVlKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZSA9IHZhcmlhYmxlQW5kVmFsdWVbMF07XG4gICAgICAgIHZhcmlhYmxlLndyaXRlKHZhcmlhYmxlQW5kVmFsdWVbMV0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5iYXRjaFNldFZhbHVlID0gYmF0Y2hTZXRWYWx1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhcmlhYmxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2ZXJzaW9uID0gJzAuNi42JztcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIkB0ZW5zb3JmbG93L3RmanMtbGF5ZXJzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlclwiKSk7XG52YXIgdGZqc19jb3JlXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCIpO1xudmFyIHRmanNfbGF5ZXJzXzEgPSByZXF1aXJlKFwiQHRlbnNvcmZsb3cvdGZqcy1sYXllcnNcIik7XG52YXIgdGZqc19jb252ZXJ0ZXJfMSA9IHJlcXVpcmUoXCJAdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlclwiKTtcbnZhciB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuZXhwb3J0cy52ZXJzaW9uID0ge1xuICAgICd0ZmpzLWNvcmUnOiB0ZmpzX2NvcmVfMS52ZXJzaW9uX2NvcmUsXG4gICAgJ3RmanMtbGF5ZXJzJzogdGZqc19sYXllcnNfMS52ZXJzaW9uX2xheWVycyxcbiAgICAndGZqcy1jb252ZXJ0ZXInOiB0ZmpzX2NvbnZlcnRlcl8xLnZlcnNpb25fY29udmVydGVyLFxuICAgICd0ZmpzJzogdmVyc2lvbl8xLnZlcnNpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBtaW5pbWFsIGxpYnJhcnkgZW50cnkgcG9pbnQuXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXgtbWluaW1hbFwiKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXHJcbiAqIEBuYW1lIGJ1aWxkXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxucHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcclxuXHJcbi8vIFNlcmlhbGl6YXRpb25cclxucHJvdG9idWYuV3JpdGVyICAgICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xyXG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xyXG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XHJcbnByb3RvYnVmLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlcl9idWZmZXJcIik7XHJcblxyXG4vLyBVdGlsaXR5XHJcbnByb3RvYnVmLnV0aWwgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xyXG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcclxucHJvdG9idWYuY29uZmlndXJlICAgID0gY29uZmlndXJlO1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuLyoqXHJcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuZnVuY3Rpb24gY29uZmlndXJlKCkge1xyXG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcclxuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xyXG59XHJcblxyXG4vLyBDb25maWd1cmUgc2VyaWFsaXphdGlvblxyXG5wcm90b2J1Zi5Xcml0ZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJXcml0ZXIpO1xyXG5jb25maWd1cmUoKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xyXG5cclxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xyXG5cclxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXHJcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xyXG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXHJcbiAqL1xyXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGJ1ZmZlci5cclxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3MgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xyXG59XHJcblxyXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcclxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcclxuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcclxuICAgIH07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyByZWFkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxyXG4gKiBAcmV0dXJucyB7UmVhZGVyfEJ1ZmZlclJlYWRlcn0gQSB7QGxpbmsgQnVmZmVyUmVhZGVyfSBpZiBgYnVmZmVyYCBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGEge0BsaW5rIFJlYWRlcn1cclxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxyXG4gKi9cclxuUmVhZGVyLmNyZWF0ZSA9IHV0aWwuQnVmZmVyXHJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcclxuICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcclxuICAgICAgICB9KShidWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogY3JlYXRlX2FycmF5O1xyXG5cclxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IChmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcclxuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XHJcbiAgICAgICAgdmFsdWUgPSAoICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3NdICYgMTI3ICAgICAgICkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XHJcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcclxuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xyXG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcclxuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XHJcbn07XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cclxuXHJcbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xyXG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXHJcbiAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcclxuICAgIHZhciBpID0gMDtcclxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcclxuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xyXG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxyXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA1dGhcclxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XHJcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xyXG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXHJcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDR0aFxyXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xyXG4gICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxyXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxyXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxyXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcclxufVxyXG5cclxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXHJcbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxyXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxyXG4gKiBAbmFtZSBSZWFkZXIjc2ludDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIGJvb2xlYW4uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcclxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXHJcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAzXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG4vKipcclxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcclxuXHJcbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XHJcblxyXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xyXG59O1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXHJcblxyXG5mdW5jdGlvbiByZWFkRml4ZWQ2NCgvKiB0aGlzOiBSZWFkZXIgKi8pIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcclxufVxyXG5cclxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBmaXhlZCA2NCBiaXRzLlxyXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXHJcbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcclxuXHJcbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XHJcbiAgICB0aGlzLnBvcyArPSA0O1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpIGFzIGEgbnVtYmVyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XHJcblxyXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcclxuICAgIHRoaXMucG9zICs9IDg7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xyXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXHJcbiAgICAgICAgc3RhcnQgID0gdGhpcy5wb3MsXHJcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XHJcblxyXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcclxuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXHJcbiAgICAgICAgPyBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMClcclxuICAgICAgICA6IHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XHJcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XHJcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxyXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XHJcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxyXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcclxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcclxuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXHJcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIGRvIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cclxuICAgICAgICAgICAgICAgIGlmICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgPT09IDQpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xyXG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcclxuXHJcbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xyXG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XHJcblxyXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XHJcblxyXG4vLyBleHRlbmRzIFJlYWRlclxyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xyXG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXHJcbiAqIEBleHRlbmRzIFJlYWRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXHJcbiAqL1xyXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XHJcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBidWZmZXIuXHJcbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXHJcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxyXG4gICAgICovXHJcbn1cclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbmlmICh1dGlsLkJ1ZmZlcilcclxuICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XHJcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXHJcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXHJcbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0ge307XHJcblxyXG4vKipcclxuICogTmFtZWQgcm9vdHMuXHJcbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxyXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjY3Jvc3MgbW9kdWxlcy5cclxuICogQG5hbWUgcm9vdHNcclxuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cclxuICpcclxuICogLy8gaW4gYW5vdGhlciBtb2R1bGU6XHJcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xyXG4gKlxyXG4gKiAvLyBpbiBhbnkgc3Vic2VxdWVudCBtb2R1bGU6XHJcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XHJcbiAqL1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBycGMgPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cclxuICogQHR5cGVkZWYgUlBDSW1wbFxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxyXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQGV4YW1wbGVcclxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xyXG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXHJcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcclxuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xyXG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcclxuICogICAgIH0pO1xyXG4gKiB9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXHJcbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XHJcblxyXG4vKipcclxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cclxuICpcclxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXHJcbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcclxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XHJcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxyXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxyXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cclxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxyXG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cclxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcclxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcclxuICovXHJcbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuXHJcbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxyXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cclxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXHJcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcclxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxyXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cclxuICovXHJcblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHJcbiAgICBpZiAoIXJlcXVlc3QpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBpZiAoIWNhbGxiYWNrKVxyXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xyXG5cclxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXHJcbiAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcclxuICovXHJcblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XHJcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XHJcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcclxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cclxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcclxuXHJcbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxyXG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb3cgYml0cy5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZ2ggYml0cy5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFplcm8gYml0cy5cclxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcclxuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XHJcbiAqL1xyXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XHJcblxyXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xyXG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcclxuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XHJcblxyXG4vKipcclxuICogWmVybyBoYXNoLlxyXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcclxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXHJcbiAqL1xyXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSAwKVxyXG4gICAgICAgIHJldHVybiB6ZXJvO1xyXG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XHJcbiAgICBpZiAoc2lnbilcclxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcclxuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxyXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcclxuICAgIGlmIChzaWduKSB7XHJcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XHJcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XHJcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XHJcbiAgICAgICAgICAgIGxvID0gMDtcclxuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxyXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcclxuICovXHJcbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKHV0aWwuTG9uZylcclxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cclxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XHJcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxyXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcclxuICAgICAgICBpZiAoIWxvKVxyXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcclxuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cclxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gdXRpbC5Mb25nXHJcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xyXG59O1xyXG5cclxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXHJcbiAqL1xyXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcclxuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcclxuICAgICAgICByZXR1cm4gemVybztcclxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXHJcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcclxuICAgICxcclxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxyXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxyXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcclxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcclxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcclxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcclxuICAgICAgICB0aGlzLmhpID4+PiAyNFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xyXG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XHJcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XHJcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcclxuICovXHJcbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xyXG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcclxuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcclxuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cclxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xyXG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXHJcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxyXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xyXG4gICAgcmV0dXJuIHBhcnQyID09PSAwXHJcbiAgICAgICAgID8gcGFydDEgPT09IDBcclxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcclxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxyXG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxyXG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XHJcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XHJcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgdXRpbCA9IGV4cG9ydHM7XHJcblxyXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxyXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XHJcblxyXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xyXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XHJcblxyXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXHJcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcclxuXHJcbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcclxudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcclxuXHJcbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xyXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcclxuXHJcbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xyXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcclxuXHJcbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXHJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xyXG5cclxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXHJcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHR5cGUge0FycmF5LjwqPn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXHJcblxyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cclxuICogQHR5cGUge09iamVjdH1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAY29uc3RcclxuICovXHJcbnV0aWwuaXNOb2RlID0gQm9vbGVhbihnbG9iYWwucHJvY2VzcyAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucyAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxyXG4gKi9cclxudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xyXG4gKi9cclxudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxyXG4gKi9cclxudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXHJcbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gKi9cclxudXRpbC5pc3NldCA9XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gKi9cclxudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xyXG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxyXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cclxuICogQGludGVyZmFjZSBCdWZmZXJcclxuICogQGV4dGVuZHMgVWludDhBcnJheVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cclxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XHJcbiAqL1xyXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XHJcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxyXG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufSkoKTtcclxuXHJcbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cclxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xyXG5cclxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cclxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXHJcbiAqL1xyXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcclxuICAgICAgICA/IHV0aWwuQnVmZmVyXHJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxyXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxyXG4gICAgICAgIDogdXRpbC5CdWZmZXJcclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcclxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxyXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxyXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXHJcbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cclxuICovXHJcbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcclxuXHJcbi8qKlxyXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxyXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cclxuICogQGludGVyZmFjZSBMb25nXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcclxuICovXHJcblxyXG4vKipcclxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxyXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XHJcbiAqL1xyXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBnbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBnbG9iYWwuZGNvZGVJTy5Mb25nIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XHJcblxyXG4vKipcclxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxyXG4gKiBAdHlwZSB7UmVnRXhwfVxyXG4gKiBAY29uc3RcclxuICovXHJcbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xyXG5cclxuLyoqXHJcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXHJcbiAqIEB0eXBlIHtSZWdFeHB9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XHJcblxyXG4vKipcclxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cclxuICogQHR5cGUge1JlZ0V4cH1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cclxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXHJcbiAqL1xyXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWVcclxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcclxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcclxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxyXG4gKi9cclxudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcclxuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcclxuICAgIGlmICh1dGlsLkxvbmcpXHJcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XHJcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcclxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcclxuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcclxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG5cclxudXRpbC5tZXJnZSA9IG1lcmdlO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXHJcbiAqL1xyXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxyXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XHJcblxyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XHJcblxyXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiAobmV3IEVycm9yKCkpLnN0YWNrIHx8IFwiXCIgfSk7XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxuXHJcbiAgICAoQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEN1c3RvbUVycm9yO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9IH0pO1xyXG5cclxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcclxufVxyXG5cclxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXHJcbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBleHRlbmRzIEVycm9yXHJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXHJcbiAqIEBleGFtcGxlXHJcbiAqIHRyeSB7XHJcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAqIH0gY2F0Y2ggKGUpIHtcclxuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxyXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xyXG4gKiB9XHJcbiAqL1xyXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XHJcblxyXG4vKipcclxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cclxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXHJcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXHJcbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcclxuICovXHJcblxyXG4vKipcclxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxyXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXHJcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcclxuICovXHJcbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XHJcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcclxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxyXG4gICAgICogQHRoaXMgT2JqZWN0XHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxyXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXHJcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXHJcbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xyXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXHJcbiAqL1xyXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAqIEB0aGlzIE9iamVjdFxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxyXG4gKlxyXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXHJcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXHJcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcclxuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xyXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcclxuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xyXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXHJcbiAqXHJcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXHJcbiAqL1xyXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XHJcbiAgICBsb25nczogU3RyaW5nLFxyXG4gICAgZW51bXM6IFN0cmluZyxcclxuICAgIGJ5dGVzOiBTdHJpbmcsXHJcbiAgICBqc29uOiB0cnVlXHJcbn07XHJcblxyXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFCdWZmZXIpIHtcclxuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcclxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcclxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XHJcbiAgICAgICAgfTtcclxuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XHJcbiAgICAgICAgfTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xyXG5cclxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xyXG5cclxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXHJcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcclxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxyXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5mbiA9IGZuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IGxlbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxyXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxyXG4gICAgICogQHR5cGUgeyp9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xyXG59XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXHJcbiAqIEBtZW1iZXJvZiBXcml0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgaGVhZC5cclxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCB0YWlsLlxyXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZXh0IHN0YXRlLlxyXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gV3JpdGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxyXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XHJcblxyXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxyXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcclxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcclxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcclxuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxyXG4gKi9cclxuV3JpdGVyLmNyZWF0ZSA9IHV0aWwuQnVmZmVyXHJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XHJcbiAgICB9O1xyXG5cclxuLyoqXHJcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcclxuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcclxufTtcclxuXHJcbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXHJcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XHJcblxyXG4vKipcclxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcclxuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XHJcbiAgICB0aGlzLmxlbiArPSBsZW47XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XHJcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcclxuICAgICAgICB2YWwgPj4+PSA3O1xyXG4gICAgfVxyXG4gICAgYnVmW3Bvc10gPSB2YWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cclxuICogQGV4dGVuZHMgT3BcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xyXG4gICAgdGhpcy5sZW4gPSBsZW47XHJcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnZhbCA9IHZhbDtcclxufVxyXG5cclxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xyXG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XHJcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cclxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXHJcbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXHJcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXHJcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcclxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXHJcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcclxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcclxuICAgIHZhbHVlKSkubGVuO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlIDwgMFxyXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXHJcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICB3aGlsZSAodmFsLmhpKSB7XHJcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcclxuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcclxuICAgICAgICB2YWwuaGkgPj4+PSA3O1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xyXG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XHJcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xyXG4gICAgfVxyXG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcclxufVxyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XHJcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XHJcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcclxuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XHJcbn07XHJcblxyXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxyXG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XHJcbiAgICB9O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XHJcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xyXG4gICAgaWYgKCFsZW4pXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcclxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xyXG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XHJcbiAgICAgICAgdmFsdWUgPSBidWY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XHJcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xyXG4gICAgcmV0dXJuIGxlblxyXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxyXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxyXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XHJcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcclxuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcclxuICAgIHRoaXMubGVuID0gMDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgIGlmICh0aGlzLnN0YXRlcykge1xyXG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcclxuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XHJcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xyXG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXHJcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcclxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XHJcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XHJcbiAgICBpZiAobGVuKSB7XHJcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxyXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XHJcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XHJcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcclxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXHJcbiAgICAgICAgcG9zICA9IDA7XHJcbiAgICB3aGlsZSAoaGVhZCkge1xyXG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcclxuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XHJcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcclxuICAgIH1cclxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICByZXR1cm4gYnVmO1xyXG59O1xyXG5cclxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XHJcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XHJcblxyXG4vLyBleHRlbmRzIFdyaXRlclxyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xyXG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XHJcblxyXG52YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXHJcbiAqIEBleHRlbmRzIFdyaXRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcclxuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXHJcbiAqL1xyXG5CdWZmZXJXcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvY19idWZmZXIoc2l6ZSkge1xyXG4gICAgcmV0dXJuIChCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUpKHNpemUpO1xyXG59O1xyXG5cclxudmFyIHdyaXRlQnl0ZXNCdWZmZXIgPSBCdWZmZXIgJiYgQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxyXG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGZhc3RlciB0aGFuIGNvcHkgKHJlcXVpcmVzIG5vZGUgPj0gNCB3aGVyZSBCdWZmZXJzIGV4dGVuZCBVaW50OEFycmF5IGFuZCBzZXQgaXMgcHJvcGVybHkgaW5oZXJpdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXHJcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDspIC8vIHBsYWluIGFycmF5IHZhbHVlc1xyXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XHJcbiAgICB9O1xyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xyXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxyXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xyXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcclxuICAgIHRoaXMudWludDMyKGxlbik7XHJcbiAgICBpZiAobGVuKVxyXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxyXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcclxuICAgIGVsc2VcclxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XHJcbiAgICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xyXG4gICAgdGhpcy51aW50MzIobGVuKTtcclxuICAgIGlmIChsZW4pXHJcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cclxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXHJcbiAqL1xyXG4iLCIvLyBBIGxpYnJhcnkgb2Ygc2VlZGFibGUgUk5HcyBpbXBsZW1lbnRlZCBpbiBKYXZhc2NyaXB0LlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciBzZWVkcmFuZG9tID0gcmVxdWlyZSgnc2VlZHJhbmRvbScpO1xuLy8gdmFyIHJhbmRvbSA9IHNlZWRyYW5kb20oMSk7IC8vIG9yIGFueSBzZWVkLlxuLy8gdmFyIHggPSByYW5kb20oKTsgICAgICAgLy8gMCA8PSB4IDwgMS4gIEV2ZXJ5IGJpdCBpcyByYW5kb20uXG4vLyB2YXIgeCA9IHJhbmRvbS5xdWljaygpOyAvLyAwIDw9IHggPCAxLiAgMzIgYml0cyBvZiByYW5kb21uZXNzLlxuXG4vLyBhbGVhLCBhIDUzLWJpdCBtdWx0aXBseS13aXRoLWNhcnJ5IGdlbmVyYXRvciBieSBKb2hhbm5lcyBCYWFnw7hlLlxuLy8gUGVyaW9kOiB+Ml4xMTZcbi8vIFJlcG9ydGVkIHRvIHBhc3MgYWxsIEJpZ0NydXNoIHRlc3RzLlxudmFyIGFsZWEgPSByZXF1aXJlKCcuL2xpYi9hbGVhJyk7XG5cbi8vIHhvcjEyOCwgYSBwdXJlIHhvci1zaGlmdCBnZW5lcmF0b3IgYnkgR2VvcmdlIE1hcnNhZ2xpYS5cbi8vIFBlcmlvZDogMl4xMjgtMS5cbi8vIFJlcG9ydGVkIHRvIGZhaWw6IE1hdHJpeFJhbmsgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yMTI4ID0gcmVxdWlyZSgnLi9saWIveG9yMTI4Jyk7XG5cbi8vIHhvcndvdywgR2VvcmdlIE1hcnNhZ2xpYSdzIDE2MC1iaXQgeG9yLXNoaWZ0IGNvbWJpbmVkIHBsdXMgd2V5bC5cbi8vIFBlcmlvZDogMl4xOTItMl4zMlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogQ29sbGlzaW9uT3ZlciwgU2ltcFBva2VyLCBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3J3b3cgPSByZXF1aXJlKCcuL2xpYi94b3J3b3cnKTtcblxuLy8geG9yc2hpZnQ3LCBieSBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllciwgdGFrZXNcbi8vIGEgZGlmZmVyZW50IGFwcHJvYWNoOiBpdCBhZGRzIHJvYnVzdG5lc3MgYnkgYWxsb3dpbmcgbW9yZSBzaGlmdHNcbi8vIHRoYW4gTWFyc2FnbGlhJ3Mgb3JpZ2luYWwgdGhyZWUuICBJdCBpcyBhIDctc2hpZnQgZ2VuZXJhdG9yXG4vLyB3aXRoIDI1NiBiaXRzLCB0aGF0IHBhc3NlcyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RtYXRpYyBmYWlsdXJlcy5cbi8vIFBlcmlvZCAyXjI1Ni0xLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3JzaGlmdDcgPSByZXF1aXJlKCcuL2xpYi94b3JzaGlmdDcnKTtcblxuLy8geG9yNDA5NiwgYnkgUmljaGFyZCBCcmVudCwgaXMgYSA0MDk2LWJpdCB4b3Itc2hpZnQgd2l0aCBhXG4vLyB2ZXJ5IGxvbmcgcGVyaW9kIHRoYXQgYWxzbyBhZGRzIGEgV2V5bCBnZW5lcmF0b3IuIEl0IGFsc28gcGFzc2VzXG4vLyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RlbWF0aWMgZmFpbHVyZXMuICBJdHMgbG9uZyBwZXJpb2QgbWF5XG4vLyBiZSB1c2VmdWwgaWYgeW91IGhhdmUgbWFueSBnZW5lcmF0b3JzIGFuZCBuZWVkIHRvIGF2b2lkXG4vLyBjb2xsaXNpb25zLlxuLy8gUGVyaW9kOiAyXjQxMjgtMl4zMi5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yNDA5NiA9IHJlcXVpcmUoJy4vbGliL3hvcjQwOTYnKTtcblxuLy8gVHljaGUtaSwgYnkgU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLCBpcyBhIGJpdC1zaGlmdGluZyByYW5kb21cbi8vIG51bWJlciBnZW5lcmF0b3IgZGVyaXZlZCBmcm9tIENoYUNoYSwgYSBtb2Rlcm4gc3RyZWFtIGNpcGhlci5cbi8vIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG4vLyBQZXJpb2Q6IH4yXjEyN1xuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB0eWNoZWkgPSByZXF1aXJlKCcuL2xpYi90eWNoZWknKTtcblxuLy8gVGhlIG9yaWdpbmFsIEFSQzQtYmFzZWQgcHJuZyBpbmNsdWRlZCBpbiB0aGlzIGxpYnJhcnkuXG4vLyBQZXJpb2Q6IH4yXjE2MDBcbnZhciBzciA9IHJlcXVpcmUoJy4vc2VlZHJhbmRvbScpO1xuXG5zci5hbGVhID0gYWxlYTtcbnNyLnhvcjEyOCA9IHhvcjEyODtcbnNyLnhvcndvdyA9IHhvcndvdztcbnNyLnhvcnNoaWZ0NyA9IHhvcnNoaWZ0NztcbnNyLnhvcjQwOTYgPSB4b3I0MDk2O1xuc3IudHljaGVpID0gdHljaGVpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNyO1xuIiwiLy8gQSBwb3J0IG9mIGFuIGFsZ29yaXRobSBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucXVpbmxhbi9iZXR0ZXItcmFuZG9tLW51bWJlcnMtZm9yLWphdmFzY3JpcHQtbWlycm9yXG4vLyBPcmlnaW5hbCB3b3JrIGlzIHVuZGVyIE1JVCBsaWNlbnNlIC1cblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2Uub3JnPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIEFsZWEoc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBtYXNoID0gTWFzaCgpO1xuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBtZS5zMCArIG1lLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIG1lLnMwID0gbWUuczE7XG4gICAgbWUuczEgPSBtZS5zMjtcbiAgICByZXR1cm4gbWUuczIgPSB0IC0gKG1lLmMgPSB0IHwgMCk7XG4gIH07XG5cbiAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICBtZS5jID0gMTtcbiAgbWUuczAgPSBtYXNoKCcgJyk7XG4gIG1lLnMxID0gbWFzaCgnICcpO1xuICBtZS5zMiA9IG1hc2goJyAnKTtcbiAgbWUuczAgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMwIDwgMCkgeyBtZS5zMCArPSAxOyB9XG4gIG1lLnMxIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMSA8IDApIHsgbWUuczEgKz0gMTsgfVxuICBtZS5zMiAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczIgPCAwKSB7IG1lLnMyICs9IDE7IH1cbiAgbWFzaCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmMgPSBmLmM7XG4gIHQuczAgPSBmLnMwO1xuICB0LnMxID0gZi5zMTtcbiAgdC5zMiA9IGYuczI7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IEFsZWEoc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSB4Zy5uZXh0O1xuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpICogMHgxMDAwMDAwMDApIHwgMDsgfVxuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm5nKCkgKyAocHJuZygpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7IC8vIDJeLTUzXG4gIH07XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgdmFyIG1hc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcblxuICByZXR1cm4gbWFzaDtcbn1cblxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLmFsZWEgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3JzaGlmdDdcIiBhbGdvcml0aG0gYnlcbi8vIEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyOlxuLy8gXCJPbiB0aGUgWG9yZ3NoaWZ0IFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yc1wiXG4vLyBodHRwOi8vc2FsdWMuZW5nci51Y29ubi5lZHUvcmVmcy9jcnlwdG8vcm5nL3Bhbm5ldG9uMDVvbnRoZXhvcnNoaWZ0LnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2YXIgWCA9IG1lLngsIGkgPSBtZS5pLCB0LCB2LCB3O1xuICAgIHQgPSBYW2ldOyB0IF49ICh0ID4+PiA3KTsgdiA9IHQgXiAodCA8PCAyNCk7XG4gICAgdCA9IFhbKGkgKyAxKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMTApO1xuICAgIHQgPSBYWyhpICsgMykgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDMpO1xuICAgIHQgPSBYWyhpICsgNCkgJiA3XTsgdiBePSB0IF4gKHQgPDwgNyk7XG4gICAgdCA9IFhbKGkgKyA3KSAmIDddOyB0ID0gdCBeICh0IDw8IDEzKTsgdiBePSB0IF4gKHQgPDwgOSk7XG4gICAgWFtpXSA9IHY7XG4gICAgbWUuaSA9IChpICsgMSkgJiA3O1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgaiwgdywgWCA9IFtdO1xuXG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgYXJyYXkgdXNpbmcgYSAzMi1iaXQgaW50ZWdlci5cbiAgICAgIHcgPSBYWzBdID0gc2VlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlZCBzdGF0ZSB1c2luZyBhIHN0cmluZy5cbiAgICAgIHNlZWQgPSAnJyArIHNlZWQ7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc2VlZC5sZW5ndGg7ICsraikge1xuICAgICAgICBYW2ogJiA3XSA9IChYW2ogJiA3XSA8PCAxNSkgXlxuICAgICAgICAgICAgKHNlZWQuY2hhckNvZGVBdChqKSArIFhbKGogKyAxKSAmIDddIDw8IDEzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5mb3JjZSBhbiBhcnJheSBsZW5ndGggb2YgOCwgbm90IGFsbCB6ZXJvZXMuXG4gICAgd2hpbGUgKFgubGVuZ3RoIDwgOCkgWC5wdXNoKDApO1xuICAgIGZvciAoaiA9IDA7IGogPCA4ICYmIFhbal0gPT09IDA7ICsraik7XG4gICAgaWYgKGogPT0gOCkgdyA9IFhbN10gPSAtMTsgZWxzZSB3ID0gWFtqXTtcblxuICAgIG1lLnggPSBYO1xuICAgIG1lLmkgPSAwO1xuXG4gICAgLy8gRGlzY2FyZCBhbiBpbml0aWFsIDI1NiB2YWx1ZXMuXG4gICAgZm9yIChqID0gMjU2OyBqID4gMDsgLS1qKSB7XG4gICAgICBtZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLnguc2xpY2UoKTtcbiAgdC5pID0gZi5pO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUueCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcnNoaWZ0NyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcndvd1wiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAobWUueCBeIChtZS54ID4+PiAyKSk7XG4gICAgbWUueCA9IG1lLnk7IG1lLnkgPSBtZS56OyBtZS56ID0gbWUudzsgbWUudyA9IG1lLnY7XG4gICAgcmV0dXJuIChtZS5kID0gKG1lLmQgKyAzNjI0MzcgfCAwKSkgK1xuICAgICAgIChtZS52ID0gKG1lLnYgXiAobWUudiA8PCA0KSkgXiAodCBeICh0IDw8IDEpKSkgfCAwO1xuICB9O1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuICBtZS52ID0gMDtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgaWYgKGsgPT0gc3Ryc2VlZC5sZW5ndGgpIHtcbiAgICAgIG1lLmQgPSBtZS54IDw8IDEwIF4gbWUueCA+Pj4gNDtcbiAgICB9XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHQudiA9IGYudjtcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3J3b3cgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAocG9vbCwgbWF0aCkge1xuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG52YXIgZ2xvYmFsID0gdGhpcyxcbiAgICB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cbiAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXG4gICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgbWFzayA9IHdpZHRoIC0gMSxcbiAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xuZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIga2V5ID0gW107XG4gIG9wdGlvbnMgPSAob3B0aW9ucyA9PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgb3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6XG4gICAgKHNlZWQgPT0gbnVsbCkgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG4gIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XG4gICAgICAgIGQgPSBzdGFydGRlbm9tLCAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cbiAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcbiAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgIH1cbiAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcbiAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgIH1cbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgfTtcblxuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgfCAwOyB9XG4gIHBybmcucXVpY2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSAvIDB4MTAwMDAwMDAwOyB9XG4gIHBybmcuZG91YmxlID0gcHJuZztcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XG5cbiAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXG4gIHJldHVybiAob3B0aW9ucy5wYXNzIHx8IGNhbGxiYWNrIHx8XG4gICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIExvYWQgdGhlIGFyYzQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgaWYgaXQgaGFzIGFuIFMgYXJyYXkuXG4gICAgICAgICAgaWYgKHN0YXRlLlMpIHsgY29weShzdGF0ZSwgYXJjNCk7IH1cbiAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoYXJjNCwge30pOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cbiAgICAgICAgaWYgKGlzX21hdGhfY2FsbCkgeyBtYXRoW3JuZ25hbWVdID0gcHJuZzsgcmV0dXJuIHNlZWQ7IH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShcbiAgcHJuZyxcbiAgc2hvcnRzZWVkLFxuICAnZ2xvYmFsJyBpbiBvcHRpb25zID8gb3B0aW9ucy5nbG9iYWwgOiAodGhpcyA9PSBtYXRoKSxcbiAgb3B0aW9ucy5zdGF0ZSk7XG59XG5tYXRoWydzZWVkJyArIHJuZ25hbWVdID0gc2VlZHJhbmRvbTtcblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG91dDtcbiAgICBpZiAobm9kZWNyeXB0byAmJiAob3V0ID0gbm9kZWNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgJ291dCcgdG8gcmVtZW1iZXIgcmFuZG9tQnl0ZXMgbWFrZXMgdGlnaHQgbWluaWZpZWQgY29kZS5cbiAgICAgIG91dCA9IG91dCh3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgfVxuICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xuICB9XG59XG5cbi8vXG4vLyB0b3N0cmluZygpXG4vLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xufVxuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vL1xuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xuLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4vL1xuaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlZWRyYW5kb207XG4gIC8vIFdoZW4gaW4gbm9kZS5qcywgdHJ5IHVzaW5nIGNyeXB0byBwYWNrYWdlIGZvciBhdXRvc2VlZGluZy5cbiAgdHJ5IHtcbiAgICBub2RlY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIH0gY2F0Y2ggKGV4KSB7fVxufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNlZWRyYW5kb207IH0pO1xufVxuXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbn0pKFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIiwiIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIl19
